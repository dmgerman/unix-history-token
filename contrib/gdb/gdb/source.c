begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* List lines of source files for GDB, the GNU debugger.    Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,    1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"source.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"gdb_regex.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"annotate.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"linespec.h"
end_include

begin_include
include|#
directive|include
file|"filenames.h"
end_include

begin_comment
comment|/* for DOSish file names */
end_comment

begin_include
include|#
directive|include
file|"completer.h"
end_include

begin_include
include|#
directive|include
file|"ui-out.h"
end_include

begin_include
include|#
directive|include
file|"readline/readline.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CRLF_SOURCE_FILES
end_ifdef

begin_comment
comment|/* Define CRLF_SOURCE_FILES in an xm-*.h file if source files on the    host use \r\n rather than just \n.  Defining CRLF_SOURCE_FILES is    much faster than defining LSEEK_NOT_LINEAR.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|O_BINARY
end_ifndef

begin_define
define|#
directive|define
name|O_BINARY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|OPEN_MODE
value|(O_RDONLY | O_BINARY)
end_define

begin_define
define|#
directive|define
name|FDOPEN_MODE
value|FOPEN_RB
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! defined (CRLF_SOURCE_FILES) */
end_comment

begin_define
define|#
directive|define
name|OPEN_MODE
value|O_RDONLY
end_define

begin_define
define|#
directive|define
name|FDOPEN_MODE
value|FOPEN_RT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! defined (CRLF_SOURCE_FILES) */
end_comment

begin_comment
comment|/* Prototypes for exported functions. */
end_comment

begin_function_decl
name|void
name|_initialize_source
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Prototypes for local functions. */
end_comment

begin_function_decl
specifier|static
name|int
name|get_filename_and_charpos
parameter_list|(
name|struct
name|symtab
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reverse_search_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|forward_search_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|line_info
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|source_info
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|show_directories
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Path of directories to search for source files.    Same format as the PATH environment variable's value.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|source_path
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Symtab of default file for listing lines of.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|symtab
modifier|*
name|current_source_symtab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default next line to list.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|current_source_line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default number of lines to print with commands like "list".    This is based on guessing how many long (i.e. more than chars_per_line    characters) lines there will be.  To be completely correct, "list"    and friends should be rewritten to count characters and see where    things are wrapping, but that would be a fair amount of work.  */
end_comment

begin_decl_stmt
name|int
name|lines_to_list
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Line number of last line printed.  Default for various commands.    current_source_line is usually, but not always, the same as this.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_line_listed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First line number listed by last listing command.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|first_line_listed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Saves the name of the last source file visited and a possible error code.    Used to prevent repeating annoying "No such file or directories" msgs */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|symtab
modifier|*
name|last_source_visited
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|last_source_error
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Return the first line listed by print_source_lines.    Used by command interpreters to request listing from    a previous point. */
end_comment

begin_function
name|int
name|get_first_line_listed
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|first_line_listed
return|;
block|}
end_function

begin_comment
comment|/* Return the default number of lines to print with commands like the    cli "list".  The caller of print_source_lines must use this to    calculate the end line and use it in the call to print_source_lines    as it does not automatically use this value. */
end_comment

begin_function
name|int
name|get_lines_to_list
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|lines_to_list
return|;
block|}
end_function

begin_comment
comment|/* Return the current source file for listing and next line to list.    NOTE: The returned sal pc and end fields are not valid. */
end_comment

begin_function
name|struct
name|symtab_and_line
name|get_current_source_symtab_and_line
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|symtab_and_line
name|cursal
decl_stmt|;
name|cursal
operator|.
name|symtab
operator|=
name|current_source_symtab
expr_stmt|;
name|cursal
operator|.
name|line
operator|=
name|current_source_line
expr_stmt|;
name|cursal
operator|.
name|pc
operator|=
literal|0
expr_stmt|;
name|cursal
operator|.
name|end
operator|=
literal|0
expr_stmt|;
return|return
name|cursal
return|;
block|}
end_function

begin_comment
comment|/* If the current source file for listing is not set, try and get a default.    Usually called before get_current_source_symtab_and_line() is called.    It may err out if a default cannot be determined.    We must be cautious about where it is called, as it can recurse as the    process of determining a new default may call the caller!    Use get_current_source_symtab_and_line only to get whatever    we have without erroring out or trying to get a default. */
end_comment

begin_function
name|void
name|set_default_source_symtab_and_line
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|symtab_and_line
name|cursal
decl_stmt|;
if|if
condition|(
operator|!
name|have_full_symbols
argument_list|()
operator|&&
operator|!
name|have_partial_symbols
argument_list|()
condition|)
name|error
argument_list|(
literal|"No symbol table is loaded.  Use the \"file\" command."
argument_list|)
expr_stmt|;
comment|/* Pull in a current source symtab if necessary */
if|if
condition|(
name|current_source_symtab
operator|==
literal|0
condition|)
name|select_source_symtab
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the current default file for listing and next line to list    (the returned sal pc and end fields are not valid.)    and set the current default to whatever is in SAL.    NOTE: The returned sal pc and end fields are not valid. */
end_comment

begin_function
name|struct
name|symtab_and_line
name|set_current_source_symtab_and_line
parameter_list|(
specifier|const
name|struct
name|symtab_and_line
modifier|*
name|sal
parameter_list|)
block|{
name|struct
name|symtab_and_line
name|cursal
decl_stmt|;
name|cursal
operator|.
name|symtab
operator|=
name|current_source_symtab
expr_stmt|;
name|cursal
operator|.
name|line
operator|=
name|current_source_line
expr_stmt|;
name|current_source_symtab
operator|=
name|sal
operator|->
name|symtab
expr_stmt|;
name|current_source_line
operator|=
name|sal
operator|->
name|line
expr_stmt|;
name|cursal
operator|.
name|pc
operator|=
literal|0
expr_stmt|;
name|cursal
operator|.
name|end
operator|=
literal|0
expr_stmt|;
return|return
name|cursal
return|;
block|}
end_function

begin_comment
comment|/* Reset any information stored about a default file and line to print. */
end_comment

begin_function
name|void
name|clear_current_source_symtab_and_line
parameter_list|(
name|void
parameter_list|)
block|{
name|current_source_symtab
operator|=
literal|0
expr_stmt|;
name|current_source_line
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the source file default for the "list" command to be S.     If S is NULL, and we don't have a default, find one.  This    should only be called when the user actually tries to use the    default, since we produce an error if we can't find a reasonable    default.  Also, since this can cause symbols to be read, doing it    before we need to would make things slower than necessary.  */
end_comment

begin_function
name|void
name|select_source_symtab
parameter_list|(
name|struct
name|symtab
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
name|ps
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
name|cs_pst
init|=
literal|0
decl_stmt|;
name|struct
name|objfile
modifier|*
name|ofp
decl_stmt|;
if|if
condition|(
name|s
condition|)
block|{
name|current_source_symtab
operator|=
name|s
expr_stmt|;
name|current_source_line
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|current_source_symtab
condition|)
return|return;
comment|/* Make the default place to list be the function `main'      if one exists.  */
if|if
condition|(
name|lookup_symbol
argument_list|(
name|main_name
argument_list|()
argument_list|,
literal|0
argument_list|,
name|VAR_DOMAIN
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|sals
operator|=
name|decode_line_spec
argument_list|(
name|main_name
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sal
operator|=
name|sals
operator|.
name|sals
index|[
literal|0
index|]
expr_stmt|;
name|xfree
argument_list|(
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
name|current_source_symtab
operator|=
name|sal
operator|.
name|symtab
expr_stmt|;
name|current_source_line
operator|=
name|max
argument_list|(
name|sal
operator|.
name|line
operator|-
operator|(
name|lines_to_list
operator|-
literal|1
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_source_symtab
condition|)
return|return;
block|}
comment|/* All right; find the last file in the symtab list (ignoring .h's).  */
name|current_source_line
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|ofp
operator|=
name|object_files
init|;
name|ofp
operator|!=
name|NULL
condition|;
name|ofp
operator|=
name|ofp
operator|->
name|next
control|)
block|{
for|for
control|(
name|s
operator|=
name|ofp
operator|->
name|symtabs
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|char
modifier|*
name|name
init|=
name|s
operator|->
name|filename
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|len
operator|>
literal|2
operator|&&
operator|(
name|DEPRECATED_STREQ
argument_list|(
operator|&
name|name
index|[
name|len
operator|-
literal|2
index|]
argument_list|,
literal|".h"
argument_list|)
operator|)
operator|)
condition|)
block|{
name|current_source_symtab
operator|=
name|s
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|current_source_symtab
condition|)
return|return;
comment|/* Howabout the partial symbol tables? */
for|for
control|(
name|ofp
operator|=
name|object_files
init|;
name|ofp
operator|!=
name|NULL
condition|;
name|ofp
operator|=
name|ofp
operator|->
name|next
control|)
block|{
for|for
control|(
name|ps
operator|=
name|ofp
operator|->
name|psymtabs
init|;
name|ps
operator|!=
name|NULL
condition|;
name|ps
operator|=
name|ps
operator|->
name|next
control|)
block|{
name|char
modifier|*
name|name
init|=
name|ps
operator|->
name|filename
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|len
operator|>
literal|2
operator|&&
operator|(
name|DEPRECATED_STREQ
argument_list|(
operator|&
name|name
index|[
name|len
operator|-
literal|2
index|]
argument_list|,
literal|".h"
argument_list|)
operator|)
operator|)
condition|)
block|{
name|cs_pst
operator|=
name|ps
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|cs_pst
condition|)
block|{
if|if
condition|(
name|cs_pst
operator|->
name|readin
condition|)
block|{
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"select_source_symtab: "
literal|"readin pst found and no symtabs."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|current_source_symtab
operator|=
name|PSYMTAB_TO_SYMTAB
argument_list|(
name|cs_pst
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|current_source_symtab
condition|)
return|return;
name|error
argument_list|(
literal|"Can't find a default source file"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|show_directories
parameter_list|(
name|char
modifier|*
name|ignore
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|puts_filtered
argument_list|(
literal|"Source directories searched: "
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
name|source_path
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Forget what we learned about line positions in source files, and    which directories contain them; must check again now since files    may be found in a different directory now.  */
end_comment

begin_function
name|void
name|forget_cached_source_info
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
for|for
control|(
name|objfile
operator|=
name|object_files
init|;
name|objfile
operator|!=
name|NULL
condition|;
name|objfile
operator|=
name|objfile
operator|->
name|next
control|)
block|{
for|for
control|(
name|s
operator|=
name|objfile
operator|->
name|symtabs
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|s
operator|->
name|line_charpos
operator|!=
name|NULL
condition|)
block|{
name|xmfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|s
operator|->
name|line_charpos
argument_list|)
expr_stmt|;
name|s
operator|->
name|line_charpos
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|fullname
operator|!=
name|NULL
condition|)
block|{
name|xmfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|s
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|s
operator|->
name|fullname
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|ALL_OBJFILE_PSYMTABS
argument_list|(
argument|objfile
argument_list|,
argument|pst
argument_list|)
block|{
if|if
condition|(
name|pst
operator|->
name|fullname
operator|!=
name|NULL
condition|)
block|{
name|xfree
argument_list|(
name|pst
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|pst
operator|->
name|fullname
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|init_source_path
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"$cdir%c$cwd"
argument_list|,
name|DIRNAME_SEPARATOR
argument_list|)
expr_stmt|;
name|source_path
operator|=
name|xstrdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|forget_cached_source_info
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|init_last_source_visited
parameter_list|(
name|void
parameter_list|)
block|{
name|last_source_visited
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add zero or more directories to the front of the source path.  */
end_comment

begin_function
name|void
name|directory_command
parameter_list|(
name|char
modifier|*
name|dirname
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|dont_repeat
argument_list|()
expr_stmt|;
comment|/* FIXME, this goes to "delete dir"... */
if|if
condition|(
name|dirname
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|from_tty
operator|&&
name|query
argument_list|(
literal|"Reinitialize source path to empty? "
argument_list|)
condition|)
block|{
name|xfree
argument_list|(
name|source_path
argument_list|)
expr_stmt|;
name|init_source_path
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|mod_path
argument_list|(
name|dirname
argument_list|,
operator|&
name|source_path
argument_list|)
expr_stmt|;
name|last_source_visited
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|from_tty
condition|)
name|show_directories
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|forget_cached_source_info
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add zero or more directories to the front of an arbitrary path.  */
end_comment

begin_function
name|void
name|mod_path
parameter_list|(
name|char
modifier|*
name|dirname
parameter_list|,
name|char
modifier|*
modifier|*
name|which_path
parameter_list|)
block|{
name|add_path
argument_list|(
name|dirname
argument_list|,
name|which_path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Workhorse of mod_path.  Takes an extra argument to determine    if dirname should be parsed for separators that indicate multiple    directories.  This allows for interfaces that pre-parse the dirname    and allow specification of traditional separator characters such    as space or tab. */
end_comment

begin_function
name|void
name|add_path
parameter_list|(
name|char
modifier|*
name|dirname
parameter_list|,
name|char
modifier|*
modifier|*
name|which_path
parameter_list|,
name|int
name|parse_separators
parameter_list|)
block|{
name|char
modifier|*
name|old
init|=
operator|*
name|which_path
decl_stmt|;
name|int
name|prefix
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dirname
operator|==
literal|0
condition|)
return|return;
name|dirname
operator|=
name|xstrdup
argument_list|(
name|dirname
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
do|do
block|{
name|char
modifier|*
name|name
init|=
name|dirname
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
block|{
name|char
modifier|*
name|separator
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|space
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|tab
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|parse_separators
condition|)
block|{
name|separator
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
name|DIRNAME_SEPARATOR
argument_list|)
expr_stmt|;
name|space
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|tab
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|separator
operator|==
literal|0
operator|&&
name|space
operator|==
literal|0
operator|&&
name|tab
operator|==
literal|0
condition|)
name|p
operator|=
name|dirname
operator|=
name|name
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
else|else
block|{
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|separator
operator|!=
literal|0
operator|&&
operator|(
name|p
operator|==
literal|0
operator|||
name|separator
operator|<
name|p
operator|)
condition|)
name|p
operator|=
name|separator
expr_stmt|;
if|if
condition|(
name|space
operator|!=
literal|0
operator|&&
operator|(
name|p
operator|==
literal|0
operator|||
name|space
operator|<
name|p
operator|)
condition|)
name|p
operator|=
name|space
expr_stmt|;
if|if
condition|(
name|tab
operator|!=
literal|0
operator|&&
operator|(
name|p
operator|==
literal|0
operator|||
name|tab
operator|<
name|p
operator|)
condition|)
name|p
operator|=
name|tab
expr_stmt|;
name|dirname
operator|=
name|p
operator|+
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|dirname
operator|==
name|DIRNAME_SEPARATOR
operator|||
operator|*
name|dirname
operator|==
literal|' '
operator|||
operator|*
name|dirname
operator|==
literal|'\t'
condition|)
operator|++
name|dirname
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|IS_DIR_SEPARATOR
argument_list|(
operator|*
name|name
argument_list|)
operator|&&
name|p
operator|<=
name|name
operator|+
literal|1
operator|)
comment|/* "/" */
ifdef|#
directive|ifdef
name|HAVE_DOS_BASED_FILE_SYSTEM
comment|/* On MS-DOS and MS-Windows, h:\ is different from h: */
operator|&&
operator|!
operator|(
name|p
operator|==
name|name
operator|+
literal|3
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|':'
operator|)
comment|/* "d:/" */
endif|#
directive|endif
operator|&&
name|IS_DIR_SEPARATOR
argument_list|(
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
condition|)
comment|/* Sigh. "foo/" => "foo" */
operator|--
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|p
operator|>
name|name
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|p
operator|-
name|name
operator|==
literal|1
condition|)
block|{
comment|/* "." => getwd ().  */
name|name
operator|=
name|current_directory
expr_stmt|;
goto|goto
name|append
goto|;
block|}
elseif|else
if|if
condition|(
name|p
operator|>
name|name
operator|+
literal|1
operator|&&
name|IS_DIR_SEPARATOR
argument_list|(
name|p
index|[
operator|-
literal|2
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|p
operator|-
name|name
operator|==
literal|2
condition|)
block|{
comment|/* "/." => "/".  */
operator|*
operator|--
name|p
operator|=
literal|'\0'
expr_stmt|;
goto|goto
name|append
goto|;
block|}
else|else
block|{
comment|/* "...foo/." => "...foo".  */
name|p
operator|-=
literal|2
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
continue|continue;
block|}
block|}
else|else
break|break;
block|}
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'~'
condition|)
name|name
operator|=
name|tilde_expand
argument_list|(
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_DOS_BASED_FILE_SYSTEM
elseif|else
if|if
condition|(
name|IS_ABSOLUTE_PATH
argument_list|(
name|name
argument_list|)
operator|&&
name|p
operator|==
name|name
operator|+
literal|2
condition|)
comment|/* "d:" => "d:." */
name|name
operator|=
name|concat
argument_list|(
name|name
argument_list|,
literal|"."
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
elseif|else
if|if
condition|(
operator|!
name|IS_ABSOLUTE_PATH
argument_list|(
name|name
argument_list|)
operator|&&
name|name
index|[
literal|0
index|]
operator|!=
literal|'$'
condition|)
name|name
operator|=
name|concat
argument_list|(
name|current_directory
argument_list|,
name|SLASH_STRING
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|p
operator|-
name|name
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Unless it's a variable, check existence.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'$'
condition|)
block|{
comment|/* These are warnings, not errors, since we don't want a 	     non-existent directory in a .gdbinit file to stop processing 	     of the .gdbinit file.  	     Whether they get added to the path is more debatable.  Current 	     answer is yes, in case the user wants to go make the directory 	     or whatever.  If the directory continues to not exist/not be 	     a directory/etc, then having them in the path should be 	     harmless.  */
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|save_errno
init|=
name|errno
decl_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Warning: "
argument_list|)
expr_stmt|;
name|print_sys_errmsg
argument_list|(
name|name
argument_list|,
name|save_errno
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|st
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFDIR
condition|)
name|warning
argument_list|(
literal|"%s is not a directory."
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|append
label|:
block|{
name|unsigned
name|int
name|len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|p
operator|=
operator|*
name|which_path
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* FIXME: strncmp loses in interesting ways on MS-DOS and 	       MS-Windows because of case-insensitivity and two different 	       but functionally identical slash characters.  We need a 	       special filesystem-dependent file-name comparison function.  	       Actually, even on Unix I would use realpath() or its work- 	       alike before comparing.  Then all the code above which 	       removes excess slashes and dots could simply go away.  */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
operator|&&
operator|(
name|p
index|[
name|len
index|]
operator|==
literal|'\0'
operator|||
name|p
index|[
name|len
index|]
operator|==
name|DIRNAME_SEPARATOR
operator|)
condition|)
block|{
comment|/* Found it in the search path, remove old copy */
if|if
condition|(
name|p
operator|>
operator|*
name|which_path
condition|)
name|p
operator|--
expr_stmt|;
comment|/* Back over leading separator */
if|if
condition|(
name|prefix
operator|>
name|p
operator|-
operator|*
name|which_path
condition|)
goto|goto
name|skip_dup
goto|;
comment|/* Same dir twice in one cmd */
name|strcpy
argument_list|(
name|p
argument_list|,
operator|&
name|p
index|[
name|len
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Copy from next \0 or  : */
block|}
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
name|DIRNAME_SEPARATOR
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
literal|0
condition|)
operator|++
name|p
expr_stmt|;
else|else
break|break;
block|}
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
name|char
name|tinybuf
index|[
literal|2
index|]
decl_stmt|;
name|tinybuf
index|[
literal|0
index|]
operator|=
name|DIRNAME_SEPARATOR
expr_stmt|;
name|tinybuf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* If we have already tacked on a name(s) in this command, be sure they stay  	       on the front as we tack on some more.  */
if|if
condition|(
name|prefix
condition|)
block|{
name|char
modifier|*
name|temp
decl_stmt|,
name|c
decl_stmt|;
name|c
operator|=
name|old
index|[
name|prefix
index|]
expr_stmt|;
name|old
index|[
name|prefix
index|]
operator|=
literal|'\0'
expr_stmt|;
name|temp
operator|=
name|concat
argument_list|(
name|old
argument_list|,
name|tinybuf
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|old
index|[
name|prefix
index|]
operator|=
name|c
expr_stmt|;
operator|*
name|which_path
operator|=
name|concat
argument_list|(
name|temp
argument_list|,
literal|""
argument_list|,
operator|&
name|old
index|[
name|prefix
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|prefix
operator|=
name|strlen
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|which_path
operator|=
name|concat
argument_list|(
name|name
argument_list|,
operator|(
name|old
index|[
literal|0
index|]
condition|?
name|tinybuf
else|:
name|old
operator|)
argument_list|,
name|old
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|prefix
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|xfree
argument_list|(
name|old
argument_list|)
expr_stmt|;
name|old
operator|=
operator|*
name|which_path
expr_stmt|;
block|}
block|}
name|skip_dup
label|:
empty_stmt|;
block|}
do|while
condition|(
operator|*
name|dirname
operator|!=
literal|'\0'
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|source_info
parameter_list|(
name|char
modifier|*
name|ignore
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|symtab
modifier|*
name|s
init|=
name|current_source_symtab
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"No current source file.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf_filtered
argument_list|(
literal|"Current source file is %s\n"
argument_list|,
name|s
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|dirname
condition|)
name|printf_filtered
argument_list|(
literal|"Compilation directory is %s\n"
argument_list|,
name|s
operator|->
name|dirname
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|fullname
condition|)
name|printf_filtered
argument_list|(
literal|"Located in %s\n"
argument_list|,
name|s
operator|->
name|fullname
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|nlines
condition|)
name|printf_filtered
argument_list|(
literal|"Contains %d line%s.\n"
argument_list|,
name|s
operator|->
name|nlines
argument_list|,
name|s
operator|->
name|nlines
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Source language is %s.\n"
argument_list|,
name|language_str
argument_list|(
name|s
operator|->
name|language
argument_list|)
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Compiled with %s debugging format.\n"
argument_list|,
name|s
operator|->
name|debugformat
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s preprocessor macro info.\n"
argument_list|,
name|s
operator|->
name|macro_table
condition|?
literal|"Includes"
else|:
literal|"Does not include"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return True if the file NAME exists and is a regular file */
end_comment

begin_function
specifier|static
name|int
name|is_regular_file
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
specifier|const
name|int
name|status
init|=
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|st
argument_list|)
decl_stmt|;
comment|/* Stat should never fail except when the file does not exist.      If stat fails, analyze the source of error and return True      unless the file does not exist, to avoid returning false results      on obscure systems where stat does not work as expected.    */
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
operator|(
name|errno
operator|!=
name|ENOENT
operator|)
return|;
return|return
name|S_ISREG
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Open a file named STRING, searching path PATH (dir names sep by some char)    using mode MODE and protection bits PROT in the calls to open.     If TRY_CWD_FIRST, try to open ./STRING before searching PATH.    (ie pretend the first element of PATH is ".").  This also indicates    that a slash in STRING disables searching of the path (this is    so that "exec-file ./foo" or "symbol-file ./foo" insures that you    get that particular version of foo or an error message).     If FILENAME_OPENED is non-null, set it to a newly allocated string naming    the actual file opened (this string will always start with a "/").  We    have to take special pains to avoid doubling the "/" between the directory    and the file, sigh!  Emacs gets confuzzed by this when we print the    source file name!!!      If a file is found, return the descriptor.    Otherwise, return -1, with errno set for the last name we tried to open.  */
end_comment

begin_comment
comment|/*>>>> This should only allow files of certain types,>>>>  eg executable, non-directory */
end_comment

begin_function
name|int
name|openp
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|try_cwd_first
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|prot
parameter_list|,
name|char
modifier|*
modifier|*
name|filename_opened
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|p1
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|alloclen
decl_stmt|;
if|if
condition|(
operator|!
name|path
condition|)
name|path
operator|=
literal|"."
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
name|mode
operator||=
name|O_BINARY
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|try_cwd_first
operator|||
name|IS_ABSOLUTE_PATH
argument_list|(
name|string
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|is_regular_file
argument_list|(
name|string
argument_list|)
condition|)
block|{
name|filename
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|filename
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|mode
argument_list|,
name|prot
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
goto|goto
name|done
goto|;
block|}
else|else
block|{
name|filename
operator|=
name|NULL
expr_stmt|;
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|string
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
name|string
index|[
name|i
index|]
argument_list|)
condition|)
goto|goto
name|done
goto|;
block|}
comment|/* ./foo => foo */
while|while
condition|(
name|string
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|IS_DIR_SEPARATOR
argument_list|(
name|string
index|[
literal|1
index|]
argument_list|)
condition|)
name|string
operator|+=
literal|2
expr_stmt|;
name|alloclen
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|2
expr_stmt|;
name|filename
operator|=
name|alloca
argument_list|(
name|alloclen
argument_list|)
expr_stmt|;
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|p
operator|=
name|path
init|;
name|p
condition|;
name|p
operator|=
name|p1
condition|?
name|p1
operator|+
literal|1
else|:
literal|0
control|)
block|{
name|p1
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
name|DIRNAME_SEPARATOR
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
condition|)
name|len
operator|=
name|p1
operator|-
name|p
expr_stmt|;
else|else
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|4
operator|&&
name|p
index|[
literal|0
index|]
operator|==
literal|'$'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'c'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'w'
operator|&&
name|p
index|[
literal|3
index|]
operator|==
literal|'d'
condition|)
block|{
comment|/* Name is $cwd -- insert current directory name instead.  */
name|int
name|newlen
decl_stmt|;
comment|/* First, realloc the filename buffer if too short. */
name|len
operator|=
name|strlen
argument_list|(
name|current_directory
argument_list|)
expr_stmt|;
name|newlen
operator|=
name|len
operator|+
name|strlen
argument_list|(
name|string
argument_list|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|newlen
operator|>
name|alloclen
condition|)
block|{
name|alloclen
operator|=
name|newlen
expr_stmt|;
name|filename
operator|=
name|alloca
argument_list|(
name|alloclen
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|filename
argument_list|,
name|current_directory
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Normal file name in path -- just use it.  */
name|strncpy
argument_list|(
name|filename
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|filename
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Remove trailing slashes */
while|while
condition|(
name|len
operator|>
literal|0
operator|&&
name|IS_DIR_SEPARATOR
argument_list|(
name|filename
index|[
name|len
operator|-
literal|1
index|]
argument_list|)
condition|)
name|filename
index|[
operator|--
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|strcat
argument_list|(
name|filename
operator|+
name|len
argument_list|,
name|SLASH_STRING
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|filename
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_regular_file
argument_list|(
name|filename
argument_list|)
condition|)
block|{
name|fd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
break|break;
block|}
block|}
name|done
label|:
if|if
condition|(
name|filename_opened
condition|)
block|{
comment|/* If a file was opened, canonicalize its filename. Use xfullpath          rather than gdb_realpath to avoid resolving the basename part          of filenames when the associated file is a symbolic link. This          fixes a potential inconsistency between the filenames known to          GDB and the filenames it prints in the annotations.  */
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
operator|*
name|filename_opened
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|IS_ABSOLUTE_PATH
argument_list|(
name|filename
argument_list|)
condition|)
operator|*
name|filename_opened
operator|=
name|xfullpath
argument_list|(
name|filename
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Beware the // my son, the Emacs barfs, the botch that catch... */
name|char
modifier|*
name|f
init|=
name|concat
argument_list|(
name|current_directory
argument_list|,
name|IS_DIR_SEPARATOR
argument_list|(
name|current_directory
index|[
name|strlen
argument_list|(
name|current_directory
argument_list|)
operator|-
literal|1
index|]
argument_list|)
condition|?
literal|""
else|:
name|SLASH_STRING
argument_list|,
name|filename
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
operator|*
name|filename_opened
operator|=
name|xfullpath
argument_list|(
name|f
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|fd
return|;
block|}
end_function

begin_comment
comment|/* This is essentially a convenience, for clients that want the behaviour    of openp, using source_path, but that really don't want the file to be    opened but want instead just to know what the full pathname is (as    qualified against source_path).     The current working directory is searched first.     If the file was found, this function returns 1, and FULL_PATHNAME is    set to the fully-qualified pathname.     Else, this functions returns 0, and FULL_PATHNAME is set to NULL.  */
end_comment

begin_function
name|int
name|source_full_path_of
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|char
modifier|*
modifier|*
name|full_pathname
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|fd
operator|=
name|openp
argument_list|(
name|source_path
argument_list|,
literal|1
argument_list|,
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
name|full_pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
operator|*
name|full_pathname
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Open a source file given a symtab S.  Returns a file descriptor or    negative number for error.  */
end_comment

begin_function
name|int
name|open_source_file
parameter_list|(
name|struct
name|symtab
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|path
init|=
name|source_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|result
decl_stmt|;
name|char
modifier|*
name|fullname
decl_stmt|;
comment|/* Quick way out if we already know its full name */
if|if
condition|(
name|s
operator|->
name|fullname
condition|)
block|{
name|result
operator|=
name|open
argument_list|(
name|s
operator|->
name|fullname
argument_list|,
name|OPEN_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|>=
literal|0
condition|)
return|return
name|result
return|;
comment|/* Didn't work -- free old one, try again. */
name|xmfree
argument_list|(
name|s
operator|->
name|objfile
operator|->
name|md
argument_list|,
name|s
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|s
operator|->
name|fullname
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|dirname
operator|!=
name|NULL
condition|)
block|{
comment|/* Replace a path entry of  $cdir  with the compilation directory name */
define|#
directive|define
name|cdir_len
value|5
comment|/* We cast strstr's result in case an ANSIhole has made it const,          which produces a "required warning" when assigned to a nonconst. */
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|strstr
argument_list|(
name|source_path
argument_list|,
literal|"$cdir"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|&&
operator|(
name|p
operator|==
name|path
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|==
name|DIRNAME_SEPARATOR
operator|)
operator|&&
operator|(
name|p
index|[
name|cdir_len
index|]
operator|==
name|DIRNAME_SEPARATOR
operator|||
name|p
index|[
name|cdir_len
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|int
name|len
decl_stmt|;
name|path
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|source_path
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|s
operator|->
name|dirname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|len
operator|=
name|p
operator|-
name|source_path
expr_stmt|;
name|strncpy
argument_list|(
name|path
argument_list|,
name|source_path
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Before $cdir */
name|strcpy
argument_list|(
name|path
operator|+
name|len
argument_list|,
name|s
operator|->
name|dirname
argument_list|)
expr_stmt|;
comment|/* new stuff */
name|strcat
argument_list|(
name|path
operator|+
name|len
argument_list|,
name|source_path
operator|+
name|len
operator|+
name|cdir_len
argument_list|)
expr_stmt|;
comment|/* After $cdir */
block|}
block|}
name|result
operator|=
name|openp
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
name|s
operator|->
name|filename
argument_list|,
name|OPEN_MODE
argument_list|,
literal|0
argument_list|,
operator|&
name|s
operator|->
name|fullname
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
comment|/* Didn't work.  Try using just the basename. */
name|p
operator|=
name|lbasename
argument_list|(
name|s
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|s
operator|->
name|filename
condition|)
name|result
operator|=
name|openp
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
name|p
argument_list|,
name|OPEN_MODE
argument_list|,
literal|0
argument_list|,
operator|&
name|s
operator|->
name|fullname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|>=
literal|0
condition|)
block|{
name|fullname
operator|=
name|s
operator|->
name|fullname
expr_stmt|;
name|s
operator|->
name|fullname
operator|=
name|mstrsave
argument_list|(
name|s
operator|->
name|objfile
operator|->
name|md
argument_list|,
name|s
operator|->
name|fullname
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|fullname
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Return the path to the source file associated with symtab.  Returns NULL    if no symtab.  */
end_comment

begin_function
name|char
modifier|*
name|symtab_to_filename
parameter_list|(
name|struct
name|symtab
modifier|*
name|s
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
return|return
name|NULL
return|;
comment|/* If we've seen the file before, just return fullname. */
if|if
condition|(
name|s
operator|->
name|fullname
condition|)
return|return
name|s
operator|->
name|fullname
return|;
comment|/* Try opening the file to setup fullname */
name|fd
operator|=
name|open_source_file
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
name|s
operator|->
name|filename
return|;
comment|/* File not found.  Just use short name */
comment|/* Found the file.  Cleanup and return the full name */
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
name|s
operator|->
name|fullname
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create and initialize the table S->line_charpos that records    the positions of the lines in the source file, which is assumed    to be open on descriptor DESC.    All set S->nlines to the number of such lines.  */
end_comment

begin_function
name|void
name|find_source_lines
parameter_list|(
name|struct
name|symtab
modifier|*
name|s
parameter_list|,
name|int
name|desc
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|int
name|nlines
init|=
literal|0
decl_stmt|;
name|int
name|lines_allocated
init|=
literal|1000
decl_stmt|;
name|int
modifier|*
name|line_charpos
decl_stmt|;
name|long
name|mtime
init|=
literal|0
decl_stmt|;
name|int
name|size
decl_stmt|;
name|line_charpos
operator|=
operator|(
name|int
operator|*
operator|)
name|xmmalloc
argument_list|(
name|s
operator|->
name|objfile
operator|->
name|md
argument_list|,
name|lines_allocated
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|desc
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|s
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|&&
name|s
operator|->
name|objfile
operator|&&
name|s
operator|->
name|objfile
operator|->
name|obfd
condition|)
name|mtime
operator|=
name|bfd_get_mtime
argument_list|(
name|s
operator|->
name|objfile
operator|->
name|obfd
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|exec_bfd
condition|)
name|mtime
operator|=
name|bfd_get_mtime
argument_list|(
name|exec_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtime
operator|&&
name|mtime
operator|<
name|st
operator|.
name|st_mtime
condition|)
block|{
name|warning
argument_list|(
literal|"Source file is more recent than executable.\n"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|LSEEK_NOT_LINEAR
block|{
name|char
name|c
decl_stmt|;
comment|/* Have to read it byte by byte to find out where the chars live */
name|line_charpos
index|[
literal|0
index|]
operator|=
name|lseek
argument_list|(
name|desc
argument_list|,
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
name|nlines
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|myread
argument_list|(
name|desc
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|nlines
operator|==
name|lines_allocated
condition|)
block|{
name|lines_allocated
operator|*=
literal|2
expr_stmt|;
name|line_charpos
operator|=
operator|(
name|int
operator|*
operator|)
name|xmrealloc
argument_list|(
name|s
operator|->
name|objfile
operator|->
name|md
argument_list|,
operator|(
name|char
operator|*
operator|)
name|line_charpos
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|lines_allocated
argument_list|)
expr_stmt|;
block|}
name|line_charpos
index|[
name|nlines
operator|++
index|]
operator|=
name|lseek
argument_list|(
name|desc
argument_list|,
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|#
directive|else
comment|/* lseek linear.  */
block|{
name|struct
name|cleanup
modifier|*
name|old_cleanups
decl_stmt|;
comment|/* st_size might be a large type, but we only support source files whose         size fits in an int.  */
name|size
operator|=
operator|(
name|int
operator|)
name|st
operator|.
name|st_size
expr_stmt|;
comment|/* Use malloc, not alloca, because this may be pretty large, and we may        run into various kinds of limits on stack size.  */
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|old_cleanups
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* Reassign `size' to result of read for systems where \r\n -> \n.  */
name|size
operator|=
name|myread
argument_list|(
name|desc
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|s
operator|->
name|filename
argument_list|)
expr_stmt|;
name|end
operator|=
name|data
operator|+
name|size
expr_stmt|;
name|p
operator|=
name|data
expr_stmt|;
name|line_charpos
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|nlines
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|end
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'\n'
comment|/* A newline at the end does not start a new line.  */
operator|&&
name|p
operator|!=
name|end
condition|)
block|{
if|if
condition|(
name|nlines
operator|==
name|lines_allocated
condition|)
block|{
name|lines_allocated
operator|*=
literal|2
expr_stmt|;
name|line_charpos
operator|=
operator|(
name|int
operator|*
operator|)
name|xmrealloc
argument_list|(
name|s
operator|->
name|objfile
operator|->
name|md
argument_list|,
operator|(
name|char
operator|*
operator|)
name|line_charpos
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|lines_allocated
argument_list|)
expr_stmt|;
block|}
name|line_charpos
index|[
name|nlines
operator|++
index|]
operator|=
name|p
operator|-
name|data
expr_stmt|;
block|}
block|}
name|do_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* lseek linear.  */
name|s
operator|->
name|nlines
operator|=
name|nlines
expr_stmt|;
name|s
operator|->
name|line_charpos
operator|=
operator|(
name|int
operator|*
operator|)
name|xmrealloc
argument_list|(
name|s
operator|->
name|objfile
operator|->
name|md
argument_list|,
operator|(
name|char
operator|*
operator|)
name|line_charpos
argument_list|,
name|nlines
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the character position of a line LINE in symtab S.    Return 0 if anything is invalid.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Currently unused */
end_comment

begin_comment
unit|int source_line_charpos (struct symtab *s, int line) {   if (!s)     return 0;   if (!s->line_charpos || line<= 0)     return 0;   if (line> s->nlines)     line = s->nlines;   return s->line_charpos[line - 1]; }
comment|/* Return the line number of character position POS in symtab S.  */
end_comment

begin_comment
unit|int source_charpos_line (struct symtab *s, int chr) {   int line = 0;   int *lnp;    if (s == 0 || s->line_charpos == 0)     return 0;   lnp = s->line_charpos;
comment|/* Files are usually short, so sequential search is Ok */
end_comment

begin_endif
unit|while (line< s->nlines&& *lnp<= chr)     {       line++;       lnp++;     }   if (line>= s->nlines)     line = s->nlines;   return line; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Get full pathname and line number positions for a symtab.    Return nonzero if line numbers may have changed.    Set *FULLNAME to actual name of the file as found by `openp',    or to 0 if the file is not found.  */
end_comment

begin_function
specifier|static
name|int
name|get_filename_and_charpos
parameter_list|(
name|struct
name|symtab
modifier|*
name|s
parameter_list|,
name|char
modifier|*
modifier|*
name|fullname
parameter_list|)
block|{
name|int
name|desc
decl_stmt|,
name|linenums_changed
init|=
literal|0
decl_stmt|;
name|desc
operator|=
name|open_source_file
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|fullname
condition|)
operator|*
name|fullname
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|fullname
condition|)
operator|*
name|fullname
operator|=
name|s
operator|->
name|fullname
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|line_charpos
operator|==
literal|0
condition|)
name|linenums_changed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|linenums_changed
condition|)
name|find_source_lines
argument_list|(
name|s
argument_list|,
name|desc
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
return|return
name|linenums_changed
return|;
block|}
end_function

begin_comment
comment|/* Print text describing the full name of the source file S    and the line number LINE and its corresponding character position.    The text starts with two Ctrl-z so that the Emacs-GDB interface    can easily find it.     MID_STATEMENT is nonzero if the PC is not at the beginning of that line.     Return 1 if successful, 0 if could not find the file.  */
end_comment

begin_function
name|int
name|identify_source_line
parameter_list|(
name|struct
name|symtab
modifier|*
name|s
parameter_list|,
name|int
name|line
parameter_list|,
name|int
name|mid_statement
parameter_list|,
name|CORE_ADDR
name|pc
parameter_list|)
block|{
if|if
condition|(
name|s
operator|->
name|line_charpos
operator|==
literal|0
condition|)
name|get_filename_and_charpos
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|fullname
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|line
operator|>
name|s
operator|->
name|nlines
condition|)
comment|/* Don't index off the end of the line_charpos array.  */
return|return
literal|0
return|;
name|annotate_source
argument_list|(
name|s
operator|->
name|fullname
argument_list|,
name|line
argument_list|,
name|s
operator|->
name|line_charpos
index|[
name|line
operator|-
literal|1
index|]
argument_list|,
name|mid_statement
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|current_source_line
operator|=
name|line
expr_stmt|;
name|first_line_listed
operator|=
name|line
expr_stmt|;
name|last_line_listed
operator|=
name|line
expr_stmt|;
name|current_source_symtab
operator|=
name|s
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print source lines from the file of symtab S,    starting with line number LINE and stopping before line number STOPLINE. */
end_comment

begin_function_decl
specifier|static
name|void
name|print_source_lines_base
parameter_list|(
name|struct
name|symtab
modifier|*
name|s
parameter_list|,
name|int
name|line
parameter_list|,
name|int
name|stopline
parameter_list|,
name|int
name|noerror
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|print_source_lines_base
parameter_list|(
name|struct
name|symtab
modifier|*
name|s
parameter_list|,
name|int
name|line
parameter_list|,
name|int
name|stopline
parameter_list|,
name|int
name|noerror
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|desc
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|nlines
init|=
name|stopline
operator|-
name|line
decl_stmt|;
comment|/* Regardless of whether we can open the file, set current_source_symtab. */
name|current_source_symtab
operator|=
name|s
expr_stmt|;
name|current_source_line
operator|=
name|line
expr_stmt|;
name|first_line_listed
operator|=
name|line
expr_stmt|;
comment|/* If printing of source lines is disabled, just print file and line number */
if|if
condition|(
name|ui_out_test_flags
argument_list|(
name|uiout
argument_list|,
name|ui_source_list
argument_list|)
condition|)
block|{
comment|/* Only prints "No such file or directory" once */
if|if
condition|(
operator|(
name|s
operator|!=
name|last_source_visited
operator|)
operator|||
operator|(
operator|!
name|last_source_error
operator|)
condition|)
block|{
name|last_source_visited
operator|=
name|s
expr_stmt|;
name|desc
operator|=
name|open_source_file
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|desc
operator|=
name|last_source_error
expr_stmt|;
name|noerror
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|desc
operator|=
operator|-
literal|1
expr_stmt|;
name|noerror
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
block|{
name|last_source_error
operator|=
name|desc
expr_stmt|;
if|if
condition|(
operator|!
name|noerror
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|s
operator|->
name|filename
argument_list|)
operator|+
literal|100
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%d\t%s"
argument_list|,
name|line
argument_list|,
name|s
operator|->
name|filename
argument_list|)
expr_stmt|;
name|print_sys_errmsg
argument_list|(
name|name
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
else|else
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
literal|"line"
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\tin "
argument_list|)
expr_stmt|;
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"file"
argument_list|,
name|s
operator|->
name|filename
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|last_source_error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|line_charpos
operator|==
literal|0
condition|)
name|find_source_lines
argument_list|(
name|s
argument_list|,
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|<
literal|1
operator|||
name|line
operator|>
name|s
operator|->
name|nlines
condition|)
block|{
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Line number %d out of range; %s has %d lines."
argument_list|,
name|line
argument_list|,
name|s
operator|->
name|filename
argument_list|,
name|s
operator|->
name|nlines
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|desc
argument_list|,
name|s
operator|->
name|line_charpos
index|[
name|line
operator|-
literal|1
index|]
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|s
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
name|stream
operator|=
name|fdopen
argument_list|(
name|desc
argument_list|,
name|FDOPEN_MODE
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|stream
argument_list|)
expr_stmt|;
while|while
condition|(
name|nlines
operator|--
operator|>
literal|0
condition|)
block|{
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|c
operator|=
name|fgetc
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
name|last_line_listed
operator|=
name|current_source_line
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d\t"
argument_list|,
name|current_source_line
operator|++
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
name|buf
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|c
operator|<
literal|040
operator|&&
name|c
operator|!=
literal|'\t'
operator|&&
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
literal|'\r'
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"^%c"
argument_list|,
name|c
operator|+
literal|0100
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|0177
condition|)
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"^?"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CRLF_SOURCE_FILES
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
block|{
comment|/* Skip a \r character, but only before a \n.  */
name|int
name|c1
init|=
name|fgetc
argument_list|(
name|stream
argument_list|)
decl_stmt|;
if|if
condition|(
name|c1
operator|!=
literal|'\n'
condition|)
name|printf_filtered
argument_list|(
literal|"^%c"
argument_list|,
name|c
operator|+
literal|0100
argument_list|)
expr_stmt|;
if|if
condition|(
name|c1
operator|!=
name|EOF
condition|)
name|ungetc
argument_list|(
name|c1
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
operator|(
name|c
operator|=
name|fgetc
argument_list|(
name|stream
argument_list|)
operator|)
operator|>=
literal|0
condition|)
do|;
block|}
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Show source lines from the file of symtab S, starting with line    number LINE and stopping before line number STOPLINE.  If this is the    not the command line version, then the source is shown in the source    window otherwise it is simply printed */
end_comment

begin_function
name|void
name|print_source_lines
parameter_list|(
name|struct
name|symtab
modifier|*
name|s
parameter_list|,
name|int
name|line
parameter_list|,
name|int
name|stopline
parameter_list|,
name|int
name|noerror
parameter_list|)
block|{
name|print_source_lines_base
argument_list|(
name|s
argument_list|,
name|line
argument_list|,
name|stopline
argument_list|,
name|noerror
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print info on range of pc's in a specified line.  */
end_comment

begin_function
specifier|static
name|void
name|line_info
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|CORE_ADDR
name|start_pc
decl_stmt|,
name|end_pc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|init_sal
argument_list|(
operator|&
name|sal
argument_list|)
expr_stmt|;
comment|/* initialize to zeroes */
if|if
condition|(
name|arg
operator|==
literal|0
condition|)
block|{
name|sal
operator|.
name|symtab
operator|=
name|current_source_symtab
expr_stmt|;
name|sal
operator|.
name|line
operator|=
name|last_line_listed
expr_stmt|;
name|sals
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
name|sals
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|sals
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|sal
expr_stmt|;
block|}
else|else
block|{
name|sals
operator|=
name|decode_line_spec_1
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
block|}
comment|/* C++  More than one line may have been specified, as when the user      specifies an overloaded function name. Print info on them all. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|.
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|sal
operator|=
name|sals
operator|.
name|sals
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|symtab
operator|==
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"No line number information available"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|pc
operator|!=
literal|0
condition|)
block|{
comment|/* This is useful for "info line *0x7f34".  If we can't tell the 	         user about a source line, at least let them have the symbolic 	         address.  */
name|printf_filtered
argument_list|(
literal|" for address "
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|print_address
argument_list|(
name|sal
operator|.
name|pc
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
else|else
name|printf_filtered
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sal
operator|.
name|line
operator|>
literal|0
operator|&&
name|find_line_pc_range
argument_list|(
name|sal
argument_list|,
operator|&
name|start_pc
argument_list|,
operator|&
name|end_pc
argument_list|)
condition|)
block|{
if|if
condition|(
name|start_pc
operator|==
name|end_pc
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Line %d of \"%s\""
argument_list|,
name|sal
operator|.
name|line
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" is at address "
argument_list|)
expr_stmt|;
name|print_address
argument_list|(
name|start_pc
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" but contains no code.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"Line %d of \"%s\""
argument_list|,
name|sal
operator|.
name|line
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" starts at address "
argument_list|)
expr_stmt|;
name|print_address
argument_list|(
name|start_pc
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" and ends at "
argument_list|)
expr_stmt|;
name|print_address
argument_list|(
name|end_pc
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
block|}
comment|/* x/i should display this line's code.  */
name|set_next_address
argument_list|(
name|start_pc
argument_list|)
expr_stmt|;
comment|/* Repeating "info line" should do the following line.  */
name|last_line_listed
operator|=
name|sal
operator|.
name|line
operator|+
literal|1
expr_stmt|;
comment|/* If this is the only line, show the source code.  If it could 	     not find the file, don't do anything special.  */
if|if
condition|(
name|annotation_level
operator|&&
name|sals
operator|.
name|nelts
operator|==
literal|1
condition|)
name|identify_source_line
argument_list|(
name|sal
operator|.
name|symtab
argument_list|,
name|sal
operator|.
name|line
argument_list|,
literal|0
argument_list|,
name|start_pc
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Is there any case in which we get here, and have an address 	   which the user would want to see?  If we have debugging symbols 	   and no line numbers?  */
name|printf_filtered
argument_list|(
literal|"Line number %d is out of range for \"%s\".\n"
argument_list|,
name|sal
operator|.
name|line
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
name|xfree
argument_list|(
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Commands to search the source file for a regexp.  */
end_comment

begin_function
specifier|static
name|void
name|forward_search_command
parameter_list|(
name|char
modifier|*
name|regex
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|desc
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|line
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|line
operator|=
name|last_line_listed
operator|+
literal|1
expr_stmt|;
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
name|re_comp
argument_list|(
name|regex
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
condition|)
name|error
argument_list|(
literal|"%s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_source_symtab
operator|==
literal|0
condition|)
name|select_source_symtab
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|desc
operator|=
name|open_source_file
argument_list|(
name|current_source_symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|current_source_symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_source_symtab
operator|->
name|line_charpos
operator|==
literal|0
condition|)
name|find_source_lines
argument_list|(
name|current_source_symtab
argument_list|,
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|<
literal|1
operator|||
name|line
operator|>
name|current_source_symtab
operator|->
name|nlines
condition|)
block|{
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Expression not found"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|desc
argument_list|,
name|current_source_symtab
operator|->
name|line_charpos
index|[
name|line
operator|-
literal|1
index|]
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|current_source_symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
name|stream
operator|=
name|fdopen
argument_list|(
name|desc
argument_list|,
name|FDOPEN_MODE
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|stream
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
specifier|static
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|cursize
decl_stmt|,
name|newsize
decl_stmt|;
name|cursize
operator|=
literal|256
expr_stmt|;
name|buf
operator|=
name|xmalloc
argument_list|(
name|cursize
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
do|do
block|{
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|p
operator|-
name|buf
operator|==
name|cursize
condition|)
block|{
name|newsize
operator|=
name|cursize
operator|+
name|cursize
operator|/
literal|2
expr_stmt|;
name|buf
operator|=
name|xrealloc
argument_list|(
name|buf
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
operator|+
name|cursize
expr_stmt|;
name|cursize
operator|=
name|newsize
expr_stmt|;
block|}
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
operator|(
name|c
operator|=
name|getc
argument_list|(
name|stream
argument_list|)
operator|)
operator|>=
literal|0
condition|)
do|;
ifdef|#
directive|ifdef
name|CRLF_SOURCE_FILES
comment|/* Remove the \r, if any, at the end of the line, otherwise          regular expressions that end with $ or \n won't work.  */
if|if
condition|(
name|p
operator|-
name|buf
operator|>
literal|1
operator|&&
name|p
index|[
operator|-
literal|2
index|]
operator|==
literal|'\r'
condition|)
block|{
name|p
operator|--
expr_stmt|;
name|p
index|[
operator|-
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* we now have a source line in buf, null terminate and match */
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|re_exec
argument_list|(
name|buf
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* Match! */
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|print_source_lines
argument_list|(
name|current_source_symtab
argument_list|,
name|line
argument_list|,
name|line
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"_"
argument_list|)
argument_list|,
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|line
argument_list|)
argument_list|)
expr_stmt|;
name|current_source_line
operator|=
name|max
argument_list|(
name|line
operator|-
name|lines_to_list
operator|/
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|line
operator|++
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"Expression not found\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|reverse_search_command
parameter_list|(
name|char
modifier|*
name|regex
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|desc
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|line
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|;
name|line
operator|=
name|last_line_listed
operator|-
literal|1
expr_stmt|;
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
name|re_comp
argument_list|(
name|regex
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
condition|)
name|error
argument_list|(
literal|"%s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_source_symtab
operator|==
literal|0
condition|)
name|select_source_symtab
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|desc
operator|=
name|open_source_file
argument_list|(
name|current_source_symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|current_source_symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_source_symtab
operator|->
name|line_charpos
operator|==
literal|0
condition|)
name|find_source_lines
argument_list|(
name|current_source_symtab
argument_list|,
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|<
literal|1
operator|||
name|line
operator|>
name|current_source_symtab
operator|->
name|nlines
condition|)
block|{
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Expression not found"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|desc
argument_list|,
name|current_source_symtab
operator|->
name|line_charpos
index|[
name|line
operator|-
literal|1
index|]
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|current_source_symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
name|stream
operator|=
name|fdopen
argument_list|(
name|desc
argument_list|,
name|FDOPEN_MODE
argument_list|)
expr_stmt|;
name|clearerr
argument_list|(
name|stream
argument_list|)
expr_stmt|;
while|while
condition|(
name|line
operator|>
literal|1
condition|)
block|{
comment|/* FIXME!!!  We walk right off the end of buf if we get a long line!!! */
name|char
name|buf
index|[
literal|4096
index|]
decl_stmt|;
comment|/* Should be reasonable??? */
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
name|c
operator|=
name|getc
argument_list|(
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
do|do
block|{
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
operator|(
name|c
operator|=
name|getc
argument_list|(
name|stream
argument_list|)
operator|)
operator|>=
literal|0
condition|)
do|;
ifdef|#
directive|ifdef
name|CRLF_SOURCE_FILES
comment|/* Remove the \r, if any, at the end of the line, otherwise          regular expressions that end with $ or \n won't work.  */
if|if
condition|(
name|p
operator|-
name|buf
operator|>
literal|1
operator|&&
name|p
index|[
operator|-
literal|2
index|]
operator|==
literal|'\r'
condition|)
block|{
name|p
operator|--
expr_stmt|;
name|p
index|[
operator|-
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* We now have a source line in buf; null terminate and match.  */
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|re_exec
argument_list|(
name|buf
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* Match! */
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|print_source_lines
argument_list|(
name|current_source_symtab
argument_list|,
name|line
argument_list|,
name|line
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"_"
argument_list|)
argument_list|,
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|line
argument_list|)
argument_list|)
expr_stmt|;
name|current_source_line
operator|=
name|max
argument_list|(
name|line
operator|-
name|lines_to_list
operator|/
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|line
operator|--
expr_stmt|;
if|if
condition|(
name|fseek
argument_list|(
name|stream
argument_list|,
name|current_source_symtab
operator|->
name|line_charpos
index|[
name|line
operator|-
literal|1
index|]
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|current_source_symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
block|}
name|printf_filtered
argument_list|(
literal|"Expression not found\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|_initialize_source
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|current_source_symtab
operator|=
literal|0
expr_stmt|;
name|init_source_path
argument_list|()
expr_stmt|;
comment|/* The intention is to use POSIX Basic Regular Expressions.      Always use the GNU regex routine for consistency across all hosts.      Our current GNU regex.c does not have all the POSIX features, so this is      just an approximation.  */
name|re_set_syntax
argument_list|(
name|RE_SYNTAX_GREP
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_cmd
argument_list|(
literal|"directory"
argument_list|,
name|class_files
argument_list|,
name|directory_command
argument_list|,
literal|"Add directory DIR to beginning of search path for source files.\n\ Forget cached info on source file locations and line positions.\n\ DIR can also be $cwd for the current working directory, or $cdir for the\n\ directory in which the source file was compiled into object code.\n\ With no argument, reset the search path to $cdir:$cwd, the default."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbx_commands
condition|)
name|add_com_alias
argument_list|(
literal|"use"
argument_list|,
literal|"directory"
argument_list|,
name|class_files
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_cmd_completer
argument_list|(
name|c
argument_list|,
name|filename_completer
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"directories"
argument_list|,
name|no_class
argument_list|,
name|show_directories
argument_list|,
literal|"Current search path for finding source files.\n\ $cwd in the path means the current working directory.\n\ $cdir in the path means the compilation directory of the source file."
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdb_commands
condition|)
block|{
name|add_com_alias
argument_list|(
literal|"D"
argument_list|,
literal|"directory"
argument_list|,
name|class_files
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"ld"
argument_list|,
name|no_class
argument_list|,
name|show_directories
argument_list|,
literal|"Current search path for finding source files.\n\ $cwd in the path means the current working directory.\n\ $cdir in the path means the compilation directory of the source file."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
block|}
name|add_info
argument_list|(
literal|"source"
argument_list|,
name|source_info
argument_list|,
literal|"Information about the current source file."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"line"
argument_list|,
name|line_info
argument_list|,
name|concat
argument_list|(
literal|"Core addresses of the code for a source line.\n\ Line can be specified as\n\   LINENUM, to list around that line in current file,\n\   FILE:LINENUM, to list around that line in that file,\n\   FUNCTION, to list around beginning of that function,\n\   FILE:FUNCTION, to distinguish among like-named static functions.\n\ "
argument_list|,
literal|"\ Default is to describe the last source line that was listed.\n\n\ This sets the default address for \"x\" to the line's first instruction\n\ so that \"x/i\" suffices to start examining the machine code.\n\ The address is also stored as the value of \"$_\"."
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"forward-search"
argument_list|,
name|class_files
argument_list|,
name|forward_search_command
argument_list|,
literal|"Search for regular expression (see regex(3)) from last line listed.\n\ The matching line number is also stored as the value of \"$_\"."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"search"
argument_list|,
literal|"forward-search"
argument_list|,
name|class_files
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"reverse-search"
argument_list|,
name|class_files
argument_list|,
name|reverse_search_command
argument_list|,
literal|"Search backward for regular expression (see regex(3)) from last line listed.\n\ The matching line number is also stored as the value of \"$_\"."
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdb_commands
condition|)
block|{
name|add_com_alias
argument_list|(
literal|"/"
argument_list|,
literal|"forward-search"
argument_list|,
name|class_files
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"?"
argument_list|,
literal|"reverse-search"
argument_list|,
name|class_files
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"listsize"
argument_list|,
name|class_support
argument_list|,
name|var_uinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|lines_to_list
argument_list|,
literal|"Set number of source lines gdb will list by default."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

