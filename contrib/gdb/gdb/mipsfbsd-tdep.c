begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*********************************************************************** Copyright 2003-2006 Raza Microelectronics, Inc.(RMI). This is a derived work from software originally provided by the external entity identified below. The licensing terms and warranties specified in the header of the original work apply to this derived work. Contribution by RMI:  *****************************#RMI_1#**********************************/
end_comment

begin_comment
comment|/* Target-dependent code for MIPS systems running NetBSD.    Copyright 2002, 2003 Free Software Foundation, Inc.    Contributed by Wasabi Systems, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"osabi.h"
end_include

begin_include
include|#
directive|include
file|"nbsd-tdep.h"
end_include

begin_include
include|#
directive|include
file|"mipsfbsd-tdep.h"
end_include

begin_include
include|#
directive|include
file|"mips-tdep.h"
end_include

begin_include
include|#
directive|include
file|"solib-svr4.h"
end_include

begin_include
include|#
directive|include
file|<sys/procfs.h>
end_include

begin_include
include|#
directive|include
file|"gregset.h"
end_include

begin_include
include|#
directive|include
file|"trad-frame.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"frame-unwind.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_comment
comment|/* Conveniently, GDB uses the same register numbering as the    ptrace register structure used by NetBSD/mips.  */
end_comment

begin_function
name|void
name|mipsfbsd_supply_reg
parameter_list|(
name|char
modifier|*
name|regs
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|PC_REGNUM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regno
operator|==
name|i
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|CANNOT_FETCH_REGISTER
argument_list|(
name|i
argument_list|)
condition|)
name|supply_register
argument_list|(
name|i
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|supply_register
argument_list|(
name|i
argument_list|,
name|regs
operator|+
operator|(
name|i
operator|*
name|mips_regsize
argument_list|(
name|current_gdbarch
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|supply_gregset
parameter_list|(
name|gdb_gregset_t
modifier|*
name|gregs
parameter_list|)
block|{
name|mipsfbsd_supply_reg
argument_list|(
operator|(
name|char
operator|*
operator|)
name|gregs
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mipsfbsd_fill_reg
parameter_list|(
name|char
modifier|*
name|regs
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|PC_REGNUM
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|regno
operator|==
name|i
operator|||
name|regno
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|!
name|CANNOT_STORE_REGISTER
argument_list|(
name|i
argument_list|)
condition|)
name|regcache_collect
argument_list|(
name|i
argument_list|,
name|regs
operator|+
operator|(
name|i
operator|*
name|mips_regsize
argument_list|(
name|current_gdbarch
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fill_gregset
parameter_list|(
name|gdb_gregset_t
modifier|*
name|gregs
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|mipsfbsd_fill_reg
argument_list|(
operator|(
name|char
operator|*
operator|)
name|gregs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mipsfbsd_supply_fpreg
parameter_list|(
name|char
modifier|*
name|fpregs
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|FP0_REGNUM
init|;
name|i
operator|<=
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|fp_implementation_revision
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|regno
operator|==
name|i
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|CANNOT_FETCH_REGISTER
argument_list|(
name|i
argument_list|)
condition|)
name|supply_register
argument_list|(
name|i
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|supply_register
argument_list|(
name|i
argument_list|,
name|fpregs
operator|+
operator|(
operator|(
name|i
operator|-
name|FP0_REGNUM
operator|)
operator|*
name|mips_regsize
argument_list|(
name|current_gdbarch
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|supply_fpregset
parameter_list|(
name|gdb_fpregset_t
modifier|*
name|fpregs
parameter_list|)
block|{
name|mipsfbsd_supply_fpreg
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fpregs
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mipsfbsd_fill_fpreg
parameter_list|(
name|char
modifier|*
name|fpregs
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|FP0_REGNUM
init|;
name|i
operator|<=
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|fp_control_status
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|regno
operator|==
name|i
operator|||
name|regno
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|!
name|CANNOT_STORE_REGISTER
argument_list|(
name|i
argument_list|)
condition|)
name|regcache_collect
argument_list|(
name|i
argument_list|,
name|fpregs
operator|+
operator|(
operator|(
name|i
operator|-
name|FP0_REGNUM
operator|)
operator|*
name|mips_regsize
argument_list|(
name|current_gdbarch
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fill_fpregset
parameter_list|(
name|gdb_fpregset_t
modifier|*
name|fpregs
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|mipsfbsd_fill_fpreg
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fpregs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fetch_core_registers
parameter_list|(
name|char
modifier|*
name|core_reg_sect
parameter_list|,
name|unsigned
name|core_reg_size
parameter_list|,
name|int
name|which
parameter_list|,
name|CORE_ADDR
name|ignore
parameter_list|)
block|{
name|char
modifier|*
name|regs
decl_stmt|,
modifier|*
name|fpregs
decl_stmt|;
comment|/* We get everything from one section.  */
if|if
condition|(
name|which
operator|!=
literal|0
condition|)
return|return;
name|regs
operator|=
name|core_reg_sect
expr_stmt|;
name|fpregs
operator|=
name|core_reg_sect
operator|+
name|SIZEOF_STRUCT_REG
expr_stmt|;
comment|/* Integer registers.  */
name|mipsfbsd_supply_reg
argument_list|(
name|regs
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Floating point registers.  */
name|mipsfbsd_supply_fpreg
argument_list|(
name|fpregs
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fetch_elfcore_registers
parameter_list|(
name|char
modifier|*
name|core_reg_sect
parameter_list|,
name|unsigned
name|core_reg_size
parameter_list|,
name|int
name|which
parameter_list|,
name|CORE_ADDR
name|ignore
parameter_list|)
block|{
switch|switch
condition|(
name|which
condition|)
block|{
case|case
literal|0
case|:
comment|/* Integer registers.  */
if|if
condition|(
name|core_reg_size
operator|!=
name|SIZEOF_STRUCT_REG
condition|)
name|warning
argument_list|(
literal|"Wrong size register set in core file."
argument_list|)
expr_stmt|;
else|else
name|mipsfbsd_supply_reg
argument_list|(
name|core_reg_sect
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Floating point registers.  */
if|if
condition|(
name|core_reg_size
operator|!=
name|SIZEOF_STRUCT_FPREG
condition|)
name|warning
argument_list|(
literal|"Wrong size register set in core file."
argument_list|)
expr_stmt|;
else|else
name|mipsfbsd_supply_fpreg
argument_list|(
name|core_reg_sect
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Don't know what kind of register request this is; just ignore it.  */
break|break;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|core_fns
name|mipsfbsd_core_fns
init|=
block|{
name|bfd_target_unknown_flavour
block|,
comment|/* core_flavour */
name|default_check_format
block|,
comment|/* check_format */
name|default_core_sniffer
block|,
comment|/* core_sniffer */
name|fetch_core_registers
block|,
comment|/* core_read_registers */
name|NULL
comment|/* next */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|core_fns
name|mipsfbsd_elfcore_fns
init|=
block|{
name|bfd_target_elf_flavour
block|,
comment|/* core_flavour */
name|default_check_format
block|,
comment|/* check_format */
name|default_core_sniffer
block|,
comment|/* core_sniffer */
name|fetch_elfcore_registers
block|,
comment|/* core_read_registers */
name|NULL
comment|/* next */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * MIPSFBSD Offsets  * 0x7fff0000    User high mem -> USRSTACK [64K]  *   * 0x7ffefff0    ps_strings    -> 16 bytes  *  * 0x7ffeffec    sigcode       -> 44 bytes  *  * 0x7ffeffc4    sigcode end   env strings etc start  *  * XXX This is out-of-date and varies by ABI.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_FBSD_SIGTRAMP_START
value|(0x7ffeffc4)
end_define

begin_define
define|#
directive|define
name|MIPS_FBSD_SIGTRAMP_END
value|(0x7ffeffec)
end_define

begin_define
define|#
directive|define
name|MIPS_FBSD_SIGTRAMP_STACK_MOD_START
value|(0x7ffeffc8)
end_define

begin_define
define|#
directive|define
name|MIPS_FBSD_SIGTRAMP_STACK_MOD_END
value|(0x7ffeffd8)
end_define

begin_function
specifier|static
name|LONGEST
name|mipsfbsd_sigtramp_offset
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
return|return
name|pc
operator|<
name|MIPS_FBSD_SIGTRAMP_END
operator|&&
name|pc
operator|>=
name|MIPS_FBSD_SIGTRAMP_START
condition|?
literal|1
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fbsd_pc_in_sigtramp
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
operator|(
name|name
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"__sigtramp"
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mipsfbsd_pc_in_sigtramp
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|char
modifier|*
name|func_name
parameter_list|)
block|{
return|return
operator|(
name|fbsd_pc_in_sigtramp
argument_list|(
name|pc
argument_list|,
name|func_name
argument_list|)
operator|||
name|mipsfbsd_sigtramp_offset
argument_list|(
name|pc
argument_list|)
operator|>=
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_sigtramp_sp_modified
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
return|return
operator|(
name|pc
operator|>=
name|MIPS_FBSD_SIGTRAMP_STACK_MOD_START
operator|&&
name|pc
operator|<=
name|MIPS_FBSD_SIGTRAMP_STACK_MOD_END
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Figure out where the longjmp will land.  We expect that we have    just entered longjmp and haven't yet setup the stack frame, so    the args are still in the argument regs.  A0_REGNUM points at the    jmp_buf structure from which we extract the PC that we will land    at.  The PC is copied into *pc.  This routine returns true on    success.  */
end_comment

begin_define
define|#
directive|define
name|FBSD_MIPS_JB_PC
value|(12)
end_define

begin_define
define|#
directive|define
name|FBSD_MIPS_JB_ELEMENT_SIZE
value|mips_regsize (current_gdbarch)
end_define

begin_define
define|#
directive|define
name|FBSD_MIPS_JB_OFFSET
value|(FBSD_MIPS_JB_PC * \ 					 FBSD_MIPS_JB_ELEMENT_SIZE)
end_define

begin_function
specifier|static
name|int
name|mipsfbsd_get_longjmp_target
parameter_list|(
name|CORE_ADDR
modifier|*
name|pc
parameter_list|)
block|{
name|CORE_ADDR
name|jb_addr
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|alloca
argument_list|(
name|FBSD_MIPS_JB_ELEMENT_SIZE
argument_list|)
expr_stmt|;
name|jb_addr
operator|=
name|read_register
argument_list|(
name|A0_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|jb_addr
operator|+
name|FBSD_MIPS_JB_OFFSET
argument_list|,
name|buf
argument_list|,
name|FBSD_MIPS_JB_ELEMENT_SIZE
argument_list|)
condition|)
return|return
literal|0
return|;
operator|*
name|pc
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|FBSD_MIPS_JB_ELEMENT_SIZE
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mipsfbsd_cannot_fetch_register
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
return|return
operator|(
name|regno
operator|==
name|ZERO_REGNUM
operator|||
name|regno
operator|==
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|fp_implementation_revision
operator|)
return|;
comment|/* XXX TODO: Are there other registers that we cannot fetch ? */
block|}
end_function

begin_function
specifier|static
name|int
name|mipsfbsd_cannot_store_register
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
return|return
operator|(
name|regno
operator|==
name|ZERO_REGNUM
operator|||
name|regno
operator|==
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|fp_implementation_revision
operator|)
return|;
comment|/* XXX TODO: Are there other registers that we cannot write ? */
block|}
end_function

begin_comment
comment|/*   * This structure is defined in mips-tdep.c.   */
end_comment

begin_struct
struct|struct
name|mips_frame_cache
block|{
name|CORE_ADDR
name|base
decl_stmt|;
name|struct
name|trad_frame_saved_reg
modifier|*
name|saved_regs
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Prologue cache for sigtramp frame   * When we land in sigtramp, sigcontext is saved on the  * stack just below the sigtramp's stack frame. We have  * the Registers saved at fixed offsets on the stack.  */
end_comment

begin_define
define|#
directive|define
name|MIPS_FBSD_SIGTRAMP_STACK_SIZE
value|(48)
end_define

begin_define
define|#
directive|define
name|MIPS_FBSD_SIGCONTEXT_REG_OFFSET
value|(32)
end_define

begin_function
specifier|static
name|struct
name|mips_frame_cache
modifier|*
name|mipsfbsd_sigtramp_frame_cache
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|)
block|{
name|struct
name|mips_frame_cache
modifier|*
name|cache
decl_stmt|;
name|CORE_ADDR
name|gregs_addr
decl_stmt|,
name|sp
decl_stmt|,
name|pc
decl_stmt|;
name|int
name|regnum
decl_stmt|;
name|int
name|sigtramp_stack_size
decl_stmt|;
if|if
condition|(
operator|*
name|this_cache
condition|)
return|return
operator|*
name|this_cache
return|;
name|cache
operator|=
name|FRAME_OBSTACK_ZALLOC
argument_list|(
expr|struct
name|mips_frame_cache
argument_list|)
expr_stmt|;
operator|*
name|this_cache
operator|=
name|cache
expr_stmt|;
name|cache
operator|->
name|saved_regs
operator|=
name|trad_frame_alloc_saved_regs
argument_list|(
name|next_frame
argument_list|)
expr_stmt|;
comment|/*     * Get sp of next frame which is the adjusted sp of    * tramp code.    */
name|sp
operator|=
name|frame_unwind_register_unsigned
argument_list|(
name|next_frame
argument_list|,
name|NUM_REGS
operator|+
name|SP_REGNUM
argument_list|)
expr_stmt|;
name|pc
operator|=
name|frame_unwind_register_unsigned
argument_list|(
name|next_frame
argument_list|,
name|NUM_REGS
operator|+
name|PC_REGNUM
argument_list|)
expr_stmt|;
name|sigtramp_stack_size
operator|=
name|is_sigtramp_sp_modified
argument_list|(
name|pc
argument_list|)
condition|?
name|MIPS_FBSD_SIGTRAMP_STACK_SIZE
else|:
literal|0
expr_stmt|;
name|gregs_addr
operator|=
name|sp
operator|+
name|sigtramp_stack_size
operator|+
name|MIPS_FBSD_SIGCONTEXT_REG_OFFSET
expr_stmt|;
for|for
control|(
name|regnum
operator|=
literal|0
init|;
name|regnum
operator|<
name|PC_REGNUM
condition|;
name|regnum
operator|++
control|)
block|{
name|cache
operator|->
name|saved_regs
index|[
name|NUM_REGS
operator|+
name|regnum
index|]
operator|.
name|addr
operator|=
name|gregs_addr
operator|+
name|regnum
operator|*
name|mips_regsize
argument_list|(
name|current_gdbarch
argument_list|)
expr_stmt|;
block|}
comment|/* Only retrieve PC and SP */
name|cache
operator|->
name|saved_regs
index|[
name|NUM_REGS
operator|+
name|SP_REGNUM
index|]
operator|.
name|addr
operator|=
name|gregs_addr
operator|+
name|SP_REGNUM
operator|*
operator|(
name|mips_regsize
argument_list|(
name|current_gdbarch
argument_list|)
operator|)
expr_stmt|;
name|cache
operator|->
name|saved_regs
index|[
name|NUM_REGS
operator|+
name|RA_REGNUM
index|]
operator|.
name|addr
operator|=
name|gregs_addr
operator|+
name|RA_REGNUM
operator|*
operator|(
name|mips_regsize
argument_list|(
name|current_gdbarch
argument_list|)
operator|)
expr_stmt|;
name|cache
operator|->
name|base
operator|=
name|get_frame_memory_unsigned
argument_list|(
name|next_frame
argument_list|,
name|cache
operator|->
name|saved_regs
index|[
name|NUM_REGS
operator|+
name|SP_REGNUM
index|]
operator|.
name|addr
argument_list|,
name|mips_regsize
argument_list|(
name|current_gdbarch
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Todo: Floating point registers */
name|cache
operator|->
name|saved_regs
index|[
name|NUM_REGS
operator|+
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|pc
index|]
operator|=
name|cache
operator|->
name|saved_regs
index|[
name|NUM_REGS
operator|+
name|RA_REGNUM
index|]
expr_stmt|;
return|return
operator|*
name|this_cache
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mipsfbsd_sigtramp_frame_this_id
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|,
name|struct
name|frame_id
modifier|*
name|this_id
parameter_list|)
block|{
name|struct
name|mips_frame_cache
modifier|*
name|cache
init|=
name|mipsfbsd_sigtramp_frame_cache
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|)
decl_stmt|;
operator|(
operator|*
name|this_id
operator|)
operator|=
name|frame_id_build
argument_list|(
name|cache
operator|->
name|base
argument_list|,
name|cache
operator|->
name|saved_regs
index|[
name|NUM_REGS
operator|+
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|pc
index|]
operator|.
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mipsfbsd_sigtramp_frame_prev_register
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|int
modifier|*
name|optimizedp
parameter_list|,
name|enum
name|lval_type
modifier|*
name|lvalp
parameter_list|,
name|CORE_ADDR
modifier|*
name|addrp
parameter_list|,
name|int
modifier|*
name|realnump
parameter_list|,
name|void
modifier|*
name|valuep
parameter_list|)
block|{
name|struct
name|mips_frame_cache
modifier|*
name|cache
init|=
name|mipsfbsd_sigtramp_frame_cache
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|)
decl_stmt|;
name|trad_frame_prev_register
argument_list|(
name|next_frame
argument_list|,
name|cache
operator|->
name|saved_regs
argument_list|,
name|regnum
argument_list|,
name|optimizedp
argument_list|,
name|lvalp
argument_list|,
name|addrp
argument_list|,
name|realnump
argument_list|,
name|valuep
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|frame_unwind
name|mipsfbsd_sigtramp_frame_unwind
init|=
block|{
name|SIGTRAMP_FRAME
block|,
name|mipsfbsd_sigtramp_frame_this_id
block|,
name|mipsfbsd_sigtramp_frame_prev_register
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|struct
name|frame_unwind
modifier|*
name|mipsfbsd_sigtramp_frame_sniffer
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
name|CORE_ADDR
name|pc
init|=
name|frame_pc_unwind
argument_list|(
name|next_frame
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
operator|&
name|name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mipsfbsd_pc_in_sigtramp
argument_list|(
name|pc
argument_list|,
name|name
argument_list|)
condition|)
return|return
operator|&
name|mipsfbsd_sigtramp_frame_unwind
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Find out if PC has landed into dynamic library stub.  * We can find it by seeing if the name of the object  * file section where the PC lies is "MIPS.stubs"  */
end_comment

begin_function
name|int
name|mipsfbsd_in_stub_section
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|obj_section
modifier|*
name|s
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|find_pc_section
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|(
name|s
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|the_bfd_section
operator|->
name|name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|s
operator|->
name|the_bfd_section
operator|->
name|name
argument_list|,
literal|".MIPS.stubs"
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Prologue cache for dynamic library stub frame.  * This stub does not modify the SP, so we set the  * cache base to calling frame's SP  */
end_comment

begin_function
specifier|static
name|struct
name|mips_frame_cache
modifier|*
name|mipsfbsd_stub_frame_cache
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|)
block|{
name|struct
name|mips_frame_cache
modifier|*
name|cache
decl_stmt|;
if|if
condition|(
operator|*
name|this_cache
condition|)
return|return
operator|*
name|this_cache
return|;
name|cache
operator|=
name|FRAME_OBSTACK_ZALLOC
argument_list|(
expr|struct
name|mips_frame_cache
argument_list|)
expr_stmt|;
operator|*
name|this_cache
operator|=
name|cache
expr_stmt|;
name|cache
operator|->
name|saved_regs
operator|=
name|trad_frame_alloc_saved_regs
argument_list|(
name|next_frame
argument_list|)
expr_stmt|;
name|cache
operator|->
name|saved_regs
index|[
name|NUM_REGS
operator|+
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|pc
index|]
operator|.
name|realreg
operator|=
name|NUM_REGS
operator|+
name|RA_REGNUM
expr_stmt|;
name|cache
operator|->
name|base
operator|=
name|frame_unwind_register_unsigned
argument_list|(
name|next_frame
argument_list|,
name|NUM_REGS
operator|+
name|SP_REGNUM
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|this_cache
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mipsfbsd_stub_frame_this_id
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|,
name|struct
name|frame_id
modifier|*
name|this_id
parameter_list|)
block|{
name|struct
name|mips_frame_cache
modifier|*
name|cache
init|=
name|mipsfbsd_stub_frame_cache
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|)
decl_stmt|;
operator|(
operator|*
name|this_id
operator|)
operator|=
name|frame_id_build
argument_list|(
name|cache
operator|->
name|base
argument_list|,
name|cache
operator|->
name|saved_regs
index|[
name|NUM_REGS
operator|+
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|pc
index|]
operator|.
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mipsfbsd_stub_frame_prev_register
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|int
modifier|*
name|optimizedp
parameter_list|,
name|enum
name|lval_type
modifier|*
name|lvalp
parameter_list|,
name|CORE_ADDR
modifier|*
name|addrp
parameter_list|,
name|int
modifier|*
name|realnump
parameter_list|,
name|void
modifier|*
name|valuep
parameter_list|)
block|{
name|struct
name|mips_frame_cache
modifier|*
name|cache
init|=
name|mipsfbsd_stub_frame_cache
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|)
decl_stmt|;
name|trad_frame_prev_register
argument_list|(
name|next_frame
argument_list|,
name|cache
operator|->
name|saved_regs
argument_list|,
name|regnum
argument_list|,
name|optimizedp
argument_list|,
name|lvalp
argument_list|,
name|addrp
argument_list|,
name|realnump
argument_list|,
name|valuep
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|frame_unwind
name|mipsfbsd_stub_frame_unwind
init|=
block|{
name|NORMAL_FRAME
block|,
name|mipsfbsd_stub_frame_this_id
block|,
name|mipsfbsd_stub_frame_prev_register
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|struct
name|frame_unwind
modifier|*
name|mipsfbsd_stub_frame_sniffer
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
name|CORE_ADDR
name|pc
init|=
name|frame_pc_unwind
argument_list|(
name|next_frame
argument_list|)
decl_stmt|;
if|if
condition|(
name|mipsfbsd_in_stub_section
argument_list|(
name|pc
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|&
name|mipsfbsd_stub_frame_unwind
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  *  typedef struct link_map {  *          caddr_t         l_addr;                 /* Base Address of library  *  #ifdef __mips__  *          caddr_t         l_offs;                 /* Load Offset of library  *  #endif  *          const char      *l_name;                /* Absolute Path to Library  *          const void      *l_ld;                  /* Pointer to .dynamic in memory  *          struct link_map *l_next, *l_prev;       /* linked list of of mapped libs  *  } Link_map;  *  *  struct r_debug {  *          int             r_version;              /* not used  *          struct link_map *r_map;                 /* list of loaded images  *          void            (*r_brk)(struct r_debug *, struct link_map *);  *                                                  /* pointer to break point  *          enum {  *              RT_CONSISTENT,                      /* things are stable  *              RT_ADD,                             /* adding a shared library  *              RT_DELETE                           /* removing a shared library  *          }               r_state;  *  };  *  */
end_comment

begin_function
specifier|static
name|struct
name|link_map_offsets
modifier|*
name|mipsfbsd_ilp32_solib_svr4_fetch_link_map_offsets
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|struct
name|link_map_offsets
name|lmo
decl_stmt|;
specifier|static
name|struct
name|link_map_offsets
modifier|*
name|lmp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|lmp
operator|==
name|NULL
condition|)
block|{
name|lmp
operator|=
operator|&
name|lmo
expr_stmt|;
name|lmo
operator|.
name|r_debug_size
operator|=
literal|16
expr_stmt|;
name|lmo
operator|.
name|r_map_offset
operator|=
literal|4
expr_stmt|;
name|lmo
operator|.
name|r_map_size
operator|=
literal|4
expr_stmt|;
name|lmo
operator|.
name|link_map_size
operator|=
literal|24
expr_stmt|;
name|lmo
operator|.
name|l_addr_offset
operator|=
literal|0
expr_stmt|;
name|lmo
operator|.
name|l_addr_size
operator|=
literal|4
expr_stmt|;
name|lmo
operator|.
name|l_name_offset
operator|=
literal|8
expr_stmt|;
name|lmo
operator|.
name|l_name_size
operator|=
literal|4
expr_stmt|;
name|lmo
operator|.
name|l_next_offset
operator|=
literal|16
expr_stmt|;
name|lmo
operator|.
name|l_next_size
operator|=
literal|4
expr_stmt|;
name|lmo
operator|.
name|l_prev_offset
operator|=
literal|20
expr_stmt|;
name|lmo
operator|.
name|l_prev_size
operator|=
literal|4
expr_stmt|;
block|}
return|return
name|lmp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mipsfbsd_init_abi
parameter_list|(
name|struct
name|gdbarch_info
name|info
parameter_list|,
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|)
block|{
name|set_gdbarch_pc_in_sigtramp
argument_list|(
name|gdbarch
argument_list|,
name|mipsfbsd_pc_in_sigtramp
argument_list|)
expr_stmt|;
name|set_gdbarch_get_longjmp_target
argument_list|(
name|gdbarch
argument_list|,
name|mipsfbsd_get_longjmp_target
argument_list|)
expr_stmt|;
name|set_gdbarch_cannot_fetch_register
argument_list|(
name|gdbarch
argument_list|,
name|mipsfbsd_cannot_fetch_register
argument_list|)
expr_stmt|;
name|set_gdbarch_cannot_store_register
argument_list|(
name|gdbarch
argument_list|,
name|mipsfbsd_cannot_store_register
argument_list|)
expr_stmt|;
name|set_gdbarch_software_single_step
argument_list|(
name|gdbarch
argument_list|,
name|mips_software_single_step
argument_list|)
expr_stmt|;
name|set_solib_svr4_fetch_link_map_offsets
argument_list|(
name|gdbarch
argument_list|,
name|mipsfbsd_ilp32_solib_svr4_fetch_link_map_offsets
argument_list|)
expr_stmt|;
name|set_gdbarch_skip_trampoline_code
argument_list|(
name|gdbarch
argument_list|,
name|find_solib_trampoline_target
argument_list|)
expr_stmt|;
name|set_gdbarch_in_solib_call_trampoline
argument_list|(
name|gdbarch
argument_list|,
name|mipsfbsd_in_stub_section
argument_list|)
expr_stmt|;
comment|/* frame sniffers */
name|frame_unwind_append_sniffer
argument_list|(
name|gdbarch
argument_list|,
name|mipsfbsd_sigtramp_frame_sniffer
argument_list|)
expr_stmt|;
name|frame_unwind_append_sniffer
argument_list|(
name|gdbarch
argument_list|,
name|mipsfbsd_stub_frame_sniffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_mipsfbsd_tdep
parameter_list|(
name|void
parameter_list|)
block|{
name|gdbarch_register_osabi
argument_list|(
name|bfd_arch_mips
argument_list|,
literal|0
argument_list|,
name|GDB_OSABI_FREEBSD_ELF
argument_list|,
name|mipsfbsd_init_abi
argument_list|)
expr_stmt|;
name|add_core_fns
argument_list|(
operator|&
name|mipsfbsd_core_fns
argument_list|)
expr_stmt|;
name|add_core_fns
argument_list|(
operator|&
name|mipsfbsd_elfcore_fns
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

