begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Sequent Symmetry host interface, for GDB when running under Unix.    Copyright 1986, 1987, 1989, 1991, 1992, 1994 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* FIXME, some 387-specific items of use taken from i387-tdep.c -- ought to be    merged back in. */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_comment
comment|/* FIXME: What is the _INKERNEL define for?  */
end_comment

begin_define
define|#
directive|define
name|_INKERNEL
end_define

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_undef
undef|#
directive|undef
name|_INKERNEL
end_undef

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_SEQUENT_
end_ifdef

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Dynix has only machine/ptrace.h, which is already included by sys/user.h  */
end_comment

begin_comment
comment|/* Dynix has no mptrace call */
end_comment

begin_define
define|#
directive|define
name|mptrace
value|ptrace
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_define
define|#
directive|define
name|TERMINAL
value|struct sgttyb
end_define

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_function
name|void
name|store_inferior_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|struct
name|pt_regset
name|regs
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
comment|/* FIXME: Fetching the registers is a kludge to initialize all elements      in the fpu and fpa status. This works for normal debugging, but      might cause problems when calling functions in the inferior.      At least fpu_control and fpa_pcr (probably more) should be added       to the registers array to solve this properly.  */
name|mptrace
argument_list|(
name|XPT_RREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|regs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|regs
operator|.
name|pr_eax
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|0
argument_list|)
index|]
expr_stmt|;
name|regs
operator|.
name|pr_ebx
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|5
argument_list|)
index|]
expr_stmt|;
name|regs
operator|.
name|pr_ecx
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|2
argument_list|)
index|]
expr_stmt|;
name|regs
operator|.
name|pr_edx
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|1
argument_list|)
index|]
expr_stmt|;
name|regs
operator|.
name|pr_esi
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|6
argument_list|)
index|]
expr_stmt|;
name|regs
operator|.
name|pr_edi
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|7
argument_list|)
index|]
expr_stmt|;
name|regs
operator|.
name|pr_esp
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|14
argument_list|)
index|]
expr_stmt|;
name|regs
operator|.
name|pr_ebp
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|15
argument_list|)
index|]
expr_stmt|;
name|regs
operator|.
name|pr_eip
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|16
argument_list|)
index|]
expr_stmt|;
name|regs
operator|.
name|pr_flags
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|17
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|31
condition|;
name|i
operator|++
control|)
block|{
name|regs
operator|.
name|pr_fpa
operator|.
name|fpa_regs
index|[
name|i
index|]
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FP1_REGNUM
operator|+
name|i
argument_list|)
index|]
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|regs
operator|.
name|pr_fpu
operator|.
name|fpu_stack
index|[
literal|0
index|]
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|ST0_REGNUM
argument_list|)
index|]
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|regs
operator|.
name|pr_fpu
operator|.
name|fpu_stack
index|[
literal|1
index|]
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|ST1_REGNUM
argument_list|)
index|]
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|regs
operator|.
name|pr_fpu
operator|.
name|fpu_stack
index|[
literal|2
index|]
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|ST2_REGNUM
argument_list|)
index|]
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|regs
operator|.
name|pr_fpu
operator|.
name|fpu_stack
index|[
literal|3
index|]
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|ST3_REGNUM
argument_list|)
index|]
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|regs
operator|.
name|pr_fpu
operator|.
name|fpu_stack
index|[
literal|4
index|]
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|ST4_REGNUM
argument_list|)
index|]
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|regs
operator|.
name|pr_fpu
operator|.
name|fpu_stack
index|[
literal|5
index|]
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|ST5_REGNUM
argument_list|)
index|]
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|regs
operator|.
name|pr_fpu
operator|.
name|fpu_stack
index|[
literal|6
index|]
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|ST6_REGNUM
argument_list|)
index|]
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|regs
operator|.
name|pr_fpu
operator|.
name|fpu_stack
index|[
literal|7
index|]
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|ST7_REGNUM
argument_list|)
index|]
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|mptrace
argument_list|(
name|XPT_WREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|regs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fetch_inferior_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|pt_regset
name|regs
decl_stmt|;
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
name|registers_fetched
argument_list|()
expr_stmt|;
name|mptrace
argument_list|(
name|XPT_RREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|regs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|EAX_REGNUM
argument_list|)
index|]
operator|=
name|regs
operator|.
name|pr_eax
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|EBX_REGNUM
argument_list|)
index|]
operator|=
name|regs
operator|.
name|pr_ebx
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|ECX_REGNUM
argument_list|)
index|]
operator|=
name|regs
operator|.
name|pr_ecx
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|EDX_REGNUM
argument_list|)
index|]
operator|=
name|regs
operator|.
name|pr_edx
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|ESI_REGNUM
argument_list|)
index|]
operator|=
name|regs
operator|.
name|pr_esi
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|EDI_REGNUM
argument_list|)
index|]
operator|=
name|regs
operator|.
name|pr_edi
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|EBP_REGNUM
argument_list|)
index|]
operator|=
name|regs
operator|.
name|pr_ebp
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|ESP_REGNUM
argument_list|)
index|]
operator|=
name|regs
operator|.
name|pr_esp
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|EIP_REGNUM
argument_list|)
index|]
operator|=
name|regs
operator|.
name|pr_eip
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|EFLAGS_REGNUM
argument_list|)
index|]
operator|=
name|regs
operator|.
name|pr_flags
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FPA_NREGS
condition|;
name|i
operator|++
control|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FP1_REGNUM
operator|+
name|i
argument_list|)
index|]
operator|=
name|regs
operator|.
name|pr_fpa
operator|.
name|fpa_regs
index|[
name|i
index|]
expr_stmt|;
block|}
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|ST0_REGNUM
argument_list|)
index|]
argument_list|,
name|regs
operator|.
name|pr_fpu
operator|.
name|fpu_stack
index|[
literal|0
index|]
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|ST1_REGNUM
argument_list|)
index|]
argument_list|,
name|regs
operator|.
name|pr_fpu
operator|.
name|fpu_stack
index|[
literal|1
index|]
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|ST2_REGNUM
argument_list|)
index|]
argument_list|,
name|regs
operator|.
name|pr_fpu
operator|.
name|fpu_stack
index|[
literal|2
index|]
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|ST3_REGNUM
argument_list|)
index|]
argument_list|,
name|regs
operator|.
name|pr_fpu
operator|.
name|fpu_stack
index|[
literal|3
index|]
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|ST4_REGNUM
argument_list|)
index|]
argument_list|,
name|regs
operator|.
name|pr_fpu
operator|.
name|fpu_stack
index|[
literal|4
index|]
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|ST5_REGNUM
argument_list|)
index|]
argument_list|,
name|regs
operator|.
name|pr_fpu
operator|.
name|fpu_stack
index|[
literal|5
index|]
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|ST6_REGNUM
argument_list|)
index|]
argument_list|,
name|regs
operator|.
name|pr_fpu
operator|.
name|fpu_stack
index|[
literal|6
index|]
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|ST7_REGNUM
argument_list|)
index|]
argument_list|,
name|regs
operator|.
name|pr_fpu
operator|.
name|fpu_stack
index|[
literal|7
index|]
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* FIXME:  This should be merged with i387-tdep.c as well. */
end_comment

begin_expr_stmt
specifier|static
name|print_fpu_status
argument_list|(
argument|ep
argument_list|)
expr|struct
name|pt_regset
name|ep
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|int
name|bothstatus
decl_stmt|;
name|int
name|top
decl_stmt|;
name|int
name|fpreg
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|printf_unfiltered
argument_list|(
literal|"80387:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_ip
operator|==
literal|0
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|" not in use.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|printf_unfiltered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_status
operator|!=
literal|0
condition|)
block|{
name|print_387_status_word
argument_list|(
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_status
argument_list|)
expr_stmt|;
block|}
name|print_387_control_word
argument_list|(
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_control
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"last exception: "
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"opcode 0x%x; "
argument_list|,
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_rsvd4
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"pc 0x%x:0x%x; "
argument_list|,
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_cs
argument_list|,
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_ip
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"operand 0x%x:0x%x\n"
argument_list|,
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_data_offset
argument_list|,
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_op_sel
argument_list|)
expr_stmt|;
name|top
operator|=
operator|(
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_status
operator|>>
literal|11
operator|)
operator|&
literal|7
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"regno  tag  msb              lsb  value\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|fpreg
operator|=
literal|7
init|;
name|fpreg
operator|>=
literal|0
condition|;
name|fpreg
operator|--
control|)
block|{
name|double
name|val
decl_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%s %d: "
argument_list|,
name|fpreg
operator|==
name|top
condition|?
literal|"=>"
else|:
literal|"  "
argument_list|,
name|fpreg
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_tag
operator|>>
operator|(
name|fpreg
operator|*
literal|2
operator|)
operator|)
operator|&
literal|3
condition|)
block|{
case|case
literal|0
case|:
name|printf_unfiltered
argument_list|(
literal|"valid "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|printf_unfiltered
argument_list|(
literal|"zero  "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printf_unfiltered
argument_list|(
literal|"trap  "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|printf_unfiltered
argument_list|(
literal|"empty "
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|9
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|printf_unfiltered
argument_list|(
literal|"%02x"
argument_list|,
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_stack
index|[
name|fpreg
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i387_to_double
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_stack
index|[
name|fpreg
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|val
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"  %g\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_rsvd1
condition|)
name|warning
argument_list|(
literal|"rsvd1 is 0x%x\n"
argument_list|,
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_rsvd1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_rsvd2
condition|)
name|warning
argument_list|(
literal|"rsvd2 is 0x%x\n"
argument_list|,
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_rsvd2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_rsvd3
condition|)
name|warning
argument_list|(
literal|"rsvd3 is 0x%x\n"
argument_list|,
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_rsvd3
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_rsvd5
condition|)
name|warning
argument_list|(
literal|"rsvd5 is 0x%x\n"
argument_list|,
name|ep
operator|.
name|pr_fpu
operator|.
name|fpu_rsvd5
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|print_1167_control_word
argument_list|(
argument|pcr
argument_list|)
end_macro

begin_decl_stmt
name|unsigned
name|int
name|pcr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|pcr_tmp
decl_stmt|;
name|pcr_tmp
operator|=
name|pcr
operator|&
name|FPA_PCR_MODE
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"\tMODE= %#x; RND= %#x "
argument_list|,
name|pcr_tmp
argument_list|,
name|pcr_tmp
operator|&
literal|12
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pcr_tmp
operator|&
literal|12
condition|)
block|{
case|case
literal|0
case|:
name|printf_unfiltered
argument_list|(
literal|"RN (Nearest Value)"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|printf_unfiltered
argument_list|(
literal|"RZ (Zero)"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printf_unfiltered
argument_list|(
literal|"RP (Positive Infinity)"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|printf_unfiltered
argument_list|(
literal|"RM (Negative Infinity)"
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf_unfiltered
argument_list|(
literal|"; IRND= %d "
argument_list|,
name|pcr_tmp
operator|&
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|pcr_tmp
operator|&
literal|2
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"(same as RND)\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_unfiltered
argument_list|(
literal|"(toward zero)\n"
argument_list|)
expr_stmt|;
block|}
name|pcr_tmp
operator|=
name|pcr
operator|&
name|FPA_PCR_EM
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"\tEM= %#x"
argument_list|,
name|pcr_tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_EM_DM
condition|)
name|printf_unfiltered
argument_list|(
literal|" DM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_EM_UOM
condition|)
name|printf_unfiltered
argument_list|(
literal|" UOM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_EM_PM
condition|)
name|printf_unfiltered
argument_list|(
literal|" PM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_EM_UM
condition|)
name|printf_unfiltered
argument_list|(
literal|" UM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_EM_OM
condition|)
name|printf_unfiltered
argument_list|(
literal|" OM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_EM_ZM
condition|)
name|printf_unfiltered
argument_list|(
literal|" ZM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_EM_IM
condition|)
name|printf_unfiltered
argument_list|(
literal|" IM"
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|pcr_tmp
operator|=
name|FPA_PCR_CC
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"\tCC= %#x"
argument_list|,
name|pcr_tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_20MHZ
condition|)
name|printf_unfiltered
argument_list|(
literal|" 20MHZ"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_CC_Z
condition|)
name|printf_unfiltered
argument_list|(
literal|" Z"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_CC_C2
condition|)
name|printf_unfiltered
argument_list|(
literal|" C2"
argument_list|)
expr_stmt|;
comment|/* Dynix defines FPA_PCR_CC_C0 to 0x100 and ptx defines        FPA_PCR_CC_C1 to 0x100.  Use whichever is defined and assume        the OS knows what it is doing.  */
ifdef|#
directive|ifdef
name|FPA_PCR_CC_C1
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_CC_C1
condition|)
name|printf_unfiltered
argument_list|(
literal|" C1"
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_CC_C0
condition|)
name|printf_unfiltered
argument_list|(
literal|" C0"
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|pcr_tmp
condition|)
block|{
case|case
name|FPA_PCR_CC_Z
case|:
name|printf_unfiltered
argument_list|(
literal|" (Equal)"
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|FPA_PCR_CC_C1
case|case
name|FPA_PCR_CC_C1
case|:
else|#
directive|else
case|case
name|FPA_PCR_CC_C0
case|:
endif|#
directive|endif
name|printf_unfiltered
argument_list|(
literal|" (Less than)"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|printf_unfiltered
argument_list|(
literal|" (Greater than)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FPA_PCR_CC_Z
operator||
ifdef|#
directive|ifdef
name|FPA_PCR_CC_C1
name|FPA_PCR_CC_C1
else|#
directive|else
name|FPA_PCR_CC_C0
endif|#
directive|endif
operator||
name|FPA_PCR_CC_C2
case|:
name|printf_unfiltered
argument_list|(
literal|" (Unordered)"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf_unfiltered
argument_list|(
literal|" (Undefined)"
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf_unfiltered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|pcr_tmp
operator|=
name|pcr
operator|&
name|FPA_PCR_AE
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"\tAE= %#x"
argument_list|,
name|pcr_tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_AE_DE
condition|)
name|printf_unfiltered
argument_list|(
literal|" DE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_AE_UOE
condition|)
name|printf_unfiltered
argument_list|(
literal|" UOE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_AE_PE
condition|)
name|printf_unfiltered
argument_list|(
literal|" PE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_AE_UE
condition|)
name|printf_unfiltered
argument_list|(
literal|" UE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_AE_OE
condition|)
name|printf_unfiltered
argument_list|(
literal|" OE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_AE_ZE
condition|)
name|printf_unfiltered
argument_list|(
literal|" ZE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_AE_EE
condition|)
name|printf_unfiltered
argument_list|(
literal|" EE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcr_tmp
operator|&
name|FPA_PCR_AE_IE
condition|)
name|printf_unfiltered
argument_list|(
literal|" IE"
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|print_1167_regs
argument_list|(
argument|regs
argument_list|)
end_macro

begin_decl_stmt
name|long
name|regs
index|[
name|FPA_NREGS
index|]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
union|union
block|{
name|double
name|d
decl_stmt|;
name|long
name|l
index|[
literal|2
index|]
decl_stmt|;
block|}
name|xd
union|;
union|union
block|{
name|float
name|f
decl_stmt|;
name|long
name|l
decl_stmt|;
block|}
name|xf
union|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FPA_NREGS
condition|;
name|i
operator|++
control|)
block|{
name|xf
operator|.
name|l
operator|=
name|regs
index|[
name|i
index|]
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%%fp%d: raw= %#x, single= %f"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|regs
index|[
name|i
index|]
argument_list|,
name|xf
operator|.
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|i
operator|&
literal|1
operator|)
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xd
operator|.
name|l
index|[
literal|1
index|]
operator|=
name|regs
index|[
name|i
index|]
expr_stmt|;
name|xd
operator|.
name|l
index|[
literal|0
index|]
operator|=
name|regs
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|", double= %f\n"
argument_list|,
name|xd
operator|.
name|d
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|print_fpa_status
argument_list|(
argument|ep
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|pt_regset
name|ep
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf_unfiltered
argument_list|(
literal|"WTL 1167:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|.
name|pr_fpa
operator|.
name|fpa_pcr
operator|!=
literal|0
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|print_1167_control_word
argument_list|(
name|ep
operator|.
name|pr_fpa
operator|.
name|fpa_pcr
argument_list|)
expr_stmt|;
name|print_1167_regs
argument_list|(
name|ep
operator|.
name|pr_fpa
operator|.
name|fpa_regs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_unfiltered
argument_list|(
literal|" not in use.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* disabled because it doesn't go through the target vector.  */
end_comment

begin_comment
unit|i386_float_info () {   char ubuf[UPAGES*NBPG];   struct pt_regset regset;    if (have_inferior_p())     {       PTRACE_READ_REGS (inferior_pid, (PTRACE_ARG3_TYPE)&regset);     }   else     {       int corechan = bfd_cache_lookup (core_bfd);       if (lseek (corechan, 0, 0)< 0) 	{ 	  perror ("seek on core file"); 	}       if (myread (corechan, ubuf, UPAGES*NBPG)< 0) 	{ 	  perror ("read on core file"); 	}
comment|/* only interested in the floating point registers */
end_comment

begin_endif
unit|regset.pr_fpu = ((struct user *) ubuf)->u_fpusave;       regset.pr_fpa = ((struct user *) ubuf)->u_fpasave;     }   print_fpu_status(regset);   print_fpa_status(regset); }
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|got_sigchld
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_comment
comment|/* This will eventually be more interesting. */
end_comment

begin_function
name|void
name|sigchld_handler
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|got_sigchld
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Signals for which the default action does not cause the process  * to die.  See<sys/signal.h> for where this came from (alas, we  * can't use those macros directly)  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|sigmask
end_ifndef

begin_define
define|#
directive|define
name|sigmask
parameter_list|(
name|s
parameter_list|)
value|(1<< ((s) - 1))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SIGNALS_DFL_SAFE
value|sigmask(SIGSTOP) | sigmask(SIGTSTP) | \ 	sigmask(SIGTTIN) | sigmask(SIGTTOU) | sigmask(SIGCHLD) | \ 	sigmask(SIGCONT) | sigmask(SIGWINCH) | sigmask(SIGPWR) | \ 	sigmask(SIGURG) | sigmask(SIGPOLL)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|ATTACH_DETACH
end_ifdef

begin_comment
comment|/*  * Thanks to XPT_MPDEBUGGER, we have to mange child_wait().  */
end_comment

begin_function
name|int
name|child_wait
parameter_list|(
name|pid
parameter_list|,
name|status
parameter_list|)
name|int
name|pid
decl_stmt|;
name|struct
name|target_waitstatus
modifier|*
name|status
decl_stmt|;
block|{
name|int
name|save_errno
decl_stmt|,
name|rv
decl_stmt|,
name|xvaloff
decl_stmt|,
name|saoff
decl_stmt|,
name|sa_hand
decl_stmt|;
name|struct
name|pt_stop
name|pt
decl_stmt|;
name|struct
name|user
name|u
decl_stmt|;
name|sigset_t
name|set
decl_stmt|;
comment|/* Host signal number for a signal which the inferior terminates with, or      0 if it hasn't terminated due to a signal.  */
specifier|static
name|int
name|death_by_signal
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|SVR4_SHARED_LIBS
comment|/* use this to distinguish ptx 2 vs ptx 4 */
name|prstatus_t
name|pstatus
decl_stmt|;
endif|#
directive|endif
do|do
block|{
name|set_sigint_trap
argument_list|()
expr_stmt|;
comment|/* Causes SIGINT to be passed on to the 			   attached process. */
name|save_errno
operator|=
name|errno
expr_stmt|;
name|got_sigchld
operator|=
literal|0
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
while|while
condition|(
name|got_sigchld
operator|==
literal|0
condition|)
block|{
name|sigsuspend
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
block|}
name|clear_sigint_trap
argument_list|()
expr_stmt|;
name|rv
operator|=
name|mptrace
argument_list|(
name|XPT_STOPSTAT
argument_list|,
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|rv
condition|)
block|{
name|printf
argument_list|(
literal|"XPT_STOPSTAT: errno %d\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
comment|/* DEBUG */
continue|continue;
block|}
name|pid
operator|=
name|pt
operator|.
name|ps_pid
expr_stmt|;
if|if
condition|(
name|pid
operator|!=
name|inferior_pid
condition|)
block|{
comment|/* NOTE: the mystery fork in csh/tcsh needs to be ignored. 	     * We should not return new children for the initial run 	     * of a process until it has done the exec. 	     */
comment|/* inferior probably forked; send it on its way */
name|rv
operator|=
name|mptrace
argument_list|(
name|XPT_UNDEBUG
argument_list|,
name|pid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|rv
condition|)
block|{
name|printf
argument_list|(
literal|"child_wait: XPT_UNDEBUG: pid %d: %s\n"
argument_list|,
name|pid
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* FIXME: Do we deal with fork notification correctly?  */
switch|switch
condition|(
name|pt
operator|.
name|ps_reason
condition|)
block|{
case|case
name|PTS_FORK
case|:
comment|/* multi proc: treat like PTS_EXEC */
comment|/* 	     * Pretend this didn't happen, since gdb isn't set up 	     * to deal with stops on fork. 	     */
name|rv
operator|=
name|ptrace
argument_list|(
name|PT_CONTSIG
argument_list|,
name|pid
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|rv
condition|)
block|{
name|printf
argument_list|(
literal|"PTS_FORK: PT_CONTSIG: error %d\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
name|PTS_EXEC
case|:
comment|/* 	     * Pretend this is a SIGTRAP. 	     */
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
break|break;
case|case
name|PTS_EXIT
case|:
comment|/* 	     * Note: we stop before the exit actually occurs.  Extract 	     * the exit code from the uarea.  If we're stopped in the 	     * exit() system call, the exit code will be in 	     * u.u_ap[0].  An exit due to an uncaught signal will have 	     * something else in here, see the comment in the default: 	     * case, below.  Finally,let the process exit. 	     */
if|if
condition|(
name|death_by_signal
condition|)
block|{
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_SIGNALED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|target_signal_from_host
argument_list|(
name|death_by_signal
argument_list|)
expr_stmt|;
name|death_by_signal
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|xvaloff
operator|=
operator|(
name|unsigned
name|long
operator|)
operator|&
name|u
operator|.
name|u_ap
index|[
literal|0
index|]
operator|-
operator|(
name|unsigned
name|long
operator|)
operator|&
name|u
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|rv
operator|=
name|ptrace
argument_list|(
name|PT_RUSER
argument_list|,
name|pid
argument_list|,
operator|(
name|char
operator|*
operator|)
name|xvaloff
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|integer
operator|=
name|rv
expr_stmt|;
comment|/* 	     * addr& data to mptrace() don't matter here, since 	     * the process is already dead. 	     */
name|rv
operator|=
name|mptrace
argument_list|(
name|XPT_UNDEBUG
argument_list|,
name|pid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|rv
condition|)
block|{
name|printf
argument_list|(
literal|"child_wait: PTS_EXIT: XPT_UNDEBUG: pid %d error %d\n"
argument_list|,
name|pid
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PTS_WATCHPT_HIT
case|:
name|fatal
argument_list|(
literal|"PTS_WATCHPT_HIT\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* stopped by signal */
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|target_signal_from_host
argument_list|(
name|pt
operator|.
name|ps_reason
argument_list|)
expr_stmt|;
name|death_by_signal
operator|=
literal|0
expr_stmt|;
if|if
condition|(
literal|0
operator|==
operator|(
name|SIGNALS_DFL_SAFE
operator|&
name|sigmask
argument_list|(
name|pt
operator|.
name|ps_reason
argument_list|)
operator|)
condition|)
block|{
break|break;
block|}
comment|/* else default action of signal is to die */
ifdef|#
directive|ifdef
name|SVR4_SHARED_LIBS
name|rv
operator|=
name|ptrace
argument_list|(
name|PT_GET_PRSTATUS
argument_list|,
name|pid
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pstatus
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|rv
condition|)
name|error
argument_list|(
literal|"child_wait: signal %d PT_GET_PRSTATUS: %s\n"
argument_list|,
name|pt
operator|.
name|ps_reason
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pstatus
operator|.
name|pr_cursig
operator|!=
name|pt
operator|.
name|ps_reason
condition|)
block|{
name|printf
argument_list|(
literal|"pstatus signal %d, pt signal %d\n"
argument_list|,
name|pstatus
operator|.
name|pr_cursig
argument_list|,
name|pt
operator|.
name|ps_reason
argument_list|)
expr_stmt|;
block|}
name|sa_hand
operator|=
operator|(
name|int
operator|)
name|pstatus
operator|.
name|pr_action
operator|.
name|sa_handler
expr_stmt|;
else|#
directive|else
name|saoff
operator|=
operator|(
name|unsigned
name|long
operator|)
operator|&
name|u
operator|.
name|u_sa
index|[
literal|0
index|]
operator|-
operator|(
name|unsigned
name|long
operator|)
operator|&
name|u
expr_stmt|;
name|saoff
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sigaction
argument_list|)
operator|*
operator|(
name|pt
operator|.
name|ps_reason
operator|-
literal|1
operator|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|sa_hand
operator|=
name|ptrace
argument_list|(
name|PT_RUSER
argument_list|,
name|pid
argument_list|,
operator|(
name|char
operator|*
operator|)
name|saoff
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|error
argument_list|(
literal|"child_wait: signal %d: RUSER: %s\n"
argument_list|,
name|pt
operator|.
name|ps_reason
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|int
operator|)
name|SIG_DFL
operator|==
name|sa_hand
condition|)
block|{
comment|/* we will be dying */
name|death_by_signal
operator|=
name|pt
operator|.
name|ps_reason
expr_stmt|;
block|}
break|break;
block|}
block|}
do|while
condition|(
name|pid
operator|!=
name|inferior_pid
condition|)
do|;
comment|/* Some other child died or stopped */
return|return
name|pid
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !ATTACH_DETACH */
end_comment

begin_comment
comment|/*  * Simple child_wait() based on inftarg.c child_wait() for use until  * the MPDEBUGGER child_wait() works properly.  This will go away when  * that is fixed.  */
end_comment

begin_macro
name|child_wait
argument_list|(
argument|pid
argument_list|,
argument|ourstatus
argument_list|)
end_macro

begin_decl_stmt
name|int
name|pid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|target_waitstatus
modifier|*
name|ourstatus
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|save_errno
decl_stmt|;
name|int
name|status
decl_stmt|;
do|do
block|{
name|pid
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
name|save_errno
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|save_errno
operator|==
name|EINTR
condition|)
continue|continue;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Child process unexpectedly missing: %s.\n"
argument_list|,
name|safe_strerror
argument_list|(
name|save_errno
argument_list|)
argument_list|)
expr_stmt|;
name|ourstatus
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_SIGNALLED
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_UNKNOWN
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
do|while
condition|(
name|pid
operator|!=
name|inferior_pid
condition|)
do|;
comment|/* Some other child died or stopped */
name|store_waitstatus
argument_list|(
name|ourstatus
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
name|pid
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ATTACH_DETACH */
end_comment

begin_escape
end_escape

begin_comment
comment|/* This function simply calls ptrace with the given arguments.      It exists so that all calls to ptrace are isolated in this     machine-dependent file. */
end_comment

begin_function
name|int
name|call_ptrace
parameter_list|(
name|request
parameter_list|,
name|pid
parameter_list|,
name|addr
parameter_list|,
name|data
parameter_list|)
name|int
name|request
decl_stmt|,
name|pid
decl_stmt|;
name|PTRACE_ARG3_TYPE
name|addr
decl_stmt|;
name|int
name|data
decl_stmt|;
block|{
return|return
name|ptrace
argument_list|(
name|request
argument_list|,
name|pid
argument_list|,
name|addr
argument_list|,
name|data
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|call_mptrace
parameter_list|(
name|request
parameter_list|,
name|pid
parameter_list|,
name|addr
parameter_list|,
name|data
parameter_list|)
name|int
name|request
decl_stmt|,
name|pid
decl_stmt|;
name|PTRACE_ARG3_TYPE
name|addr
decl_stmt|;
name|int
name|data
decl_stmt|;
block|{
return|return
name|mptrace
argument_list|(
name|request
argument_list|,
name|pid
argument_list|,
name|addr
argument_list|,
name|data
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUG_PTRACE
argument_list|)
end_if

begin_comment
comment|/* For the rest of the file, use an extra level of indirection */
end_comment

begin_comment
comment|/* This lets us breakpoint usefully on call_ptrace. */
end_comment

begin_define
define|#
directive|define
name|ptrace
value|call_ptrace
end_define

begin_define
define|#
directive|define
name|mptrace
value|call_mptrace
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|kill_inferior
parameter_list|()
block|{
if|if
condition|(
name|inferior_pid
operator|==
literal|0
condition|)
return|return;
comment|/* For MPDEBUGGER, don't use PT_KILL, since the child will stop      again with a PTS_EXIT.  Just hit him with SIGKILL (so he stops)      and detach. */
name|kill
argument_list|(
name|inferior_pid
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ATTACH_DETACH
name|detach
argument_list|(
name|SIGKILL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ATTACH_DETACH */
name|ptrace
argument_list|(
name|PT_KILL
argument_list|,
name|inferior_pid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wait
argument_list|(
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ATTACH_DETACH */
name|target_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Resume execution of the inferior process.    If STEP is nonzero, single-step it.    If SIGNAL is nonzero, give it that signal.  */
end_comment

begin_function
name|void
name|child_resume
parameter_list|(
name|pid
parameter_list|,
name|step
parameter_list|,
name|signal
parameter_list|)
name|int
name|pid
decl_stmt|;
name|int
name|step
decl_stmt|;
name|enum
name|target_signal
name|signal
decl_stmt|;
block|{
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
name|pid
operator|=
name|inferior_pid
expr_stmt|;
comment|/* An address of (PTRACE_ARG3_TYPE)1 tells ptrace to continue from where      it was.  (If GDB wanted it to start some other way, we have already      written a new PC value to the child.)       If this system does not support PT_SSTEP, a higher level function will      have called single_step() to transmute the step request into a      continue request (by setting breakpoints on all possible successor      instructions), so we don't have to worry about that here.  */
if|if
condition|(
name|step
condition|)
name|ptrace
argument_list|(
name|PT_SSTEP
argument_list|,
name|pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
literal|1
argument_list|,
name|signal
argument_list|)
expr_stmt|;
else|else
name|ptrace
argument_list|(
name|PT_CONTSIG
argument_list|,
name|pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
literal|1
argument_list|,
name|signal
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
name|perror_with_name
argument_list|(
literal|"ptrace"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|ATTACH_DETACH
end_ifdef

begin_comment
comment|/* Start debugging the process whose number is PID.  */
end_comment

begin_function
name|int
name|attach
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|sigset_t
name|set
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|rv
operator|=
name|mptrace
argument_list|(
name|XPT_DEBUG
argument_list|,
name|pid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|rv
condition|)
block|{
name|error
argument_list|(
literal|"mptrace(XPT_DEBUG): %s"
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rv
operator|=
name|mptrace
argument_list|(
name|XPT_SIGNAL
argument_list|,
name|pid
argument_list|,
literal|0
argument_list|,
name|SIGSTOP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|rv
condition|)
block|{
name|error
argument_list|(
literal|"mptrace(XPT_SIGNAL): %s"
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|attach_flag
operator|=
literal|1
expr_stmt|;
return|return
name|pid
return|;
block|}
end_function

begin_function
name|void
name|detach
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|int
name|rv
decl_stmt|;
name|rv
operator|=
name|mptrace
argument_list|(
name|XPT_UNDEBUG
argument_list|,
name|inferior_pid
argument_list|,
literal|1
argument_list|,
name|signo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|rv
condition|)
block|{
name|error
argument_list|(
literal|"mptrace(XPT_UNDEBUG): %s"
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|attach_flag
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ATTACH_DETACH */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Default the type of the ptrace transfer to int.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PTRACE_XFER_TYPE
end_ifndef

begin_define
define|#
directive|define
name|PTRACE_XFER_TYPE
value|int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* NOTE! I tried using PTRACE_READDATA, etc., to read and write memory    in the NEW_SUN_PTRACE case.    It ought to be straightforward.  But it appears that writing did    not write the data that I specified.  I cannot understand where    it got the data that it actually did write.  */
end_comment

begin_comment
comment|/* Copy LEN bytes to or from inferior's memory starting at MEMADDR    to debugger memory starting at MYADDR.   Copy to inferior if    WRITE is nonzero.       Returns the length copied, which is either the LEN argument or zero.    This xfer function does not do partial moves, since child_ops    doesn't allow memory operations to cross below us in the target stack    anyway.  */
end_comment

begin_function
name|int
name|child_xfer_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|write
parameter_list|,
name|target
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|write
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
comment|/* ignored */
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Round starting address down to longword boundary.  */
specifier|register
name|CORE_ADDR
name|addr
init|=
name|memaddr
operator|&
operator|-
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
decl_stmt|;
comment|/* Round ending address up; get number of longwords that makes.  */
specifier|register
name|int
name|count
init|=
operator|(
operator|(
operator|(
name|memaddr
operator|+
name|len
operator|)
operator|-
name|addr
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
decl_stmt|;
comment|/* Allocate buffer of that many longwords.  */
specifier|register
name|PTRACE_XFER_TYPE
modifier|*
name|buffer
init|=
operator|(
name|PTRACE_XFER_TYPE
operator|*
operator|)
name|alloca
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|write
condition|)
block|{
comment|/* Fill start and end extra bytes of buffer with existing memory data.  */
if|if
condition|(
name|addr
operator|!=
name|memaddr
operator|||
name|len
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
condition|)
block|{
comment|/* Need part of initial word -- fetch it.  */
name|buffer
index|[
literal|0
index|]
operator|=
name|ptrace
argument_list|(
name|PT_RTEXT
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|>
literal|1
condition|)
comment|/* FIXME, avoid if even boundary */
block|{
name|buffer
index|[
name|count
operator|-
literal|1
index|]
operator|=
name|ptrace
argument_list|(
name|PT_RTEXT
argument_list|,
name|inferior_pid
argument_list|,
operator|(
call|(
name|PTRACE_ARG3_TYPE
call|)
argument_list|(
name|addr
operator|+
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Copy data to be written over corresponding part of buffer */
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
operator|(
name|memaddr
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Write the entire buffer.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|PT_WDATA
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|addr
argument_list|,
name|buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
block|{
comment|/* Using the appropriate one (I or D) is necessary for 		 Gould NP1, at least.  */
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|PT_WTEXT
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|addr
argument_list|,
name|buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errno
condition|)
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
comment|/* Read all the longwords */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|buffer
index|[
name|i
index|]
operator|=
name|ptrace
argument_list|(
name|PT_RTEXT
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
return|return
literal|0
return|;
name|QUIT
expr_stmt|;
block|}
comment|/* Copy appropriate bytes out of the buffer.  */
name|memcpy
argument_list|(
name|myaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
operator|(
name|memaddr
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_function
name|void
name|_initialize_symm_nat
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|ATTACH_DETACH
comment|/*  * the MPDEBUGGER is necessary for process tree debugging and attach  * to work, but it alters the behavior of debugged processes, so other  * things (at least child_wait()) will have to change to accomodate  * that.  *  * Note that attach is not implemented in dynix 3, and not in ptx  * until version 2.1 of the OS.  */
name|int
name|rv
decl_stmt|;
name|sigset_t
name|set
decl_stmt|;
name|struct
name|sigaction
name|sact
decl_stmt|;
name|rv
operator|=
name|mptrace
argument_list|(
name|XPT_MPDEBUGGER
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|rv
condition|)
block|{
name|fatal
argument_list|(
literal|"_initialize_symm_nat(): mptrace(XPT_MPDEBUGGER): %s"
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Under MPDEBUGGER, we get SIGCLHD when a traced process does 	 * anything of interest. 	 */
comment|/* 	 * Block SIGCHLD.  We leave it blocked all the time, and then 	 * call sigsuspend() in child_wait() to wait for the child 	 * to do something.  None of these ought to fail, but check anyway. 	 */
name|sigemptyset
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
name|rv
operator|=
name|sigaddset
argument_list|(
operator|&
name|set
argument_list|,
name|SIGCHLD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|rv
condition|)
block|{
name|fatal
argument_list|(
literal|"_initialize_symm_nat(): sigaddset(SIGCHLD): %s"
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rv
operator|=
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|set
argument_list|,
operator|(
name|sigset_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|rv
condition|)
block|{
name|fatal
argument_list|(
literal|"_initialize_symm_nat(): sigprocmask(SIG_BLOCK): %s"
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sact
operator|.
name|sa_handler
operator|=
name|sigchld_handler
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|sact
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|sact
operator|.
name|sa_flags
operator|=
name|SA_NOCLDWAIT
expr_stmt|;
comment|/* keep the zombies away */
name|rv
operator|=
name|sigaction
argument_list|(
name|SIGCHLD
argument_list|,
operator|&
name|sact
argument_list|,
operator|(
expr|struct
name|sigaction
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|-
literal|1
operator|==
name|rv
condition|)
block|{
name|fatal
argument_list|(
literal|"_initialize_symm_nat(): sigaction(SIGCHLD): %s"
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

end_unit

