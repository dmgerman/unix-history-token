begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Perform non-arithmetic operations on values, for GDB.    Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,    1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"cp-abi.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_comment
comment|/* Flag indicating HP compilers were used; needed to correctly handle some    value operations with HP aCC code/runtime. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|hp_som_som_object_present
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|overload_debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local functions.  */
end_comment

begin_function_decl
specifier|static
name|int
name|typecmp
parameter_list|(
name|int
name|staticp
parameter_list|,
name|struct
name|type
modifier|*
name|t1
index|[]
parameter_list|,
name|struct
name|value
modifier|*
name|t2
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|CORE_ADDR
name|find_function_addr
parameter_list|(
name|struct
name|value
modifier|*
parameter_list|,
name|struct
name|type
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|value
modifier|*
name|value_arg_coerce
parameter_list|(
name|struct
name|value
modifier|*
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|CORE_ADDR
name|value_push
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|struct
name|value
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|value
modifier|*
name|search_struct_field
parameter_list|(
name|char
modifier|*
parameter_list|,
name|struct
name|value
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|value
modifier|*
name|search_struct_method
parameter_list|(
name|char
modifier|*
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_field_in
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|CORE_ADDR
name|allocate_space_in_inferior
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|value
modifier|*
name|cast_into_complex
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|value
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|fn_field
modifier|*
name|find_method_list
parameter_list|(
name|struct
name|value
modifier|*
modifier|*
name|argp
parameter_list|,
name|char
modifier|*
name|method
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
modifier|*
name|static_memfuncp
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
modifier|*
name|num_fns
parameter_list|,
name|struct
name|type
modifier|*
modifier|*
name|basetype
parameter_list|,
name|int
modifier|*
name|boffset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|_initialize_valops
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Flag for whether we want to abandon failed expression evals by default.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int auto_abandon = 0;
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|overload_resolution
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This boolean tells what gdb should do if a signal is received while in    a function called from gdb (call dummy).  If set, gdb unwinds the stack    and restore the context to what as it was before the call.    The default is to stop in the frame where the signal was received. */
end_comment

begin_decl_stmt
name|int
name|unwind_on_signal_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Find the address of function name NAME in the inferior.  */
end_comment

begin_function
name|struct
name|value
modifier|*
name|find_function_in_inferior
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|register
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_BLOCK
condition|)
block|{
name|error
argument_list|(
literal|"\"%s\" exists in this program but is not a function."
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|value_of_variable
argument_list|(
name|sym
argument_list|,
name|NULL
argument_list|)
return|;
block|}
else|else
block|{
name|struct
name|minimal_symbol
modifier|*
name|msymbol
init|=
name|lookup_minimal_symbol
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|msymbol
operator|!=
name|NULL
condition|)
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|CORE_ADDR
name|maddr
decl_stmt|;
name|type
operator|=
name|lookup_pointer_type
argument_list|(
name|builtin_type_char
argument_list|)
expr_stmt|;
name|type
operator|=
name|lookup_function_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|type
operator|=
name|lookup_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|maddr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
return|return
name|value_from_pointer
argument_list|(
name|type
argument_list|,
name|maddr
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|target_has_execution
condition|)
name|error
argument_list|(
literal|"evaluation of this expression requires the target program to be active"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"evaluation of this expression requires the program to have a function \"%s\"."
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Allocate NBYTES of space in the inferior using the inferior's malloc    and return a value that is a pointer to the allocated space. */
end_comment

begin_function
name|struct
name|value
modifier|*
name|value_allocate_space_in_inferior
parameter_list|(
name|int
name|len
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|blocklen
decl_stmt|;
name|struct
name|value
modifier|*
name|val
init|=
name|find_function_in_inferior
argument_list|(
literal|"malloc"
argument_list|)
decl_stmt|;
name|blocklen
operator|=
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|len
argument_list|)
expr_stmt|;
name|val
operator|=
name|call_function_by_hand
argument_list|(
name|val
argument_list|,
literal|1
argument_list|,
operator|&
name|blocklen
argument_list|)
expr_stmt|;
if|if
condition|(
name|value_logical_not
argument_list|(
name|val
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|target_has_execution
condition|)
name|error
argument_list|(
literal|"No memory available to program now: you need to start the target first"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"No memory available to program: call to malloc failed"
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|allocate_space_in_inferior
parameter_list|(
name|int
name|len
parameter_list|)
block|{
return|return
name|value_as_long
argument_list|(
name|value_allocate_space_in_inferior
argument_list|(
name|len
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Cast value ARG2 to type TYPE and return as a value.    More general than a C cast: accepts any two types of the same length,    and if ARG2 is an lvalue it can be cast into anything at all.  */
end_comment

begin_comment
comment|/* In C++, casts may change pointer or object representations.  */
end_comment

begin_function
name|struct
name|value
modifier|*
name|value_cast
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|value
modifier|*
name|arg2
parameter_list|)
block|{
specifier|register
name|enum
name|type_code
name|code1
decl_stmt|;
specifier|register
name|enum
name|type_code
name|code2
decl_stmt|;
specifier|register
name|int
name|scalar
decl_stmt|;
name|struct
name|type
modifier|*
name|type2
decl_stmt|;
name|int
name|convert_to_boolean
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
operator|==
name|type
condition|)
return|return
name|arg2
return|;
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|code1
operator|=
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|COERCE_REF
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|type2
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* A cast to an undetermined-length array_type, such as (TYPE [])OBJECT,      is treated like a cast to (TYPE [N])OBJECT,      where N is sizeof(OBJECT)/sizeof(TYPE). */
if|if
condition|(
name|code1
operator|==
name|TYPE_CODE_ARRAY
condition|)
block|{
name|struct
name|type
modifier|*
name|element_type
init|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|unsigned
name|element_length
init|=
name|TYPE_LENGTH
argument_list|(
name|check_typedef
argument_list|(
name|element_type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|element_length
operator|>
literal|0
operator|&&
name|TYPE_ARRAY_UPPER_BOUND_TYPE
argument_list|(
name|type
argument_list|)
operator|==
name|BOUND_CANNOT_BE_DETERMINED
condition|)
block|{
name|struct
name|type
modifier|*
name|range_type
init|=
name|TYPE_INDEX_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|val_length
init|=
name|TYPE_LENGTH
argument_list|(
name|type2
argument_list|)
decl_stmt|;
name|LONGEST
name|low_bound
decl_stmt|,
name|high_bound
decl_stmt|,
name|new_length
decl_stmt|;
if|if
condition|(
name|get_discrete_bounds
argument_list|(
name|range_type
argument_list|,
operator|&
name|low_bound
argument_list|,
operator|&
name|high_bound
argument_list|)
operator|<
literal|0
condition|)
name|low_bound
operator|=
literal|0
operator|,
name|high_bound
operator|=
literal|0
expr_stmt|;
name|new_length
operator|=
name|val_length
operator|/
name|element_length
expr_stmt|;
if|if
condition|(
name|val_length
operator|%
name|element_length
operator|!=
literal|0
condition|)
name|warning
argument_list|(
literal|"array element type size does not divide object size in cast"
argument_list|)
expr_stmt|;
comment|/* FIXME-type-allocation: need a way to free this type when we are 	     done with it.  */
name|range_type
operator|=
name|create_range_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|TYPE_TARGET_TYPE
argument_list|(
name|range_type
argument_list|)
argument_list|,
name|low_bound
argument_list|,
name|new_length
operator|+
name|low_bound
operator|-
literal|1
argument_list|)
expr_stmt|;
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
operator|=
name|create_array_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|element_type
argument_list|,
name|range_type
argument_list|)
expr_stmt|;
return|return
name|arg2
return|;
block|}
block|}
if|if
condition|(
name|current_language
operator|->
name|c_style_arrays
operator|&&
name|TYPE_CODE
argument_list|(
name|type2
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
condition|)
name|arg2
operator|=
name|value_coerce_array
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type2
argument_list|)
operator|==
name|TYPE_CODE_FUNC
condition|)
name|arg2
operator|=
name|value_coerce_function
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
name|type2
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
argument_list|)
expr_stmt|;
name|COERCE_VARYING_ARRAY
argument_list|(
name|arg2
argument_list|,
name|type2
argument_list|)
expr_stmt|;
name|code2
operator|=
name|TYPE_CODE
argument_list|(
name|type2
argument_list|)
expr_stmt|;
if|if
condition|(
name|code1
operator|==
name|TYPE_CODE_COMPLEX
condition|)
return|return
name|cast_into_complex
argument_list|(
name|type
argument_list|,
name|arg2
argument_list|)
return|;
if|if
condition|(
name|code1
operator|==
name|TYPE_CODE_BOOL
condition|)
block|{
name|code1
operator|=
name|TYPE_CODE_INT
expr_stmt|;
name|convert_to_boolean
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|code1
operator|==
name|TYPE_CODE_CHAR
condition|)
name|code1
operator|=
name|TYPE_CODE_INT
expr_stmt|;
if|if
condition|(
name|code2
operator|==
name|TYPE_CODE_BOOL
operator|||
name|code2
operator|==
name|TYPE_CODE_CHAR
condition|)
name|code2
operator|=
name|TYPE_CODE_INT
expr_stmt|;
name|scalar
operator|=
operator|(
name|code2
operator|==
name|TYPE_CODE_INT
operator|||
name|code2
operator|==
name|TYPE_CODE_FLT
operator|||
name|code2
operator|==
name|TYPE_CODE_ENUM
operator|||
name|code2
operator|==
name|TYPE_CODE_RANGE
operator|)
expr_stmt|;
if|if
condition|(
name|code1
operator|==
name|TYPE_CODE_STRUCT
operator|&&
name|code2
operator|==
name|TYPE_CODE_STRUCT
operator|&&
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Look in the type of the source to see if it contains the          type of the target as a superclass.  If so, we'll need to          offset the object in addition to changing its type.  */
name|struct
name|value
modifier|*
name|v
init|=
name|search_struct_field
argument_list|(
name|type_name_no_tag
argument_list|(
name|type
argument_list|)
argument_list|,
name|arg2
argument_list|,
literal|0
argument_list|,
name|type2
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
condition|)
block|{
name|VALUE_TYPE
argument_list|(
name|v
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|v
return|;
block|}
block|}
if|if
condition|(
name|code1
operator|==
name|TYPE_CODE_FLT
operator|&&
name|scalar
condition|)
return|return
name|value_from_double
argument_list|(
name|type
argument_list|,
name|value_as_double
argument_list|(
name|arg2
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|(
name|code1
operator|==
name|TYPE_CODE_INT
operator|||
name|code1
operator|==
name|TYPE_CODE_ENUM
operator|||
name|code1
operator|==
name|TYPE_CODE_RANGE
operator|)
operator|&&
operator|(
name|scalar
operator|||
name|code2
operator|==
name|TYPE_CODE_PTR
operator|)
condition|)
block|{
name|LONGEST
name|longest
decl_stmt|;
if|if
condition|(
name|hp_som_som_object_present
operator|&&
comment|/* if target compiled by HP aCC */
operator|(
name|code2
operator|==
name|TYPE_CODE_PTR
operator|)
condition|)
block|{
name|unsigned
name|int
modifier|*
name|ptr
decl_stmt|;
name|struct
name|value
modifier|*
name|retvalp
decl_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type2
argument_list|)
argument_list|)
condition|)
block|{
comment|/* With HP aCC, pointers to data members have a bias */
case|case
name|TYPE_CODE_MEMBER
case|:
name|retvalp
operator|=
name|value_from_longest
argument_list|(
name|type
argument_list|,
name|value_as_long
argument_list|(
name|arg2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* force evaluation */
name|ptr
operator|=
operator|(
name|unsigned
name|int
operator|*
operator|)
name|VALUE_CONTENTS
argument_list|(
name|retvalp
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|&=
operator|~
literal|0x20000000
expr_stmt|;
comment|/* zap 29th bit to remove bias */
return|return
name|retvalp
return|;
comment|/* While pointers to methods don't really point to a function */
case|case
name|TYPE_CODE_METHOD
case|:
name|error
argument_list|(
literal|"Pointers to methods not supported with HP aCC"
argument_list|)
expr_stmt|;
default|default:
break|break;
comment|/* fall out and go to normal handling */
block|}
block|}
comment|/* When we cast pointers to integers, we mustn't use          POINTER_TO_ADDRESS to find the address the pointer          represents, as value_as_long would.  GDB should evaluate          expressions just as the compiler would --- and the compiler          sees a cast as a simple reinterpretation of the pointer's          bits.  */
if|if
condition|(
name|code2
operator|==
name|TYPE_CODE_PTR
condition|)
name|longest
operator|=
name|extract_unsigned_integer
argument_list|(
name|VALUE_CONTENTS
argument_list|(
name|arg2
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type2
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|longest
operator|=
name|value_as_long
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|type
argument_list|,
name|convert_to_boolean
condition|?
call|(
name|LONGEST
call|)
argument_list|(
name|longest
condition|?
literal|1
else|:
literal|0
argument_list|)
else|:
name|longest
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|TYPE_CODE_PTR
operator|&&
operator|(
name|code2
operator|==
name|TYPE_CODE_INT
operator|||
name|code2
operator|==
name|TYPE_CODE_ENUM
operator|||
name|code2
operator|==
name|TYPE_CODE_RANGE
operator|)
condition|)
block|{
comment|/* TYPE_LENGTH (type) is the length of a pointer, but we really 	 want the length of an address! -- we are really dealing with 	 addresses (i.e., gdb representations) not pointers (i.e., 	 target representations) here.  	 This allows things like "print *(int *)0x01000234" to work 	 without printing a misleading message -- which would 	 otherwise occur when dealing with a target having two byte 	 pointers and four byte addresses.  */
name|int
name|addr_bit
init|=
name|TARGET_ADDR_BIT
decl_stmt|;
name|LONGEST
name|longest
init|=
name|value_as_long
argument_list|(
name|arg2
argument_list|)
decl_stmt|;
if|if
condition|(
name|addr_bit
operator|<
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
operator|*
name|HOST_CHAR_BIT
condition|)
block|{
if|if
condition|(
name|longest
operator|>=
operator|(
operator|(
name|LONGEST
operator|)
literal|1
operator|<<
name|addr_bit
operator|)
operator|||
name|longest
operator|<=
operator|-
operator|(
operator|(
name|LONGEST
operator|)
literal|1
operator|<<
name|addr_bit
operator|)
condition|)
name|warning
argument_list|(
literal|"value truncated"
argument_list|)
expr_stmt|;
block|}
return|return
name|value_from_longest
argument_list|(
name|type
argument_list|,
name|longest
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_LENGTH
argument_list|(
name|type2
argument_list|)
condition|)
block|{
if|if
condition|(
name|code1
operator|==
name|TYPE_CODE_PTR
operator|&&
name|code2
operator|==
name|TYPE_CODE_PTR
condition|)
block|{
name|struct
name|type
modifier|*
name|t1
init|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|t2
init|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type2
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|t1
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|&&
name|TYPE_CODE
argument_list|(
name|t2
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|&&
operator|!
name|value_logical_not
argument_list|(
name|arg2
argument_list|)
condition|)
block|{
name|struct
name|value
modifier|*
name|v
decl_stmt|;
comment|/* Look in the type of the source to see if it contains the 	         type of the target as a superclass.  If so, we'll need to 	         offset the pointer rather than just change its type.  */
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|t1
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|v
operator|=
name|search_struct_field
argument_list|(
name|type_name_no_tag
argument_list|(
name|t1
argument_list|)
argument_list|,
name|value_ind
argument_list|(
name|arg2
argument_list|)
argument_list|,
literal|0
argument_list|,
name|t2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
condition|)
block|{
name|v
operator|=
name|value_addr
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|VALUE_TYPE
argument_list|(
name|v
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|v
return|;
block|}
block|}
comment|/* Look in the type of the target to see if it contains the 	         type of the source as a superclass.  If so, we'll need to 	         offset the pointer rather than just change its type. 	         FIXME: This fails silently with virtual inheritance.  */
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|t2
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|v
operator|=
name|search_struct_field
argument_list|(
name|type_name_no_tag
argument_list|(
name|t2
argument_list|)
argument_list|,
name|value_zero
argument_list|(
name|t1
argument_list|,
name|not_lval
argument_list|)
argument_list|,
literal|0
argument_list|,
name|t1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
condition|)
block|{
name|struct
name|value
modifier|*
name|v2
init|=
name|value_ind
argument_list|(
name|arg2
argument_list|)
decl_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|v2
argument_list|)
operator|-=
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|v
argument_list|)
expr_stmt|;
comment|/* JYG: adjust the new pointer value and 			 embedded offset. */
name|v2
operator|->
name|aligner
operator|.
name|contents
index|[
literal|0
index|]
operator|-=
name|VALUE_EMBEDDED_OFFSET
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|VALUE_EMBEDDED_OFFSET
argument_list|(
name|v2
argument_list|)
operator|=
literal|0
expr_stmt|;
name|v2
operator|=
name|value_addr
argument_list|(
name|v2
argument_list|)
expr_stmt|;
name|VALUE_TYPE
argument_list|(
name|v2
argument_list|)
operator|=
name|type
expr_stmt|;
return|return
name|v2
return|;
block|}
block|}
block|}
comment|/* No superclass found, just fall through to change ptr type.  */
block|}
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
operator|=
name|type
expr_stmt|;
name|arg2
operator|=
name|value_change_enclosing_type
argument_list|(
name|arg2
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|VALUE_POINTED_TO_OFFSET
argument_list|(
name|arg2
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* pai: chk_val */
return|return
name|arg2
return|;
block|}
elseif|else
if|if
condition|(
name|chill_varying_type
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|struct
name|type
modifier|*
name|range1
decl_stmt|,
modifier|*
name|range2
decl_stmt|,
modifier|*
name|eltype1
decl_stmt|,
modifier|*
name|eltype2
decl_stmt|;
name|struct
name|value
modifier|*
name|val
decl_stmt|;
name|int
name|count1
decl_stmt|,
name|count2
decl_stmt|;
name|LONGEST
name|low_bound
decl_stmt|,
name|high_bound
decl_stmt|;
name|char
modifier|*
name|valaddr
decl_stmt|,
modifier|*
name|valaddr_data
decl_stmt|;
comment|/* For lint warning about eltype2 possibly uninitialized: */
name|eltype2
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|code2
operator|==
name|TYPE_CODE_BITSTRING
condition|)
name|error
argument_list|(
literal|"not implemented: converting bitstring to varying type"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|code2
operator|!=
name|TYPE_CODE_ARRAY
operator|&&
name|code2
operator|!=
name|TYPE_CODE_STRING
operator|)
operator|||
operator|(
name|eltype1
operator|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
operator|,
name|eltype2
operator|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type2
argument_list|)
argument_list|)
operator|,
operator|(
name|TYPE_LENGTH
argument_list|(
name|eltype1
argument_list|)
operator|!=
name|TYPE_LENGTH
argument_list|(
name|eltype2
argument_list|)
comment|/* || TYPE_CODE (eltype1) != TYPE_CODE (eltype2) */
operator|)
operator|)
condition|)
name|error
argument_list|(
literal|"Invalid conversion to varying type"
argument_list|)
expr_stmt|;
name|range1
operator|=
name|TYPE_FIELD_TYPE
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|range2
operator|=
name|TYPE_FIELD_TYPE
argument_list|(
name|type2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_discrete_bounds
argument_list|(
name|range1
argument_list|,
operator|&
name|low_bound
argument_list|,
operator|&
name|high_bound
argument_list|)
operator|<
literal|0
condition|)
name|count1
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|count1
operator|=
name|high_bound
operator|-
name|low_bound
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|get_discrete_bounds
argument_list|(
name|range2
argument_list|,
operator|&
name|low_bound
argument_list|,
operator|&
name|high_bound
argument_list|)
operator|<
literal|0
condition|)
name|count1
operator|=
operator|-
literal|1
operator|,
name|count2
operator|=
literal|0
expr_stmt|;
comment|/* To force error before */
else|else
name|count2
operator|=
name|high_bound
operator|-
name|low_bound
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|count2
operator|>
name|count1
condition|)
name|error
argument_list|(
literal|"target varying type is too small"
argument_list|)
expr_stmt|;
name|val
operator|=
name|allocate_value
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|valaddr
operator|=
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|valaddr_data
operator|=
name|valaddr
operator|+
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
operator|/
literal|8
expr_stmt|;
comment|/* Set val's __var_length field to count2. */
name|store_signed_integer
argument_list|(
name|valaddr
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|count2
argument_list|)
expr_stmt|;
comment|/* Set the __var_data field to count2 elements copied from arg2. */
name|memcpy
argument_list|(
name|valaddr_data
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|arg2
argument_list|)
argument_list|,
name|count2
operator|*
name|TYPE_LENGTH
argument_list|(
name|eltype2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Zero the rest of the __var_data field of val. */
name|memset
argument_list|(
name|valaddr_data
operator|+
name|count2
operator|*
name|TYPE_LENGTH
argument_list|(
name|eltype2
argument_list|)
argument_list|,
literal|'\0'
argument_list|,
operator|(
name|count1
operator|-
name|count2
operator|)
operator|*
name|TYPE_LENGTH
argument_list|(
name|eltype2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
elseif|else
if|if
condition|(
name|VALUE_LVAL
argument_list|(
name|arg2
argument_list|)
operator|==
name|lval_memory
condition|)
block|{
return|return
name|value_at_lazy
argument_list|(
name|type
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|arg2
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|arg2
argument_list|)
argument_list|,
name|VALUE_BFD_SECTION
argument_list|(
name|arg2
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|code1
operator|==
name|TYPE_CODE_VOID
condition|)
block|{
return|return
name|value_zero
argument_list|(
name|builtin_type_void
argument_list|,
name|not_lval
argument_list|)
return|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"Invalid cast."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Create a value of type TYPE that is zero, and return it.  */
end_comment

begin_function
name|struct
name|value
modifier|*
name|value_zero
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|enum
name|lval_type
name|lv
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|val
init|=
name|allocate_value
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|,
literal|0
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|check_typedef
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|val
argument_list|)
operator|=
name|lv
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Return a value with type TYPE located at ADDR.     Call value_at only if the data needs to be fetched immediately;    if we can be 'lazy' and defer the fetch, perhaps indefinately, call    value_at_lazy instead.  value_at_lazy simply records the address of    the data and sets the lazy-evaluation-required flag.  The lazy flag    is tested in the VALUE_CONTENTS macro, which is used if and when    the contents are actually required.     Note: value_at does *NOT* handle embedded offsets; perform such    adjustments before or after calling it. */
end_comment

begin_function
name|struct
name|value
modifier|*
name|value_at
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|,
name|asection
modifier|*
name|sect
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|val
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|check_typedef
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_VOID
condition|)
name|error
argument_list|(
literal|"Attempt to dereference a generic pointer."
argument_list|)
expr_stmt|;
name|val
operator|=
name|allocate_value
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|read_memory
argument_list|(
name|addr
argument_list|,
name|VALUE_CONTENTS_ALL_RAW
argument_list|(
name|val
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|val
argument_list|)
operator|=
name|lval_memory
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|=
name|addr
expr_stmt|;
name|VALUE_BFD_SECTION
argument_list|(
name|val
argument_list|)
operator|=
name|sect
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Return a lazy value with type TYPE located at ADDR (cf. value_at).  */
end_comment

begin_function
name|struct
name|value
modifier|*
name|value_at_lazy
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|,
name|asection
modifier|*
name|sect
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|val
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|check_typedef
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_VOID
condition|)
name|error
argument_list|(
literal|"Attempt to dereference a generic pointer."
argument_list|)
expr_stmt|;
name|val
operator|=
name|allocate_value
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|val
argument_list|)
operator|=
name|lval_memory
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|=
name|addr
expr_stmt|;
name|VALUE_LAZY
argument_list|(
name|val
argument_list|)
operator|=
literal|1
expr_stmt|;
name|VALUE_BFD_SECTION
argument_list|(
name|val
argument_list|)
operator|=
name|sect
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Called only from the VALUE_CONTENTS and VALUE_CONTENTS_ALL macros,    if the current data for a variable needs to be loaded into    VALUE_CONTENTS(VAL).  Fetches the data from the user's process, and    clears the lazy flag to indicate that the data in the buffer is valid.     If the value is zero-length, we avoid calling read_memory, which would    abort.  We mark the value as fetched anyway -- all 0 bytes of it.     This function returns a value because it is used in the VALUE_CONTENTS    macro as part of an expression, where a void would not work.  The    value is ignored.  */
end_comment

begin_function
name|int
name|value_fetch_lazy
parameter_list|(
name|struct
name|value
modifier|*
name|val
parameter_list|)
block|{
name|CORE_ADDR
name|addr
init|=
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|val
argument_list|)
decl_stmt|;
name|int
name|length
init|=
name|TYPE_LENGTH
argument_list|(
name|VALUE_ENCLOSING_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|type
init|=
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
decl_stmt|;
if|if
condition|(
name|length
condition|)
name|read_memory
argument_list|(
name|addr
argument_list|,
name|VALUE_CONTENTS_ALL_RAW
argument_list|(
name|val
argument_list|)
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|VALUE_LAZY
argument_list|(
name|val
argument_list|)
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Store the contents of FROMVAL into the location of TOVAL.    Return a new value with the location of TOVAL and contents of FROMVAL.  */
end_comment

begin_function
name|struct
name|value
modifier|*
name|value_assign
parameter_list|(
name|struct
name|value
modifier|*
name|toval
parameter_list|,
name|struct
name|value
modifier|*
name|fromval
parameter_list|)
block|{
specifier|register
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|value
modifier|*
name|val
decl_stmt|;
name|char
modifier|*
name|raw_buffer
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|MAX_REGISTER_RAW_SIZE
argument_list|)
decl_stmt|;
name|int
name|use_buffer
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|toval
operator|->
name|modifiable
condition|)
name|error
argument_list|(
literal|"Left operand of assignment is not a modifiable lvalue."
argument_list|)
expr_stmt|;
name|COERCE_REF
argument_list|(
name|toval
argument_list|)
expr_stmt|;
name|type
operator|=
name|VALUE_TYPE
argument_list|(
name|toval
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_LVAL
argument_list|(
name|toval
argument_list|)
operator|!=
name|lval_internalvar
condition|)
name|fromval
operator|=
name|value_cast
argument_list|(
name|type
argument_list|,
name|fromval
argument_list|)
expr_stmt|;
else|else
name|COERCE_ARRAY
argument_list|(
name|fromval
argument_list|)
expr_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* If TOVAL is a special machine register requiring conversion      of program values to a special raw format,      convert FROMVAL's contents now, with result in `raw_buffer',      and set USE_BUFFER to the number of bytes to write.  */
if|if
condition|(
name|VALUE_REGNO
argument_list|(
name|toval
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|int
name|regno
init|=
name|VALUE_REGNO
argument_list|(
name|toval
argument_list|)
decl_stmt|;
if|if
condition|(
name|REGISTER_CONVERTIBLE
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|struct
name|type
modifier|*
name|fromtype
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|fromval
argument_list|)
argument_list|)
decl_stmt|;
name|REGISTER_CONVERT_TO_RAW
argument_list|(
name|fromtype
argument_list|,
name|regno
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|fromval
argument_list|)
argument_list|,
name|raw_buffer
argument_list|)
expr_stmt|;
name|use_buffer
operator|=
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|VALUE_LVAL
argument_list|(
name|toval
argument_list|)
condition|)
block|{
case|case
name|lval_internalvar
case|:
name|set_internalvar
argument_list|(
name|VALUE_INTERNALVAR
argument_list|(
name|toval
argument_list|)
argument_list|,
name|fromval
argument_list|)
expr_stmt|;
name|val
operator|=
name|value_copy
argument_list|(
name|VALUE_INTERNALVAR
argument_list|(
name|toval
argument_list|)
operator|->
name|value
argument_list|)
expr_stmt|;
name|val
operator|=
name|value_change_enclosing_type
argument_list|(
name|val
argument_list|,
name|VALUE_ENCLOSING_TYPE
argument_list|(
name|fromval
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_EMBEDDED_OFFSET
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_EMBEDDED_OFFSET
argument_list|(
name|fromval
argument_list|)
expr_stmt|;
name|VALUE_POINTED_TO_OFFSET
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_POINTED_TO_OFFSET
argument_list|(
name|fromval
argument_list|)
expr_stmt|;
return|return
name|val
return|;
case|case
name|lval_internalvar_component
case|:
name|set_internalvar_component
argument_list|(
name|VALUE_INTERNALVAR
argument_list|(
name|toval
argument_list|)
argument_list|,
name|VALUE_OFFSET
argument_list|(
name|toval
argument_list|)
argument_list|,
name|VALUE_BITPOS
argument_list|(
name|toval
argument_list|)
argument_list|,
name|VALUE_BITSIZE
argument_list|(
name|toval
argument_list|)
argument_list|,
name|fromval
argument_list|)
expr_stmt|;
break|break;
case|case
name|lval_memory
case|:
block|{
name|char
modifier|*
name|dest_buffer
decl_stmt|;
name|CORE_ADDR
name|changed_addr
decl_stmt|;
name|int
name|changed_len
decl_stmt|;
if|if
condition|(
name|VALUE_BITSIZE
argument_list|(
name|toval
argument_list|)
condition|)
block|{
name|char
name|buffer
index|[
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
index|]
decl_stmt|;
comment|/* We assume that the argument to read_memory is in units of 	       host chars.  FIXME:  Is that correct?  */
name|changed_len
operator|=
operator|(
name|VALUE_BITPOS
argument_list|(
name|toval
argument_list|)
operator|+
name|VALUE_BITSIZE
argument_list|(
name|toval
argument_list|)
operator|+
name|HOST_CHAR_BIT
operator|-
literal|1
operator|)
operator|/
name|HOST_CHAR_BIT
expr_stmt|;
if|if
condition|(
name|changed_len
operator|>
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
condition|)
name|error
argument_list|(
literal|"Can't handle bitfields which don't fit in a %d bit word."
argument_list|,
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
operator|*
name|HOST_CHAR_BIT
argument_list|)
expr_stmt|;
name|read_memory
argument_list|(
name|VALUE_ADDRESS
argument_list|(
name|toval
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|toval
argument_list|)
argument_list|,
name|buffer
argument_list|,
name|changed_len
argument_list|)
expr_stmt|;
name|modify_field
argument_list|(
name|buffer
argument_list|,
name|value_as_long
argument_list|(
name|fromval
argument_list|)
argument_list|,
name|VALUE_BITPOS
argument_list|(
name|toval
argument_list|)
argument_list|,
name|VALUE_BITSIZE
argument_list|(
name|toval
argument_list|)
argument_list|)
expr_stmt|;
name|changed_addr
operator|=
name|VALUE_ADDRESS
argument_list|(
name|toval
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|toval
argument_list|)
expr_stmt|;
name|dest_buffer
operator|=
name|buffer
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|use_buffer
condition|)
block|{
name|changed_addr
operator|=
name|VALUE_ADDRESS
argument_list|(
name|toval
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|toval
argument_list|)
expr_stmt|;
name|changed_len
operator|=
name|use_buffer
expr_stmt|;
name|dest_buffer
operator|=
name|raw_buffer
expr_stmt|;
block|}
else|else
block|{
name|changed_addr
operator|=
name|VALUE_ADDRESS
argument_list|(
name|toval
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|toval
argument_list|)
expr_stmt|;
name|changed_len
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|dest_buffer
operator|=
name|VALUE_CONTENTS
argument_list|(
name|fromval
argument_list|)
expr_stmt|;
block|}
name|write_memory
argument_list|(
name|changed_addr
argument_list|,
name|dest_buffer
argument_list|,
name|changed_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|memory_changed_hook
condition|)
name|memory_changed_hook
argument_list|(
name|changed_addr
argument_list|,
name|changed_len
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|lval_register
case|:
if|if
condition|(
name|VALUE_BITSIZE
argument_list|(
name|toval
argument_list|)
condition|)
block|{
name|char
name|buffer
index|[
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
index|]
decl_stmt|;
name|int
name|len
init|=
name|REGISTER_RAW_SIZE
argument_list|(
name|VALUE_REGNO
argument_list|(
name|toval
argument_list|)
argument_list|)
operator|-
name|VALUE_OFFSET
argument_list|(
name|toval
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|>
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
condition|)
name|error
argument_list|(
literal|"Can't handle bitfields in registers larger than %d bits."
argument_list|,
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
operator|*
name|HOST_CHAR_BIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_BITPOS
argument_list|(
name|toval
argument_list|)
operator|+
name|VALUE_BITSIZE
argument_list|(
name|toval
argument_list|)
operator|>
name|len
operator|*
name|HOST_CHAR_BIT
condition|)
comment|/* Getting this right would involve being very careful about 	       byte order.  */
name|error
argument_list|(
literal|"Can't assign to bitfields that cross register "
literal|"boundaries."
argument_list|)
expr_stmt|;
name|read_register_bytes
argument_list|(
name|VALUE_ADDRESS
argument_list|(
name|toval
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|toval
argument_list|)
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|modify_field
argument_list|(
name|buffer
argument_list|,
name|value_as_long
argument_list|(
name|fromval
argument_list|)
argument_list|,
name|VALUE_BITPOS
argument_list|(
name|toval
argument_list|)
argument_list|,
name|VALUE_BITSIZE
argument_list|(
name|toval
argument_list|)
argument_list|)
expr_stmt|;
name|write_register_bytes
argument_list|(
name|VALUE_ADDRESS
argument_list|(
name|toval
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|toval
argument_list|)
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|use_buffer
condition|)
name|write_register_bytes
argument_list|(
name|VALUE_ADDRESS
argument_list|(
name|toval
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|toval
argument_list|)
argument_list|,
name|raw_buffer
argument_list|,
name|use_buffer
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Do any conversion necessary when storing this type to more 	     than one register.  */
ifdef|#
directive|ifdef
name|REGISTER_CONVERT_FROM_TYPE
name|memcpy
argument_list|(
name|raw_buffer
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|fromval
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|REGISTER_CONVERT_FROM_TYPE
argument_list|(
name|VALUE_REGNO
argument_list|(
name|toval
argument_list|)
argument_list|,
name|type
argument_list|,
name|raw_buffer
argument_list|)
expr_stmt|;
name|write_register_bytes
argument_list|(
name|VALUE_ADDRESS
argument_list|(
name|toval
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|toval
argument_list|)
argument_list|,
name|raw_buffer
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|write_register_bytes
argument_list|(
name|VALUE_ADDRESS
argument_list|(
name|toval
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|toval
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|fromval
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Assigning to the stack pointer, frame pointer, and other          (architecture and calling convention specific) registers may          cause the frame cache to be out of date.  We just do this          on all assignments to registers for simplicity; I doubt the slowdown          matters.  */
name|reinit_frame_cache
argument_list|()
expr_stmt|;
break|break;
case|case
name|lval_reg_frame_relative
case|:
block|{
comment|/* value is stored in a series of registers in the frame 	   specified by the structure.  Copy that value out, modify 	   it, and copy it back in.  */
name|int
name|amount_to_copy
init|=
operator|(
name|VALUE_BITSIZE
argument_list|(
name|toval
argument_list|)
condition|?
literal|1
else|:
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|)
decl_stmt|;
name|int
name|reg_size
init|=
name|REGISTER_RAW_SIZE
argument_list|(
name|VALUE_FRAME_REGNUM
argument_list|(
name|toval
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|byte_offset
init|=
name|VALUE_OFFSET
argument_list|(
name|toval
argument_list|)
operator|%
name|reg_size
decl_stmt|;
name|int
name|reg_offset
init|=
name|VALUE_OFFSET
argument_list|(
name|toval
argument_list|)
operator|/
name|reg_size
decl_stmt|;
name|int
name|amount_copied
decl_stmt|;
comment|/* Make the buffer large enough in all cases.  */
comment|/* FIXME (alloca): Not safe for very large data types. */
name|char
modifier|*
name|buffer
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|amount_to_copy
operator|+
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
operator|+
name|MAX_REGISTER_RAW_SIZE
argument_list|)
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
comment|/* Figure out which frame this is in currently.  */
for|for
control|(
name|frame
operator|=
name|get_current_frame
argument_list|()
init|;
name|frame
operator|&&
name|FRAME_FP
argument_list|(
name|frame
argument_list|)
operator|!=
name|VALUE_FRAME
argument_list|(
name|toval
argument_list|)
condition|;
name|frame
operator|=
name|get_prev_frame
argument_list|(
name|frame
argument_list|)
control|)
empty_stmt|;
if|if
condition|(
operator|!
name|frame
condition|)
name|error
argument_list|(
literal|"Value being assigned to is no longer active."
argument_list|)
expr_stmt|;
name|amount_to_copy
operator|+=
operator|(
name|reg_size
operator|-
name|amount_to_copy
operator|%
name|reg_size
operator|)
expr_stmt|;
comment|/* Copy it out.  */
for|for
control|(
operator|(
name|regno
operator|=
name|VALUE_FRAME_REGNUM
argument_list|(
name|toval
argument_list|)
operator|+
name|reg_offset
operator|,
name|amount_copied
operator|=
literal|0
operator|)
init|;
name|amount_copied
operator|<
name|amount_to_copy
condition|;
name|amount_copied
operator|+=
name|reg_size
operator|,
name|regno
operator|++
control|)
block|{
name|get_saved_register
argument_list|(
name|buffer
operator|+
name|amount_copied
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|CORE_ADDR
operator|*
operator|)
name|NULL
argument_list|,
name|frame
argument_list|,
name|regno
argument_list|,
operator|(
expr|enum
name|lval_type
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Modify what needs to be modified.  */
if|if
condition|(
name|VALUE_BITSIZE
argument_list|(
name|toval
argument_list|)
condition|)
name|modify_field
argument_list|(
name|buffer
operator|+
name|byte_offset
argument_list|,
name|value_as_long
argument_list|(
name|fromval
argument_list|)
argument_list|,
name|VALUE_BITPOS
argument_list|(
name|toval
argument_list|)
argument_list|,
name|VALUE_BITSIZE
argument_list|(
name|toval
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|use_buffer
condition|)
name|memcpy
argument_list|(
name|buffer
operator|+
name|byte_offset
argument_list|,
name|raw_buffer
argument_list|,
name|use_buffer
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|buffer
operator|+
name|byte_offset
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|fromval
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy it back.  */
for|for
control|(
operator|(
name|regno
operator|=
name|VALUE_FRAME_REGNUM
argument_list|(
name|toval
argument_list|)
operator|+
name|reg_offset
operator|,
name|amount_copied
operator|=
literal|0
operator|)
init|;
name|amount_copied
operator|<
name|amount_to_copy
condition|;
name|amount_copied
operator|+=
name|reg_size
operator|,
name|regno
operator|++
control|)
block|{
name|enum
name|lval_type
name|lval
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|optim
decl_stmt|;
comment|/* Just find out where to put it.  */
name|get_saved_register
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|optim
argument_list|,
operator|&
name|addr
argument_list|,
name|frame
argument_list|,
name|regno
argument_list|,
operator|&
name|lval
argument_list|)
expr_stmt|;
if|if
condition|(
name|optim
condition|)
name|error
argument_list|(
literal|"Attempt to assign to a value that was optimized out."
argument_list|)
expr_stmt|;
if|if
condition|(
name|lval
operator|==
name|lval_memory
condition|)
name|write_memory
argument_list|(
name|addr
argument_list|,
name|buffer
operator|+
name|amount_copied
argument_list|,
name|reg_size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|lval
operator|==
name|lval_register
condition|)
name|write_register_bytes
argument_list|(
name|addr
argument_list|,
name|buffer
operator|+
name|amount_copied
argument_list|,
name|reg_size
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Attempt to assign to an unmodifiable value."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|register_changed_hook
condition|)
name|register_changed_hook
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|error
argument_list|(
literal|"Left operand of assignment is not an lvalue."
argument_list|)
expr_stmt|;
block|}
comment|/* If the field does not entirely fill a LONGEST, then zero the sign bits.      If the field is signed, and is negative, then sign extend. */
if|if
condition|(
operator|(
name|VALUE_BITSIZE
argument_list|(
name|toval
argument_list|)
operator|>
literal|0
operator|)
operator|&&
operator|(
name|VALUE_BITSIZE
argument_list|(
name|toval
argument_list|)
operator|<
literal|8
operator|*
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
operator|)
condition|)
block|{
name|LONGEST
name|fieldval
init|=
name|value_as_long
argument_list|(
name|fromval
argument_list|)
decl_stmt|;
name|LONGEST
name|valmask
init|=
operator|(
operator|(
operator|(
name|ULONGEST
operator|)
literal|1
operator|)
operator|<<
name|VALUE_BITSIZE
argument_list|(
name|toval
argument_list|)
operator|)
operator|-
literal|1
decl_stmt|;
name|fieldval
operator|&=
name|valmask
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|fieldval
operator|&
operator|(
name|valmask
operator|^
operator|(
name|valmask
operator|>>
literal|1
operator|)
operator|)
operator|)
condition|)
name|fieldval
operator||=
operator|~
name|valmask
expr_stmt|;
name|fromval
operator|=
name|value_from_longest
argument_list|(
name|type
argument_list|,
name|fieldval
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|value_copy
argument_list|(
name|toval
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|fromval
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
operator|=
name|type
expr_stmt|;
name|val
operator|=
name|value_change_enclosing_type
argument_list|(
name|val
argument_list|,
name|VALUE_ENCLOSING_TYPE
argument_list|(
name|fromval
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_EMBEDDED_OFFSET
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_EMBEDDED_OFFSET
argument_list|(
name|fromval
argument_list|)
expr_stmt|;
name|VALUE_POINTED_TO_OFFSET
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_POINTED_TO_OFFSET
argument_list|(
name|fromval
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Extend a value VAL to COUNT repetitions of its type.  */
end_comment

begin_function
name|struct
name|value
modifier|*
name|value_repeat
parameter_list|(
name|struct
name|value
modifier|*
name|arg1
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|val
decl_stmt|;
if|if
condition|(
name|VALUE_LVAL
argument_list|(
name|arg1
argument_list|)
operator|!=
name|lval_memory
condition|)
name|error
argument_list|(
literal|"Only values in memory can be extended with '@'."
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
literal|1
condition|)
name|error
argument_list|(
literal|"Invalid number %d of repetitions."
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|val
operator|=
name|allocate_repeat_value
argument_list|(
name|VALUE_ENCLOSING_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|read_memory
argument_list|(
name|VALUE_ADDRESS
argument_list|(
name|arg1
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|VALUE_CONTENTS_ALL_RAW
argument_list|(
name|val
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|VALUE_ENCLOSING_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|val
argument_list|)
operator|=
name|lval_memory
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_ADDRESS
argument_list|(
name|arg1
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|struct
name|value
modifier|*
name|value_of_variable
parameter_list|(
name|struct
name|symbol
modifier|*
name|var
parameter_list|,
name|struct
name|block
modifier|*
name|b
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|val
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|frame
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|b
condition|)
name|frame
operator|=
name|NULL
expr_stmt|;
comment|/* Use selected frame.  */
elseif|else
if|if
condition|(
name|symbol_read_needs_frame
argument_list|(
name|var
argument_list|)
condition|)
block|{
name|frame
operator|=
name|block_innermost_frame
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|frame
condition|)
block|{
if|if
condition|(
name|BLOCK_FUNCTION
argument_list|(
name|b
argument_list|)
operator|&&
name|SYMBOL_SOURCE_NAME
argument_list|(
name|BLOCK_FUNCTION
argument_list|(
name|b
argument_list|)
argument_list|)
condition|)
name|error
argument_list|(
literal|"No frame is currently executing in block %s."
argument_list|,
name|SYMBOL_SOURCE_NAME
argument_list|(
name|BLOCK_FUNCTION
argument_list|(
name|b
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"No frame is currently executing in specified block"
argument_list|)
expr_stmt|;
block|}
block|}
name|val
operator|=
name|read_var_value
argument_list|(
name|var
argument_list|,
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|val
condition|)
name|error
argument_list|(
literal|"Address of symbol \"%s\" is unknown."
argument_list|,
name|SYMBOL_SOURCE_NAME
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Given a value which is an array, return a value which is a pointer to its    first element, regardless of whether or not the array has a nonzero lower    bound.     FIXME:  A previous comment here indicated that this routine should be    substracting the array's lower bound.  It's not clear to me that this    is correct.  Given an array subscripting operation, it would certainly    work to do the adjustment here, essentially computing:     (&array[0] - (lowerbound * sizeof array[0])) + (index * sizeof array[0])     However I believe a more appropriate and logical place to account for    the lower bound is to do so in value_subscript, essentially computing:     (&array[0] + ((index - lowerbound) * sizeof array[0]))     As further evidence consider what would happen with operations other    than array subscripting, where the caller would get back a value that    had an address somewhere before the actual first element of the array,    and the information about the lower bound would be lost because of    the coercion to pointer type.  */
end_comment

begin_function
name|struct
name|value
modifier|*
name|value_coerce_array
parameter_list|(
name|struct
name|value
modifier|*
name|arg1
parameter_list|)
block|{
specifier|register
name|struct
name|type
modifier|*
name|type
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|VALUE_LVAL
argument_list|(
name|arg1
argument_list|)
operator|!=
name|lval_memory
condition|)
name|error
argument_list|(
literal|"Attempt to take address of value not located in memory."
argument_list|)
expr_stmt|;
return|return
name|value_from_pointer
argument_list|(
name|lookup_pointer_type
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
operator|(
name|VALUE_ADDRESS
argument_list|(
name|arg1
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|arg1
argument_list|)
operator|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a value which is a function, return a value which is a pointer    to it.  */
end_comment

begin_function
name|struct
name|value
modifier|*
name|value_coerce_function
parameter_list|(
name|struct
name|value
modifier|*
name|arg1
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|retval
decl_stmt|;
if|if
condition|(
name|VALUE_LVAL
argument_list|(
name|arg1
argument_list|)
operator|!=
name|lval_memory
condition|)
name|error
argument_list|(
literal|"Attempt to take address of value not located in memory."
argument_list|)
expr_stmt|;
name|retval
operator|=
name|value_from_pointer
argument_list|(
name|lookup_pointer_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|,
operator|(
name|VALUE_ADDRESS
argument_list|(
name|arg1
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|arg1
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|VALUE_BFD_SECTION
argument_list|(
name|retval
argument_list|)
operator|=
name|VALUE_BFD_SECTION
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer value for the object for which ARG1 is the contents.  */
end_comment

begin_function
name|struct
name|value
modifier|*
name|value_addr
parameter_list|(
name|struct
name|value
modifier|*
name|arg1
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|arg2
decl_stmt|;
name|struct
name|type
modifier|*
name|type
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_REF
condition|)
block|{
comment|/* Copy the value, but change the type from (T&) to (T*).          We keep the same location information, which is efficient,          and allows&(&X) to get the location containing the reference. */
name|arg2
operator|=
name|value_copy
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
operator|=
name|lookup_pointer_type
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|arg2
return|;
block|}
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FUNC
condition|)
return|return
name|value_coerce_function
argument_list|(
name|arg1
argument_list|)
return|;
if|if
condition|(
name|VALUE_LVAL
argument_list|(
name|arg1
argument_list|)
operator|!=
name|lval_memory
condition|)
name|error
argument_list|(
literal|"Attempt to take address of value not located in memory."
argument_list|)
expr_stmt|;
comment|/* Get target memory address */
name|arg2
operator|=
name|value_from_pointer
argument_list|(
name|lookup_pointer_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|,
operator|(
name|VALUE_ADDRESS
argument_list|(
name|arg1
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|arg1
argument_list|)
operator|+
name|VALUE_EMBEDDED_OFFSET
argument_list|(
name|arg1
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* This may be a pointer to a base subobject; so remember the      full derived object's type ... */
name|arg2
operator|=
name|value_change_enclosing_type
argument_list|(
name|arg2
argument_list|,
name|lookup_pointer_type
argument_list|(
name|VALUE_ENCLOSING_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ... and also the relative position of the subobject in the full object */
name|VALUE_POINTED_TO_OFFSET
argument_list|(
name|arg2
argument_list|)
operator|=
name|VALUE_EMBEDDED_OFFSET
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|VALUE_BFD_SECTION
argument_list|(
name|arg2
argument_list|)
operator|=
name|VALUE_BFD_SECTION
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
return|return
name|arg2
return|;
block|}
end_function

begin_comment
comment|/* Given a value of a pointer type, apply the C unary * operator to it.  */
end_comment

begin_function
name|struct
name|value
modifier|*
name|value_ind
parameter_list|(
name|struct
name|value
modifier|*
name|arg1
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|base_type
decl_stmt|;
name|struct
name|value
modifier|*
name|arg2
decl_stmt|;
name|COERCE_ARRAY
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|base_type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|base_type
argument_list|)
operator|==
name|TYPE_CODE_MEMBER
condition|)
name|error
argument_list|(
literal|"not implemented: member types in value_ind"
argument_list|)
expr_stmt|;
comment|/* Allow * on an integer so we can cast it to whatever we want.      This returns an int, which seems like the most C-like thing      to do.  "long long" variables are rare enough that      BUILTIN_TYPE_LONGEST would seem to be a mistake.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|base_type
argument_list|)
operator|==
name|TYPE_CODE_INT
condition|)
return|return
name|value_at
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|CORE_ADDR
operator|)
name|value_as_long
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|VALUE_BFD_SECTION
argument_list|(
name|arg1
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|base_type
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
block|{
name|struct
name|type
modifier|*
name|enc_type
decl_stmt|;
comment|/* We may be pointing to something embedded in a larger object */
comment|/* Get the real type of the enclosing object */
name|enc_type
operator|=
name|check_typedef
argument_list|(
name|VALUE_ENCLOSING_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|enc_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|enc_type
argument_list|)
expr_stmt|;
comment|/* Retrieve the enclosing object pointed to */
name|arg2
operator|=
name|value_at_lazy
argument_list|(
name|enc_type
argument_list|,
name|value_as_address
argument_list|(
name|arg1
argument_list|)
operator|-
name|VALUE_POINTED_TO_OFFSET
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|VALUE_BFD_SECTION
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Re-adjust type */
name|VALUE_TYPE
argument_list|(
name|arg2
argument_list|)
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|base_type
argument_list|)
expr_stmt|;
comment|/* Add embedding info */
name|arg2
operator|=
name|value_change_enclosing_type
argument_list|(
name|arg2
argument_list|,
name|enc_type
argument_list|)
expr_stmt|;
name|VALUE_EMBEDDED_OFFSET
argument_list|(
name|arg2
argument_list|)
operator|=
name|VALUE_POINTED_TO_OFFSET
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
comment|/* We may be pointing to an object of some derived type */
name|arg2
operator|=
name|value_full_object
argument_list|(
name|arg2
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|arg2
return|;
block|}
name|error
argument_list|(
literal|"Attempt to take contents of a non-pointer value."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* For lint -- never reached */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Pushing small parts of stack frames.  */
end_comment

begin_comment
comment|/* Push one word (the size of object that a register holds).  */
end_comment

begin_function
name|CORE_ADDR
name|push_word
parameter_list|(
name|CORE_ADDR
name|sp
parameter_list|,
name|ULONGEST
name|word
parameter_list|)
block|{
specifier|register
name|int
name|len
init|=
name|REGISTER_SIZE
decl_stmt|;
name|char
modifier|*
name|buffer
init|=
name|alloca
argument_list|(
name|MAX_REGISTER_RAW_SIZE
argument_list|)
decl_stmt|;
name|store_unsigned_integer
argument_list|(
name|buffer
argument_list|,
name|len
argument_list|,
name|word
argument_list|)
expr_stmt|;
if|if
condition|(
name|INNER_THAN
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* stack grows downward */
name|sp
operator|-=
name|len
expr_stmt|;
name|write_memory
argument_list|(
name|sp
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* stack grows upward */
name|write_memory
argument_list|(
name|sp
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sp
operator|+=
name|len
expr_stmt|;
block|}
return|return
name|sp
return|;
block|}
end_function

begin_comment
comment|/* Push LEN bytes with data at BUFFER.  */
end_comment

begin_function
name|CORE_ADDR
name|push_bytes
parameter_list|(
name|CORE_ADDR
name|sp
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|INNER_THAN
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* stack grows downward */
name|sp
operator|-=
name|len
expr_stmt|;
name|write_memory
argument_list|(
name|sp
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* stack grows upward */
name|write_memory
argument_list|(
name|sp
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sp
operator|+=
name|len
expr_stmt|;
block|}
return|return
name|sp
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|PARM_BOUNDARY
end_ifndef

begin_define
define|#
directive|define
name|PARM_BOUNDARY
value|(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Push onto the stack the specified value VALUE.  Pad it correctly for    it to be an argument to a function.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|value_push
parameter_list|(
specifier|register
name|CORE_ADDR
name|sp
parameter_list|,
name|struct
name|value
modifier|*
name|arg
parameter_list|)
block|{
specifier|register
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|VALUE_ENCLOSING_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|int
name|container_len
init|=
name|len
decl_stmt|;
specifier|register
name|int
name|offset
decl_stmt|;
comment|/* How big is the container we're going to put this value in?  */
if|if
condition|(
name|PARM_BOUNDARY
condition|)
name|container_len
operator|=
operator|(
operator|(
name|len
operator|+
name|PARM_BOUNDARY
operator|/
name|TARGET_CHAR_BIT
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|PARM_BOUNDARY
operator|/
name|TARGET_CHAR_BIT
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* Are we going to put it at the high or low end of the container?  */
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|)
name|offset
operator|=
name|container_len
operator|-
name|len
expr_stmt|;
else|else
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|INNER_THAN
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* stack grows downward */
name|sp
operator|-=
name|container_len
expr_stmt|;
name|write_memory
argument_list|(
name|sp
operator|+
name|offset
argument_list|,
name|VALUE_CONTENTS_ALL
argument_list|(
name|arg
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* stack grows upward */
name|write_memory
argument_list|(
name|sp
operator|+
name|offset
argument_list|,
name|VALUE_CONTENTS_ALL
argument_list|(
name|arg
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sp
operator|+=
name|container_len
expr_stmt|;
block|}
return|return
name|sp
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|default_push_arguments
parameter_list|(
name|int
name|nargs
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|args
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|,
name|int
name|struct_return
parameter_list|,
name|CORE_ADDR
name|struct_addr
parameter_list|)
block|{
comment|/* ASSERT ( !struct_return); */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|nargs
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|sp
operator|=
name|value_push
argument_list|(
name|sp
argument_list|,
name|args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_comment
comment|/* Functions to use for the COERCE_FLOAT_TO_DOUBLE gdbarch method.     How you should pass arguments to a function depends on whether it    was defined in K&R style or prototype style.  If you define a    function using the K&R syntax that takes a `float' argument, then    callers must pass that argument as a `double'.  If you define the    function using the prototype syntax, then you must pass the    argument as a `float', with no promotion.     Unfortunately, on certain older platforms, the debug info doesn't    indicate reliably how each function was defined.  A function type's    TYPE_FLAG_PROTOTYPED flag may be clear, even if the function was    defined in prototype style.  When calling a function whose    TYPE_FLAG_PROTOTYPED flag is clear, GDB consults the    COERCE_FLOAT_TO_DOUBLE gdbarch method to decide what to do.     For modern targets, it is proper to assume that, if the prototype    flag is clear, that can be trusted: `float' arguments should be    promoted to `double'.  You should register the function    `standard_coerce_float_to_double' to get this behavior.     For some older targets, if the prototype flag is clear, that    doesn't tell us anything.  So we guess that, if we don't have a    type for the formal parameter (i.e., the first argument to    COERCE_FLOAT_TO_DOUBLE is null), then we should promote it;    otherwise, we should leave it alone.  The function    `default_coerce_float_to_double' provides this behavior; it is the    default value, for compatibility with older configurations.  */
end_comment

begin_function
name|int
name|default_coerce_float_to_double
parameter_list|(
name|struct
name|type
modifier|*
name|formal
parameter_list|,
name|struct
name|type
modifier|*
name|actual
parameter_list|)
block|{
return|return
name|formal
operator|==
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|standard_coerce_float_to_double
parameter_list|(
name|struct
name|type
modifier|*
name|formal
parameter_list|,
name|struct
name|type
modifier|*
name|actual
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Perform the standard coercions that are specified    for arguments to be passed to C functions.     If PARAM_TYPE is non-NULL, it is the expected parameter type.    IS_PROTOTYPED is non-zero if the function declaration is prototyped.  */
end_comment

begin_function
specifier|static
name|struct
name|value
modifier|*
name|value_arg_coerce
parameter_list|(
name|struct
name|value
modifier|*
name|arg
parameter_list|,
name|struct
name|type
modifier|*
name|param_type
parameter_list|,
name|int
name|is_prototyped
parameter_list|)
block|{
specifier|register
name|struct
name|type
modifier|*
name|arg_type
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|type
modifier|*
name|type
init|=
name|param_type
condition|?
name|check_typedef
argument_list|(
name|param_type
argument_list|)
else|:
name|arg_type
decl_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_REF
case|:
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|arg_type
argument_list|)
operator|!=
name|TYPE_CODE_REF
operator|&&
name|TYPE_CODE
argument_list|(
name|arg_type
argument_list|)
operator|!=
name|TYPE_CODE_PTR
condition|)
block|{
name|arg
operator|=
name|value_addr
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
operator|=
name|param_type
expr_stmt|;
return|return
name|arg
return|;
block|}
break|break;
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_CHAR
case|:
case|case
name|TYPE_CODE_BOOL
case|:
case|case
name|TYPE_CODE_ENUM
case|:
comment|/* If we don't have a prototype, coerce to integer type if necessary.  */
if|if
condition|(
operator|!
name|is_prototyped
condition|)
block|{
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_LENGTH
argument_list|(
name|builtin_type_int
argument_list|)
condition|)
name|type
operator|=
name|builtin_type_int
expr_stmt|;
block|}
comment|/* Currently all target ABIs require at least the width of an integer          type for an argument.  We may have to conditionalize the following          type coercion for future targets.  */
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_LENGTH
argument_list|(
name|builtin_type_int
argument_list|)
condition|)
name|type
operator|=
name|builtin_type_int
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_FLT
case|:
comment|/* FIXME: We should always convert floats to doubles in the          non-prototyped case.  As many debugging formats include          no information about prototyping, we have to live with          COERCE_FLOAT_TO_DOUBLE for now.  */
if|if
condition|(
operator|!
name|is_prototyped
operator|&&
name|COERCE_FLOAT_TO_DOUBLE
argument_list|(
name|param_type
argument_list|,
name|arg_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|<
name|TYPE_LENGTH
argument_list|(
name|builtin_type_double
argument_list|)
condition|)
name|type
operator|=
name|builtin_type_double
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|>
name|TYPE_LENGTH
argument_list|(
name|builtin_type_double
argument_list|)
condition|)
name|type
operator|=
name|builtin_type_long_double
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_FUNC
case|:
name|type
operator|=
name|lookup_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_ARRAY
case|:
if|if
condition|(
name|current_language
operator|->
name|c_style_arrays
condition|)
name|type
operator|=
name|lookup_pointer_type
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_UNDEF
case|:
case|case
name|TYPE_CODE_PTR
case|:
case|case
name|TYPE_CODE_STRUCT
case|:
case|case
name|TYPE_CODE_UNION
case|:
case|case
name|TYPE_CODE_VOID
case|:
case|case
name|TYPE_CODE_SET
case|:
case|case
name|TYPE_CODE_RANGE
case|:
case|case
name|TYPE_CODE_STRING
case|:
case|case
name|TYPE_CODE_BITSTRING
case|:
case|case
name|TYPE_CODE_ERROR
case|:
case|case
name|TYPE_CODE_MEMBER
case|:
case|case
name|TYPE_CODE_METHOD
case|:
case|case
name|TYPE_CODE_COMPLEX
case|:
default|default:
break|break;
block|}
return|return
name|value_cast
argument_list|(
name|type
argument_list|,
name|arg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Determine a function's address and its return type from its value.    Calls error() if the function is not valid for calling.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|find_function_addr
parameter_list|(
name|struct
name|value
modifier|*
name|function
parameter_list|,
name|struct
name|type
modifier|*
modifier|*
name|retval_type
parameter_list|)
block|{
specifier|register
name|struct
name|type
modifier|*
name|ftype
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|type_code
name|code
init|=
name|TYPE_CODE
argument_list|(
name|ftype
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|value_type
decl_stmt|;
name|CORE_ADDR
name|funaddr
decl_stmt|;
comment|/* If it's a member function, just look at the function      part of it.  */
comment|/* Determine address to call.  */
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_FUNC
operator|||
name|code
operator|==
name|TYPE_CODE_METHOD
condition|)
block|{
name|funaddr
operator|=
name|VALUE_ADDRESS
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|value_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|ftype
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_PTR
condition|)
block|{
name|funaddr
operator|=
name|value_as_address
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|ftype
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|ftype
argument_list|)
operator|==
name|TYPE_CODE_FUNC
operator|||
name|TYPE_CODE
argument_list|(
name|ftype
argument_list|)
operator|==
name|TYPE_CODE_METHOD
condition|)
block|{
name|funaddr
operator|=
name|CONVERT_FROM_FUNC_PTR_ADDR
argument_list|(
name|funaddr
argument_list|)
expr_stmt|;
name|value_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|ftype
argument_list|)
expr_stmt|;
block|}
else|else
name|value_type
operator|=
name|builtin_type_int
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_INT
condition|)
block|{
comment|/* Handle the case of functions lacking debugging info.          Their values are characters since their addresses are char */
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|ftype
argument_list|)
operator|==
literal|1
condition|)
name|funaddr
operator|=
name|value_as_address
argument_list|(
name|value_addr
argument_list|(
name|function
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* Handle integer used as address of a function.  */
name|funaddr
operator|=
operator|(
name|CORE_ADDR
operator|)
name|value_as_long
argument_list|(
name|function
argument_list|)
expr_stmt|;
name|value_type
operator|=
name|builtin_type_int
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Invalid data type for function to be called."
argument_list|)
expr_stmt|;
operator|*
name|retval_type
operator|=
name|value_type
expr_stmt|;
return|return
name|funaddr
return|;
block|}
end_function

begin_comment
comment|/* All this stuff with a dummy frame may seem unnecessarily complicated    (why not just save registers in GDB?).  The purpose of pushing a dummy    frame which looks just like a real frame is so that if you call a    function and then hit a breakpoint (get a signal, etc), "backtrace"    will look right.  Whether the backtrace needs to actually show the    stack at the time the inferior function was called is debatable, but    it certainly needs to not display garbage.  So if you are contemplating    making dummy frames be different from normal frames, consider that.  */
end_comment

begin_comment
comment|/* Perform a function call in the inferior.    ARGS is a vector of values of arguments (NARGS of them).    FUNCTION is a value, the function to be called.    Returns a value representing what the function returned.    May fail to return, if a breakpoint or signal is hit    during the execution of the function.     ARGS is modified to contain coerced values. */
end_comment

begin_function
specifier|static
name|struct
name|value
modifier|*
name|hand_function_call
parameter_list|(
name|struct
name|value
modifier|*
name|function
parameter_list|,
name|int
name|nargs
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|args
parameter_list|)
block|{
specifier|register
name|CORE_ADDR
name|sp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|CORE_ADDR
name|start_sp
decl_stmt|;
comment|/* CALL_DUMMY is an array of words (REGISTER_SIZE), but each word      is in host byte order.  Before calling FIX_CALL_DUMMY, we byteswap it      and remove any extra bytes which might exist because ULONGEST is      bigger than REGISTER_SIZE.       NOTE: This is pretty wierd, as the call dummy is actually a      sequence of instructions.  But CISC machines will have      to pack the instructions into REGISTER_SIZE units (and      so will RISC machines for which INSTRUCTION_SIZE is not      REGISTER_SIZE).       NOTE: This is pretty stupid.  CALL_DUMMY should be in strict      target byte order. */
specifier|static
name|ULONGEST
modifier|*
name|dummy
decl_stmt|;
name|int
name|sizeof_dummy1
decl_stmt|;
name|char
modifier|*
name|dummy1
decl_stmt|;
name|CORE_ADDR
name|old_sp
decl_stmt|;
name|struct
name|type
modifier|*
name|value_type
decl_stmt|;
name|unsigned
name|char
name|struct_return
decl_stmt|;
name|CORE_ADDR
name|struct_addr
init|=
literal|0
decl_stmt|;
name|struct
name|inferior_status
modifier|*
name|inf_status
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|CORE_ADDR
name|funaddr
decl_stmt|;
name|int
name|using_gcc
decl_stmt|;
comment|/* Set to version of gcc in use, or zero if not gcc */
name|CORE_ADDR
name|real_pc
decl_stmt|;
name|struct
name|type
modifier|*
name|param_type
init|=
name|NULL
decl_stmt|;
name|struct
name|type
modifier|*
name|ftype
init|=
name|check_typedef
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|function
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|n_method_args
init|=
literal|0
decl_stmt|;
name|dummy
operator|=
name|alloca
argument_list|(
name|SIZEOF_CALL_DUMMY_WORDS
argument_list|)
expr_stmt|;
name|sizeof_dummy1
operator|=
name|REGISTER_SIZE
operator|*
name|SIZEOF_CALL_DUMMY_WORDS
operator|/
sizeof|sizeof
argument_list|(
name|ULONGEST
argument_list|)
expr_stmt|;
name|dummy1
operator|=
name|alloca
argument_list|(
name|sizeof_dummy1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dummy
argument_list|,
name|CALL_DUMMY_WORDS
argument_list|,
name|SIZEOF_CALL_DUMMY_WORDS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target_has_execution
condition|)
name|noprocess
argument_list|()
expr_stmt|;
name|inf_status
operator|=
name|save_inferior_status
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup_restore_inferior_status
argument_list|(
name|inf_status
argument_list|)
expr_stmt|;
comment|/* PUSH_DUMMY_FRAME is responsible for saving the inferior registers      (and POP_FRAME for restoring them).  (At least on most machines)      they are saved on the stack in the inferior.  */
name|PUSH_DUMMY_FRAME
expr_stmt|;
name|old_sp
operator|=
name|sp
operator|=
name|read_sp
argument_list|()
expr_stmt|;
if|if
condition|(
name|INNER_THAN
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* Stack grows down */
name|sp
operator|-=
name|sizeof_dummy1
expr_stmt|;
name|start_sp
operator|=
name|sp
expr_stmt|;
block|}
else|else
block|{
comment|/* Stack grows up */
name|start_sp
operator|=
name|sp
expr_stmt|;
name|sp
operator|+=
name|sizeof_dummy1
expr_stmt|;
block|}
name|funaddr
operator|=
name|find_function_addr
argument_list|(
name|function
argument_list|,
operator|&
name|value_type
argument_list|)
expr_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|value_type
argument_list|)
expr_stmt|;
block|{
name|struct
name|block
modifier|*
name|b
init|=
name|block_for_pc
argument_list|(
name|funaddr
argument_list|)
decl_stmt|;
comment|/* If compiled without -g, assume GCC 2.  */
name|using_gcc
operator|=
operator|(
name|b
operator|==
name|NULL
condition|?
literal|2
else|:
name|BLOCK_GCC_COMPILED
argument_list|(
name|b
argument_list|)
operator|)
expr_stmt|;
block|}
comment|/* Are we returning a value using a structure return or a normal      value return? */
name|struct_return
operator|=
name|using_struct_return
argument_list|(
name|function
argument_list|,
name|funaddr
argument_list|,
name|value_type
argument_list|,
name|using_gcc
argument_list|)
expr_stmt|;
comment|/* Create a call sequence customized for this function      and the number of arguments for it.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
call|(
name|int
call|)
argument_list|(
name|SIZEOF_CALL_DUMMY_WORDS
operator|/
sizeof|sizeof
argument_list|(
name|dummy
index|[
literal|0
index|]
argument_list|)
argument_list|)
condition|;
name|i
operator|++
control|)
name|store_unsigned_integer
argument_list|(
operator|&
name|dummy1
index|[
name|i
operator|*
name|REGISTER_SIZE
index|]
argument_list|,
name|REGISTER_SIZE
argument_list|,
operator|(
name|ULONGEST
operator|)
name|dummy
index|[
name|i
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GDB_TARGET_IS_HPPA
name|real_pc
operator|=
name|FIX_CALL_DUMMY
argument_list|(
name|dummy1
argument_list|,
name|start_sp
argument_list|,
name|funaddr
argument_list|,
name|nargs
argument_list|,
name|args
argument_list|,
name|value_type
argument_list|,
name|using_gcc
argument_list|)
expr_stmt|;
else|#
directive|else
name|FIX_CALL_DUMMY
argument_list|(
name|dummy1
argument_list|,
name|start_sp
argument_list|,
name|funaddr
argument_list|,
name|nargs
argument_list|,
name|args
argument_list|,
name|value_type
argument_list|,
name|using_gcc
argument_list|)
expr_stmt|;
name|real_pc
operator|=
name|start_sp
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|CALL_DUMMY_LOCATION
operator|==
name|ON_STACK
condition|)
block|{
name|write_memory
argument_list|(
name|start_sp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dummy1
argument_list|,
name|sizeof_dummy1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CALL_DUMMY_LOCATION
operator|==
name|BEFORE_TEXT_END
condition|)
block|{
comment|/* Convex Unix prohibits executing in the stack segment. */
comment|/* Hope there is empty room at the top of the text segment. */
specifier|extern
name|CORE_ADDR
name|text_end
decl_stmt|;
specifier|static
name|int
name|checked
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|checked
condition|)
for|for
control|(
name|start_sp
operator|=
name|text_end
operator|-
name|sizeof_dummy1
init|;
name|start_sp
operator|<
name|text_end
condition|;
operator|++
name|start_sp
control|)
if|if
condition|(
name|read_memory_integer
argument_list|(
name|start_sp
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"text segment full -- no place to put call"
argument_list|)
expr_stmt|;
name|checked
operator|=
literal|1
expr_stmt|;
name|sp
operator|=
name|old_sp
expr_stmt|;
name|real_pc
operator|=
name|text_end
operator|-
name|sizeof_dummy1
expr_stmt|;
name|write_memory
argument_list|(
name|real_pc
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dummy1
argument_list|,
name|sizeof_dummy1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CALL_DUMMY_LOCATION
operator|==
name|AFTER_TEXT_END
condition|)
block|{
specifier|extern
name|CORE_ADDR
name|text_end
decl_stmt|;
name|int
name|errcode
decl_stmt|;
name|sp
operator|=
name|old_sp
expr_stmt|;
name|real_pc
operator|=
name|text_end
expr_stmt|;
name|errcode
operator|=
name|target_write_memory
argument_list|(
name|real_pc
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dummy1
argument_list|,
name|sizeof_dummy1
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"Cannot write text segment -- call_function failed"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CALL_DUMMY_LOCATION
operator|==
name|AT_ENTRY_POINT
condition|)
block|{
name|real_pc
operator|=
name|funaddr
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|lint
name|sp
operator|=
name|old_sp
expr_stmt|;
comment|/* It really is used, for some ifdef's... */
endif|#
directive|endif
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|ftype
argument_list|)
operator|==
name|TYPE_CODE_METHOD
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|TYPE_CODE
argument_list|(
name|TYPE_ARG_TYPES
argument_list|(
name|ftype
argument_list|)
index|[
name|i
index|]
argument_list|)
operator|!=
name|TYPE_CODE_VOID
condition|)
name|i
operator|++
expr_stmt|;
name|n_method_args
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|nargs
operator|<
name|i
condition|)
name|error
argument_list|(
literal|"too few arguments in method call"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nargs
operator|<
name|TYPE_NFIELDS
argument_list|(
name|ftype
argument_list|)
condition|)
name|error
argument_list|(
literal|"too few arguments in function call"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|nargs
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|/* Assume that methods are always prototyped, unless they are off the 	 end (which we should only be allowing if there is a ``...'').            FIXME.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|ftype
argument_list|)
operator|==
name|TYPE_CODE_METHOD
condition|)
block|{
if|if
condition|(
name|i
operator|<
name|n_method_args
condition|)
name|args
index|[
name|i
index|]
operator|=
name|value_arg_coerce
argument_list|(
name|args
index|[
name|i
index|]
argument_list|,
name|TYPE_ARG_TYPES
argument_list|(
name|ftype
argument_list|)
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|args
index|[
name|i
index|]
operator|=
name|value_arg_coerce
argument_list|(
name|args
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If we're off the end of the known arguments, do the standard          promotions.  FIXME: if we had a prototype, this should only          be allowed if ... were present.  */
if|if
condition|(
name|i
operator|>=
name|TYPE_NFIELDS
argument_list|(
name|ftype
argument_list|)
condition|)
name|args
index|[
name|i
index|]
operator|=
name|value_arg_coerce
argument_list|(
name|args
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|param_type
operator|=
name|TYPE_FIELD_TYPE
argument_list|(
name|ftype
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|args
index|[
name|i
index|]
operator|=
name|value_arg_coerce
argument_list|(
name|args
index|[
name|i
index|]
argument_list|,
name|param_type
argument_list|,
name|TYPE_PROTOTYPED
argument_list|(
name|ftype
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*elz: this code is to handle the case in which the function to be called          has a pointer to function as parameter and the corresponding actual argument          is the address of a function and not a pointer to function variable.          In aCC compiled code, the calls through pointers to functions (in the body          of the function called by hand) are made via $$dyncall_external which          requires some registers setting, this is taken care of if we call          via a function pointer variable, but not via a function address.          In cc this is not a problem. */
if|if
condition|(
name|using_gcc
operator|==
literal|0
condition|)
if|if
condition|(
name|param_type
condition|)
comment|/* if this parameter is a pointer to function */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|param_type
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|param_type
operator|->
name|target_type
argument_list|)
operator|==
name|TYPE_CODE_FUNC
condition|)
comment|/* elz: FIXME here should go the test about the compiler used 	         to compile the target. We want to issue the error 	         message only if the compiler used was HP's aCC. 	         If we used HP's cc, then there is no problem and no need 	         to return at this point */
if|if
condition|(
name|using_gcc
operator|==
literal|0
condition|)
comment|/*&& compiler == aCC */
comment|/* go see if the actual parameter is a variable of type 		   pointer to function or just a function */
if|if
condition|(
name|args
index|[
name|i
index|]
operator|->
name|lval
operator|==
name|not_lval
condition|)
block|{
name|char
modifier|*
name|arg_name
decl_stmt|;
if|if
condition|(
name|find_pc_partial_function
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|args
index|[
name|i
index|]
operator|->
name|aligner
operator|.
name|contents
index|[
literal|0
index|]
argument_list|,
operator|&
name|arg_name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
name|error
argument_list|(
literal|"\ You cannot use function<%s> as argument. \n\ You must use a pointer to function type variable. Command ignored."
argument_list|,
name|arg_name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|REG_STRUCT_HAS_ADDR_P
argument_list|()
condition|)
block|{
comment|/* This is a machine like the sparc, where we may need to pass a 	 pointer to the structure, not the structure itself.  */
for|for
control|(
name|i
operator|=
name|nargs
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|struct
name|type
modifier|*
name|arg_type
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|arg_type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|TYPE_CODE
argument_list|(
name|arg_type
argument_list|)
operator|==
name|TYPE_CODE_UNION
operator|||
name|TYPE_CODE
argument_list|(
name|arg_type
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
operator|||
name|TYPE_CODE
argument_list|(
name|arg_type
argument_list|)
operator|==
name|TYPE_CODE_STRING
operator|||
name|TYPE_CODE
argument_list|(
name|arg_type
argument_list|)
operator|==
name|TYPE_CODE_BITSTRING
operator|||
name|TYPE_CODE
argument_list|(
name|arg_type
argument_list|)
operator|==
name|TYPE_CODE_SET
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|arg_type
argument_list|)
operator|==
name|TYPE_CODE_FLT
operator|&&
name|TYPE_LENGTH
argument_list|(
name|arg_type
argument_list|)
operator|>
literal|8
operator|)
operator|)
operator|&&
name|REG_STRUCT_HAS_ADDR
argument_list|(
name|using_gcc
argument_list|,
name|arg_type
argument_list|)
condition|)
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/*  = TYPE_LENGTH (arg_type); */
name|int
name|aligned_len
decl_stmt|;
name|arg_type
operator|=
name|check_typedef
argument_list|(
name|VALUE_ENCLOSING_TYPE
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|arg_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|STACK_ALIGN_P
argument_list|()
condition|)
comment|/* MVS 11/22/96: I think at least some of this 		   stack_align code is really broken.  Better to let 		   PUSH_ARGUMENTS adjust the stack in a target-defined 		   manner.  */
name|aligned_len
operator|=
name|STACK_ALIGN
argument_list|(
name|len
argument_list|)
expr_stmt|;
else|else
name|aligned_len
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|INNER_THAN
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* stack grows downward */
name|sp
operator|-=
name|aligned_len
expr_stmt|;
comment|/* ... so the address of the thing we push is the 		     stack pointer after we push it.  */
name|addr
operator|=
name|sp
expr_stmt|;
block|}
else|else
block|{
comment|/* The stack grows up, so the address of the thing 		     we push is the stack pointer before we push it.  */
name|addr
operator|=
name|sp
expr_stmt|;
name|sp
operator|+=
name|aligned_len
expr_stmt|;
block|}
comment|/* Push the structure.  */
name|write_memory
argument_list|(
name|addr
argument_list|,
name|VALUE_CONTENTS_ALL
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* The value we're going to pass is the address of the 		 thing we just pushed.  */
comment|/*args[i] = value_from_longest (lookup_pointer_type (value_type), 		(LONGEST) addr); */
name|args
index|[
name|i
index|]
operator|=
name|value_from_pointer
argument_list|(
name|lookup_pointer_type
argument_list|(
name|arg_type
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Reserve space for the return structure to be written on the      stack, if necessary */
if|if
condition|(
name|struct_return
condition|)
block|{
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|value_type
argument_list|)
decl_stmt|;
if|if
condition|(
name|STACK_ALIGN_P
argument_list|()
condition|)
comment|/* MVS 11/22/96: I think at least some of this stack_align 	   code is really broken.  Better to let PUSH_ARGUMENTS adjust 	   the stack in a target-defined manner.  */
name|len
operator|=
name|STACK_ALIGN
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|INNER_THAN
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* stack grows downward */
name|sp
operator|-=
name|len
expr_stmt|;
name|struct_addr
operator|=
name|sp
expr_stmt|;
block|}
else|else
block|{
comment|/* stack grows upward */
name|struct_addr
operator|=
name|sp
expr_stmt|;
name|sp
operator|+=
name|len
expr_stmt|;
block|}
block|}
comment|/* elz: on HPPA no need for this extra alignment, maybe it is needed      on other architectures. This is because all the alignment is      taken care of in the above code (ifdef REG_STRUCT_HAS_ADDR) and      in hppa_push_arguments */
if|if
condition|(
name|EXTRA_STACK_ALIGNMENT_NEEDED
condition|)
block|{
comment|/* MVS 11/22/96: I think at least some of this stack_align code 	 is really broken.  Better to let PUSH_ARGUMENTS adjust the 	 stack in a target-defined manner.  */
if|if
condition|(
name|STACK_ALIGN_P
argument_list|()
operator|&&
name|INNER_THAN
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* If stack grows down, we must leave a hole at the top. */
name|int
name|len
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|nargs
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|len
operator|+=
name|TYPE_LENGTH
argument_list|(
name|VALUE_ENCLOSING_TYPE
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|CALL_DUMMY_STACK_ADJUST_P
condition|)
name|len
operator|+=
name|CALL_DUMMY_STACK_ADJUST
expr_stmt|;
name|sp
operator|-=
name|STACK_ALIGN
argument_list|(
name|len
argument_list|)
operator|-
name|len
expr_stmt|;
block|}
block|}
name|sp
operator|=
name|PUSH_ARGUMENTS
argument_list|(
name|nargs
argument_list|,
name|args
argument_list|,
name|sp
argument_list|,
name|struct_return
argument_list|,
name|struct_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|PUSH_RETURN_ADDRESS_P
argument_list|()
condition|)
comment|/* for targets that use no CALL_DUMMY */
comment|/* There are a number of targets now which actually don't write        any CALL_DUMMY instructions into the target, but instead just        save the machine state, push the arguments, and jump directly        to the callee function.  Since this doesn't actually involve        executing a JSR/BSR instruction, the return address must be set        up by hand, either by pushing onto the stack or copying into a        return-address register as appropriate.  Formerly this has been        done in PUSH_ARGUMENTS, but that's overloading its        functionality a bit, so I'm making it explicit to do it here.  */
name|sp
operator|=
name|PUSH_RETURN_ADDRESS
argument_list|(
name|real_pc
argument_list|,
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|STACK_ALIGN_P
argument_list|()
operator|&&
operator|!
name|INNER_THAN
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* If stack grows up, we must leave a hole at the bottom, note          that sp already has been advanced for the arguments!  */
if|if
condition|(
name|CALL_DUMMY_STACK_ADJUST_P
condition|)
name|sp
operator|+=
name|CALL_DUMMY_STACK_ADJUST
expr_stmt|;
name|sp
operator|=
name|STACK_ALIGN
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
comment|/* XXX This seems wrong.  For stacks that grow down we shouldn't do    anything here!  */
comment|/* MVS 11/22/96: I think at least some of this stack_align code is      really broken.  Better to let PUSH_ARGUMENTS adjust the stack in      a target-defined manner.  */
if|if
condition|(
name|CALL_DUMMY_STACK_ADJUST_P
condition|)
if|if
condition|(
name|INNER_THAN
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* stack grows downward */
name|sp
operator|-=
name|CALL_DUMMY_STACK_ADJUST
expr_stmt|;
block|}
comment|/* Store the address at which the structure is supposed to be      written.  Note that this (and the code which reserved the space      above) assumes that gcc was used to compile this function.  Since      it doesn't cost us anything but space and if the function is pcc      it will ignore this value, we will make that assumption.       Also note that on some machines (like the sparc) pcc uses a      convention like gcc's.  */
if|if
condition|(
name|struct_return
condition|)
name|STORE_STRUCT_RETURN
argument_list|(
name|struct_addr
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/* Write the stack pointer.  This is here because the statements above      might fool with it.  On SPARC, this write also stores the register      window into the right place in the new stack frame, which otherwise      wouldn't happen.  (See store_inferior_registers in sparc-nat.c.)  */
name|write_sp
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|SAVE_DUMMY_FRAME_TOS_P
argument_list|()
condition|)
name|SAVE_DUMMY_FRAME_TOS
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|{
name|char
modifier|*
name|retbuf
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|REGISTER_BYTES
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|symbol
modifier|*
name|symbol
decl_stmt|;
name|name
operator|=
name|NULL
expr_stmt|;
name|symbol
operator|=
name|find_pc_function
argument_list|(
name|funaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|symbol
condition|)
block|{
name|name
operator|=
name|SYMBOL_SOURCE_NAME
argument_list|(
name|symbol
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Try the minimal symbols.  */
name|struct
name|minimal_symbol
modifier|*
name|msymbol
init|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|funaddr
argument_list|)
decl_stmt|;
if|if
condition|(
name|msymbol
condition|)
block|{
name|name
operator|=
name|SYMBOL_SOURCE_NAME
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|char
name|format
index|[
literal|80
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|format
argument_list|,
literal|"at %s"
argument_list|,
name|local_hex_format
argument_list|()
argument_list|)
expr_stmt|;
name|name
operator|=
name|alloca
argument_list|(
literal|80
argument_list|)
expr_stmt|;
comment|/* FIXME-32x64: assumes funaddr fits in a long.  */
name|sprintf
argument_list|(
name|name
argument_list|,
name|format
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|funaddr
argument_list|)
expr_stmt|;
block|}
comment|/* Execute the stack dummy routine, calling FUNCTION.        When it is done, discard the empty frame        after storing the contents of all regs into retbuf.  */
name|rc
operator|=
name|run_stack_dummy
argument_list|(
name|real_pc
operator|+
name|CALL_DUMMY_START_OFFSET
argument_list|,
name|retbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|1
condition|)
block|{
comment|/* We stopped inside the FUNCTION because of a random signal. 	   Further execution of the FUNCTION is not allowed. */
if|if
condition|(
name|unwind_on_signal_p
condition|)
block|{
comment|/* The user wants the context restored. */
comment|/* We must get back to the frame we were before the dummy call. */
name|POP_FRAME
expr_stmt|;
comment|/* FIXME: Insert a bunch of wrap_here; name can be very long if it's 	       a C++ name with arguments and stuff.  */
name|error
argument_list|(
literal|"\ The program being debugged was signaled while in a function called from GDB.\n\ GDB has restored the context to what it was before the call.\n\ To change this behavior use \"set unwindonsignal off\"\n\ Evaluation of the expression containing the function (%s) will be abandoned."
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The user wants to stay in the frame where we stopped (default).*/
comment|/* If we did the cleanups, we would print a spurious error 	       message (Unable to restore previously selected frame), 	       would write the registers from the inf_status (which is 	       wrong), and would do other wrong things.  */
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
name|discard_inferior_status
argument_list|(
name|inf_status
argument_list|)
expr_stmt|;
comment|/* FIXME: Insert a bunch of wrap_here; name can be very long if it's 	       a C++ name with arguments and stuff.  */
name|error
argument_list|(
literal|"\ The program being debugged was signaled while in a function called from GDB.\n\ GDB remains in the frame where the signal was received.\n\ To change this behavior use \"set unwindonsignal on\"\n\ Evaluation of the expression containing the function (%s) will be abandoned."
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rc
operator|==
literal|2
condition|)
block|{
comment|/* We hit a breakpoint inside the FUNCTION. */
comment|/* If we did the cleanups, we would print a spurious error 	   message (Unable to restore previously selected frame), 	   would write the registers from the inf_status (which is 	   wrong), and would do other wrong things.  */
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
name|discard_inferior_status
argument_list|(
name|inf_status
argument_list|)
expr_stmt|;
comment|/* The following error message used to say "The expression 	   which contained the function call has been discarded."  It 	   is a hard concept to explain in a few words.  Ideally, GDB 	   would be able to resume evaluation of the expression when 	   the function finally is done executing.  Perhaps someday 	   this will be implemented (it would not be easy).  */
comment|/* FIXME: Insert a bunch of wrap_here; name can be very long if it's 	   a C++ name with arguments and stuff.  */
name|error
argument_list|(
literal|"\ The program being debugged stopped while in a function called from GDB.\n\ When the function (%s) is done executing, GDB will silently\n\ stop (instead of continuing to evaluate the expression containing\n\ the function call)."
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* If we get here the called FUNCTION run to completion. */
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
comment|/* Figure out the value returned by the function.  */
comment|/* elz: I defined this new macro for the hppa architecture only.    this gives us a way to get the value returned by the function from the stack,    at the same address we told the function to put it.    We cannot assume on the pa that r28 still contains the address of the returned    structure. Usually this will be overwritten by the callee.    I don't know about other architectures, so I defined this macro  */
ifdef|#
directive|ifdef
name|VALUE_RETURNED_FROM_STACK
if|if
condition|(
name|struct_return
condition|)
return|return
operator|(
expr|struct
name|value
operator|*
operator|)
name|VALUE_RETURNED_FROM_STACK
argument_list|(
name|value_type
argument_list|,
name|struct_addr
argument_list|)
return|;
endif|#
directive|endif
return|return
name|value_being_returned
argument_list|(
name|value_type
argument_list|,
name|retbuf
argument_list|,
name|struct_return
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|struct
name|value
modifier|*
name|call_function_by_hand
parameter_list|(
name|struct
name|value
modifier|*
name|function
parameter_list|,
name|int
name|nargs
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|args
parameter_list|)
block|{
if|if
condition|(
name|CALL_DUMMY_P
condition|)
block|{
return|return
name|hand_function_call
argument_list|(
name|function
argument_list|,
name|nargs
argument_list|,
name|args
argument_list|)
return|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"Cannot invoke functions on this machine."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create a value for an array by allocating space in the inferior, copying    the data into that space, and then setting up an array value.     The array bounds are set from LOWBOUND and HIGHBOUND, and the array is    populated from the values passed in ELEMVEC.     The element type of the array is inherited from the type of the    first element, and all elements must have the same size (though we    don't currently enforce any restriction on their types). */
end_comment

begin_function
name|struct
name|value
modifier|*
name|value_array
parameter_list|(
name|int
name|lowbound
parameter_list|,
name|int
name|highbound
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|elemvec
parameter_list|)
block|{
name|int
name|nelem
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|unsigned
name|int
name|typelength
decl_stmt|;
name|struct
name|value
modifier|*
name|val
decl_stmt|;
name|struct
name|type
modifier|*
name|rangetype
decl_stmt|;
name|struct
name|type
modifier|*
name|arraytype
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
comment|/* Validate that the bounds are reasonable and that each of the elements      have the same size. */
name|nelem
operator|=
name|highbound
operator|-
name|lowbound
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|nelem
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"bad array bounds (%d, %d)"
argument_list|,
name|lowbound
argument_list|,
name|highbound
argument_list|)
expr_stmt|;
block|}
name|typelength
operator|=
name|TYPE_LENGTH
argument_list|(
name|VALUE_ENCLOSING_TYPE
argument_list|(
name|elemvec
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|1
init|;
name|idx
operator|<
name|nelem
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|VALUE_ENCLOSING_TYPE
argument_list|(
name|elemvec
index|[
name|idx
index|]
argument_list|)
argument_list|)
operator|!=
name|typelength
condition|)
block|{
name|error
argument_list|(
literal|"array elements must all be the same size"
argument_list|)
expr_stmt|;
block|}
block|}
name|rangetype
operator|=
name|create_range_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|builtin_type_int
argument_list|,
name|lowbound
argument_list|,
name|highbound
argument_list|)
expr_stmt|;
name|arraytype
operator|=
name|create_array_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|VALUE_ENCLOSING_TYPE
argument_list|(
name|elemvec
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|rangetype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|current_language
operator|->
name|c_style_arrays
condition|)
block|{
name|val
operator|=
name|allocate_value
argument_list|(
name|arraytype
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|nelem
condition|;
name|idx
operator|++
control|)
block|{
name|memcpy
argument_list|(
name|VALUE_CONTENTS_ALL_RAW
argument_list|(
name|val
argument_list|)
operator|+
operator|(
name|idx
operator|*
name|typelength
operator|)
argument_list|,
name|VALUE_CONTENTS_ALL
argument_list|(
name|elemvec
index|[
name|idx
index|]
argument_list|)
argument_list|,
name|typelength
argument_list|)
expr_stmt|;
block|}
name|VALUE_BFD_SECTION
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_BFD_SECTION
argument_list|(
name|elemvec
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
comment|/* Allocate space to store the array in the inferior, and then initialize      it by copying in each element.  FIXME:  Is it worth it to create a      local buffer in which to collect each value and then write all the      bytes in one operation? */
name|addr
operator|=
name|allocate_space_in_inferior
argument_list|(
name|nelem
operator|*
name|typelength
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|nelem
condition|;
name|idx
operator|++
control|)
block|{
name|write_memory
argument_list|(
name|addr
operator|+
operator|(
name|idx
operator|*
name|typelength
operator|)
argument_list|,
name|VALUE_CONTENTS_ALL
argument_list|(
name|elemvec
index|[
name|idx
index|]
argument_list|)
argument_list|,
name|typelength
argument_list|)
expr_stmt|;
block|}
comment|/* Create the array type and set up an array value to be evaluated lazily. */
name|val
operator|=
name|value_at_lazy
argument_list|(
name|arraytype
argument_list|,
name|addr
argument_list|,
name|VALUE_BFD_SECTION
argument_list|(
name|elemvec
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Create a value for a string constant by allocating space in the inferior,    copying the data into that space, and returning the address with type    TYPE_CODE_STRING.  PTR points to the string constant data; LEN is number    of characters.    Note that string types are like array of char types with a lower bound of    zero and an upper bound of LEN - 1.  Also note that the string may contain    embedded null bytes. */
end_comment

begin_function
name|struct
name|value
modifier|*
name|value_string
parameter_list|(
name|char
modifier|*
name|ptr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|val
decl_stmt|;
name|int
name|lowbound
init|=
name|current_language
operator|->
name|string_lower_bound
decl_stmt|;
name|struct
name|type
modifier|*
name|rangetype
init|=
name|create_range_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|builtin_type_int
argument_list|,
name|lowbound
argument_list|,
name|len
operator|+
name|lowbound
operator|-
literal|1
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|stringtype
init|=
name|create_string_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|rangetype
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
if|if
condition|(
name|current_language
operator|->
name|c_style_arrays
operator|==
literal|0
condition|)
block|{
name|val
operator|=
name|allocate_value
argument_list|(
name|stringtype
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
comment|/* Allocate space to store the string in the inferior, and then      copy LEN bytes from PTR in gdb to that address in the inferior. */
name|addr
operator|=
name|allocate_space_in_inferior
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|addr
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|val
operator|=
name|value_at_lazy
argument_list|(
name|stringtype
argument_list|,
name|addr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|value
modifier|*
name|value_bitstring
parameter_list|(
name|char
modifier|*
name|ptr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|val
decl_stmt|;
name|struct
name|type
modifier|*
name|domain_type
init|=
name|create_range_type
argument_list|(
name|NULL
argument_list|,
name|builtin_type_int
argument_list|,
literal|0
argument_list|,
name|len
operator|-
literal|1
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|type
init|=
name|create_set_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|domain_type
argument_list|)
decl_stmt|;
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_BITSTRING
expr_stmt|;
name|val
operator|=
name|allocate_value
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
argument_list|,
name|ptr
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* See if we can pass arguments in T2 to a function which takes arguments    of types T1.  Both t1 and t2 are NULL-terminated vectors.  If some    arguments need coercion of some sort, then the coerced values are written    into T2.  Return value is 0 if the arguments could be matched, or the    position at which they differ if not.     STATICP is nonzero if the T1 argument list came from a    static member function.     For non-static member functions, we ignore the first argument,    which is the type of the instance variable.  This is because we want    to handle calls with objects from derived classes.  This is not    entirely correct: we should actually check to make sure that a    requested operation is type secure, shouldn't we?  FIXME.  */
end_comment

begin_function
specifier|static
name|int
name|typecmp
parameter_list|(
name|int
name|staticp
parameter_list|,
name|struct
name|type
modifier|*
name|t1
index|[]
parameter_list|,
name|struct
name|value
modifier|*
name|t2
index|[]
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|t2
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|staticp
operator|&&
name|t1
operator|==
literal|0
condition|)
return|return
name|t2
index|[
literal|1
index|]
operator|!=
literal|0
return|;
if|if
condition|(
name|t1
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|t1
index|[
literal|0
index|]
argument_list|)
operator|==
name|TYPE_CODE_VOID
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|t1
index|[
operator|!
name|staticp
index|]
operator|==
literal|0
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
operator|!
name|staticp
init|;
name|t1
index|[
name|i
index|]
operator|&&
name|TYPE_CODE
argument_list|(
name|t1
index|[
name|i
index|]
argument_list|)
operator|!=
name|TYPE_CODE_VOID
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|type
modifier|*
name|tt1
decl_stmt|,
modifier|*
name|tt2
decl_stmt|;
if|if
condition|(
operator|!
name|t2
index|[
name|i
index|]
condition|)
return|return
name|i
operator|+
literal|1
return|;
name|tt1
operator|=
name|check_typedef
argument_list|(
name|t1
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|tt2
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|t2
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|tt1
argument_list|)
operator|==
name|TYPE_CODE_REF
comment|/* We should be doing hairy argument matching, as below.  */
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|tt1
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE
argument_list|(
name|tt2
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|tt2
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
condition|)
name|t2
index|[
name|i
index|]
operator|=
name|value_coerce_array
argument_list|(
name|t2
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|t2
index|[
name|i
index|]
operator|=
name|value_addr
argument_list|(
name|t2
index|[
name|i
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* djb - 20000715 - Until the new type structure is in the 	 place, and we can attempt things like implicit conversions, 	 we need to do this so you can take something like a map<const 	 char *>, and properly access map["hello"], because the 	 argument to [] will be a reference to a pointer to a char, 	 and the argument will be a pointer to a char. */
while|while
condition|(
name|TYPE_CODE
argument_list|(
name|tt1
argument_list|)
operator|==
name|TYPE_CODE_REF
operator|||
name|TYPE_CODE
argument_list|(
name|tt1
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
block|{
name|tt1
operator|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|tt1
argument_list|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|TYPE_CODE
argument_list|(
name|tt2
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
operator|||
name|TYPE_CODE
argument_list|(
name|tt2
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|||
name|TYPE_CODE
argument_list|(
name|tt2
argument_list|)
operator|==
name|TYPE_CODE_REF
condition|)
block|{
name|tt2
operator|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|tt2
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|tt1
argument_list|)
operator|==
name|TYPE_CODE
argument_list|(
name|tt2
argument_list|)
condition|)
continue|continue;
comment|/* Array to pointer is a `trivial conversion' according to the ARM.  */
comment|/* We should be doing much hairier argument matching (see section 13.2          of the ARM), but as a quick kludge, just check for the same type          code.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|t1
index|[
name|i
index|]
argument_list|)
operator|!=
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|t2
index|[
name|i
index|]
argument_list|)
argument_list|)
condition|)
return|return
name|i
operator|+
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|t1
index|[
name|i
index|]
condition|)
return|return
literal|0
return|;
return|return
name|t2
index|[
name|i
index|]
condition|?
name|i
operator|+
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Helper function used by value_struct_elt to recurse through baseclasses.    Look for a field NAME in ARG1. Adjust the address of ARG1 by OFFSET bytes,    and search in it assuming it has (class) type TYPE.    If found, return value, else return NULL.     If LOOKING_FOR_BASECLASS, then instead of looking for struct fields,    look for a baseclass named NAME.  */
end_comment

begin_function
specifier|static
name|struct
name|value
modifier|*
name|search_struct_field
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|value
modifier|*
name|arg1
parameter_list|,
name|int
name|offset
parameter_list|,
specifier|register
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|looking_for_baseclass
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|nbases
init|=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|looking_for_baseclass
condition|)
for|for
control|(
name|i
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
name|nbases
condition|;
name|i
operator|--
control|)
block|{
name|char
modifier|*
name|t_field_name
init|=
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|t_field_name
operator|&&
operator|(
name|strcmp_iw
argument_list|(
name|t_field_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|struct
name|value
modifier|*
name|v
decl_stmt|;
if|if
condition|(
name|TYPE_FIELD_STATIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
name|v
operator|=
name|value_static_field
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
expr_stmt|;
else|else
name|v
operator|=
name|value_primitive_field
argument_list|(
name|arg1
argument_list|,
name|offset
argument_list|,
name|i
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"there is no field named %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
if|if
condition|(
name|t_field_name
operator|&&
operator|(
name|t_field_name
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_UNION
operator|&&
operator|(
name|strcmp_iw
argument_list|(
name|t_field_name
argument_list|,
literal|"else"
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
name|struct
name|type
modifier|*
name|field_type
init|=
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|field_type
argument_list|)
operator|==
name|TYPE_CODE_UNION
operator|||
name|TYPE_CODE
argument_list|(
name|field_type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
condition|)
block|{
comment|/* Look for a match through the fields of an anonymous union, 		   or anonymous struct.  C++ provides anonymous unions.  		   In the GNU Chill implementation of variant record types, 		   each<alternative field> has an (anonymous) union type, 		   each member of the union represents a<variant alternative>. 		   Each<variant alternative> is represented as a struct, 		   with a member for each<variant field>.  */
name|struct
name|value
modifier|*
name|v
decl_stmt|;
name|int
name|new_offset
init|=
name|offset
decl_stmt|;
comment|/* This is pretty gross.  In G++, the offset in an anonymous 		   union is relative to the beginning of the enclosing struct. 		   In the GNU Chill implementation of variant records, 		   the bitpos is zero in an anonymous union field, so we 		   have to add the offset of the union here. */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|field_type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|||
operator|(
name|TYPE_NFIELDS
argument_list|(
name|field_type
argument_list|)
operator|>
literal|0
operator|&&
name|TYPE_FIELD_BITPOS
argument_list|(
name|field_type
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|new_offset
operator|+=
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|/
literal|8
expr_stmt|;
name|v
operator|=
name|search_struct_field
argument_list|(
name|name
argument_list|,
name|arg1
argument_list|,
name|new_offset
argument_list|,
name|field_type
argument_list|,
name|looking_for_baseclass
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
condition|)
return|return
name|v
return|;
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbases
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|value
modifier|*
name|v
decl_stmt|;
name|struct
name|type
modifier|*
name|basetype
init|=
name|check_typedef
argument_list|(
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If we are looking for baseclasses, this is what we get when we          hit them.  But it could happen that the base part's member name          is not yet filled in.  */
name|int
name|found_baseclass
init|=
operator|(
name|looking_for_baseclass
operator|&&
name|TYPE_BASECLASS_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|!=
name|NULL
operator|&&
operator|(
name|strcmp_iw
argument_list|(
name|name
argument_list|,
name|TYPE_BASECLASS_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|BASETYPE_VIA_VIRTUAL
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|int
name|boffset
decl_stmt|;
name|struct
name|value
modifier|*
name|v2
init|=
name|allocate_value
argument_list|(
name|basetype
argument_list|)
decl_stmt|;
name|boffset
operator|=
name|baseclass_offset
argument_list|(
name|type
argument_list|,
name|i
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|arg1
argument_list|)
operator|+
name|offset
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|arg1
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|arg1
argument_list|)
operator|+
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|boffset
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"virtual baseclass botch"
argument_list|)
expr_stmt|;
comment|/* The virtual base class pointer might have been clobbered by the 	     user program. Make sure that it still points to a valid memory 	     location.  */
name|boffset
operator|+=
name|offset
expr_stmt|;
if|if
condition|(
name|boffset
operator|<
literal|0
operator|||
name|boffset
operator|>=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|CORE_ADDR
name|base_addr
decl_stmt|;
name|base_addr
operator|=
name|VALUE_ADDRESS
argument_list|(
name|arg1
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|arg1
argument_list|)
operator|+
name|boffset
expr_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|base_addr
argument_list|,
name|VALUE_CONTENTS_RAW
argument_list|(
name|v2
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|basetype
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"virtual baseclass botch"
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|v2
argument_list|)
operator|=
name|lval_memory
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|v2
argument_list|)
operator|=
name|base_addr
expr_stmt|;
block|}
else|else
block|{
name|VALUE_LVAL
argument_list|(
name|v2
argument_list|)
operator|=
name|VALUE_LVAL
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|v2
argument_list|)
operator|=
name|VALUE_ADDRESS
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|VALUE_OFFSET
argument_list|(
name|v2
argument_list|)
operator|=
name|VALUE_OFFSET
argument_list|(
name|arg1
argument_list|)
operator|+
name|boffset
expr_stmt|;
if|if
condition|(
name|VALUE_LAZY
argument_list|(
name|arg1
argument_list|)
condition|)
name|VALUE_LAZY
argument_list|(
name|v2
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|v2
argument_list|)
argument_list|,
name|VALUE_CONTENTS_RAW
argument_list|(
name|arg1
argument_list|)
operator|+
name|boffset
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|basetype
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|found_baseclass
condition|)
return|return
name|v2
return|;
name|v
operator|=
name|search_struct_field
argument_list|(
name|name
argument_list|,
name|v2
argument_list|,
literal|0
argument_list|,
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|looking_for_baseclass
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|found_baseclass
condition|)
name|v
operator|=
name|value_primitive_field
argument_list|(
name|arg1
argument_list|,
name|offset
argument_list|,
name|i
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|v
operator|=
name|search_struct_field
argument_list|(
name|name
argument_list|,
name|arg1
argument_list|,
name|offset
operator|+
name|TYPE_BASECLASS_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|/
literal|8
argument_list|,
name|basetype
argument_list|,
name|looking_for_baseclass
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
condition|)
return|return
name|v
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the offset (in bytes) of the virtual base of type BASETYPE  * in an object pointed to by VALADDR (on the host), assumed to be of  * type TYPE.  OFFSET is number of bytes beyond start of ARG to start  * looking (in case VALADDR is the contents of an enclosing object).  *  * This routine recurses on the primary base of the derived class because  * the virtual base entries of the primary base appear before the other  * virtual base entries.  *  * If the virtual base is not found, a negative integer is returned.  * The magnitude of the negative integer is the number of entries in  * the virtual table to skip over (entries corresponding to various  * ancestral classes in the chain of primary bases).  *  * Important: This assumes the HP / Taligent C++ runtime  * conventions. Use baseclass_offset() instead to deal with g++  * conventions.  */
end_comment

begin_function
name|void
name|find_rt_vbase_offset
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|type
modifier|*
name|basetype
parameter_list|,
name|char
modifier|*
name|valaddr
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
modifier|*
name|boffset_p
parameter_list|,
name|int
modifier|*
name|skip_p
parameter_list|)
block|{
name|int
name|boffset
decl_stmt|;
comment|/* offset of virtual base */
name|int
name|index
decl_stmt|;
comment|/* displacement to use in virtual table */
name|int
name|skip
decl_stmt|;
name|struct
name|value
modifier|*
name|vp
decl_stmt|;
name|CORE_ADDR
name|vtbl
decl_stmt|;
comment|/* the virtual table pointer */
name|struct
name|type
modifier|*
name|pbc
decl_stmt|;
comment|/* the primary base class */
comment|/* Look for the virtual base recursively in the primary base, first.    * This is because the derived class object and its primary base    * subobject share the primary virtual table.  */
name|boffset
operator|=
literal|0
expr_stmt|;
name|pbc
operator|=
name|TYPE_PRIMARY_BASE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|pbc
condition|)
block|{
name|find_rt_vbase_offset
argument_list|(
name|pbc
argument_list|,
name|basetype
argument_list|,
name|valaddr
argument_list|,
name|offset
argument_list|,
operator|&
name|boffset
argument_list|,
operator|&
name|skip
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip
operator|<
literal|0
condition|)
block|{
operator|*
name|boffset_p
operator|=
name|boffset
expr_stmt|;
operator|*
name|skip_p
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
block|}
else|else
name|skip
operator|=
literal|0
expr_stmt|;
comment|/* Find the index of the virtual base according to HP/Taligent      runtime spec. (Depth-first, left-to-right.)  */
name|index
operator|=
name|virtual_base_index_skip_primaries
argument_list|(
name|basetype
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
condition|)
block|{
operator|*
name|skip_p
operator|=
name|skip
operator|+
name|virtual_base_list_length_skip_primaries
argument_list|(
name|type
argument_list|)
expr_stmt|;
operator|*
name|boffset_p
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* pai: FIXME -- 32x64 possible problem */
comment|/* First word (4 bytes) in object layout is the vtable pointer */
name|vtbl
operator|=
operator|*
operator|(
name|CORE_ADDR
operator|*
operator|)
operator|(
name|valaddr
operator|+
name|offset
operator|)
expr_stmt|;
comment|/* Before the constructor is invoked, things are usually zero'd out. */
if|if
condition|(
name|vtbl
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Couldn't find virtual table -- object may not be constructed yet."
argument_list|)
expr_stmt|;
comment|/* Find virtual base's offset -- jump over entries for primary base    * ancestors, then use the index computed above.  But also adjust by    * HP_ACC_VBASE_START for the vtable slots before the start of the    * virtual base entries.  Offset is negative -- virtual base entries    * appear _before_ the address point of the virtual table. */
comment|/* pai: FIXME -- 32x64 problem, if word = 8 bytes, change multiplier& use long type */
comment|/* epstein : FIXME -- added param for overlay section. May not be correct */
name|vp
operator|=
name|value_at
argument_list|(
name|builtin_type_int
argument_list|,
name|vtbl
operator|+
literal|4
operator|*
operator|(
operator|-
name|skip
operator|-
name|index
operator|-
name|HP_ACC_VBASE_START
operator|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|boffset
operator|=
name|value_as_long
argument_list|(
name|vp
argument_list|)
expr_stmt|;
operator|*
name|skip_p
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|boffset_p
operator|=
name|boffset
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Helper function used by value_struct_elt to recurse through baseclasses.    Look for a field NAME in ARG1. Adjust the address of ARG1 by OFFSET bytes,    and search in it assuming it has (class) type TYPE.    If found, return value, else if name matched and args not return (value)-1,    else return NULL. */
end_comment

begin_function
specifier|static
name|struct
name|value
modifier|*
name|search_struct_method
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|arg1p
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|args
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
modifier|*
name|static_memfuncp
parameter_list|,
specifier|register
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|value
modifier|*
name|v
decl_stmt|;
name|int
name|name_matched
init|=
literal|0
decl_stmt|;
name|char
name|dem_opname
index|[
literal|64
index|]
decl_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|char
modifier|*
name|t_field_name
init|=
name|TYPE_FN_FIELDLIST_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* FIXME!  May need to check for ARM demangling here */
if|if
condition|(
name|strncmp
argument_list|(
name|t_field_name
argument_list|,
literal|"__"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|t_field_name
argument_list|,
literal|"op"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|t_field_name
argument_list|,
literal|"type"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cplus_demangle_opname
argument_list|(
name|t_field_name
argument_list|,
name|dem_opname
argument_list|,
name|DMGL_ANSI
argument_list|)
condition|)
name|t_field_name
operator|=
name|dem_opname
expr_stmt|;
elseif|else
if|if
condition|(
name|cplus_demangle_opname
argument_list|(
name|t_field_name
argument_list|,
name|dem_opname
argument_list|,
literal|0
argument_list|)
condition|)
name|t_field_name
operator|=
name|dem_opname
expr_stmt|;
block|}
if|if
condition|(
name|t_field_name
operator|&&
operator|(
name|strcmp_iw
argument_list|(
name|t_field_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|int
name|j
init|=
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|-
literal|1
decl_stmt|;
name|struct
name|fn_field
modifier|*
name|f
init|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|name_matched
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|j
operator|>
literal|0
operator|&&
name|args
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"cannot resolve overloaded method `%s': no arguments supplied"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|j
operator|==
literal|0
operator|&&
name|args
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|TYPE_FN_FIELD_STUB
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
name|check_stub_method
argument_list|(
name|type
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|v
operator|=
name|value_fn_field
argument_list|(
name|arg1p
argument_list|,
name|f
argument_list|,
name|j
argument_list|,
name|type
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|!=
name|NULL
condition|)
return|return
name|v
return|;
block|}
else|else
while|while
condition|(
name|j
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|TYPE_FN_FIELD_STUB
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
name|check_stub_method
argument_list|(
name|type
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|typecmp
argument_list|(
name|TYPE_FN_FIELD_STATIC_P
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|,
name|TYPE_FN_FIELD_ARGS
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|,
name|args
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_FN_FIELD_VIRTUAL_P
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
return|return
name|value_virtual_fn_field
argument_list|(
name|arg1p
argument_list|,
name|f
argument_list|,
name|j
argument_list|,
name|type
argument_list|,
name|offset
argument_list|)
return|;
if|if
condition|(
name|TYPE_FN_FIELD_STATIC_P
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
operator|&&
name|static_memfuncp
condition|)
operator|*
name|static_memfuncp
operator|=
literal|1
expr_stmt|;
name|v
operator|=
name|value_fn_field
argument_list|(
name|arg1p
argument_list|,
name|f
argument_list|,
name|j
argument_list|,
name|type
argument_list|,
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|!=
name|NULL
condition|)
return|return
name|v
return|;
block|}
name|j
operator|--
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|base_offset
decl_stmt|;
if|if
condition|(
name|BASETYPE_VIA_VIRTUAL
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_HAS_VTABLE
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* HP aCC compiled type, search for virtual base offset 	         according to HP/Taligent runtime spec.  */
name|int
name|skip
decl_stmt|;
name|find_rt_vbase_offset
argument_list|(
name|type
argument_list|,
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|VALUE_CONTENTS_ALL
argument_list|(
operator|*
name|arg1p
argument_list|)
argument_list|,
name|offset
operator|+
name|VALUE_EMBEDDED_OFFSET
argument_list|(
operator|*
name|arg1p
argument_list|)
argument_list|,
operator|&
name|base_offset
argument_list|,
operator|&
name|skip
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip
operator|>=
literal|0
condition|)
name|error
argument_list|(
literal|"Virtual base class offset not found in vtable"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|type
modifier|*
name|baseclass
init|=
name|check_typedef
argument_list|(
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|base_valaddr
decl_stmt|;
comment|/* The virtual base class pointer might have been clobbered by the 	         user program. Make sure that it still points to a valid memory 	         location.  */
if|if
condition|(
name|offset
operator|<
literal|0
operator|||
name|offset
operator|>=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|base_valaddr
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|TYPE_LENGTH
argument_list|(
name|baseclass
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|VALUE_ADDRESS
argument_list|(
operator|*
name|arg1p
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
operator|*
name|arg1p
argument_list|)
operator|+
name|offset
argument_list|,
name|base_valaddr
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|baseclass
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"virtual baseclass botch"
argument_list|)
expr_stmt|;
block|}
else|else
name|base_valaddr
operator|=
name|VALUE_CONTENTS
argument_list|(
operator|*
name|arg1p
argument_list|)
operator|+
name|offset
expr_stmt|;
name|base_offset
operator|=
name|baseclass_offset
argument_list|(
name|type
argument_list|,
name|i
argument_list|,
name|base_valaddr
argument_list|,
name|VALUE_ADDRESS
argument_list|(
operator|*
name|arg1p
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
operator|*
name|arg1p
argument_list|)
operator|+
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_offset
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"virtual baseclass botch"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|base_offset
operator|=
name|TYPE_BASECLASS_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|/
literal|8
expr_stmt|;
block|}
name|v
operator|=
name|search_struct_method
argument_list|(
name|name
argument_list|,
name|arg1p
argument_list|,
name|args
argument_list|,
name|base_offset
operator|+
name|offset
argument_list|,
name|static_memfuncp
argument_list|,
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
operator|(
expr|struct
name|value
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
name|name_matched
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v
condition|)
block|{
comment|/* FIXME-bothner:  Why is this commented out?  Why is it here?  */
comment|/*        *arg1p = arg1_tmp; */
return|return
name|v
return|;
block|}
block|}
if|if
condition|(
name|name_matched
condition|)
return|return
operator|(
expr|struct
name|value
operator|*
operator|)
operator|-
literal|1
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Given *ARGP, a value of type (pointer to a)* structure/union,    extract the component named NAME from the ultimate target structure/union    and return it as a value with its appropriate type.    ERR is used in the error message if *ARGP's type is wrong.     C++: ARGS is a list of argument types to aid in the selection of    an appropriate method. Also, handle derived types.     STATIC_MEMFUNCP, if non-NULL, points to a caller-supplied location    where the truthvalue of whether the function that was resolved was    a static member function or not is stored.     ERR is an error message to be printed in case the field is not found.  */
end_comment

begin_function
name|struct
name|value
modifier|*
name|value_struct_elt
parameter_list|(
name|struct
name|value
modifier|*
modifier|*
name|argp
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|args
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
modifier|*
name|static_memfuncp
parameter_list|,
name|char
modifier|*
name|err
parameter_list|)
block|{
specifier|register
name|struct
name|type
modifier|*
name|t
decl_stmt|;
name|struct
name|value
modifier|*
name|v
decl_stmt|;
name|COERCE_ARRAY
argument_list|(
operator|*
name|argp
argument_list|)
expr_stmt|;
name|t
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
operator|*
name|argp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Follow pointers until we get to a non-pointer.  */
while|while
condition|(
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|||
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_CODE_REF
condition|)
block|{
operator|*
name|argp
operator|=
name|value_ind
argument_list|(
operator|*
name|argp
argument_list|)
expr_stmt|;
comment|/* Don't coerce fn pointer to fn and then back again!  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
operator|*
name|argp
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_FUNC
condition|)
name|COERCE_ARRAY
argument_list|(
operator|*
name|argp
argument_list|)
expr_stmt|;
name|t
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
operator|*
name|argp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_CODE_MEMBER
condition|)
name|error
argument_list|(
literal|"not implemented: member type in value_struct_elt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
operator|&&
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TYPE_CODE_UNION
condition|)
name|error
argument_list|(
literal|"Attempt to extract a component of a value that is not a %s."
argument_list|,
name|err
argument_list|)
expr_stmt|;
comment|/* Assume it's not, unless we see that it is.  */
if|if
condition|(
name|static_memfuncp
condition|)
operator|*
name|static_memfuncp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
block|{
comment|/* if there are no arguments ...do this...  */
comment|/* Try as a field first, because if we succeed, there          is less work to be done.  */
name|v
operator|=
name|search_struct_field
argument_list|(
name|name
argument_list|,
operator|*
name|argp
argument_list|,
literal|0
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
condition|)
return|return
name|v
return|;
comment|/* C++: If it was not found as a data field, then try to          return it as a pointer to a method.  */
if|if
condition|(
name|destructor_name_p
argument_list|(
name|name
argument_list|,
name|t
argument_list|)
condition|)
name|error
argument_list|(
literal|"Cannot get value of destructor"
argument_list|)
expr_stmt|;
name|v
operator|=
name|search_struct_method
argument_list|(
name|name
argument_list|,
name|argp
argument_list|,
name|args
argument_list|,
literal|0
argument_list|,
name|static_memfuncp
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
operator|(
expr|struct
name|value
operator|*
operator|)
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"Cannot take address of a method"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|v
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|TYPE_NFN_FIELDS
argument_list|(
name|t
argument_list|)
condition|)
name|error
argument_list|(
literal|"There is no member or method named %s."
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"There is no member named %s."
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
name|v
return|;
block|}
if|if
condition|(
name|destructor_name_p
argument_list|(
name|name
argument_list|,
name|t
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|args
index|[
literal|1
index|]
condition|)
block|{
comment|/* Destructors are a special case.  */
name|int
name|m_index
decl_stmt|,
name|f_index
decl_stmt|;
name|v
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|get_destructor_fn_field
argument_list|(
name|t
argument_list|,
operator|&
name|m_index
argument_list|,
operator|&
name|f_index
argument_list|)
condition|)
block|{
name|v
operator|=
name|value_fn_field
argument_list|(
name|NULL
argument_list|,
name|TYPE_FN_FIELDLIST1
argument_list|(
name|t
argument_list|,
name|m_index
argument_list|)
argument_list|,
name|f_index
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"could not find destructor function named %s."
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
return|return
name|v
return|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"destructor should not have any argument"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|v
operator|=
name|search_struct_method
argument_list|(
name|name
argument_list|,
name|argp
argument_list|,
name|args
argument_list|,
literal|0
argument_list|,
name|static_memfuncp
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
operator|(
expr|struct
name|value
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"One of the arguments you tried to pass to %s could not be converted to what the function wants."
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|v
operator|==
literal|0
condition|)
block|{
comment|/* See if user tried to invoke data as function.  If so,          hand it back.  If it's not callable (i.e., a pointer to function),          gdb should give an error.  */
name|v
operator|=
name|search_struct_field
argument_list|(
name|name
argument_list|,
operator|*
name|argp
argument_list|,
literal|0
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|v
condition|)
name|error
argument_list|(
literal|"Structure has no component named %s."
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/* Search through the methods of an object (and its bases)  * to find a specified method. Return the pointer to the  * fn_field list of overloaded instances.  * Helper function for value_find_oload_list.  * ARGP is a pointer to a pointer to a value (the object)  * METHOD is a string containing the method name  * OFFSET is the offset within the value  * STATIC_MEMFUNCP is set if the method is static  * TYPE is the assumed type of the object  * NUM_FNS is the number of overloaded instances  * BASETYPE is set to the actual type of the subobject where the method is found  * BOFFSET is the offset of the base subobject where the method is found */
end_comment

begin_function
specifier|static
name|struct
name|fn_field
modifier|*
name|find_method_list
parameter_list|(
name|struct
name|value
modifier|*
modifier|*
name|argp
parameter_list|,
name|char
modifier|*
name|method
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
modifier|*
name|static_memfuncp
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
modifier|*
name|num_fns
parameter_list|,
name|struct
name|type
modifier|*
modifier|*
name|basetype
parameter_list|,
name|int
modifier|*
name|boffset
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|fn_field
modifier|*
name|f
decl_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
operator|*
name|num_fns
operator|=
literal|0
expr_stmt|;
comment|/* First check in object itself */
for|for
control|(
name|i
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|/* pai: FIXME What about operators and type conversions? */
name|char
modifier|*
name|fn_field_name
init|=
name|TYPE_FN_FIELDLIST_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|fn_field_name
operator|&&
operator|(
name|strcmp_iw
argument_list|(
name|fn_field_name
argument_list|,
name|method
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
operator|*
name|num_fns
operator|=
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
expr_stmt|;
operator|*
name|basetype
operator|=
name|type
expr_stmt|;
operator|*
name|boffset
operator|=
name|offset
expr_stmt|;
return|return
name|TYPE_FN_FIELDLIST1
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
return|;
block|}
block|}
comment|/* Not found in object, check in base subobjects */
for|for
control|(
name|i
operator|=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|int
name|base_offset
decl_stmt|;
if|if
condition|(
name|BASETYPE_VIA_VIRTUAL
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_HAS_VTABLE
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* HP aCC compiled type, search for virtual base offset 	       * according to HP/Taligent runtime spec.  */
name|int
name|skip
decl_stmt|;
name|find_rt_vbase_offset
argument_list|(
name|type
argument_list|,
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|VALUE_CONTENTS_ALL
argument_list|(
operator|*
name|argp
argument_list|)
argument_list|,
name|offset
operator|+
name|VALUE_EMBEDDED_OFFSET
argument_list|(
operator|*
name|argp
argument_list|)
argument_list|,
operator|&
name|base_offset
argument_list|,
operator|&
name|skip
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip
operator|>=
literal|0
condition|)
name|error
argument_list|(
literal|"Virtual base class offset not found in vtable"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* probably g++ runtime model */
name|base_offset
operator|=
name|VALUE_OFFSET
argument_list|(
operator|*
name|argp
argument_list|)
operator|+
name|offset
expr_stmt|;
name|base_offset
operator|=
name|baseclass_offset
argument_list|(
name|type
argument_list|,
name|i
argument_list|,
name|VALUE_CONTENTS
argument_list|(
operator|*
name|argp
argument_list|)
operator|+
name|base_offset
argument_list|,
name|VALUE_ADDRESS
argument_list|(
operator|*
name|argp
argument_list|)
operator|+
name|base_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_offset
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"virtual baseclass botch"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* non-virtual base, simply use bit position from debug info */
block|{
name|base_offset
operator|=
name|TYPE_BASECLASS_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|/
literal|8
expr_stmt|;
block|}
name|f
operator|=
name|find_method_list
argument_list|(
name|argp
argument_list|,
name|method
argument_list|,
name|base_offset
operator|+
name|offset
argument_list|,
name|static_memfuncp
argument_list|,
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|num_fns
argument_list|,
name|basetype
argument_list|,
name|boffset
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
condition|)
return|return
name|f
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the list of overloaded methods of a specified name.  * ARGP is a pointer to a pointer to a value (the object)  * METHOD is the method name  * OFFSET is the offset within the value contents  * STATIC_MEMFUNCP is set if the method is static  * NUM_FNS is the number of overloaded instances  * BASETYPE is set to the type of the base subobject that defines the method  * BOFFSET is the offset of the base subobject which defines the method */
end_comment

begin_function
name|struct
name|fn_field
modifier|*
name|value_find_oload_method_list
parameter_list|(
name|struct
name|value
modifier|*
modifier|*
name|argp
parameter_list|,
name|char
modifier|*
name|method
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
modifier|*
name|static_memfuncp
parameter_list|,
name|int
modifier|*
name|num_fns
parameter_list|,
name|struct
name|type
modifier|*
modifier|*
name|basetype
parameter_list|,
name|int
modifier|*
name|boffset
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
operator|*
name|argp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* code snarfed from value_struct_elt */
while|while
condition|(
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|||
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_CODE_REF
condition|)
block|{
operator|*
name|argp
operator|=
name|value_ind
argument_list|(
operator|*
name|argp
argument_list|)
expr_stmt|;
comment|/* Don't coerce fn pointer to fn and then back again!  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
operator|*
name|argp
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_FUNC
condition|)
name|COERCE_ARRAY
argument_list|(
operator|*
name|argp
argument_list|)
expr_stmt|;
name|t
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
operator|*
name|argp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_CODE_MEMBER
condition|)
name|error
argument_list|(
literal|"Not implemented: member type in value_find_oload_lis"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
operator|&&
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TYPE_CODE_UNION
condition|)
name|error
argument_list|(
literal|"Attempt to extract a component of a value that is not a struct or union"
argument_list|)
expr_stmt|;
comment|/* Assume it's not static, unless we see that it is.  */
if|if
condition|(
name|static_memfuncp
condition|)
operator|*
name|static_memfuncp
operator|=
literal|0
expr_stmt|;
return|return
name|find_method_list
argument_list|(
name|argp
argument_list|,
name|method
argument_list|,
literal|0
argument_list|,
name|static_memfuncp
argument_list|,
name|t
argument_list|,
name|num_fns
argument_list|,
name|basetype
argument_list|,
name|boffset
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given an array of argument types (ARGTYPES) (which includes an    entry for "this" in the case of C++ methods), the number of    arguments NARGS, the NAME of a function whether it's a method or    not (METHOD), and the degree of laxness (LAX) in conforming to    overload resolution rules in ANSI C++, find the best function that    matches on the argument types according to the overload resolution    rules.     In the case of class methods, the parameter OBJ is an object value    in which to search for overloaded methods.     In the case of non-method functions, the parameter FSYM is a symbol    corresponding to one of the overloaded functions.     Return value is an integer: 0 -> good match, 10 -> debugger applied    non-standard coercions, 100 -> incompatible.     If a method is being searched for, VALP will hold the value.    If a non-method is being searched for, SYMP will hold the symbol for it.     If a method is being searched for, and it is a static method,    then STATICP will point to a non-zero value.     Note: This function does *not* check the value of    overload_resolution.  Caller must check it to see whether overload    resolution is permitted.  */
end_comment

begin_function
name|int
name|find_overload_match
parameter_list|(
name|struct
name|type
modifier|*
modifier|*
name|arg_types
parameter_list|,
name|int
name|nargs
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|method
parameter_list|,
name|int
name|lax
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|objp
parameter_list|,
name|struct
name|symbol
modifier|*
name|fsym
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|valp
parameter_list|,
name|struct
name|symbol
modifier|*
modifier|*
name|symp
parameter_list|,
name|int
modifier|*
name|staticp
parameter_list|)
block|{
name|int
name|nparms
decl_stmt|;
name|struct
name|type
modifier|*
modifier|*
name|parm_types
decl_stmt|;
name|int
name|champ_nparms
init|=
literal|0
decl_stmt|;
name|struct
name|value
modifier|*
name|obj
init|=
operator|(
name|objp
condition|?
operator|*
name|objp
else|:
name|NULL
operator|)
decl_stmt|;
name|short
name|oload_champ
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Index of best overloaded function */
name|short
name|oload_ambiguous
init|=
literal|0
decl_stmt|;
comment|/* Current ambiguity state for overload resolution */
comment|/* 0 => no ambiguity, 1 => two good funcs, 2 => incomparable funcs */
name|short
name|oload_ambig_champ
init|=
operator|-
literal|1
decl_stmt|;
comment|/* 2nd contender for best match */
name|short
name|oload_non_standard
init|=
literal|0
decl_stmt|;
comment|/* did we have to use non-standard conversions? */
name|short
name|oload_incompatible
init|=
literal|0
decl_stmt|;
comment|/* are args supplied incompatible with any function? */
name|struct
name|badness_vector
modifier|*
name|bv
decl_stmt|;
comment|/* A measure of how good an overloaded instance is */
name|struct
name|badness_vector
modifier|*
name|oload_champ_bv
init|=
name|NULL
decl_stmt|;
comment|/* The measure for the current best match */
name|struct
name|value
modifier|*
name|temp
init|=
name|obj
decl_stmt|;
name|struct
name|fn_field
modifier|*
name|fns_ptr
init|=
name|NULL
decl_stmt|;
comment|/* For methods, the list of overloaded methods */
name|struct
name|symbol
modifier|*
modifier|*
name|oload_syms
init|=
name|NULL
decl_stmt|;
comment|/* For non-methods, the list of overloaded function symbols */
name|int
name|num_fns
init|=
literal|0
decl_stmt|;
comment|/* Number of overloaded instances being considered */
name|struct
name|type
modifier|*
name|basetype
init|=
name|NULL
decl_stmt|;
name|int
name|boffset
decl_stmt|;
specifier|register
name|int
name|jj
decl_stmt|;
specifier|register
name|int
name|ix
decl_stmt|;
name|char
modifier|*
name|obj_type_name
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|func_name
init|=
name|NULL
decl_stmt|;
comment|/* Get the list of overloaded methods or functions */
if|if
condition|(
name|method
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|len
decl_stmt|;
name|struct
name|type
modifier|*
name|domain
decl_stmt|;
name|obj_type_name
operator|=
name|TYPE_NAME
argument_list|(
name|VALUE_TYPE
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Hack: evaluate_subexp_standard often passes in a pointer          value rather than the object itself, so try again */
if|if
condition|(
operator|(
operator|!
name|obj_type_name
operator|||
operator|!
operator|*
name|obj_type_name
operator|)
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|obj
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|)
condition|)
name|obj_type_name
operator|=
name|TYPE_NAME
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|obj
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fns_ptr
operator|=
name|value_find_oload_method_list
argument_list|(
operator|&
name|temp
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
name|staticp
argument_list|,
operator|&
name|num_fns
argument_list|,
operator|&
name|basetype
argument_list|,
operator|&
name|boffset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fns_ptr
operator|||
operator|!
name|num_fns
condition|)
name|error
argument_list|(
literal|"Couldn't find method %s%s%s"
argument_list|,
name|obj_type_name
argument_list|,
operator|(
name|obj_type_name
operator|&&
operator|*
name|obj_type_name
operator|)
condition|?
literal|"::"
else|:
literal|""
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|domain
operator|=
name|TYPE_DOMAIN_TYPE
argument_list|(
name|fns_ptr
index|[
literal|0
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|domain
argument_list|)
expr_stmt|;
comment|/* NOTE: dan/2000-03-10: This stuff is for STABS, which won't          give us the info we need directly in the types. We have to          use the method stub conversion to get it. Be aware that this          is by no means perfect, and if you use STABS, please move to          DWARF-2, or something like it, because trying to improve          overloading using STABS is really a waste of time. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
name|struct
name|fn_field
modifier|*
name|f
init|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|len2
init|=
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len2
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|TYPE_FN_FIELD_STUB
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
operator|&&
operator|(
operator|!
name|strcmp_iw
argument_list|(
name|TYPE_FN_FIELDLIST_NAME
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
argument_list|,
name|name
argument_list|)
operator|)
condition|)
name|check_stub_method
argument_list|(
name|domain
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|int
name|i
init|=
operator|-
literal|1
decl_stmt|;
name|func_name
operator|=
name|cplus_demangle
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|fsym
argument_list|)
argument_list|,
name|DMGL_NO_OPTS
argument_list|)
expr_stmt|;
comment|/* If the name is NULL this must be a C-style function.          Just return the same symbol. */
if|if
condition|(
operator|!
name|func_name
condition|)
block|{
operator|*
name|symp
operator|=
name|fsym
expr_stmt|;
return|return
literal|0
return|;
block|}
name|oload_syms
operator|=
name|make_symbol_overload_list
argument_list|(
name|fsym
argument_list|)
expr_stmt|;
while|while
condition|(
name|oload_syms
index|[
operator|++
name|i
index|]
condition|)
name|num_fns
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|num_fns
condition|)
name|error
argument_list|(
literal|"Couldn't find function %s"
argument_list|,
name|func_name
argument_list|)
expr_stmt|;
block|}
name|oload_champ_bv
operator|=
name|NULL
expr_stmt|;
comment|/* Consider each candidate in turn */
for|for
control|(
name|ix
operator|=
literal|0
init|;
name|ix
operator|<
name|num_fns
condition|;
name|ix
operator|++
control|)
block|{
if|if
condition|(
name|method
condition|)
block|{
comment|/* For static member functions, we won't have a this pointer, but nothing 	     else seems to handle them right now, so we just pretend ourselves */
name|nparms
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TYPE_FN_FIELD_ARGS
argument_list|(
name|fns_ptr
argument_list|,
name|ix
argument_list|)
condition|)
block|{
while|while
condition|(
name|TYPE_CODE
argument_list|(
name|TYPE_FN_FIELD_ARGS
argument_list|(
name|fns_ptr
argument_list|,
name|ix
argument_list|)
index|[
name|nparms
index|]
argument_list|)
operator|!=
name|TYPE_CODE_VOID
condition|)
name|nparms
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If it's not a method, this is the proper place */
name|nparms
operator|=
name|TYPE_NFIELDS
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|oload_syms
index|[
name|ix
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Prepare array of parameter types */
name|parm_types
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|nparms
operator|*
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|jj
operator|=
literal|0
init|;
name|jj
operator|<
name|nparms
condition|;
name|jj
operator|++
control|)
name|parm_types
index|[
name|jj
index|]
operator|=
operator|(
name|method
condition|?
operator|(
name|TYPE_FN_FIELD_ARGS
argument_list|(
name|fns_ptr
argument_list|,
name|ix
argument_list|)
index|[
name|jj
index|]
operator|)
else|:
name|TYPE_FIELD_TYPE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|oload_syms
index|[
name|ix
index|]
argument_list|)
argument_list|,
name|jj
argument_list|)
operator|)
expr_stmt|;
comment|/* Compare parameter types to supplied argument types */
name|bv
operator|=
name|rank_function
argument_list|(
name|parm_types
argument_list|,
name|nparms
argument_list|,
name|arg_types
argument_list|,
name|nargs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|oload_champ_bv
condition|)
block|{
name|oload_champ_bv
operator|=
name|bv
expr_stmt|;
name|oload_champ
operator|=
literal|0
expr_stmt|;
name|champ_nparms
operator|=
name|nparms
expr_stmt|;
block|}
else|else
comment|/* See whether current candidate is better or worse than previous best */
switch|switch
condition|(
name|compare_badness
argument_list|(
name|bv
argument_list|,
name|oload_champ_bv
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|oload_ambiguous
operator|=
literal|1
expr_stmt|;
comment|/* top two contenders are equally good */
name|oload_ambig_champ
operator|=
name|ix
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|oload_ambiguous
operator|=
literal|2
expr_stmt|;
comment|/* incomparable top contenders */
name|oload_ambig_champ
operator|=
name|ix
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|oload_champ_bv
operator|=
name|bv
expr_stmt|;
comment|/* new champion, record details */
name|oload_ambiguous
operator|=
literal|0
expr_stmt|;
name|oload_champ
operator|=
name|ix
expr_stmt|;
name|oload_ambig_champ
operator|=
operator|-
literal|1
expr_stmt|;
name|champ_nparms
operator|=
name|nparms
expr_stmt|;
break|break;
case|case
literal|3
case|:
default|default:
break|break;
block|}
name|xfree
argument_list|(
name|parm_types
argument_list|)
expr_stmt|;
if|if
condition|(
name|overload_debug
condition|)
block|{
if|if
condition|(
name|method
condition|)
name|fprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Overloaded method instance %s, # of parms %d\n"
argument_list|,
name|fns_ptr
index|[
name|ix
index|]
operator|.
name|physname
argument_list|,
name|nparms
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Overloaded function instance %s # of parms %d\n"
argument_list|,
name|SYMBOL_DEMANGLED_NAME
argument_list|(
name|oload_syms
index|[
name|ix
index|]
argument_list|)
argument_list|,
name|nparms
argument_list|)
expr_stmt|;
for|for
control|(
name|jj
operator|=
literal|0
init|;
name|jj
operator|<
name|nargs
condition|;
name|jj
operator|++
control|)
name|fprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"...Badness @ %d : %d\n"
argument_list|,
name|jj
argument_list|,
name|bv
operator|->
name|rank
index|[
name|jj
index|]
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Overload resolution champion is %d, ambiguous? %d\n"
argument_list|,
name|oload_champ
argument_list|,
name|oload_ambiguous
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* end loop over all candidates */
comment|/* NOTE: dan/2000-03-10: Seems to be a better idea to just pick one      if they have the exact same goodness. This is because there is no      way to differentiate based on return type, which we need to in      cases like overloads of .begin()<It's both const and non-const> */
if|#
directive|if
literal|0
block|if (oload_ambiguous)     {       if (method) 	error ("Cannot resolve overloaded method %s%s%s to unique instance; disambiguate by specifying function signature", 	       obj_type_name, 	       (obj_type_name&& *obj_type_name) ? "::" : "", 	       name);       else 	error ("Cannot resolve overloaded function %s to unique instance; disambiguate by specifying function signature", 	       func_name);     }
endif|#
directive|endif
comment|/* Check how bad the best match is */
for|for
control|(
name|ix
operator|=
literal|1
init|;
name|ix
operator|<=
name|nargs
condition|;
name|ix
operator|++
control|)
block|{
if|if
condition|(
name|oload_champ_bv
operator|->
name|rank
index|[
name|ix
index|]
operator|>=
literal|100
condition|)
name|oload_incompatible
operator|=
literal|1
expr_stmt|;
comment|/* truly mismatched types */
elseif|else
if|if
condition|(
name|oload_champ_bv
operator|->
name|rank
index|[
name|ix
index|]
operator|>=
literal|10
condition|)
name|oload_non_standard
operator|=
literal|1
expr_stmt|;
comment|/* non-standard type conversions needed */
block|}
if|if
condition|(
name|oload_incompatible
condition|)
block|{
if|if
condition|(
name|method
condition|)
name|error
argument_list|(
literal|"Cannot resolve method %s%s%s to any overloaded instance"
argument_list|,
name|obj_type_name
argument_list|,
operator|(
name|obj_type_name
operator|&&
operator|*
name|obj_type_name
operator|)
condition|?
literal|"::"
else|:
literal|""
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Cannot resolve function %s to any overloaded instance"
argument_list|,
name|func_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|oload_non_standard
condition|)
block|{
if|if
condition|(
name|method
condition|)
name|warning
argument_list|(
literal|"Using non-standard conversion to match method %s%s%s to supplied arguments"
argument_list|,
name|obj_type_name
argument_list|,
operator|(
name|obj_type_name
operator|&&
operator|*
name|obj_type_name
operator|)
condition|?
literal|"::"
else|:
literal|""
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"Using non-standard conversion to match function %s to supplied arguments"
argument_list|,
name|func_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|method
condition|)
block|{
if|if
condition|(
name|TYPE_FN_FIELD_VIRTUAL_P
argument_list|(
name|fns_ptr
argument_list|,
name|oload_champ
argument_list|)
condition|)
operator|*
name|valp
operator|=
name|value_virtual_fn_field
argument_list|(
operator|&
name|temp
argument_list|,
name|fns_ptr
argument_list|,
name|oload_champ
argument_list|,
name|basetype
argument_list|,
name|boffset
argument_list|)
expr_stmt|;
else|else
operator|*
name|valp
operator|=
name|value_fn_field
argument_list|(
operator|&
name|temp
argument_list|,
name|fns_ptr
argument_list|,
name|oload_champ
argument_list|,
name|basetype
argument_list|,
name|boffset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|symp
operator|=
name|oload_syms
index|[
name|oload_champ
index|]
expr_stmt|;
name|xfree
argument_list|(
name|func_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|objp
condition|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|temp
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_PTR
operator|&&
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
operator|*
name|objp
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
block|{
name|temp
operator|=
name|value_addr
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
operator|*
name|objp
operator|=
name|temp
expr_stmt|;
block|}
return|return
name|oload_incompatible
condition|?
literal|100
else|:
operator|(
name|oload_non_standard
condition|?
literal|10
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* C++: return 1 is NAME is a legitimate name for the destructor    of type TYPE.  If TYPE does not have a destructor, or    if NAME is inappropriate for TYPE, an error is signaled.  */
end_comment

begin_function
name|int
name|destructor_name_p
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
comment|/* destructors are a special case.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'~'
condition|)
block|{
name|char
modifier|*
name|dname
init|=
name|type_name_no_tag
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|strchr
argument_list|(
name|dname
argument_list|,
literal|'<'
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|len
decl_stmt|;
comment|/* Do not compare the template part for template classes.  */
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|len
operator|=
name|strlen
argument_list|(
name|dname
argument_list|)
expr_stmt|;
else|else
name|len
operator|=
name|cp
operator|-
name|dname
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|name
operator|+
literal|1
argument_list|)
operator|!=
name|len
operator|||
operator|!
name|STREQN
argument_list|(
name|dname
argument_list|,
name|name
operator|+
literal|1
argument_list|,
name|len
argument_list|)
condition|)
name|error
argument_list|(
literal|"name of destructor must equal name of class"
argument_list|)
expr_stmt|;
else|else
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Helper function for check_field: Given TYPE, a structure/union,    return 1 if the component named NAME from the ultimate    target structure/union is defined, otherwise, return 0. */
end_comment

begin_function
specifier|static
name|int
name|check_field_in
parameter_list|(
specifier|register
name|struct
name|type
modifier|*
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|;
name|i
operator|--
control|)
block|{
name|char
modifier|*
name|t_field_name
init|=
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|t_field_name
operator|&&
operator|(
name|strcmp_iw
argument_list|(
name|t_field_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
literal|1
return|;
block|}
comment|/* C++: If it was not found as a data field, then try to      return it as a pointer to a method.  */
comment|/* Destructors are a special case.  */
if|if
condition|(
name|destructor_name_p
argument_list|(
name|name
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|int
name|m_index
decl_stmt|,
name|f_index
decl_stmt|;
return|return
name|get_destructor_fn_field
argument_list|(
name|type
argument_list|,
operator|&
name|m_index
argument_list|,
operator|&
name|f_index
argument_list|)
return|;
block|}
for|for
control|(
name|i
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
if|if
condition|(
name|strcmp_iw
argument_list|(
name|TYPE_FN_FIELDLIST_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
for|for
control|(
name|i
operator|=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|check_field_in
argument_list|(
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|name
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* C++: Given ARG1, a value of type (pointer to a)* structure/union,    return 1 if the component named NAME from the ultimate    target structure/union is defined, otherwise, return 0.  */
end_comment

begin_function
name|int
name|check_field
parameter_list|(
name|struct
name|value
modifier|*
name|arg1
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|register
name|struct
name|type
modifier|*
name|t
decl_stmt|;
name|COERCE_ARRAY
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|t
operator|=
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
comment|/* Follow pointers until we get to a non-pointer.  */
for|for
control|(
init|;
condition|;
control|)
block|{
name|CHECK_TYPEDEF
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TYPE_CODE_PTR
operator|&&
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TYPE_CODE_REF
condition|)
break|break;
name|t
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_CODE_MEMBER
condition|)
name|error
argument_list|(
literal|"not implemented: member type in check_field"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
operator|&&
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TYPE_CODE_UNION
condition|)
name|error
argument_list|(
literal|"Internal error: `this' is not an aggregate"
argument_list|)
expr_stmt|;
return|return
name|check_field_in
argument_list|(
name|t
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* C++: Given an aggregate type CURTYPE, and a member name NAME,    return the address of this member as a "pointer to member"    type.  If INTYPE is non-null, then it will be the type    of the member we are looking for.  This will help us resolve    "pointers to member functions".  This function is used    to resolve user expressions of the form "DOMAIN::NAME".  */
end_comment

begin_function
name|struct
name|value
modifier|*
name|value_struct_elt_for_reference
parameter_list|(
name|struct
name|type
modifier|*
name|domain
parameter_list|,
name|int
name|offset
parameter_list|,
name|struct
name|type
modifier|*
name|curtype
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|type
modifier|*
name|intype
parameter_list|)
block|{
specifier|register
name|struct
name|type
modifier|*
name|t
init|=
name|curtype
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|value
modifier|*
name|v
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
operator|&&
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|!=
name|TYPE_CODE_UNION
condition|)
name|error
argument_list|(
literal|"Internal error: non-aggregate type to value_struct_elt_for_reference"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|TYPE_NFIELDS
argument_list|(
name|t
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
name|TYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
condition|;
name|i
operator|--
control|)
block|{
name|char
modifier|*
name|t_field_name
init|=
name|TYPE_FIELD_NAME
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|t_field_name
operator|&&
name|STREQ
argument_list|(
name|t_field_name
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_FIELD_STATIC
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|v
operator|=
name|value_static_field
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Internal error: could not find static variable %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
if|if
condition|(
name|TYPE_FIELD_PACKED
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
condition|)
name|error
argument_list|(
literal|"pointers to bitfield members not allowed"
argument_list|)
expr_stmt|;
return|return
name|value_from_longest
argument_list|(
name|lookup_reference_type
argument_list|(
name|lookup_member_type
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|,
name|domain
argument_list|)
argument_list|)
argument_list|,
name|offset
operator|+
call|(
name|LONGEST
call|)
argument_list|(
name|TYPE_FIELD_BITPOS
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
operator|>>
literal|3
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/* C++: If it was not found as a data field, then try to      return it as a pointer to a method.  */
comment|/* Destructors are a special case.  */
if|if
condition|(
name|destructor_name_p
argument_list|(
name|name
argument_list|,
name|t
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"member pointers to destructors not implemented yet"
argument_list|)
expr_stmt|;
block|}
comment|/* Perform all necessary dereferencing.  */
while|while
condition|(
name|intype
operator|&&
name|TYPE_CODE
argument_list|(
name|intype
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
name|intype
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|intype
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|t
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|char
modifier|*
name|t_field_name
init|=
name|TYPE_FN_FIELDLIST_NAME
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|char
name|dem_opname
index|[
literal|64
index|]
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|t_field_name
argument_list|,
literal|"__"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|t_field_name
argument_list|,
literal|"op"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|t_field_name
argument_list|,
literal|"type"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cplus_demangle_opname
argument_list|(
name|t_field_name
argument_list|,
name|dem_opname
argument_list|,
name|DMGL_ANSI
argument_list|)
condition|)
name|t_field_name
operator|=
name|dem_opname
expr_stmt|;
elseif|else
if|if
condition|(
name|cplus_demangle_opname
argument_list|(
name|t_field_name
argument_list|,
name|dem_opname
argument_list|,
literal|0
argument_list|)
condition|)
name|t_field_name
operator|=
name|dem_opname
expr_stmt|;
block|}
if|if
condition|(
name|t_field_name
operator|&&
name|STREQ
argument_list|(
name|t_field_name
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|int
name|j
init|=
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|struct
name|fn_field
modifier|*
name|f
init|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|intype
operator|==
literal|0
operator|&&
name|j
operator|>
literal|1
condition|)
name|error
argument_list|(
literal|"non-unique member `%s' requires type instantiation"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|intype
condition|)
block|{
while|while
condition|(
name|j
operator|--
condition|)
if|if
condition|(
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
operator|==
name|intype
condition|)
break|break;
if|if
condition|(
name|j
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"no member function matches that type instantiation"
argument_list|)
expr_stmt|;
block|}
else|else
name|j
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TYPE_FN_FIELD_STUB
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
name|check_stub_method
argument_list|(
name|t
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FN_FIELD_VIRTUAL_P
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
block|{
return|return
name|value_from_longest
argument_list|(
name|lookup_reference_type
argument_list|(
name|lookup_member_type
argument_list|(
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|,
name|domain
argument_list|)
argument_list|)
argument_list|,
operator|(
name|LONGEST
operator|)
name|METHOD_PTR_FROM_VOFFSET
argument_list|(
name|TYPE_FN_FIELD_VOFFSET
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|struct
name|symbol
modifier|*
name|s
init|=
name|lookup_symbol
argument_list|(
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
name|v
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|v
operator|=
name|read_var_value
argument_list|(
name|s
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|VALUE_TYPE (v) = lookup_reference_type 		    (lookup_member_type (TYPE_FN_FIELD_TYPE (f, j), 					 domain));
endif|#
directive|endif
block|}
return|return
name|v
return|;
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
name|TYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|struct
name|value
modifier|*
name|v
decl_stmt|;
name|int
name|base_offset
decl_stmt|;
if|if
condition|(
name|BASETYPE_VIA_VIRTUAL
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
condition|)
name|base_offset
operator|=
literal|0
expr_stmt|;
else|else
name|base_offset
operator|=
name|TYPE_BASECLASS_BITPOS
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
operator|/
literal|8
expr_stmt|;
name|v
operator|=
name|value_struct_elt_for_reference
argument_list|(
name|domain
argument_list|,
name|offset
operator|+
name|base_offset
argument_list|,
name|TYPE_BASECLASS
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|,
name|name
argument_list|,
name|intype
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
condition|)
return|return
name|v
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer value V, find the real (RTTI) type    of the object it points to.    Other parameters FULL, TOP, USING_ENC as with value_rtti_type()    and refer to the values computed for the object pointed to. */
end_comment

begin_function
name|struct
name|type
modifier|*
name|value_rtti_target_type
parameter_list|(
name|struct
name|value
modifier|*
name|v
parameter_list|,
name|int
modifier|*
name|full
parameter_list|,
name|int
modifier|*
name|top
parameter_list|,
name|int
modifier|*
name|using_enc
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|target
decl_stmt|;
name|target
operator|=
name|value_ind
argument_list|(
name|v
argument_list|)
expr_stmt|;
return|return
name|value_rtti_type
argument_list|(
name|target
argument_list|,
name|full
argument_list|,
name|top
argument_list|,
name|using_enc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a value pointed to by ARGP, check its real run-time type, and    if that is different from the enclosing type, create a new value    using the real run-time type as the enclosing type (and of the same    type as ARGP) and return it, with the embedded offset adjusted to    be the correct offset to the enclosed object    RTYPE is the type, and XFULL, XTOP, and XUSING_ENC are the other    parameters, computed by value_rtti_type(). If these are available,    they can be supplied and a second call to value_rtti_type() is avoided.    (Pass RTYPE == NULL if they're not available */
end_comment

begin_function
name|struct
name|value
modifier|*
name|value_full_object
parameter_list|(
name|struct
name|value
modifier|*
name|argp
parameter_list|,
name|struct
name|type
modifier|*
name|rtype
parameter_list|,
name|int
name|xfull
parameter_list|,
name|int
name|xtop
parameter_list|,
name|int
name|xusing_enc
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|real_type
decl_stmt|;
name|int
name|full
init|=
literal|0
decl_stmt|;
name|int
name|top
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|using_enc
init|=
literal|0
decl_stmt|;
name|struct
name|value
modifier|*
name|new_val
decl_stmt|;
if|if
condition|(
name|rtype
condition|)
block|{
name|real_type
operator|=
name|rtype
expr_stmt|;
name|full
operator|=
name|xfull
expr_stmt|;
name|top
operator|=
name|xtop
expr_stmt|;
name|using_enc
operator|=
name|xusing_enc
expr_stmt|;
block|}
else|else
name|real_type
operator|=
name|value_rtti_type
argument_list|(
name|argp
argument_list|,
operator|&
name|full
argument_list|,
operator|&
name|top
argument_list|,
operator|&
name|using_enc
argument_list|)
expr_stmt|;
comment|/* If no RTTI data, or if object is already complete, do nothing */
if|if
condition|(
operator|!
name|real_type
operator|||
name|real_type
operator|==
name|VALUE_ENCLOSING_TYPE
argument_list|(
name|argp
argument_list|)
condition|)
return|return
name|argp
return|;
comment|/* If we have the full object, but for some reason the enclosing      type is wrong, set it */
comment|/* pai: FIXME -- sounds iffy */
if|if
condition|(
name|full
condition|)
block|{
name|argp
operator|=
name|value_change_enclosing_type
argument_list|(
name|argp
argument_list|,
name|real_type
argument_list|)
expr_stmt|;
return|return
name|argp
return|;
block|}
comment|/* Check if object is in memory */
if|if
condition|(
name|VALUE_LVAL
argument_list|(
name|argp
argument_list|)
operator|!=
name|lval_memory
condition|)
block|{
name|warning
argument_list|(
literal|"Couldn't retrieve complete object of RTTI type %s; object may be in register(s)."
argument_list|,
name|TYPE_NAME
argument_list|(
name|real_type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|argp
return|;
block|}
comment|/* All other cases -- retrieve the complete object */
comment|/* Go back by the computed top_offset from the beginning of the object,      adjusting for the embedded offset of argp if that's what value_rtti_type      used for its computation. */
name|new_val
operator|=
name|value_at_lazy
argument_list|(
name|real_type
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|argp
argument_list|)
operator|-
name|top
operator|+
operator|(
name|using_enc
condition|?
literal|0
else|:
name|VALUE_EMBEDDED_OFFSET
argument_list|(
name|argp
argument_list|)
operator|)
argument_list|,
name|VALUE_BFD_SECTION
argument_list|(
name|argp
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_TYPE
argument_list|(
name|new_val
argument_list|)
operator|=
name|VALUE_TYPE
argument_list|(
name|argp
argument_list|)
expr_stmt|;
name|VALUE_EMBEDDED_OFFSET
argument_list|(
name|new_val
argument_list|)
operator|=
name|using_enc
condition|?
name|top
operator|+
name|VALUE_EMBEDDED_OFFSET
argument_list|(
name|argp
argument_list|)
else|:
name|top
expr_stmt|;
return|return
name|new_val
return|;
block|}
end_function

begin_comment
comment|/* C++: return the value of the class instance variable, if one exists.    Flag COMPLAIN signals an error if the request is made in an    inappropriate context.  */
end_comment

begin_function
name|struct
name|value
modifier|*
name|value_of_this
parameter_list|(
name|int
name|complain
parameter_list|)
block|{
name|struct
name|symbol
modifier|*
name|func
decl_stmt|,
modifier|*
name|sym
decl_stmt|;
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
specifier|const
name|char
name|funny_this
index|[]
init|=
literal|"this"
decl_stmt|;
name|struct
name|value
modifier|*
name|this
decl_stmt|;
if|if
condition|(
name|selected_frame
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"no frame selected"
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
name|func
operator|=
name|get_frame_function
argument_list|(
name|selected_frame
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|func
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"no `this' in nameless context"
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
name|b
operator|=
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|func
argument_list|)
expr_stmt|;
name|i
operator|=
name|BLOCK_NSYMS
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"no args, no `this'"
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
comment|/* Calling lookup_block_symbol is necessary to get the LOC_REGISTER      symbol instead of the LOC_ARG one (if both exist).  */
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|b
argument_list|,
name|funny_this
argument_list|,
name|VAR_NAMESPACE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|complain
condition|)
name|error
argument_list|(
literal|"current stack frame not in method"
argument_list|)
expr_stmt|;
else|else
return|return
name|NULL
return|;
block|}
name|this
operator|=
name|read_var_value
argument_list|(
name|sym
argument_list|,
name|selected_frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|this
operator|==
literal|0
operator|&&
name|complain
condition|)
name|error
argument_list|(
literal|"`this' argument at unknown address"
argument_list|)
expr_stmt|;
return|return
name|this
return|;
block|}
end_function

begin_comment
comment|/* Create a slice (sub-string, sub-array) of ARRAY, that is LENGTH elements    long, starting at LOWBOUND.  The result has the same lower bound as    the original ARRAY.  */
end_comment

begin_function
name|struct
name|value
modifier|*
name|value_slice
parameter_list|(
name|struct
name|value
modifier|*
name|array
parameter_list|,
name|int
name|lowbound
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|slice_range_type
decl_stmt|,
modifier|*
name|slice_type
decl_stmt|,
modifier|*
name|range_type
decl_stmt|;
name|LONGEST
name|lowerbound
decl_stmt|,
name|upperbound
decl_stmt|,
name|offset
decl_stmt|;
name|struct
name|value
modifier|*
name|slice
decl_stmt|;
name|struct
name|type
modifier|*
name|array_type
decl_stmt|;
name|array_type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|array
argument_list|)
argument_list|)
expr_stmt|;
name|COERCE_VARYING_ARRAY
argument_list|(
name|array
argument_list|,
name|array_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|array_type
argument_list|)
operator|!=
name|TYPE_CODE_ARRAY
operator|&&
name|TYPE_CODE
argument_list|(
name|array_type
argument_list|)
operator|!=
name|TYPE_CODE_STRING
operator|&&
name|TYPE_CODE
argument_list|(
name|array_type
argument_list|)
operator|!=
name|TYPE_CODE_BITSTRING
condition|)
name|error
argument_list|(
literal|"cannot take slice of non-array"
argument_list|)
expr_stmt|;
name|range_type
operator|=
name|TYPE_INDEX_TYPE
argument_list|(
name|array_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|get_discrete_bounds
argument_list|(
name|range_type
argument_list|,
operator|&
name|lowerbound
argument_list|,
operator|&
name|upperbound
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"slice from bad array or bitstring"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lowbound
operator|<
name|lowerbound
operator|||
name|length
operator|<
literal|0
operator|||
name|lowbound
operator|+
name|length
operator|-
literal|1
operator|>
name|upperbound
comment|/* Chill allows zero-length strings but not arrays. */
operator|||
operator|(
name|current_language
operator|->
name|la_language
operator|==
name|language_chill
operator|&&
name|length
operator|==
literal|0
operator|&&
name|TYPE_CODE
argument_list|(
name|array_type
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
operator|)
condition|)
name|error
argument_list|(
literal|"slice out of range"
argument_list|)
expr_stmt|;
comment|/* FIXME-type-allocation: need a way to free this type when we are      done with it.  */
name|slice_range_type
operator|=
name|create_range_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|TYPE_TARGET_TYPE
argument_list|(
name|range_type
argument_list|)
argument_list|,
name|lowbound
argument_list|,
name|lowbound
operator|+
name|length
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|array_type
argument_list|)
operator|==
name|TYPE_CODE_BITSTRING
condition|)
block|{
name|int
name|i
decl_stmt|;
name|slice_type
operator|=
name|create_set_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|slice_range_type
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|slice_type
argument_list|)
operator|=
name|TYPE_CODE_BITSTRING
expr_stmt|;
name|slice
operator|=
name|value_zero
argument_list|(
name|slice_type
argument_list|,
name|not_lval
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|int
name|element
init|=
name|value_bit_index
argument_list|(
name|array_type
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|array
argument_list|)
argument_list|,
name|lowbound
operator|+
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|element
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"internal error accessing bitstring"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|element
operator|>
literal|0
condition|)
block|{
name|int
name|j
init|=
name|i
operator|%
name|TARGET_CHAR_BIT
decl_stmt|;
if|if
condition|(
name|BITS_BIG_ENDIAN
condition|)
name|j
operator|=
name|TARGET_CHAR_BIT
operator|-
literal|1
operator|-
name|j
expr_stmt|;
name|VALUE_CONTENTS_RAW
argument_list|(
name|slice
argument_list|)
index|[
name|i
operator|/
name|TARGET_CHAR_BIT
index|]
operator||=
operator|(
literal|1
operator|<<
name|j
operator|)
expr_stmt|;
block|}
block|}
comment|/* We should set the address, bitssize, and bitspos, so the clice          can be used on the LHS, but that may require extensions to          value_assign.  For now, just leave as a non_lval.  FIXME.  */
block|}
else|else
block|{
name|struct
name|type
modifier|*
name|element_type
init|=
name|TYPE_TARGET_TYPE
argument_list|(
name|array_type
argument_list|)
decl_stmt|;
name|offset
operator|=
operator|(
name|lowbound
operator|-
name|lowerbound
operator|)
operator|*
name|TYPE_LENGTH
argument_list|(
name|check_typedef
argument_list|(
name|element_type
argument_list|)
argument_list|)
expr_stmt|;
name|slice_type
operator|=
name|create_array_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|element_type
argument_list|,
name|slice_range_type
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|slice_type
argument_list|)
operator|=
name|TYPE_CODE
argument_list|(
name|array_type
argument_list|)
expr_stmt|;
name|slice
operator|=
name|allocate_value
argument_list|(
name|slice_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_LAZY
argument_list|(
name|array
argument_list|)
condition|)
name|VALUE_LAZY
argument_list|(
name|slice
argument_list|)
operator|=
literal|1
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|VALUE_CONTENTS
argument_list|(
name|slice
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|array
argument_list|)
operator|+
name|offset
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|slice_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_LVAL
argument_list|(
name|array
argument_list|)
operator|==
name|lval_internalvar
condition|)
name|VALUE_LVAL
argument_list|(
name|slice
argument_list|)
operator|=
name|lval_internalvar_component
expr_stmt|;
else|else
name|VALUE_LVAL
argument_list|(
name|slice
argument_list|)
operator|=
name|VALUE_LVAL
argument_list|(
name|array
argument_list|)
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|slice
argument_list|)
operator|=
name|VALUE_ADDRESS
argument_list|(
name|array
argument_list|)
expr_stmt|;
name|VALUE_OFFSET
argument_list|(
name|slice
argument_list|)
operator|=
name|VALUE_OFFSET
argument_list|(
name|array
argument_list|)
operator|+
name|offset
expr_stmt|;
block|}
return|return
name|slice
return|;
block|}
end_function

begin_comment
comment|/* Assuming chill_varying_type (VARRAY) is true, return an equivalent    value as a fixed-length array. */
end_comment

begin_function
name|struct
name|value
modifier|*
name|varying_to_slice
parameter_list|(
name|struct
name|value
modifier|*
name|varray
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|vtype
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|varray
argument_list|)
argument_list|)
decl_stmt|;
name|LONGEST
name|length
init|=
name|unpack_long
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|vtype
argument_list|,
literal|0
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|varray
argument_list|)
operator|+
name|TYPE_FIELD_BITPOS
argument_list|(
name|vtype
argument_list|,
literal|0
argument_list|)
operator|/
literal|8
argument_list|)
decl_stmt|;
return|return
name|value_slice
argument_list|(
name|value_primitive_field
argument_list|(
name|varray
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|vtype
argument_list|)
argument_list|,
literal|0
argument_list|,
name|length
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create a value for a FORTRAN complex number.  Currently most of    the time values are coerced to COMPLEX*16 (i.e. a complex number    composed of 2 doubles.  This really should be a smarter routine    that figures out precision inteligently as opposed to assuming    doubles. FIXME: fmb */
end_comment

begin_function
name|struct
name|value
modifier|*
name|value_literal_complex
parameter_list|(
name|struct
name|value
modifier|*
name|arg1
parameter_list|,
name|struct
name|value
modifier|*
name|arg2
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|val
decl_stmt|;
name|struct
name|type
modifier|*
name|real_type
init|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|val
operator|=
name|allocate_value
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|value_cast
argument_list|(
name|real_type
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|value_cast
argument_list|(
name|real_type
argument_list|,
name|arg2
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|arg1
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|real_type
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
operator|+
name|TYPE_LENGTH
argument_list|(
name|real_type
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|arg2
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|real_type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Cast a value into the appropriate complex data type. */
end_comment

begin_function
specifier|static
name|struct
name|value
modifier|*
name|cast_into_complex
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|value
modifier|*
name|val
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|real_type
init|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_COMPLEX
condition|)
block|{
name|struct
name|type
modifier|*
name|val_real_type
init|=
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|value
modifier|*
name|re_val
init|=
name|allocate_value
argument_list|(
name|val_real_type
argument_list|)
decl_stmt|;
name|struct
name|value
modifier|*
name|im_val
init|=
name|allocate_value
argument_list|(
name|val_real_type
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|re_val
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|val_real_type
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|im_val
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
operator|+
name|TYPE_LENGTH
argument_list|(
name|val_real_type
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|val_real_type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|value_literal_complex
argument_list|(
name|re_val
argument_list|,
name|im_val
argument_list|,
name|type
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_FLT
operator|||
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_INT
condition|)
return|return
name|value_literal_complex
argument_list|(
name|val
argument_list|,
name|value_zero
argument_list|(
name|real_type
argument_list|,
name|not_lval
argument_list|)
argument_list|,
name|type
argument_list|)
return|;
else|else
name|error
argument_list|(
literal|"cannot cast non-number to complex"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_valops
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
literal|0
block|add_show_from_set     (add_set_cmd ("abandon", class_support, var_boolean, (char *)&auto_abandon, 		  "Set automatic abandonment of expressions upon failure.",&setlist),&showlist);
endif|#
directive|endif
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"overload-resolution"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|overload_resolution
argument_list|,
literal|"Set overload resolution in evaluating C++ functions."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|overload_resolution
operator|=
literal|1
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"unwindonsignal"
argument_list|,
name|no_class
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|unwind_on_signal_p
argument_list|,
literal|"Set unwinding of stack if a signal is received while in a call dummy.\n\ The unwindonsignal lets the user determine what gdb should do if a signal\n\ is received while in a function called from gdb (call dummy).  If set, gdb\n\ unwinds the stack and restore the context to what as it was before the call.\n\ The default is to stop in the frame where the signal was received."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

