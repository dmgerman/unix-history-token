begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Frame unwinder for frames using the libunwind library.     Copyright 2003 Free Software Foundation, Inc.     Written by Jeff Johnston, contributed by Red Hat Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"frame-base.h"
end_include

begin_include
include|#
directive|include
file|"frame-unwind.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|<dlfcn.h>
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"libunwind-frame.h"
end_include

begin_include
include|#
directive|include
file|"complaints.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|libunwind_initialized
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|gdbarch_data
modifier|*
name|libunwind_descr_handle
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|LIBUNWIND_SO
end_ifndef

begin_define
define|#
directive|define
name|LIBUNWIND_SO
value|"libunwind.so"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Required function pointers from libunwind.  */
end_comment

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|unw_get_reg_p
function_decl|)
parameter_list|(
name|unw_cursor_t
modifier|*
parameter_list|,
name|unw_regnum_t
parameter_list|,
name|unw_word_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|unw_get_fpreg_p
function_decl|)
parameter_list|(
name|unw_cursor_t
modifier|*
parameter_list|,
name|unw_regnum_t
parameter_list|,
name|unw_fpreg_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|unw_get_saveloc_p
function_decl|)
parameter_list|(
name|unw_cursor_t
modifier|*
parameter_list|,
name|unw_regnum_t
parameter_list|,
name|unw_save_loc_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|unw_step_p
function_decl|)
parameter_list|(
name|unw_cursor_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|unw_init_remote_p
function_decl|)
parameter_list|(
name|unw_cursor_t
modifier|*
parameter_list|,
name|unw_addr_space_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unw_addr_space_t
function_decl|(
modifier|*
name|unw_create_addr_space_p
function_decl|)
parameter_list|(
name|unw_accessors_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|unw_search_unwind_table_p
function_decl|)
parameter_list|(
name|unw_addr_space_t
parameter_list|,
name|unw_word_t
parameter_list|,
name|unw_dyn_info_t
modifier|*
parameter_list|,
name|unw_proc_info_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unw_word_t
function_decl|(
modifier|*
name|unw_find_dyn_list_p
function_decl|)
parameter_list|(
name|unw_addr_space_t
parameter_list|,
name|unw_dyn_info_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|libunwind_frame_cache
block|{
name|CORE_ADDR
name|base
decl_stmt|;
name|CORE_ADDR
name|func_addr
decl_stmt|;
name|unw_cursor_t
name|cursor
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* We need to qualify the function names with a platform-specific prefix to match     the names used by the libunwind library.  The UNW_OBJ macro is provided by the    libunwind.h header file.  */
end_comment

begin_define
define|#
directive|define
name|STRINGIFY2
parameter_list|(
name|name
parameter_list|)
value|#name
end_define

begin_define
define|#
directive|define
name|STRINGIFY
parameter_list|(
name|name
parameter_list|)
value|STRINGIFY2(name)
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|get_reg_name
init|=
name|STRINGIFY
argument_list|(
name|UNW_OBJ
argument_list|(
name|get_reg
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|get_fpreg_name
init|=
name|STRINGIFY
argument_list|(
name|UNW_OBJ
argument_list|(
name|get_fpreg
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|get_saveloc_name
init|=
name|STRINGIFY
argument_list|(
name|UNW_OBJ
argument_list|(
name|get_save_loc
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|step_name
init|=
name|STRINGIFY
argument_list|(
name|UNW_OBJ
argument_list|(
name|step
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|init_remote_name
init|=
name|STRINGIFY
argument_list|(
name|UNW_OBJ
argument_list|(
name|init_remote
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|create_addr_space_name
init|=
name|STRINGIFY
argument_list|(
name|UNW_OBJ
argument_list|(
name|create_addr_space
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|search_unwind_table_name
init|=
name|STRINGIFY
argument_list|(
name|UNW_OBJ
argument_list|(
name|search_unwind_table
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|find_dyn_list_name
init|=
name|STRINGIFY
argument_list|(
name|UNW_OBJ
argument_list|(
name|find_dyn_list
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|libunwind_descr
modifier|*
name|libunwind_descr
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|)
block|{
return|return
name|gdbarch_data
argument_list|(
name|gdbarch
argument_list|,
name|libunwind_descr_handle
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|libunwind_descr_init
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|)
block|{
name|struct
name|libunwind_descr
modifier|*
name|descr
init|=
name|GDBARCH_OBSTACK_ZALLOC
argument_list|(
name|gdbarch
argument_list|,
expr|struct
name|libunwind_descr
argument_list|)
decl_stmt|;
return|return
name|descr
return|;
block|}
end_function

begin_function
name|void
name|libunwind_frame_set_descr
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|libunwind_descr
modifier|*
name|descr
parameter_list|)
block|{
name|struct
name|libunwind_descr
modifier|*
name|arch_descr
decl_stmt|;
name|gdb_assert
argument_list|(
name|gdbarch
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|arch_descr
operator|=
name|gdbarch_data
argument_list|(
name|gdbarch
argument_list|,
name|libunwind_descr_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|arch_descr
operator|==
name|NULL
condition|)
block|{
comment|/* First time here.  Must initialize data area.  */
name|arch_descr
operator|=
name|libunwind_descr_init
argument_list|(
name|gdbarch
argument_list|)
expr_stmt|;
name|set_gdbarch_data
argument_list|(
name|gdbarch
argument_list|,
name|libunwind_descr_handle
argument_list|,
name|arch_descr
argument_list|)
expr_stmt|;
block|}
comment|/* Copy new descriptor info into arch descriptor.  */
name|arch_descr
operator|->
name|gdb2uw
operator|=
name|descr
operator|->
name|gdb2uw
expr_stmt|;
name|arch_descr
operator|->
name|uw2gdb
operator|=
name|descr
operator|->
name|uw2gdb
expr_stmt|;
name|arch_descr
operator|->
name|is_fpreg
operator|=
name|descr
operator|->
name|is_fpreg
expr_stmt|;
name|arch_descr
operator|->
name|accessors
operator|=
name|descr
operator|->
name|accessors
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|libunwind_frame_cache
modifier|*
name|libunwind_frame_cache
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|)
block|{
name|unw_accessors_t
modifier|*
name|acc
decl_stmt|;
name|unw_addr_space_t
name|as
decl_stmt|;
name|unw_word_t
name|fp
decl_stmt|;
name|unw_regnum_t
name|uw_sp_regnum
decl_stmt|;
name|struct
name|libunwind_frame_cache
modifier|*
name|cache
decl_stmt|;
name|struct
name|libunwind_descr
modifier|*
name|descr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
if|if
condition|(
operator|*
name|this_cache
condition|)
return|return
operator|*
name|this_cache
return|;
comment|/* Allocate a new cache.  */
name|cache
operator|=
name|FRAME_OBSTACK_ZALLOC
argument_list|(
expr|struct
name|libunwind_frame_cache
argument_list|)
expr_stmt|;
name|cache
operator|->
name|func_addr
operator|=
name|frame_func_unwind
argument_list|(
name|next_frame
argument_list|)
expr_stmt|;
comment|/* Get a libunwind cursor to the previous frame.  We do this by initializing      a cursor.  Libunwind treats a new cursor as the top of stack and will get      the current register set via the libunwind register accessor.  Now, we      provide the platform-specific accessors and we set up the register accessor to use      the frame register unwinding interfaces so that we properly get the registers for      the current frame rather than the top.  We then use the  unw_step function to       move the libunwind cursor back one frame.  We can later use this cursor to find previous       registers via the unw_get_reg interface which will invoke libunwind's special logic.  */
name|descr
operator|=
name|libunwind_descr
argument_list|(
name|get_frame_arch
argument_list|(
name|next_frame
argument_list|)
argument_list|)
expr_stmt|;
name|acc
operator|=
name|descr
operator|->
name|accessors
expr_stmt|;
name|as
operator|=
name|unw_create_addr_space_p
argument_list|(
name|acc
argument_list|,
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|?
name|__BIG_ENDIAN
else|:
name|__LITTLE_ENDIAN
argument_list|)
expr_stmt|;
name|unw_init_remote_p
argument_list|(
operator|&
name|cache
operator|->
name|cursor
argument_list|,
name|as
argument_list|,
name|next_frame
argument_list|)
expr_stmt|;
name|unw_step_p
argument_list|(
operator|&
name|cache
operator|->
name|cursor
argument_list|)
expr_stmt|;
comment|/* To get base address, get sp from previous frame.  */
name|uw_sp_regnum
operator|=
name|descr
operator|->
name|gdb2uw
argument_list|(
name|SP_REGNUM
argument_list|)
expr_stmt|;
name|ret
operator|=
name|unw_get_reg_p
argument_list|(
operator|&
name|cache
operator|->
name|cursor
argument_list|,
name|uw_sp_regnum
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Can't get libunwind sp register."
argument_list|)
expr_stmt|;
name|cache
operator|->
name|base
operator|=
operator|(
name|CORE_ADDR
operator|)
name|fp
expr_stmt|;
operator|*
name|this_cache
operator|=
name|cache
expr_stmt|;
return|return
name|cache
return|;
block|}
end_function

begin_function
name|unw_word_t
name|libunwind_find_dyn_list
parameter_list|(
name|unw_addr_space_t
name|as
parameter_list|,
name|unw_dyn_info_t
modifier|*
name|di
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
name|unw_find_dyn_list_p
argument_list|(
name|as
argument_list|,
name|di
argument_list|,
name|arg
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|frame_unwind
name|libunwind_frame_unwind
init|=
block|{
name|NORMAL_FRAME
block|,
name|libunwind_frame_this_id
block|,
name|libunwind_frame_prev_register
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Verify if there is sufficient libunwind information for the frame to use    libunwind frame unwinding.  */
end_comment

begin_function
specifier|const
name|struct
name|frame_unwind
modifier|*
name|libunwind_frame_sniffer
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
name|unw_cursor_t
name|cursor
decl_stmt|;
name|unw_accessors_t
modifier|*
name|acc
decl_stmt|;
name|unw_addr_space_t
name|as
decl_stmt|;
name|struct
name|libunwind_descr
modifier|*
name|descr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
comment|/* To test for libunwind unwind support, initialize a cursor to the current frame and try to back      up.  We use this same method when setting up the frame cache (see libunwind_frame_cache()).      If libunwind returns success for this operation, it means that it has found sufficient      libunwind unwinding information to do so.  */
name|descr
operator|=
name|libunwind_descr
argument_list|(
name|get_frame_arch
argument_list|(
name|next_frame
argument_list|)
argument_list|)
expr_stmt|;
name|acc
operator|=
name|descr
operator|->
name|accessors
expr_stmt|;
name|as
operator|=
name|unw_create_addr_space_p
argument_list|(
name|acc
argument_list|,
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|?
name|__BIG_ENDIAN
else|:
name|__LITTLE_ENDIAN
argument_list|)
expr_stmt|;
name|ret
operator|=
name|unw_init_remote_p
argument_list|(
operator|&
name|cursor
argument_list|,
name|as
argument_list|,
name|next_frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>=
literal|0
condition|)
name|ret
operator|=
name|unw_step_p
argument_list|(
operator|&
name|cursor
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
return|return
operator|&
name|libunwind_frame_unwind
return|;
block|}
end_function

begin_function
name|void
name|libunwind_frame_this_id
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|,
name|struct
name|frame_id
modifier|*
name|this_id
parameter_list|)
block|{
name|struct
name|libunwind_frame_cache
modifier|*
name|cache
init|=
name|libunwind_frame_cache
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|)
decl_stmt|;
operator|(
operator|*
name|this_id
operator|)
operator|=
name|frame_id_build
argument_list|(
name|cache
operator|->
name|base
argument_list|,
name|cache
operator|->
name|func_addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|libunwind_frame_prev_register
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|int
modifier|*
name|optimizedp
parameter_list|,
name|enum
name|lval_type
modifier|*
name|lvalp
parameter_list|,
name|CORE_ADDR
modifier|*
name|addrp
parameter_list|,
name|int
modifier|*
name|realnump
parameter_list|,
name|void
modifier|*
name|valuep
parameter_list|)
block|{
name|struct
name|libunwind_frame_cache
modifier|*
name|cache
init|=
name|libunwind_frame_cache
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|)
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|unw_cursor_t
modifier|*
name|c
decl_stmt|;
name|unw_save_loc_t
name|sl
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
name|unw_word_t
name|intval
decl_stmt|;
name|unw_fpreg_t
name|fpval
decl_stmt|;
name|unw_regnum_t
name|uw_regnum
decl_stmt|;
name|struct
name|libunwind_descr
modifier|*
name|descr
decl_stmt|;
comment|/* Convert from gdb register number to libunwind register number.  */
name|descr
operator|=
name|libunwind_descr
argument_list|(
name|get_frame_arch
argument_list|(
name|next_frame
argument_list|)
argument_list|)
expr_stmt|;
name|uw_regnum
operator|=
name|descr
operator|->
name|gdb2uw
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target_has_registers
condition|)
name|error
argument_list|(
literal|"No registers."
argument_list|)
expr_stmt|;
operator|*
name|optimizedp
operator|=
literal|0
expr_stmt|;
operator|*
name|addrp
operator|=
literal|0
expr_stmt|;
operator|*
name|lvalp
operator|=
name|not_lval
expr_stmt|;
operator|*
name|realnump
operator|=
operator|-
literal|1
expr_stmt|;
name|memset
argument_list|(
name|valuep
argument_list|,
literal|0
argument_list|,
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|uw_regnum
operator|<
literal|0
condition|)
return|return;
comment|/* To get the previous register, we use the libunwind register APIs with      the cursor we have already pushed back to the previous frame.  */
if|if
condition|(
name|descr
operator|->
name|is_fpreg
argument_list|(
name|uw_regnum
argument_list|)
condition|)
block|{
name|ret
operator|=
name|unw_get_fpreg_p
argument_list|(
operator|&
name|cache
operator|->
name|cursor
argument_list|,
name|uw_regnum
argument_list|,
operator|&
name|fpval
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|&
name|fpval
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|unw_get_reg_p
argument_list|(
operator|&
name|cache
operator|->
name|cursor
argument_list|,
name|uw_regnum
argument_list|,
operator|&
name|intval
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|&
name|intval
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return;
name|memcpy
argument_list|(
name|valuep
argument_list|,
name|ptr
argument_list|,
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|unw_get_saveloc_p
argument_list|(
operator|&
name|cache
operator|->
name|cursor
argument_list|,
name|uw_regnum
argument_list|,
operator|&
name|sl
argument_list|)
operator|<
literal|0
condition|)
return|return;
switch|switch
condition|(
name|sl
operator|.
name|type
condition|)
block|{
case|case
name|UNW_SLT_NONE
case|:
operator|*
name|optimizedp
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|UNW_SLT_MEMORY
case|:
operator|*
name|lvalp
operator|=
name|lval_memory
expr_stmt|;
operator|*
name|addrp
operator|=
name|sl
operator|.
name|u
operator|.
name|addr
expr_stmt|;
break|break;
case|case
name|UNW_SLT_REG
case|:
operator|*
name|lvalp
operator|=
name|lval_register
expr_stmt|;
operator|*
name|realnump
operator|=
name|regnum
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|CORE_ADDR
name|libunwind_frame_base_address
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|)
block|{
name|struct
name|libunwind_frame_cache
modifier|*
name|cache
init|=
name|libunwind_frame_cache
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|)
decl_stmt|;
return|return
name|cache
operator|->
name|base
return|;
block|}
end_function

begin_comment
comment|/* The following is a glue routine to call the libunwind unwind table    search function to get unwind information for a specified ip address.  */
end_comment

begin_function
name|int
name|libunwind_search_unwind_table
parameter_list|(
name|void
modifier|*
name|as
parameter_list|,
name|long
name|ip
parameter_list|,
name|void
modifier|*
name|di
parameter_list|,
name|void
modifier|*
name|pi
parameter_list|,
name|int
name|need_unwind_info
parameter_list|,
name|void
modifier|*
name|args
parameter_list|)
block|{
return|return
name|unw_search_unwind_table_p
argument_list|(
operator|*
operator|(
name|unw_addr_space_t
operator|*
operator|)
name|as
argument_list|,
operator|(
name|unw_word_t
operator|)
name|ip
argument_list|,
name|di
argument_list|,
name|pi
argument_list|,
name|need_unwind_info
argument_list|,
name|args
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|libunwind_load
parameter_list|(
name|void
parameter_list|)
block|{
name|void
modifier|*
name|handle
decl_stmt|;
name|handle
operator|=
name|dlopen
argument_list|(
name|LIBUNWIND_SO
argument_list|,
name|RTLD_NOW
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Initialize pointers to the dynamic library functions we will use.  */
name|unw_get_reg_p
operator|=
name|dlsym
argument_list|(
name|handle
argument_list|,
name|get_reg_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|unw_get_reg_p
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|unw_get_fpreg_p
operator|=
name|dlsym
argument_list|(
name|handle
argument_list|,
name|get_fpreg_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|unw_get_fpreg_p
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|unw_get_saveloc_p
operator|=
name|dlsym
argument_list|(
name|handle
argument_list|,
name|get_saveloc_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|unw_get_saveloc_p
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|unw_step_p
operator|=
name|dlsym
argument_list|(
name|handle
argument_list|,
name|step_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|unw_step_p
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|unw_init_remote_p
operator|=
name|dlsym
argument_list|(
name|handle
argument_list|,
name|init_remote_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|unw_init_remote_p
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|unw_create_addr_space_p
operator|=
name|dlsym
argument_list|(
name|handle
argument_list|,
name|create_addr_space_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|unw_create_addr_space_p
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|unw_search_unwind_table_p
operator|=
name|dlsym
argument_list|(
name|handle
argument_list|,
name|search_unwind_table_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|unw_search_unwind_table_p
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|unw_find_dyn_list_p
operator|=
name|dlsym
argument_list|(
name|handle
argument_list|,
name|find_dyn_list_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|unw_find_dyn_list_p
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|libunwind_is_initialized
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|libunwind_initialized
return|;
block|}
end_function

begin_comment
comment|/* Provide a prototype to silence -Wmissing-prototypes.  */
end_comment

begin_function_decl
name|void
name|_initialize_libunwind_frame
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|_initialize_libunwind_frame
parameter_list|(
name|void
parameter_list|)
block|{
name|libunwind_descr_handle
operator|=
name|register_gdbarch_data
argument_list|(
name|libunwind_descr_init
argument_list|)
expr_stmt|;
name|libunwind_initialized
operator|=
name|libunwind_load
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

