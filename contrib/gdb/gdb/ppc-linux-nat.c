begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* PPC GNU/Linux native support.    Copyright 1988, 1989, 1991, 1992, 1994, 1996, 2000, 2001, 2002    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/procfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_comment
comment|/* Prototypes for supply_gregset etc. */
end_comment

begin_include
include|#
directive|include
file|"gregset.h"
end_include

begin_include
include|#
directive|include
file|"ppc-tdep.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|PT_READ_U
end_ifndef

begin_define
define|#
directive|define
name|PT_READ_U
value|PTRACE_PEEKUSR
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PT_WRITE_U
end_ifndef

begin_define
define|#
directive|define
name|PT_WRITE_U
value|PTRACE_POKEUSR
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Default the type of the ptrace transfer to int.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PTRACE_XFER_TYPE
end_ifndef

begin_define
define|#
directive|define
name|PTRACE_XFER_TYPE
value|int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Glibc's headers don't define PTRACE_GETVRREGS so we cannot use a    configure time check.  Some older glibc's (for instance 2.2.1)    don't have a specific powerpc version of ptrace.h, and fall back on    a generic one.  In such cases, sys/ptrace.h defines    PTRACE_GETFPXREGS and PTRACE_SETFPXREGS to the same numbers that    ppc kernel's asm/ptrace.h defines PTRACE_GETVRREGS and    PTRACE_SETVRREGS to be.  This also makes a configury check pretty    much useless.  */
end_comment

begin_comment
comment|/* These definitions should really come from the glibc header files,    but Glibc doesn't know about the vrregs yet.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PTRACE_GETVRREGS
end_ifndef

begin_define
define|#
directive|define
name|PTRACE_GETVRREGS
value|18
end_define

begin_define
define|#
directive|define
name|PTRACE_SETVRREGS
value|19
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This oddity is because the Linux kernel defines elf_vrregset_t as    an array of 33 16 bytes long elements.  I.e. it leaves out vrsave.    However the PTRACE_GETVRREGS and PTRACE_SETVRREGS requests return    the vrsave as an extra 4 bytes at the end.  I opted for creating a    flat array of chars, so that it is easier to manipulate for gdb.     There are 32 vector registers 16 bytes longs, plus a VSCR register    which is only 4 bytes long, but is fetched as a 16 bytes    quantity. Up to here we have the elf_vrregset_t structure.    Appended to this there is space for the VRSAVE register: 4 bytes.    Even though this vrsave register is not included in the regset    typedef, it is handled by the ptrace requests.     Note that GNU/Linux doesn't support little endian PPC hardware,    therefore the offset at which the real value of the VSCR register    is located will be always 12 bytes.     The layout is like this (where x is the actual value of the vscr reg): */
end_comment

begin_comment
comment|/* *INDENT-OFF* */
end_comment

begin_comment
comment|/*    |.|.|.|.|.....|.|.|.|.||.|.|.|x||.|<-------><-------><-------><->      VR0           VR31     VSCR    VRSAVE */
end_comment

begin_comment
comment|/* *INDENT-ON* */
end_comment

begin_define
define|#
directive|define
name|SIZEOF_VRREGS
value|33*16+4
end_define

begin_typedef
typedef|typedef
name|char
name|gdb_vrregset_t
index|[
name|SIZEOF_VRREGS
index|]
typedef|;
end_typedef

begin_comment
comment|/* For runtime check of ptrace support for VRREGS.  */
end_comment

begin_decl_stmt
name|int
name|have_ptrace_getvrregs
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|kernel_u_size
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|user
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* *INDENT-OFF* */
end_comment

begin_comment
comment|/* registers layout, as presented by the ptrace interface: PT_R0, PT_R1, PT_R2, PT_R3, PT_R4, PT_R5, PT_R6, PT_R7, PT_R8, PT_R9, PT_R10, PT_R11, PT_R12, PT_R13, PT_R14, PT_R15, PT_R16, PT_R17, PT_R18, PT_R19, PT_R20, PT_R21, PT_R22, PT_R23, PT_R24, PT_R25, PT_R26, PT_R27, PT_R28, PT_R29, PT_R30, PT_R31, PT_FPR0, PT_FPR0 + 2, PT_FPR0 + 4, PT_FPR0 + 6, PT_FPR0 + 8, PT_FPR0 + 10, PT_FPR0 + 12, PT_FPR0 + 14, PT_FPR0 + 16, PT_FPR0 + 18, PT_FPR0 + 20, PT_FPR0 + 22, PT_FPR0 + 24, PT_FPR0 + 26, PT_FPR0 + 28, PT_FPR0 + 30, PT_FPR0 + 32, PT_FPR0 + 34, PT_FPR0 + 36, PT_FPR0 + 38, PT_FPR0 + 40, PT_FPR0 + 42, PT_FPR0 + 44, PT_FPR0 + 46, PT_FPR0 + 48, PT_FPR0 + 50, PT_FPR0 + 52, PT_FPR0 + 54, PT_FPR0 + 56, PT_FPR0 + 58, PT_FPR0 + 60, PT_FPR0 + 62, PT_NIP, PT_MSR, PT_CCR, PT_LNK, PT_CTR, PT_XER, PT_MQ */
end_comment

begin_comment
comment|/* *INDENT_ON * */
end_comment

begin_function
specifier|static
name|int
name|ppc_register_u_addr
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|int
name|u_addr
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
comment|/* General purpose registers occupy 1 slot each in the buffer */
if|if
condition|(
name|regno
operator|>=
name|tdep
operator|->
name|ppc_gp0_regnum
operator|&&
name|regno
operator|<=
name|tdep
operator|->
name|ppc_gplast_regnum
condition|)
name|u_addr
operator|=
operator|(
operator|(
name|PT_R0
operator|+
name|regno
operator|)
operator|*
literal|4
operator|)
expr_stmt|;
comment|/* Floating point regs: 2 slots each */
if|if
condition|(
name|regno
operator|>=
name|FP0_REGNUM
operator|&&
name|regno
operator|<=
name|FPLAST_REGNUM
condition|)
name|u_addr
operator|=
operator|(
operator|(
name|PT_FPR0
operator|+
operator|(
name|regno
operator|-
name|FP0_REGNUM
operator|)
operator|*
literal|2
operator|)
operator|*
literal|4
operator|)
expr_stmt|;
comment|/* UISA special purpose registers: 1 slot each */
if|if
condition|(
name|regno
operator|==
name|PC_REGNUM
condition|)
name|u_addr
operator|=
name|PT_NIP
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|tdep
operator|->
name|ppc_lr_regnum
condition|)
name|u_addr
operator|=
name|PT_LNK
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|tdep
operator|->
name|ppc_cr_regnum
condition|)
name|u_addr
operator|=
name|PT_CCR
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|tdep
operator|->
name|ppc_xer_regnum
condition|)
name|u_addr
operator|=
name|PT_XER
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|tdep
operator|->
name|ppc_ctr_regnum
condition|)
name|u_addr
operator|=
name|PT_CTR
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|tdep
operator|->
name|ppc_mq_regnum
condition|)
name|u_addr
operator|=
name|PT_MQ
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|tdep
operator|->
name|ppc_ps_regnum
condition|)
name|u_addr
operator|=
name|PT_MSR
operator|*
literal|4
expr_stmt|;
return|return
name|u_addr
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ppc_ptrace_cannot_fetch_store_register
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
return|return
operator|(
name|ppc_register_u_addr
argument_list|(
name|regno
argument_list|)
operator|==
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The Linux kernel ptrace interface for AltiVec registers uses the    registers set mechanism, as opposed to the interface for all the    other registers, that stores/fetches each register individually.  */
end_comment

begin_function
specifier|static
name|void
name|fetch_altivec_register
parameter_list|(
name|int
name|tid
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|gdb_vrregset_t
name|regs
decl_stmt|;
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
name|int
name|vrregsize
init|=
name|REGISTER_RAW_SIZE
argument_list|(
name|tdep
operator|->
name|ppc_vr0_regnum
argument_list|)
decl_stmt|;
name|ret
operator|=
name|ptrace
argument_list|(
name|PTRACE_GETVRREGS
argument_list|,
name|tid
argument_list|,
literal|0
argument_list|,
operator|&
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EIO
condition|)
block|{
name|have_ptrace_getvrregs
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|perror_with_name
argument_list|(
literal|"Unable to fetch AltiVec register"
argument_list|)
expr_stmt|;
block|}
comment|/* VSCR is fetched as a 16 bytes quantity, but it is really 4 bytes      long on the hardware.  We deal only with the lower 4 bytes of the      vector.  VRSAVE is at the end of the array in a 4 bytes slot, so      there is no need to define an offset for it.  */
if|if
condition|(
name|regno
operator|==
operator|(
name|tdep
operator|->
name|ppc_vrsave_regnum
operator|-
literal|1
operator|)
condition|)
name|offset
operator|=
name|vrregsize
operator|-
name|REGISTER_RAW_SIZE
argument_list|(
name|tdep
operator|->
name|ppc_vrsave_regnum
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
argument_list|,
name|regs
operator|+
operator|(
name|regno
operator|-
name|tdep
operator|->
name|ppc_vr0_regnum
operator|)
operator|*
name|vrregsize
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fetch_register
parameter_list|(
name|int
name|tid
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
comment|/* This isn't really an address.  But ptrace thinks of it as one.  */
name|char
name|mess
index|[
literal|128
index|]
decl_stmt|;
comment|/* For messages */
specifier|register
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
comment|/* Offset of registers within the u area. */
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|MAX_REGISTER_RAW_SIZE
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|regaddr
init|=
name|ppc_register_u_addr
argument_list|(
name|regno
argument_list|)
decl_stmt|;
if|if
condition|(
name|altivec_register_p
argument_list|(
name|regno
argument_list|)
condition|)
block|{
comment|/* If this is the first time through, or if it is not the first          time through, and we have comfirmed that there is kernel          support for such a ptrace request, then go and fetch the          register.  */
if|if
condition|(
name|have_ptrace_getvrregs
condition|)
block|{
name|fetch_altivec_register
argument_list|(
name|tid
argument_list|,
name|regno
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we have discovered that there is no ptrace support for         AltiVec registers, fall through and return zeroes, because         regaddr will be -1 in this case.  */
block|}
if|if
condition|(
name|regaddr
operator|==
operator|-
literal|1
condition|)
block|{
name|memset
argument_list|(
name|buf
argument_list|,
literal|'\0'
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Supply zeroes */
name|supply_register
argument_list|(
name|regno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|PTRACE_XFER_TYPE
operator|*
operator|)
operator|&
name|buf
index|[
name|i
index|]
operator|=
name|ptrace
argument_list|(
name|PT_READ_U
argument_list|,
name|tid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|regaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|regaddr
operator|+=
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|mess
argument_list|,
literal|"reading register %s (#%d)"
argument_list|,
name|REGISTER_NAME
argument_list|(
name|regno
argument_list|)
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|mess
argument_list|)
expr_stmt|;
block|}
block|}
name|supply_register
argument_list|(
name|regno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|supply_vrregset
parameter_list|(
name|gdb_vrregset_t
modifier|*
name|vrregsetp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
name|int
name|num_of_vrregs
init|=
name|tdep
operator|->
name|ppc_vrsave_regnum
operator|-
name|tdep
operator|->
name|ppc_vr0_regnum
operator|+
literal|1
decl_stmt|;
name|int
name|vrregsize
init|=
name|REGISTER_RAW_SIZE
argument_list|(
name|tdep
operator|->
name|ppc_vr0_regnum
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
name|vrregsize
operator|-
name|REGISTER_RAW_SIZE
argument_list|(
name|tdep
operator|->
name|ppc_vrsave_regnum
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_of_vrregs
condition|;
name|i
operator|++
control|)
block|{
comment|/* The last 2 registers of this set are only 32 bit long, not          128.  However an offset is necessary only for VSCR because it          occupies a whole vector, while VRSAVE occupies a full 4 bytes          slot.  */
if|if
condition|(
name|i
operator|==
operator|(
name|num_of_vrregs
operator|-
literal|2
operator|)
condition|)
name|supply_register
argument_list|(
name|tdep
operator|->
name|ppc_vr0_regnum
operator|+
name|i
argument_list|,
operator|*
name|vrregsetp
operator|+
name|i
operator|*
name|vrregsize
operator|+
name|offset
argument_list|)
expr_stmt|;
else|else
name|supply_register
argument_list|(
name|tdep
operator|->
name|ppc_vr0_regnum
operator|+
name|i
argument_list|,
operator|*
name|vrregsetp
operator|+
name|i
operator|*
name|vrregsize
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fetch_altivec_registers
parameter_list|(
name|int
name|tid
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|gdb_vrregset_t
name|regs
decl_stmt|;
name|ret
operator|=
name|ptrace
argument_list|(
name|PTRACE_GETVRREGS
argument_list|,
name|tid
argument_list|,
literal|0
argument_list|,
operator|&
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EIO
condition|)
block|{
name|have_ptrace_getvrregs
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|perror_with_name
argument_list|(
literal|"Unable to fetch AltiVec registers"
argument_list|)
expr_stmt|;
block|}
name|supply_vrregset
argument_list|(
operator|&
name|regs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fetch_ppc_registers
parameter_list|(
name|int
name|tid
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|tdep
operator|->
name|ppc_mq_regnum
condition|;
name|i
operator|++
control|)
name|fetch_register
argument_list|(
name|tid
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_ptrace_getvrregs
condition|)
if|if
condition|(
name|tdep
operator|->
name|ppc_vr0_regnum
operator|!=
operator|-
literal|1
operator|&&
name|tdep
operator|->
name|ppc_vrsave_regnum
operator|!=
operator|-
literal|1
condition|)
name|fetch_altivec_registers
argument_list|(
name|tid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fetch registers from the child process.  Fetch all registers if    regno == -1, otherwise fetch all general registers or all floating    point registers depending upon the value of regno.  */
end_comment

begin_function
name|void
name|fetch_inferior_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
comment|/* Overload thread id onto process id */
name|int
name|tid
init|=
name|TIDGET
argument_list|(
name|inferior_ptid
argument_list|)
decl_stmt|;
comment|/* No thread id, just use process id */
if|if
condition|(
name|tid
operator|==
literal|0
condition|)
name|tid
operator|=
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
name|fetch_ppc_registers
argument_list|(
name|tid
argument_list|)
expr_stmt|;
else|else
name|fetch_register
argument_list|(
name|tid
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store one register. */
end_comment

begin_function
specifier|static
name|void
name|store_altivec_register
parameter_list|(
name|int
name|tid
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|gdb_vrregset_t
name|regs
decl_stmt|;
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
name|int
name|vrregsize
init|=
name|REGISTER_RAW_SIZE
argument_list|(
name|tdep
operator|->
name|ppc_vr0_regnum
argument_list|)
decl_stmt|;
name|ret
operator|=
name|ptrace
argument_list|(
name|PTRACE_GETVRREGS
argument_list|,
name|tid
argument_list|,
literal|0
argument_list|,
operator|&
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EIO
condition|)
block|{
name|have_ptrace_getvrregs
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|perror_with_name
argument_list|(
literal|"Unable to fetch AltiVec register"
argument_list|)
expr_stmt|;
block|}
comment|/* VSCR is fetched as a 16 bytes quantity, but it is really 4 bytes      long on the hardware.  */
if|if
condition|(
name|regno
operator|==
operator|(
name|tdep
operator|->
name|ppc_vrsave_regnum
operator|-
literal|1
operator|)
condition|)
name|offset
operator|=
name|vrregsize
operator|-
name|REGISTER_RAW_SIZE
argument_list|(
name|tdep
operator|->
name|ppc_vrsave_regnum
argument_list|)
expr_stmt|;
name|regcache_collect
argument_list|(
name|regno
argument_list|,
name|regs
operator|+
operator|(
name|regno
operator|-
name|tdep
operator|->
name|ppc_vr0_regnum
operator|)
operator|*
name|vrregsize
operator|+
name|offset
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ptrace
argument_list|(
name|PTRACE_SETVRREGS
argument_list|,
name|tid
argument_list|,
literal|0
argument_list|,
operator|&
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"Unable to store AltiVec register"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|store_register
parameter_list|(
name|int
name|tid
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
comment|/* This isn't really an address.  But ptrace thinks of it as one.  */
name|CORE_ADDR
name|regaddr
init|=
name|ppc_register_u_addr
argument_list|(
name|regno
argument_list|)
decl_stmt|;
name|char
name|mess
index|[
literal|128
index|]
decl_stmt|;
comment|/* For messages */
specifier|register
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
comment|/* Offset of registers within the u area.  */
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|MAX_REGISTER_RAW_SIZE
argument_list|)
decl_stmt|;
if|if
condition|(
name|altivec_register_p
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|store_altivec_register
argument_list|(
name|tid
argument_list|,
name|regno
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|regaddr
operator|==
operator|-
literal|1
condition|)
return|return;
name|regcache_collect
argument_list|(
name|regno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|PT_WRITE_U
argument_list|,
name|tid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|regaddr
argument_list|,
operator|*
operator|(
name|PTRACE_XFER_TYPE
operator|*
operator|)
operator|&
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|regaddr
operator|+=
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|mess
argument_list|,
literal|"writing register %s (#%d)"
argument_list|,
name|REGISTER_NAME
argument_list|(
name|regno
argument_list|)
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|mess
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|fill_vrregset
parameter_list|(
name|gdb_vrregset_t
modifier|*
name|vrregsetp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
name|int
name|num_of_vrregs
init|=
name|tdep
operator|->
name|ppc_vrsave_regnum
operator|-
name|tdep
operator|->
name|ppc_vr0_regnum
operator|+
literal|1
decl_stmt|;
name|int
name|vrregsize
init|=
name|REGISTER_RAW_SIZE
argument_list|(
name|tdep
operator|->
name|ppc_vr0_regnum
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
name|vrregsize
operator|-
name|REGISTER_RAW_SIZE
argument_list|(
name|tdep
operator|->
name|ppc_vrsave_regnum
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_of_vrregs
condition|;
name|i
operator|++
control|)
block|{
comment|/* The last 2 registers of this set are only 32 bit long, not          128, but only VSCR is fetched as a 16 bytes quantity.  */
if|if
condition|(
name|i
operator|==
operator|(
name|num_of_vrregs
operator|-
literal|2
operator|)
condition|)
name|regcache_collect
argument_list|(
name|tdep
operator|->
name|ppc_vr0_regnum
operator|+
name|i
argument_list|,
operator|*
name|vrregsetp
operator|+
name|i
operator|*
name|vrregsize
operator|+
name|offset
argument_list|)
expr_stmt|;
else|else
name|regcache_collect
argument_list|(
name|tdep
operator|->
name|ppc_vr0_regnum
operator|+
name|i
argument_list|,
operator|*
name|vrregsetp
operator|+
name|i
operator|*
name|vrregsize
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|store_altivec_registers
parameter_list|(
name|int
name|tid
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|gdb_vrregset_t
name|regs
decl_stmt|;
name|ret
operator|=
name|ptrace
argument_list|(
name|PTRACE_GETVRREGS
argument_list|,
name|tid
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
operator|&
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EIO
condition|)
block|{
name|have_ptrace_getvrregs
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|perror_with_name
argument_list|(
literal|"Couldn't get AltiVec registers"
argument_list|)
expr_stmt|;
block|}
name|fill_vrregset
argument_list|(
operator|&
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PTRACE_SETVRREGS
argument_list|,
name|tid
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
operator|&
name|regs
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"Couldn't write AltiVec registers"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|store_ppc_registers
parameter_list|(
name|int
name|tid
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|tdep
operator|->
name|ppc_mq_regnum
condition|;
name|i
operator|++
control|)
name|store_register
argument_list|(
name|tid
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_ptrace_getvrregs
condition|)
if|if
condition|(
name|tdep
operator|->
name|ppc_vr0_regnum
operator|!=
operator|-
literal|1
operator|&&
name|tdep
operator|->
name|ppc_vrsave_regnum
operator|!=
operator|-
literal|1
condition|)
name|store_altivec_registers
argument_list|(
name|tid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|store_inferior_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
comment|/* Overload thread id onto process id */
name|int
name|tid
init|=
name|TIDGET
argument_list|(
name|inferior_ptid
argument_list|)
decl_stmt|;
comment|/* No thread id, just use process id */
if|if
condition|(
name|tid
operator|==
literal|0
condition|)
name|tid
operator|=
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|0
condition|)
name|store_register
argument_list|(
name|tid
argument_list|,
name|regno
argument_list|)
expr_stmt|;
else|else
name|store_ppc_registers
argument_list|(
name|tid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|supply_gregset
parameter_list|(
name|gdb_gregset_t
modifier|*
name|gregsetp
parameter_list|)
block|{
name|int
name|regi
decl_stmt|;
specifier|register
name|elf_greg_t
modifier|*
name|regp
init|=
operator|(
name|elf_greg_t
operator|*
operator|)
name|gregsetp
decl_stmt|;
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
for|for
control|(
name|regi
operator|=
literal|0
init|;
name|regi
operator|<
literal|32
condition|;
name|regi
operator|++
control|)
name|supply_register
argument_list|(
name|regi
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|regi
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|PC_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|PT_NIP
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|tdep
operator|->
name|ppc_lr_regnum
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|PT_LNK
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|tdep
operator|->
name|ppc_cr_regnum
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|PT_CCR
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|tdep
operator|->
name|ppc_xer_regnum
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|PT_XER
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|tdep
operator|->
name|ppc_ctr_regnum
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|PT_CTR
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|tdep
operator|->
name|ppc_mq_regnum
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|PT_MQ
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|tdep
operator|->
name|ppc_ps_regnum
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|PT_MSR
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fill_gregset
parameter_list|(
name|gdb_gregset_t
modifier|*
name|gregsetp
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|int
name|regi
decl_stmt|;
name|elf_greg_t
modifier|*
name|regp
init|=
operator|(
name|elf_greg_t
operator|*
operator|)
name|gregsetp
decl_stmt|;
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
for|for
control|(
name|regi
operator|=
literal|0
init|;
name|regi
operator|<
literal|32
condition|;
name|regi
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
name|regno
operator|==
name|regi
condition|)
name|regcache_collect
argument_list|(
name|regi
argument_list|,
name|regp
operator|+
name|PT_R0
operator|+
name|regi
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
name|regno
operator|==
name|PC_REGNUM
condition|)
name|regcache_collect
argument_list|(
name|PC_REGNUM
argument_list|,
name|regp
operator|+
name|PT_NIP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
name|regno
operator|==
name|tdep
operator|->
name|ppc_lr_regnum
condition|)
name|regcache_collect
argument_list|(
name|tdep
operator|->
name|ppc_lr_regnum
argument_list|,
name|regp
operator|+
name|PT_LNK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
name|regno
operator|==
name|tdep
operator|->
name|ppc_cr_regnum
condition|)
name|regcache_collect
argument_list|(
name|tdep
operator|->
name|ppc_cr_regnum
argument_list|,
name|regp
operator|+
name|PT_CCR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
name|regno
operator|==
name|tdep
operator|->
name|ppc_xer_regnum
condition|)
name|regcache_collect
argument_list|(
name|tdep
operator|->
name|ppc_xer_regnum
argument_list|,
name|regp
operator|+
name|PT_XER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
name|regno
operator|==
name|tdep
operator|->
name|ppc_ctr_regnum
condition|)
name|regcache_collect
argument_list|(
name|tdep
operator|->
name|ppc_ctr_regnum
argument_list|,
name|regp
operator|+
name|PT_CTR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
name|regno
operator|==
name|tdep
operator|->
name|ppc_mq_regnum
condition|)
name|regcache_collect
argument_list|(
name|tdep
operator|->
name|ppc_mq_regnum
argument_list|,
name|regp
operator|+
name|PT_MQ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
name|regno
operator|==
name|tdep
operator|->
name|ppc_ps_regnum
condition|)
name|regcache_collect
argument_list|(
name|tdep
operator|->
name|ppc_ps_regnum
argument_list|,
name|regp
operator|+
name|PT_MSR
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|supply_fpregset
parameter_list|(
name|gdb_fpregset_t
modifier|*
name|fpregsetp
parameter_list|)
block|{
name|int
name|regi
decl_stmt|;
for|for
control|(
name|regi
operator|=
literal|0
init|;
name|regi
operator|<
literal|32
condition|;
name|regi
operator|++
control|)
name|supply_register
argument_list|(
name|FP0_REGNUM
operator|+
name|regi
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
operator|*
name|fpregsetp
operator|+
name|regi
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a pointer to a floating point register set in /proc format    (fpregset_t *), update the register specified by REGNO from gdb's    idea of the current floating point register set.  If REGNO is -1,    update them all.  */
end_comment

begin_function
name|void
name|fill_fpregset
parameter_list|(
name|gdb_fpregset_t
modifier|*
name|fpregsetp
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|int
name|regi
decl_stmt|;
for|for
control|(
name|regi
operator|=
literal|0
init|;
name|regi
operator|<
literal|32
condition|;
name|regi
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|FP0_REGNUM
operator|+
name|regi
operator|)
condition|)
name|regcache_collect
argument_list|(
name|FP0_REGNUM
operator|+
name|regi
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
operator|*
name|fpregsetp
operator|+
name|regi
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

