begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Remote debugging interface for Array Tech RAID controller..    Copyright 90, 91, 92, 93, 94, 1995  Free Software Foundation, Inc.    Contributed by Cygnus Support. Written by Rob Savoye for Cygnus.     This module talks to a debug monitor called 'MONITOR', which    We communicate with MONITOR via either a direct serial line, or a TCP    (or possibly TELNET) stream to a terminal multiplexor,    which in turn talks to the target board.    This file is part of GDB.    This program is free software; you can redistribute it and/or modify   it under the terms of the GNU General Public License as published by   the Free Software Foundation; either version 2 of the License, or   (at your option) any later version.    This program is distributed in the hope that it will be useful,   but WITHOUT ANY WARRANTY; without even the implied warranty of   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   GNU General Public License for more details.    You should have received a copy of the GNU General Public License   along with this program; if not, write to the Free Software   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_include
include|#
directive|include
file|"monitor.h"
end_include

begin_include
include|#
directive|include
file|"remote-utils.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|baud_rate
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ARRAY_PROMPT
value|">> "
end_define

begin_define
define|#
directive|define
name|SWAP_TARGET_AND_HOST
parameter_list|(
name|buffer
parameter_list|,
name|len
parameter_list|)
define|\
value|do									\     {									\       if (TARGET_BYTE_ORDER != HOST_BYTE_ORDER)				\ 	{								\ 	  char tmp;							\ 	  char *p = (char *)(buffer);					\ 	  char *q = ((char *)(buffer)) + len - 1;		   	\ 	  for (; p< q; p++, q--)				 	\ 	    {								\ 	      tmp = *q;							\ 	      *q = *p;							\ 	      *p = tmp;							\ 	    }								\ 	}								\     }									\   while (0)
end_define

begin_decl_stmt
specifier|static
name|void
name|debuglogs
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|array_open
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|array_close
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|array_detach
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|array_attach
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|array_resume
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|array_fetch_register
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|array_store_register
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|array_fetch_registers
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|array_store_registers
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|array_prepare_to_store
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|array_files_info
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|array_kill
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|array_create_inferior
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|array_mourn_inferior
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|make_gdb_packet
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|array_xfer_memory
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|array_wait
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|array_insert_breakpoint
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|array_remove_breakpoint
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tohex
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|to_hex
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|from_hex
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|array_send_packet
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|array_get_packet
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|ascii2hexword
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|hexword2ascii
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|version
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LOG_FILE
value|"monitor.log"
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LOG_FILE
argument_list|)
end_if

begin_decl_stmt
name|FILE
modifier|*
name|log_file
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|timeout
init|=
literal|30
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Having this larger than 400 causes us to be incompatible with m68k-stub.c    and i386-stub.c.  Normally, no one would notice because it only matters    for writing large chunks of memory (e.g. in downloads).  Also, this needs    to be more than 400 if required to hold the registers (see below, where    we round it up based on REGISTER_BYTES).  */
end_comment

begin_define
define|#
directive|define
name|PBUFSIZ
value|400
end_define

begin_comment
comment|/*   * Descriptor for I/O to remote machine.  Initialize it to NULL so that  * array_open knows that we don't have a file open when the program starts.  */
end_comment

begin_decl_stmt
name|serial_t
name|array_desc
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * this array of registers need to match the indexes used by GDB. The  * whole reason this exists is cause the various ROM monitors use  * different strings than GDB does, and doesn't support all the  * registers either. So, typing "info reg sp" becomes a "r30".  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|tmp_mips_processor_type
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|mips_set_processor_type
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|target_ops
name|array_ops
init|=
block|{
literal|"array"
block|,
comment|/* to_shortname */
comment|/* to_longname */
literal|"Debug using the standard GDB remote protocol for the Array Tech target."
block|,
comment|/* to_doc */
literal|"Debug using the standard GDB remote protocol for the Array Tech target.\n\ Specify the serial device it is connected to (e.g. /dev/ttya)."
block|,
name|array_open
block|,
comment|/* to_open */
name|array_close
block|,
comment|/* to_close */
name|NULL
block|,
comment|/* to_attach */
name|array_detach
block|,
comment|/* to_detach */
name|array_resume
block|,
comment|/* to_resume */
name|array_wait
block|,
comment|/* to_wait */
name|array_fetch_registers
block|,
comment|/* to_fetch_registers */
name|array_store_registers
block|,
comment|/* to_store_registers */
name|array_prepare_to_store
block|,
comment|/* to_prepare_to_store */
name|array_xfer_memory
block|,
comment|/* to_xfer_memory */
name|array_files_info
block|,
comment|/* to_files_info */
name|array_insert_breakpoint
block|,
comment|/* to_insert_breakpoint */
name|array_remove_breakpoint
block|,
comment|/* to_remove_breakpoint */
literal|0
block|,
comment|/* to_terminal_init */
literal|0
block|,
comment|/* to_terminal_inferior */
literal|0
block|,
comment|/* to_terminal_ours_for_output */
literal|0
block|,
comment|/* to_terminal_ours */
literal|0
block|,
comment|/* to_terminal_info */
name|array_kill
block|,
comment|/* to_kill */
literal|0
block|,
comment|/* to_load */
literal|0
block|,
comment|/* to_lookup_symbol */
name|array_create_inferior
block|,
comment|/* to_create_inferior */
name|array_mourn_inferior
block|,
comment|/* to_mourn_inferior */
literal|0
block|,
comment|/* to_can_run */
literal|0
block|,
comment|/* to_notice_signals */
literal|0
block|,
comment|/* to_thread_alive */
literal|0
block|,
comment|/* to_stop */
name|process_stratum
block|,
comment|/* to_stratum */
literal|0
block|,
comment|/* to_next */
literal|1
block|,
comment|/* to_has_all_memory */
literal|1
block|,
comment|/* to_has_memory */
literal|1
block|,
comment|/* to_has_stack */
literal|1
block|,
comment|/* to_has_registers */
literal|1
block|,
comment|/* to_has_execution */
literal|0
block|,
comment|/* sections */
literal|0
block|,
comment|/* sections_end */
name|OPS_MAGIC
comment|/* to_magic */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * printf_monitor -- send data to monitor.  Works just like printf.  */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|printf_monitor
parameter_list|(
name|char
modifier|*
name|pattern
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|printf_monitor
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|args
decl_stmt|;
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|va_start
argument_list|(
name|args
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
else|#
directive|else
name|char
modifier|*
name|pattern
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|pattern
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vsprintf
argument_list|(
name|buf
argument_list|,
name|pattern
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|debuglogs
argument_list|(
literal|1
argument_list|,
literal|"printf_monitor(), Sending: \"%s\"."
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|>
name|PBUFSIZ
condition|)
name|error
argument_list|(
literal|"printf_monitor(): string too long"
argument_list|)
expr_stmt|;
if|if
condition|(
name|SERIAL_WRITE
argument_list|(
name|array_desc
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"SERIAL_WRITE failed: %s\n"
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * write_monitor -- send raw data to monitor.  */
end_comment

begin_function
specifier|static
name|void
name|write_monitor
parameter_list|(
name|data
parameter_list|,
name|len
parameter_list|)
name|char
name|data
index|[]
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
if|if
condition|(
name|SERIAL_WRITE
argument_list|(
name|array_desc
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"SERIAL_WRITE failed: %s\n"
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|data
operator|+
name|len
operator|+
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|debuglogs
argument_list|(
literal|1
argument_list|,
literal|"write_monitor(), Sending: \"%s\"."
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * debuglogs -- deal with debugging info to multiple sources. This takes  *	two real args, the first one is the level to be compared against   *	the sr_get_debug() value, the second arg is a printf buffer and args  *	to be formatted and printed. A CR is added after each string is printed.  */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|debuglogs
parameter_list|(
name|int
name|level
parameter_list|,
name|char
modifier|*
name|pattern
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|debuglogs
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|args
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|char
name|newbuf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|va_start
argument_list|(
name|args
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
else|#
directive|else
name|char
modifier|*
name|pattern
decl_stmt|;
name|int
name|level
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|level
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|int
argument_list|)
expr_stmt|;
comment|/* get the debug level */
name|pattern
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
comment|/* get the printf style pattern */
endif|#
directive|endif
if|if
condition|(
operator|(
name|level
operator|<
literal|0
operator|)
operator|||
operator|(
name|level
operator|>
literal|100
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"Bad argument passed to debuglogs(), needs debug level"
argument_list|)
expr_stmt|;
return|return;
block|}
name|vsprintf
argument_list|(
name|buf
argument_list|,
name|pattern
argument_list|,
name|args
argument_list|)
expr_stmt|;
comment|/* format the string */
comment|/* convert some characters so it'll look right in the log */
name|p
operator|=
name|newbuf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|buf
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
name|PBUFSIZ
condition|)
name|error
argument_list|(
literal|"Debug message too long"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|buf
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'\n'
case|:
comment|/* newlines */
operator|*
name|p
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'n'
expr_stmt|;
continue|continue;
case|case
literal|'\r'
case|:
comment|/* carriage returns */
operator|*
name|p
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'r'
expr_stmt|;
continue|continue;
case|case
literal|'\033'
case|:
comment|/* escape */
operator|*
name|p
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'e'
expr_stmt|;
continue|continue;
case|case
literal|'\t'
case|:
comment|/* tab */
operator|*
name|p
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'t'
expr_stmt|;
continue|continue;
case|case
literal|'\b'
case|:
comment|/* backspace */
operator|*
name|p
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'b'
expr_stmt|;
continue|continue;
default|default:
comment|/* no change */
operator|*
name|p
operator|++
operator|=
name|buf
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|<
literal|26
condition|)
block|{
comment|/* modify control characters */
operator|*
name|p
operator|++
operator|=
literal|'^'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|buf
index|[
name|i
index|]
operator|+
literal|'A'
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|>=
literal|128
condition|)
block|{
comment|/* modify control characters */
operator|*
name|p
operator|++
operator|=
literal|'!'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|buf
index|[
name|i
index|]
operator|+
literal|'A'
expr_stmt|;
continue|continue;
block|}
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* terminate the string */
if|if
condition|(
name|sr_get_debug
argument_list|()
operator|>
name|level
condition|)
name|printf_unfiltered
argument_list|(
literal|"%s\n"
argument_list|,
name|newbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG_FILE
comment|/* write to the monitor log */
if|if
condition|(
name|log_file
operator|!=
literal|0x0
condition|)
block|{
name|fputs
argument_list|(
name|newbuf
argument_list|,
name|log_file
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|log_file
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|log_file
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* readchar -- read a character from the remote system, doing all the fancy  *	timeout stuff.  */
end_comment

begin_function
specifier|static
name|int
name|readchar
parameter_list|(
name|timeout
parameter_list|)
name|int
name|timeout
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
name|SERIAL_READCHAR
argument_list|(
name|array_desc
argument_list|,
name|abs
argument_list|(
name|timeout
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
operator|>
literal|5
condition|)
block|{
name|putchar
argument_list|(
name|c
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
name|debuglogs
argument_list|(
literal|5
argument_list|,
literal|"readchar: timeout = %d\n"
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|LOG_FILE
if|if
condition|(
name|isascii
argument_list|(
name|c
argument_list|)
condition|)
name|putc
argument_list|(
name|c
operator|&
literal|0x7f
argument_list|,
name|log_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|c
operator|>=
literal|0
condition|)
return|return
name|c
operator|&
literal|0x7f
return|;
if|if
condition|(
name|c
operator|==
name|SERIAL_TIMEOUT
condition|)
block|{
if|if
condition|(
name|timeout
operator|<=
literal|0
condition|)
return|return
name|c
return|;
comment|/* Polls shouldn't generate timeout errors */
name|error
argument_list|(
literal|"Timeout reading from remote system."
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG_FILE
name|fputs
argument_list|(
literal|"ERROR: Timeout reading from remote system"
argument_list|,
name|log_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|perror_with_name
argument_list|(
literal|"readchar"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * expect --  scan input from the remote system, until STRING is found.  *	If DISCARD is non-zero, then discard non-matching input, else print  *	it out. Let the user break out immediately.  */
end_comment

begin_function
specifier|static
name|void
name|expect
parameter_list|(
name|string
parameter_list|,
name|discard
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|discard
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|string
decl_stmt|;
name|int
name|c
decl_stmt|;
name|debuglogs
argument_list|(
literal|1
argument_list|,
literal|"Expecting \"%s\"."
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|immediate_quit
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isascii
argument_list|(
name|c
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|c
operator|==
operator|*
name|p
operator|++
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|immediate_quit
operator|=
literal|0
expr_stmt|;
name|debuglogs
argument_list|(
literal|4
argument_list|,
literal|"Matched"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|discard
condition|)
block|{
name|fputc_unfiltered
argument_list|(
name|c
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|string
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Keep discarding input until we see the MONITOR array_cmds->prompt.     The convention for dealing with the expect_prompt is that you    o give your command    o *then* wait for the expect_prompt.     Thus the last thing that a procedure does with the serial line    will be an expect_prompt().  Exception:  array_resume does not    wait for the expect_prompt, because the terminal is being handed over    to the inferior.  However, the next thing which happens after that    is a array_wait which does wait for the expect_prompt.    Note that this includes abnormal exit, e.g. error().  This is    necessary to prevent getting into states from which we can't    recover.  */
end_comment

begin_function
specifier|static
name|void
name|expect_prompt
parameter_list|(
name|discard
parameter_list|)
name|int
name|discard
decl_stmt|;
block|{
name|expect
argument_list|(
name|ARRAY_PROMPT
argument_list|,
name|discard
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * junk -- ignore junk characters. Returns a 1 if junk, 0 otherwise  */
end_comment

begin_function
specifier|static
name|int
name|junk
parameter_list|(
name|ch
parameter_list|)
name|char
name|ch
decl_stmt|;
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'\0'
case|:
case|case
literal|' '
case|:
case|case
literal|'-'
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
if|if
condition|(
name|sr_get_debug
argument_list|()
operator|>
literal|5
condition|)
name|debuglogs
argument_list|(
literal|5
argument_list|,
literal|"Ignoring \'%c\'."
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
default|default:
if|if
condition|(
name|sr_get_debug
argument_list|()
operator|>
literal|5
condition|)
name|debuglogs
argument_list|(
literal|5
argument_list|,
literal|"Accepting \'%c\'."
argument_list|,
name|ch
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/*   *  get_hex_digit -- Get a hex digit from the remote system& return its value.  *		If ignore is nonzero, ignore spaces, newline& tabs.  */
end_comment

begin_function
specifier|static
name|int
name|get_hex_digit
parameter_list|(
name|ignore
parameter_list|)
name|int
name|ignore
decl_stmt|;
block|{
specifier|static
name|int
name|ch
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|ch
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|junk
argument_list|(
name|ch
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|sr_get_debug
argument_list|()
operator|>
literal|4
condition|)
block|{
name|debuglogs
argument_list|(
literal|4
argument_list|,
literal|"get_hex_digit() got a 0x%x(%c)"
argument_list|,
name|ch
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|LOG_FILE
comment|/* write to the monitor log */
if|if
condition|(
name|log_file
operator|!=
literal|0x0
condition|)
block|{
name|fputs
argument_list|(
literal|"get_hex_digit() got a 0x"
argument_list|,
name|log_file
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
name|ch
argument_list|,
name|log_file
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|log_file
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|log_file
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
return|return
name|ch
operator|-
literal|'0'
return|;
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'F'
condition|)
return|return
name|ch
operator|-
literal|'A'
operator|+
literal|10
return|;
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'f'
condition|)
return|return
name|ch
operator|-
literal|'a'
operator|+
literal|10
return|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|' '
operator|&&
name|ignore
condition|)
empty_stmt|;
else|else
block|{
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|debuglogs
argument_list|(
literal|4
argument_list|,
literal|"Invalid hex digit from remote system. (0x%x)"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Invalid hex digit from remote system. (0x%x)"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* get_hex_byte -- Get a byte from monitor and put it in *BYT.   *	Accept any number leading spaces.  */
end_comment

begin_function
specifier|static
name|void
name|get_hex_byte
parameter_list|(
name|byt
parameter_list|)
name|char
modifier|*
name|byt
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
name|val
operator|=
name|get_hex_digit
argument_list|(
literal|1
argument_list|)
operator|<<
literal|4
expr_stmt|;
name|debuglogs
argument_list|(
literal|4
argument_list|,
literal|"get_hex_byte() -- Read first nibble 0x%x"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator||=
name|get_hex_digit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|debuglogs
argument_list|(
literal|4
argument_list|,
literal|"get_hex_byte() -- Read second nibble 0x%x"
argument_list|,
name|val
argument_list|)
expr_stmt|;
operator|*
name|byt
operator|=
name|val
expr_stmt|;
name|debuglogs
argument_list|(
literal|4
argument_list|,
literal|"get_hex_byte() -- Read a 0x%x"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * get_hex_word --  Get N 32-bit words from remote, each preceded by a space,  *	and put them in registers starting at REGNO.  */
end_comment

begin_function
specifier|static
name|int
name|get_hex_word
parameter_list|()
block|{
name|long
name|val
decl_stmt|,
name|newval
decl_stmt|;
name|int
name|i
decl_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
block|if (HOST_BYTE_ORDER == BIG_ENDIAN) {
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|val
operator|=
operator|(
name|val
operator|<<
literal|4
operator|)
operator|+
name|get_hex_digit
argument_list|(
name|i
operator|==
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|} else {     for (i = 7; i>= 0; i--)       val = (val<< 4) + get_hex_digit (i == 0);   }
endif|#
directive|endif
name|debuglogs
argument_list|(
literal|4
argument_list|,
literal|"get_hex_word() got a 0x%x for a %s host."
argument_list|,
name|val
argument_list|,
operator|(
name|HOST_BYTE_ORDER
operator|==
name|BIG_ENDIAN
operator|)
condition|?
literal|"big endian"
else|:
literal|"little endian"
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* This is called not only when we first attach, but also when the    user types "run" after having attached.  */
end_comment

begin_function
specifier|static
name|void
name|array_create_inferior
parameter_list|(
name|execfile
parameter_list|,
name|args
parameter_list|,
name|env
parameter_list|)
name|char
modifier|*
name|execfile
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
name|char
modifier|*
modifier|*
name|env
decl_stmt|;
block|{
name|int
name|entry_pt
decl_stmt|;
if|if
condition|(
name|args
operator|&&
operator|*
name|args
condition|)
name|error
argument_list|(
literal|"Can't pass arguments to remote MONITOR process"
argument_list|)
expr_stmt|;
if|if
condition|(
name|execfile
operator|==
literal|0
operator|||
name|exec_bfd
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No exec file specified"
argument_list|)
expr_stmt|;
name|entry_pt
operator|=
operator|(
name|int
operator|)
name|bfd_get_start_address
argument_list|(
name|exec_bfd
argument_list|)
expr_stmt|;
comment|/* The "process" (board) is already stopped awaiting our commands, and    the program is already downloaded.  We just set its PC and go.  */
name|clear_proceed_status
argument_list|()
expr_stmt|;
comment|/* Tell wait_for_inferior that we've started a new process.  */
name|init_wait_for_inferior
argument_list|()
expr_stmt|;
comment|/* Set up the "saved terminal modes" of the inferior      based on what modes we are starting it with.  */
name|target_terminal_init
argument_list|()
expr_stmt|;
comment|/* Install inferior's terminal modes.  */
name|target_terminal_inferior
argument_list|()
expr_stmt|;
comment|/* insert_step_breakpoint ();  FIXME, do we need this?  */
comment|/* Let 'er rip... */
name|proceed
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|entry_pt
argument_list|,
name|TARGET_SIGNAL_DEFAULT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * array_open -- open a connection to a remote debugger.  *	NAME is the filename used for communication.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|baudrate
init|=
literal|9600
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|dev_name
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|array_open
parameter_list|(
name|args
parameter_list|,
name|name
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
name|packet
index|[
name|PBUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Use `target %s DEVICE-NAME' to use a serial port, or \n\ `target %s HOST-NAME:PORT-NUMBER' to use a network connection."
argument_list|,
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/*  if (is_open) */
name|array_close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|target_preopen
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|array_ops
argument_list|)
expr_stmt|;
name|tmp_mips_processor_type
operator|=
literal|"lsi33k"
expr_stmt|;
comment|/* change the default from r3051 */
name|mips_set_processor_type_command
argument_list|(
literal|"lsi33k"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|dev_name
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|array_desc
operator|=
name|SERIAL_OPEN
argument_list|(
name|dev_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|array_desc
operator|==
name|NULL
condition|)
name|perror_with_name
argument_list|(
name|dev_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|baud_rate
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|SERIAL_SETBAUDRATE
argument_list|(
name|array_desc
argument_list|,
name|baud_rate
argument_list|)
condition|)
block|{
name|SERIAL_CLOSE
argument_list|(
name|array_desc
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|SERIAL_RAW
argument_list|(
name|array_desc
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|LOG_FILE
argument_list|)
name|log_file
operator|=
name|fopen
argument_list|(
name|LOG_FILE
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|log_file
operator|==
name|NULL
condition|)
name|perror_with_name
argument_list|(
name|LOG_FILE
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|log_file
argument_list|,
literal|"GDB %s (%s"
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|log_file
argument_list|,
literal|" --target %s)\n"
argument_list|,
name|array_ops
operator|.
name|to_shortname
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|log_file
argument_list|,
literal|"Remote target %s connected to %s\n\n"
argument_list|,
name|array_ops
operator|.
name|to_shortname
argument_list|,
name|dev_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* see if the target is alive. For a ROM monitor, we can just try to force the      expect_prompt to print a few times. For the GDB remote protocol, the application      being debugged is sitting at a breakpoint and waiting for GDB to initialize      the connection. We force it to give us an empty packet to see if it's alive.      */
name|debuglogs
argument_list|(
literal|3
argument_list|,
literal|"Trying to ACK the target's debug stub"
argument_list|)
expr_stmt|;
comment|/* unless your are on the new hardware, the old board won't initialize        because the '@' doesn't flush output like it does on the new ROMS.      */
name|printf_monitor
argument_list|(
literal|"@"
argument_list|)
expr_stmt|;
comment|/* ask for the last signal */
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* See if we get a expect_prompt */
ifdef|#
directive|ifdef
name|TEST_ARRAY
comment|/* skip packet for testing */
name|make_gdb_packet
argument_list|(
name|packet
argument_list|,
literal|"?"
argument_list|)
expr_stmt|;
comment|/* ask for a bogus packet */
if|if
condition|(
name|array_send_packet
argument_list|(
name|packet
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Couldn't transmit packet\n"
argument_list|)
expr_stmt|;
name|printf_monitor
argument_list|(
literal|"@\n"
argument_list|)
expr_stmt|;
comment|/* force it to flush stdout */
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* See if we get a expect_prompt */
endif|#
directive|endif
name|push_target
argument_list|(
operator|&
name|array_ops
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"Remote target %s connected to %s\n"
argument_list|,
name|array_ops
operator|.
name|to_shortname
argument_list|,
name|dev_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * array_close -- Close out all files and local state before this  *	target loses control.  */
end_comment

begin_function
specifier|static
name|void
name|array_close
parameter_list|(
name|quitting
parameter_list|)
name|int
name|quitting
decl_stmt|;
block|{
name|SERIAL_CLOSE
argument_list|(
name|array_desc
argument_list|)
expr_stmt|;
name|array_desc
operator|=
name|NULL
expr_stmt|;
name|debuglogs
argument_list|(
literal|1
argument_list|,
literal|"array_close (quitting=%d)"
argument_list|,
name|quitting
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|LOG_FILE
argument_list|)
if|if
condition|(
name|log_file
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|log_file
argument_list|)
condition|)
name|printf_filtered
argument_list|(
literal|"Error writing log file.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|log_file
argument_list|)
operator|!=
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|"Error closing log file.\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*   * array_detach -- terminate the open connection to the remote  *	debugger. Use this when you want to detach and do something  *	else with your gdb.  */
end_comment

begin_function
specifier|static
name|void
name|array_detach
parameter_list|(
name|from_tty
parameter_list|)
name|int
name|from_tty
decl_stmt|;
block|{
name|debuglogs
argument_list|(
literal|1
argument_list|,
literal|"array_detach ()"
argument_list|)
expr_stmt|;
name|pop_target
argument_list|()
expr_stmt|;
comment|/* calls array_close to do the real work */
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"Ending remote %s debugging\n"
argument_list|,
name|target_shortname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * array_attach -- attach GDB to the target.  */
end_comment

begin_function
specifier|static
name|void
name|array_attach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"Starting remote %s debugging\n"
argument_list|,
name|target_shortname
argument_list|)
expr_stmt|;
name|debuglogs
argument_list|(
literal|1
argument_list|,
literal|"array_attach (args=%s)"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|printf_monitor
argument_list|(
literal|"go %x\n"
argument_list|)
expr_stmt|;
comment|/* swallow the echo.  */
name|expect
argument_list|(
literal|"go %x\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * array_resume -- Tell the remote machine to resume.  */
end_comment

begin_function
specifier|static
name|void
name|array_resume
parameter_list|(
name|pid
parameter_list|,
name|step
parameter_list|,
name|sig
parameter_list|)
name|int
name|pid
decl_stmt|,
name|step
decl_stmt|;
name|enum
name|target_signal
name|sig
decl_stmt|;
block|{
name|debuglogs
argument_list|(
literal|1
argument_list|,
literal|"array_resume (step=%d, sig=%d)"
argument_list|,
name|step
argument_list|,
name|sig
argument_list|)
expr_stmt|;
if|if
condition|(
name|step
condition|)
block|{
name|printf_monitor
argument_list|(
literal|"s\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_monitor
argument_list|(
literal|"go\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|TMPBUFSIZ
value|5
end_define

begin_comment
comment|/*  * array_wait -- Wait until the remote machine stops, then return,  *          storing status in status just as `wait' would.  */
end_comment

begin_function
specifier|static
name|int
name|array_wait
parameter_list|(
name|pid
parameter_list|,
name|status
parameter_list|)
name|int
name|pid
decl_stmt|;
name|struct
name|target_waitstatus
modifier|*
name|status
decl_stmt|;
block|{
name|int
name|old_timeout
init|=
name|timeout
decl_stmt|;
name|int
name|result
decl_stmt|,
name|i
decl_stmt|;
name|char
name|c
decl_stmt|;
name|serial_t
name|tty_desc
decl_stmt|;
name|serial_ttystate
name|ttystate
decl_stmt|;
name|debuglogs
argument_list|(
literal|1
argument_list|,
literal|"array_wait (), printing extraneous text."
argument_list|)
expr_stmt|;
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|integer
operator|=
literal|0
expr_stmt|;
name|timeout
operator|=
literal|0
expr_stmt|;
comment|/* Don't time out -- user program is running. */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__GO32__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__WIN32__
argument_list|)
name|tty_desc
operator|=
name|SERIAL_FDOPEN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ttystate
operator|=
name|SERIAL_GET_TTY_STATE
argument_list|(
name|tty_desc
argument_list|)
expr_stmt|;
name|SERIAL_RAW
argument_list|(
name|tty_desc
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
comment|/* poll on the serial port and the keyboard. */
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|c
operator|==
operator|*
operator|(
name|ARRAY_PROMPT
operator|+
name|i
operator|)
condition|)
block|{
if|if
condition|(
operator|++
name|i
operator|>=
name|strlen
argument_list|(
name|ARRAY_PROMPT
argument_list|)
condition|)
block|{
comment|/* matched the prompt */
name|debuglogs
argument_list|(
literal|4
argument_list|,
literal|"array_wait(), got the expect_prompt."
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* not the prompt */
name|i
operator|=
literal|0
expr_stmt|;
block|}
name|fputc_unfiltered
argument_list|(
name|c
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|SERIAL_READCHAR
argument_list|(
name|tty_desc
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|0
condition|)
block|{
name|SERIAL_WRITE
argument_list|(
name|array_desc
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* do this so it looks like there's keyboard echo */
if|if
condition|(
name|c
operator|==
literal|3
condition|)
comment|/* exit on Control-C */
break|break;
if|#
directive|if
literal|0
block|fputc_unfiltered (c, gdb_stdout);       fflush (stdout);
endif|#
directive|endif
block|}
block|}
name|SERIAL_SET_TTY_STATE
argument_list|(
name|tty_desc
argument_list|,
name|ttystate
argument_list|)
expr_stmt|;
else|#
directive|else
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|debuglogs
argument_list|(
literal|4
argument_list|,
literal|"array_wait(), got the expect_prompt."
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
name|timeout
operator|=
name|old_timeout
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * array_fetch_registers -- read the remote registers into the  *	block regs.  */
end_comment

begin_function
specifier|static
name|void
name|array_fetch_registers
parameter_list|(
name|ignored
parameter_list|)
name|int
name|ignored
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|char
name|packet
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|char
name|regs
index|[
name|REGISTER_BYTES
index|]
decl_stmt|;
name|debuglogs
argument_list|(
literal|1
argument_list|,
literal|"array_fetch_registers (ignored=%d)\n"
argument_list|,
name|ignored
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|packet
argument_list|,
literal|0
argument_list|,
name|PBUFSIZ
argument_list|)
expr_stmt|;
comment|/* Unimplemented registers read as all bits zero.  */
name|memset
argument_list|(
name|regs
argument_list|,
literal|0
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
name|make_gdb_packet
argument_list|(
name|packet
argument_list|,
literal|"g"
argument_list|)
expr_stmt|;
if|if
condition|(
name|array_send_packet
argument_list|(
name|packet
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Couldn't transmit packet\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|array_get_packet
argument_list|(
name|packet
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Couldn't receive packet\n"
argument_list|)
expr_stmt|;
comment|/* FIXME: read bytes from packet */
name|debuglogs
argument_list|(
literal|4
argument_list|,
literal|"array_fetch_registers: Got a \"%s\" back\n"
argument_list|,
name|packet
argument_list|)
expr_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<=
name|PC_REGNUM
operator|+
literal|4
condition|;
name|regno
operator|++
control|)
block|{
comment|/* supply register stores in target byte order, so swap here */
comment|/* FIXME: convert from ASCII hex to raw bytes */
name|i
operator|=
name|ascii2hexword
argument_list|(
name|packet
operator|+
operator|(
name|regno
operator|*
literal|8
operator|)
argument_list|)
expr_stmt|;
name|debuglogs
argument_list|(
literal|5
argument_list|,
literal|"Adding register %d = %x\n"
argument_list|,
name|regno
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|SWAP_TARGET_AND_HOST
argument_list|(
operator|&
name|i
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*   * This is unused by targets like this one that use a  * protocol based on GDB's remote protocol.  */
end_comment

begin_function
specifier|static
name|void
name|array_fetch_register
parameter_list|(
name|ignored
parameter_list|)
name|int
name|ignored
decl_stmt|;
block|{
name|array_fetch_registers
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get all the registers from the targets. They come back in a large array.  */
end_comment

begin_function
specifier|static
name|void
name|array_store_registers
parameter_list|(
name|ignored
parameter_list|)
name|int
name|ignored
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
name|unsigned
name|long
name|i
decl_stmt|;
name|char
name|packet
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|char
name|num
index|[
literal|9
index|]
decl_stmt|;
name|debuglogs
argument_list|(
literal|1
argument_list|,
literal|"array_store_registers()"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|packet
argument_list|,
literal|0
argument_list|,
name|PBUFSIZ
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|PBUFSIZ
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'G'
expr_stmt|;
comment|/* Unimplemented registers read as all bits zero.  */
comment|/* FIXME: read bytes from packet */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
literal|41
condition|;
name|regno
operator|++
control|)
block|{
comment|/* FIXME */
comment|/* supply register stores in target byte order, so swap here */
comment|/* FIXME: convert from ASCII hex to raw bytes */
name|i
operator|=
operator|(
name|unsigned
name|long
operator|)
name|read_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|hexword2ascii
argument_list|(
name|num
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|buf
operator|+
operator|(
name|regno
operator|*
literal|8
operator|)
operator|+
literal|1
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
operator|*
operator|(
name|buf
operator|+
operator|(
name|regno
operator|*
literal|8
operator|)
operator|+
literal|2
operator|)
operator|=
literal|0
expr_stmt|;
name|make_gdb_packet
argument_list|(
name|packet
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|array_send_packet
argument_list|(
name|packet
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Couldn't transmit packet\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|array_get_packet
argument_list|(
name|packet
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Couldn't receive packet\n"
argument_list|)
expr_stmt|;
name|registers_changed
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * This is unused by targets like this one that use a  * protocol based on GDB's remote protocol.  */
end_comment

begin_function
specifier|static
name|void
name|array_store_register
parameter_list|(
name|ignored
parameter_list|)
name|int
name|ignored
decl_stmt|;
block|{
name|array_store_registers
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get ready to modify the registers array.  On machines which store    individual registers, this doesn't need to do anything.  On machines    which store all the registers in one fell swoop, this makes sure    that registers contains all the registers from the program being    debugged.  */
end_comment

begin_function
specifier|static
name|void
name|array_prepare_to_store
parameter_list|()
block|{
comment|/* Do nothing, since we can store individual regs */
block|}
end_function

begin_function
specifier|static
name|void
name|array_files_info
parameter_list|()
block|{
name|printf
argument_list|(
literal|"\tAttached to %s at %d baud.\n"
argument_list|,
name|dev_name
argument_list|,
name|baudrate
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * array_write_inferior_memory -- Copy LEN bytes of data from debugger  *	memory at MYADDR to inferior's memory at MEMADDR.  Returns length moved.  */
end_comment

begin_function
specifier|static
name|int
name|array_write_inferior_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|unsigned
name|long
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|char
name|packet
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|char
name|num
index|[
literal|9
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|debuglogs
argument_list|(
literal|1
argument_list|,
literal|"array_write_inferior_memory (memaddr=0x%x, myaddr=0x%x, len=%d)"
argument_list|,
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
literal|'\0'
argument_list|,
name|PBUFSIZ
argument_list|)
expr_stmt|;
comment|/* this also sets the string terminator */
name|p
operator|=
name|buf
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'M'
expr_stmt|;
comment|/* The command to write memory */
name|hexword2ascii
argument_list|(
name|num
argument_list|,
name|memaddr
argument_list|)
expr_stmt|;
comment|/* convert the address */
name|strcpy
argument_list|(
name|p
argument_list|,
name|num
argument_list|)
expr_stmt|;
comment|/* copy the address */
name|p
operator|+=
literal|8
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|','
expr_stmt|;
comment|/* add comma delimeter */
name|hexword2ascii
argument_list|(
name|num
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Get the length as a 4 digit number */
operator|*
name|p
operator|++
operator|=
name|num
index|[
literal|4
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|num
index|[
literal|5
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|num
index|[
literal|6
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|num
index|[
literal|7
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|':'
expr_stmt|;
comment|/* add the colon delimeter */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
name|j
operator|++
control|)
block|{
comment|/* copy the data in after converting it */
operator|*
name|p
operator|++
operator|=
name|tohex
argument_list|(
operator|(
name|myaddr
index|[
name|j
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|tohex
argument_list|(
name|myaddr
index|[
name|j
index|]
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
name|make_gdb_packet
argument_list|(
name|packet
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|array_send_packet
argument_list|(
name|packet
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Couldn't transmit packet\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|array_get_packet
argument_list|(
name|packet
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Couldn't receive packet\n"
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/*  * array_read_inferior_memory -- read LEN bytes from inferior memory  *	at MEMADDR.  Put the result at debugger address MYADDR.  Returns  *	length moved.  */
end_comment

begin_function
specifier|static
name|int
name|array_read_inferior_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|j
decl_stmt|;
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|char
name|packet
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|int
name|count
decl_stmt|;
comment|/* Number of bytes read so far.  */
name|unsigned
name|long
name|startaddr
decl_stmt|;
comment|/* Starting address of this pass.  */
name|int
name|len_this_pass
decl_stmt|;
comment|/* Number of bytes to read in this pass.  */
name|debuglogs
argument_list|(
literal|1
argument_list|,
literal|"array_read_inferior_memory (memaddr=0x%x, myaddr=0x%x, len=%d)"
argument_list|,
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Note that this code works correctly if startaddr is just less      than UINT_MAX (well, really CORE_ADDR_MAX if there was such a      thing).  That is, something like      array_read_bytes (CORE_ADDR_MAX - 4, foo, 4)      works--it never adds len To memaddr and gets 0.  */
comment|/* However, something like      array_read_bytes (CORE_ADDR_MAX - 3, foo, 4)      doesn't need to work.  Detect it and give up if there's an attempt      to do that.  */
if|if
condition|(
operator|(
operator|(
name|memaddr
operator|-
literal|1
operator|)
operator|+
name|len
operator|)
operator|<
name|memaddr
condition|)
block|{
name|errno
operator|=
name|EIO
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|count
operator|=
literal|0
operator|,
name|startaddr
operator|=
name|memaddr
init|;
name|count
operator|<
name|len
condition|;
name|startaddr
operator|+=
name|len_this_pass
control|)
block|{
comment|/* Try to align to 16 byte boundry (why?) */
name|len_this_pass
operator|=
literal|16
expr_stmt|;
if|if
condition|(
operator|(
name|startaddr
operator|%
literal|16
operator|)
operator|!=
literal|0
condition|)
block|{
name|len_this_pass
operator|-=
name|startaddr
operator|%
literal|16
expr_stmt|;
block|}
comment|/* Only transfer bytes we need */
if|if
condition|(
name|len_this_pass
operator|>
operator|(
name|len
operator|-
name|count
operator|)
condition|)
block|{
name|len_this_pass
operator|=
operator|(
name|len
operator|-
name|count
operator|)
expr_stmt|;
block|}
comment|/* Fetch the bytes */
name|debuglogs
argument_list|(
literal|3
argument_list|,
literal|"read %d bytes from inferior address %x"
argument_list|,
name|len_this_pass
argument_list|,
name|startaddr
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"m%08x,%04x"
argument_list|,
name|startaddr
argument_list|,
name|len_this_pass
argument_list|)
expr_stmt|;
name|make_gdb_packet
argument_list|(
name|packet
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|array_send_packet
argument_list|(
name|packet
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Couldn't transmit packet\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|array_get_packet
argument_list|(
name|packet
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Couldn't receive packet\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|packet
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Got no data in the GDB packet\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Pick packet apart and xfer bytes to myaddr */
name|debuglogs
argument_list|(
literal|4
argument_list|,
literal|"array_read_inferior_memory: Got a \"%s\" back\n"
argument_list|,
name|packet
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len_this_pass
condition|;
name|j
operator|++
control|)
block|{
comment|/* extract the byte values */
name|myaddr
index|[
name|count
operator|++
index|]
operator|=
name|from_hex
argument_list|(
operator|*
operator|(
name|packet
operator|+
operator|(
name|j
operator|*
literal|2
operator|)
operator|)
argument_list|)
operator|*
literal|16
operator|+
name|from_hex
argument_list|(
operator|*
operator|(
name|packet
operator|+
operator|(
name|j
operator|*
literal|2
operator|)
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|debuglogs
argument_list|(
literal|5
argument_list|,
literal|"myaddr[%d] set to %x\n"
argument_list|,
name|count
operator|-
literal|1
argument_list|,
name|myaddr
index|[
name|count
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/* FIXME-someday!  merge these two.  */
end_comment

begin_function
specifier|static
name|int
name|array_xfer_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|write
parameter_list|,
name|target
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|write
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
comment|/* ignored */
block|{
if|if
condition|(
name|write
condition|)
return|return
name|array_write_inferior_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
return|;
else|else
return|return
name|array_read_inferior_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|array_kill
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
return|return;
comment|/* ignore attempts to kill target system */
block|}
end_function

begin_comment
comment|/* Clean up when a program exits.    The program actually lives on in the remote processor's RAM, and may be    run again without a download.  Don't leave it full of breakpoint    instructions.  */
end_comment

begin_function
specifier|static
name|void
name|array_mourn_inferior
parameter_list|()
block|{
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|generic_mourn_inferior
argument_list|()
expr_stmt|;
comment|/* Do all the proper things now */
block|}
end_function

begin_define
define|#
directive|define
name|MAX_ARRAY_BREAKPOINTS
value|16
end_define

begin_decl_stmt
specifier|extern
name|int
name|memory_breakpoint_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|breakaddr
index|[
name|MAX_ARRAY_BREAKPOINTS
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * array_insert_breakpoint -- add a breakpoint  */
end_comment

begin_function
specifier|static
name|int
name|array_insert_breakpoint
parameter_list|(
name|addr
parameter_list|,
name|shadow
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|shadow
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|debuglogs
argument_list|(
literal|1
argument_list|,
literal|"array_insert_breakpoint() addr = 0x%x"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|MAX_ARRAY_BREAKPOINTS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|breakaddr
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|breakaddr
index|[
name|i
index|]
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
operator|>
literal|4
condition|)
name|printf
argument_list|(
literal|"Breakpoint at %x\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|array_read_inferior_memory
argument_list|(
name|addr
argument_list|,
name|shadow
argument_list|,
name|memory_breakpoint_size
argument_list|)
expr_stmt|;
name|printf_monitor
argument_list|(
literal|"b 0x%x\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Too many breakpoints (> 16) for monitor\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * _remove_breakpoint -- Tell the monitor to remove a breakpoint  */
end_comment

begin_function
specifier|static
name|int
name|array_remove_breakpoint
parameter_list|(
name|addr
parameter_list|,
name|shadow
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|shadow
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|debuglogs
argument_list|(
literal|1
argument_list|,
literal|"array_remove_breakpoint() addr = 0x%x"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_ARRAY_BREAKPOINTS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|breakaddr
index|[
name|i
index|]
operator|==
name|addr
condition|)
block|{
name|breakaddr
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* some monitors remove breakpoints based on the address */
name|printf_monitor
argument_list|(
literal|"bd %x\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't find breakpoint associated with 0x%x\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|array_stop
parameter_list|()
block|{
name|debuglogs
argument_list|(
literal|1
argument_list|,
literal|"array_stop()"
argument_list|)
expr_stmt|;
name|printf_monitor
argument_list|(
literal|"\003"
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * array_command -- put a command string, in args, out to MONITOR.  *	Output from MONITOR is placed on the users terminal until the  *	expect_prompt is seen. FIXME  */
end_comment

begin_function
specifier|static
name|void
name|monitor_command
parameter_list|(
name|args
parameter_list|,
name|fromtty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|fromtty
decl_stmt|;
block|{
name|debuglogs
argument_list|(
literal|1
argument_list|,
literal|"monitor_command (args=%s)"
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|array_desc
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"monitor target not open."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
name|error
argument_list|(
literal|"Missing command."
argument_list|)
expr_stmt|;
name|printf_monitor
argument_list|(
literal|"%s\n"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * make_gdb_packet -- make a GDB packet. The data is always ASCII.  *	 A debug packet whose contents are<data>  *	 is encapsulated for transmission in the form:  *  *		$<data> # CSUM1 CSUM2  *  *<data> must be ASCII alphanumeric and cannot include characters  *       '$' or '#'.  If<data> starts with two characters followed by  *       ':', then the existing stubs interpret this as a sequence number.  *  *       CSUM1 and CSUM2 are ascii hex representation of an 8-bit   *       checksum of<data>, the most significant nibble is sent first.  *       the hex digits 0-9,a-f are used.  *  */
end_comment

begin_function
specifier|static
name|void
name|make_gdb_packet
parameter_list|(
name|buf
parameter_list|,
name|data
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|,
decl|*
name|data
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|csum
init|=
literal|0
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|debuglogs
argument_list|(
literal|3
argument_list|,
literal|"make_gdb_packet(%s)\n"
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|cnt
operator|=
name|strlen
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|>
name|PBUFSIZ
condition|)
name|error
argument_list|(
literal|"make_gdb_packet(): to much data\n"
argument_list|)
expr_stmt|;
comment|/* start with the packet header */
name|p
operator|=
name|buf
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'$'
expr_stmt|;
comment|/* calculate the checksum */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|csum
operator|+=
name|data
index|[
name|i
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|data
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* terminate the data with a '#' */
operator|*
name|p
operator|++
operator|=
literal|'#'
expr_stmt|;
comment|/* add the checksum as two ascii digits */
operator|*
name|p
operator|++
operator|=
name|tohex
argument_list|(
operator|(
name|csum
operator|>>
literal|4
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|tohex
argument_list|(
name|csum
operator|&
literal|0xf
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|0x0
expr_stmt|;
comment|/* Null terminator on string */
block|}
end_block

begin_comment
comment|/*  * array_send_packet -- send a GDB packet to the target with error handling. We  *		get a '+' (ACK) back if the packet is received and the checksum  *		matches. Otherwise a '-' (NAK) is returned. It returns a 1 for a  *		successful transmition, or a 0 for a failure.  */
end_comment

begin_function
specifier|static
name|int
name|array_send_packet
parameter_list|(
name|packet
parameter_list|)
name|char
modifier|*
name|packet
decl_stmt|;
block|{
name|int
name|c
decl_stmt|,
name|retries
decl_stmt|,
name|i
decl_stmt|;
name|char
name|junk
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|retries
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|/* scan the packet to make sure it only contains valid characters.      this may sound silly, but sometimes a garbled packet will hang      the target board. We scan the whole thing, then print the error      message.      */
block|for (i = 0; i< strlen(packet); i++) {     debuglogs (5, "array_send_packet(): Scanning \'%c\'\n", packet[i]);
comment|/* legit hex numbers or command */
block|if ((isxdigit(packet[i])) || (isalpha(packet[i])))       continue;     switch (packet[i]) {     case '+':
comment|/* ACK */
block|case '-':
comment|/* NAK */
block|case '#':
comment|/* end of packet */
block|case '$':
comment|/* start of packet */
block|continue;     default:
comment|/* bogus character */
block|retries++;       debuglogs (4, "array_send_packet(): Found a non-ascii digit \'%c\' in the packet.\n", packet[i]);     }   }
endif|#
directive|endif
if|if
condition|(
name|retries
operator|>
literal|0
condition|)
name|error
argument_list|(
literal|"Can't send packet, found %d non-ascii characters"
argument_list|,
name|retries
argument_list|)
expr_stmt|;
comment|/* ok, try to send the packet */
name|retries
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|retries
operator|++
operator|<=
literal|10
condition|)
block|{
name|printf_monitor
argument_list|(
literal|"%s"
argument_list|,
name|packet
argument_list|)
expr_stmt|;
comment|/* read until either a timeout occurs (-2) or '+' is read */
while|while
condition|(
name|retries
operator|<=
literal|10
condition|)
block|{
name|c
operator|=
name|readchar
argument_list|(
operator|-
name|timeout
argument_list|)
expr_stmt|;
name|debuglogs
argument_list|(
literal|3
argument_list|,
literal|"Reading a GDB protocol packet... Got a '%c'\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'+'
case|:
name|debuglogs
argument_list|(
literal|3
argument_list|,
literal|"Got Ack\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|SERIAL_TIMEOUT
case|:
name|debuglogs
argument_list|(
literal|3
argument_list|,
literal|"Timed out reading serial port\n"
argument_list|)
expr_stmt|;
name|printf_monitor
argument_list|(
literal|"@"
argument_list|)
expr_stmt|;
comment|/* resync with the monitor */
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* See if we get a expect_prompt */
break|break;
comment|/* Retransmit buffer */
case|case
literal|'-'
case|:
name|debuglogs
argument_list|(
literal|3
argument_list|,
literal|"Got NAK\n"
argument_list|)
expr_stmt|;
name|printf_monitor
argument_list|(
literal|"@"
argument_list|)
expr_stmt|;
comment|/* resync with the monitor */
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* See if we get a expect_prompt */
break|break;
case|case
literal|'$'
case|:
comment|/* it's probably an old response, or the echo of our command. 	 * just gobble up the packet and ignore it. 	 */
name|debuglogs
argument_list|(
literal|3
argument_list|,
literal|"Got a junk packet\n"
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|c
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
name|junk
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'#'
condition|)
do|;
name|c
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
name|junk
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
name|junk
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|junk
index|[
name|i
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
name|debuglogs
argument_list|(
literal|3
argument_list|,
literal|"Reading a junk packet, got a \"%s\"\n"
argument_list|,
name|junk
argument_list|)
expr_stmt|;
continue|continue;
comment|/* Now, go look for next packet */
default|default:
continue|continue;
block|}
name|retries
operator|++
expr_stmt|;
name|debuglogs
argument_list|(
literal|3
argument_list|,
literal|"Retransmitting packet \"%s\"\n"
argument_list|,
name|packet
argument_list|)
expr_stmt|;
break|break;
comment|/* Here to retransmit */
block|}
block|}
comment|/* outer while */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * array_get_packet -- get a GDB packet from the target. Basically we read till we  *		see a '#', then check the checksum. It returns a 1 if it's gotten a  *		packet, or a 0 it the packet wasn't transmitted correctly.  */
end_comment

begin_function
specifier|static
name|int
name|array_get_packet
parameter_list|(
name|packet
parameter_list|)
name|char
modifier|*
name|packet
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|int
name|retries
decl_stmt|;
name|unsigned
name|char
name|csum
decl_stmt|;
name|unsigned
name|char
name|pktcsum
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|;
name|csum
operator|=
literal|0
expr_stmt|;
name|bp
operator|=
name|packet
expr_stmt|;
name|memset
argument_list|(
name|packet
argument_list|,
literal|1
argument_list|,
name|PBUFSIZ
argument_list|)
expr_stmt|;
name|retries
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|retries
operator|<=
literal|10
condition|)
block|{
do|do
block|{
name|c
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|SERIAL_TIMEOUT
condition|)
block|{
name|debuglogs
argument_list|(
literal|3
argument_list|,
literal|"array_get_packet: got time out from serial port.\n"
argument_list|)
expr_stmt|;
block|}
name|debuglogs
argument_list|(
literal|3
argument_list|,
literal|"Waiting for a '$', got a %c\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|'$'
condition|)
do|;
name|retries
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|retries
operator|<=
literal|10
condition|)
block|{
name|c
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
name|debuglogs
argument_list|(
literal|3
argument_list|,
literal|"array_get_packet: got a '%c'\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|SERIAL_TIMEOUT
case|:
name|debuglogs
argument_list|(
literal|3
argument_list|,
literal|"Timeout in mid-packet, retrying\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|'$'
case|:
name|debuglogs
argument_list|(
literal|3
argument_list|,
literal|"Saw new packet start in middle of old one\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* Start a new packet, count retries */
case|case
literal|'#'
case|:
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
name|pktcsum
operator|=
name|from_hex
argument_list|(
name|readchar
argument_list|(
name|timeout
argument_list|)
argument_list|)
operator|<<
literal|4
expr_stmt|;
name|pktcsum
operator||=
name|from_hex
argument_list|(
name|readchar
argument_list|(
name|timeout
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|csum
operator|==
literal|0
condition|)
name|debuglogs
argument_list|(
literal|3
argument_list|,
literal|"\nGDB packet checksum zero, must be a bogus packet\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|csum
operator|==
name|pktcsum
condition|)
block|{
name|debuglogs
argument_list|(
literal|3
argument_list|,
literal|"\nGDB packet checksum correct, packet data is \"%s\",\n"
argument_list|,
name|packet
argument_list|)
expr_stmt|;
name|printf_monitor
argument_list|(
literal|"@"
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|debuglogs
argument_list|(
literal|3
argument_list|,
literal|"Bad checksum, sentsum=0x%x, csum=0x%x\n"
argument_list|,
name|pktcsum
argument_list|,
name|csum
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|'*'
case|:
comment|/* Run length encoding */
name|debuglogs
argument_list|(
literal|5
argument_list|,
literal|"Run length encoding in packet\n"
argument_list|)
expr_stmt|;
name|csum
operator|+=
name|c
expr_stmt|;
name|c
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
name|csum
operator|+=
name|c
expr_stmt|;
name|c
operator|=
name|c
operator|-
literal|' '
operator|+
literal|3
expr_stmt|;
comment|/* Compute repeat count */
if|if
condition|(
name|c
operator|>
literal|0
operator|&&
name|c
operator|<
literal|255
operator|&&
name|bp
operator|+
name|c
operator|-
literal|1
operator|<
name|packet
operator|+
name|PBUFSIZ
operator|-
literal|1
condition|)
block|{
name|memset
argument_list|(
name|bp
argument_list|,
operator|*
operator|(
name|bp
operator|-
literal|1
operator|)
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|c
expr_stmt|;
continue|continue;
block|}
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Repeat count %d too large for buffer.\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
default|default:
if|if
condition|(
operator|(
operator|!
name|isxdigit
argument_list|(
name|c
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|ispunct
argument_list|(
name|c
argument_list|)
operator|)
condition|)
name|debuglogs
argument_list|(
literal|4
argument_list|,
literal|"Got a non-ascii digit \'%c\'.\\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|<
name|packet
operator|+
name|PBUFSIZ
operator|-
literal|1
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
name|csum
operator|+=
name|c
expr_stmt|;
continue|continue;
block|}
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"Remote packet too long.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * ascii2hexword -- convert an ascii number represented by 8 digits to a hex value.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|ascii2hexword
parameter_list|(
name|mem
parameter_list|)
name|unsigned
name|char
modifier|*
name|mem
decl_stmt|;
block|{
name|unsigned
name|long
name|val
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|9
index|]
decl_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|val
operator|<<=
literal|4
expr_stmt|;
if|if
condition|(
name|mem
index|[
name|i
index|]
operator|>=
literal|'A'
operator|&&
name|mem
index|[
name|i
index|]
operator|<=
literal|'F'
condition|)
name|val
operator|=
name|val
operator|+
name|mem
index|[
name|i
index|]
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
if|if
condition|(
name|mem
index|[
name|i
index|]
operator|>=
literal|'a'
operator|&&
name|mem
index|[
name|i
index|]
operator|<=
literal|'f'
condition|)
name|val
operator|=
name|val
operator|+
name|mem
index|[
name|i
index|]
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
if|if
condition|(
name|mem
index|[
name|i
index|]
operator|>=
literal|'0'
operator|&&
name|mem
index|[
name|i
index|]
operator|<=
literal|'9'
condition|)
name|val
operator|=
name|val
operator|+
name|mem
index|[
name|i
index|]
operator|-
literal|'0'
expr_stmt|;
name|buf
index|[
name|i
index|]
operator|=
name|mem
index|[
name|i
index|]
expr_stmt|;
block|}
name|buf
index|[
literal|8
index|]
operator|=
literal|'\0'
expr_stmt|;
name|debuglogs
argument_list|(
literal|4
argument_list|,
literal|"ascii2hexword() got a 0x%x from %s(%x).\n"
argument_list|,
name|val
argument_list|,
name|buf
argument_list|,
name|mem
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/*  * ascii2hexword -- convert a hex value to an ascii number represented by 8  *	digits.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|hexword2ascii
parameter_list|(
name|mem
parameter_list|,
name|num
parameter_list|)
name|unsigned
name|char
modifier|*
name|mem
decl_stmt|;
name|unsigned
name|long
name|num
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|ch
decl_stmt|;
name|debuglogs
argument_list|(
literal|4
argument_list|,
literal|"hexword2ascii() converting %x "
argument_list|,
name|num
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|7
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|mem
index|[
name|i
index|]
operator|=
name|tohex
argument_list|(
operator|(
name|num
operator|>>
literal|4
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
name|mem
index|[
name|i
index|]
operator|=
name|tohex
argument_list|(
name|num
operator|&
literal|0xf
argument_list|)
expr_stmt|;
name|num
operator|=
name|num
operator|>>
literal|4
expr_stmt|;
block|}
name|mem
index|[
literal|8
index|]
operator|=
literal|'\0'
expr_stmt|;
name|debuglogs
argument_list|(
literal|4
argument_list|,
literal|"\tto a %s"
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert hex digit A to a number.  */
end_comment

begin_function
specifier|static
name|int
name|from_hex
parameter_list|(
name|a
parameter_list|)
name|int
name|a
decl_stmt|;
block|{
if|if
condition|(
name|a
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|debuglogs
argument_list|(
literal|4
argument_list|,
literal|"from_hex got a 0x%x(%c)\n"
argument_list|,
name|a
argument_list|,
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|>=
literal|'0'
operator|&&
name|a
operator|<=
literal|'9'
condition|)
return|return
name|a
operator|-
literal|'0'
return|;
if|if
condition|(
name|a
operator|>=
literal|'a'
operator|&&
name|a
operator|<=
literal|'f'
condition|)
return|return
name|a
operator|-
literal|'a'
operator|+
literal|10
return|;
if|if
condition|(
name|a
operator|>=
literal|'A'
operator|&&
name|a
operator|<=
literal|'F'
condition|)
return|return
name|a
operator|-
literal|'A'
operator|+
literal|10
return|;
else|else
block|{
name|error
argument_list|(
literal|"Reply contains invalid hex digit 0x%x"
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Convert number NIB to a hex digit.  */
end_comment

begin_function
specifier|static
name|int
name|tohex
parameter_list|(
name|nib
parameter_list|)
name|int
name|nib
decl_stmt|;
block|{
if|if
condition|(
name|nib
operator|<
literal|10
condition|)
return|return
literal|'0'
operator|+
name|nib
return|;
else|else
return|return
literal|'a'
operator|+
name|nib
operator|-
literal|10
return|;
block|}
end_function

begin_comment
comment|/*  * _initialize_remote_monitors -- setup a few addtitional commands that  *		are usually only used by monitors.  */
end_comment

begin_function
name|void
name|_initialize_remote_monitors
parameter_list|()
block|{
comment|/* generic monitor command */
name|add_com
argument_list|(
literal|"monitor"
argument_list|,
name|class_obscure
argument_list|,
name|monitor_command
argument_list|,
literal|"Send a command to the debug monitor."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * _initialize_array -- do any special init stuff for the target.  */
end_comment

begin_function
name|void
name|_initialize_array
parameter_list|()
block|{
name|add_target
argument_list|(
operator|&
name|array_ops
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

