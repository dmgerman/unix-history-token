begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Basic C++ demangling support for GDB.    Copyright 1991, 1992, 1996, 1999 Free Software Foundation, Inc.    Written by Fred Fish at Cygnus Support.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/*  This file contains support code for C++ demangling that is common    to a styles of demangling, and GDB specific. */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_comment
comment|/* Select the default C++ demangling style to use.  The default is "auto",    which allows gdb to attempt to pick an appropriate demangling style for    the executable it has loaded.  It can be set to a specific style ("gnu",    "lucid", "arm", "hp", etc.) in which case gdb will never attempt to do auto    selection of the style unless you do an explicit "set demangle auto".    To select one of these as the default, set DEFAULT_DEMANGLING_STYLE in    the appropriate target configuration file. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DEFAULT_DEMANGLING_STYLE
end_ifndef

begin_define
define|#
directive|define
name|DEFAULT_DEMANGLING_STYLE
value|AUTO_DEMANGLING_STYLE_STRING
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* String name for the current demangling style.  Set by the    "set demangle-style" command, printed as part of the output by the    "show demangle-style" command. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|current_demangling_style_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of supported demangling styles.  Contains the name of the style as    seen by the user, and the enum value that corresponds to that style. */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
name|demangler
block|{
name|char
modifier|*
name|demangling_style_name
decl_stmt|;
name|enum
name|demangling_styles
name|demangling_style
decl_stmt|;
name|char
modifier|*
name|demangling_style_doc
decl_stmt|;
block|}
name|demanglers
index|[]
init|=
block|{
block|{
name|AUTO_DEMANGLING_STYLE_STRING
block|,
name|auto_demangling
block|,
literal|"Automatic selection based on executable"
block|}
block|,
block|{
name|GNU_DEMANGLING_STYLE_STRING
block|,
name|gnu_demangling
block|,
literal|"GNU (g++) style demangling"
block|}
block|,
block|{
name|LUCID_DEMANGLING_STYLE_STRING
block|,
name|lucid_demangling
block|,
literal|"Lucid (lcc) style demangling"
block|}
block|,
block|{
name|ARM_DEMANGLING_STYLE_STRING
block|,
name|arm_demangling
block|,
literal|"ARM style demangling"
block|}
block|,
if|#
directive|if
literal|0
comment|/* XXX remove when binutils 2.9.2 is imported */
block|{     HP_DEMANGLING_STYLE_STRING,       hp_demangling,       "HP (aCC) style demangling"   }   ,   {     EDG_DEMANGLING_STYLE_STRING,       edg_demangling,       "EDG style demangling"   }   ,
endif|#
directive|endif
block|{
name|NULL
block|,
name|unknown_demangling
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|set_demangling_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|cmd_list_element
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set current demangling style.  Called by the "set demangle-style"    command after it has updated the current_demangling_style_string to    match what the user has entered.     If the user has entered a string that matches a known demangling style    name in the demanglers[] array then just leave the string alone and update    the current_demangling_style enum value to match.     If the user has entered a string that doesn't match, including an empty    string, then print a list of the currently known styles and restore    the current_demangling_style_string to match the current_demangling_style    enum value.     Note:  Assumes that current_demangling_style_string always points to    a malloc'd string, even if it is a null-string. */
end_comment

begin_function
specifier|static
name|void
name|set_demangling_command
parameter_list|(
name|ignore
parameter_list|,
name|from_tty
parameter_list|,
name|c
parameter_list|)
name|char
modifier|*
name|ignore
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
block|{
specifier|const
name|struct
name|demangler
modifier|*
name|dem
decl_stmt|;
comment|/*  First just try to match whatever style name the user supplied with      one of the known ones.  Don't bother special casing for an empty      name, we just treat it as any other style name that doesn't match.      If we match, update the current demangling style enum. */
for|for
control|(
name|dem
operator|=
name|demanglers
init|;
name|dem
operator|->
name|demangling_style_name
operator|!=
name|NULL
condition|;
name|dem
operator|++
control|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|current_demangling_style_string
argument_list|,
name|dem
operator|->
name|demangling_style_name
argument_list|)
condition|)
block|{
name|current_demangling_style
operator|=
name|dem
operator|->
name|demangling_style
expr_stmt|;
break|break;
block|}
block|}
comment|/* Check to see if we found a match.  If not, gripe about any non-empty      style name and supply a list of valid ones.  FIXME:  This should      probably be done with some sort of completion and with help. */
if|if
condition|(
name|dem
operator|->
name|demangling_style_name
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|current_demangling_style_string
operator|!=
literal|'\0'
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"Unknown demangling style `%s'.\n"
argument_list|,
name|current_demangling_style_string
argument_list|)
expr_stmt|;
block|}
name|printf_unfiltered
argument_list|(
literal|"The currently understood settings are:\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|dem
operator|=
name|demanglers
init|;
name|dem
operator|->
name|demangling_style_name
operator|!=
name|NULL
condition|;
name|dem
operator|++
control|)
block|{
name|printf_unfiltered
argument_list|(
literal|"%-10s %s\n"
argument_list|,
name|dem
operator|->
name|demangling_style_name
argument_list|,
name|dem
operator|->
name|demangling_style_doc
argument_list|)
expr_stmt|;
if|if
condition|(
name|dem
operator|->
name|demangling_style
operator|==
name|current_demangling_style
condition|)
block|{
name|free
argument_list|(
name|current_demangling_style_string
argument_list|)
expr_stmt|;
name|current_demangling_style_string
operator|=
name|savestring
argument_list|(
name|dem
operator|->
name|demangling_style_name
argument_list|,
name|strlen
argument_list|(
name|dem
operator|->
name|demangling_style_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|current_demangling_style
operator|==
name|unknown_demangling
condition|)
block|{
comment|/* This can happen during initialization if gdb is compiled with 	     a DEMANGLING_STYLE value that is unknown, so pick the first 	     one as the default. */
name|current_demangling_style
operator|=
name|demanglers
index|[
literal|0
index|]
operator|.
name|demangling_style
expr_stmt|;
name|current_demangling_style_string
operator|=
name|savestring
argument_list|(
name|demanglers
index|[
literal|0
index|]
operator|.
name|demangling_style_name
argument_list|,
name|strlen
argument_list|(
name|demanglers
index|[
literal|0
index|]
operator|.
name|demangling_style_name
argument_list|)
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"`%s' style demangling chosen as the default.\n"
argument_list|,
name|current_demangling_style_string
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Fake a "set demangle-style" command. */
end_comment

begin_function
name|void
name|set_demangling_style
parameter_list|(
name|style
parameter_list|)
name|char
modifier|*
name|style
decl_stmt|;
block|{
if|if
condition|(
name|current_demangling_style_string
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|current_demangling_style_string
argument_list|)
expr_stmt|;
block|}
name|current_demangling_style_string
operator|=
name|savestring
argument_list|(
name|style
argument_list|,
name|strlen
argument_list|(
name|style
argument_list|)
argument_list|)
expr_stmt|;
name|set_demangling_command
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* In order to allow a single demangler executable to demangle strings    using various common values of CPLUS_MARKER, as well as any specific    one set at compile time, we maintain a string containing all the    commonly used ones, and check to see if the marker we are looking for    is in that string.  CPLUS_MARKER is usually '$' on systems where the    assembler can deal with that.  Where the assembler can't, it's usually    '.' (but on many systems '.' is used for other things).  We put the    current defined CPLUS_MARKER first (which defaults to '$'), followed    by the next most common value, followed by an explicit '$' in case    the value of CPLUS_MARKER is not '$'.     We could avoid this if we could just get g++ to tell us what the actual    cplus marker character is as part of the debug information, perhaps by    ensuring that it is the character that terminates the gcc<n>_compiled    marker symbol (FIXME). */
end_comment

begin_decl_stmt
specifier|static
name|char
name|cplus_markers
index|[]
init|=
block|{
name|CPLUS_MARKER
block|,
literal|'.'
block|,
literal|'$'
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|is_cplus_marker
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
return|return
name|c
operator|&&
name|strchr
argument_list|(
name|cplus_markers
argument_list|,
name|c
argument_list|)
operator|!=
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|_initialize_demangler
parameter_list|()
block|{
name|struct
name|cmd_list_element
modifier|*
name|set
decl_stmt|,
modifier|*
name|show
decl_stmt|;
name|set
operator|=
name|add_set_cmd
argument_list|(
literal|"demangle-style"
argument_list|,
name|class_support
argument_list|,
name|var_string_noescape
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|current_demangling_style_string
argument_list|,
literal|"Set the current C++ demangling style.\n\ Use `set demangle-style' without arguments for a list of demangling styles."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|show
operator|=
name|add_show_from_set
argument_list|(
name|set
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|set
operator|->
name|function
operator|.
name|sfunc
operator|=
name|set_demangling_command
expr_stmt|;
comment|/* Set the default demangling style chosen at compilation time. */
name|set_demangling_style
argument_list|(
name|DEFAULT_DEMANGLING_STYLE
argument_list|)
expr_stmt|;
name|set_cplus_marker_for_demangling
argument_list|(
name|CPLUS_MARKER
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

