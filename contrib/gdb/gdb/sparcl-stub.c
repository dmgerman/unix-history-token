begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************************  		THIS SOFTWARE IS NOT COPYRIGHTED     HP offers the following for use in the public domain.  HP makes no    warranty with regard to the software or it's performance and the    user accepts the software "AS IS" with all faults.     HP DISCLAIMS ANY WARRANTIES, EXPRESS OR IMPLIED, WITH REGARD    TO THIS SOFTWARE INCLUDING BUT NOT LIMITED TO THE WARRANTIES    OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  ****************************************************************************/
end_comment

begin_comment
comment|/****************************************************************************  *  Header: remcom.c,v 1.34 91/03/09 12:29:49 glenne Exp $  *  *  Module name: remcom.c $  *  Revision: 1.34 $  *  Date: 91/03/09 12:29:49 $  *  Contributor:     Lake Stevens Instrument Division$  *  *  Description:     low level support for gdb debugger. $  *  *  Considerations:  only works on target hardware $  *  *  Written by:      Glenn Engel $  *  ModuleState:     Experimental $  *  *  NOTES:           See Below $  *  *  Modified for SPARC by Stu Grossman, Cygnus Support.  *  Based on sparc-stub.c, it's modified for SPARClite Debug Unit hardware  *  breakpoint support to create sparclite-stub.c, by Kung Hsu, Cygnus Support.  *  *  This code has been extensively tested on the Fujitsu SPARClite demo board.  *  *  To enable debugger support, two things need to happen.  One, a  *  call to set_debug_traps() is necessary in order to allow any breakpoints  *  or error conditions to be properly intercepted and reported to gdb.  *  Two, a breakpoint needs to be generated to begin communication.  This  *  is most easily accomplished by a call to breakpoint().  Breakpoint()  *  simulates a breakpoint by executing a trap #1.  *  *************  *  *    The following gdb commands are supported:  *  * command          function                               Return value  *  *    g             return the value of the CPU registers  hex data or ENN  *    G             set the value of the CPU registers     OK or ENN  *    P             set the value of a single CPU register OK or ENN  *  *    mAA..AA,LLLL  Read LLLL bytes at address AA..AA      hex data or ENN  *    MAA..AA,LLLL: Write LLLL bytes at address AA.AA      OK or ENN  *  *    c             Resume at current address              SNN   ( signal NN)  *    cAA..AA       Continue at address AA..AA             SNN  *  *    s             Step one instruction                   SNN  *    sAA..AA       Step one instruction from AA..AA       SNN  *  *    k             kill  *  *    ?             What was the last sigval ?             SNN   (signal NN)  *  * All commands and responses are sent with a packet which includes a  * checksum.  A packet consists of  *  * $<packet info>#<checksum>.  *  * where  *<packet info> ::<characters representing the command or response>  *<checksum>    ::< two hex digits computed as modulo 256 sum of<packetinfo>>  *  * When a packet is received, it is first acknowledged with either '+' or '-'.  * '+' indicates a successful transfer.  '-' indicates a failed transfer.  *  * Example:  *  * Host:                  Reply:  * $m0,10#2a               +$00010203040506070809101112131415#42  *  ****************************************************************************/
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sparclite.h>
end_include

begin_comment
comment|/************************************************************************  *  * external low-level support routines  */
end_comment

begin_function_decl
specifier|extern
name|void
name|putDebugChar
parameter_list|(
name|int
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* write a single character      */
end_comment

begin_function_decl
specifier|extern
name|int
name|getDebugChar
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* read and return a single char */
end_comment

begin_comment
comment|/************************************************************************/
end_comment

begin_comment
comment|/* BUFMAX defines the maximum number of characters in inbound/outbound buffers*/
end_comment

begin_comment
comment|/* at least NUMREGBYTES*2 are needed for register packets */
end_comment

begin_define
define|#
directive|define
name|BUFMAX
value|2048
end_define

begin_decl_stmt
specifier|static
name|int
name|initialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* !0 means we've been initialized */
end_comment

begin_function_decl
specifier|extern
name|void
name|breakinst
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_mem_fault_trap
parameter_list|(
name|int
name|enable
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|get_in_break_mode
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|char
name|hexchars
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NUMREGS
value|80
end_define

begin_comment
comment|/* Number of bytes of registers.  */
end_comment

begin_define
define|#
directive|define
name|NUMREGBYTES
value|(NUMREGS * 4)
end_define

begin_enum
enum|enum
name|regnames
block|{
name|G0
block|,
name|G1
block|,
name|G2
block|,
name|G3
block|,
name|G4
block|,
name|G5
block|,
name|G6
block|,
name|G7
block|,
name|O0
block|,
name|O1
block|,
name|O2
block|,
name|O3
block|,
name|O4
block|,
name|O5
block|,
name|SP
block|,
name|O7
block|,
name|L0
block|,
name|L1
block|,
name|L2
block|,
name|L3
block|,
name|L4
block|,
name|L5
block|,
name|L6
block|,
name|L7
block|,
name|I0
block|,
name|I1
block|,
name|I2
block|,
name|I3
block|,
name|I4
block|,
name|I5
block|,
name|FP
block|,
name|I7
block|,
name|F0
block|,
name|F1
block|,
name|F2
block|,
name|F3
block|,
name|F4
block|,
name|F5
block|,
name|F6
block|,
name|F7
block|,
name|F8
block|,
name|F9
block|,
name|F10
block|,
name|F11
block|,
name|F12
block|,
name|F13
block|,
name|F14
block|,
name|F15
block|,
name|F16
block|,
name|F17
block|,
name|F18
block|,
name|F19
block|,
name|F20
block|,
name|F21
block|,
name|F22
block|,
name|F23
block|,
name|F24
block|,
name|F25
block|,
name|F26
block|,
name|F27
block|,
name|F28
block|,
name|F29
block|,
name|F30
block|,
name|F31
block|,
name|Y
block|,
name|PSR
block|,
name|WIM
block|,
name|TBR
block|,
name|PC
block|,
name|NPC
block|,
name|FPSR
block|,
name|CPSR
block|,
name|DIA1
block|,
name|DIA2
block|,
name|DDA1
block|,
name|DDA2
block|,
name|DDV1
block|,
name|DDV2
block|,
name|DCR
block|,
name|DSR
block|}
enum|;
end_enum

begin_comment
comment|/***************************  ASSEMBLY CODE MACROS *************************/
end_comment

begin_comment
comment|/* 									   */
end_comment

begin_function_decl
specifier|extern
name|void
name|trap_low
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Create private copies of common functions used by the stub.  This prevents    nasty interactions between app code and the stub (for instance if user steps    into strlen, etc..) */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|strcpy
parameter_list|(
name|char
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|)
block|{
name|char
modifier|*
name|retval
init|=
name|dst
decl_stmt|;
while|while
condition|(
operator|(
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
operator|)
operator|!=
literal|'\000'
condition|)
empty_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|memcpy
parameter_list|(
name|void
modifier|*
name|vdst
parameter_list|,
specifier|const
name|void
modifier|*
name|vsrc
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|char
modifier|*
name|dst
init|=
name|vdst
decl_stmt|;
specifier|const
name|char
modifier|*
name|src
init|=
name|vsrc
decl_stmt|;
name|char
modifier|*
name|retval
init|=
name|dst
decl_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
condition|)
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_asm
asm|asm(" 	.reserve trapstack, 1000 * 4, \"bss\", 8  	.data 	.align	4  in_trap_handler: 	.word	0  	.text 	.align 4  ! This function is called when any SPARC trap (except window overflow or ! underflow) occurs.  It makes sure that the invalid register window is still ! available before jumping into C code.  It will also restore the world if you ! return from handle_exception. ! ! On entry, trap_low expects l1 and l2 to contain pc and npc respectivly. ! Register usage throughout the routine is as follows: ! !	l0 - psr !	l1 - pc !	l2 - npc !	l3 - wim !	l4 - scratch and y reg !	l5 - scratch and tbr !	l6 - unused !	l7 - unused  	.globl _trap_low _trap_low: 	mov	%psr, %l0 	mov	%wim, %l3  	srl	%l3, %l0, %l4		! wim>> cwp 	cmp	%l4, 1 	bne	window_fine		! Branch if not in the invalid window 	nop  ! Handle window overflow  	mov	%g1, %l4		! Save g1, we use it to hold the wim 	srl	%l3, 1, %g1		! Rotate wim right 	tst	%g1 	bg	good_wim		! Branch if new wim is non-zero 	nop  ! At this point, we need to bring a 1 into the high order bit of the wim. ! Since we don't want to make any assumptions about the number of register ! windows, we figure it out dynamically so as to setup the wim correctly.  	not	%g1			! Fill g1 with ones 	mov	%g1, %wim		! Fill the wim with ones 	nop 	nop 	nop 	mov	%wim, %g1		! Read back the wim 	inc	%g1			! Now g1 has 1 just to left of wim 	srl	%g1, 1, %g1		! Now put 1 at top of wim 	mov	%g0, %wim		! Clear wim so that subsequent save 	nop				!  won't trap 	nop 	nop  good_wim: 	save	%g0, %g0, %g0		! Slip into next window 	mov	%g1, %wim		! Install the new wim  	std	%l0, [%sp + 0 * 4]	! save L& I registers 	std	%l2, [%sp + 2 * 4] 	std	%l4, [%sp + 4 * 4] 	std	%l6, [%sp + 6 * 4]  	std	%i0, [%sp + 8 * 4] 	std	%i2, [%sp + 10 * 4] 	std	%i4, [%sp + 12 * 4] 	std	%i6, [%sp + 14 * 4]  	restore				! Go back to trap window. 	mov	%l4, %g1		! Restore %g1  window_fine: 	sethi	%hi(in_trap_handler), %l4 	ld	[%lo(in_trap_handler) + %l4], %l5 	tst	%l5 	bg	recursive_trap 	inc	%l5  	set	trapstack+1000*4, %sp	! Switch to trap stack  recursive_trap: 	st	%l5, [%lo(in_trap_handler) + %l4] 	sub	%sp,(16+1+6+1+80)*4,%sp	! Make room for input& locals  					! + hidden arg + arg spill 					! + doubleword alignment 					! + registers[72] local var  	std	%g0, [%sp + (24 + 0) * 4] ! registers[Gx] 	std	%g2, [%sp + (24 + 2) * 4] 	std	%g4, [%sp + (24 + 4) * 4] 	std	%g6, [%sp + (24 + 6) * 4]  	std	%i0, [%sp + (24 + 8) * 4] ! registers[Ox] 	std	%i2, [%sp + (24 + 10) * 4] 	std	%i4, [%sp + (24 + 12) * 4] 	std	%i6, [%sp + (24 + 14) * 4]  	mov	%y, %l4 	mov	%tbr, %l5 	st	%l4, [%sp + (24 + 64) * 4] ! Y 	st	%l0, [%sp + (24 + 65) * 4] ! PSR 	st	%l3, [%sp + (24 + 66) * 4] ! WIM 	st	%l5, [%sp + (24 + 67) * 4] ! TBR 	st	%l1, [%sp + (24 + 68) * 4] ! PC 	st	%l2, [%sp + (24 + 69) * 4] ! NPC  	or	%l0, 0xf20, %l4 	mov	%l4, %psr		! Turn on traps, disable interrupts  	set	0x1000, %l1 	btst	%l1, %l0		! FP enabled? 	be	no_fpstore 	nop  ! Must save fsr first, to flush the FQ.  This may cause a deferred fp trap, so ! traps must be enabled to allow the trap handler to clean things up.  	st	%fsr, [%sp + (24 + 70) * 4]  	std	%f0, [%sp + (24 + 32) * 4] 	std	%f2, [%sp + (24 + 34) * 4] 	std	%f4, [%sp + (24 + 36) * 4] 	std	%f6, [%sp + (24 + 38) * 4] 	std	%f8, [%sp + (24 + 40) * 4] 	std	%f10, [%sp + (24 + 42) * 4] 	std	%f12, [%sp + (24 + 44) * 4] 	std	%f14, [%sp + (24 + 46) * 4] 	std	%f16, [%sp + (24 + 48) * 4] 	std	%f18, [%sp + (24 + 50) * 4] 	std	%f20, [%sp + (24 + 52) * 4] 	std	%f22, [%sp + (24 + 54) * 4] 	std	%f24, [%sp + (24 + 56) * 4] 	std	%f26, [%sp + (24 + 58) * 4] 	std	%f28, [%sp + (24 + 60) * 4] 	std	%f30, [%sp + (24 + 62) * 4] no_fpstore:  	call	_handle_exception 	add	%sp, 24 * 4, %o0	! Pass address of registers  ! Reload all of the registers that aren't on the stack  	ld	[%sp + (24 + 1) * 4], %g1 ! registers[Gx] 	ldd	[%sp + (24 + 2) * 4], %g2 	ldd	[%sp + (24 + 4) * 4], %g4 	ldd	[%sp + (24 + 6) * 4], %g6  	ldd	[%sp + (24 + 8) * 4], %i0 ! registers[Ox] 	ldd	[%sp + (24 + 10) * 4], %i2 	ldd	[%sp + (24 + 12) * 4], %i4 	ldd	[%sp + (24 + 14) * 4], %i6   	ldd	[%sp + (24 + 64) * 4], %l0 ! Y& PSR 	ldd	[%sp + (24 + 68) * 4], %l2 ! PC& NPC  	set	0x1000, %l5 	btst	%l5, %l1		! FP enabled? 	be	no_fpreload 	nop  	ldd	[%sp + (24 + 32) * 4], %f0 	ldd	[%sp + (24 + 34) * 4], %f2 	ldd	[%sp + (24 + 36) * 4], %f4 	ldd	[%sp + (24 + 38) * 4], %f6 	ldd	[%sp + (24 + 40) * 4], %f8 	ldd	[%sp + (24 + 42) * 4], %f10 	ldd	[%sp + (24 + 44) * 4], %f12 	ldd	[%sp + (24 + 46) * 4], %f14 	ldd	[%sp + (24 + 48) * 4], %f16 	ldd	[%sp + (24 + 50) * 4], %f18 	ldd	[%sp + (24 + 52) * 4], %f20 	ldd	[%sp + (24 + 54) * 4], %f22 	ldd	[%sp + (24 + 56) * 4], %f24 	ldd	[%sp + (24 + 58) * 4], %f26 	ldd	[%sp + (24 + 60) * 4], %f28 	ldd	[%sp + (24 + 62) * 4], %f30  	ld	[%sp + (24 + 70) * 4], %fsr no_fpreload:  	restore				! Ensure that previous window is valid 	save	%g0, %g0, %g0		!  by causing a window_underflow trap  	mov	%l0, %y 	mov	%l1, %psr		! Make sure that traps are disabled 					! for rett 	sethi	%hi(in_trap_handler), %l4 	ld	[%lo(in_trap_handler) + %l4], %l5 	dec	%l5 	st	%l5, [%lo(in_trap_handler) + %l4]  	jmpl	%l2, %g0		! Restore old PC 	rett	%l3			! Restore old nPC ");
end_asm

begin_comment
comment|/* Convert ch from a hex digit to an int */
end_comment

begin_function
specifier|static
name|int
name|hex
parameter_list|(
name|unsigned
name|char
name|ch
parameter_list|)
block|{
if|if
condition|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'f'
condition|)
return|return
name|ch
operator|-
literal|'a'
operator|+
literal|10
return|;
if|if
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
return|return
name|ch
operator|-
literal|'0'
return|;
if|if
condition|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'F'
condition|)
return|return
name|ch
operator|-
literal|'A'
operator|+
literal|10
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|remcomInBuffer
index|[
name|BUFMAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|remcomOutBuffer
index|[
name|BUFMAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* scan for the sequence $<data>#<checksum>     */
end_comment

begin_function
name|unsigned
name|char
modifier|*
name|getpacket
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|buffer
init|=
operator|&
name|remcomInBuffer
index|[
literal|0
index|]
decl_stmt|;
name|unsigned
name|char
name|checksum
decl_stmt|;
name|unsigned
name|char
name|xmitcsum
decl_stmt|;
name|int
name|count
decl_stmt|;
name|char
name|ch
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* wait around for the start character, ignore all other characters */
while|while
condition|(
operator|(
name|ch
operator|=
name|getDebugChar
argument_list|()
operator|)
operator|!=
literal|'$'
condition|)
empty_stmt|;
name|retry
label|:
name|checksum
operator|=
literal|0
expr_stmt|;
name|xmitcsum
operator|=
operator|-
literal|1
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
comment|/* now, read until a # or end of buffer is found */
while|while
condition|(
name|count
operator|<
name|BUFMAX
condition|)
block|{
name|ch
operator|=
name|getDebugChar
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'$'
condition|)
goto|goto
name|retry
goto|;
if|if
condition|(
name|ch
operator|==
literal|'#'
condition|)
break|break;
name|checksum
operator|=
name|checksum
operator|+
name|ch
expr_stmt|;
name|buffer
index|[
name|count
index|]
operator|=
name|ch
expr_stmt|;
name|count
operator|=
name|count
operator|+
literal|1
expr_stmt|;
block|}
name|buffer
index|[
name|count
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'#'
condition|)
block|{
name|ch
operator|=
name|getDebugChar
argument_list|()
expr_stmt|;
name|xmitcsum
operator|=
name|hex
argument_list|(
name|ch
argument_list|)
operator|<<
literal|4
expr_stmt|;
name|ch
operator|=
name|getDebugChar
argument_list|()
expr_stmt|;
name|xmitcsum
operator|+=
name|hex
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|checksum
operator|!=
name|xmitcsum
condition|)
block|{
name|putDebugChar
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
comment|/* failed checksum */
block|}
else|else
block|{
name|putDebugChar
argument_list|(
literal|'+'
argument_list|)
expr_stmt|;
comment|/* successful transfer */
comment|/* if a sequence char is present, reply the sequence ID */
if|if
condition|(
name|buffer
index|[
literal|2
index|]
operator|==
literal|':'
condition|)
block|{
name|putDebugChar
argument_list|(
name|buffer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|putDebugChar
argument_list|(
name|buffer
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|&
name|buffer
index|[
literal|3
index|]
return|;
block|}
return|return
operator|&
name|buffer
index|[
literal|0
index|]
return|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* send the packet in buffer.  */
end_comment

begin_function
specifier|static
name|void
name|putpacket
parameter_list|(
name|unsigned
name|char
modifier|*
name|buffer
parameter_list|)
block|{
name|unsigned
name|char
name|checksum
decl_stmt|;
name|int
name|count
decl_stmt|;
name|unsigned
name|char
name|ch
decl_stmt|;
comment|/*  $<packet info>#<checksum>. */
do|do
block|{
name|putDebugChar
argument_list|(
literal|'$'
argument_list|)
expr_stmt|;
name|checksum
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ch
operator|=
name|buffer
index|[
name|count
index|]
condition|)
block|{
name|putDebugChar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|checksum
operator|+=
name|ch
expr_stmt|;
name|count
operator|+=
literal|1
expr_stmt|;
block|}
name|putDebugChar
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
name|putDebugChar
argument_list|(
name|hexchars
index|[
name|checksum
operator|>>
literal|4
index|]
argument_list|)
expr_stmt|;
name|putDebugChar
argument_list|(
name|hexchars
index|[
name|checksum
operator|&
literal|0xf
index|]
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|getDebugChar
argument_list|()
operator|!=
literal|'+'
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Indicate to caller of mem2hex or hex2mem that there has been an    error.  */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|mem_err
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Convert the memory pointed to by mem into hex, placing result in buf.  * Return a pointer to the last char put in buf (null), in case of mem fault,  * return 0.  * If MAY_FAULT is non-zero, then we will handle memory faults by returning  * a 0, else treat a fault like any other fault in the stub.  */
end_comment

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|mem2hex
parameter_list|(
name|unsigned
name|char
modifier|*
name|mem
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|may_fault
parameter_list|)
block|{
name|unsigned
name|char
name|ch
decl_stmt|;
name|set_mem_fault_trap
argument_list|(
name|may_fault
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
name|ch
operator|=
operator|*
name|mem
operator|++
expr_stmt|;
if|if
condition|(
name|mem_err
condition|)
return|return
literal|0
return|;
operator|*
name|buf
operator|++
operator|=
name|hexchars
index|[
name|ch
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|hexchars
index|[
name|ch
operator|&
literal|0xf
index|]
expr_stmt|;
block|}
operator|*
name|buf
operator|=
literal|0
expr_stmt|;
name|set_mem_fault_trap
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* convert the hex array pointed to by buf into binary to be placed in mem  * return a pointer to the character AFTER the last byte written */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|hex2mem
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|unsigned
name|char
modifier|*
name|mem
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|may_fault
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|ch
decl_stmt|;
name|set_mem_fault_trap
argument_list|(
name|may_fault
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|=
name|hex
argument_list|(
operator|*
name|buf
operator|++
argument_list|)
operator|<<
literal|4
expr_stmt|;
name|ch
operator||=
name|hex
argument_list|(
operator|*
name|buf
operator|++
argument_list|)
expr_stmt|;
operator|*
name|mem
operator|++
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|mem_err
condition|)
return|return
literal|0
return|;
block|}
name|set_mem_fault_trap
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|mem
return|;
block|}
end_function

begin_comment
comment|/* This table contains the mapping between SPARC hardware trap types, and    signals, which are primarily what GDB understands.  It also indicates    which hardware traps we need to commandeer when initializing the stub. */
end_comment

begin_struct
specifier|static
struct|struct
name|hard_trap_info
block|{
name|unsigned
name|char
name|tt
decl_stmt|;
comment|/* Trap type code for SPARClite */
name|unsigned
name|char
name|signo
decl_stmt|;
comment|/* Signal that we map this trap into */
block|}
name|hard_trap_info
index|[]
init|=
block|{
block|{
literal|0x01
block|,
name|SIGSEGV
block|}
block|,
comment|/* instruction access error */
block|{
literal|0x02
block|,
name|SIGILL
block|}
block|,
comment|/* privileged instruction */
block|{
literal|0x03
block|,
name|SIGILL
block|}
block|,
comment|/* illegal instruction */
block|{
literal|0x04
block|,
name|SIGEMT
block|}
block|,
comment|/* fp disabled */
block|{
literal|0x07
block|,
name|SIGBUS
block|}
block|,
comment|/* mem address not aligned */
block|{
literal|0x09
block|,
name|SIGSEGV
block|}
block|,
comment|/* data access exception */
block|{
literal|0x0a
block|,
name|SIGEMT
block|}
block|,
comment|/* tag overflow */
block|{
literal|0x20
block|,
name|SIGBUS
block|}
block|,
comment|/* r register access error */
block|{
literal|0x21
block|,
name|SIGBUS
block|}
block|,
comment|/* instruction access error */
block|{
literal|0x24
block|,
name|SIGEMT
block|}
block|,
comment|/* cp disabled */
block|{
literal|0x29
block|,
name|SIGBUS
block|}
block|,
comment|/* data access error */
block|{
literal|0x2a
block|,
name|SIGFPE
block|}
block|,
comment|/* divide by zero */
block|{
literal|0x2b
block|,
name|SIGBUS
block|}
block|,
comment|/* data store error */
block|{
literal|0x80
operator|+
literal|1
block|,
name|SIGTRAP
block|}
block|,
comment|/* ta 1 - normal breakpoint instruction */
block|{
literal|0xff
block|,
name|SIGTRAP
block|}
block|,
comment|/* hardware breakpoint */
block|{
literal|0
block|,
literal|0
block|}
comment|/* Must be last */
block|}
struct|;
end_struct

begin_comment
comment|/* Set up exception handlers for tracing and breakpoints */
end_comment

begin_function
name|void
name|set_debug_traps
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|hard_trap_info
modifier|*
name|ht
decl_stmt|;
comment|/* Only setup fp traps if the FP is disabled.  */
for|for
control|(
name|ht
operator|=
name|hard_trap_info
init|;
name|ht
operator|->
name|tt
operator|!=
literal|0
operator|&&
name|ht
operator|->
name|signo
operator|!=
literal|0
condition|;
name|ht
operator|++
control|)
if|if
condition|(
name|ht
operator|->
name|tt
operator|!=
literal|4
operator|||
operator|!
operator|(
name|read_psr
argument_list|()
operator|&
literal|0x1000
operator|)
condition|)
name|exceptionHandler
argument_list|(
name|ht
operator|->
name|tt
argument_list|,
name|trap_low
argument_list|)
expr_stmt|;
name|initialized
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_asm
asm|asm (" ! Trap handler for memory errors.  This just sets mem_err to be non-zero.  It ! assumes that %l1 is non-zero.  This should be safe, as it is doubtful that ! 0 would ever contain code that could mem fault.  This routine will skip ! past the faulting instruction after setting mem_err.  	.text 	.align 4  _fltr_set_mem_err: 	sethi %hi(_mem_err), %l0 	st %l1, [%l0 + %lo(_mem_err)] 	jmpl %l2, %g0 	rett %l2+4 ");
end_asm

begin_function
specifier|static
name|void
name|set_mem_fault_trap
parameter_list|(
name|int
name|enable
parameter_list|)
block|{
specifier|extern
name|void
name|fltr_set_mem_err
parameter_list|()
function_decl|;
name|mem_err
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|enable
condition|)
name|exceptionHandler
argument_list|(
literal|9
argument_list|,
name|fltr_set_mem_err
argument_list|)
expr_stmt|;
else|else
name|exceptionHandler
argument_list|(
literal|9
argument_list|,
name|trap_low
argument_list|)
expr_stmt|;
block|}
end_function

begin_asm
asm|asm (" 	.text 	.align 4  _dummy_hw_breakpoint: 	jmpl %l2, %g0 	rett %l2+4 	nop 	nop ");
end_asm

begin_function
specifier|static
name|void
name|get_in_break_mode
parameter_list|(
name|void
parameter_list|)
block|{
specifier|extern
name|void
name|dummy_hw_breakpoint
parameter_list|()
function_decl|;
name|exceptionHandler
argument_list|(
literal|255
argument_list|,
name|dummy_hw_breakpoint
argument_list|)
expr_stmt|;
asm|asm ("ta 255");
name|exceptionHandler
argument_list|(
literal|255
argument_list|,
name|trap_low
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert the SPARC hardware trap type code to a unix signal number. */
end_comment

begin_function
specifier|static
name|int
name|computeSignal
parameter_list|(
name|int
name|tt
parameter_list|)
block|{
name|struct
name|hard_trap_info
modifier|*
name|ht
decl_stmt|;
for|for
control|(
name|ht
operator|=
name|hard_trap_info
init|;
name|ht
operator|->
name|tt
operator|&&
name|ht
operator|->
name|signo
condition|;
name|ht
operator|++
control|)
if|if
condition|(
name|ht
operator|->
name|tt
operator|==
name|tt
condition|)
return|return
name|ht
operator|->
name|signo
return|;
return|return
name|SIGHUP
return|;
comment|/* default for things we don't know about */
block|}
end_function

begin_comment
comment|/*  * While we find nice hex chars, build an int.  * Return number of chars processed.  */
end_comment

begin_function
specifier|static
name|int
name|hexToInt
parameter_list|(
name|char
modifier|*
modifier|*
name|ptr
parameter_list|,
name|int
modifier|*
name|intValue
parameter_list|)
block|{
name|int
name|numChars
init|=
literal|0
decl_stmt|;
name|int
name|hexValue
decl_stmt|;
operator|*
name|intValue
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
operator|*
name|ptr
condition|)
block|{
name|hexValue
operator|=
name|hex
argument_list|(
operator|*
operator|*
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|hexValue
operator|<
literal|0
condition|)
break|break;
operator|*
name|intValue
operator|=
operator|(
operator|*
name|intValue
operator|<<
literal|4
operator|)
operator||
name|hexValue
expr_stmt|;
name|numChars
operator|++
expr_stmt|;
operator|(
operator|*
name|ptr
operator|)
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|numChars
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function does all command procesing for interfacing to gdb.  It  * returns 1 if you should skip the instruction at the trap address, 0  * otherwise.  */
end_comment

begin_function
specifier|static
name|void
name|handle_exception
parameter_list|(
name|unsigned
name|long
modifier|*
name|registers
parameter_list|)
block|{
name|int
name|tt
decl_stmt|;
comment|/* Trap type */
name|int
name|sigval
decl_stmt|;
name|int
name|addr
decl_stmt|;
name|int
name|length
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|unsigned
name|long
modifier|*
name|sp
decl_stmt|;
name|unsigned
name|long
name|dsr
decl_stmt|;
comment|/* First, we must force all of the windows to be spilled out */
asm|asm("	save %sp, -64, %sp 	save %sp, -64, %sp 	save %sp, -64, %sp 	save %sp, -64, %sp 	save %sp, -64, %sp 	save %sp, -64, %sp 	save %sp, -64, %sp 	save %sp, -64, %sp 	restore 	restore 	restore 	restore 	restore 	restore 	restore 	restore ");
name|get_in_break_mode
argument_list|()
expr_stmt|;
comment|/* Enable DSU register writes */
name|registers
index|[
name|DIA1
index|]
operator|=
name|read_asi
argument_list|(
literal|1
argument_list|,
literal|0xff00
argument_list|)
expr_stmt|;
name|registers
index|[
name|DIA2
index|]
operator|=
name|read_asi
argument_list|(
literal|1
argument_list|,
literal|0xff04
argument_list|)
expr_stmt|;
name|registers
index|[
name|DDA1
index|]
operator|=
name|read_asi
argument_list|(
literal|1
argument_list|,
literal|0xff08
argument_list|)
expr_stmt|;
name|registers
index|[
name|DDA2
index|]
operator|=
name|read_asi
argument_list|(
literal|1
argument_list|,
literal|0xff0c
argument_list|)
expr_stmt|;
name|registers
index|[
name|DDV1
index|]
operator|=
name|read_asi
argument_list|(
literal|1
argument_list|,
literal|0xff10
argument_list|)
expr_stmt|;
name|registers
index|[
name|DDV2
index|]
operator|=
name|read_asi
argument_list|(
literal|1
argument_list|,
literal|0xff14
argument_list|)
expr_stmt|;
name|registers
index|[
name|DCR
index|]
operator|=
name|read_asi
argument_list|(
literal|1
argument_list|,
literal|0xff18
argument_list|)
expr_stmt|;
name|registers
index|[
name|DSR
index|]
operator|=
name|read_asi
argument_list|(
literal|1
argument_list|,
literal|0xff1c
argument_list|)
expr_stmt|;
if|if
condition|(
name|registers
index|[
name|PC
index|]
operator|==
operator|(
name|unsigned
name|long
operator|)
name|breakinst
condition|)
block|{
name|registers
index|[
name|PC
index|]
operator|=
name|registers
index|[
name|NPC
index|]
expr_stmt|;
name|registers
index|[
name|NPC
index|]
operator|+=
literal|4
expr_stmt|;
block|}
name|sp
operator|=
operator|(
name|unsigned
name|long
operator|*
operator|)
name|registers
index|[
name|SP
index|]
expr_stmt|;
name|dsr
operator|=
operator|(
name|unsigned
name|long
operator|)
name|registers
index|[
name|DSR
index|]
expr_stmt|;
if|if
condition|(
name|dsr
operator|&
literal|0x3c
condition|)
name|tt
operator|=
literal|255
expr_stmt|;
else|else
name|tt
operator|=
operator|(
name|registers
index|[
name|TBR
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* reply to host that an exception has occurred */
name|sigval
operator|=
name|computeSignal
argument_list|(
name|tt
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|remcomOutBuffer
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|'T'
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|sigval
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|sigval
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|PC
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|PC
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|':'
expr_stmt|;
name|ptr
operator|=
name|mem2hex
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|registers
index|[
name|PC
index|]
argument_list|,
name|ptr
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|';'
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|FP
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|FP
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|':'
expr_stmt|;
name|ptr
operator|=
name|mem2hex
argument_list|(
name|sp
operator|+
literal|8
operator|+
literal|6
argument_list|,
name|ptr
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FP */
operator|*
name|ptr
operator|++
operator|=
literal|';'
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|SP
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|SP
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|':'
expr_stmt|;
name|ptr
operator|=
name|mem2hex
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sp
argument_list|,
name|ptr
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|';'
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|NPC
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|NPC
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|':'
expr_stmt|;
name|ptr
operator|=
name|mem2hex
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|registers
index|[
name|NPC
index|]
argument_list|,
name|ptr
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|';'
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|O7
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|hexchars
index|[
name|O7
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|':'
expr_stmt|;
name|ptr
operator|=
name|mem2hex
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|registers
index|[
name|O7
index|]
argument_list|,
name|ptr
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|';'
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|0
expr_stmt|;
name|putpacket
argument_list|(
name|remcomOutBuffer
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|remcomOutBuffer
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|ptr
operator|=
name|getpacket
argument_list|()
expr_stmt|;
switch|switch
condition|(
operator|*
name|ptr
operator|++
condition|)
block|{
case|case
literal|'?'
case|:
name|remcomOutBuffer
index|[
literal|0
index|]
operator|=
literal|'S'
expr_stmt|;
name|remcomOutBuffer
index|[
literal|1
index|]
operator|=
name|hexchars
index|[
name|sigval
operator|>>
literal|4
index|]
expr_stmt|;
name|remcomOutBuffer
index|[
literal|2
index|]
operator|=
name|hexchars
index|[
name|sigval
operator|&
literal|0xf
index|]
expr_stmt|;
name|remcomOutBuffer
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* toggle debug flag */
break|break;
case|case
literal|'g'
case|:
comment|/* return the value of the CPU registers */
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|L0
index|]
argument_list|,
name|sp
argument_list|,
literal|16
operator|*
literal|4
argument_list|)
expr_stmt|;
comment|/* Copy L& I regs from stack */
name|mem2hex
argument_list|(
operator|(
name|char
operator|*
operator|)
name|registers
argument_list|,
name|remcomOutBuffer
argument_list|,
name|NUMREGBYTES
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
comment|/* Set the value of all registers */
case|case
literal|'P'
case|:
comment|/* Set the value of one register */
block|{
name|unsigned
name|long
modifier|*
name|newsp
decl_stmt|,
name|psr
decl_stmt|;
name|psr
operator|=
name|registers
index|[
name|PSR
index|]
expr_stmt|;
if|if
condition|(
name|ptr
index|[
operator|-
literal|1
index|]
operator|==
literal|'P'
condition|)
block|{
name|int
name|regno
decl_stmt|;
if|if
condition|(
name|hexToInt
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|regno
argument_list|)
operator|&&
operator|*
name|ptr
operator|++
operator|==
literal|'='
condition|)
if|if
condition|(
name|regno
operator|>=
name|L0
operator|&&
name|regno
operator|<=
name|I7
condition|)
name|hex2mem
argument_list|(
name|ptr
argument_list|,
name|sp
operator|+
name|regno
operator|-
name|L0
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|hex2mem
argument_list|(
name|ptr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|registers
index|[
name|regno
index|]
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"E01"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|hex2mem
argument_list|(
name|ptr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|registers
argument_list|,
name|NUMREGBYTES
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|sp
argument_list|,
operator|&
name|registers
index|[
name|L0
index|]
argument_list|,
literal|16
operator|*
literal|4
argument_list|)
expr_stmt|;
comment|/* Copy L& I regs to stack */
block|}
comment|/* See if the stack pointer has moved.  If so, then copy the saved 	       locals and ins to the new location.  This keeps the window 	       overflow and underflow routines happy.  */
name|newsp
operator|=
operator|(
name|unsigned
name|long
operator|*
operator|)
name|registers
index|[
name|SP
index|]
expr_stmt|;
if|if
condition|(
name|sp
operator|!=
name|newsp
condition|)
name|sp
operator|=
name|memcpy
argument_list|(
name|newsp
argument_list|,
name|sp
argument_list|,
literal|16
operator|*
literal|4
argument_list|)
expr_stmt|;
comment|/* Don't allow CWP to be modified. */
if|if
condition|(
name|psr
operator|!=
name|registers
index|[
name|PSR
index|]
condition|)
name|registers
index|[
name|PSR
index|]
operator|=
operator|(
name|psr
operator|&
literal|0x1f
operator|)
operator||
operator|(
name|registers
index|[
name|PSR
index|]
operator|&
operator|~
literal|0x1f
operator|)
expr_stmt|;
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"OK"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'m'
case|:
comment|/* mAA..AA,LLLL  Read LLLL bytes at address AA..AA */
comment|/* Try to read %x,%x.  */
if|if
condition|(
name|hexToInt
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|addr
argument_list|)
operator|&&
operator|*
name|ptr
operator|++
operator|==
literal|','
operator|&&
name|hexToInt
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|length
argument_list|)
condition|)
block|{
if|if
condition|(
name|mem2hex
argument_list|(
operator|(
name|char
operator|*
operator|)
name|addr
argument_list|,
name|remcomOutBuffer
argument_list|,
name|length
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"E03"
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"E01"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* MAA..AA,LLLL: Write LLLL bytes at address AA.AA return OK */
comment|/* Try to read '%x,%x:'.  */
if|if
condition|(
name|hexToInt
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|addr
argument_list|)
operator|&&
operator|*
name|ptr
operator|++
operator|==
literal|','
operator|&&
name|hexToInt
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|length
argument_list|)
operator|&&
operator|*
name|ptr
operator|++
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|hex2mem
argument_list|(
name|ptr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|addr
argument_list|,
name|length
argument_list|,
literal|1
argument_list|)
condition|)
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"OK"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"E03"
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|remcomOutBuffer
argument_list|,
literal|"E02"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* cAA..AA    Continue at address AA..AA(optional) */
comment|/* try to read optional parameter, pc unchanged if no parm */
if|if
condition|(
name|hexToInt
argument_list|(
operator|&
name|ptr
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
block|{
name|registers
index|[
name|PC
index|]
operator|=
name|addr
expr_stmt|;
name|registers
index|[
name|NPC
index|]
operator|=
name|addr
operator|+
literal|4
expr_stmt|;
block|}
comment|/* Need to flush the instruction cache here, as we may have deposited a    breakpoint, and the icache probably has no way of knowing that a data ref to    some location may have changed something that is in the instruction cache.  */
name|flush_i_cache
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|registers
index|[
name|DSR
index|]
operator|&
literal|0x1
operator|)
comment|/* DSU enabled? */
operator|&&
operator|!
operator|(
name|registers
index|[
name|DCR
index|]
operator|&
literal|0x200
operator|)
condition|)
comment|/* Are we in break state? */
block|{
comment|/* Yes, set the DSU regs */
name|write_asi
argument_list|(
literal|1
argument_list|,
literal|0xff00
argument_list|,
name|registers
index|[
name|DIA1
index|]
argument_list|)
expr_stmt|;
name|write_asi
argument_list|(
literal|1
argument_list|,
literal|0xff04
argument_list|,
name|registers
index|[
name|DIA2
index|]
argument_list|)
expr_stmt|;
name|write_asi
argument_list|(
literal|1
argument_list|,
literal|0xff08
argument_list|,
name|registers
index|[
name|DDA1
index|]
argument_list|)
expr_stmt|;
name|write_asi
argument_list|(
literal|1
argument_list|,
literal|0xff0c
argument_list|,
name|registers
index|[
name|DDA2
index|]
argument_list|)
expr_stmt|;
name|write_asi
argument_list|(
literal|1
argument_list|,
literal|0xff10
argument_list|,
name|registers
index|[
name|DDV1
index|]
argument_list|)
expr_stmt|;
name|write_asi
argument_list|(
literal|1
argument_list|,
literal|0xff14
argument_list|,
name|registers
index|[
name|DDV2
index|]
argument_list|)
expr_stmt|;
name|write_asi
argument_list|(
literal|1
argument_list|,
literal|0xff1c
argument_list|,
name|registers
index|[
name|DSR
index|]
argument_list|)
expr_stmt|;
name|write_asi
argument_list|(
literal|1
argument_list|,
literal|0xff18
argument_list|,
name|registers
index|[
name|DCR
index|]
operator||
literal|0x200
argument_list|)
expr_stmt|;
comment|/* Clear break */
block|}
return|return;
comment|/* kill the program */
case|case
literal|'k'
case|:
comment|/* do nothing */
break|break;
if|#
directive|if
literal|0
block|case 't':
comment|/* Test feature */
block|asm (" std %f30,[%sp]"); 	  break;
endif|#
directive|endif
case|case
literal|'r'
case|:
comment|/* Reset */
asm|asm ("call 0 		nop ");
break|break;
block|}
comment|/* switch */
comment|/* reply to the request */
name|putpacket
argument_list|(
name|remcomOutBuffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function will generate a breakpoint exception.  It is used at the    beginning of a program to sync up with a debugger and can be used    otherwise as a quick means to stop program execution and "break" into    the debugger. */
end_comment

begin_function
name|void
name|breakpoint
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|initialized
condition|)
return|return;
asm|asm("	.globl _breakinst  	_breakinst: ta 1       ");
block|}
end_function

end_unit

