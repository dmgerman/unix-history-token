begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Support for printing Pascal values for GDB, the GNU debugger.    Copyright 2000, 2001    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file is derived from c-valprint.c */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"valprint.h"
end_include

begin_include
include|#
directive|include
file|"typeprint.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"annotate.h"
end_include

begin_include
include|#
directive|include
file|"p-lang.h"
end_include

begin_include
include|#
directive|include
file|"cp-abi.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Print data of type TYPE located at VALADDR (within GDB), which came from    the inferior at address ADDRESS, onto stdio stream STREAM according to    FORMAT (a letter or 0 for natural format).  The data at VALADDR is in    target byte order.     If the data are a string pointer, returns the number of string characters    printed.     If DEREF_REF is nonzero, then dereference references, otherwise just print    them like pointers.     The PRETTY parameter controls prettyprinting.  */
end_comment

begin_function
name|int
name|pascal_val_print
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|valaddr
parameter_list|,
name|int
name|embedded_offset
parameter_list|,
name|CORE_ADDR
name|address
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|format
parameter_list|,
name|int
name|deref_ref
parameter_list|,
name|int
name|recurse
parameter_list|,
name|enum
name|val_prettyprint
name|pretty
parameter_list|)
block|{
specifier|register
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* Number of characters printed */
name|unsigned
name|len
decl_stmt|;
name|struct
name|type
modifier|*
name|elttype
decl_stmt|;
name|unsigned
name|eltlen
decl_stmt|;
name|int
name|length_pos
decl_stmt|,
name|length_size
decl_stmt|,
name|string_pos
decl_stmt|;
name|int
name|char_size
decl_stmt|;
name|LONGEST
name|val
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_ARRAY
case|:
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|>
literal|0
operator|&&
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
block|{
name|elttype
operator|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|eltlen
operator|=
name|TYPE_LENGTH
argument_list|(
name|elttype
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|/
name|eltlen
expr_stmt|;
if|if
condition|(
name|prettyprint_arrays
condition|)
block|{
name|print_spaces_filtered
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
comment|/* For an array of chars, print with string syntax.  */
if|if
condition|(
name|eltlen
operator|==
literal|1
operator|&&
operator|(
operator|(
name|TYPE_CODE
argument_list|(
name|elttype
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|)
operator|||
operator|(
operator|(
name|current_language
operator|->
name|la_language
operator|==
name|language_m2
operator|)
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|elttype
argument_list|)
operator|==
name|TYPE_CODE_CHAR
operator|)
operator|)
operator|)
operator|&&
operator|(
name|format
operator|==
literal|0
operator|||
name|format
operator|==
literal|'s'
operator|)
condition|)
block|{
comment|/* If requested, look for the first null char and only print 	         elements up to it.  */
if|if
condition|(
name|stop_print_at_null
condition|)
block|{
name|unsigned
name|int
name|temp_len
decl_stmt|;
comment|/* Look for a NULL char. */
for|for
control|(
name|temp_len
operator|=
literal|0
init|;
operator|(
name|valaddr
operator|+
name|embedded_offset
operator|)
index|[
name|temp_len
index|]
operator|&&
name|temp_len
operator|<
name|len
operator|&&
name|temp_len
operator|<
name|print_max
condition|;
name|temp_len
operator|++
control|)
empty_stmt|;
name|len
operator|=
name|temp_len
expr_stmt|;
block|}
name|LA_PRINT_STRING
argument_list|(
name|stream
argument_list|,
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i
operator|=
name|len
expr_stmt|;
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
comment|/* If this is a virtual function table, print the 0th 	         entry specially, and the rest of the members normally.  */
if|if
condition|(
name|pascal_object_is_vtbl_ptr_type
argument_list|(
name|elttype
argument_list|)
condition|)
block|{
name|i
operator|=
literal|1
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%d vtable entries"
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
literal|0
expr_stmt|;
block|}
name|val_print_array_elements
argument_list|(
name|type
argument_list|,
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|address
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* Array of unspecified length: treat like pointer to first elt.  */
name|addr
operator|=
name|address
expr_stmt|;
goto|goto
name|print_unpacked_pointer
goto|;
case|case
name|TYPE_CODE_PTR
case|:
if|if
condition|(
name|format
operator|&&
name|format
operator|!=
literal|'s'
condition|)
block|{
name|print_scalar_formatted
argument_list|(
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|vtblprint
operator|&&
name|pascal_object_is_vtbl_ptr_type
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Print the unmangled name if desired.  */
comment|/* Print vtable entry - we only get here if we ARE using 	     -fvtable_thunks.  (Otherwise, look under TYPE_CODE_STRUCT.) */
name|print_address_demangle
argument_list|(
name|extract_address
argument_list|(
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|stream
argument_list|,
name|demangle
argument_list|)
expr_stmt|;
break|break;
block|}
name|elttype
operator|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|elttype
argument_list|)
operator|==
name|TYPE_CODE_METHOD
condition|)
block|{
name|pascal_object_print_class_method
argument_list|(
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|type
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|elttype
argument_list|)
operator|==
name|TYPE_CODE_MEMBER
condition|)
block|{
name|pascal_object_print_class_member
argument_list|(
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|TYPE_DOMAIN_TYPE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addr
operator|=
name|unpack_pointer
argument_list|(
name|type
argument_list|,
name|valaddr
operator|+
name|embedded_offset
argument_list|)
expr_stmt|;
name|print_unpacked_pointer
label|:
name|elttype
operator|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|elttype
argument_list|)
operator|==
name|TYPE_CODE_FUNC
condition|)
block|{
comment|/* Try to print what function it points to.  */
name|print_address_demangle
argument_list|(
name|addr
argument_list|,
name|stream
argument_list|,
name|demangle
argument_list|)
expr_stmt|;
comment|/* Return value is irrelevant except for string pointers.  */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|addressprint
operator|&&
name|format
operator|!=
literal|'s'
condition|)
block|{
name|print_address_numeric
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
comment|/* For a pointer to char or unsigned char, also print the string 	     pointed to, unless pointer is null.  */
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|elttype
argument_list|)
operator|==
literal|1
operator|&&
name|TYPE_CODE
argument_list|(
name|elttype
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|&&
operator|(
name|format
operator|==
literal|0
operator|||
name|format
operator|==
literal|'s'
operator|)
operator|&&
name|addr
operator|!=
literal|0
condition|)
block|{
comment|/* no wide string yet */
name|i
operator|=
name|val_print_string
argument_list|(
name|addr
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
comment|/* also for pointers to pascal strings */
comment|/* Note: this is Free Pascal specific: 	     as GDB does not recognize stabs pascal strings 	     Pascal strings are mapped to records 	     with lowercase names PM  */
if|if
condition|(
name|is_pascal_string_type
argument_list|(
name|elttype
argument_list|,
operator|&
name|length_pos
argument_list|,
operator|&
name|length_size
argument_list|,
operator|&
name|string_pos
argument_list|,
operator|&
name|char_size
argument_list|)
operator|&&
name|addr
operator|!=
literal|0
condition|)
block|{
name|ULONGEST
name|string_length
decl_stmt|;
name|void
modifier|*
name|buffer
decl_stmt|;
name|buffer
operator|=
name|xmalloc
argument_list|(
name|length_size
argument_list|)
expr_stmt|;
name|read_memory
argument_list|(
name|addr
operator|+
name|length_pos
argument_list|,
name|buffer
argument_list|,
name|length_size
argument_list|)
expr_stmt|;
name|string_length
operator|=
name|extract_unsigned_integer
argument_list|(
name|buffer
argument_list|,
name|length_size
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|i
operator|=
name|val_print_string
argument_list|(
name|addr
operator|+
name|string_pos
argument_list|,
name|string_length
argument_list|,
name|char_size
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pascal_object_is_vtbl_member
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* print vtbl's nicely */
name|CORE_ADDR
name|vt_address
init|=
name|unpack_pointer
argument_list|(
name|type
argument_list|,
name|valaddr
operator|+
name|embedded_offset
argument_list|)
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
init|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|vt_address
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|msymbol
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|vt_address
operator|==
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
operator|)
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"<"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|SYMBOL_SOURCE_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|">"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vt_address
operator|&&
name|vtblprint
condition|)
block|{
name|struct
name|value
modifier|*
name|vt_val
decl_stmt|;
name|struct
name|symbol
modifier|*
name|wsym
init|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|NULL
decl_stmt|;
name|struct
name|type
modifier|*
name|wtype
decl_stmt|;
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|struct
name|block
modifier|*
name|block
init|=
operator|(
expr|struct
name|block
operator|*
operator|)
name|NULL
decl_stmt|;
name|int
name|is_this_fld
decl_stmt|;
if|if
condition|(
name|msymbol
operator|!=
name|NULL
condition|)
name|wsym
operator|=
name|lookup_symbol
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|,
name|block
argument_list|,
name|VAR_NAMESPACE
argument_list|,
operator|&
name|is_this_fld
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|wsym
condition|)
block|{
name|wtype
operator|=
name|SYMBOL_TYPE
argument_list|(
name|wsym
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wtype
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|vt_val
operator|=
name|value_at
argument_list|(
name|wtype
argument_list|,
name|vt_address
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|val_print
argument_list|(
name|VALUE_TYPE
argument_list|(
name|vt_val
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|vt_val
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|vt_val
argument_list|)
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
if|if
condition|(
name|pretty
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Return number of characters printed, including the terminating 	     '\0' if we reached the end.  val_print_string takes care including 	     the terminating '\0' if necessary.  */
return|return
name|i
return|;
block|}
break|break;
case|case
name|TYPE_CODE_MEMBER
case|:
name|error
argument_list|(
literal|"not implemented: member type in pascal_val_print"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_REF
case|:
name|elttype
operator|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|elttype
argument_list|)
operator|==
name|TYPE_CODE_MEMBER
condition|)
block|{
name|pascal_object_print_class_member
argument_list|(
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|TYPE_DOMAIN_TYPE
argument_list|(
name|elttype
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|addressprint
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"@"
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|extract_address
argument_list|(
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|TARGET_PTR_BIT
operator|/
name|HOST_CHAR_BIT
argument_list|)
argument_list|,
literal|1
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|deref_ref
condition|)
name|fputs_filtered
argument_list|(
literal|": "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
comment|/* De-reference the reference.  */
if|if
condition|(
name|deref_ref
condition|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|elttype
argument_list|)
operator|!=
name|TYPE_CODE_UNDEF
condition|)
block|{
name|struct
name|value
modifier|*
name|deref_val
init|=
name|value_at
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|unpack_pointer
argument_list|(
name|lookup_pointer_type
argument_list|(
name|builtin_type_void
argument_list|)
argument_list|,
name|valaddr
operator|+
name|embedded_offset
argument_list|)
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|val_print
argument_list|(
name|VALUE_TYPE
argument_list|(
name|deref_val
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|deref_val
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|deref_val
argument_list|)
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
block|}
else|else
name|fputs_filtered
argument_list|(
literal|"???"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_UNION
case|:
if|if
condition|(
name|recurse
operator|&&
operator|!
name|unionprint
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{...}"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Fall through.  */
case|case
name|TYPE_CODE_STRUCT
case|:
if|if
condition|(
name|vtblprint
operator|&&
name|pascal_object_is_vtbl_ptr_type
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Print the unmangled name if desired.  */
comment|/* Print vtable entry - we only get here if NOT using 	     -fvtable_thunks.  (Otherwise, look under TYPE_CODE_PTR.) */
name|print_address_demangle
argument_list|(
name|extract_address
argument_list|(
name|valaddr
operator|+
name|embedded_offset
operator|+
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|VTBL_FNADDR_OFFSET
argument_list|)
operator|/
literal|8
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|VTBL_FNADDR_OFFSET
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|stream
argument_list|,
name|demangle
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|is_pascal_string_type
argument_list|(
name|type
argument_list|,
operator|&
name|length_pos
argument_list|,
operator|&
name|length_size
argument_list|,
operator|&
name|string_pos
argument_list|,
operator|&
name|char_size
argument_list|)
condition|)
block|{
name|len
operator|=
name|extract_unsigned_integer
argument_list|(
name|valaddr
operator|+
name|embedded_offset
operator|+
name|length_pos
argument_list|,
name|length_size
argument_list|)
expr_stmt|;
name|LA_PRINT_STRING
argument_list|(
name|stream
argument_list|,
name|valaddr
operator|+
name|embedded_offset
operator|+
name|string_pos
argument_list|,
name|len
argument_list|,
name|char_size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
name|pascal_object_print_value_fields
argument_list|(
name|type
argument_list|,
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|address
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_ENUM
case|:
if|if
condition|(
name|format
condition|)
block|{
name|print_scalar_formatted
argument_list|(
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
block|}
name|len
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|val
operator|=
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
operator|+
name|embedded_offset
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|<
name|len
condition|)
block|{
name|fputs_filtered
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|print_longest
argument_list|(
name|stream
argument_list|,
literal|'d'
argument_list|,
literal|0
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_FUNC
case|:
if|if
condition|(
name|format
condition|)
block|{
name|print_scalar_formatted
argument_list|(
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FIXME, we should consider, at least for ANSI C language, eliminating          the distinction made between FUNCs and POINTERs to FUNCs.  */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"} "
argument_list|)
expr_stmt|;
comment|/* Try to print what function it points to, and its address.  */
name|print_address_demangle
argument_list|(
name|address
argument_list|,
name|stream
argument_list|,
name|demangle
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_BOOL
case|:
name|format
operator|=
name|format
condition|?
name|format
else|:
name|output_format
expr_stmt|;
if|if
condition|(
name|format
condition|)
name|print_scalar_formatted
argument_list|(
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
block|{
name|val
operator|=
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
operator|+
name|embedded_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|fputs_filtered
argument_list|(
literal|"false"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|==
literal|1
condition|)
name|fputs_filtered
argument_list|(
literal|"true"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
block|{
name|fputs_filtered
argument_list|(
literal|"true ("
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%ld)"
argument_list|,
operator|(
name|long
name|int
operator|)
name|val
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TYPE_CODE_RANGE
case|:
comment|/* FIXME: create_range_type does not set the unsigned bit in a          range type (I think it probably should copy it from the target          type), so we won't print values which are too large to          fit in a signed integer correctly.  */
comment|/* FIXME: Doesn't handle ranges of enums correctly.  (Can't just          print with the target type, though, because the size of our type          and the target type might differ).  */
comment|/* FALLTHROUGH */
case|case
name|TYPE_CODE_INT
case|:
name|format
operator|=
name|format
condition|?
name|format
else|:
name|output_format
expr_stmt|;
if|if
condition|(
name|format
condition|)
block|{
name|print_scalar_formatted
argument_list|(
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val_print_type_code_int
argument_list|(
name|type
argument_list|,
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_CHAR
case|:
name|format
operator|=
name|format
condition|?
name|format
else|:
name|output_format
expr_stmt|;
if|if
condition|(
name|format
condition|)
block|{
name|print_scalar_formatted
argument_list|(
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
operator|+
name|embedded_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%u"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|val
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|val
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|LA_PRINT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|val
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_FLT
case|:
if|if
condition|(
name|format
condition|)
block|{
name|print_scalar_formatted
argument_list|(
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|print_floating
argument_list|(
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|type
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_BITSTRING
case|:
case|case
name|TYPE_CODE_SET
case|:
name|elttype
operator|=
name|TYPE_INDEX_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|elttype
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_STUB
argument_list|(
name|elttype
argument_list|)
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<incomplete type>"
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|stream
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|struct
name|type
modifier|*
name|range
init|=
name|elttype
decl_stmt|;
name|LONGEST
name|low_bound
decl_stmt|,
name|high_bound
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|is_bitstring
init|=
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_BITSTRING
decl_stmt|;
name|int
name|need_comma
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|is_bitstring
condition|)
name|fputs_filtered
argument_list|(
literal|"B'"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|"["
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|i
operator|=
name|get_discrete_bounds
argument_list|(
name|range
argument_list|,
operator|&
name|low_bound
argument_list|,
operator|&
name|high_bound
argument_list|)
expr_stmt|;
name|maybe_bad_bstring
label|:
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"<error value>"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
for|for
control|(
name|i
operator|=
name|low_bound
init|;
name|i
operator|<=
name|high_bound
condition|;
name|i
operator|++
control|)
block|{
name|int
name|element
init|=
name|value_bit_index
argument_list|(
name|type
argument_list|,
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|element
operator|<
literal|0
condition|)
block|{
name|i
operator|=
name|element
expr_stmt|;
goto|goto
name|maybe_bad_bstring
goto|;
block|}
if|if
condition|(
name|is_bitstring
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|element
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|element
condition|)
block|{
if|if
condition|(
name|need_comma
condition|)
name|fputs_filtered
argument_list|(
literal|", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_type_scalar
argument_list|(
name|range
argument_list|,
name|i
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<=
name|high_bound
operator|&&
name|value_bit_index
argument_list|(
name|type
argument_list|,
name|valaddr
operator|+
name|embedded_offset
argument_list|,
operator|++
name|i
argument_list|)
condition|)
block|{
name|int
name|j
init|=
name|i
decl_stmt|;
name|fputs_filtered
argument_list|(
literal|".."
argument_list|,
name|stream
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|+
literal|1
operator|<=
name|high_bound
operator|&&
name|value_bit_index
argument_list|(
name|type
argument_list|,
name|valaddr
operator|+
name|embedded_offset
argument_list|,
operator|++
name|i
argument_list|)
condition|)
name|j
operator|=
name|i
expr_stmt|;
name|print_type_scalar
argument_list|(
name|range
argument_list|,
name|j
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|done
label|:
if|if
condition|(
name|is_bitstring
condition|)
name|fputs_filtered
argument_list|(
literal|"'"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|"]"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_VOID
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"void"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_ERROR
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<error type>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_UNDEF
case|:
comment|/* This happens (without TYPE_FLAG_STUB set) on systems which don't use          dbx xrefs (NO_DBX_XREFS in gcc) if a file has a "struct foo *bar"          and no complete type for struct foo in that file.  */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<incomplete type>"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Invalid pascal type code %d in symbol table."
argument_list|,
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|gdb_flush
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|pascal_value_print
parameter_list|(
name|struct
name|value
modifier|*
name|val
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|format
parameter_list|,
name|enum
name|val_prettyprint
name|pretty
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
decl_stmt|;
comment|/* If it is a pointer, indicate what it points to.       Print type also if it is a reference.       Object pascal: if it is a member pointer, we will take care      of that when we print it.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_REF
condition|)
block|{
comment|/* Hack:  remove (char *) for char strings.  Their          type is indicated by the quoted string anyway. */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|&&
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|==
name|NULL
operator|&&
name|TYPE_NAME
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|NULL
operator|&&
name|STREQ
argument_list|(
name|TYPE_NAME
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
literal|"char"
argument_list|)
condition|)
block|{
comment|/* Print nothing */
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|") "
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|val_print
argument_list|(
name|type
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_EMBEDDED_OFFSET
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|val
argument_list|)
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|pretty
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************                     Inserted from cp-valprint ******************************************************************************/
end_comment

begin_decl_stmt
specifier|extern
name|int
name|vtblprint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls printing of vtbl's */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|objectprint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls looking up an object's derived type 				   using what we find in its vtables.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pascal_static_field_print
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls printing of static fields. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|dont_print_vb_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|dont_print_statmem_obstack
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|pascal_object_print_static_field
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|value
modifier|*
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|enum
name|val_prettyprint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pascal_object_print_value
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|CORE_ADDR
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|enum
name|val_prettyprint
parameter_list|,
name|struct
name|type
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|pascal_object_print_class_method
parameter_list|(
name|char
modifier|*
name|valaddr
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|domain
decl_stmt|;
name|struct
name|fn_field
modifier|*
name|f
init|=
name|NULL
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
name|int
name|len2
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|char
modifier|*
name|kind
init|=
literal|""
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|type
modifier|*
name|target_type
init|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|domain
operator|=
name|TYPE_DOMAIN_TYPE
argument_list|(
name|target_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|domain
operator|==
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<unknown>"
argument_list|)
expr_stmt|;
return|return;
block|}
name|addr
operator|=
name|unpack_pointer
argument_list|(
name|lookup_pointer_type
argument_list|(
name|builtin_type_void
argument_list|)
argument_list|,
name|valaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|METHOD_PTR_IS_VIRTUAL
argument_list|(
name|addr
argument_list|)
condition|)
block|{
name|offset
operator|=
name|METHOD_PTR_TO_VOFFSET
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|domain
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|f
operator|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|len2
operator|=
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len2
condition|;
name|j
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|TYPE_FN_FIELD_VOFFSET
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
operator|==
name|offset
condition|)
block|{
if|if
condition|(
name|TYPE_FN_FIELD_STUB
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
name|check_stub_method
argument_list|(
name|domain
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|kind
operator|=
literal|"virtual "
expr_stmt|;
goto|goto
name|common
goto|;
block|}
block|}
block|}
block|}
else|else
block|{
name|sym
operator|=
name|find_pc_function
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"invalid pointer to member function"
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|domain
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|f
operator|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|len2
operator|=
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len2
condition|;
name|j
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|TYPE_FN_FIELD_STUB
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
name|check_stub_method
argument_list|(
name|domain
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
block|{
goto|goto
name|common
goto|;
block|}
block|}
block|}
block|}
name|common
label|:
if|if
condition|(
name|i
operator|<
name|len
condition|)
block|{
name|char
modifier|*
name|demangled_name
decl_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|kind
argument_list|)
expr_stmt|;
name|demangled_name
operator|=
name|cplus_demangle
argument_list|(
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|,
name|DMGL_ANSI
operator||
name|DMGL_PARAMS
argument_list|)
expr_stmt|;
if|if
condition|(
name|demangled_name
operator|==
name|NULL
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<badly mangled name %s>"
argument_list|,
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|fputs_filtered
argument_list|(
name|demangled_name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|demangled_name
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|") %d"
argument_list|,
operator|(
name|int
operator|)
name|addr
operator|>>
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* It was changed to this after 2.4.5.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|pascal_vtbl_ptr_name
index|[]
init|=
block|{
literal|'_'
block|,
literal|'_'
block|,
literal|'v'
block|,
literal|'t'
block|,
literal|'b'
block|,
literal|'l'
block|,
literal|'_'
block|,
literal|'p'
block|,
literal|'t'
block|,
literal|'r'
block|,
literal|'_'
block|,
literal|'t'
block|,
literal|'y'
block|,
literal|'p'
block|,
literal|'e'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return truth value for assertion that TYPE is of the type    "pointer to virtual function".  */
end_comment

begin_function
name|int
name|pascal_object_is_vtbl_ptr_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|char
modifier|*
name|typename
init|=
name|type_name_no_tag
argument_list|(
name|type
argument_list|)
decl_stmt|;
return|return
operator|(
name|typename
operator|!=
name|NULL
operator|&&
operator|(
name|STREQ
argument_list|(
name|typename
argument_list|,
name|pascal_vtbl_ptr_name
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return truth value for the assertion that TYPE is of the type    "pointer to virtual function table".  */
end_comment

begin_function
name|int
name|pascal_object_is_vtbl_member
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
block|{
name|type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
condition|)
block|{
name|type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
comment|/* if not using thunks */
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
comment|/* if using thunks */
block|{
comment|/* Virtual functions tables are full of pointers 	         to virtual functions. */
return|return
name|pascal_object_is_vtbl_ptr_type
argument_list|(
name|type
argument_list|)
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Mutually recursive subroutines of pascal_object_print_value and c_val_print to    print out a structure's fields: pascal_object_print_value_fields and pascal_object_print_value.     TYPE, VALADDR, ADDRESS, STREAM, RECURSE, and PRETTY have the    same meanings as in pascal_object_print_value and c_val_print.     DONT_PRINT is an array of baseclass types that we    should not print, or zero if called from top level.  */
end_comment

begin_function
name|void
name|pascal_object_print_value_fields
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|valaddr
parameter_list|,
name|CORE_ADDR
name|address
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|format
parameter_list|,
name|int
name|recurse
parameter_list|,
name|enum
name|val_prettyprint
name|pretty
parameter_list|,
name|struct
name|type
modifier|*
modifier|*
name|dont_print_vb
parameter_list|,
name|int
name|dont_print_statmem
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|n_baseclasses
decl_stmt|;
name|struct
name|obstack
name|tmp_obstack
decl_stmt|;
name|char
modifier|*
name|last_dont_print
init|=
name|obstack_next_free
argument_list|(
operator|&
name|dont_print_statmem_obstack
argument_list|)
decl_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|n_baseclasses
operator|=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Print out baseclasses such that we don't print      duplicates of virtual baseclasses.  */
if|if
condition|(
name|n_baseclasses
operator|>
literal|0
condition|)
name|pascal_object_print_value
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
name|address
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|,
name|dont_print_vb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|len
operator|&&
name|n_baseclasses
operator|==
literal|1
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<No data fields>"
argument_list|)
expr_stmt|;
else|else
block|{
specifier|extern
name|int
name|inspect_it
decl_stmt|;
name|int
name|fields_seen
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dont_print_statmem
operator|==
literal|0
condition|)
block|{
comment|/* If we're at top level, carve out a completely fresh 	     chunk of the obstack and use that until this particular 	     invocation returns.  */
name|tmp_obstack
operator|=
name|dont_print_statmem_obstack
expr_stmt|;
name|obstack_finish
argument_list|(
operator|&
name|dont_print_statmem_obstack
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|n_baseclasses
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
comment|/* If requested, skip printing of static fields.  */
if|if
condition|(
operator|!
name|pascal_static_field_print
operator|&&
name|TYPE_FIELD_STATIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|fields_seen
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n_baseclasses
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|pretty
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"members of "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|type_name_no_tag
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|": "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
name|fields_seen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pretty
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wrap_here
argument_list|(
name|n_spaces
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inspect_it
condition|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
name|fputs_filtered
argument_list|(
literal|"\"( ptr \""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|"\"( nodef \""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FIELD_STATIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
name|fputs_filtered
argument_list|(
literal|"static "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_symbol_filtered
argument_list|(
name|stream
argument_list|,
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|language_cplus
argument_list|,
name|DMGL_PARAMS
operator||
name|DMGL_ANSI
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"\" \""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_symbol_filtered
argument_list|(
name|stream
argument_list|,
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|language_cplus
argument_list|,
name|DMGL_PARAMS
operator||
name|DMGL_ANSI
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"\") \""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|annotate_field_begin
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FIELD_STATIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
name|fputs_filtered
argument_list|(
literal|"static "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_symbol_filtered
argument_list|(
name|stream
argument_list|,
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|language_cplus
argument_list|,
name|DMGL_PARAMS
operator||
name|DMGL_ANSI
argument_list|)
expr_stmt|;
name|annotate_field_name_end
argument_list|()
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" = "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|annotate_field_value
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TYPE_FIELD_STATIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|&&
name|TYPE_FIELD_PACKED
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|struct
name|value
modifier|*
name|v
decl_stmt|;
comment|/* Bitfields require special handling, especially due to byte 	         order problems.  */
if|if
condition|(
name|TYPE_FIELD_IGNORE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"<optimized out or zero length>"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|v
operator|=
name|value_from_longest
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|unpack_field_as_long
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|val_print
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|v
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|TYPE_FIELD_IGNORE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"<optimized out or zero length>"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_FIELD_STATIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
comment|/* struct value *v = value_static_field (type, i); v4.17 specific */
name|struct
name|value
modifier|*
name|v
decl_stmt|;
name|v
operator|=
name|value_from_longest
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|unpack_field_as_long
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
name|NULL
condition|)
name|fputs_filtered
argument_list|(
literal|"<optimized out>"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|pascal_object_print_static_field
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|v
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* val_print (TYPE_FIELD_TYPE (type, i), 		     valaddr + TYPE_FIELD_BITPOS (type, i) / 8, 		     address + TYPE_FIELD_BITPOS (type, i) / 8, 0, 		     stream, format, 0, recurse + 1, pretty); */
name|val_print
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|valaddr
argument_list|,
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|/
literal|8
argument_list|,
name|address
operator|+
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|/
literal|8
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
block|}
block|}
name|annotate_field_end
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dont_print_statmem
operator|==
literal|0
condition|)
block|{
comment|/* Free the space used to deal with the printing 	     of the members from top level.  */
name|obstack_free
argument_list|(
operator|&
name|dont_print_statmem_obstack
argument_list|,
name|last_dont_print
argument_list|)
expr_stmt|;
name|dont_print_statmem_obstack
operator|=
name|tmp_obstack
expr_stmt|;
block|}
if|if
condition|(
name|pretty
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Special val_print routine to avoid printing multiple copies of virtual    baseclasses.  */
end_comment

begin_function
name|void
name|pascal_object_print_value
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|valaddr
parameter_list|,
name|CORE_ADDR
name|address
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|format
parameter_list|,
name|int
name|recurse
parameter_list|,
name|enum
name|val_prettyprint
name|pretty
parameter_list|,
name|struct
name|type
modifier|*
modifier|*
name|dont_print_vb
parameter_list|)
block|{
name|struct
name|obstack
name|tmp_obstack
decl_stmt|;
name|struct
name|type
modifier|*
modifier|*
name|last_dont_print
init|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|obstack_next_free
argument_list|(
operator|&
name|dont_print_vb_obstack
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|dont_print_vb
operator|==
literal|0
condition|)
block|{
comment|/* If we're at top level, carve out a completely fresh          chunk of the obstack and use that until this particular          invocation returns.  */
name|tmp_obstack
operator|=
name|dont_print_vb_obstack
expr_stmt|;
comment|/* Bump up the high-water mark.  Now alpha is omega.  */
name|obstack_finish
argument_list|(
operator|&
name|dont_print_vb_obstack
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|int
name|boffset
decl_stmt|;
name|struct
name|type
modifier|*
name|baseclass
init|=
name|check_typedef
argument_list|(
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|basename
init|=
name|TYPE_NAME
argument_list|(
name|baseclass
argument_list|)
decl_stmt|;
name|char
modifier|*
name|base_valaddr
decl_stmt|;
if|if
condition|(
name|BASETYPE_VIA_VIRTUAL
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|struct
name|type
modifier|*
modifier|*
name|first_dont_print
init|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|dont_print_vb_obstack
argument_list|)
decl_stmt|;
name|int
name|j
init|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|obstack_next_free
argument_list|(
operator|&
name|dont_print_vb_obstack
argument_list|)
operator|-
name|first_dont_print
decl_stmt|;
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
if|if
condition|(
name|baseclass
operator|==
name|first_dont_print
index|[
name|j
index|]
condition|)
goto|goto
name|flush_it
goto|;
name|obstack_ptr_grow
argument_list|(
operator|&
name|dont_print_vb_obstack
argument_list|,
name|baseclass
argument_list|)
expr_stmt|;
block|}
name|boffset
operator|=
name|baseclass_offset
argument_list|(
name|type
argument_list|,
name|i
argument_list|,
name|valaddr
argument_list|,
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|pretty
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
literal|"<"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* Not sure what the best notation is in the case where there is no          baseclass name.  */
name|fputs_filtered
argument_list|(
name|basename
condition|?
name|basename
else|:
literal|""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"> = "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* The virtual base class pointer might have been clobbered by the          user program. Make sure that it still points to a valid memory          location.  */
if|if
condition|(
name|boffset
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|boffset
operator|<
literal|0
operator|||
name|boffset
operator|>=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|)
condition|)
block|{
comment|/* FIXME (alloc): not safe is baseclass is really really big. */
name|base_valaddr
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|TYPE_LENGTH
argument_list|(
name|baseclass
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|address
operator|+
name|boffset
argument_list|,
name|base_valaddr
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|baseclass
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|boffset
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|base_valaddr
operator|=
name|valaddr
operator|+
name|boffset
expr_stmt|;
if|if
condition|(
name|boffset
operator|==
operator|-
literal|1
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<invalid address>"
argument_list|)
expr_stmt|;
else|else
name|pascal_object_print_value_fields
argument_list|(
name|baseclass
argument_list|,
name|base_valaddr
argument_list|,
name|address
operator|+
name|boffset
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|,
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|dont_print_vb_obstack
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|flush_it
label|:
empty_stmt|;
block|}
if|if
condition|(
name|dont_print_vb
operator|==
literal|0
condition|)
block|{
comment|/* Free the space used to deal with the printing          of this type from top level.  */
name|obstack_free
argument_list|(
operator|&
name|dont_print_vb_obstack
argument_list|,
name|last_dont_print
argument_list|)
expr_stmt|;
comment|/* Reset watermark so that we can continue protecting          ourselves from whatever we were protecting ourselves.  */
name|dont_print_vb_obstack
operator|=
name|tmp_obstack
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print value of a static member.    To avoid infinite recursion when printing a class that contains    a static instance of the class, we keep the addresses of all printed    static member classes in an obstack and refuse to print them more    than once.     VAL contains the value to print, TYPE, STREAM, RECURSE, and PRETTY    have the same meanings as in c_val_print.  */
end_comment

begin_function
specifier|static
name|void
name|pascal_object_print_static_field
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|value
modifier|*
name|val
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|format
parameter_list|,
name|int
name|recurse
parameter_list|,
name|enum
name|val_prettyprint
name|pretty
parameter_list|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
condition|)
block|{
name|CORE_ADDR
modifier|*
name|first_dont_print
decl_stmt|;
name|int
name|i
decl_stmt|;
name|first_dont_print
operator|=
operator|(
name|CORE_ADDR
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|dont_print_statmem_obstack
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
name|CORE_ADDR
operator|*
operator|)
name|obstack_next_free
argument_list|(
operator|&
name|dont_print_statmem_obstack
argument_list|)
operator|-
name|first_dont_print
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|==
name|first_dont_print
index|[
name|i
index|]
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"<same as static member of an already seen type>"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|obstack_grow
argument_list|(
operator|&
name|dont_print_statmem_obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|pascal_object_print_value_fields
argument_list|(
name|type
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|val_print
argument_list|(
name|type
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pascal_object_print_class_member
parameter_list|(
name|char
modifier|*
name|valaddr
parameter_list|,
name|struct
name|type
modifier|*
name|domain
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|char
modifier|*
name|prefix
parameter_list|)
block|{
comment|/* VAL is a byte offset into the structure type DOMAIN.      Find the name of the field for that offset and      print it.  */
name|int
name|extra
init|=
literal|0
decl_stmt|;
name|int
name|bits
init|=
literal|0
decl_stmt|;
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|len
init|=
name|TYPE_NFIELDS
argument_list|(
name|domain
argument_list|)
decl_stmt|;
comment|/* @@ Make VAL into bit offset */
name|LONGEST
name|val
init|=
name|unpack_long
argument_list|(
name|builtin_type_int
argument_list|,
name|valaddr
argument_list|)
operator|<<
literal|3
decl_stmt|;
for|for
control|(
name|i
operator|=
name|TYPE_N_BASECLASSES
argument_list|(
name|domain
argument_list|)
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|int
name|bitpos
init|=
name|TYPE_FIELD_BITPOS
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|QUIT
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|bitpos
condition|)
break|break;
if|if
condition|(
name|val
operator|<
name|bitpos
operator|&&
name|i
operator|!=
literal|0
condition|)
block|{
comment|/* Somehow pointing into a field.  */
name|i
operator|-=
literal|1
expr_stmt|;
name|extra
operator|=
operator|(
name|val
operator|-
name|TYPE_FIELD_BITPOS
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|extra
operator|&
literal|0x7
condition|)
name|bits
operator|=
literal|1
expr_stmt|;
else|else
name|extra
operator|>>=
literal|3
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|<
name|len
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|name
operator|=
name|type_name_no_tag
argument_list|(
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|fputs_filtered
argument_list|(
name|name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|pascal_type_print_base
argument_list|(
name|domain
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" + %d bytes"
argument_list|,
name|extra
argument_list|)
expr_stmt|;
if|if
condition|(
name|bits
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" (offset in bits)"
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%ld"
argument_list|,
call|(
name|long
name|int
call|)
argument_list|(
name|val
operator|>>
literal|3
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_pascal_valprint
parameter_list|(
name|void
parameter_list|)
block|{
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"pascal_static-members"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pascal_static_field_print
argument_list|,
literal|"Set printing of pascal static members."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
comment|/* Turn on printing of static fields.  */
name|pascal_static_field_print
operator|=
literal|1
expr_stmt|;
block|}
end_function

end_unit

