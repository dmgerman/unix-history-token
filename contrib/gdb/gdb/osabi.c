begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* OS ABI variant handling for GDB.    Copyright 2001, 2002, 2003 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,      but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.       You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"osabi.h"
end_include

begin_include
include|#
directive|include
file|"arch-utils.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|GDB_OSABI_DEFAULT
end_ifndef

begin_define
define|#
directive|define
name|GDB_OSABI_DEFAULT
value|GDB_OSABI_UNKNOWN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* State for the "set osabi" command.  */
end_comment

begin_enum
specifier|static
enum|enum
block|{
name|osabi_auto
block|,
name|osabi_default
block|,
name|osabi_user
block|}
name|user_osabi_state
enum|;
end_enum

begin_decl_stmt
specifier|static
name|enum
name|gdb_osabi
name|user_selected_osabi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|gdb_osabi_available_names
index|[
name|GDB_OSABI_INVALID
operator|+
literal|3
index|]
init|=
block|{
literal|"auto"
block|,
literal|"default"
block|,
literal|"none"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|set_osabi_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This table matches the indices assigned to enum gdb_osabi.  Keep    them in sync.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|gdb_osabi_names
index|[]
init|=
block|{
literal|"none"
block|,
literal|"SVR4"
block|,
literal|"GNU/Hurd"
block|,
literal|"Solaris"
block|,
literal|"OSF/1"
block|,
literal|"GNU/Linux"
block|,
literal|"FreeBSD a.out"
block|,
literal|"FreeBSD ELF"
block|,
literal|"NetBSD a.out"
block|,
literal|"NetBSD ELF"
block|,
literal|"OpenBSD ELF"
block|,
literal|"Windows CE"
block|,
literal|"DJGPP"
block|,
literal|"NetWare"
block|,
literal|"Irix"
block|,
literal|"LynxOS"
block|,
literal|"Interix"
block|,
literal|"HP/UX ELF"
block|,
literal|"HP/UX SOM"
block|,
literal|"ARM EABI v1"
block|,
literal|"ARM EABI v2"
block|,
literal|"ARM APCS"
block|,
literal|"QNX Neutrino"
block|,
literal|"Cygwin"
block|,
literal|"<invalid>"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|char
modifier|*
name|gdbarch_osabi_name
parameter_list|(
name|enum
name|gdb_osabi
name|osabi
parameter_list|)
block|{
if|if
condition|(
name|osabi
operator|>=
name|GDB_OSABI_UNKNOWN
operator|&&
name|osabi
operator|<
name|GDB_OSABI_INVALID
condition|)
return|return
name|gdb_osabi_names
index|[
name|osabi
index|]
return|;
return|return
name|gdb_osabi_names
index|[
name|GDB_OSABI_INVALID
index|]
return|;
block|}
end_function

begin_comment
comment|/* Handler for a given architecture/OS ABI pair.  There should be only    one handler for a given OS ABI each architecture family.  */
end_comment

begin_struct
struct|struct
name|gdb_osabi_handler
block|{
name|struct
name|gdb_osabi_handler
modifier|*
name|next
decl_stmt|;
specifier|const
name|struct
name|bfd_arch_info
modifier|*
name|arch_info
decl_stmt|;
name|enum
name|gdb_osabi
name|osabi
decl_stmt|;
name|void
function_decl|(
modifier|*
name|init_osabi
function_decl|)
parameter_list|(
name|struct
name|gdbarch_info
parameter_list|,
name|struct
name|gdbarch
modifier|*
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|gdb_osabi_handler
modifier|*
name|gdb_osabi_handler_list
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|gdbarch_register_osabi
parameter_list|(
name|enum
name|bfd_architecture
name|arch
parameter_list|,
name|unsigned
name|long
name|machine
parameter_list|,
name|enum
name|gdb_osabi
name|osabi
parameter_list|,
name|void
function_decl|(
modifier|*
name|init_osabi
function_decl|)
parameter_list|(
name|struct
name|gdbarch_info
parameter_list|,
name|struct
name|gdbarch
modifier|*
parameter_list|)
parameter_list|)
block|{
name|struct
name|gdb_osabi_handler
modifier|*
modifier|*
name|handler_p
decl_stmt|;
specifier|const
name|struct
name|bfd_arch_info
modifier|*
name|arch_info
init|=
name|bfd_lookup_arch
argument_list|(
name|arch
argument_list|,
name|machine
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|name_ptr
decl_stmt|;
comment|/* Registering an OS ABI handler for "unknown" is not allowed.  */
if|if
condition|(
name|osabi
operator|==
name|GDB_OSABI_UNKNOWN
condition|)
block|{
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"gdbarch_register_osabi: An attempt to register a handler for "
literal|"OS ABI \"%s\" for architecture %s was made.  The handler will "
literal|"not be registered"
argument_list|,
name|gdbarch_osabi_name
argument_list|(
name|osabi
argument_list|)
argument_list|,
name|bfd_printable_arch_mach
argument_list|(
name|arch
argument_list|,
name|machine
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|gdb_assert
argument_list|(
name|arch_info
argument_list|)
expr_stmt|;
for|for
control|(
name|handler_p
operator|=
operator|&
name|gdb_osabi_handler_list
init|;
operator|*
name|handler_p
operator|!=
name|NULL
condition|;
name|handler_p
operator|=
operator|&
operator|(
operator|*
name|handler_p
operator|)
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|handler_p
operator|)
operator|->
name|arch_info
operator|==
name|arch_info
operator|&&
operator|(
operator|*
name|handler_p
operator|)
operator|->
name|osabi
operator|==
name|osabi
condition|)
block|{
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"gdbarch_register_osabi: A handler for OS ABI \"%s\" "
literal|"has already been registered for architecture %s"
argument_list|,
name|gdbarch_osabi_name
argument_list|(
name|osabi
argument_list|)
argument_list|,
name|arch_info
operator|->
name|printable_name
argument_list|)
expr_stmt|;
comment|/* If user wants to continue, override previous definition.  */
operator|(
operator|*
name|handler_p
operator|)
operator|->
name|init_osabi
operator|=
name|init_osabi
expr_stmt|;
return|return;
block|}
block|}
operator|(
operator|*
name|handler_p
operator|)
operator|=
operator|(
expr|struct
name|gdb_osabi_handler
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|gdb_osabi_handler
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|handler_p
operator|)
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|handler_p
operator|)
operator|->
name|arch_info
operator|=
name|arch_info
expr_stmt|;
operator|(
operator|*
name|handler_p
operator|)
operator|->
name|osabi
operator|=
name|osabi
expr_stmt|;
operator|(
operator|*
name|handler_p
operator|)
operator|->
name|init_osabi
operator|=
name|init_osabi
expr_stmt|;
comment|/* Add this OS ABI to the list of enum values for "set osabi", if it isn't      already there.  */
for|for
control|(
name|name_ptr
operator|=
name|gdb_osabi_available_names
init|;
operator|*
name|name_ptr
condition|;
name|name_ptr
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|name_ptr
operator|==
name|gdbarch_osabi_name
argument_list|(
name|osabi
argument_list|)
condition|)
return|return;
block|}
operator|*
name|name_ptr
operator|++
operator|=
name|gdbarch_osabi_name
argument_list|(
name|osabi
argument_list|)
expr_stmt|;
operator|*
name|name_ptr
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Sniffer to find the OS ABI for a given file's architecture and flavour.     It is legal to have multiple sniffers for each arch/flavour pair, to    disambiguate one OS's a.out from another, for example.  The first sniffer    to return something other than GDB_OSABI_UNKNOWN wins, so a sniffer should    be careful to claim a file only if it knows for sure what it is.  */
end_comment

begin_struct
struct|struct
name|gdb_osabi_sniffer
block|{
name|struct
name|gdb_osabi_sniffer
modifier|*
name|next
decl_stmt|;
name|enum
name|bfd_architecture
name|arch
decl_stmt|;
comment|/* bfd_arch_unknown == wildcard */
name|enum
name|bfd_flavour
name|flavour
decl_stmt|;
name|enum
name|gdb_osabi
function_decl|(
modifier|*
name|sniffer
function_decl|)
parameter_list|(
name|bfd
modifier|*
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|gdb_osabi_sniffer
modifier|*
name|gdb_osabi_sniffer_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|gdbarch_register_osabi_sniffer
argument_list|(
expr|enum
name|bfd_architecture
name|arch
argument_list|,
expr|enum
name|bfd_flavour
name|flavour
argument_list|,
expr|enum
name|gdb_osabi
argument_list|(
operator|*
name|sniffer_fn
argument_list|)
argument_list|(
name|bfd
operator|*
argument_list|)
argument_list|)
block|{
name|struct
name|gdb_osabi_sniffer
modifier|*
name|sniffer
decl_stmt|;
name|sniffer
operator|=
operator|(
expr|struct
name|gdb_osabi_sniffer
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|gdb_osabi_sniffer
argument_list|)
argument_list|)
expr_stmt|;
name|sniffer
operator|->
name|arch
operator|=
name|arch
expr_stmt|;
name|sniffer
operator|->
name|flavour
operator|=
name|flavour
expr_stmt|;
name|sniffer
operator|->
name|sniffer
operator|=
name|sniffer_fn
expr_stmt|;
name|sniffer
operator|->
name|next
operator|=
name|gdb_osabi_sniffer_list
expr_stmt|;
name|gdb_osabi_sniffer_list
operator|=
name|sniffer
expr_stmt|;
block|}
end_decl_stmt

begin_escape
end_escape

begin_function
name|enum
name|gdb_osabi
name|gdbarch_lookup_osabi
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|gdb_osabi_sniffer
modifier|*
name|sniffer
decl_stmt|;
name|enum
name|gdb_osabi
name|osabi
decl_stmt|,
name|match
decl_stmt|;
name|int
name|match_specific
decl_stmt|;
comment|/* If we aren't in "auto" mode, return the specified OS ABI.  */
if|if
condition|(
name|user_osabi_state
operator|==
name|osabi_user
condition|)
return|return
name|user_selected_osabi
return|;
comment|/* If we don't have a binary, return the default OS ABI (if set) or      an inconclusive result (otherwise).  */
if|if
condition|(
name|abfd
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|GDB_OSABI_DEFAULT
operator|!=
name|GDB_OSABI_UNKNOWN
condition|)
return|return
name|GDB_OSABI_DEFAULT
return|;
else|else
return|return
name|GDB_OSABI_UNINITIALIZED
return|;
block|}
name|match
operator|=
name|GDB_OSABI_UNKNOWN
expr_stmt|;
name|match_specific
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sniffer
operator|=
name|gdb_osabi_sniffer_list
init|;
name|sniffer
operator|!=
name|NULL
condition|;
name|sniffer
operator|=
name|sniffer
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|sniffer
operator|->
name|arch
operator|==
name|bfd_arch_unknown
comment|/* wildcard */
operator|||
name|sniffer
operator|->
name|arch
operator|==
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
operator|)
operator|&&
name|sniffer
operator|->
name|flavour
operator|==
name|bfd_get_flavour
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
name|osabi
operator|=
call|(
modifier|*
name|sniffer
operator|->
name|sniffer
call|)
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|osabi
operator|<
name|GDB_OSABI_UNKNOWN
operator|||
name|osabi
operator|>=
name|GDB_OSABI_INVALID
condition|)
block|{
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"gdbarch_lookup_osabi: invalid OS ABI (%d) from sniffer "
literal|"for architecture %s flavour %d"
argument_list|,
operator|(
name|int
operator|)
name|osabi
argument_list|,
name|bfd_printable_arch_mach
argument_list|(
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|bfd_get_flavour
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|osabi
operator|!=
name|GDB_OSABI_UNKNOWN
condition|)
block|{
comment|/* A specific sniffer always overrides a generic sniffer. 		 Croak on multiple match if the two matches are of the 		 same class.  If the user wishes to continue, we'll use 		 the first match.  */
if|if
condition|(
name|match
operator|!=
name|GDB_OSABI_UNKNOWN
condition|)
block|{
if|if
condition|(
operator|(
name|match_specific
operator|&&
name|sniffer
operator|->
name|arch
operator|!=
name|bfd_arch_unknown
operator|)
operator|||
operator|(
operator|!
name|match_specific
operator|&&
name|sniffer
operator|->
name|arch
operator|==
name|bfd_arch_unknown
operator|)
condition|)
block|{
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"gdbarch_lookup_osabi: multiple %sspecific OS ABI "
literal|"match for architecture %s flavour %d: first "
literal|"match \"%s\", second match \"%s\""
argument_list|,
name|match_specific
condition|?
literal|""
else|:
literal|"non-"
argument_list|,
name|bfd_printable_arch_mach
argument_list|(
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|bfd_get_flavour
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|gdbarch_osabi_name
argument_list|(
name|match
argument_list|)
argument_list|,
name|gdbarch_osabi_name
argument_list|(
name|osabi
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sniffer
operator|->
name|arch
operator|!=
name|bfd_arch_unknown
condition|)
block|{
name|match
operator|=
name|osabi
expr_stmt|;
name|match_specific
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|match
operator|=
name|osabi
expr_stmt|;
if|if
condition|(
name|sniffer
operator|->
name|arch
operator|!=
name|bfd_arch_unknown
condition|)
name|match_specific
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* If we didn't find a match, but a default was specified at configure      time, return the default.  */
if|if
condition|(
name|GDB_OSABI_DEFAULT
operator|!=
name|GDB_OSABI_UNKNOWN
operator|&&
name|match
operator|==
name|GDB_OSABI_UNKNOWN
condition|)
return|return
name|GDB_OSABI_DEFAULT
return|;
else|else
return|return
name|match
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if architecture A can run code written for    architecture B.  */
end_comment

begin_function
specifier|static
name|int
name|can_run_code_for
parameter_list|(
specifier|const
name|struct
name|bfd_arch_info
modifier|*
name|a
parameter_list|,
specifier|const
name|struct
name|bfd_arch_info
modifier|*
name|b
parameter_list|)
block|{
comment|/* BFD's 'A->compatible (A, B)' functions return zero if A and B are      incompatible.  But if they are compatible, it returns the 'more      featureful' of the two arches.  That is, if A can run code      written for B, but B can't run code written for A, then it'll      return A.       struct bfd_arch_info objects are singletons: that is, there's      supposed to be exactly one instance for a given machine.  So you      can tell whether two are equivalent by comparing pointers.  */
return|return
operator|(
name|a
operator|==
name|b
operator|||
name|a
operator|->
name|compatible
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|==
name|a
operator|)
return|;
block|}
end_function

begin_function
name|void
name|gdbarch_init_osabi
parameter_list|(
name|struct
name|gdbarch_info
name|info
parameter_list|,
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|)
block|{
name|struct
name|gdb_osabi_handler
modifier|*
name|handler
decl_stmt|;
if|if
condition|(
name|info
operator|.
name|osabi
operator|==
name|GDB_OSABI_UNKNOWN
condition|)
block|{
comment|/* Don't complain about an unknown OSABI.  Assume the user knows          what they are doing.  */
return|return;
block|}
for|for
control|(
name|handler
operator|=
name|gdb_osabi_handler_list
init|;
name|handler
operator|!=
name|NULL
condition|;
name|handler
operator|=
name|handler
operator|->
name|next
control|)
block|{
if|if
condition|(
name|handler
operator|->
name|osabi
operator|!=
name|info
operator|.
name|osabi
condition|)
continue|continue;
comment|/* If the architecture described by ARCH_INFO can run code for          the architcture we registered the handler for, then the          handler is applicable.  Note, though, that if the handler is          for an architecture that is a superset of ARCH_INFO, we can't          use that --- it would be perfectly correct for it to install          gdbarch methods that refer to registers / instructions /          other facilities ARCH_INFO doesn't have.           NOTE: kettenis/20021027: There may be more than one machine 	 type that is compatible with the desired machine type.  Right 	 now we simply return the first match, which is fine for now. 	 However, we might want to do something smarter in the future.  */
comment|/* NOTE: cagney/2003-10-23: The code for "a can_run_code_for b"          is implemented using BFD's compatible method (a->compatible          (b) == a -- the lowest common denominator between a and b is          a).  That method's definition of compatible may not be as you          expect.  For instance the test "amd64 can run code for i386"          (or more generally "64-bit ISA can run code for the 32-bit          ISA").  BFD doesn't normally consider 32-bit and 64-bit          "compatible" so it doesn't succeed.  */
if|if
condition|(
name|can_run_code_for
argument_list|(
name|info
operator|.
name|bfd_arch_info
argument_list|,
name|handler
operator|->
name|arch_info
argument_list|)
condition|)
block|{
call|(
modifier|*
name|handler
operator|->
name|init_osabi
call|)
argument_list|(
name|info
argument_list|,
name|gdbarch
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|warning
argument_list|(
literal|"A handler for the OS ABI \"%s\" is not built into this configuration\n"
literal|"of GDB.  Attempting to continue with the default %s settings.\n"
argument_list|,
name|gdbarch_osabi_name
argument_list|(
name|info
operator|.
name|osabi
argument_list|)
argument_list|,
name|info
operator|.
name|bfd_arch_info
operator|->
name|printable_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Limit on the amount of data to be read.  */
end_comment

begin_define
define|#
directive|define
name|MAX_NOTESZ
value|128
end_define

begin_comment
comment|/* Return non-zero if NOTE matches NAME, DESCSZ and TYPE.  */
end_comment

begin_function
specifier|static
name|int
name|check_note
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sect
parameter_list|,
specifier|const
name|char
modifier|*
name|note
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|long
name|descsz
parameter_list|,
name|unsigned
name|long
name|type
parameter_list|)
block|{
name|unsigned
name|long
name|notesz
decl_stmt|;
comment|/* Calculate the size of this note.  */
name|notesz
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|notesz
operator|=
operator|(
operator|(
name|notesz
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
operator|)
expr_stmt|;
name|notesz
operator|+=
name|descsz
expr_stmt|;
name|notesz
operator|=
operator|(
operator|(
name|notesz
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
operator|)
expr_stmt|;
comment|/* If this assertion triggers, increase MAX_NOTESZ.  */
name|gdb_assert
argument_list|(
name|notesz
operator|<=
name|MAX_NOTESZ
argument_list|)
expr_stmt|;
comment|/* Check whether SECT is big enough to comtain the complete note.  */
if|if
condition|(
name|notesz
operator|>
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Check the note name.  */
if|if
condition|(
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|note
argument_list|)
operator|!=
operator|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
operator|)
operator|||
name|strcmp
argument_list|(
name|note
operator|+
literal|12
argument_list|,
name|name
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Check the descriptor size.  */
if|if
condition|(
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|note
operator|+
literal|4
argument_list|)
operator|!=
name|descsz
condition|)
return|return
literal|0
return|;
comment|/* Check the note type.  */
if|if
condition|(
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|note
operator|+
literal|8
argument_list|)
operator|!=
name|type
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Generic sniffer for ELF flavoured files.  */
end_comment

begin_function
name|void
name|generic_elf_osabi_sniff_abi_tag_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sect
parameter_list|,
name|void
modifier|*
name|obj
parameter_list|)
block|{
name|enum
name|gdb_osabi
modifier|*
name|osabi
init|=
name|obj
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|sectsize
decl_stmt|;
name|char
modifier|*
name|note
decl_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
expr_stmt|;
name|sectsize
operator|=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
expr_stmt|;
comment|/* Limit the amount of data to read.  */
if|if
condition|(
name|sectsize
operator|>
name|MAX_NOTESZ
condition|)
name|sectsize
operator|=
name|MAX_NOTESZ
expr_stmt|;
name|note
operator|=
name|alloca
argument_list|(
name|sectsize
argument_list|)
expr_stmt|;
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|,
name|note
argument_list|,
literal|0
argument_list|,
name|sectsize
argument_list|)
expr_stmt|;
comment|/* .note.ABI-tag notes, used by GNU/Linux and FreeBSD.  */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".note.ABI-tag"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* GNU.  */
if|if
condition|(
name|check_note
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|,
name|note
argument_list|,
literal|"GNU"
argument_list|,
literal|16
argument_list|,
name|NT_GNU_ABI_TAG
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|abi_tag
init|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|note
operator|+
literal|16
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|abi_tag
condition|)
block|{
case|case
name|GNU_ABI_TAG_LINUX
case|:
operator|*
name|osabi
operator|=
name|GDB_OSABI_LINUX
expr_stmt|;
break|break;
case|case
name|GNU_ABI_TAG_HURD
case|:
operator|*
name|osabi
operator|=
name|GDB_OSABI_HURD
expr_stmt|;
break|break;
case|case
name|GNU_ABI_TAG_SOLARIS
case|:
operator|*
name|osabi
operator|=
name|GDB_OSABI_SOLARIS
expr_stmt|;
break|break;
case|case
name|GNU_ABI_TAG_FREEBSD
case|:
operator|*
name|osabi
operator|=
name|GDB_OSABI_FREEBSD_ELF
expr_stmt|;
break|break;
case|case
name|GNU_ABI_TAG_NETBSD
case|:
operator|*
name|osabi
operator|=
name|GDB_OSABI_NETBSD_ELF
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"\ generic_elf_osabi_sniff_abi_tag_sections: unknown OS number %d"
argument_list|,
name|abi_tag
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* FreeBSD.  */
if|if
condition|(
name|check_note
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|,
name|note
argument_list|,
literal|"FreeBSD"
argument_list|,
literal|4
argument_list|,
name|NT_FREEBSD_ABI_TAG
argument_list|)
condition|)
block|{
comment|/* There is no need to check the version yet.  */
operator|*
name|osabi
operator|=
name|GDB_OSABI_FREEBSD_ELF
expr_stmt|;
return|return;
block|}
return|return;
block|}
comment|/* .note.netbsd.ident notes, used by NetBSD.  */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".note.netbsd.ident"
argument_list|)
operator|==
literal|0
operator|&&
name|check_note
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|,
name|note
argument_list|,
literal|"NetBSD"
argument_list|,
literal|4
argument_list|,
name|NT_NETBSD_IDENT
argument_list|)
condition|)
block|{
comment|/* There is no need to check the version yet.  */
operator|*
name|osabi
operator|=
name|GDB_OSABI_NETBSD_ELF
expr_stmt|;
return|return;
block|}
comment|/* .note.openbsd.ident notes, used by OpenBSD.  */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".note.openbsd.ident"
argument_list|)
operator|==
literal|0
operator|&&
name|check_note
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|,
name|note
argument_list|,
literal|"OpenBSD"
argument_list|,
literal|4
argument_list|,
name|NT_OPENBSD_IDENT
argument_list|)
condition|)
block|{
comment|/* There is no need to check the version yet.  */
operator|*
name|osabi
operator|=
name|GDB_OSABI_OPENBSD_ELF
expr_stmt|;
return|return;
block|}
comment|/* .note.netbsdcore.procinfo notes, used by NetBSD.  */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".note.netbsdcore.procinfo"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|osabi
operator|=
name|GDB_OSABI_NETBSD_ELF
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|enum
name|gdb_osabi
name|generic_elf_osabi_sniffer
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|unsigned
name|int
name|elfosabi
decl_stmt|;
name|enum
name|gdb_osabi
name|osabi
init|=
name|GDB_OSABI_UNKNOWN
decl_stmt|;
name|elfosabi
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_ident
index|[
name|EI_OSABI
index|]
expr_stmt|;
switch|switch
condition|(
name|elfosabi
condition|)
block|{
case|case
name|ELFOSABI_NONE
case|:
comment|/* When elfosabi is ELFOSABI_NONE (0), then the ELF structures in the          file are conforming to the base specification for that machine 	 (there are no OS-specific extensions).  In order to determine the 	 real OS in use we must look for OS notes that have been added.  */
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|generic_elf_osabi_sniff_abi_tag_sections
argument_list|,
operator|&
name|osabi
argument_list|)
expr_stmt|;
break|break;
case|case
name|ELFOSABI_FREEBSD
case|:
name|osabi
operator|=
name|GDB_OSABI_FREEBSD_ELF
expr_stmt|;
break|break;
case|case
name|ELFOSABI_NETBSD
case|:
name|osabi
operator|=
name|GDB_OSABI_NETBSD_ELF
expr_stmt|;
break|break;
case|case
name|ELFOSABI_LINUX
case|:
name|osabi
operator|=
name|GDB_OSABI_LINUX
expr_stmt|;
break|break;
case|case
name|ELFOSABI_HURD
case|:
name|osabi
operator|=
name|GDB_OSABI_HURD
expr_stmt|;
break|break;
case|case
name|ELFOSABI_SOLARIS
case|:
name|osabi
operator|=
name|GDB_OSABI_SOLARIS
expr_stmt|;
break|break;
case|case
name|ELFOSABI_HPUX
case|:
name|osabi
operator|=
name|GDB_OSABI_HPUX_ELF
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|osabi
operator|==
name|GDB_OSABI_UNKNOWN
condition|)
block|{
comment|/* The FreeBSD folks have been naughty; they stored the string          "FreeBSD" in the padding of the e_ident field of the ELF          header to "brand" their ELF binaries in FreeBSD 3.x.  */
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_ident
index|[
literal|8
index|]
argument_list|,
literal|"FreeBSD"
argument_list|)
operator|==
literal|0
condition|)
name|osabi
operator|=
name|GDB_OSABI_FREEBSD_ELF
expr_stmt|;
block|}
return|return
name|osabi
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|set_osabi
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|struct
name|gdbarch_info
name|info
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|set_osabi_string
argument_list|,
literal|"auto"
argument_list|)
operator|==
literal|0
condition|)
name|user_osabi_state
operator|=
name|osabi_auto
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|set_osabi_string
argument_list|,
literal|"default"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|user_selected_osabi
operator|=
name|GDB_OSABI_DEFAULT
expr_stmt|;
name|user_osabi_state
operator|=
name|osabi_user
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|set_osabi_string
argument_list|,
literal|"none"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|user_selected_osabi
operator|=
name|GDB_OSABI_UNKNOWN
expr_stmt|;
name|user_osabi_state
operator|=
name|osabi_user
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|GDB_OSABI_INVALID
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|set_osabi_string
argument_list|,
name|gdbarch_osabi_name
argument_list|(
name|i
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|user_selected_osabi
operator|=
name|i
expr_stmt|;
name|user_osabi_state
operator|=
name|osabi_user
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|GDB_OSABI_INVALID
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Invalid OS ABI \"%s\" passed to command handler."
argument_list|,
name|set_osabi_string
argument_list|)
expr_stmt|;
block|}
comment|/* NOTE: At some point (true multiple architectures) we'll need to be more      graceful here.  */
name|gdbarch_info_init
argument_list|(
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gdbarch_update_p
argument_list|(
name|info
argument_list|)
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Updating OS ABI failed."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_osabi
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|user_osabi_state
operator|==
name|osabi_auto
condition|)
name|printf_filtered
argument_list|(
literal|"The current OS ABI is \"auto\" (currently \"%s\").\n"
argument_list|,
name|gdbarch_osabi_name
argument_list|(
name|gdbarch_osabi
argument_list|(
name|current_gdbarch
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"The current OS ABI is \"%s\".\n"
argument_list|,
name|gdbarch_osabi_name
argument_list|(
name|user_selected_osabi
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GDB_OSABI_DEFAULT
operator|!=
name|GDB_OSABI_UNKNOWN
condition|)
name|printf_filtered
argument_list|(
literal|"The default OS ABI is \"%s\".\n"
argument_list|,
name|gdbarch_osabi_name
argument_list|(
name|GDB_OSABI_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|extern
name|initialize_file_ftype
name|_initialize_gdb_osabi
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -Wmissing-prototype */
end_comment

begin_function
name|void
name|_initialize_gdb_osabi
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|gdb_osabi_names
index|[
name|GDB_OSABI_INVALID
index|]
argument_list|,
literal|"<invalid>"
argument_list|)
operator|!=
literal|0
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"_initialize_gdb_osabi: gdb_osabi_names[] is inconsistent"
argument_list|)
expr_stmt|;
comment|/* Register a generic sniffer for ELF flavoured files.  */
name|gdbarch_register_osabi_sniffer
argument_list|(
name|bfd_arch_unknown
argument_list|,
name|bfd_target_elf_flavour
argument_list|,
name|generic_elf_osabi_sniffer
argument_list|)
expr_stmt|;
comment|/* Register the "set osabi" command.  */
name|c
operator|=
name|add_set_enum_cmd
argument_list|(
literal|"osabi"
argument_list|,
name|class_support
argument_list|,
name|gdb_osabi_available_names
argument_list|,
operator|&
name|set_osabi_string
argument_list|,
literal|"Set OS ABI of target."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|set_cmd_sfunc
argument_list|(
name|c
argument_list|,
name|set_osabi
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"osabi"
argument_list|,
name|class_support
argument_list|,
name|show_osabi
argument_list|,
literal|"Show OS/ABI of target."
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|user_osabi_state
operator|=
name|osabi_auto
expr_stmt|;
block|}
end_function

end_unit

