begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Shared code to pre-read a stab (dbx-style), when building a psymtab.    Copyright 1986, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 1998    Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* The following need to be defined:    SET_NAMESTRING() --Set namestring to name of symbol.    CUR_SYMBOL_TYPE --Type code of current symbol.    CUR_SYMBOL_VALUE --Value field of current symbol.  May be adjusted here.    namestring - variable pointing to the name of the stab.    section_offsets - variable pointing to the section offsets.    pst - the partial symbol table being built.     psymtab_include_list, includes_used, includes_allocated - list of include      file names (N_SOL) seen so far.    dependency_list, dependencies_used, dependencies_allocated - list of      N_EXCL stabs seen so far.     END_PSYMTAB -- end a partial symbol table.    START_PSYMTAB -- start a partial symbol table.  */
end_comment

begin_comment
comment|/* End of macro definitions, now let's handle them symbols!  */
end_comment

begin_switch
switch|switch
condition|(
name|CUR_SYMBOL_TYPE
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* 	   * Standard, external, non-debugger, symbols 	   */
case|case
name|N_TEXT
operator||
name|N_EXT
case|:
case|case
name|N_NBTEXT
operator||
name|N_EXT
case|:
name|CUR_SYMBOL_VALUE
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
goto|goto
name|record_it
goto|;
case|case
name|N_DATA
operator||
name|N_EXT
case|:
case|case
name|N_NBDATA
operator||
name|N_EXT
case|:
name|CUR_SYMBOL_VALUE
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_DATA
argument_list|)
expr_stmt|;
goto|goto
name|record_it
goto|;
case|case
name|N_BSS
case|:
case|case
name|N_BSS
operator||
name|N_EXT
case|:
case|case
name|N_NBBSS
operator||
name|N_EXT
case|:
case|case
name|N_SETV
operator||
name|N_EXT
case|:
comment|/* FIXME, is this in BSS? */
name|CUR_SYMBOL_VALUE
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_BSS
argument_list|)
expr_stmt|;
goto|goto
name|record_it
goto|;
case|case
name|N_ABS
operator||
name|N_EXT
case|:
name|record_it
label|:
ifdef|#
directive|ifdef
name|DBXREAD_ONLY
name|SET_NAMESTRING
argument_list|()
expr_stmt|;
name|bss_ext_symbol
label|:
name|record_minimal_symbol
argument_list|(
name|namestring
argument_list|,
name|CUR_SYMBOL_VALUE
argument_list|,
name|CUR_SYMBOL_TYPE
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Always */
endif|#
directive|endif
comment|/* DBXREAD_ONLY */
continue|continue;
comment|/* Standard, local, non-debugger, symbols */
case|case
name|N_NBTEXT
case|:
comment|/* We need to be able to deal with both N_FN or N_TEXT, 	     because we have no way of knowing whether the sys-supplied ld 	     or GNU ld was used to make the executable.  Sequents throw 	     in another wrinkle -- they renumbered N_FN.  */
case|case
name|N_FN
case|:
case|case
name|N_FN_SEQ
case|:
case|case
name|N_TEXT
case|:
ifdef|#
directive|ifdef
name|DBXREAD_ONLY
name|CUR_SYMBOL_VALUE
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
name|SET_NAMESTRING
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|namestring
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|namestring
index|[
literal|1
index|]
operator|==
literal|'l'
operator|)
operator|||
operator|(
name|namestring
index|[
operator|(
name|nsl
operator|=
name|strlen
argument_list|(
name|namestring
argument_list|)
operator|)
operator|-
literal|1
index|]
operator|==
literal|'o'
operator|&&
name|namestring
index|[
name|nsl
operator|-
literal|2
index|]
operator|==
literal|'.'
operator|)
condition|)
block|{
if|if
condition|(
name|objfile
operator|->
name|ei
operator|.
name|entry_point
operator|<
name|CUR_SYMBOL_VALUE
operator|&&
name|objfile
operator|->
name|ei
operator|.
name|entry_point
operator|>=
name|last_o_file_start
condition|)
block|{
name|objfile
operator|->
name|ei
operator|.
name|entry_file_lowpc
operator|=
name|last_o_file_start
expr_stmt|;
name|objfile
operator|->
name|ei
operator|.
name|entry_file_highpc
operator|=
name|CUR_SYMBOL_VALUE
expr_stmt|;
block|}
if|if
condition|(
name|past_first_source_file
operator|&&
name|pst
comment|/* The gould NP1 uses low values for .o and -l symbols 		     which are not the address.  */
operator|&&
name|CUR_SYMBOL_VALUE
operator|>=
name|pst
operator|->
name|textlow
condition|)
block|{
name|END_PSYMTAB
argument_list|(
name|pst
argument_list|,
name|psymtab_include_list
argument_list|,
name|includes_used
argument_list|,
name|symnum
operator|*
name|symbol_size
argument_list|,
name|CUR_SYMBOL_VALUE
operator|>
name|pst
operator|->
name|texthigh
condition|?
name|CUR_SYMBOL_VALUE
else|:
name|pst
operator|->
name|texthigh
argument_list|,
name|dependency_list
argument_list|,
name|dependencies_used
argument_list|,
name|textlow_not_set
argument_list|)
expr_stmt|;
name|pst
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
literal|0
expr_stmt|;
name|includes_used
operator|=
literal|0
expr_stmt|;
name|dependencies_used
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|past_first_source_file
operator|=
literal|1
expr_stmt|;
name|last_o_file_start
operator|=
name|CUR_SYMBOL_VALUE
expr_stmt|;
block|}
else|else
goto|goto
name|record_it
goto|;
endif|#
directive|endif
comment|/* DBXREAD_ONLY */
continue|continue;
case|case
name|N_DATA
case|:
name|CUR_SYMBOL_VALUE
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_DATA
argument_list|)
expr_stmt|;
goto|goto
name|record_it
goto|;
case|case
name|N_UNDF
operator||
name|N_EXT
case|:
ifdef|#
directive|ifdef
name|DBXREAD_ONLY
if|if
condition|(
name|CUR_SYMBOL_VALUE
operator|!=
literal|0
condition|)
block|{
comment|/* This is a "Fortran COMMON" symbol.  See if the target 	       environment knows where it has been relocated to.  */
name|CORE_ADDR
name|reladdr
decl_stmt|;
name|SET_NAMESTRING
argument_list|()
expr_stmt|;
if|if
condition|(
name|target_lookup_symbol
argument_list|(
name|namestring
argument_list|,
operator|&
name|reladdr
argument_list|)
condition|)
block|{
continue|continue;
comment|/* Error in lookup; ignore symbol for now.  */
block|}
name|CUR_SYMBOL_TYPE
operator|^=
operator|(
name|N_BSS
operator|^
name|N_UNDF
operator|)
expr_stmt|;
comment|/* Define it as a bss-symbol */
name|CUR_SYMBOL_VALUE
operator|=
name|reladdr
expr_stmt|;
goto|goto
name|bss_ext_symbol
goto|;
block|}
endif|#
directive|endif
comment|/* DBXREAD_ONLY */
continue|continue;
comment|/* Just undefined, not COMMON */
case|case
name|N_UNDF
case|:
ifdef|#
directive|ifdef
name|DBXREAD_ONLY
if|if
condition|(
name|processing_acc_compilation
operator|&&
name|CUR_SYMBOL_STRX
operator|==
literal|1
condition|)
block|{
comment|/* Deal with relative offsets in the string table 	       used in ELF+STAB under Solaris.  If we want to use the 	       n_strx field, which contains the name of the file, 	       we must adjust file_string_table_offset *before* calling 	       SET_NAMESTRING().  */
name|past_first_source_file
operator|=
literal|1
expr_stmt|;
name|file_string_table_offset
operator|=
name|next_file_string_table_offset
expr_stmt|;
name|next_file_string_table_offset
operator|=
name|file_string_table_offset
operator|+
name|CUR_SYMBOL_VALUE
expr_stmt|;
if|if
condition|(
name|next_file_string_table_offset
operator|<
name|file_string_table_offset
condition|)
name|error
argument_list|(
literal|"string table offset backs up at %d"
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
comment|/* FIXME -- replace error() with complaint.  */
continue|continue;
block|}
endif|#
directive|endif
comment|/* DBXREAD_ONLY */
continue|continue;
comment|/* Lots of symbol types we can just ignore.  */
case|case
name|N_ABS
case|:
case|case
name|N_NBDATA
case|:
case|case
name|N_NBBSS
case|:
continue|continue;
comment|/* Keep going . . .*/
comment|/* 	   * Special symbol types for GNU 	   */
case|case
name|N_INDR
case|:
case|case
name|N_INDR
operator||
name|N_EXT
case|:
case|case
name|N_SETA
case|:
case|case
name|N_SETA
operator||
name|N_EXT
case|:
case|case
name|N_SETT
case|:
case|case
name|N_SETT
operator||
name|N_EXT
case|:
case|case
name|N_SETD
case|:
case|case
name|N_SETD
operator||
name|N_EXT
case|:
case|case
name|N_SETB
case|:
case|case
name|N_SETB
operator||
name|N_EXT
case|:
case|case
name|N_SETV
case|:
continue|continue;
comment|/* 	   * Debugger symbols 	   */
case|case
name|N_SO
case|:
block|{
name|unsigned
name|long
name|valu
decl_stmt|;
specifier|static
name|int
name|prev_so_symnum
init|=
operator|-
literal|10
decl_stmt|;
specifier|static
name|int
name|first_so_symnum
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|prev_textlow_not_set
decl_stmt|;
name|valu
operator|=
name|CUR_SYMBOL_VALUE
operator|+
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
name|prev_textlow_not_set
operator|=
name|textlow_not_set
expr_stmt|;
ifdef|#
directive|ifdef
name|SOFUN_ADDRESS_MAYBE_MISSING
comment|/* A zero value is probably an indication for the SunPRO 3.0 	     compiler. end_psymtab explicitly tests for zero, so 	     don't relocate it.  */
if|if
condition|(
name|CUR_SYMBOL_VALUE
operator|==
literal|0
condition|)
block|{
name|textlow_not_set
operator|=
literal|1
expr_stmt|;
name|valu
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|textlow_not_set
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|textlow_not_set
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|past_first_source_file
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|prev_so_symnum
operator|!=
name|symnum
operator|-
literal|1
condition|)
block|{
comment|/* Here if prev stab wasn't N_SO */
name|first_so_symnum
operator|=
name|symnum
expr_stmt|;
if|if
condition|(
name|pst
condition|)
block|{
name|END_PSYMTAB
argument_list|(
name|pst
argument_list|,
name|psymtab_include_list
argument_list|,
name|includes_used
argument_list|,
name|symnum
operator|*
name|symbol_size
argument_list|,
name|valu
operator|>
name|pst
operator|->
name|texthigh
condition|?
name|valu
else|:
name|pst
operator|->
name|texthigh
argument_list|,
name|dependency_list
argument_list|,
name|dependencies_used
argument_list|,
name|prev_textlow_not_set
argument_list|)
expr_stmt|;
name|pst
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
literal|0
expr_stmt|;
name|includes_used
operator|=
literal|0
expr_stmt|;
name|dependencies_used
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|prev_so_symnum
operator|=
name|symnum
expr_stmt|;
comment|/* End the current partial symtab and start a new one */
name|SET_NAMESTRING
argument_list|()
expr_stmt|;
comment|/* Null name means end of .o file.  Don't start a new one. */
if|if
condition|(
operator|*
name|namestring
operator|==
literal|'\000'
condition|)
continue|continue;
comment|/* Some compilers (including gcc) emit a pair of initial N_SOs. 	     The first one is a directory name; the second the file name. 	     If pst exists, is empty, and has a filename ending in '/', 	     we assume the previous N_SO was a directory name. */
name|p
operator|=
name|strrchr
argument_list|(
name|namestring
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|&&
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|'\000'
condition|)
continue|continue;
comment|/* Simply ignore directory name SOs */
comment|/* Some other compilers (C++ ones in particular) emit useless 	     SOs for non-existant .c files.  We ignore all subsequent SOs that 	     immediately follow the first.  */
if|if
condition|(
operator|!
name|pst
condition|)
name|pst
operator|=
name|START_PSYMTAB
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|,
name|namestring
argument_list|,
name|valu
argument_list|,
name|first_so_symnum
operator|*
name|symbol_size
argument_list|,
name|objfile
operator|->
name|global_psymbols
operator|.
name|next
argument_list|,
name|objfile
operator|->
name|static_psymbols
operator|.
name|next
argument_list|)
expr_stmt|;
continue|continue;
block|}
case|case
name|N_BINCL
case|:
block|{
ifdef|#
directive|ifdef
name|DBXREAD_ONLY
name|enum
name|language
name|tmp_language
decl_stmt|;
comment|/* Add this bincl to the bincl_list for future EXCLs.  No 	       need to save the string; it'll be around until 	       read_dbx_symtab function returns */
name|SET_NAMESTRING
argument_list|()
expr_stmt|;
name|tmp_language
operator|=
name|deduce_language_from_filename
argument_list|(
name|namestring
argument_list|)
expr_stmt|;
comment|/* Only change the psymtab's language if we've learned 	       something useful (eg. tmp_language is not language_unknown). 	       In addition, to match what start_subfile does, never change 	       from C++ to C.  */
if|if
condition|(
name|tmp_language
operator|!=
name|language_unknown
operator|&&
operator|(
name|tmp_language
operator|!=
name|language_c
operator|||
name|psymtab_language
operator|!=
name|language_cplus
operator|)
condition|)
name|psymtab_language
operator|=
name|tmp_language
expr_stmt|;
if|if
condition|(
name|pst
operator|==
name|NULL
condition|)
block|{
comment|/* FIXME: we should not get here without a PST to work on. 		   Attempt to recover.  */
name|complain
argument_list|(
operator|&
name|unclaimed_bincl_complaint
argument_list|,
name|namestring
argument_list|,
name|symnum
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|add_bincl_to_list
argument_list|(
name|pst
argument_list|,
name|namestring
argument_list|,
name|CUR_SYMBOL_VALUE
argument_list|)
expr_stmt|;
comment|/* Mark down an include file in the current psymtab */
goto|goto
name|record_include_file
goto|;
else|#
directive|else
comment|/* DBXREAD_ONLY */
continue|continue;
endif|#
directive|endif
block|}
case|case
name|N_SOL
case|:
block|{
name|enum
name|language
name|tmp_language
decl_stmt|;
comment|/* Mark down an include file in the current psymtab */
name|SET_NAMESTRING
argument_list|()
expr_stmt|;
name|tmp_language
operator|=
name|deduce_language_from_filename
argument_list|(
name|namestring
argument_list|)
expr_stmt|;
comment|/* Only change the psymtab's language if we've learned 	       something useful (eg. tmp_language is not language_unknown). 	       In addition, to match what start_subfile does, never change 	       from C++ to C.  */
if|if
condition|(
name|tmp_language
operator|!=
name|language_unknown
operator|&&
operator|(
name|tmp_language
operator|!=
name|language_c
operator|||
name|psymtab_language
operator|!=
name|language_cplus
operator|)
condition|)
name|psymtab_language
operator|=
name|tmp_language
expr_stmt|;
comment|/* In C++, one may expect the same filename to come round many 	       times, when code is coming alternately from the main file 	       and from inline functions in other files. So I check to see 	       if this is a file we've seen before -- either the main 	       source file, or a previously included file. 	        	       This seems to be a lot of time to be spending on N_SOL, but 	       things like "break c-exp.y:435" need to work (I 	       suppose the psymtab_include_list could be hashed or put 	       in a binary tree, if profiling shows this is a major hog).  */
if|if
condition|(
name|pst
operator|&&
name|STREQ
argument_list|(
name|namestring
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
condition|)
continue|continue;
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|includes_used
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|STREQ
argument_list|(
name|namestring
argument_list|,
name|psymtab_include_list
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|i
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
continue|continue;
block|}
ifdef|#
directive|ifdef
name|DBXREAD_ONLY
name|record_include_file
label|:
endif|#
directive|endif
name|psymtab_include_list
index|[
name|includes_used
operator|++
index|]
operator|=
name|namestring
expr_stmt|;
if|if
condition|(
name|includes_used
operator|>=
name|includes_allocated
condition|)
block|{
name|char
modifier|*
modifier|*
name|orig
init|=
name|psymtab_include_list
decl_stmt|;
name|psymtab_include_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|includes_allocated
operator|*=
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|PTR
operator|)
name|psymtab_include_list
argument_list|,
operator|(
name|PTR
operator|)
name|orig
argument_list|,
name|includes_used
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
case|case
name|N_LSYM
case|:
comment|/* Typedef or automatic variable. */
case|case
name|N_STSYM
case|:
comment|/* Data seg var -- static  */
case|case
name|N_LCSYM
case|:
comment|/* BSS      "  */
case|case
name|N_ROSYM
case|:
comment|/* Read-only data seg var -- static.  */
case|case
name|N_NBSTS
case|:
comment|/* Gould nobase.  */
case|case
name|N_NBLCS
case|:
comment|/* symbols.  */
case|case
name|N_FUN
case|:
case|case
name|N_GSYM
case|:
comment|/* Global (extern) variable; can be 				   data or bss (sigh FIXME).  */
comment|/* Following may probably be ignored; I'll leave them here 	   for now (until I do Pascal and Modula 2 extensions).  */
case|case
name|N_PC
case|:
comment|/* I may or may not need this; I 				   suspect not.  */
case|case
name|N_M2C
case|:
comment|/* I suspect that I can ignore this here. */
case|case
name|N_SCOPE
case|:
comment|/* Same.   */
name|SET_NAMESTRING
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|DBXREAD_ONLY
comment|/* See if this is an end of function stab.  */
if|if
condition|(
name|CUR_SYMBOL_TYPE
operator|==
name|N_FUN
operator|&&
operator|*
name|namestring
operator|==
literal|'\000'
condition|)
block|{
name|unsigned
name|long
name|valu
decl_stmt|;
comment|/* It's value is the size (in bytes) of the function for 		 function relative stabs, or the address of the function's 		 end for old style stabs.  */
name|valu
operator|=
name|CUR_SYMBOL_VALUE
operator|+
name|last_function_start
expr_stmt|;
if|if
condition|(
name|pst
operator|->
name|texthigh
operator|==
literal|0
operator|||
name|valu
operator|>
name|pst
operator|->
name|texthigh
condition|)
name|pst
operator|->
name|texthigh
operator|=
name|valu
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|namestring
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
continue|continue;
comment|/* Not a debugging symbol.   */
comment|/* Main processing section for debugging symbols which 	     the initial read through the symbol tables needs to worry 	     about.  If we reach this point, the symbol which we are 	     considering is definitely one we are interested in. 	     p must also contain the (valid) index into the namestring 	     which indicates the debugging type symbol.  */
switch|switch
condition|(
name|p
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'S'
case|:
name|CUR_SYMBOL_VALUE
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_DATA
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STATIC_TRANSFORM_NAME
name|namestring
operator|=
name|STATIC_TRANSFORM_NAME
argument_list|(
name|namestring
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|p
operator|-
name|namestring
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_STATIC
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
literal|0
argument_list|,
name|CUR_SYMBOL_VALUE
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'G'
case|:
name|CUR_SYMBOL_VALUE
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_DATA
argument_list|)
expr_stmt|;
comment|/* The addresses in these entries are reported to be 		 wrong.  See the code that reads 'G's for symtabs. */
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|p
operator|-
name|namestring
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_STATIC
argument_list|,
operator|&
name|objfile
operator|->
name|global_psymbols
argument_list|,
literal|0
argument_list|,
name|CUR_SYMBOL_VALUE
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'T'
case|:
if|if
condition|(
name|p
operator|!=
name|namestring
condition|)
comment|/* a name is there, not just :T... */
block|{
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|p
operator|-
name|namestring
argument_list|,
name|STRUCT_NAMESPACE
argument_list|,
name|LOC_TYPEDEF
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
name|CUR_SYMBOL_VALUE
argument_list|,
literal|0
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|==
literal|'t'
condition|)
block|{
comment|/* Also a typedef with the same name.  */
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|p
operator|-
name|namestring
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_TYPEDEF
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
name|CUR_SYMBOL_VALUE
argument_list|,
literal|0
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* The semantics of C++ state that "struct foo { ... }" 		     also defines a typedef for "foo".  Unfortuantely, cfront 		     never makes the typedef when translating from C++ to C. 		     We make the typedef here so that "ptype foo" works as 		     expected for cfront translated code.  */
elseif|else
if|if
condition|(
name|psymtab_language
operator|==
name|language_cplus
condition|)
block|{
comment|/* Also a typedef with the same name.  */
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|p
operator|-
name|namestring
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_TYPEDEF
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
name|CUR_SYMBOL_VALUE
argument_list|,
literal|0
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
block|}
goto|goto
name|check_enum
goto|;
case|case
literal|'t'
case|:
if|if
condition|(
name|p
operator|!=
name|namestring
condition|)
comment|/* a name is there, not just :T... */
block|{
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|p
operator|-
name|namestring
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_TYPEDEF
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
name|CUR_SYMBOL_VALUE
argument_list|,
literal|0
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
name|check_enum
label|:
comment|/* If this is an enumerated type, we need to 		 add all the enum constants to the partial symbol 		 table.  This does not cover enums without names, e.g. 		 "enum {a, b} c;" in C, but fortunately those are 		 rare.  There is no way for GDB to find those from the 		 enum type without spending too much time on it.  Thus 		 to solve this problem, the compiler needs to put out the 		 enum in a nameless type.  GCC2 does this.  */
comment|/* We are looking for something of the form<name> ":" ("t" | "T") [<number> "="] "e" 		 {<constant> ":"<value> ","} ";".  */
comment|/* Skip over the colon and the 't' or 'T'.  */
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* This type may be given a number.  Also, numbers can come 		 in pairs like (0,26).  Skip over it.  */
while|while
condition|(
operator|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
operator|)
operator|||
operator|*
name|p
operator|==
literal|'('
operator|||
operator|*
name|p
operator|==
literal|','
operator|||
operator|*
name|p
operator|==
literal|')'
operator|||
operator|*
name|p
operator|==
literal|'='
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'e'
condition|)
block|{
comment|/* The aix4 compiler emits extra crud before the members.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
comment|/* Skip over the type (?).  */
while|while
condition|(
operator|*
name|p
operator|!=
literal|':'
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Skip over the colon.  */
name|p
operator|++
expr_stmt|;
block|}
comment|/* We have found an enumerated type.  */
comment|/* According to comments in read_enum_type 		     a comma could end it instead of a semicolon. 		     I don't know where that happens. 		     Accept either.  */
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|';'
operator|&&
operator|*
name|p
operator|!=
literal|','
condition|)
block|{
name|char
modifier|*
name|q
decl_stmt|;
comment|/* Check for and handle cretinous dbx symbol name 			 continuation!  */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
operator|||
operator|(
operator|*
name|p
operator|==
literal|'?'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
condition|)
name|p
operator|=
name|next_symbol_text
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
comment|/* Point to the character after the name 			 of the enum constant.  */
for|for
control|(
name|q
operator|=
name|p
init|;
operator|*
name|q
operator|&&
operator|*
name|q
operator|!=
literal|':'
condition|;
name|q
operator|++
control|)
empty_stmt|;
comment|/* Note that the value doesn't matter for 			 enum constants in psymtabs, just in symtabs.  */
name|add_psymbol_to_list
argument_list|(
name|p
argument_list|,
name|q
operator|-
name|p
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_CONST
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Point past the name.  */
name|p
operator|=
name|q
expr_stmt|;
comment|/* Skip over the value.  */
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|','
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Advance past the comma.  */
if|if
condition|(
operator|*
name|p
condition|)
name|p
operator|++
expr_stmt|;
block|}
block|}
continue|continue;
case|case
literal|'c'
case|:
comment|/* Constant, e.g. from "const" in Pascal.  */
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|p
operator|-
name|namestring
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_CONST
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
name|CUR_SYMBOL_VALUE
argument_list|,
literal|0
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'f'
case|:
name|CUR_SYMBOL_VALUE
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DBXREAD_ONLY
comment|/* Keep track of the start of the last function so we 		 can handle end of function symbols.  */
name|last_function_start
operator|=
name|CUR_SYMBOL_VALUE
expr_stmt|;
comment|/* Kludges for ELF/STABS with Sun ACC */
name|last_function_name
operator|=
name|namestring
expr_stmt|;
ifdef|#
directive|ifdef
name|SOFUN_ADDRESS_MAYBE_MISSING
comment|/* Do not fix textlow==0 for .o or NLM files, as 0 is a legit 		 value for the bottom of the text seg in those cases. */
if|if
condition|(
name|pst
operator|&&
name|textlow_not_set
condition|)
block|{
name|pst
operator|->
name|textlow
operator|=
name|find_stab_function_addr
argument_list|(
name|namestring
argument_list|,
name|pst
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|textlow_not_set
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
literal|0
block|if (startup_file_end == 0) 		startup_file_end = CUR_SYMBOL_VALUE;
endif|#
directive|endif
comment|/* End kludge.  */
comment|/* In reordered executables this function may lie outside 		 the bounds created by N_SO symbols.  If that's the case 		 use the address of this function as the low bound for 		 the partial symbol table.  */
if|if
condition|(
name|textlow_not_set
operator|||
operator|(
name|CUR_SYMBOL_VALUE
operator|<
name|pst
operator|->
name|textlow
operator|&&
name|CUR_SYMBOL_VALUE
operator|!=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
operator|)
condition|)
block|{
name|pst
operator|->
name|textlow
operator|=
name|CUR_SYMBOL_VALUE
expr_stmt|;
name|textlow_not_set
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DBXREAD_ONLY */
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|p
operator|-
name|namestring
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_BLOCK
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
literal|0
argument_list|,
name|CUR_SYMBOL_VALUE
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
continue|continue;
comment|/* Global functions were ignored here, but now they 	         are put into the global psymtab like one would expect. 		 They're also in the minimal symbol table.  */
case|case
literal|'F'
case|:
name|CUR_SYMBOL_VALUE
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DBXREAD_ONLY
comment|/* Keep track of the start of the last function so we 		 can handle end of function symbols.  */
name|last_function_start
operator|=
name|CUR_SYMBOL_VALUE
expr_stmt|;
comment|/* Kludges for ELF/STABS with Sun ACC */
name|last_function_name
operator|=
name|namestring
expr_stmt|;
ifdef|#
directive|ifdef
name|SOFUN_ADDRESS_MAYBE_MISSING
comment|/* Do not fix textlow==0 for .o or NLM files, as 0 is a legit 		 value for the bottom of the text seg in those cases. */
if|if
condition|(
name|pst
operator|&&
name|textlow_not_set
condition|)
block|{
name|pst
operator|->
name|textlow
operator|=
name|find_stab_function_addr
argument_list|(
name|namestring
argument_list|,
name|pst
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|textlow_not_set
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
literal|0
block|if (startup_file_end == 0) 		startup_file_end = CUR_SYMBOL_VALUE;
endif|#
directive|endif
comment|/* End kludge.  */
comment|/* In reordered executables this function may lie outside 		 the bounds created by N_SO symbols.  If that's the case 		 use the address of this function as the low bound for 		 the partial symbol table.  */
if|if
condition|(
name|textlow_not_set
operator|||
operator|(
name|CUR_SYMBOL_VALUE
operator|<
name|pst
operator|->
name|textlow
operator|&&
name|CUR_SYMBOL_VALUE
operator|!=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
operator|)
condition|)
block|{
name|pst
operator|->
name|textlow
operator|=
name|CUR_SYMBOL_VALUE
expr_stmt|;
name|textlow_not_set
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DBXREAD_ONLY */
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|p
operator|-
name|namestring
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_BLOCK
argument_list|,
operator|&
name|objfile
operator|->
name|global_psymbols
argument_list|,
literal|0
argument_list|,
name|CUR_SYMBOL_VALUE
argument_list|,
name|psymtab_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
continue|continue;
comment|/* Two things show up here (hopefully); static symbols of 		 local scope (static used inside braces) or extensions 		 of structure symbols.  We can ignore both.  */
case|case
literal|'V'
case|:
case|case
literal|'('
case|:
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
case|case
literal|'-'
case|:
case|case
literal|'#'
case|:
comment|/* for symbol identification (used in live ranges) */
comment|/* added to support cfront stabs strings */
case|case
literal|'Z'
case|:
comment|/* for definition continuations */
case|case
literal|'P'
case|:
comment|/* for prototypes */
continue|continue;
case|case
literal|':'
case|:
comment|/* It is a C++ nested symbol.  We don't need to record it 		 (I don't think); if we try to look up foo::bar::baz, 		 then symbols for the symtab containing foo should get 		 read in, I think.  */
comment|/* Someone says sun cc puts out symbols like 		 /foo/baz/maclib::/usr/local/bin/maclib, 		 which would get here with a symbol type of ':'.  */
continue|continue;
default|default:
comment|/* Unexpected symbol descriptor.  The second and subsequent stabs 		 of a continued stab can show up here.  The question is 		 whether they ever can mimic a normal stab--it would be 		 nice if not, since we certainly don't want to spend the 		 time searching to the end of every string looking for 		 a backslash.  */
name|complain
argument_list|(
operator|&
name|unknown_symchar_complaint
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Ignore it; perhaps it is an extension that we don't 		 know about.  */
continue|continue;
block|}
case|case
name|N_EXCL
case|:
ifdef|#
directive|ifdef
name|DBXREAD_ONLY
name|SET_NAMESTRING
argument_list|()
expr_stmt|;
comment|/* Find the corresponding bincl and mark that psymtab on the 	     psymtab dependency list */
block|{
name|struct
name|partial_symtab
modifier|*
name|needed_pst
init|=
name|find_corresponding_bincl_psymtab
argument_list|(
name|namestring
argument_list|,
name|CUR_SYMBOL_VALUE
argument_list|)
decl_stmt|;
comment|/* If this include file was defined earlier in this file, 	       leave it alone.  */
if|if
condition|(
name|needed_pst
operator|==
name|pst
condition|)
continue|continue;
if|if
condition|(
name|needed_pst
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dependencies_used
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|dependency_list
index|[
name|i
index|]
operator|==
name|needed_pst
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* If it's already in the list, skip the rest.  */
if|if
condition|(
name|found
condition|)
continue|continue;
name|dependency_list
index|[
name|dependencies_used
operator|++
index|]
operator|=
name|needed_pst
expr_stmt|;
if|if
condition|(
name|dependencies_used
operator|>=
name|dependencies_allocated
condition|)
block|{
name|struct
name|partial_symtab
modifier|*
modifier|*
name|orig
init|=
name|dependency_list
decl_stmt|;
name|dependency_list
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|dependencies_allocated
operator|*=
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|PTR
operator|)
name|dependency_list
argument_list|,
operator|(
name|PTR
operator|)
name|orig
argument_list|,
operator|(
name|dependencies_used
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_INFO
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Had to reallocate dependency list.\n"
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"New dependencies allocated: %d\n"
argument_list|,
name|dependencies_allocated
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
endif|#
directive|endif
comment|/* DBXREAD_ONLY */
continue|continue;
case|case
name|N_ENDM
case|:
ifdef|#
directive|ifdef
name|SOFUN_ADDRESS_MAYBE_MISSING
comment|/* Solaris 2 end of module, finish current partial symbol table. 	     END_PSYMTAB will set pst->texthigh to the proper value, which 	     is necessary if a module compiled without debugging info 	     follows this module.  */
if|if
condition|(
name|pst
condition|)
block|{
name|END_PSYMTAB
argument_list|(
name|pst
argument_list|,
name|psymtab_include_list
argument_list|,
name|includes_used
argument_list|,
name|symnum
operator|*
name|symbol_size
argument_list|,
operator|(
name|CORE_ADDR
operator|)
literal|0
argument_list|,
name|dependency_list
argument_list|,
name|dependencies_used
argument_list|,
name|textlow_not_set
argument_list|)
expr_stmt|;
name|pst
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
literal|0
expr_stmt|;
name|includes_used
operator|=
literal|0
expr_stmt|;
name|dependencies_used
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
continue|continue;
case|case
name|N_RBRAC
case|:
ifdef|#
directive|ifdef
name|HANDLE_RBRAC
name|HANDLE_RBRAC
argument_list|(
name|CUR_SYMBOL_VALUE
argument_list|)
expr_stmt|;
continue|continue;
endif|#
directive|endif
case|case
name|N_EINCL
case|:
case|case
name|N_DSLINE
case|:
case|case
name|N_BSLINE
case|:
case|case
name|N_SSYM
case|:
comment|/* Claim: Structure or union element. 				   Hopefully, I can ignore this.  */
case|case
name|N_ENTRY
case|:
comment|/* Alternate entry point; can ignore. */
case|case
name|N_MAIN
case|:
comment|/* Can definitely ignore this.   */
case|case
name|N_CATCH
case|:
comment|/* These are GNU C++ extensions */
case|case
name|N_EHDECL
case|:
comment|/* that can safely be ignored here. */
case|case
name|N_LENG
case|:
case|case
name|N_BCOMM
case|:
case|case
name|N_ECOMM
case|:
case|case
name|N_ECOML
case|:
case|case
name|N_FNAME
case|:
case|case
name|N_SLINE
case|:
case|case
name|N_RSYM
case|:
case|case
name|N_PSYM
case|:
case|case
name|N_LBRAC
case|:
case|case
name|N_NSYMS
case|:
comment|/* Ultrix 4.0: symbol count */
case|case
name|N_DEFD
case|:
comment|/* GNU Modula-2 */
if|#
directive|if
literal|0
comment|/* XXX remove when binutils 2.9.2 is imported */
block|case N_ALIAS:
comment|/* SunPro F77: alias name, ignore for now.  */
endif|#
directive|endif
case|case
name|N_OBJ
case|:
comment|/* useless types from Solaris */
case|case
name|N_OPT
case|:
comment|/* These symbols aren't interesting; don't worry about them */
continue|continue;
default|default:
comment|/* If we haven't found it yet, ignore it.  It's probably some 	     new type we don't know about yet.  */
name|complain
argument_list|(
operator|&
name|unknown_symtype_complaint
argument_list|,
name|local_hex_string
argument_list|(
name|CUR_SYMBOL_TYPE
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
end_switch

end_unit

