begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target-dependent code for the ALPHA architecture, for GDB, the GNU Debugger.    Copyright 1993, 94, 95, 96, 97, 1998 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<machine/alpha_cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_comment
comment|/* FIXME: Some of this code should perhaps be merged with mips-tdep.c.  */
end_comment

begin_comment
comment|/* Prototypes for local functions. */
end_comment

begin_decl_stmt
specifier|static
name|alpha_extra_func_info_t
name|push_sigtramp_desc
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
name|low_addr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|read_next_frame_reg
name|PARAMS
argument_list|(
operator|(
expr|struct
name|frame_info
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|heuristic_proc_start
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|alpha_extra_func_info_t
name|heuristic_proc_desc
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
name|CORE_ADDR
operator|,
expr|struct
name|frame_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|alpha_extra_func_info_t
name|find_proc_desc
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
expr|struct
name|frame_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int alpha_in_lenient_prologue PARAMS ((CORE_ADDR, CORE_ADDR));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|reinit_frame_cache_sfunc
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|cmd_list_element
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|after_prologue
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
name|pc
operator|,
name|alpha_extra_func_info_t
name|proc_desc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|alpha_in_prologue
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
name|pc
operator|,
name|alpha_extra_func_info_t
name|proc_desc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Heuristic_proc_start may hunt through the text section for a long    time across a 2400 baud serial line.  Allows the user to limit this    search.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|heuristic_fence_post
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Layout of a stack frame on the alpha:                  |				|  pdr members:	|  7th ... nth arg,		|                 |  `pushed' by caller.		|                 |				| ----------------|-------------------------------|<--  old_sp == vfp    ^  ^  ^  ^	|				|    |  |  |  |	|				|    |  |localoff	|  Copies of 1st .. 6th		|    |  |  |  |	|  argument if necessary.	|    |  |  |  v	|				|    |  |  |  ---	|-------------------------------|<-- FRAME_LOCALS_ADDRESS    |  |  |      |				|    |  |  |      |  Locals and temporaries.	|    |  |  |      |				|    |  |  |      |-------------------------------|    |  |  |      |				|    |-fregoffset	|  Saved float registers.	|    |  |  |      |  F9				|    |  |  |      |   .				|    |  |  |      |   .				|    |  |  |      |  F2				|    |  |  v      |				|    |  |  -------|-------------------------------|    |  |         |				|    |  |         |  Saved registers.		|    |  |         |  S6				|    |-regoffset	|   .				|    |  |         |   .				|    |  |         |  S0				|    |  |         |  pdr.pcreg			|    |  v         |				|    |  ----------|-------------------------------|    |            |				|  frameoffset    |  Argument build area, gets	|    |            |  7th ... nth arg for any	|    |            |  called procedure.		|    v            |  				|    -------------|-------------------------------|<-- sp                 |				| */
end_comment

begin_define
define|#
directive|define
name|PROC_LOW_ADDR
parameter_list|(
name|proc
parameter_list|)
value|((proc)->pdr.adr)
end_define

begin_comment
comment|/* least address */
end_comment

begin_define
define|#
directive|define
name|PROC_HIGH_ADDR
parameter_list|(
name|proc
parameter_list|)
value|((proc)->pdr.iline)
end_define

begin_comment
comment|/* upper address bound */
end_comment

begin_define
define|#
directive|define
name|PROC_DUMMY_FRAME
parameter_list|(
name|proc
parameter_list|)
value|((proc)->pdr.iopt)
end_define

begin_comment
comment|/* frame for CALL_DUMMY */
end_comment

begin_define
define|#
directive|define
name|PROC_FRAME_OFFSET
parameter_list|(
name|proc
parameter_list|)
value|((proc)->pdr.frameoffset)
end_define

begin_define
define|#
directive|define
name|PROC_FRAME_REG
parameter_list|(
name|proc
parameter_list|)
value|((proc)->pdr.framereg)
end_define

begin_define
define|#
directive|define
name|PROC_REG_MASK
parameter_list|(
name|proc
parameter_list|)
value|((proc)->pdr.regmask)
end_define

begin_define
define|#
directive|define
name|PROC_FREG_MASK
parameter_list|(
name|proc
parameter_list|)
value|((proc)->pdr.fregmask)
end_define

begin_define
define|#
directive|define
name|PROC_REG_OFFSET
parameter_list|(
name|proc
parameter_list|)
value|((proc)->pdr.regoffset)
end_define

begin_define
define|#
directive|define
name|PROC_FREG_OFFSET
parameter_list|(
name|proc
parameter_list|)
value|((proc)->pdr.fregoffset)
end_define

begin_define
define|#
directive|define
name|PROC_PC_REG
parameter_list|(
name|proc
parameter_list|)
value|((proc)->pdr.pcreg)
end_define

begin_define
define|#
directive|define
name|PROC_LOCALOFF
parameter_list|(
name|proc
parameter_list|)
value|((proc)->pdr.localoff)
end_define

begin_define
define|#
directive|define
name|PROC_SYMBOL
parameter_list|(
name|proc
parameter_list|)
value|(*(struct symbol**)&(proc)->pdr.isym)
end_define

begin_define
define|#
directive|define
name|_PROC_MAGIC_
value|0x0F0F0F0F
end_define

begin_define
define|#
directive|define
name|PROC_DESC_IS_DUMMY
parameter_list|(
name|proc
parameter_list|)
value|((proc)->pdr.isym == _PROC_MAGIC_)
end_define

begin_define
define|#
directive|define
name|SET_PROC_DESC_IS_DUMMY
parameter_list|(
name|proc
parameter_list|)
value|((proc)->pdr.isym = _PROC_MAGIC_)
end_define

begin_struct
struct|struct
name|linked_proc_info
block|{
name|struct
name|alpha_extra_func_info
name|info
decl_stmt|;
name|struct
name|linked_proc_info
modifier|*
name|next
decl_stmt|;
block|}
modifier|*
name|linked_proc_desc_table
init|=
name|NULL
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* Under GNU/Linux, signal handler invocations can be identified by the    designated code sequence that is used to return from a signal    handler.  In particular, the return address of a signal handler    points to the following sequence (the first instruction is quadword    aligned):  	bis $30,$30,$16 	addq $31,0x67,$0 	call_pal callsys     Each instruction has a unique encoding, so we simply attempt to    match the instruction the pc is pointing to with any of the above    instructions.  If there is a hit, we know the offset to the start    of the designated sequence and can then check whether we really are    executing in a designated sequence.  If not, -1 is returned,    otherwise the offset from the start of the desingated sequence is    returned.     There is a slight chance of false hits: code could jump into the    middle of the designated sequence, in which case there is no    guarantee that we are in the middle of a sigreturn syscall.  Don't    think this will be a problem in praxis, though. */
end_comment

begin_function
name|long
name|alpha_linux_sigtramp_offset
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|unsigned
name|int
name|i
index|[
literal|3
index|]
decl_stmt|,
name|w
decl_stmt|;
name|long
name|off
decl_stmt|;
if|if
condition|(
name|read_memory_nobpt
argument_list|(
name|pc
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|w
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|off
operator|=
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|w
condition|)
block|{
case|case
literal|0x47de0410
case|:
name|off
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* bis $30,$30,$16 */
case|case
literal|0x43ecf400
case|:
name|off
operator|=
literal|4
expr_stmt|;
break|break;
comment|/* addq $31,0x67,$0 */
case|case
literal|0x00000083
case|:
name|off
operator|=
literal|8
expr_stmt|;
break|break;
comment|/* call_pal callsys */
default|default:
return|return
operator|-
literal|1
return|;
block|}
name|pc
operator|-=
name|off
expr_stmt|;
if|if
condition|(
name|pc
operator|&
literal|0x7
condition|)
block|{
comment|/* designated sequence is not quadword aligned */
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|read_memory_nobpt
argument_list|(
name|pc
argument_list|,
operator|(
name|char
operator|*
operator|)
name|i
argument_list|,
sizeof|sizeof
argument_list|(
name|i
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|i
index|[
literal|0
index|]
operator|==
literal|0x47de0410
operator|&&
name|i
index|[
literal|1
index|]
operator|==
literal|0x43ecf400
operator|&&
name|i
index|[
literal|2
index|]
operator|==
literal|0x00000083
condition|)
return|return
name|off
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Under OSF/1, the __sigtramp routine is frameless and has a frame    size of zero, but we are able to backtrace through it.  */
end_comment

begin_function
name|CORE_ADDR
name|alpha_osf_skip_sigtramp_frame
parameter_list|(
name|frame
parameter_list|,
name|pc
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
operator|&
name|name
argument_list|,
operator|(
name|CORE_ADDR
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|CORE_ADDR
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN_SIGTRAMP
argument_list|(
name|pc
argument_list|,
name|name
argument_list|)
condition|)
return|return
name|frame
operator|->
name|frame
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Dynamically create a signal-handler caller procedure descriptor for    the signal-handler return code starting at address LOW_ADDR.  The    descriptor is added to the linked_proc_desc_table.  */
end_comment

begin_function
specifier|static
name|alpha_extra_func_info_t
name|push_sigtramp_desc
parameter_list|(
name|low_addr
parameter_list|)
name|CORE_ADDR
name|low_addr
decl_stmt|;
block|{
name|struct
name|linked_proc_info
modifier|*
name|link
decl_stmt|;
name|alpha_extra_func_info_t
name|proc_desc
decl_stmt|;
name|link
operator|=
operator|(
expr|struct
name|linked_proc_info
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|linked_proc_info
argument_list|)
argument_list|)
expr_stmt|;
name|link
operator|->
name|next
operator|=
name|linked_proc_desc_table
expr_stmt|;
name|linked_proc_desc_table
operator|=
name|link
expr_stmt|;
name|proc_desc
operator|=
operator|&
name|link
operator|->
name|info
expr_stmt|;
name|proc_desc
operator|->
name|numargs
operator|=
literal|0
expr_stmt|;
name|PROC_LOW_ADDR
argument_list|(
name|proc_desc
argument_list|)
operator|=
name|low_addr
expr_stmt|;
name|PROC_HIGH_ADDR
argument_list|(
name|proc_desc
argument_list|)
operator|=
name|low_addr
operator|+
literal|3
operator|*
literal|4
expr_stmt|;
name|PROC_DUMMY_FRAME
argument_list|(
name|proc_desc
argument_list|)
operator|=
literal|0
expr_stmt|;
name|PROC_FRAME_OFFSET
argument_list|(
name|proc_desc
argument_list|)
operator|=
literal|0x298
expr_stmt|;
comment|/* sizeof(struct sigcontext_struct) */
name|PROC_FRAME_REG
argument_list|(
name|proc_desc
argument_list|)
operator|=
name|SP_REGNUM
expr_stmt|;
name|PROC_REG_MASK
argument_list|(
name|proc_desc
argument_list|)
operator|=
literal|0xffff
expr_stmt|;
name|PROC_FREG_MASK
argument_list|(
name|proc_desc
argument_list|)
operator|=
literal|0xffff
expr_stmt|;
name|PROC_PC_REG
argument_list|(
name|proc_desc
argument_list|)
operator|=
literal|26
expr_stmt|;
name|PROC_LOCALOFF
argument_list|(
name|proc_desc
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SET_PROC_DESC_IS_DYN_SIGTRAMP
argument_list|(
name|proc_desc
argument_list|)
expr_stmt|;
return|return
operator|(
name|proc_desc
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Guaranteed to set frame->saved_regs to some values (it never leaves it    NULL).  */
end_comment

begin_function
name|void
name|alpha_find_saved_regs
parameter_list|(
name|frame
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
block|{
name|int
name|ireg
decl_stmt|;
name|CORE_ADDR
name|reg_position
decl_stmt|;
name|unsigned
name|long
name|mask
decl_stmt|;
name|alpha_extra_func_info_t
name|proc_desc
decl_stmt|;
name|int
name|returnreg
decl_stmt|;
name|frame_saved_regs_zalloc
argument_list|(
name|frame
argument_list|)
expr_stmt|;
comment|/* If it is the frame for __sigtramp, the saved registers are located      in a sigcontext structure somewhere on the stack. __sigtramp      passes a pointer to the sigcontext structure on the stack.      If the stack layout for __sigtramp changes, or if sigcontext offsets      change, we might have to update this code.  */
ifndef|#
directive|ifndef
name|SIGFRAME_PC_OFF
define|#
directive|define
name|SIGFRAME_PC_OFF
value|(2 * 8)
define|#
directive|define
name|SIGFRAME_REGSAVE_OFF
value|(4 * 8)
define|#
directive|define
name|SIGFRAME_FPREGSAVE_OFF
value|(SIGFRAME_REGSAVE_OFF + 32 * 8 + 8)
endif|#
directive|endif
if|if
condition|(
name|frame
operator|->
name|signal_handler_caller
condition|)
block|{
name|CORE_ADDR
name|sigcontext_addr
decl_stmt|;
name|sigcontext_addr
operator|=
name|SIGCONTEXT_ADDR
argument_list|(
name|frame
argument_list|)
expr_stmt|;
for|for
control|(
name|ireg
operator|=
literal|0
init|;
name|ireg
operator|<
literal|32
condition|;
name|ireg
operator|++
control|)
block|{
name|reg_position
operator|=
name|sigcontext_addr
operator|+
name|SIGFRAME_REGSAVE_OFF
operator|+
name|ireg
operator|*
literal|8
expr_stmt|;
name|frame
operator|->
name|saved_regs
index|[
name|ireg
index|]
operator|=
name|reg_position
expr_stmt|;
block|}
for|for
control|(
name|ireg
operator|=
literal|0
init|;
name|ireg
operator|<
literal|32
condition|;
name|ireg
operator|++
control|)
block|{
name|reg_position
operator|=
name|sigcontext_addr
operator|+
name|SIGFRAME_FPREGSAVE_OFF
operator|+
name|ireg
operator|*
literal|8
expr_stmt|;
name|frame
operator|->
name|saved_regs
index|[
name|FP0_REGNUM
operator|+
name|ireg
index|]
operator|=
name|reg_position
expr_stmt|;
block|}
name|frame
operator|->
name|saved_regs
index|[
name|PC_REGNUM
index|]
operator|=
name|sigcontext_addr
operator|+
name|SIGFRAME_PC_OFF
expr_stmt|;
return|return;
block|}
name|proc_desc
operator|=
name|frame
operator|->
name|proc_desc
expr_stmt|;
if|if
condition|(
name|proc_desc
operator|==
name|NULL
condition|)
comment|/* I'm not sure how/whether this can happen.  Normally when we can't        find a proc_desc, we "synthesize" one using heuristic_proc_desc        and set the saved_regs right away.  */
return|return;
comment|/* Fill in the offsets for the registers which gen_mask says      were saved.  */
name|reg_position
operator|=
name|frame
operator|->
name|frame
operator|+
name|PROC_REG_OFFSET
argument_list|(
name|proc_desc
argument_list|)
expr_stmt|;
name|mask
operator|=
name|PROC_REG_MASK
argument_list|(
name|proc_desc
argument_list|)
expr_stmt|;
name|returnreg
operator|=
name|PROC_PC_REG
argument_list|(
name|proc_desc
argument_list|)
expr_stmt|;
comment|/* Note that RA is always saved first, regardless of its actual      register number.  */
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|returnreg
operator|)
condition|)
block|{
name|frame
operator|->
name|saved_regs
index|[
name|returnreg
index|]
operator|=
name|reg_position
expr_stmt|;
name|reg_position
operator|+=
literal|8
expr_stmt|;
name|mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|returnreg
operator|)
expr_stmt|;
comment|/* Clear bit for RA so we 				    don't save again later. */
block|}
for|for
control|(
name|ireg
operator|=
literal|0
init|;
name|ireg
operator|<=
literal|31
condition|;
operator|++
name|ireg
control|)
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|ireg
operator|)
condition|)
block|{
name|frame
operator|->
name|saved_regs
index|[
name|ireg
index|]
operator|=
name|reg_position
expr_stmt|;
name|reg_position
operator|+=
literal|8
expr_stmt|;
block|}
comment|/* Fill in the offsets for the registers which float_mask says      were saved.  */
name|reg_position
operator|=
name|frame
operator|->
name|frame
operator|+
name|PROC_FREG_OFFSET
argument_list|(
name|proc_desc
argument_list|)
expr_stmt|;
name|mask
operator|=
name|PROC_FREG_MASK
argument_list|(
name|proc_desc
argument_list|)
expr_stmt|;
for|for
control|(
name|ireg
operator|=
literal|0
init|;
name|ireg
operator|<=
literal|31
condition|;
operator|++
name|ireg
control|)
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|ireg
operator|)
condition|)
block|{
name|frame
operator|->
name|saved_regs
index|[
name|FP0_REGNUM
operator|+
name|ireg
index|]
operator|=
name|reg_position
expr_stmt|;
name|reg_position
operator|+=
literal|8
expr_stmt|;
block|}
name|frame
operator|->
name|saved_regs
index|[
name|PC_REGNUM
index|]
operator|=
name|frame
operator|->
name|saved_regs
index|[
name|returnreg
index|]
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|read_next_frame_reg
parameter_list|(
name|fi
parameter_list|,
name|regno
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|int
name|regno
decl_stmt|;
block|{
for|for
control|(
init|;
name|fi
condition|;
name|fi
operator|=
name|fi
operator|->
name|next
control|)
block|{
comment|/* We have to get the saved sp from the sigcontext 	 if it is a signal handler frame.  */
if|if
condition|(
name|regno
operator|==
name|SP_REGNUM
operator|&&
operator|!
name|fi
operator|->
name|signal_handler_caller
condition|)
return|return
name|fi
operator|->
name|frame
return|;
else|else
block|{
if|if
condition|(
name|fi
operator|->
name|saved_regs
operator|==
name|NULL
condition|)
name|alpha_find_saved_regs
argument_list|(
name|fi
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|saved_regs
index|[
name|regno
index|]
condition|)
return|return
name|read_memory_integer
argument_list|(
name|fi
operator|->
name|saved_regs
index|[
name|regno
index|]
argument_list|,
literal|8
argument_list|)
return|;
block|}
block|}
return|return
name|read_register
argument_list|(
name|regno
argument_list|)
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|alpha_frame_saved_pc
parameter_list|(
name|frame
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
block|{
name|alpha_extra_func_info_t
name|proc_desc
init|=
name|frame
operator|->
name|proc_desc
decl_stmt|;
comment|/* We have to get the saved pc from the sigcontext      if it is a signal handler frame.  */
name|int
name|pcreg
init|=
name|frame
operator|->
name|signal_handler_caller
condition|?
name|PC_REGNUM
else|:
name|frame
operator|->
name|pc_reg
decl_stmt|;
if|if
condition|(
name|proc_desc
operator|&&
name|PROC_DESC_IS_DUMMY
argument_list|(
name|proc_desc
argument_list|)
condition|)
return|return
name|read_memory_integer
argument_list|(
name|frame
operator|->
name|frame
operator|-
literal|8
argument_list|,
literal|8
argument_list|)
return|;
return|return
name|read_next_frame_reg
argument_list|(
name|frame
argument_list|,
name|pcreg
argument_list|)
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|alpha_saved_pc_after_call
parameter_list|(
name|frame
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
block|{
name|CORE_ADDR
name|pc
init|=
name|frame
operator|->
name|pc
decl_stmt|;
name|CORE_ADDR
name|tmp
decl_stmt|;
name|alpha_extra_func_info_t
name|proc_desc
decl_stmt|;
name|int
name|pcreg
decl_stmt|;
comment|/* Skip over shared library trampoline if necessary.  */
name|tmp
operator|=
name|SKIP_TRAMPOLINE_CODE
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
literal|0
condition|)
name|pc
operator|=
name|tmp
expr_stmt|;
name|proc_desc
operator|=
name|find_proc_desc
argument_list|(
name|pc
argument_list|,
name|frame
operator|->
name|next
argument_list|)
expr_stmt|;
name|pcreg
operator|=
name|proc_desc
condition|?
name|PROC_PC_REG
argument_list|(
name|proc_desc
argument_list|)
else|:
name|RA_REGNUM
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|signal_handler_caller
condition|)
return|return
name|alpha_frame_saved_pc
argument_list|(
name|frame
argument_list|)
return|;
else|else
return|return
name|read_register
argument_list|(
name|pcreg
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|alpha_extra_func_info
name|temp_proc_desc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|frame_saved_regs
name|temp_saved_regs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if instruction at PC is a return instruction.  "ret    $zero,($ra),1" on alpha. */
end_comment

begin_function
specifier|static
name|int
name|alpha_about_to_return
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
return|return
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|)
operator|==
literal|0x6bfa8001
return|;
block|}
end_function

begin_comment
comment|/* This fencepost looks highly suspicious to me.  Removing it also    seems suspicious as it could affect remote debugging across serial    lines.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|heuristic_proc_start
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
name|CORE_ADDR
name|start_pc
init|=
name|pc
decl_stmt|;
name|CORE_ADDR
name|fence
init|=
name|start_pc
operator|-
name|heuristic_fence_post
decl_stmt|;
if|if
condition|(
name|start_pc
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|heuristic_fence_post
operator|==
name|UINT_MAX
operator|||
name|fence
operator|<
name|VM_MIN_ADDRESS
condition|)
name|fence
operator|=
name|VM_MIN_ADDRESS
expr_stmt|;
comment|/* search back for previous return */
for|for
control|(
name|start_pc
operator|-=
literal|4
init|;
condition|;
name|start_pc
operator|-=
literal|4
control|)
if|if
condition|(
name|start_pc
operator|<
name|fence
condition|)
block|{
comment|/* It's not clear to me why we reach this point when 	       stop_soon_quietly, but with this test, at least we 	       don't print out warnings for every child forked (eg, on 	       decstation).  22apr93 rich@cygnus.com.  */
if|if
condition|(
operator|!
name|stop_soon_quietly
condition|)
block|{
specifier|static
name|int
name|blurb_printed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fence
operator|==
name|VM_MIN_ADDRESS
condition|)
name|warning
argument_list|(
literal|"Hit beginning of text section without finding"
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"Hit heuristic-fence-post without finding"
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"enclosing function for address 0x%lx"
argument_list|,
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|blurb_printed
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\ This warning occurs if you are debugging a function without any symbols\n\ (for example, in a stripped executable).  In that case, you may wish to\n\ increase the size of the search with the `set heuristic-fence-post' command.\n\ \n\ Otherwise, you told GDB there was a function where there isn't one, or\n\ (more likely) you have encountered a bug in GDB.\n"
argument_list|)
expr_stmt|;
name|blurb_printed
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|alpha_about_to_return
argument_list|(
name|start_pc
argument_list|)
condition|)
break|break;
name|start_pc
operator|+=
literal|4
expr_stmt|;
comment|/* skip return */
return|return
name|start_pc
return|;
block|}
end_function

begin_function
specifier|static
name|alpha_extra_func_info_t
name|heuristic_proc_desc
parameter_list|(
name|start_pc
parameter_list|,
name|limit_pc
parameter_list|,
name|next_frame
parameter_list|)
name|CORE_ADDR
name|start_pc
decl_stmt|,
name|limit_pc
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|next_frame
decl_stmt|;
block|{
name|CORE_ADDR
name|sp
init|=
name|read_next_frame_reg
argument_list|(
name|next_frame
argument_list|,
name|SP_REGNUM
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|cur_pc
decl_stmt|;
name|int
name|frame_size
decl_stmt|;
name|int
name|has_frame_reg
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|reg_mask
init|=
literal|0
decl_stmt|;
name|int
name|pcreg
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|start_pc
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
operator|&
name|temp_proc_desc
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|temp_proc_desc
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|temp_saved_regs
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|frame_saved_regs
argument_list|)
argument_list|)
expr_stmt|;
name|PROC_LOW_ADDR
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator|=
name|start_pc
expr_stmt|;
if|if
condition|(
name|start_pc
operator|+
literal|200
operator|<
name|limit_pc
condition|)
name|limit_pc
operator|=
name|start_pc
operator|+
literal|200
expr_stmt|;
name|frame_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cur_pc
operator|=
name|start_pc
init|;
name|cur_pc
operator|<
name|limit_pc
condition|;
name|cur_pc
operator|+=
literal|4
control|)
block|{
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|unsigned
name|long
name|word
decl_stmt|;
name|int
name|status
decl_stmt|;
name|status
operator|=
name|read_memory_nobpt
argument_list|(
name|cur_pc
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|memory_error
argument_list|(
name|status
argument_list|,
name|cur_pc
argument_list|)
expr_stmt|;
name|word
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|word
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0x23de0000
condition|)
comment|/* lda $sp,n($sp) */
block|{
if|if
condition|(
name|word
operator|&
literal|0x8000
condition|)
name|frame_size
operator|+=
operator|(
operator|-
name|word
operator|)
operator|&
literal|0xffff
expr_stmt|;
else|else
comment|/* Exit loop if a positive stack adjustment is found, which 		 usually means that the stack cleanup code in the function 		 epilogue is reached.  */
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|word
operator|&
literal|0xfc1f0000
operator|)
operator|==
literal|0xb41e0000
comment|/* stq reg,n($sp) */
operator|&&
operator|(
name|word
operator|&
literal|0xffff0000
operator|)
operator|!=
literal|0xb7fe0000
condition|)
comment|/* reg != $zero */
block|{
name|int
name|reg
init|=
operator|(
name|word
operator|&
literal|0x03e00000
operator|)
operator|>>
literal|21
decl_stmt|;
name|reg_mask
operator||=
literal|1
operator|<<
name|reg
expr_stmt|;
name|temp_saved_regs
operator|.
name|regs
index|[
name|reg
index|]
operator|=
name|sp
operator|+
operator|(
name|short
operator|)
name|word
expr_stmt|;
comment|/* Starting with OSF/1-3.2C, the system libraries are shipped 	       without local symbols, but they still contain procedure 	       descriptors without a symbol reference. GDB is currently 	       unable to find these procedure descriptors and uses 	       heuristic_proc_desc instead. 	       As some low level compiler support routines (__div*, __add*) 	       use a non-standard return address register, we have to 	       add some heuristics to determine the return address register, 	       or stepping over these routines will fail. 	       Usually the return address register is the first register 	       saved on the stack, but assembler optimization might 	       rearrange the register saves. 	       So we recognize only a few registers (t7, t9, ra) within 	       the procedure prologue as valid return address registers. 	       If we encounter a return instruction, we extract the 	       the return address register from it.  	       FIXME: Rewriting GDB to access the procedure descriptors, 	       e.g. via the minimal symbol table, might obviate this hack.  */
if|if
condition|(
name|pcreg
operator|==
operator|-
literal|1
operator|&&
name|cur_pc
operator|<
operator|(
name|start_pc
operator|+
literal|80
operator|)
operator|&&
operator|(
name|reg
operator|==
name|T7_REGNUM
operator|||
name|reg
operator|==
name|T9_REGNUM
operator|||
name|reg
operator|==
name|RA_REGNUM
operator|)
condition|)
name|pcreg
operator|=
name|reg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|word
operator|&
literal|0xffe0ffff
operator|)
operator|==
literal|0x6be08001
condition|)
comment|/* ret zero,reg,1 */
name|pcreg
operator|=
operator|(
name|word
operator|>>
literal|16
operator|)
operator|&
literal|0x1f
expr_stmt|;
elseif|else
if|if
condition|(
name|word
operator|==
literal|0x47de040f
condition|)
comment|/* bis sp,sp fp */
name|has_frame_reg
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|pcreg
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* If we haven't found a valid return address register yet, 	   keep searching in the procedure prologue.  */
while|while
condition|(
name|cur_pc
operator|<
operator|(
name|limit_pc
operator|+
literal|80
operator|)
operator|&&
name|cur_pc
operator|<
operator|(
name|start_pc
operator|+
literal|80
operator|)
condition|)
block|{
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|unsigned
name|long
name|word
decl_stmt|;
if|if
condition|(
name|read_memory_nobpt
argument_list|(
name|cur_pc
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
condition|)
break|break;
name|cur_pc
operator|+=
literal|4
expr_stmt|;
name|word
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|word
operator|&
literal|0xfc1f0000
operator|)
operator|==
literal|0xb41e0000
comment|/* stq reg,n($sp) */
operator|&&
operator|(
name|word
operator|&
literal|0xffff0000
operator|)
operator|!=
literal|0xb7fe0000
condition|)
comment|/* reg != $zero */
block|{
name|int
name|reg
init|=
operator|(
name|word
operator|&
literal|0x03e00000
operator|)
operator|>>
literal|21
decl_stmt|;
if|if
condition|(
name|reg
operator|==
name|T7_REGNUM
operator|||
name|reg
operator|==
name|T9_REGNUM
operator|||
name|reg
operator|==
name|RA_REGNUM
condition|)
block|{
name|pcreg
operator|=
name|reg
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|word
operator|&
literal|0xffe0ffff
operator|)
operator|==
literal|0x6be08001
condition|)
comment|/* ret zero,reg,1 */
block|{
name|pcreg
operator|=
operator|(
name|word
operator|>>
literal|16
operator|)
operator|&
literal|0x1f
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|has_frame_reg
condition|)
name|PROC_FRAME_REG
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator|=
name|GCC_FP_REGNUM
expr_stmt|;
else|else
name|PROC_FRAME_REG
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator|=
name|SP_REGNUM
expr_stmt|;
name|PROC_FRAME_OFFSET
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator|=
name|frame_size
expr_stmt|;
name|PROC_REG_MASK
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator|=
name|reg_mask
expr_stmt|;
name|PROC_PC_REG
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator|=
operator|(
name|pcreg
operator|==
operator|-
literal|1
operator|)
condition|?
name|RA_REGNUM
else|:
name|pcreg
expr_stmt|;
name|PROC_LOCALOFF
argument_list|(
operator|&
name|temp_proc_desc
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* XXX - bogus */
return|return
operator|&
name|temp_proc_desc
return|;
block|}
end_function

begin_comment
comment|/* This returns the PC of the first inst after the prologue.  If we can't    find the prologue, then return 0.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|after_prologue
parameter_list|(
name|pc
parameter_list|,
name|proc_desc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|alpha_extra_func_info_t
name|proc_desc
decl_stmt|;
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|CORE_ADDR
name|func_addr
decl_stmt|,
name|func_end
decl_stmt|;
if|if
condition|(
operator|!
name|proc_desc
condition|)
name|proc_desc
operator|=
name|find_proc_desc
argument_list|(
name|pc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc_desc
condition|)
block|{
if|if
condition|(
name|PROC_DESC_IS_DYN_SIGTRAMP
argument_list|(
name|proc_desc
argument_list|)
condition|)
return|return
name|PROC_LOW_ADDR
argument_list|(
name|proc_desc
argument_list|)
return|;
comment|/* "prologue" is in kernel */
comment|/* If function is frameless, then we need to do it the hard way.  I 	 strongly suspect that frameless always means prologueless... */
if|if
condition|(
name|PROC_FRAME_REG
argument_list|(
name|proc_desc
argument_list|)
operator|==
name|SP_REGNUM
operator|&&
name|PROC_FRAME_OFFSET
argument_list|(
name|proc_desc
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
name|NULL
argument_list|,
operator|&
name|func_addr
argument_list|,
operator|&
name|func_end
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Unknown */
name|sal
operator|=
name|find_pc_line
argument_list|(
name|func_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|end
operator|<
name|func_end
condition|)
return|return
name|sal
operator|.
name|end
return|;
comment|/* The line after the prologue is after the end of the function.  In this      case, tell the caller to find the prologue the hard way.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if we *might* be in a function prologue.  Return zero if we    are definitively *not* in a function prologue.  */
end_comment

begin_function
specifier|static
name|int
name|alpha_in_prologue
parameter_list|(
name|pc
parameter_list|,
name|proc_desc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|alpha_extra_func_info_t
name|proc_desc
decl_stmt|;
block|{
name|CORE_ADDR
name|after_prologue_pc
decl_stmt|;
name|after_prologue_pc
operator|=
name|after_prologue
argument_list|(
name|pc
argument_list|,
name|proc_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|after_prologue_pc
operator|==
literal|0
operator|||
name|pc
operator|<
name|after_prologue_pc
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|alpha_extra_func_info_t
name|find_proc_desc
parameter_list|(
name|pc
parameter_list|,
name|next_frame
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|next_frame
decl_stmt|;
block|{
name|alpha_extra_func_info_t
name|proc_desc
decl_stmt|;
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|CORE_ADDR
name|startaddr
decl_stmt|;
comment|/* Try to get the proc_desc from the linked call dummy proc_descs      if the pc is in the call dummy.      This is hairy. In the case of nested dummy calls we have to find the      right proc_desc, but we might not yet know the frame for the dummy      as it will be contained in the proc_desc we are searching for.      So we have to find the proc_desc whose frame is closest to the current      stack pointer.  */
if|if
condition|(
name|PC_IN_CALL_DUMMY
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|struct
name|linked_proc_info
modifier|*
name|link
decl_stmt|;
name|CORE_ADDR
name|sp
init|=
name|read_next_frame_reg
argument_list|(
name|next_frame
argument_list|,
name|SP_REGNUM
argument_list|)
decl_stmt|;
name|alpha_extra_func_info_t
name|found_proc_desc
init|=
name|NULL
decl_stmt|;
name|long
name|min_distance
init|=
name|LONG_MAX
decl_stmt|;
for|for
control|(
name|link
operator|=
name|linked_proc_desc_table
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
block|{
name|long
name|distance
init|=
operator|(
name|CORE_ADDR
operator|)
name|PROC_DUMMY_FRAME
argument_list|(
operator|&
name|link
operator|->
name|info
argument_list|)
operator|-
name|sp
decl_stmt|;
if|if
condition|(
name|distance
operator|>
literal|0
operator|&&
name|distance
operator|<
name|min_distance
condition|)
block|{
name|min_distance
operator|=
name|distance
expr_stmt|;
name|found_proc_desc
operator|=
operator|&
name|link
operator|->
name|info
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found_proc_desc
operator|!=
name|NULL
condition|)
return|return
name|found_proc_desc
return|;
block|}
name|b
operator|=
name|block_for_pc
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
name|NULL
argument_list|,
operator|&
name|startaddr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
name|sym
operator|=
name|NULL
expr_stmt|;
else|else
block|{
if|if
condition|(
name|startaddr
operator|>
name|BLOCK_START
argument_list|(
name|b
argument_list|)
condition|)
comment|/* This is the "pathological" case referred to in a comment in 	   print_frame_info.  It might be better to move this check into 	   symbol reading.  */
name|sym
operator|=
name|NULL
expr_stmt|;
else|else
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|MIPS_EFI_SYMBOL_NAME
argument_list|,
name|b
argument_list|,
name|LABEL_NAMESPACE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* If we never found a PDR for this function in symbol reading, then      examine prologues to find the information.  */
if|if
condition|(
name|sym
operator|&&
operator|(
operator|(
name|mips_extra_func_info_t
operator|)
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|)
operator|->
name|pdr
operator|.
name|framereg
operator|==
operator|-
literal|1
condition|)
name|sym
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
comment|/* IF this is the topmost frame AND 	 * (this proc does not have debugging information OR 	 * the PC is in the procedure prologue) 	 * THEN create a "heuristic" proc_desc (by analyzing 	 * the actual code) to replace the "official" proc_desc. 	 */
name|proc_desc
operator|=
operator|(
name|alpha_extra_func_info_t
operator|)
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_frame
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|PROC_DESC_IS_DUMMY
argument_list|(
name|proc_desc
argument_list|)
operator|||
name|alpha_in_prologue
argument_list|(
name|pc
argument_list|,
name|proc_desc
argument_list|)
condition|)
block|{
name|alpha_extra_func_info_t
name|found_heuristic
init|=
name|heuristic_proc_desc
argument_list|(
name|PROC_LOW_ADDR
argument_list|(
name|proc_desc
argument_list|)
argument_list|,
name|pc
argument_list|,
name|next_frame
argument_list|)
decl_stmt|;
if|if
condition|(
name|found_heuristic
condition|)
block|{
name|PROC_LOCALOFF
argument_list|(
name|found_heuristic
argument_list|)
operator|=
name|PROC_LOCALOFF
argument_list|(
name|proc_desc
argument_list|)
expr_stmt|;
name|PROC_PC_REG
argument_list|(
name|found_heuristic
argument_list|)
operator|=
name|PROC_PC_REG
argument_list|(
name|proc_desc
argument_list|)
expr_stmt|;
name|proc_desc
operator|=
name|found_heuristic
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|long
name|offset
decl_stmt|;
comment|/* Is linked_proc_desc_table really necessary?  It only seems to be used 	 by procedure call dummys.  However, the procedures being called ought 	 to have their own proc_descs, and even if they don't, 	 heuristic_proc_desc knows how to create them! */
specifier|register
name|struct
name|linked_proc_info
modifier|*
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|linked_proc_desc_table
init|;
name|link
condition|;
name|link
operator|=
name|link
operator|->
name|next
control|)
if|if
condition|(
name|PROC_LOW_ADDR
argument_list|(
operator|&
name|link
operator|->
name|info
argument_list|)
operator|<=
name|pc
operator|&&
name|PROC_HIGH_ADDR
argument_list|(
operator|&
name|link
operator|->
name|info
argument_list|)
operator|>
name|pc
condition|)
return|return
operator|&
name|link
operator|->
name|info
return|;
comment|/* If PC is inside a dynamically generated sigtramp handler, 	 create and push a procedure descriptor for that code: */
name|offset
operator|=
name|DYNAMIC_SIGTRAMP_OFFSET
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
literal|0
condition|)
return|return
name|push_sigtramp_desc
argument_list|(
name|pc
operator|-
name|offset
argument_list|)
return|;
comment|/* If heuristic_fence_post is non-zero, determine the procedure 	 start address by examining the instructions. 	 This allows us to find the start address of static functions which 	 have no symbolic information, as startaddr would have been set to 	 the preceding global function start address by the 	 find_pc_partial_function call above.  */
if|if
condition|(
name|startaddr
operator|==
literal|0
operator|||
name|heuristic_fence_post
operator|!=
literal|0
condition|)
name|startaddr
operator|=
name|heuristic_proc_start
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|proc_desc
operator|=
name|heuristic_proc_desc
argument_list|(
name|startaddr
argument_list|,
name|pc
argument_list|,
name|next_frame
argument_list|)
expr_stmt|;
block|}
return|return
name|proc_desc
return|;
block|}
end_function

begin_decl_stmt
name|alpha_extra_func_info_t
name|cached_proc_desc
decl_stmt|;
end_decl_stmt

begin_function
name|CORE_ADDR
name|alpha_frame_chain
parameter_list|(
name|frame
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
block|{
name|alpha_extra_func_info_t
name|proc_desc
decl_stmt|;
name|CORE_ADDR
name|saved_pc
init|=
name|FRAME_SAVED_PC
argument_list|(
name|frame
argument_list|)
decl_stmt|;
if|if
condition|(
name|saved_pc
operator|==
literal|0
operator|||
name|inside_entry_file
argument_list|(
name|saved_pc
argument_list|)
condition|)
return|return
literal|0
return|;
name|proc_desc
operator|=
name|find_proc_desc
argument_list|(
name|saved_pc
argument_list|,
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|proc_desc
condition|)
return|return
literal|0
return|;
name|cached_proc_desc
operator|=
name|proc_desc
expr_stmt|;
comment|/* Fetch the frame pointer for a dummy frame from the procedure        descriptor.  */
if|if
condition|(
name|PROC_DESC_IS_DUMMY
argument_list|(
name|proc_desc
argument_list|)
condition|)
return|return
operator|(
name|CORE_ADDR
operator|)
name|PROC_DUMMY_FRAME
argument_list|(
name|proc_desc
argument_list|)
return|;
comment|/* If no frame pointer and frame size is zero, we must be at end        of stack (or otherwise hosed).  If we don't check frame size,        we loop forever if we see a zero size frame.  */
if|if
condition|(
name|PROC_FRAME_REG
argument_list|(
name|proc_desc
argument_list|)
operator|==
name|SP_REGNUM
operator|&&
name|PROC_FRAME_OFFSET
argument_list|(
name|proc_desc
argument_list|)
operator|==
literal|0
comment|/* The previous frame from a sigtramp frame might be frameless 	   and have frame size zero.  */
operator|&&
operator|!
name|frame
operator|->
name|signal_handler_caller
condition|)
return|return
name|FRAME_PAST_SIGTRAMP_FRAME
argument_list|(
name|frame
argument_list|,
name|saved_pc
argument_list|)
return|;
else|else
return|return
name|read_next_frame_reg
argument_list|(
name|frame
argument_list|,
name|PROC_FRAME_REG
argument_list|(
name|proc_desc
argument_list|)
argument_list|)
operator|+
name|PROC_FRAME_OFFSET
argument_list|(
name|proc_desc
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|init_extra_frame_info
parameter_list|(
name|frame
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
block|{
comment|/* Use proc_desc calculated in frame_chain */
name|alpha_extra_func_info_t
name|proc_desc
init|=
name|frame
operator|->
name|next
condition|?
name|cached_proc_desc
else|:
name|find_proc_desc
argument_list|(
name|frame
operator|->
name|pc
argument_list|,
name|frame
operator|->
name|next
argument_list|)
decl_stmt|;
name|frame
operator|->
name|saved_regs
operator|=
name|NULL
expr_stmt|;
name|frame
operator|->
name|localoff
operator|=
literal|0
expr_stmt|;
name|frame
operator|->
name|pc_reg
operator|=
name|RA_REGNUM
expr_stmt|;
name|frame
operator|->
name|proc_desc
operator|=
name|proc_desc
operator|==
operator|&
name|temp_proc_desc
condition|?
literal|0
else|:
name|proc_desc
expr_stmt|;
if|if
condition|(
name|proc_desc
condition|)
block|{
comment|/* Get the locals offset and the saved pc register from the 	 procedure descriptor, they are valid even if we are in the 	 middle of the prologue.  */
name|frame
operator|->
name|localoff
operator|=
name|PROC_LOCALOFF
argument_list|(
name|proc_desc
argument_list|)
expr_stmt|;
name|frame
operator|->
name|pc_reg
operator|=
name|PROC_PC_REG
argument_list|(
name|proc_desc
argument_list|)
expr_stmt|;
comment|/* Fixup frame-pointer - only needed for top frame */
comment|/* Fetch the frame pointer for a dummy frame from the procedure 	 descriptor.  */
if|if
condition|(
name|PROC_DESC_IS_DUMMY
argument_list|(
name|proc_desc
argument_list|)
condition|)
name|frame
operator|->
name|frame
operator|=
operator|(
name|CORE_ADDR
operator|)
name|PROC_DUMMY_FRAME
argument_list|(
name|proc_desc
argument_list|)
expr_stmt|;
comment|/* This may not be quite right, if proc has a real frame register. 	 Get the value of the frame relative sp, procedure might have been 	 interrupted by a signal at it's very start.  */
elseif|else
if|if
condition|(
name|frame
operator|->
name|pc
operator|==
name|PROC_LOW_ADDR
argument_list|(
name|proc_desc
argument_list|)
operator|&&
operator|!
name|PROC_DESC_IS_DYN_SIGTRAMP
argument_list|(
name|proc_desc
argument_list|)
condition|)
name|frame
operator|->
name|frame
operator|=
name|read_next_frame_reg
argument_list|(
name|frame
operator|->
name|next
argument_list|,
name|SP_REGNUM
argument_list|)
expr_stmt|;
else|else
name|frame
operator|->
name|frame
operator|=
name|read_next_frame_reg
argument_list|(
name|frame
operator|->
name|next
argument_list|,
name|PROC_FRAME_REG
argument_list|(
name|proc_desc
argument_list|)
argument_list|)
operator|+
name|PROC_FRAME_OFFSET
argument_list|(
name|proc_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc_desc
operator|==
operator|&
name|temp_proc_desc
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Do not set the saved registers for a sigtramp frame, 	     alpha_find_saved_registers will do that for us. 	     We can't use frame->signal_handler_caller, it is not yet set.  */
name|find_pc_partial_function
argument_list|(
name|frame
operator|->
name|pc
argument_list|,
operator|&
name|name
argument_list|,
operator|(
name|CORE_ADDR
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|CORE_ADDR
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IN_SIGTRAMP
argument_list|(
name|frame
operator|->
name|pc
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|frame
operator|->
name|saved_regs
operator|=
operator|(
name|CORE_ADDR
operator|*
operator|)
name|frame_obstack_alloc
argument_list|(
name|SIZEOF_FRAME_SAVED_REGS
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|frame
operator|->
name|saved_regs
argument_list|,
name|temp_saved_regs
operator|.
name|regs
argument_list|,
name|SIZEOF_FRAME_SAVED_REGS
argument_list|)
expr_stmt|;
name|frame
operator|->
name|saved_regs
index|[
name|PC_REGNUM
index|]
operator|=
name|frame
operator|->
name|saved_regs
index|[
name|RA_REGNUM
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* ALPHA stack frames are almost impenetrable.  When execution stops,    we basically have to look at symbol information for the function    that we stopped in, which tells us *which* register (if any) is    the base of the frame pointer, and what offset from that register    the frame itself is at.       This presents a problem when trying to examine a stack in memory    (that isn't executing at the moment), using the "frame" command.  We    don't have a PC, nor do we have any registers except SP.     This routine takes two arguments, SP and PC, and tries to make the    cached frames look as if these two arguments defined a frame on the    cache.  This allows the rest of info frame to extract the important    arguments without difficulty.  */
end_comment

begin_function
name|struct
name|frame_info
modifier|*
name|setup_arbitrary_frame
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|CORE_ADDR
modifier|*
name|argv
decl_stmt|;
block|{
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
name|error
argument_list|(
literal|"ALPHA frame specifications require two arguments: sp and pc"
argument_list|)
expr_stmt|;
return|return
name|create_new_frame
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The alpha passes the first six arguments in the registers, the rest on    the stack. The register arguments are eventually transferred to the    argument transfer area immediately below the stack by the called function    anyway. So we `push' at least six arguments on the stack, `reload' the    argument registers and then adjust the stack pointer to point past the    sixth argument. This algorithm simplifies the passing of a large struct    which extends from the registers to the stack.    If the called function is returning a structure, the address of the    structure to be returned is passed as a hidden first argument.  */
end_comment

begin_function
name|CORE_ADDR
name|alpha_push_arguments
parameter_list|(
name|nargs
parameter_list|,
name|args
parameter_list|,
name|sp
parameter_list|,
name|struct_return
parameter_list|,
name|struct_addr
parameter_list|)
name|int
name|nargs
decl_stmt|;
name|value_ptr
modifier|*
name|args
decl_stmt|;
name|CORE_ADDR
name|sp
decl_stmt|;
name|int
name|struct_return
decl_stmt|;
name|CORE_ADDR
name|struct_addr
decl_stmt|;
block|{
specifier|register
name|i
expr_stmt|;
name|int
name|accumulate_size
init|=
name|struct_return
condition|?
literal|8
else|:
literal|0
decl_stmt|;
name|int
name|arg_regs_size
init|=
name|ALPHA_NUM_ARG_REGS
operator|*
literal|8
decl_stmt|;
struct|struct
name|alpha_arg
block|{
name|char
modifier|*
name|contents
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|}
struct|;
name|struct
name|alpha_arg
modifier|*
name|alpha_args
init|=
operator|(
expr|struct
name|alpha_arg
operator|*
operator|)
name|alloca
argument_list|(
name|nargs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|alpha_arg
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|alpha_arg
modifier|*
name|m_arg
decl_stmt|;
name|char
name|raw_buffer
index|[
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
index|]
decl_stmt|;
name|int
name|required_arg_regs
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|m_arg
operator|=
name|alpha_args
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
operator|,
name|m_arg
operator|++
control|)
block|{
name|value_ptr
name|arg
init|=
name|args
index|[
name|i
index|]
decl_stmt|;
name|struct
name|type
modifier|*
name|arg_type
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Cast argument to long if necessary as the compiler does it too.  */
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|arg_type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_BOOL
case|:
case|case
name|TYPE_CODE_CHAR
case|:
case|case
name|TYPE_CODE_RANGE
case|:
case|case
name|TYPE_CODE_ENUM
case|:
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|arg_type
argument_list|)
operator|<
name|TYPE_LENGTH
argument_list|(
name|builtin_type_long
argument_list|)
condition|)
block|{
name|arg_type
operator|=
name|builtin_type_long
expr_stmt|;
name|arg
operator|=
name|value_cast
argument_list|(
name|arg_type
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
name|m_arg
operator|->
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|arg_type
argument_list|)
expr_stmt|;
name|m_arg
operator|->
name|offset
operator|=
name|accumulate_size
expr_stmt|;
name|accumulate_size
operator|=
operator|(
name|accumulate_size
operator|+
name|m_arg
operator|->
name|len
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
name|m_arg
operator|->
name|contents
operator|=
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
comment|/* Determine required argument register loads, loading an argument register      is expensive as it uses three ptrace calls.  */
name|required_arg_regs
operator|=
name|accumulate_size
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|required_arg_regs
operator|>
name|ALPHA_NUM_ARG_REGS
condition|)
name|required_arg_regs
operator|=
name|ALPHA_NUM_ARG_REGS
expr_stmt|;
comment|/* Make room for the arguments on the stack.  */
if|if
condition|(
name|accumulate_size
operator|<
name|arg_regs_size
condition|)
name|accumulate_size
operator|=
name|arg_regs_size
expr_stmt|;
name|sp
operator|-=
name|accumulate_size
expr_stmt|;
comment|/* Keep sp aligned to a multiple of 16 as the compiler does it too.  */
name|sp
operator|&=
operator|~
literal|15
expr_stmt|;
comment|/* `Push' arguments on the stack.  */
for|for
control|(
name|i
operator|=
name|nargs
init|;
name|m_arg
operator|--
operator|,
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
name|write_memory
argument_list|(
name|sp
operator|+
name|m_arg
operator|->
name|offset
argument_list|,
name|m_arg
operator|->
name|contents
argument_list|,
name|m_arg
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|struct_return
condition|)
block|{
name|store_address
argument_list|(
name|raw_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
argument_list|,
name|struct_addr
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|sp
argument_list|,
name|raw_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Load the argument registers.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|required_arg_regs
condition|;
name|i
operator|++
control|)
block|{
name|LONGEST
name|val
decl_stmt|;
name|val
operator|=
name|read_memory_integer
argument_list|(
name|sp
operator|+
name|i
operator|*
literal|8
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|A0_REGNUM
operator|+
name|i
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|FPA0_REGNUM
operator|+
name|i
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
return|return
name|sp
operator|+
name|arg_regs_size
return|;
block|}
end_function

begin_function
name|void
name|alpha_push_dummy_frame
parameter_list|()
block|{
name|int
name|ireg
decl_stmt|;
name|struct
name|linked_proc_info
modifier|*
name|link
decl_stmt|;
name|alpha_extra_func_info_t
name|proc_desc
decl_stmt|;
name|CORE_ADDR
name|sp
init|=
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|save_address
decl_stmt|;
name|char
name|raw_buffer
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|unsigned
name|long
name|mask
decl_stmt|;
name|link
operator|=
operator|(
expr|struct
name|linked_proc_info
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|linked_proc_info
argument_list|)
argument_list|)
expr_stmt|;
name|link
operator|->
name|next
operator|=
name|linked_proc_desc_table
expr_stmt|;
name|linked_proc_desc_table
operator|=
name|link
expr_stmt|;
name|proc_desc
operator|=
operator|&
name|link
operator|->
name|info
expr_stmt|;
comment|/*    * The registers we must save are all those not preserved across    * procedure calls.    * In addition, we must save the PC and RA.    *    * Dummy frame layout:    *  (high memory)    * 	Saved PC    *    Saved F30    *    ...    *    Saved F0    *	Saved R29    *	...    *	Saved R0    *	Saved R26 (RA)    *	Parameter build area    *  (low memory)    */
comment|/* MASK(i,j) == (1<<i) + (1<<(i+1)) + ... + (1<<j)). Assume i<=j<31. */
define|#
directive|define
name|MASK
parameter_list|(
name|i
parameter_list|,
name|j
parameter_list|)
value|((((LONGEST)1<< ((j)+1)) - 1) ^ (((LONGEST)1<< (i)) - 1))
define|#
directive|define
name|GEN_REG_SAVE_MASK
value|(MASK(0,8) | MASK(16,29))
define|#
directive|define
name|GEN_REG_SAVE_COUNT
value|24
define|#
directive|define
name|FLOAT_REG_SAVE_MASK
value|(MASK(0,1) | MASK(10,30))
define|#
directive|define
name|FLOAT_REG_SAVE_COUNT
value|23
comment|/* The special register is the PC as we have no bit for it in the save masks.      alpha_frame_saved_pc knows where the pc is saved in a dummy frame.  */
define|#
directive|define
name|SPECIAL_REG_SAVE_COUNT
value|1
name|PROC_REG_MASK
argument_list|(
name|proc_desc
argument_list|)
operator|=
name|GEN_REG_SAVE_MASK
expr_stmt|;
name|PROC_FREG_MASK
argument_list|(
name|proc_desc
argument_list|)
operator|=
name|FLOAT_REG_SAVE_MASK
expr_stmt|;
comment|/* PROC_REG_OFFSET is the offset from the dummy frame to the saved RA,      but keep SP aligned to a multiple of 16.  */
name|PROC_REG_OFFSET
argument_list|(
name|proc_desc
argument_list|)
operator|=
operator|-
operator|(
operator|(
literal|8
operator|*
operator|(
name|SPECIAL_REG_SAVE_COUNT
operator|+
name|GEN_REG_SAVE_COUNT
operator|+
name|FLOAT_REG_SAVE_COUNT
operator|)
operator|+
literal|15
operator|)
operator|&
operator|~
literal|15
operator|)
expr_stmt|;
name|PROC_FREG_OFFSET
argument_list|(
name|proc_desc
argument_list|)
operator|=
name|PROC_REG_OFFSET
argument_list|(
name|proc_desc
argument_list|)
operator|+
literal|8
operator|*
name|GEN_REG_SAVE_COUNT
expr_stmt|;
comment|/* Save general registers.      The return address register is the first saved register, all other      registers follow in ascending order.      The PC is saved immediately below the SP.  */
name|save_address
operator|=
name|sp
operator|+
name|PROC_REG_OFFSET
argument_list|(
name|proc_desc
argument_list|)
expr_stmt|;
name|store_address
argument_list|(
name|raw_buffer
argument_list|,
literal|8
argument_list|,
name|read_register
argument_list|(
name|RA_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|save_address
argument_list|,
name|raw_buffer
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|save_address
operator|+=
literal|8
expr_stmt|;
name|mask
operator|=
name|PROC_REG_MASK
argument_list|(
name|proc_desc
argument_list|)
operator|&
literal|0xffffffffL
expr_stmt|;
for|for
control|(
name|ireg
operator|=
literal|0
init|;
name|mask
condition|;
name|ireg
operator|++
operator|,
name|mask
operator|>>=
literal|1
control|)
if|if
condition|(
name|mask
operator|&
literal|1
condition|)
block|{
if|if
condition|(
name|ireg
operator|==
name|RA_REGNUM
condition|)
continue|continue;
name|store_address
argument_list|(
name|raw_buffer
argument_list|,
literal|8
argument_list|,
name|read_register
argument_list|(
name|ireg
argument_list|)
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|save_address
argument_list|,
name|raw_buffer
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|save_address
operator|+=
literal|8
expr_stmt|;
block|}
name|store_address
argument_list|(
name|raw_buffer
argument_list|,
literal|8
argument_list|,
name|read_register
argument_list|(
name|PC_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|sp
operator|-
literal|8
argument_list|,
name|raw_buffer
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* Save floating point registers.  */
name|save_address
operator|=
name|sp
operator|+
name|PROC_FREG_OFFSET
argument_list|(
name|proc_desc
argument_list|)
expr_stmt|;
name|mask
operator|=
name|PROC_FREG_MASK
argument_list|(
name|proc_desc
argument_list|)
operator|&
literal|0xffffffffL
expr_stmt|;
for|for
control|(
name|ireg
operator|=
literal|0
init|;
name|mask
condition|;
name|ireg
operator|++
operator|,
name|mask
operator|>>=
literal|1
control|)
if|if
condition|(
name|mask
operator|&
literal|1
condition|)
block|{
name|store_address
argument_list|(
name|raw_buffer
argument_list|,
literal|8
argument_list|,
name|read_register
argument_list|(
name|ireg
operator|+
name|FP0_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|save_address
argument_list|,
name|raw_buffer
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|save_address
operator|+=
literal|8
expr_stmt|;
block|}
comment|/* Set and save the frame address for the dummy.        This is tricky. The only registers that are suitable for a frame save      are those that are preserved across procedure calls (s0-s6). But if      a read system call is interrupted and then a dummy call is made      (see testsuite/gdb.t17/interrupt.exp) the dummy call hangs till the read      is satisfied. Then it returns with the s0-s6 registers set to the values      on entry to the read system call and our dummy frame pointer would be      destroyed. So we save the dummy frame in the proc_desc and handle the      retrieval of the frame pointer of a dummy specifically. The frame register      is set to the virtual frame (pseudo) register, it's value will always      be read as zero and will help us to catch any errors in the dummy frame      retrieval code.  */
name|PROC_DUMMY_FRAME
argument_list|(
name|proc_desc
argument_list|)
operator|=
name|sp
expr_stmt|;
name|PROC_FRAME_REG
argument_list|(
name|proc_desc
argument_list|)
operator|=
name|FP_REGNUM
expr_stmt|;
name|PROC_FRAME_OFFSET
argument_list|(
name|proc_desc
argument_list|)
operator|=
literal|0
expr_stmt|;
name|sp
operator|+=
name|PROC_REG_OFFSET
argument_list|(
name|proc_desc
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|PROC_LOW_ADDR
argument_list|(
name|proc_desc
argument_list|)
operator|=
name|CALL_DUMMY_ADDRESS
argument_list|()
expr_stmt|;
name|PROC_HIGH_ADDR
argument_list|(
name|proc_desc
argument_list|)
operator|=
name|PROC_LOW_ADDR
argument_list|(
name|proc_desc
argument_list|)
operator|+
literal|4
expr_stmt|;
name|SET_PROC_DESC_IS_DUMMY
argument_list|(
name|proc_desc
argument_list|)
expr_stmt|;
name|PROC_PC_REG
argument_list|(
name|proc_desc
argument_list|)
operator|=
name|RA_REGNUM
expr_stmt|;
block|}
end_function

begin_function
name|void
name|alpha_pop_frame
parameter_list|()
block|{
specifier|register
name|int
name|regnum
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|frame
init|=
name|get_current_frame
argument_list|()
decl_stmt|;
name|CORE_ADDR
name|new_sp
init|=
name|frame
operator|->
name|frame
decl_stmt|;
name|alpha_extra_func_info_t
name|proc_desc
init|=
name|frame
operator|->
name|proc_desc
decl_stmt|;
name|write_register
argument_list|(
name|PC_REGNUM
argument_list|,
name|FRAME_SAVED_PC
argument_list|(
name|frame
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|->
name|saved_regs
operator|==
name|NULL
condition|)
name|alpha_find_saved_regs
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc_desc
condition|)
block|{
for|for
control|(
name|regnum
operator|=
literal|32
init|;
operator|--
name|regnum
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|PROC_REG_MASK
argument_list|(
name|proc_desc
argument_list|)
operator|&
operator|(
literal|1
operator|<<
name|regnum
operator|)
condition|)
name|write_register
argument_list|(
name|regnum
argument_list|,
name|read_memory_integer
argument_list|(
name|frame
operator|->
name|saved_regs
index|[
name|regnum
index|]
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|regnum
operator|=
literal|32
init|;
operator|--
name|regnum
operator|>=
literal|0
condition|;
control|)
if|if
condition|(
name|PROC_FREG_MASK
argument_list|(
name|proc_desc
argument_list|)
operator|&
operator|(
literal|1
operator|<<
name|regnum
operator|)
condition|)
name|write_register
argument_list|(
name|regnum
operator|+
name|FP0_REGNUM
argument_list|,
name|read_memory_integer
argument_list|(
name|frame
operator|->
name|saved_regs
index|[
name|regnum
operator|+
name|FP0_REGNUM
index|]
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|write_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|new_sp
argument_list|)
expr_stmt|;
name|flush_cached_frames
argument_list|()
expr_stmt|;
if|if
condition|(
name|proc_desc
operator|&&
operator|(
name|PROC_DESC_IS_DUMMY
argument_list|(
name|proc_desc
argument_list|)
operator|||
name|PROC_DESC_IS_DYN_SIGTRAMP
argument_list|(
name|proc_desc
argument_list|)
operator|)
condition|)
block|{
name|struct
name|linked_proc_info
modifier|*
name|pi_ptr
decl_stmt|,
modifier|*
name|prev_ptr
decl_stmt|;
for|for
control|(
name|pi_ptr
operator|=
name|linked_proc_desc_table
operator|,
name|prev_ptr
operator|=
name|NULL
init|;
name|pi_ptr
operator|!=
name|NULL
condition|;
name|prev_ptr
operator|=
name|pi_ptr
operator|,
name|pi_ptr
operator|=
name|pi_ptr
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|&
name|pi_ptr
operator|->
name|info
operator|==
name|proc_desc
condition|)
break|break;
block|}
if|if
condition|(
name|pi_ptr
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Can't locate dummy extra frame info\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev_ptr
operator|!=
name|NULL
condition|)
name|prev_ptr
operator|->
name|next
operator|=
name|pi_ptr
operator|->
name|next
expr_stmt|;
else|else
name|linked_proc_desc_table
operator|=
name|pi_ptr
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|pi_ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* To skip prologues, I use this predicate.  Returns either PC itself    if the code at PC does not look like a function prologue; otherwise    returns an address that (if we're lucky) follows the prologue.  If    LENIENT, then we must skip everything which is involved in setting    up the frame (it's OK to skip more, just so long as we don't skip    anything which might clobber the registers which are being saved.    Currently we must not skip more on the alpha, but we might the lenient    stuff some day.  */
end_comment

begin_function
name|CORE_ADDR
name|alpha_skip_prologue
parameter_list|(
name|pc
parameter_list|,
name|lenient
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|int
name|lenient
decl_stmt|;
block|{
name|unsigned
name|long
name|inst
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|CORE_ADDR
name|post_prologue_pc
decl_stmt|;
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|GDB_TARGET_HAS_SHARED_LIBS
comment|/* Silently return the unaltered pc upon memory errors.        This could happen on OSF/1 if decode_line_1 tries to skip the        prologue for quickstarted shared library functions when the        shared library is not yet mapped in.        Reading target memory is slow over serial lines, so we perform        this check only if the target has shared libraries.  */
if|if
condition|(
name|target_read_memory
argument_list|(
name|pc
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
condition|)
return|return
name|pc
return|;
endif|#
directive|endif
comment|/* See if we can determine the end of the prologue via the symbol table.        If so, then return either PC, or the PC after the prologue, whichever        is greater.  */
name|post_prologue_pc
operator|=
name|after_prologue
argument_list|(
name|pc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|post_prologue_pc
operator|!=
literal|0
condition|)
return|return
name|max
argument_list|(
name|pc
argument_list|,
name|post_prologue_pc
argument_list|)
return|;
comment|/* Can't determine prologue from the symbol table, need to examine        instructions.  */
comment|/* Skip the typical prologue instructions. These are the stack adjustment        instruction and the instructions that save registers on the stack        or in the gcc frame.  */
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
literal|100
condition|;
name|offset
operator|+=
literal|4
control|)
block|{
name|int
name|status
decl_stmt|;
name|status
operator|=
name|read_memory_nobpt
argument_list|(
name|pc
operator|+
name|offset
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|memory_error
argument_list|(
name|status
argument_list|,
name|pc
operator|+
name|offset
argument_list|)
expr_stmt|;
name|inst
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* The alpha has no delay slots. But let's keep the lenient stuff, 	   we might need it for something else in the future.  */
if|if
condition|(
name|lenient
operator|&&
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0x27bb0000
condition|)
comment|/* ldah $gp,n($t12) */
continue|continue;
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0x23bd0000
condition|)
comment|/* lda $gp,n($gp) */
continue|continue;
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0x23de0000
condition|)
comment|/* lda $sp,n($sp) */
continue|continue;
elseif|else
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xfc1f0000
operator|)
operator|==
literal|0xb41e0000
operator|&&
operator|(
name|inst
operator|&
literal|0xffff0000
operator|)
operator|!=
literal|0xb7fe0000
condition|)
continue|continue;
comment|/* stq reg,n($sp) */
comment|/* reg != $zero */
elseif|else
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xfc1f0000
operator|)
operator|==
literal|0x9c1e0000
operator|&&
operator|(
name|inst
operator|&
literal|0xffff0000
operator|)
operator|!=
literal|0x9ffe0000
condition|)
continue|continue;
comment|/* stt reg,n($sp) */
comment|/* reg != $zero */
elseif|else
if|if
condition|(
name|inst
operator|==
literal|0x47de040f
condition|)
comment|/* bis sp,sp,fp */
continue|continue;
else|else
break|break;
block|}
return|return
name|pc
operator|+
name|offset
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Is address PC in the prologue (loosely defined) for function at    STARTADDR?  */
end_comment

begin_endif
unit|static int alpha_in_lenient_prologue (startaddr, pc)      CORE_ADDR startaddr;      CORE_ADDR pc; {   CORE_ADDR end_prologue = alpha_skip_prologue (startaddr, 1);   return pc>= startaddr&& pc< end_prologue; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* The alpha needs a conversion between register and memory format if    the register is a floating point register and       memory format is float, as the register format must be double    or       memory format is an integer with 4 bytes or less, as the representation       of integers in floating point registers is different. */
end_comment

begin_function
name|void
name|alpha_register_convert_to_virtual
parameter_list|(
name|regnum
parameter_list|,
name|valtype
parameter_list|,
name|raw_buffer
parameter_list|,
name|virtual_buffer
parameter_list|)
name|int
name|regnum
decl_stmt|;
name|struct
name|type
modifier|*
name|valtype
decl_stmt|;
name|char
modifier|*
name|raw_buffer
decl_stmt|;
name|char
modifier|*
name|virtual_buffer
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
operator|>=
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|virtual_buffer
argument_list|,
name|raw_buffer
argument_list|,
name|REGISTER_VIRTUAL_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|TYPE_CODE_FLT
condition|)
block|{
name|double
name|d
init|=
name|extract_floating
argument_list|(
name|raw_buffer
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
decl_stmt|;
name|store_floating
argument_list|(
name|virtual_buffer
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|&&
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
operator|<=
literal|4
condition|)
block|{
name|ULONGEST
name|l
decl_stmt|;
name|l
operator|=
name|extract_unsigned_integer
argument_list|(
name|raw_buffer
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
name|l
operator|=
operator|(
operator|(
name|l
operator|>>
literal|32
operator|)
operator|&
literal|0xc0000000
operator|)
operator||
operator|(
operator|(
name|l
operator|>>
literal|29
operator|)
operator|&
literal|0x3fffffff
operator|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|virtual_buffer
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Cannot retrieve value from floating point register"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|alpha_register_convert_to_raw
parameter_list|(
name|valtype
parameter_list|,
name|regnum
parameter_list|,
name|virtual_buffer
parameter_list|,
name|raw_buffer
parameter_list|)
name|struct
name|type
modifier|*
name|valtype
decl_stmt|;
name|int
name|regnum
decl_stmt|;
name|char
modifier|*
name|virtual_buffer
decl_stmt|;
name|char
modifier|*
name|raw_buffer
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
operator|>=
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|raw_buffer
argument_list|,
name|virtual_buffer
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|TYPE_CODE_FLT
condition|)
block|{
name|double
name|d
init|=
name|extract_floating
argument_list|(
name|virtual_buffer
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
argument_list|)
decl_stmt|;
name|store_floating
argument_list|(
name|raw_buffer
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|&&
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
operator|<=
literal|4
condition|)
block|{
name|ULONGEST
name|l
decl_stmt|;
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|valtype
argument_list|)
condition|)
name|l
operator|=
name|extract_unsigned_integer
argument_list|(
name|virtual_buffer
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|l
operator|=
name|extract_signed_integer
argument_list|(
name|virtual_buffer
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
argument_list|)
expr_stmt|;
name|l
operator|=
operator|(
operator|(
name|l
operator|&
literal|0xc0000000
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
name|l
operator|&
literal|0x3fffffff
operator|)
operator|<<
literal|29
operator|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|raw_buffer
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Cannot store value in floating point register"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a return value in `regbuf' with a type `valtype',     extract and copy its value into `valbuf'.  */
end_comment

begin_function
name|void
name|alpha_extract_return_value
parameter_list|(
name|valtype
parameter_list|,
name|regbuf
parameter_list|,
name|valbuf
parameter_list|)
name|struct
name|type
modifier|*
name|valtype
decl_stmt|;
name|char
name|regbuf
index|[
name|REGISTER_BYTES
index|]
decl_stmt|;
name|char
modifier|*
name|valbuf
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|TYPE_CODE_FLT
condition|)
name|alpha_register_convert_to_virtual
argument_list|(
name|FP0_REGNUM
argument_list|,
name|valtype
argument_list|,
name|regbuf
operator|+
name|REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
argument_list|)
argument_list|,
name|valbuf
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|valbuf
argument_list|,
name|regbuf
operator|+
name|REGISTER_BYTE
argument_list|(
name|V0_REGNUM
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a return value in `regbuf' with a type `valtype',     write its value into the appropriate register.  */
end_comment

begin_function
name|void
name|alpha_store_return_value
parameter_list|(
name|valtype
parameter_list|,
name|valbuf
parameter_list|)
name|struct
name|type
modifier|*
name|valtype
decl_stmt|;
name|char
modifier|*
name|valbuf
decl_stmt|;
block|{
name|char
name|raw_buffer
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|int
name|regnum
init|=
name|V0_REGNUM
decl_stmt|;
name|int
name|length
init|=
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|TYPE_CODE_FLT
condition|)
block|{
name|regnum
operator|=
name|FP0_REGNUM
expr_stmt|;
name|length
operator|=
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
name|alpha_register_convert_to_raw
argument_list|(
name|valtype
argument_list|,
name|regnum
argument_list|,
name|valbuf
argument_list|,
name|raw_buffer
argument_list|)
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|raw_buffer
argument_list|,
name|valbuf
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|write_register_bytes
argument_list|(
name|REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
argument_list|,
name|raw_buffer
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Just like reinit_frame_cache, but with the right arguments to be    callable as an sfunc.  */
end_comment

begin_function
specifier|static
name|void
name|reinit_frame_cache_sfunc
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|,
name|c
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
block|{
name|reinit_frame_cache
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is the definition of CALL_DUMMY_ADDRESS.  It's a heuristic that is used    to find a convenient place in the text segment to stick a breakpoint to    detect the completion of a target function call (ala call_function_by_hand).  */
end_comment

begin_function
name|CORE_ADDR
name|alpha_call_dummy_address
parameter_list|()
block|{
name|CORE_ADDR
name|entry
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|sym
decl_stmt|;
name|entry
operator|=
name|entry_point_address
argument_list|()
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
literal|0
condition|)
return|return
name|entry
return|;
name|sym
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"_Prelude"
argument_list|,
name|NULL
argument_list|,
name|symfile_objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sym
operator|||
name|MSYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|!=
name|mst_text
condition|)
return|return
literal|0
return|;
else|else
return|return
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|+
literal|4
return|;
block|}
end_function

begin_function
name|void
name|_initialize_alpha_tdep
parameter_list|()
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|tm_print_insn
operator|=
name|print_insn_alpha
expr_stmt|;
comment|/* Let the user set the fence post for heuristic_proc_start.  */
comment|/* We really would like to have both "0" and "unlimited" work, but      command.c doesn't deal with that.  So make it a var_zinteger      because the user can always use "999999" or some such for unlimited.  */
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"heuristic-fence-post"
argument_list|,
name|class_support
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|heuristic_fence_post
argument_list|,
literal|"\ Set the distance searched for the start of a function.\n\ If you are debugging a stripped executable, GDB needs to search through the\n\ program for the start of a function.  This command sets the distance of the\n\ search.  The only need to set it is when debugging a stripped executable."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
comment|/* We need to throw away the frame cache when we set this, since it      might change our ability to get backtraces.  */
name|c
operator|->
name|function
operator|.
name|sfunc
operator|=
name|reinit_frame_cache_sfunc
expr_stmt|;
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

