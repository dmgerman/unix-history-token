begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target-dependent code for the ALPHA architecture, for GDB, the GNU Debugger.    Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"doublest.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"frame-unwind.h"
end_include

begin_include
include|#
directive|include
file|"frame-base.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2-frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"linespec.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"reggroups.h"
end_include

begin_include
include|#
directive|include
file|"arch-utils.h"
end_include

begin_include
include|#
directive|include
file|"osabi.h"
end_include

begin_include
include|#
directive|include
file|"block.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"alpha-tdep.h"
end_include

begin_escape
end_escape

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|alpha_register_name
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|register_names
index|[]
init|=
block|{
literal|"v0"
block|,
literal|"t0"
block|,
literal|"t1"
block|,
literal|"t2"
block|,
literal|"t3"
block|,
literal|"t4"
block|,
literal|"t5"
block|,
literal|"t6"
block|,
literal|"t7"
block|,
literal|"s0"
block|,
literal|"s1"
block|,
literal|"s2"
block|,
literal|"s3"
block|,
literal|"s4"
block|,
literal|"s5"
block|,
literal|"fp"
block|,
literal|"a0"
block|,
literal|"a1"
block|,
literal|"a2"
block|,
literal|"a3"
block|,
literal|"a4"
block|,
literal|"a5"
block|,
literal|"t8"
block|,
literal|"t9"
block|,
literal|"t10"
block|,
literal|"t11"
block|,
literal|"ra"
block|,
literal|"t12"
block|,
literal|"at"
block|,
literal|"gp"
block|,
literal|"sp"
block|,
literal|"zero"
block|,
literal|"f0"
block|,
literal|"f1"
block|,
literal|"f2"
block|,
literal|"f3"
block|,
literal|"f4"
block|,
literal|"f5"
block|,
literal|"f6"
block|,
literal|"f7"
block|,
literal|"f8"
block|,
literal|"f9"
block|,
literal|"f10"
block|,
literal|"f11"
block|,
literal|"f12"
block|,
literal|"f13"
block|,
literal|"f14"
block|,
literal|"f15"
block|,
literal|"f16"
block|,
literal|"f17"
block|,
literal|"f18"
block|,
literal|"f19"
block|,
literal|"f20"
block|,
literal|"f21"
block|,
literal|"f22"
block|,
literal|"f23"
block|,
literal|"f24"
block|,
literal|"f25"
block|,
literal|"f26"
block|,
literal|"f27"
block|,
literal|"f28"
block|,
literal|"f29"
block|,
literal|"f30"
block|,
literal|"fpcr"
block|,
literal|"pc"
block|,
literal|""
block|,
literal|"unique"
block|}
decl_stmt|;
if|if
condition|(
name|regno
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|regno
operator|>=
operator|(
sizeof|sizeof
argument_list|(
name|register_names
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|register_names
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
return|return
name|register_names
index|[
name|regno
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alpha_cannot_fetch_register
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
return|return
name|regno
operator|==
name|ALPHA_ZERO_REGNUM
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alpha_cannot_store_register
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
return|return
name|regno
operator|==
name|ALPHA_ZERO_REGNUM
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|type
modifier|*
name|alpha_register_type
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
name|regno
operator|==
name|ALPHA_SP_REGNUM
operator|||
name|regno
operator|==
name|ALPHA_GP_REGNUM
condition|)
return|return
name|builtin_type_void_data_ptr
return|;
if|if
condition|(
name|regno
operator|==
name|ALPHA_PC_REGNUM
condition|)
return|return
name|builtin_type_void_func_ptr
return|;
comment|/* Don't need to worry about little vs big endian until       some jerk tries to port to alpha-unicosmk.  */
if|if
condition|(
name|regno
operator|>=
name|ALPHA_FP0_REGNUM
operator|&&
name|regno
operator|<
name|ALPHA_FP0_REGNUM
operator|+
literal|31
condition|)
return|return
name|builtin_type_ieee_double_little
return|;
return|return
name|builtin_type_int64
return|;
block|}
end_function

begin_comment
comment|/* Is REGNUM a member of REGGROUP?  */
end_comment

begin_function
specifier|static
name|int
name|alpha_register_reggroup_p
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|int
name|regnum
parameter_list|,
name|struct
name|reggroup
modifier|*
name|group
parameter_list|)
block|{
comment|/* Filter out any registers eliminated, but whose regnum is       reserved for backward compatibility, e.g. the vfp.  */
if|if
condition|(
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
operator|==
name|NULL
operator|||
operator|*
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|group
operator|==
name|all_reggroup
condition|)
return|return
literal|1
return|;
comment|/* Zero should not be saved or restored.  Technically it is a general      register (just as $f31 would be a float if we represented it), but      there's no point displaying it during "info regs", so leave it out      of all groups except for "all".  */
if|if
condition|(
name|regnum
operator|==
name|ALPHA_ZERO_REGNUM
condition|)
return|return
literal|0
return|;
comment|/* All other registers are saved and restored.  */
if|if
condition|(
name|group
operator|==
name|save_reggroup
operator|||
name|group
operator|==
name|restore_reggroup
condition|)
return|return
literal|1
return|;
comment|/* All other groups are non-overlapping.  */
comment|/* Since this is really a PALcode memory slot...  */
if|if
condition|(
name|regnum
operator|==
name|ALPHA_UNIQUE_REGNUM
condition|)
return|return
name|group
operator|==
name|system_reggroup
return|;
comment|/* Force the FPCR to be considered part of the floating point state.  */
if|if
condition|(
name|regnum
operator|==
name|ALPHA_FPCR_REGNUM
condition|)
return|return
name|group
operator|==
name|float_reggroup
return|;
if|if
condition|(
name|regnum
operator|>=
name|ALPHA_FP0_REGNUM
operator|&&
name|regnum
operator|<
name|ALPHA_FP0_REGNUM
operator|+
literal|31
condition|)
return|return
name|group
operator|==
name|float_reggroup
return|;
else|else
return|return
name|group
operator|==
name|general_reggroup
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alpha_register_byte
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
return|return
operator|(
name|regno
operator|*
literal|8
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alpha_register_raw_size
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
return|return
literal|8
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alpha_register_virtual_size
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
return|return
literal|8
return|;
block|}
end_function

begin_comment
comment|/* The following represents exactly the conversion performed by    the LDS instruction.  This applies to both single-precision    floating point and 32-bit integers.  */
end_comment

begin_function
specifier|static
name|void
name|alpha_lds
parameter_list|(
name|void
modifier|*
name|out
parameter_list|,
specifier|const
name|void
modifier|*
name|in
parameter_list|)
block|{
name|ULONGEST
name|mem
init|=
name|extract_unsigned_integer
argument_list|(
name|in
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|ULONGEST
name|frac
init|=
operator|(
name|mem
operator|>>
literal|0
operator|)
operator|&
literal|0x7fffff
decl_stmt|;
name|ULONGEST
name|sign
init|=
operator|(
name|mem
operator|>>
literal|31
operator|)
operator|&
literal|1
decl_stmt|;
name|ULONGEST
name|exp_msb
init|=
operator|(
name|mem
operator|>>
literal|30
operator|)
operator|&
literal|1
decl_stmt|;
name|ULONGEST
name|exp_low
init|=
operator|(
name|mem
operator|>>
literal|23
operator|)
operator|&
literal|0x7f
decl_stmt|;
name|ULONGEST
name|exp
decl_stmt|,
name|reg
decl_stmt|;
name|exp
operator|=
operator|(
name|exp_msb
operator|<<
literal|10
operator|)
operator||
name|exp_low
expr_stmt|;
if|if
condition|(
name|exp_msb
condition|)
block|{
if|if
condition|(
name|exp_low
operator|==
literal|0x7f
condition|)
name|exp
operator|=
literal|0x7ff
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|exp_low
operator|!=
literal|0x00
condition|)
name|exp
operator||=
literal|0x380
expr_stmt|;
block|}
name|reg
operator|=
operator|(
name|sign
operator|<<
literal|63
operator|)
operator||
operator|(
name|exp
operator|<<
literal|52
operator|)
operator||
operator|(
name|frac
operator|<<
literal|29
operator|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|out
argument_list|,
literal|8
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Similarly, this represents exactly the conversion performed by    the STS instruction.  */
end_comment

begin_function
specifier|static
name|void
name|alpha_sts
parameter_list|(
name|void
modifier|*
name|out
parameter_list|,
specifier|const
name|void
modifier|*
name|in
parameter_list|)
block|{
name|ULONGEST
name|reg
decl_stmt|,
name|mem
decl_stmt|;
name|reg
operator|=
name|extract_unsigned_integer
argument_list|(
name|in
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|mem
operator|=
operator|(
operator|(
name|reg
operator|>>
literal|32
operator|)
operator|&
literal|0xc0000000
operator|)
operator||
operator|(
operator|(
name|reg
operator|>>
literal|29
operator|)
operator|&
literal|0x3fffffff
operator|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|out
argument_list|,
literal|4
argument_list|,
name|mem
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The alpha needs a conversion between register and memory format if the    register is a floating point register and memory format is float, as the    register format must be double or memory format is an integer with 4    bytes or less, as the representation of integers in floating point    registers is different. */
end_comment

begin_function
specifier|static
name|int
name|alpha_convert_register_p
parameter_list|(
name|int
name|regno
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
return|return
operator|(
name|regno
operator|>=
name|ALPHA_FP0_REGNUM
operator|&&
name|regno
operator|<
name|ALPHA_FP0_REGNUM
operator|+
literal|31
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|alpha_register_to_value
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|regnum
parameter_list|,
name|struct
name|type
modifier|*
name|valtype
parameter_list|,
name|void
modifier|*
name|out
parameter_list|)
block|{
name|char
name|in
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|frame_register_read
argument_list|(
name|frame
argument_list|,
name|regnum
argument_list|,
name|in
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
condition|)
block|{
case|case
literal|4
case|:
name|alpha_sts
argument_list|(
name|out
argument_list|,
name|in
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|memcpy
argument_list|(
name|out
argument_list|,
name|in
argument_list|,
literal|8
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Cannot retrieve value from floating point register"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|alpha_value_to_register
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|regnum
parameter_list|,
name|struct
name|type
modifier|*
name|valtype
parameter_list|,
specifier|const
name|void
modifier|*
name|in
parameter_list|)
block|{
name|char
name|out
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
switch|switch
condition|(
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
condition|)
block|{
case|case
literal|4
case|:
name|alpha_lds
argument_list|(
name|out
argument_list|,
name|in
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|memcpy
argument_list|(
name|out
argument_list|,
name|in
argument_list|,
literal|8
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Cannot store value in floating point register"
argument_list|)
expr_stmt|;
block|}
name|put_frame_register
argument_list|(
name|frame
argument_list|,
name|regnum
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The alpha passes the first six arguments in the registers, the rest on    the stack.  The register arguments are stored in ARG_REG_BUFFER, and    then moved into the register file; this simplifies the passing of a    large struct which extends from the registers to the stack, plus avoids    three ptrace invocations per word.     We don't bother tracking which register values should go in integer    regs or fp regs; we load the same values into both.     If the called function is returning a structure, the address of the    structure to be returned is passed as a hidden first argument.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|alpha_push_dummy_call
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|CORE_ADDR
name|func_addr
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|CORE_ADDR
name|bp_addr
parameter_list|,
name|int
name|nargs
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|args
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|,
name|int
name|struct_return
parameter_list|,
name|CORE_ADDR
name|struct_addr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|accumulate_size
init|=
name|struct_return
condition|?
literal|8
else|:
literal|0
decl_stmt|;
struct|struct
name|alpha_arg
block|{
name|char
modifier|*
name|contents
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|}
struct|;
name|struct
name|alpha_arg
modifier|*
name|alpha_args
init|=
operator|(
expr|struct
name|alpha_arg
operator|*
operator|)
name|alloca
argument_list|(
name|nargs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|alpha_arg
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|alpha_arg
modifier|*
name|m_arg
decl_stmt|;
name|char
name|arg_reg_buffer
index|[
name|ALPHA_REGISTER_SIZE
operator|*
name|ALPHA_NUM_ARG_REGS
index|]
decl_stmt|;
name|int
name|required_arg_regs
decl_stmt|;
comment|/* The ABI places the address of the called function in T12.  */
name|regcache_cooked_write_signed
argument_list|(
name|regcache
argument_list|,
name|ALPHA_T12_REGNUM
argument_list|,
name|func_addr
argument_list|)
expr_stmt|;
comment|/* Set the return address register to point to the entry point      of the program, where a breakpoint lies in wait.  */
name|regcache_cooked_write_signed
argument_list|(
name|regcache
argument_list|,
name|ALPHA_RA_REGNUM
argument_list|,
name|bp_addr
argument_list|)
expr_stmt|;
comment|/* Lay out the arguments in memory.  */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|m_arg
operator|=
name|alpha_args
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
operator|,
name|m_arg
operator|++
control|)
block|{
name|struct
name|value
modifier|*
name|arg
init|=
name|args
index|[
name|i
index|]
decl_stmt|;
name|struct
name|type
modifier|*
name|arg_type
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Cast argument to long if necessary as the compiler does it too.  */
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|arg_type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_BOOL
case|:
case|case
name|TYPE_CODE_CHAR
case|:
case|case
name|TYPE_CODE_RANGE
case|:
case|case
name|TYPE_CODE_ENUM
case|:
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|arg_type
argument_list|)
operator|==
literal|4
condition|)
block|{
comment|/* 32-bit values must be sign-extended to 64 bits 		 even if the base data type is unsigned.  */
name|arg_type
operator|=
name|builtin_type_int32
expr_stmt|;
name|arg
operator|=
name|value_cast
argument_list|(
name|arg_type
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|arg_type
argument_list|)
operator|<
name|ALPHA_REGISTER_SIZE
condition|)
block|{
name|arg_type
operator|=
name|builtin_type_int64
expr_stmt|;
name|arg
operator|=
name|value_cast
argument_list|(
name|arg_type
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_FLT
case|:
comment|/* "float" arguments loaded in registers must be passed in 	     register format, aka "double".  */
if|if
condition|(
name|accumulate_size
operator|<
sizeof|sizeof
argument_list|(
name|arg_reg_buffer
argument_list|)
operator|&&
name|TYPE_LENGTH
argument_list|(
name|arg_type
argument_list|)
operator|==
literal|4
condition|)
block|{
name|arg_type
operator|=
name|builtin_type_ieee_double_little
expr_stmt|;
name|arg
operator|=
name|value_cast
argument_list|(
name|arg_type
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
comment|/* Tru64 5.1 has a 128-bit long double, and passes this by 	     invisible reference.  No one else uses this data type.  */
elseif|else
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|arg_type
argument_list|)
operator|==
literal|16
condition|)
block|{
comment|/* Allocate aligned storage.  */
name|sp
operator|=
operator|(
name|sp
operator|&
operator|-
literal|16
operator|)
operator|-
literal|16
expr_stmt|;
comment|/* Write the real data into the stack.  */
name|write_memory
argument_list|(
name|sp
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* Construct the indirection.  */
name|arg_type
operator|=
name|lookup_pointer_type
argument_list|(
name|arg_type
argument_list|)
expr_stmt|;
name|arg
operator|=
name|value_from_pointer
argument_list|(
name|arg_type
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_COMPLEX
case|:
comment|/* ??? The ABI says that complex values are passed as two 	     separate scalar values.  This distinction only matters 	     for complex float.  However, GCC does not implement this.  */
comment|/* Tru64 5.1 has a 128-bit long double, and passes this by 	     invisible reference.  */
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|arg_type
argument_list|)
operator|==
literal|32
condition|)
block|{
comment|/* Allocate aligned storage.  */
name|sp
operator|=
operator|(
name|sp
operator|&
operator|-
literal|16
operator|)
operator|-
literal|16
expr_stmt|;
comment|/* Write the real data into the stack.  */
name|write_memory
argument_list|(
name|sp
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
argument_list|,
literal|32
argument_list|)
expr_stmt|;
comment|/* Construct the indirection.  */
name|arg_type
operator|=
name|lookup_pointer_type
argument_list|(
name|arg_type
argument_list|)
expr_stmt|;
name|arg
operator|=
name|value_from_pointer
argument_list|(
name|arg_type
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
name|m_arg
operator|->
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|arg_type
argument_list|)
expr_stmt|;
name|m_arg
operator|->
name|offset
operator|=
name|accumulate_size
expr_stmt|;
name|accumulate_size
operator|=
operator|(
name|accumulate_size
operator|+
name|m_arg
operator|->
name|len
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
name|m_arg
operator|->
name|contents
operator|=
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
comment|/* Determine required argument register loads, loading an argument register      is expensive as it uses three ptrace calls.  */
name|required_arg_regs
operator|=
name|accumulate_size
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|required_arg_regs
operator|>
name|ALPHA_NUM_ARG_REGS
condition|)
name|required_arg_regs
operator|=
name|ALPHA_NUM_ARG_REGS
expr_stmt|;
comment|/* Make room for the arguments on the stack.  */
if|if
condition|(
name|accumulate_size
operator|<
sizeof|sizeof
argument_list|(
name|arg_reg_buffer
argument_list|)
condition|)
name|accumulate_size
operator|=
literal|0
expr_stmt|;
else|else
name|accumulate_size
operator|-=
sizeof|sizeof
argument_list|(
name|arg_reg_buffer
argument_list|)
expr_stmt|;
name|sp
operator|-=
name|accumulate_size
expr_stmt|;
comment|/* Keep sp aligned to a multiple of 16 as the ABI requires.  */
name|sp
operator|&=
operator|~
literal|15
expr_stmt|;
comment|/* `Push' arguments on the stack.  */
for|for
control|(
name|i
operator|=
name|nargs
init|;
name|m_arg
operator|--
operator|,
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
name|char
modifier|*
name|contents
init|=
name|m_arg
operator|->
name|contents
decl_stmt|;
name|int
name|offset
init|=
name|m_arg
operator|->
name|offset
decl_stmt|;
name|int
name|len
init|=
name|m_arg
operator|->
name|len
decl_stmt|;
comment|/* Copy the bytes destined for registers into arg_reg_buffer.  */
if|if
condition|(
name|offset
operator|<
sizeof|sizeof
argument_list|(
name|arg_reg_buffer
argument_list|)
condition|)
block|{
if|if
condition|(
name|offset
operator|+
name|len
operator|<=
sizeof|sizeof
argument_list|(
name|arg_reg_buffer
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|arg_reg_buffer
operator|+
name|offset
argument_list|,
name|contents
argument_list|,
name|len
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|int
name|tlen
init|=
sizeof|sizeof
argument_list|(
name|arg_reg_buffer
argument_list|)
operator|-
name|offset
decl_stmt|;
name|memcpy
argument_list|(
name|arg_reg_buffer
operator|+
name|offset
argument_list|,
name|contents
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|tlen
expr_stmt|;
name|contents
operator|+=
name|tlen
expr_stmt|;
name|len
operator|-=
name|tlen
expr_stmt|;
block|}
block|}
comment|/* Everything else goes to the stack.  */
name|write_memory
argument_list|(
name|sp
operator|+
name|offset
operator|-
sizeof|sizeof
argument_list|(
name|arg_reg_buffer
argument_list|)
argument_list|,
name|contents
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|struct_return
condition|)
name|store_unsigned_integer
argument_list|(
name|arg_reg_buffer
argument_list|,
name|ALPHA_REGISTER_SIZE
argument_list|,
name|struct_addr
argument_list|)
expr_stmt|;
comment|/* Load the argument registers.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|required_arg_regs
condition|;
name|i
operator|++
control|)
block|{
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|ALPHA_A0_REGNUM
operator|+
name|i
argument_list|,
name|arg_reg_buffer
operator|+
name|i
operator|*
name|ALPHA_REGISTER_SIZE
argument_list|)
expr_stmt|;
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|ALPHA_FPA0_REGNUM
operator|+
name|i
argument_list|,
name|arg_reg_buffer
operator|+
name|i
operator|*
name|ALPHA_REGISTER_SIZE
argument_list|)
expr_stmt|;
block|}
comment|/* Finally, update the stack pointer.  */
name|regcache_cooked_write_signed
argument_list|(
name|regcache
argument_list|,
name|ALPHA_SP_REGNUM
argument_list|,
name|sp
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_comment
comment|/* Extract from REGCACHE the value about to be returned from a function    and copy it into VALBUF.  */
end_comment

begin_function
specifier|static
name|void
name|alpha_extract_return_value
parameter_list|(
name|struct
name|type
modifier|*
name|valtype
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|void
modifier|*
name|valbuf
parameter_list|)
block|{
name|int
name|length
init|=
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
decl_stmt|;
name|char
name|raw_buffer
index|[
name|ALPHA_REGISTER_SIZE
index|]
decl_stmt|;
name|ULONGEST
name|l
decl_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|valtype
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_FLT
case|:
switch|switch
condition|(
name|length
condition|)
block|{
case|case
literal|4
case|:
name|regcache_cooked_read
argument_list|(
name|regcache
argument_list|,
name|ALPHA_FP0_REGNUM
argument_list|,
name|raw_buffer
argument_list|)
expr_stmt|;
name|alpha_sts
argument_list|(
name|valbuf
argument_list|,
name|raw_buffer
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|regcache_cooked_read
argument_list|(
name|regcache
argument_list|,
name|ALPHA_FP0_REGNUM
argument_list|,
name|valbuf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|regcache_cooked_read_unsigned
argument_list|(
name|regcache
argument_list|,
name|ALPHA_V0_REGNUM
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
name|read_memory
argument_list|(
name|l
argument_list|,
name|valbuf
argument_list|,
literal|16
argument_list|)
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"unknown floating point width"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_COMPLEX
case|:
switch|switch
condition|(
name|length
condition|)
block|{
case|case
literal|8
case|:
comment|/* ??? This isn't correct wrt the ABI, but it's what GCC does.  */
name|regcache_cooked_read
argument_list|(
name|regcache
argument_list|,
name|ALPHA_FP0_REGNUM
argument_list|,
name|valbuf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|regcache_cooked_read
argument_list|(
name|regcache
argument_list|,
name|ALPHA_FP0_REGNUM
argument_list|,
name|valbuf
argument_list|)
expr_stmt|;
name|regcache_cooked_read
argument_list|(
name|regcache
argument_list|,
name|ALPHA_FP0_REGNUM
operator|+
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|valbuf
operator|+
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
literal|32
case|:
name|regcache_cooked_read_signed
argument_list|(
name|regcache
argument_list|,
name|ALPHA_V0_REGNUM
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
name|read_memory
argument_list|(
name|l
argument_list|,
name|valbuf
argument_list|,
literal|32
argument_list|)
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"unknown floating point width"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* Assume everything else degenerates to an integer.  */
name|regcache_cooked_read_unsigned
argument_list|(
name|regcache
argument_list|,
name|ALPHA_V0_REGNUM
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|valbuf
argument_list|,
name|length
argument_list|,
name|l
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Extract from REGCACHE the address of a structure about to be returned    from a function.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|alpha_extract_struct_value_address
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|)
block|{
name|ULONGEST
name|addr
decl_stmt|;
name|regcache_cooked_read_unsigned
argument_list|(
name|regcache
argument_list|,
name|ALPHA_V0_REGNUM
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* Insert the given value into REGCACHE as if it was being     returned by a function.  */
end_comment

begin_function
specifier|static
name|void
name|alpha_store_return_value
parameter_list|(
name|struct
name|type
modifier|*
name|valtype
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
specifier|const
name|void
modifier|*
name|valbuf
parameter_list|)
block|{
name|int
name|length
init|=
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
decl_stmt|;
name|char
name|raw_buffer
index|[
name|ALPHA_REGISTER_SIZE
index|]
decl_stmt|;
name|ULONGEST
name|l
decl_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|valtype
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_FLT
case|:
switch|switch
condition|(
name|length
condition|)
block|{
case|case
literal|4
case|:
name|alpha_lds
argument_list|(
name|raw_buffer
argument_list|,
name|valbuf
argument_list|)
expr_stmt|;
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|ALPHA_FP0_REGNUM
argument_list|,
name|raw_buffer
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|ALPHA_FP0_REGNUM
argument_list|,
name|valbuf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
comment|/* FIXME: 128-bit long doubles are returned like structures: 	     by writing into indirect storage provided by the caller 	     as the first argument.  */
name|error
argument_list|(
literal|"Cannot set a 128-bit long double return value."
argument_list|)
expr_stmt|;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"unknown floating point width"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_COMPLEX
case|:
switch|switch
condition|(
name|length
condition|)
block|{
case|case
literal|8
case|:
comment|/* ??? This isn't correct wrt the ABI, but it's what GCC does.  */
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|ALPHA_FP0_REGNUM
argument_list|,
name|valbuf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|ALPHA_FP0_REGNUM
argument_list|,
name|valbuf
argument_list|)
expr_stmt|;
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|ALPHA_FP0_REGNUM
operator|+
literal|1
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|valbuf
operator|+
literal|8
argument_list|)
expr_stmt|;
break|break;
case|case
literal|32
case|:
comment|/* FIXME: 128-bit long doubles are returned like structures: 	     by writing into indirect storage provided by the caller 	     as the first argument.  */
name|error
argument_list|(
literal|"Cannot set a 128-bit long double return value."
argument_list|)
expr_stmt|;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"unknown floating point width"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* Assume everything else degenerates to an integer.  */
comment|/* 32-bit values must be sign-extended to 64 bits 	 even if the base data type is unsigned.  */
if|if
condition|(
name|length
operator|==
literal|4
condition|)
name|valtype
operator|=
name|builtin_type_int32
expr_stmt|;
name|l
operator|=
name|unpack_long
argument_list|(
name|valtype
argument_list|,
name|valbuf
argument_list|)
expr_stmt|;
name|regcache_cooked_write_unsigned
argument_list|(
name|regcache
argument_list|,
name|ALPHA_V0_REGNUM
argument_list|,
name|l
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
specifier|const
name|unsigned
name|char
modifier|*
name|alpha_breakpoint_from_pc
parameter_list|(
name|CORE_ADDR
modifier|*
name|pcptr
parameter_list|,
name|int
modifier|*
name|lenptr
parameter_list|)
block|{
specifier|static
specifier|const
name|unsigned
name|char
name|alpha_breakpoint
index|[]
init|=
block|{
literal|0x80
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
comment|/* call_pal bpt */
operator|*
name|lenptr
operator|=
sizeof|sizeof
argument_list|(
name|alpha_breakpoint
argument_list|)
expr_stmt|;
return|return
operator|(
name|alpha_breakpoint
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This returns the PC of the first insn after the prologue.    If we can't find the prologue, then return 0.  */
end_comment

begin_function
name|CORE_ADDR
name|alpha_after_prologue
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|CORE_ADDR
name|func_addr
decl_stmt|,
name|func_end
decl_stmt|;
if|if
condition|(
operator|!
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
name|NULL
argument_list|,
operator|&
name|func_addr
argument_list|,
operator|&
name|func_end
argument_list|)
condition|)
return|return
literal|0
return|;
name|sal
operator|=
name|find_pc_line
argument_list|(
name|func_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|end
operator|<
name|func_end
condition|)
return|return
name|sal
operator|.
name|end
return|;
comment|/* The line after the prologue is after the end of the function.  In this      case, tell the caller to find the prologue the hard way.  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Read an instruction from memory at PC, looking through breakpoints.  */
end_comment

begin_function
name|unsigned
name|int
name|alpha_read_insn
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|int
name|status
decl_stmt|;
name|status
operator|=
name|read_memory_nobpt
argument_list|(
name|pc
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|memory_error
argument_list|(
name|status
argument_list|,
name|pc
argument_list|)
expr_stmt|;
return|return
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* To skip prologues, I use this predicate.  Returns either PC itself    if the code at PC does not look like a function prologue; otherwise    returns an address that (if we're lucky) follows the prologue.  If    LENIENT, then we must skip everything which is involved in setting    up the frame (it's OK to skip more, just so long as we don't skip    anything which might clobber the registers which are being saved.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|alpha_skip_prologue
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|unsigned
name|long
name|inst
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|CORE_ADDR
name|post_prologue_pc
decl_stmt|;
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
comment|/* Silently return the unaltered pc upon memory errors.      This could happen on OSF/1 if decode_line_1 tries to skip the      prologue for quickstarted shared library functions when the      shared library is not yet mapped in.      Reading target memory is slow over serial lines, so we perform      this check only if the target has shared libraries (which all      Alpha targets do).  */
if|if
condition|(
name|target_read_memory
argument_list|(
name|pc
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
condition|)
return|return
name|pc
return|;
comment|/* See if we can determine the end of the prologue via the symbol table.      If so, then return either PC, or the PC after the prologue, whichever      is greater.  */
name|post_prologue_pc
operator|=
name|alpha_after_prologue
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|post_prologue_pc
operator|!=
literal|0
condition|)
return|return
name|max
argument_list|(
name|pc
argument_list|,
name|post_prologue_pc
argument_list|)
return|;
comment|/* Can't determine prologue from the symbol table, need to examine      instructions.  */
comment|/* Skip the typical prologue instructions. These are the stack adjustment      instruction and the instructions that save registers on the stack      or in the gcc frame.  */
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
literal|100
condition|;
name|offset
operator|+=
literal|4
control|)
block|{
name|inst
operator|=
name|alpha_read_insn
argument_list|(
name|pc
operator|+
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0x27bb0000
condition|)
comment|/* ldah $gp,n($t12) */
continue|continue;
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0x23bd0000
condition|)
comment|/* lda $gp,n($gp) */
continue|continue;
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0x23de0000
condition|)
comment|/* lda $sp,n($sp) */
continue|continue;
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xffe01fff
operator|)
operator|==
literal|0x43c0153e
condition|)
comment|/* subq $sp,n,$sp */
continue|continue;
if|if
condition|(
operator|(
operator|(
name|inst
operator|&
literal|0xfc1f0000
operator|)
operator|==
literal|0xb41e0000
comment|/* stq reg,n($sp) */
operator|||
operator|(
name|inst
operator|&
literal|0xfc1f0000
operator|)
operator|==
literal|0x9c1e0000
operator|)
comment|/* stt reg,n($sp) */
operator|&&
operator|(
name|inst
operator|&
literal|0x03e00000
operator|)
operator|!=
literal|0x03e00000
condition|)
comment|/* reg != $zero */
continue|continue;
if|if
condition|(
name|inst
operator|==
literal|0x47de040f
condition|)
comment|/* bis sp,sp,fp */
continue|continue;
if|if
condition|(
name|inst
operator|==
literal|0x47fe040f
condition|)
comment|/* bis zero,sp,fp */
continue|continue;
break|break;
block|}
return|return
name|pc
operator|+
name|offset
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Figure out where the longjmp will land.    We expect the first arg to be a pointer to the jmp_buf structure from    which we extract the PC (JB_PC) that we will land at.  The PC is copied    into the "pc".  This routine returns true on success.  */
end_comment

begin_function
specifier|static
name|int
name|alpha_get_longjmp_target
parameter_list|(
name|CORE_ADDR
modifier|*
name|pc
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|jb_addr
decl_stmt|;
name|char
name|raw_buffer
index|[
name|ALPHA_REGISTER_SIZE
index|]
decl_stmt|;
name|jb_addr
operator|=
name|read_register
argument_list|(
name|ALPHA_A0_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|jb_addr
operator|+
operator|(
name|tdep
operator|->
name|jb_pc
operator|*
name|tdep
operator|->
name|jb_elt_size
operator|)
argument_list|,
name|raw_buffer
argument_list|,
name|tdep
operator|->
name|jb_elt_size
argument_list|)
condition|)
return|return
literal|0
return|;
operator|*
name|pc
operator|=
name|extract_unsigned_integer
argument_list|(
name|raw_buffer
argument_list|,
name|tdep
operator|->
name|jb_elt_size
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Frame unwinder for signal trampolines.  We use alpha tdep bits that    describe the location and shape of the sigcontext structure.  After    that, all registers are in memory, so it's easy.  */
end_comment

begin_comment
comment|/* ??? Shouldn't we be able to do this generically, rather than with    OSABI data specific to Alpha?  */
end_comment

begin_struct
struct|struct
name|alpha_sigtramp_unwind_cache
block|{
name|CORE_ADDR
name|sigcontext_addr
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|struct
name|alpha_sigtramp_unwind_cache
modifier|*
name|alpha_sigtramp_frame_unwind_cache
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_prologue_cache
parameter_list|)
block|{
name|struct
name|alpha_sigtramp_unwind_cache
modifier|*
name|info
decl_stmt|;
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
decl_stmt|;
if|if
condition|(
operator|*
name|this_prologue_cache
condition|)
return|return
operator|*
name|this_prologue_cache
return|;
name|info
operator|=
name|FRAME_OBSTACK_ZALLOC
argument_list|(
expr|struct
name|alpha_sigtramp_unwind_cache
argument_list|)
expr_stmt|;
operator|*
name|this_prologue_cache
operator|=
name|info
expr_stmt|;
name|tdep
operator|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
expr_stmt|;
name|info
operator|->
name|sigcontext_addr
operator|=
name|tdep
operator|->
name|sigcontext_addr
argument_list|(
name|next_frame
argument_list|)
expr_stmt|;
return|return
name|info
return|;
block|}
end_function

begin_comment
comment|/* Return the address of REGNUM in a sigtramp frame.  Since this is    all arithmetic, it doesn't seem worthwhile to cache it.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|alpha_sigtramp_register_address
parameter_list|(
name|CORE_ADDR
name|sigcontext_addr
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
if|if
condition|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
literal|32
condition|)
return|return
name|sigcontext_addr
operator|+
name|tdep
operator|->
name|sc_regs_offset
operator|+
name|regnum
operator|*
literal|8
return|;
elseif|else
if|if
condition|(
name|regnum
operator|>=
name|ALPHA_FP0_REGNUM
operator|&&
name|regnum
operator|<
name|ALPHA_FP0_REGNUM
operator|+
literal|32
condition|)
return|return
name|sigcontext_addr
operator|+
name|tdep
operator|->
name|sc_fpregs_offset
operator|+
name|regnum
operator|*
literal|8
return|;
elseif|else
if|if
condition|(
name|regnum
operator|==
name|ALPHA_PC_REGNUM
condition|)
return|return
name|sigcontext_addr
operator|+
name|tdep
operator|->
name|sc_pc_offset
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Given a GDB frame, determine the address of the calling function's    frame.  This will be used to create a new GDB frame struct.  */
end_comment

begin_function
specifier|static
name|void
name|alpha_sigtramp_frame_this_id
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_prologue_cache
parameter_list|,
name|struct
name|frame_id
modifier|*
name|this_id
parameter_list|)
block|{
name|struct
name|alpha_sigtramp_unwind_cache
modifier|*
name|info
init|=
name|alpha_sigtramp_frame_unwind_cache
argument_list|(
name|next_frame
argument_list|,
name|this_prologue_cache
argument_list|)
decl_stmt|;
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
decl_stmt|;
name|CORE_ADDR
name|stack_addr
decl_stmt|,
name|code_addr
decl_stmt|;
comment|/* If the OSABI couldn't locate the sigcontext, give up.  */
if|if
condition|(
name|info
operator|->
name|sigcontext_addr
operator|==
literal|0
condition|)
return|return;
comment|/* If we have dynamic signal trampolines, find their start.      If we do not, then we must assume there is a symbol record      that can provide the start address.  */
name|tdep
operator|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdep
operator|->
name|dynamic_sigtramp_offset
condition|)
block|{
name|int
name|offset
decl_stmt|;
name|code_addr
operator|=
name|frame_pc_unwind
argument_list|(
name|next_frame
argument_list|)
expr_stmt|;
name|offset
operator|=
name|tdep
operator|->
name|dynamic_sigtramp_offset
argument_list|(
name|code_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
literal|0
condition|)
name|code_addr
operator|-=
name|offset
expr_stmt|;
else|else
name|code_addr
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|code_addr
operator|=
name|frame_func_unwind
argument_list|(
name|next_frame
argument_list|)
expr_stmt|;
comment|/* The stack address is trivially read from the sigcontext.  */
name|stack_addr
operator|=
name|alpha_sigtramp_register_address
argument_list|(
name|info
operator|->
name|sigcontext_addr
argument_list|,
name|ALPHA_SP_REGNUM
argument_list|)
expr_stmt|;
name|stack_addr
operator|=
name|get_frame_memory_unsigned
argument_list|(
name|next_frame
argument_list|,
name|stack_addr
argument_list|,
name|ALPHA_REGISTER_SIZE
argument_list|)
expr_stmt|;
operator|*
name|this_id
operator|=
name|frame_id_build
argument_list|(
name|stack_addr
argument_list|,
name|code_addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Retrieve the value of REGNUM in FRAME.  Don't give up!  */
end_comment

begin_function
specifier|static
name|void
name|alpha_sigtramp_frame_prev_register
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_prologue_cache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|int
modifier|*
name|optimizedp
parameter_list|,
name|enum
name|lval_type
modifier|*
name|lvalp
parameter_list|,
name|CORE_ADDR
modifier|*
name|addrp
parameter_list|,
name|int
modifier|*
name|realnump
parameter_list|,
name|void
modifier|*
name|bufferp
parameter_list|)
block|{
name|struct
name|alpha_sigtramp_unwind_cache
modifier|*
name|info
init|=
name|alpha_sigtramp_frame_unwind_cache
argument_list|(
name|next_frame
argument_list|,
name|this_prologue_cache
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|sigcontext_addr
operator|!=
literal|0
condition|)
block|{
comment|/* All integer and fp registers are stored in memory.  */
name|addr
operator|=
name|alpha_sigtramp_register_address
argument_list|(
name|info
operator|->
name|sigcontext_addr
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|!=
literal|0
condition|)
block|{
operator|*
name|optimizedp
operator|=
literal|0
expr_stmt|;
operator|*
name|lvalp
operator|=
name|lval_memory
expr_stmt|;
operator|*
name|addrp
operator|=
name|addr
expr_stmt|;
operator|*
name|realnump
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|bufferp
operator|!=
name|NULL
condition|)
name|get_frame_memory
argument_list|(
name|next_frame
argument_list|,
name|addr
argument_list|,
name|bufferp
argument_list|,
name|ALPHA_REGISTER_SIZE
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* This extra register may actually be in the sigcontext, but our      current description of it in alpha_sigtramp_frame_unwind_cache      doesn't include it.  Too bad.  Fall back on whatever's in the      outer frame.  */
name|frame_register
argument_list|(
name|next_frame
argument_list|,
name|regnum
argument_list|,
name|optimizedp
argument_list|,
name|lvalp
argument_list|,
name|addrp
argument_list|,
name|realnump
argument_list|,
name|bufferp
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|frame_unwind
name|alpha_sigtramp_frame_unwind
init|=
block|{
name|SIGTRAMP_FRAME
block|,
name|alpha_sigtramp_frame_this_id
block|,
name|alpha_sigtramp_frame_prev_register
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|struct
name|frame_unwind
modifier|*
name|alpha_sigtramp_frame_sniffer
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
name|CORE_ADDR
name|pc
init|=
name|frame_pc_unwind
argument_list|(
name|next_frame
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
comment|/* We shouldn't even bother to try if the OSABI didn't register      a sigcontext_addr handler.  */
if|if
condition|(
operator|!
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|sigcontext_addr
condition|)
return|return
name|NULL
return|;
comment|/* Otherwise we should be in a signal frame.  */
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
operator|&
name|name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|PC_IN_SIGTRAMP
argument_list|(
name|pc
argument_list|,
name|name
argument_list|)
condition|)
return|return
operator|&
name|alpha_sigtramp_frame_unwind
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Fallback alpha frame unwinder.  Uses instruction scanning and knows    something about the traditional layout of alpha stack frames.  */
end_comment

begin_struct
struct|struct
name|alpha_heuristic_unwind_cache
block|{
name|CORE_ADDR
modifier|*
name|saved_regs
decl_stmt|;
name|CORE_ADDR
name|vfp
decl_stmt|;
name|CORE_ADDR
name|start_pc
decl_stmt|;
name|int
name|return_reg
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Heuristic_proc_start may hunt through the text section for a long    time across a 2400 baud serial line.  Allows the user to limit this    search.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|heuristic_fence_post
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Attempt to locate the start of the function containing PC.  We assume that    the previous function ends with an about_to_return insn.  Not foolproof by    any means, since gcc is happy to put the epilogue in the middle of a    function.  But we're guessing anyway...  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|alpha_heuristic_proc_start
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|last_non_nop
init|=
name|pc
decl_stmt|;
name|CORE_ADDR
name|fence
init|=
name|pc
operator|-
name|heuristic_fence_post
decl_stmt|;
name|CORE_ADDR
name|orig_pc
init|=
name|pc
decl_stmt|;
name|CORE_ADDR
name|func
decl_stmt|;
if|if
condition|(
name|pc
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* First see if we can find the start of the function from minimal      symbol information.  This can succeed with a binary that doesn't      have debug info, but hasn't been stripped.  */
name|func
operator|=
name|get_pc_function_start
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
condition|)
return|return
name|func
return|;
if|if
condition|(
name|heuristic_fence_post
operator|==
name|UINT_MAX
operator|||
name|fence
operator|<
name|tdep
operator|->
name|vm_min_address
condition|)
name|fence
operator|=
name|tdep
operator|->
name|vm_min_address
expr_stmt|;
comment|/* Search back for previous return; also stop at a 0, which might be      seen for instance before the start of a code section.  Don't include      nops, since this usually indicates padding between functions.  */
for|for
control|(
name|pc
operator|-=
literal|4
init|;
name|pc
operator|>=
name|fence
condition|;
name|pc
operator|-=
literal|4
control|)
block|{
name|unsigned
name|int
name|insn
init|=
name|alpha_read_insn
argument_list|(
name|pc
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|insn
condition|)
block|{
case|case
literal|0
case|:
comment|/* invalid insn */
case|case
literal|0x6bfa8001
case|:
comment|/* ret $31,($26),1 */
return|return
name|last_non_nop
return|;
case|case
literal|0x2ffe0000
case|:
comment|/* unop: ldq_u $31,0($30) */
case|case
literal|0x47ff041f
case|:
comment|/* nop: bis $31,$31,$31 */
break|break;
default|default:
name|last_non_nop
operator|=
name|pc
expr_stmt|;
break|break;
block|}
block|}
comment|/* It's not clear to me why we reach this point when stopping quietly,      but with this test, at least we don't print out warnings for every      child forked (eg, on decstation).  22apr93 rich@cygnus.com.  */
if|if
condition|(
name|stop_soon
operator|==
name|NO_STOP_QUIETLY
condition|)
block|{
specifier|static
name|int
name|blurb_printed
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|fence
operator|==
name|tdep
operator|->
name|vm_min_address
condition|)
name|warning
argument_list|(
literal|"Hit beginning of text section without finding"
argument_list|)
expr_stmt|;
else|else
name|warning
argument_list|(
literal|"Hit heuristic-fence-post without finding"
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"enclosing function for address 0x%s"
argument_list|,
name|paddr_nz
argument_list|(
name|orig_pc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|blurb_printed
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\ This warning occurs if you are debugging a function without any symbols\n\ (for example, in a stripped executable).  In that case, you may wish to\n\ increase the size of the search with the `set heuristic-fence-post' command.\n\ \n\ Otherwise, you told GDB there was a function where there isn't one, or\n\ (more likely) you have encountered a bug in GDB.\n"
argument_list|)
expr_stmt|;
name|blurb_printed
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|alpha_heuristic_unwind_cache
modifier|*
name|alpha_heuristic_frame_unwind_cache
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_prologue_cache
parameter_list|,
name|CORE_ADDR
name|start_pc
parameter_list|)
block|{
name|struct
name|alpha_heuristic_unwind_cache
modifier|*
name|info
decl_stmt|;
name|ULONGEST
name|val
decl_stmt|;
name|CORE_ADDR
name|limit_pc
decl_stmt|,
name|cur_pc
decl_stmt|;
name|int
name|frame_reg
decl_stmt|,
name|frame_size
decl_stmt|,
name|return_reg
decl_stmt|,
name|reg
decl_stmt|;
if|if
condition|(
operator|*
name|this_prologue_cache
condition|)
return|return
operator|*
name|this_prologue_cache
return|;
name|info
operator|=
name|FRAME_OBSTACK_ZALLOC
argument_list|(
expr|struct
name|alpha_heuristic_unwind_cache
argument_list|)
expr_stmt|;
operator|*
name|this_prologue_cache
operator|=
name|info
expr_stmt|;
name|info
operator|->
name|saved_regs
operator|=
name|frame_obstack_zalloc
argument_list|(
name|SIZEOF_FRAME_SAVED_REGS
argument_list|)
expr_stmt|;
name|limit_pc
operator|=
name|frame_pc_unwind
argument_list|(
name|next_frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_pc
operator|==
literal|0
condition|)
name|start_pc
operator|=
name|alpha_heuristic_proc_start
argument_list|(
name|limit_pc
argument_list|)
expr_stmt|;
name|info
operator|->
name|start_pc
operator|=
name|start_pc
expr_stmt|;
name|frame_reg
operator|=
name|ALPHA_SP_REGNUM
expr_stmt|;
name|frame_size
operator|=
literal|0
expr_stmt|;
name|return_reg
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* If we've identified a likely place to start, do code scanning.  */
if|if
condition|(
name|start_pc
operator|!=
literal|0
condition|)
block|{
comment|/* Limit the forward search to 50 instructions.  */
if|if
condition|(
name|start_pc
operator|+
literal|200
operator|<
name|limit_pc
condition|)
name|limit_pc
operator|=
name|start_pc
operator|+
literal|200
expr_stmt|;
for|for
control|(
name|cur_pc
operator|=
name|start_pc
init|;
name|cur_pc
operator|<
name|limit_pc
condition|;
name|cur_pc
operator|+=
literal|4
control|)
block|{
name|unsigned
name|int
name|word
init|=
name|alpha_read_insn
argument_list|(
name|cur_pc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|word
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0x23de0000
condition|)
comment|/* lda $sp,n($sp) */
block|{
if|if
condition|(
name|word
operator|&
literal|0x8000
condition|)
block|{
comment|/* Consider only the first stack allocation instruction 		     to contain the static size of the frame. */
if|if
condition|(
name|frame_size
operator|==
literal|0
condition|)
name|frame_size
operator|=
operator|(
operator|-
name|word
operator|)
operator|&
literal|0xffff
expr_stmt|;
block|}
else|else
block|{
comment|/* Exit loop if a positive stack adjustment is found, which 		     usually means that the stack cleanup code in the function 		     epilogue is reached.  */
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|word
operator|&
literal|0xfc1f0000
operator|)
operator|==
literal|0xb41e0000
condition|)
comment|/* stq reg,n($sp) */
block|{
name|reg
operator|=
operator|(
name|word
operator|&
literal|0x03e00000
operator|)
operator|>>
literal|21
expr_stmt|;
comment|/* Ignore this instruction if we have already encountered                  an instruction saving the same register earlier in the                  function code.  The current instruction does not tell                  us where the original value upon function entry is saved.                  All it says is that the function we are scanning reused                  that register for some computation of its own, and is now                  saving its result.  */
if|if
condition|(
name|info
operator|->
name|saved_regs
index|[
name|reg
index|]
condition|)
continue|continue;
if|if
condition|(
name|reg
operator|==
literal|31
condition|)
continue|continue;
comment|/* Do not compute the address where the register was saved yet, 		 because we don't know yet if the offset will need to be 		 relative to $sp or $fp (we can not compute the address 		 relative to $sp if $sp is updated during the execution of 		 the current subroutine, for instance when doing some alloca). 		 So just store the offset for the moment, and compute the 		 address later when we know whether this frame has a frame 		 pointer or not.  */
comment|/* Hack: temporarily add one, so that the offset is non-zero 		 and we can tell which registers have save offsets below.  */
name|info
operator|->
name|saved_regs
index|[
name|reg
index|]
operator|=
operator|(
name|word
operator|&
literal|0xffff
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* Starting with OSF/1-3.2C, the system libraries are shipped 		 without local symbols, but they still contain procedure 		 descriptors without a symbol reference. GDB is currently 		 unable to find these procedure descriptors and uses 		 heuristic_proc_desc instead. 		 As some low level compiler support routines (__div*, __add*) 		 use a non-standard return address register, we have to 		 add some heuristics to determine the return address register, 		 or stepping over these routines will fail. 		 Usually the return address register is the first register 		 saved on the stack, but assembler optimization might 		 rearrange the register saves. 		 So we recognize only a few registers (t7, t9, ra) within 		 the procedure prologue as valid return address registers. 		 If we encounter a return instruction, we extract the 		 the return address register from it.  		 FIXME: Rewriting GDB to access the procedure descriptors, 		 e.g. via the minimal symbol table, might obviate this hack.  */
if|if
condition|(
name|return_reg
operator|==
operator|-
literal|1
operator|&&
name|cur_pc
operator|<
operator|(
name|start_pc
operator|+
literal|80
operator|)
operator|&&
operator|(
name|reg
operator|==
name|ALPHA_T7_REGNUM
operator|||
name|reg
operator|==
name|ALPHA_T9_REGNUM
operator|||
name|reg
operator|==
name|ALPHA_RA_REGNUM
operator|)
condition|)
name|return_reg
operator|=
name|reg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|word
operator|&
literal|0xffe0ffff
operator|)
operator|==
literal|0x6be08001
condition|)
comment|/* ret zero,reg,1 */
name|return_reg
operator|=
operator|(
name|word
operator|>>
literal|16
operator|)
operator|&
literal|0x1f
expr_stmt|;
elseif|else
if|if
condition|(
name|word
operator|==
literal|0x47de040f
condition|)
comment|/* bis sp,sp,fp */
name|frame_reg
operator|=
name|ALPHA_GCC_FP_REGNUM
expr_stmt|;
elseif|else
if|if
condition|(
name|word
operator|==
literal|0x47fe040f
condition|)
comment|/* bis zero,sp,fp */
name|frame_reg
operator|=
name|ALPHA_GCC_FP_REGNUM
expr_stmt|;
block|}
comment|/* If we haven't found a valid return address register yet, keep 	 searching in the procedure prologue.  */
if|if
condition|(
name|return_reg
operator|==
operator|-
literal|1
condition|)
block|{
while|while
condition|(
name|cur_pc
operator|<
operator|(
name|limit_pc
operator|+
literal|80
operator|)
operator|&&
name|cur_pc
operator|<
operator|(
name|start_pc
operator|+
literal|80
operator|)
condition|)
block|{
name|unsigned
name|int
name|word
init|=
name|alpha_read_insn
argument_list|(
name|cur_pc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|word
operator|&
literal|0xfc1f0000
operator|)
operator|==
literal|0xb41e0000
condition|)
comment|/* stq reg,n($sp) */
block|{
name|reg
operator|=
operator|(
name|word
operator|&
literal|0x03e00000
operator|)
operator|>>
literal|21
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|ALPHA_T7_REGNUM
operator|||
name|reg
operator|==
name|ALPHA_T9_REGNUM
operator|||
name|reg
operator|==
name|ALPHA_RA_REGNUM
condition|)
block|{
name|return_reg
operator|=
name|reg
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|word
operator|&
literal|0xffe0ffff
operator|)
operator|==
literal|0x6be08001
condition|)
comment|/* ret zero,reg,1 */
block|{
name|return_reg
operator|=
operator|(
name|word
operator|>>
literal|16
operator|)
operator|&
literal|0x1f
expr_stmt|;
break|break;
block|}
name|cur_pc
operator|+=
literal|4
expr_stmt|;
block|}
block|}
block|}
comment|/* Failing that, do default to the customary RA.  */
if|if
condition|(
name|return_reg
operator|==
operator|-
literal|1
condition|)
name|return_reg
operator|=
name|ALPHA_RA_REGNUM
expr_stmt|;
name|info
operator|->
name|return_reg
operator|=
name|return_reg
expr_stmt|;
name|frame_unwind_unsigned_register
argument_list|(
name|next_frame
argument_list|,
name|frame_reg
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|info
operator|->
name|vfp
operator|=
name|val
operator|+
name|frame_size
expr_stmt|;
comment|/* Convert offsets to absolute addresses.  See above about adding      one to the offsets to make all detected offsets non-zero.  */
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<
name|ALPHA_NUM_REGS
condition|;
operator|++
name|reg
control|)
if|if
condition|(
name|info
operator|->
name|saved_regs
index|[
name|reg
index|]
condition|)
name|info
operator|->
name|saved_regs
index|[
name|reg
index|]
operator|+=
name|val
operator|-
literal|1
expr_stmt|;
return|return
name|info
return|;
block|}
end_function

begin_comment
comment|/* Given a GDB frame, determine the address of the calling function's    frame.  This will be used to create a new GDB frame struct.  */
end_comment

begin_function
specifier|static
name|void
name|alpha_heuristic_frame_this_id
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_prologue_cache
parameter_list|,
name|struct
name|frame_id
modifier|*
name|this_id
parameter_list|)
block|{
name|struct
name|alpha_heuristic_unwind_cache
modifier|*
name|info
init|=
name|alpha_heuristic_frame_unwind_cache
argument_list|(
name|next_frame
argument_list|,
name|this_prologue_cache
argument_list|,
literal|0
argument_list|)
decl_stmt|;
operator|*
name|this_id
operator|=
name|frame_id_build
argument_list|(
name|info
operator|->
name|vfp
argument_list|,
name|info
operator|->
name|start_pc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Retrieve the value of REGNUM in FRAME.  Don't give up!  */
end_comment

begin_function
specifier|static
name|void
name|alpha_heuristic_frame_prev_register
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_prologue_cache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|int
modifier|*
name|optimizedp
parameter_list|,
name|enum
name|lval_type
modifier|*
name|lvalp
parameter_list|,
name|CORE_ADDR
modifier|*
name|addrp
parameter_list|,
name|int
modifier|*
name|realnump
parameter_list|,
name|void
modifier|*
name|bufferp
parameter_list|)
block|{
name|struct
name|alpha_heuristic_unwind_cache
modifier|*
name|info
init|=
name|alpha_heuristic_frame_unwind_cache
argument_list|(
name|next_frame
argument_list|,
name|this_prologue_cache
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* The PC of the previous frame is stored in the link register of      the current frame.  Frob regnum so that we pull the value from      the correct place.  */
if|if
condition|(
name|regnum
operator|==
name|ALPHA_PC_REGNUM
condition|)
name|regnum
operator|=
name|info
operator|->
name|return_reg
expr_stmt|;
comment|/* For all registers known to be saved in the current frame,       do the obvious and pull the value out.  */
if|if
condition|(
name|info
operator|->
name|saved_regs
index|[
name|regnum
index|]
condition|)
block|{
operator|*
name|optimizedp
operator|=
literal|0
expr_stmt|;
operator|*
name|lvalp
operator|=
name|lval_memory
expr_stmt|;
operator|*
name|addrp
operator|=
name|info
operator|->
name|saved_regs
index|[
name|regnum
index|]
expr_stmt|;
operator|*
name|realnump
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|bufferp
operator|!=
name|NULL
condition|)
name|get_frame_memory
argument_list|(
name|next_frame
argument_list|,
operator|*
name|addrp
argument_list|,
name|bufferp
argument_list|,
name|ALPHA_REGISTER_SIZE
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* The stack pointer of the previous frame is computed by popping      the current stack frame.  */
if|if
condition|(
name|regnum
operator|==
name|ALPHA_SP_REGNUM
condition|)
block|{
operator|*
name|optimizedp
operator|=
literal|0
expr_stmt|;
operator|*
name|lvalp
operator|=
name|not_lval
expr_stmt|;
operator|*
name|addrp
operator|=
literal|0
expr_stmt|;
operator|*
name|realnump
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|bufferp
operator|!=
name|NULL
condition|)
name|store_unsigned_integer
argument_list|(
name|bufferp
argument_list|,
name|ALPHA_REGISTER_SIZE
argument_list|,
name|info
operator|->
name|vfp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Otherwise assume the next frame has the same register value.  */
name|frame_register
argument_list|(
name|next_frame
argument_list|,
name|regnum
argument_list|,
name|optimizedp
argument_list|,
name|lvalp
argument_list|,
name|addrp
argument_list|,
name|realnump
argument_list|,
name|bufferp
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|frame_unwind
name|alpha_heuristic_frame_unwind
init|=
block|{
name|NORMAL_FRAME
block|,
name|alpha_heuristic_frame_this_id
block|,
name|alpha_heuristic_frame_prev_register
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|struct
name|frame_unwind
modifier|*
name|alpha_heuristic_frame_sniffer
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
return|return
operator|&
name|alpha_heuristic_frame_unwind
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|alpha_heuristic_frame_base_address
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_prologue_cache
parameter_list|)
block|{
name|struct
name|alpha_heuristic_unwind_cache
modifier|*
name|info
init|=
name|alpha_heuristic_frame_unwind_cache
argument_list|(
name|next_frame
argument_list|,
name|this_prologue_cache
argument_list|,
literal|0
argument_list|)
decl_stmt|;
return|return
name|info
operator|->
name|vfp
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|frame_base
name|alpha_heuristic_frame_base
init|=
block|{
operator|&
name|alpha_heuristic_frame_unwind
block|,
name|alpha_heuristic_frame_base_address
block|,
name|alpha_heuristic_frame_base_address
block|,
name|alpha_heuristic_frame_base_address
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Just like reinit_frame_cache, but with the right arguments to be    callable as an sfunc.  Used by the "set heuristic-fence-post" command.  */
end_comment

begin_function
specifier|static
name|void
name|reinit_frame_cache_sfunc
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|reinit_frame_cache
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ALPHA stack frames are almost impenetrable.  When execution stops,    we basically have to look at symbol information for the function    that we stopped in, which tells us *which* register (if any) is    the base of the frame pointer, and what offset from that register    the frame itself is at.       This presents a problem when trying to examine a stack in memory    (that isn't executing at the moment), using the "frame" command.  We    don't have a PC, nor do we have any registers except SP.     This routine takes two arguments, SP and PC, and tries to make the    cached frames look as if these two arguments defined a frame on the    cache.  This allows the rest of info frame to extract the important    arguments without difficulty.  */
end_comment

begin_function
name|struct
name|frame_info
modifier|*
name|alpha_setup_arbitrary_frame
parameter_list|(
name|int
name|argc
parameter_list|,
name|CORE_ADDR
modifier|*
name|argv
parameter_list|)
block|{
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
name|error
argument_list|(
literal|"ALPHA frame specifications require two arguments: sp and pc"
argument_list|)
expr_stmt|;
return|return
name|create_new_frame
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Assuming NEXT_FRAME->prev is a dummy, return the frame ID of that    dummy frame.  The frame ID's base needs to match the TOS value    saved by save_dummy_frame_tos(), and the PC match the dummy frame's    breakpoint.  */
end_comment

begin_function
specifier|static
name|struct
name|frame_id
name|alpha_unwind_dummy_id
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
name|ULONGEST
name|base
decl_stmt|;
name|frame_unwind_unsigned_register
argument_list|(
name|next_frame
argument_list|,
name|ALPHA_SP_REGNUM
argument_list|,
operator|&
name|base
argument_list|)
expr_stmt|;
return|return
name|frame_id_build
argument_list|(
name|base
argument_list|,
name|frame_pc_unwind
argument_list|(
name|next_frame
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|alpha_unwind_pc
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
name|ULONGEST
name|pc
decl_stmt|;
name|frame_unwind_unsigned_register
argument_list|(
name|next_frame
argument_list|,
name|ALPHA_PC_REGNUM
argument_list|,
operator|&
name|pc
argument_list|)
expr_stmt|;
return|return
name|pc
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Helper routines for alpha*-nat.c files to move register sets to and    from core files.  The UNIQUE pointer is allowed to be NULL, as most    targets don't supply this value in their core files.  */
end_comment

begin_function
name|void
name|alpha_supply_int_regs
parameter_list|(
name|int
name|regno
parameter_list|,
specifier|const
name|void
modifier|*
name|r0_r30
parameter_list|,
specifier|const
name|void
modifier|*
name|pc
parameter_list|,
specifier|const
name|void
modifier|*
name|unique
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|31
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|regno
operator|==
name|i
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
name|supply_register
argument_list|(
name|i
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|r0_r30
operator|+
name|i
operator|*
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|ALPHA_ZERO_REGNUM
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
name|supply_register
argument_list|(
name|ALPHA_ZERO_REGNUM
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|ALPHA_PC_REGNUM
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
name|supply_register
argument_list|(
name|ALPHA_PC_REGNUM
argument_list|,
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|ALPHA_UNIQUE_REGNUM
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
name|supply_register
argument_list|(
name|ALPHA_UNIQUE_REGNUM
argument_list|,
name|unique
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|alpha_fill_int_regs
parameter_list|(
name|int
name|regno
parameter_list|,
name|void
modifier|*
name|r0_r30
parameter_list|,
name|void
modifier|*
name|pc
parameter_list|,
name|void
modifier|*
name|unique
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|31
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|regno
operator|==
name|i
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
name|regcache_collect
argument_list|(
name|i
argument_list|,
operator|(
name|char
operator|*
operator|)
name|r0_r30
operator|+
name|i
operator|*
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|ALPHA_PC_REGNUM
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
name|regcache_collect
argument_list|(
name|ALPHA_PC_REGNUM
argument_list|,
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|unique
operator|&&
operator|(
name|regno
operator|==
name|ALPHA_UNIQUE_REGNUM
operator|||
name|regno
operator|==
operator|-
literal|1
operator|)
condition|)
name|regcache_collect
argument_list|(
name|ALPHA_UNIQUE_REGNUM
argument_list|,
name|unique
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|alpha_supply_fp_regs
parameter_list|(
name|int
name|regno
parameter_list|,
specifier|const
name|void
modifier|*
name|f0_f30
parameter_list|,
specifier|const
name|void
modifier|*
name|fpcr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|ALPHA_FP0_REGNUM
init|;
name|i
operator|<
name|ALPHA_FP0_REGNUM
operator|+
literal|31
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|regno
operator|==
name|i
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
name|supply_register
argument_list|(
name|i
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|f0_f30
operator|+
operator|(
name|i
operator|-
name|ALPHA_FP0_REGNUM
operator|)
operator|*
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|ALPHA_FPCR_REGNUM
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
name|supply_register
argument_list|(
name|ALPHA_FPCR_REGNUM
argument_list|,
name|fpcr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|alpha_fill_fp_regs
parameter_list|(
name|int
name|regno
parameter_list|,
name|void
modifier|*
name|f0_f30
parameter_list|,
name|void
modifier|*
name|fpcr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|ALPHA_FP0_REGNUM
init|;
name|i
operator|<
name|ALPHA_FP0_REGNUM
operator|+
literal|31
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|regno
operator|==
name|i
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
name|regcache_collect
argument_list|(
name|i
argument_list|,
operator|(
name|char
operator|*
operator|)
name|f0_f30
operator|+
operator|(
name|i
operator|-
name|ALPHA_FP0_REGNUM
operator|)
operator|*
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|ALPHA_FPCR_REGNUM
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
name|regcache_collect
argument_list|(
name|ALPHA_FPCR_REGNUM
argument_list|,
name|fpcr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* alpha_software_single_step() is called just before we want to resume    the inferior, if we want to single-step it but there is no hardware    or kernel single-step support (NetBSD on Alpha, for example).  We find    the target of the coming instruction and breakpoint it.     single_step is also called just after the inferior stops.  If we had    set up a simulated single-step, we undo our damage.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|alpha_next_pc
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|unsigned
name|int
name|insn
decl_stmt|;
name|unsigned
name|int
name|op
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|LONGEST
name|rav
decl_stmt|;
name|insn
operator|=
name|alpha_read_insn
argument_list|(
name|pc
argument_list|)
expr_stmt|;
comment|/* Opcode is top 6 bits. */
name|op
operator|=
operator|(
name|insn
operator|>>
literal|26
operator|)
operator|&
literal|0x3f
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0x1a
condition|)
block|{
comment|/* Jump format: target PC is: 	 RB& ~3  */
return|return
operator|(
name|read_register
argument_list|(
operator|(
name|insn
operator|>>
literal|16
operator|)
operator|&
literal|0x1f
argument_list|)
operator|&
operator|~
literal|3
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|op
operator|&
literal|0x30
operator|)
operator|==
literal|0x30
condition|)
block|{
comment|/* Branch format: target PC is: 	 (new PC) + (4 * sext(displacement))  */
if|if
condition|(
name|op
operator|==
literal|0x30
operator|||
comment|/* BR */
name|op
operator|==
literal|0x34
condition|)
comment|/* BSR */
block|{
name|branch_taken
label|:
name|offset
operator|=
operator|(
name|insn
operator|&
literal|0x001fffff
operator|)
expr_stmt|;
if|if
condition|(
name|offset
operator|&
literal|0x00100000
condition|)
name|offset
operator||=
literal|0xffe00000
expr_stmt|;
name|offset
operator|*=
literal|4
expr_stmt|;
return|return
operator|(
name|pc
operator|+
literal|4
operator|+
name|offset
operator|)
return|;
block|}
comment|/* Need to determine if branch is taken; read RA.  */
name|rav
operator|=
operator|(
name|LONGEST
operator|)
name|read_register
argument_list|(
operator|(
name|insn
operator|>>
literal|21
operator|)
operator|&
literal|0x1f
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
literal|0x38
case|:
comment|/* BLBC */
if|if
condition|(
operator|(
name|rav
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
goto|goto
name|branch_taken
goto|;
break|break;
case|case
literal|0x3c
case|:
comment|/* BLBS */
if|if
condition|(
name|rav
operator|&
literal|1
condition|)
goto|goto
name|branch_taken
goto|;
break|break;
case|case
literal|0x39
case|:
comment|/* BEQ */
if|if
condition|(
name|rav
operator|==
literal|0
condition|)
goto|goto
name|branch_taken
goto|;
break|break;
case|case
literal|0x3d
case|:
comment|/* BNE */
if|if
condition|(
name|rav
operator|!=
literal|0
condition|)
goto|goto
name|branch_taken
goto|;
break|break;
case|case
literal|0x3a
case|:
comment|/* BLT */
if|if
condition|(
name|rav
operator|<
literal|0
condition|)
goto|goto
name|branch_taken
goto|;
break|break;
case|case
literal|0x3b
case|:
comment|/* BLE */
if|if
condition|(
name|rav
operator|<=
literal|0
condition|)
goto|goto
name|branch_taken
goto|;
break|break;
case|case
literal|0x3f
case|:
comment|/* BGT */
if|if
condition|(
name|rav
operator|>
literal|0
condition|)
goto|goto
name|branch_taken
goto|;
break|break;
case|case
literal|0x3e
case|:
comment|/* BGE */
if|if
condition|(
name|rav
operator|>=
literal|0
condition|)
goto|goto
name|branch_taken
goto|;
break|break;
comment|/* ??? Missing floating-point branches.  */
block|}
block|}
comment|/* Not a branch or branch not taken; target PC is:      pc + 4  */
return|return
operator|(
name|pc
operator|+
literal|4
operator|)
return|;
block|}
end_function

begin_function
name|void
name|alpha_software_single_step
parameter_list|(
name|enum
name|target_signal
name|sig
parameter_list|,
name|int
name|insert_breakpoints_p
parameter_list|)
block|{
specifier|static
name|CORE_ADDR
name|next_pc
decl_stmt|;
typedef|typedef
name|char
name|binsn_quantum
index|[
name|BREAKPOINT_MAX
index|]
typedef|;
specifier|static
name|binsn_quantum
name|break_mem
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
if|if
condition|(
name|insert_breakpoints_p
condition|)
block|{
name|pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
name|next_pc
operator|=
name|alpha_next_pc
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|target_insert_breakpoint
argument_list|(
name|next_pc
argument_list|,
name|break_mem
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|target_remove_breakpoint
argument_list|(
name|next_pc
argument_list|,
name|break_mem
argument_list|)
expr_stmt|;
name|write_pc
argument_list|(
name|next_pc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize the current architecture based on INFO.  If possible, re-use an    architecture from ARCHES, which is a list of architectures already created    during this debugging session.     Called e.g. at program startup, when reading a core file, and when reading    a binary file.  */
end_comment

begin_function
specifier|static
name|struct
name|gdbarch
modifier|*
name|alpha_gdbarch_init
parameter_list|(
name|struct
name|gdbarch_info
name|info
parameter_list|,
name|struct
name|gdbarch_list
modifier|*
name|arches
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
decl_stmt|;
name|struct
name|gdbarch
modifier|*
name|gdbarch
decl_stmt|;
comment|/* Try to determine the ABI of the object we are loading.  */
if|if
condition|(
name|info
operator|.
name|abfd
operator|!=
name|NULL
operator|&&
name|info
operator|.
name|osabi
operator|==
name|GDB_OSABI_UNKNOWN
condition|)
block|{
comment|/* If it's an ECOFF file, assume it's OSF/1.  */
if|if
condition|(
name|bfd_get_flavour
argument_list|(
name|info
operator|.
name|abfd
argument_list|)
operator|==
name|bfd_target_ecoff_flavour
condition|)
name|info
operator|.
name|osabi
operator|=
name|GDB_OSABI_OSF1
expr_stmt|;
block|}
comment|/* Find a candidate among extant architectures.  */
name|arches
operator|=
name|gdbarch_list_lookup_by_info
argument_list|(
name|arches
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|arches
operator|!=
name|NULL
condition|)
return|return
name|arches
operator|->
name|gdbarch
return|;
name|tdep
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|gdbarch_tdep
argument_list|)
argument_list|)
expr_stmt|;
name|gdbarch
operator|=
name|gdbarch_alloc
argument_list|(
operator|&
name|info
argument_list|,
name|tdep
argument_list|)
expr_stmt|;
comment|/* Lowest text address.  This is used by heuristic_proc_start()      to decide when to stop looking.  */
name|tdep
operator|->
name|vm_min_address
operator|=
operator|(
name|CORE_ADDR
operator|)
literal|0x120000000
expr_stmt|;
name|tdep
operator|->
name|dynamic_sigtramp_offset
operator|=
name|NULL
expr_stmt|;
name|tdep
operator|->
name|sigcontext_addr
operator|=
name|NULL
expr_stmt|;
name|tdep
operator|->
name|sc_pc_offset
operator|=
literal|2
operator|*
literal|8
expr_stmt|;
name|tdep
operator|->
name|sc_regs_offset
operator|=
literal|4
operator|*
literal|8
expr_stmt|;
name|tdep
operator|->
name|sc_fpregs_offset
operator|=
name|tdep
operator|->
name|sc_regs_offset
operator|+
literal|32
operator|*
literal|8
operator|+
literal|8
expr_stmt|;
name|tdep
operator|->
name|jb_pc
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* longjmp support not enabled by default  */
comment|/* Type sizes */
name|set_gdbarch_short_bit
argument_list|(
name|gdbarch
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|set_gdbarch_int_bit
argument_list|(
name|gdbarch
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|set_gdbarch_long_bit
argument_list|(
name|gdbarch
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|set_gdbarch_long_long_bit
argument_list|(
name|gdbarch
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|set_gdbarch_float_bit
argument_list|(
name|gdbarch
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|set_gdbarch_double_bit
argument_list|(
name|gdbarch
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|set_gdbarch_long_double_bit
argument_list|(
name|gdbarch
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|set_gdbarch_ptr_bit
argument_list|(
name|gdbarch
argument_list|,
literal|64
argument_list|)
expr_stmt|;
comment|/* Register info */
name|set_gdbarch_num_regs
argument_list|(
name|gdbarch
argument_list|,
name|ALPHA_NUM_REGS
argument_list|)
expr_stmt|;
name|set_gdbarch_sp_regnum
argument_list|(
name|gdbarch
argument_list|,
name|ALPHA_SP_REGNUM
argument_list|)
expr_stmt|;
name|set_gdbarch_pc_regnum
argument_list|(
name|gdbarch
argument_list|,
name|ALPHA_PC_REGNUM
argument_list|)
expr_stmt|;
name|set_gdbarch_fp0_regnum
argument_list|(
name|gdbarch
argument_list|,
name|ALPHA_FP0_REGNUM
argument_list|)
expr_stmt|;
name|set_gdbarch_register_name
argument_list|(
name|gdbarch
argument_list|,
name|alpha_register_name
argument_list|)
expr_stmt|;
name|set_gdbarch_deprecated_register_byte
argument_list|(
name|gdbarch
argument_list|,
name|alpha_register_byte
argument_list|)
expr_stmt|;
name|set_gdbarch_deprecated_register_raw_size
argument_list|(
name|gdbarch
argument_list|,
name|alpha_register_raw_size
argument_list|)
expr_stmt|;
name|set_gdbarch_deprecated_register_virtual_size
argument_list|(
name|gdbarch
argument_list|,
name|alpha_register_virtual_size
argument_list|)
expr_stmt|;
name|set_gdbarch_register_type
argument_list|(
name|gdbarch
argument_list|,
name|alpha_register_type
argument_list|)
expr_stmt|;
name|set_gdbarch_cannot_fetch_register
argument_list|(
name|gdbarch
argument_list|,
name|alpha_cannot_fetch_register
argument_list|)
expr_stmt|;
name|set_gdbarch_cannot_store_register
argument_list|(
name|gdbarch
argument_list|,
name|alpha_cannot_store_register
argument_list|)
expr_stmt|;
name|set_gdbarch_convert_register_p
argument_list|(
name|gdbarch
argument_list|,
name|alpha_convert_register_p
argument_list|)
expr_stmt|;
name|set_gdbarch_register_to_value
argument_list|(
name|gdbarch
argument_list|,
name|alpha_register_to_value
argument_list|)
expr_stmt|;
name|set_gdbarch_value_to_register
argument_list|(
name|gdbarch
argument_list|,
name|alpha_value_to_register
argument_list|)
expr_stmt|;
name|set_gdbarch_register_reggroup_p
argument_list|(
name|gdbarch
argument_list|,
name|alpha_register_reggroup_p
argument_list|)
expr_stmt|;
comment|/* Prologue heuristics.  */
name|set_gdbarch_skip_prologue
argument_list|(
name|gdbarch
argument_list|,
name|alpha_skip_prologue
argument_list|)
expr_stmt|;
comment|/* Disassembler.  */
name|set_gdbarch_print_insn
argument_list|(
name|gdbarch
argument_list|,
name|print_insn_alpha
argument_list|)
expr_stmt|;
comment|/* Call info.  */
name|set_gdbarch_use_struct_convention
argument_list|(
name|gdbarch
argument_list|,
name|always_use_struct_convention
argument_list|)
expr_stmt|;
name|set_gdbarch_extract_return_value
argument_list|(
name|gdbarch
argument_list|,
name|alpha_extract_return_value
argument_list|)
expr_stmt|;
name|set_gdbarch_store_return_value
argument_list|(
name|gdbarch
argument_list|,
name|alpha_store_return_value
argument_list|)
expr_stmt|;
name|set_gdbarch_deprecated_extract_struct_value_address
argument_list|(
name|gdbarch
argument_list|,
name|alpha_extract_struct_value_address
argument_list|)
expr_stmt|;
comment|/* Settings for calling functions in the inferior.  */
name|set_gdbarch_push_dummy_call
argument_list|(
name|gdbarch
argument_list|,
name|alpha_push_dummy_call
argument_list|)
expr_stmt|;
comment|/* Methods for saving / extracting a dummy frame's ID.  */
name|set_gdbarch_unwind_dummy_id
argument_list|(
name|gdbarch
argument_list|,
name|alpha_unwind_dummy_id
argument_list|)
expr_stmt|;
comment|/* Return the unwound PC value.  */
name|set_gdbarch_unwind_pc
argument_list|(
name|gdbarch
argument_list|,
name|alpha_unwind_pc
argument_list|)
expr_stmt|;
name|set_gdbarch_inner_than
argument_list|(
name|gdbarch
argument_list|,
name|core_addr_lessthan
argument_list|)
expr_stmt|;
name|set_gdbarch_skip_trampoline_code
argument_list|(
name|gdbarch
argument_list|,
name|find_solib_trampoline_target
argument_list|)
expr_stmt|;
name|set_gdbarch_breakpoint_from_pc
argument_list|(
name|gdbarch
argument_list|,
name|alpha_breakpoint_from_pc
argument_list|)
expr_stmt|;
name|set_gdbarch_decr_pc_after_break
argument_list|(
name|gdbarch
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Hook in ABI-specific overrides, if they have been registered.  */
name|gdbarch_init_osabi
argument_list|(
name|info
argument_list|,
name|gdbarch
argument_list|)
expr_stmt|;
comment|/* Now that we have tuned the configuration, set a few final things      based on what the OS ABI has told us.  */
if|if
condition|(
name|tdep
operator|->
name|jb_pc
operator|>=
literal|0
condition|)
name|set_gdbarch_get_longjmp_target
argument_list|(
name|gdbarch
argument_list|,
name|alpha_get_longjmp_target
argument_list|)
expr_stmt|;
name|frame_unwind_append_sniffer
argument_list|(
name|gdbarch
argument_list|,
name|alpha_sigtramp_frame_sniffer
argument_list|)
expr_stmt|;
name|frame_unwind_append_sniffer
argument_list|(
name|gdbarch
argument_list|,
name|alpha_heuristic_frame_sniffer
argument_list|)
expr_stmt|;
name|frame_base_set_default
argument_list|(
name|gdbarch
argument_list|,
operator|&
name|alpha_heuristic_frame_base
argument_list|)
expr_stmt|;
return|return
name|gdbarch
return|;
block|}
end_function

begin_function
name|void
name|alpha_dwarf2_init_abi
parameter_list|(
name|struct
name|gdbarch_info
name|info
parameter_list|,
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|)
block|{
name|frame_unwind_append_sniffer
argument_list|(
name|gdbarch
argument_list|,
name|dwarf2_frame_sniffer
argument_list|)
expr_stmt|;
name|frame_base_append_sniffer
argument_list|(
name|gdbarch
argument_list|,
name|dwarf2_frame_base_sniffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|initialize_file_ftype
name|_initialize_alpha_tdep
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -Wmissing-prototypes */
end_comment

begin_function
name|void
name|_initialize_alpha_tdep
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|gdbarch_register
argument_list|(
name|bfd_arch_alpha
argument_list|,
name|alpha_gdbarch_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Let the user set the fence post for heuristic_proc_start.  */
comment|/* We really would like to have both "0" and "unlimited" work, but      command.c doesn't deal with that.  So make it a var_zinteger      because the user can always use "999999" or some such for unlimited.  */
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"heuristic-fence-post"
argument_list|,
name|class_support
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|heuristic_fence_post
argument_list|,
literal|"\ Set the distance searched for the start of a function.\n\ If you are debugging a stripped executable, GDB needs to search through the\n\ program for the start of a function.  This command sets the distance of the\n\ search.  The only need to set it is when debugging a stripped executable."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
comment|/* We need to throw away the frame cache when we set this, since it      might change our ability to get backtraces.  */
name|set_cmd_sfunc
argument_list|(
name|c
argument_list|,
name|reinit_frame_cache_sfunc
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

