begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Machine independent support for QNX Neutrino /proc (process file system)    for GDB.  Written by Colin Burgess at QNX Software Systems Limited.      Copyright 2003 Free Software Foundation, Inc.     Contributed by QNX Software Systems Ltd.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<spawn.h>
end_include

begin_include
include|#
directive|include
file|<sys/debug.h>
end_include

begin_include
include|#
directive|include
file|<sys/procfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/neutrino.h>
end_include

begin_include
include|#
directive|include
file|<sys/syspage.h>
end_include

begin_include
include|#
directive|include
file|"gdb_dirent.h"
end_include

begin_include
include|#
directive|include
file|<sys/netmgr.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdbthread.h"
end_include

begin_include
include|#
directive|include
file|"nto-tdep.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_define
define|#
directive|define
name|NULL_PID
value|0
end_define

begin_define
define|#
directive|define
name|_DEBUG_FLAG_TRACE
value|(_DEBUG_FLAG_TRACE_EXEC|_DEBUG_FLAG_TRACE_RD|\ 		_DEBUG_FLAG_TRACE_WR|_DEBUG_FLAG_TRACE_MODIFY)
end_define

begin_decl_stmt
specifier|static
name|struct
name|target_ops
name|procfs_ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ctl_fd
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|ofunc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|procfs_run
name|run
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|procfs_open
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|procfs_can_run
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ptid_t
name|procfs_wait
parameter_list|(
name|ptid_t
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|procfs_xfer_memory
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|struct
name|mem_attrib
modifier|*
name|attrib
parameter_list|,
name|struct
name|target_ops
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|procfs_fetch_registers
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|notice_signals
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_procfs_ops
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ptid_t
name|do_attach
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|procfs_can_use_hw_breakpoint
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|procfs_insert_hw_breakpoint
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|procfs_remove_hw_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|procfs_insert_hw_watchpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|procfs_remove_hw_watchpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|procfs_stopped_by_watchpoint
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* These two globals are only ever set in procfs_open(), but are    referenced elsewhere.  'nto_procfs_node' is a flag used to say    whether we are local, or we should get the current node descriptor    for the remote QNX node.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|nto_procfs_path
index|[
name|PATH_MAX
index|]
init|=
block|{
literal|"/proc"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|nto_procfs_node
init|=
name|ND_LOCAL_NODE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the current QNX Node, or error out.  This is a simple    wrapper for the netmgr_strtond() function.  The reason this    is required is because QNX node descriptors are transient so    we have to re-acquire them every time.  */
end_comment

begin_function
specifier|static
name|unsigned
name|nto_node
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|node
decl_stmt|;
if|if
condition|(
name|ND_NODE_CMP
argument_list|(
name|nto_procfs_node
argument_list|,
name|ND_LOCAL_NODE
argument_list|)
operator|==
literal|0
condition|)
return|return
name|ND_LOCAL_NODE
return|;
name|node
operator|=
name|netmgr_strtond
argument_list|(
name|nto_procfs_path
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"Lost the QNX node.  Debug session probably over."
argument_list|)
expr_stmt|;
return|return
operator|(
name|node
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This is called when we call 'target procfs<arg>' from the (gdb) prompt.    For QNX6 (nto), the only valid arg will be a QNX node string,     eg: "/net/some_node".  If arg is not a valid QNX node, we will    default to local.  */
end_comment

begin_function
specifier|static
name|void
name|procfs_open
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
modifier|*
name|nodestr
decl_stmt|;
name|char
modifier|*
name|endstr
decl_stmt|;
name|char
name|buffer
index|[
literal|50
index|]
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|total_size
decl_stmt|;
name|procfs_sysinfo
modifier|*
name|sysinfo
decl_stmt|;
comment|/* Set the default node used for spawning to this one,      and only override it if there is a valid arg.  */
name|nto_procfs_node
operator|=
name|ND_LOCAL_NODE
expr_stmt|;
name|nodestr
operator|=
name|arg
condition|?
name|xstrdup
argument_list|(
name|arg
argument_list|)
else|:
name|arg
expr_stmt|;
name|init_thread_list
argument_list|()
expr_stmt|;
if|if
condition|(
name|nodestr
condition|)
block|{
name|nto_procfs_node
operator|=
name|netmgr_strtond
argument_list|(
name|nodestr
argument_list|,
operator|&
name|endstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|nto_procfs_node
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOTSUP
condition|)
name|printf_filtered
argument_list|(
literal|"QNX Net Manager not found.\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Invalid QNX node %s: error %d (%s).\n"
argument_list|,
name|nodestr
argument_list|,
name|errno
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|nodestr
argument_list|)
expr_stmt|;
name|nodestr
operator|=
name|NULL
expr_stmt|;
name|nto_procfs_node
operator|=
name|ND_LOCAL_NODE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|endstr
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|endstr
operator|-
literal|1
operator|)
operator|==
literal|'/'
condition|)
operator|*
operator|(
name|endstr
operator|-
literal|1
operator|)
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|endstr
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|snprintf
argument_list|(
name|nto_procfs_path
argument_list|,
name|PATH_MAX
operator|-
literal|1
argument_list|,
literal|"%s%s"
argument_list|,
name|nodestr
condition|?
name|nodestr
else|:
literal|""
argument_list|,
literal|"/proc"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nodestr
condition|)
name|xfree
argument_list|(
name|nodestr
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|nto_procfs_path
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Error opening %s : %d (%s)\n"
argument_list|,
name|nto_procfs_path
argument_list|,
name|errno
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Invalid procfs arg"
argument_list|)
expr_stmt|;
block|}
name|sysinfo
operator|=
operator|(
name|void
operator|*
operator|)
name|buffer
expr_stmt|;
if|if
condition|(
name|devctl
argument_list|(
name|fd
argument_list|,
name|DCMD_PROC_SYSINFO
argument_list|,
name|sysinfo
argument_list|,
sizeof|sizeof
name|buffer
argument_list|,
literal|0
argument_list|)
operator|!=
name|EOK
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Error getting size: %d (%s)\n"
argument_list|,
name|errno
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Devctl failed."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|total_size
operator|=
name|sysinfo
operator|->
name|total_size
expr_stmt|;
name|sysinfo
operator|=
name|alloca
argument_list|(
name|total_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sysinfo
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Memory error: %d (%s)\n"
argument_list|,
name|errno
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"alloca failed."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|devctl
argument_list|(
name|fd
argument_list|,
name|DCMD_PROC_SYSINFO
argument_list|,
name|sysinfo
argument_list|,
name|total_size
argument_list|,
literal|0
argument_list|)
operator|!=
name|EOK
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Error getting sysinfo: %d (%s)\n"
argument_list|,
name|errno
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Devctl failed."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sysinfo
operator|->
name|type
operator|!=
name|nto_map_arch_to_cputype
argument_list|(
name|TARGET_ARCHITECTURE
operator|->
name|arch_name
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Invalid target CPU."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Debugging using %s\n"
argument_list|,
name|nto_procfs_path
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|procfs_set_thread
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
name|pid_t
name|tid
decl_stmt|;
name|tid
operator|=
name|ptid_get_tid
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
name|devctl
argument_list|(
name|ctl_fd
argument_list|,
name|DCMD_PROC_CURTHREAD
argument_list|,
operator|&
name|tid
argument_list|,
sizeof|sizeof
argument_list|(
name|tid
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  Return nonzero if the thread TH is still alive.  */
end_comment

begin_function
specifier|static
name|int
name|procfs_thread_alive
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
name|pid_t
name|tid
decl_stmt|;
name|tid
operator|=
name|ptid_get_tid
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
if|if
condition|(
name|devctl
argument_list|(
name|ctl_fd
argument_list|,
name|DCMD_PROC_CURTHREAD
argument_list|,
operator|&
name|tid
argument_list|,
sizeof|sizeof
argument_list|(
name|tid
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|EOK
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|procfs_find_new_threads
parameter_list|(
name|void
parameter_list|)
block|{
name|procfs_status
name|status
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|ptid_t
name|ptid
decl_stmt|;
if|if
condition|(
name|ctl_fd
operator|==
operator|-
literal|1
condition|)
return|return;
name|pid
operator|=
name|ptid_get_pid
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
for|for
control|(
name|status
operator|.
name|tid
operator|=
literal|1
init|;
condition|;
operator|++
name|status
operator|.
name|tid
control|)
block|{
if|if
condition|(
name|devctl
argument_list|(
name|ctl_fd
argument_list|,
name|DCMD_PROC_TIDSTATUS
argument_list|,
operator|&
name|status
argument_list|,
sizeof|sizeof
argument_list|(
name|status
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
name|EOK
operator|&&
name|status
operator|.
name|tid
operator|!=
literal|0
condition|)
break|break;
name|ptid
operator|=
name|ptid_build
argument_list|(
name|pid
argument_list|,
literal|0
argument_list|,
name|status
operator|.
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in_thread_list
argument_list|(
name|ptid
argument_list|)
condition|)
name|add_thread
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|procfs_pidlist
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|DIR
modifier|*
name|dp
init|=
name|NULL
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dirp
init|=
name|NULL
decl_stmt|;
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|;
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|;
name|procfs_info
modifier|*
name|pidinfo
init|=
name|NULL
decl_stmt|;
name|procfs_debuginfo
modifier|*
name|info
init|=
name|NULL
decl_stmt|;
name|procfs_status
modifier|*
name|status
init|=
name|NULL
decl_stmt|;
name|pid_t
name|num_threads
init|=
literal|0
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|char
name|name
index|[
literal|512
index|]
decl_stmt|;
name|dp
operator|=
name|opendir
argument_list|(
name|nto_procfs_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"failed to opendir \"%s\" - %d (%s)"
argument_list|,
name|nto_procfs_path
argument_list|,
name|errno
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Start scan at first pid.  */
name|rewinddir
argument_list|(
name|dp
argument_list|)
expr_stmt|;
do|do
block|{
comment|/* Get the right pid and procfs path for the pid.  */
do|do
block|{
name|dirp
operator|=
name|readdir
argument_list|(
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirp
operator|==
name|NULL
condition|)
block|{
name|closedir
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return;
block|}
name|snprintf
argument_list|(
name|buf
argument_list|,
literal|511
argument_list|,
literal|"%s/%s/as"
argument_list|,
name|nto_procfs_path
argument_list|,
name|dirp
operator|->
name|d_name
argument_list|)
expr_stmt|;
name|pid
operator|=
name|atoi
argument_list|(
name|dirp
operator|->
name|d_name
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|pid
operator|==
literal|0
condition|)
do|;
comment|/* Open the procfs path. */
name|fd
operator|=
name|open
argument_list|(
name|buf
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"failed to open %s - %d (%s)\n"
argument_list|,
name|buf
argument_list|,
name|errno
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|closedir
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return;
block|}
name|pidinfo
operator|=
operator|(
name|procfs_info
operator|*
operator|)
name|buf
expr_stmt|;
if|if
condition|(
name|devctl
argument_list|(
name|fd
argument_list|,
name|DCMD_PROC_INFO
argument_list|,
name|pidinfo
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
name|EOK
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"devctl DCMD_PROC_INFO failed - %d (%s)\n"
argument_list|,
name|errno
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|num_threads
operator|=
name|pidinfo
operator|->
name|num_threads
expr_stmt|;
name|info
operator|=
operator|(
name|procfs_debuginfo
operator|*
operator|)
name|buf
expr_stmt|;
if|if
condition|(
name|devctl
argument_list|(
name|fd
argument_list|,
name|DCMD_PROC_MAPDEBUG_BASE
argument_list|,
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
name|EOK
condition|)
name|strcpy
argument_list|(
name|name
argument_list|,
literal|"unavailable"
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|name
argument_list|,
name|info
operator|->
name|path
argument_list|)
expr_stmt|;
comment|/* Collect state info on all the threads.  */
name|status
operator|=
operator|(
name|procfs_status
operator|*
operator|)
name|buf
expr_stmt|;
for|for
control|(
name|status
operator|->
name|tid
operator|=
literal|1
init|;
name|status
operator|->
name|tid
operator|<=
name|num_threads
condition|;
name|status
operator|->
name|tid
operator|++
control|)
block|{
if|if
condition|(
name|devctl
argument_list|(
name|fd
argument_list|,
name|DCMD_PROC_TIDSTATUS
argument_list|,
name|status
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
name|EOK
operator|&&
name|status
operator|->
name|tid
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|status
operator|->
name|tid
operator|!=
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|"%s - %d/%d\n"
argument_list|,
name|name
argument_list|,
name|pid
argument_list|,
name|status
operator|->
name|tid
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|dirp
operator|!=
name|NULL
condition|)
do|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|closedir
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|procfs_meminfo
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|procfs_mapinfo
modifier|*
name|mapinfos
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|num_mapinfos
init|=
literal|0
decl_stmt|;
name|procfs_mapinfo
modifier|*
name|mapinfo_p
decl_stmt|,
modifier|*
name|mapinfo_p2
decl_stmt|;
name|int
name|flags
init|=
operator|~
literal|0
decl_stmt|,
name|err
decl_stmt|,
name|num
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
struct|struct
block|{
name|procfs_debuginfo
name|info
decl_stmt|;
name|char
name|buff
index|[
name|_POSIX_PATH_MAX
index|]
decl_stmt|;
block|}
name|map
struct|;
struct|struct
name|info
block|{
name|unsigned
name|addr
decl_stmt|;
name|unsigned
name|size
decl_stmt|;
name|unsigned
name|flags
decl_stmt|;
name|unsigned
name|debug_vaddr
decl_stmt|;
name|unsigned
name|long
name|long
name|offset
decl_stmt|;
block|}
struct|;
struct|struct
name|printinfo
block|{
name|unsigned
name|long
name|long
name|ino
decl_stmt|;
name|unsigned
name|dev
decl_stmt|;
name|struct
name|info
name|text
decl_stmt|;
name|struct
name|info
name|data
decl_stmt|;
name|char
name|name
index|[
literal|256
index|]
decl_stmt|;
block|}
name|printme
struct|;
comment|/* Get the number of map entrys.  */
name|err
operator|=
name|devctl
argument_list|(
name|ctl_fd
argument_list|,
name|DCMD_PROC_MAPINFO
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|EOK
condition|)
block|{
name|printf
argument_list|(
literal|"failed devctl num mapinfos - %d (%s)\n"
argument_list|,
name|err
argument_list|,
name|safe_strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|mapinfos
operator|=
name|xmalloc
argument_list|(
name|num
operator|*
sizeof|sizeof
argument_list|(
name|procfs_mapinfo
argument_list|)
argument_list|)
expr_stmt|;
name|num_mapinfos
operator|=
name|num
expr_stmt|;
name|mapinfo_p
operator|=
name|mapinfos
expr_stmt|;
comment|/* Fill the map entrys.  */
name|err
operator|=
name|devctl
argument_list|(
name|ctl_fd
argument_list|,
name|DCMD_PROC_MAPINFO
argument_list|,
name|mapinfo_p
argument_list|,
name|num
operator|*
sizeof|sizeof
argument_list|(
name|procfs_mapinfo
argument_list|)
argument_list|,
operator|&
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|EOK
condition|)
block|{
name|printf
argument_list|(
literal|"failed devctl mapinfos - %d (%s)\n"
argument_list|,
name|err
argument_list|,
name|safe_strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|mapinfos
argument_list|)
expr_stmt|;
return|return;
block|}
name|num
operator|=
name|min
argument_list|(
name|num
argument_list|,
name|num_mapinfos
argument_list|)
expr_stmt|;
comment|/* Run through the list of mapinfos, and store the data and text info      so we can print it at the bottom of the loop.  */
for|for
control|(
name|mapinfo_p
operator|=
name|mapinfos
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
operator|,
name|mapinfo_p
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|mapinfo_p
operator|->
name|flags
operator|&
name|flags
operator|)
condition|)
name|mapinfo_p
operator|->
name|ino
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mapinfo_p
operator|->
name|ino
operator|==
literal|0
condition|)
comment|/* Already visited.  */
continue|continue;
name|map
operator|.
name|info
operator|.
name|vaddr
operator|=
name|mapinfo_p
operator|->
name|vaddr
expr_stmt|;
name|err
operator|=
name|devctl
argument_list|(
name|ctl_fd
argument_list|,
name|DCMD_PROC_MAPDEBUG
argument_list|,
operator|&
name|map
argument_list|,
sizeof|sizeof
argument_list|(
name|map
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|EOK
condition|)
continue|continue;
name|memset
argument_list|(
operator|&
name|printme
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|printme
argument_list|)
expr_stmt|;
name|printme
operator|.
name|dev
operator|=
name|mapinfo_p
operator|->
name|dev
expr_stmt|;
name|printme
operator|.
name|ino
operator|=
name|mapinfo_p
operator|->
name|ino
expr_stmt|;
name|printme
operator|.
name|text
operator|.
name|addr
operator|=
name|mapinfo_p
operator|->
name|vaddr
expr_stmt|;
name|printme
operator|.
name|text
operator|.
name|size
operator|=
name|mapinfo_p
operator|->
name|size
expr_stmt|;
name|printme
operator|.
name|text
operator|.
name|flags
operator|=
name|mapinfo_p
operator|->
name|flags
expr_stmt|;
name|printme
operator|.
name|text
operator|.
name|offset
operator|=
name|mapinfo_p
operator|->
name|offset
expr_stmt|;
name|printme
operator|.
name|text
operator|.
name|debug_vaddr
operator|=
name|map
operator|.
name|info
operator|.
name|vaddr
expr_stmt|;
name|strcpy
argument_list|(
name|printme
operator|.
name|name
argument_list|,
name|map
operator|.
name|info
operator|.
name|path
argument_list|)
expr_stmt|;
comment|/* Check for matching data.  */
for|for
control|(
name|mapinfo_p2
operator|=
name|mapinfos
operator|,
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num
condition|;
name|j
operator|++
operator|,
name|mapinfo_p2
operator|++
control|)
block|{
if|if
condition|(
name|mapinfo_p2
operator|->
name|vaddr
operator|!=
name|mapinfo_p
operator|->
name|vaddr
operator|&&
name|mapinfo_p2
operator|->
name|ino
operator|==
name|mapinfo_p
operator|->
name|ino
operator|&&
name|mapinfo_p2
operator|->
name|dev
operator|==
name|mapinfo_p
operator|->
name|dev
condition|)
block|{
name|map
operator|.
name|info
operator|.
name|vaddr
operator|=
name|mapinfo_p2
operator|->
name|vaddr
expr_stmt|;
name|err
operator|=
name|devctl
argument_list|(
name|ctl_fd
argument_list|,
name|DCMD_PROC_MAPDEBUG
argument_list|,
operator|&
name|map
argument_list|,
sizeof|sizeof
argument_list|(
name|map
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|EOK
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|map
operator|.
name|info
operator|.
name|path
argument_list|,
name|printme
operator|.
name|name
argument_list|)
condition|)
continue|continue;
comment|/* Lower debug_vaddr is always text, if nessessary, swap.  */
if|if
condition|(
operator|(
name|int
operator|)
name|map
operator|.
name|info
operator|.
name|vaddr
operator|<
operator|(
name|int
operator|)
name|printme
operator|.
name|text
operator|.
name|debug_vaddr
condition|)
block|{
name|memcpy
argument_list|(
operator|&
operator|(
name|printme
operator|.
name|data
operator|)
argument_list|,
operator|&
operator|(
name|printme
operator|.
name|text
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|printme
operator|.
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|printme
operator|.
name|text
operator|.
name|addr
operator|=
name|mapinfo_p2
operator|->
name|vaddr
expr_stmt|;
name|printme
operator|.
name|text
operator|.
name|size
operator|=
name|mapinfo_p2
operator|->
name|size
expr_stmt|;
name|printme
operator|.
name|text
operator|.
name|flags
operator|=
name|mapinfo_p2
operator|->
name|flags
expr_stmt|;
name|printme
operator|.
name|text
operator|.
name|offset
operator|=
name|mapinfo_p2
operator|->
name|offset
expr_stmt|;
name|printme
operator|.
name|text
operator|.
name|debug_vaddr
operator|=
name|map
operator|.
name|info
operator|.
name|vaddr
expr_stmt|;
block|}
else|else
block|{
name|printme
operator|.
name|data
operator|.
name|addr
operator|=
name|mapinfo_p2
operator|->
name|vaddr
expr_stmt|;
name|printme
operator|.
name|data
operator|.
name|size
operator|=
name|mapinfo_p2
operator|->
name|size
expr_stmt|;
name|printme
operator|.
name|data
operator|.
name|flags
operator|=
name|mapinfo_p2
operator|->
name|flags
expr_stmt|;
name|printme
operator|.
name|data
operator|.
name|offset
operator|=
name|mapinfo_p2
operator|->
name|offset
expr_stmt|;
name|printme
operator|.
name|data
operator|.
name|debug_vaddr
operator|=
name|map
operator|.
name|info
operator|.
name|vaddr
expr_stmt|;
block|}
name|mapinfo_p2
operator|->
name|ino
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|mapinfo_p
operator|->
name|ino
operator|=
literal|0
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s\n"
argument_list|,
name|printme
operator|.
name|name
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\ttext=%08x bytes @ 0x%08x\n"
argument_list|,
name|printme
operator|.
name|text
operator|.
name|size
argument_list|,
name|printme
operator|.
name|text
operator|.
name|addr
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\t\tflags=%08x\n"
argument_list|,
name|printme
operator|.
name|text
operator|.
name|flags
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\t\tdebug=%08x\n"
argument_list|,
name|printme
operator|.
name|text
operator|.
name|debug_vaddr
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\t\toffset=%016llx\n"
argument_list|,
name|printme
operator|.
name|text
operator|.
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|printme
operator|.
name|data
operator|.
name|size
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\tdata=%08x bytes @ 0x%08x\n"
argument_list|,
name|printme
operator|.
name|data
operator|.
name|size
argument_list|,
name|printme
operator|.
name|data
operator|.
name|addr
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\t\tflags=%08x\n"
argument_list|,
name|printme
operator|.
name|data
operator|.
name|flags
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\t\tdebug=%08x\n"
argument_list|,
name|printme
operator|.
name|data
operator|.
name|debug_vaddr
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\t\toffset=%016llx\n"
argument_list|,
name|printme
operator|.
name|data
operator|.
name|offset
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"\tdev=0x%x\n"
argument_list|,
name|printme
operator|.
name|dev
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\tino=0x%x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|printme
operator|.
name|ino
argument_list|)
expr_stmt|;
block|}
name|xfree
argument_list|(
name|mapinfos
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Print status information about what we're accessing.  */
end_comment

begin_function
specifier|static
name|void
name|procfs_files_info
parameter_list|(
name|struct
name|target_ops
modifier|*
name|ignore
parameter_list|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\tUsing the running image of %s %s via %s.\n"
argument_list|,
name|attach_flag
condition|?
literal|"attached"
else|:
literal|"child"
argument_list|,
name|target_pid_to_str
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|nto_procfs_path
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark our target-struct as eligible for stray "run" and "attach" commands.  */
end_comment

begin_function
specifier|static
name|int
name|procfs_can_run
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Attach to process PID, then initialize for debugging it.  */
end_comment

begin_function
specifier|static
name|void
name|procfs_attach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
modifier|*
name|exec_file
decl_stmt|;
name|int
name|pid
decl_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
name|error_no_arg
argument_list|(
literal|"process-id to attach"
argument_list|)
expr_stmt|;
name|pid
operator|=
name|atoi
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
name|getpid
argument_list|()
condition|)
name|error
argument_list|(
literal|"Attaching GDB to itself is not a good idea..."
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|exec_file
operator|=
operator|(
name|char
operator|*
operator|)
name|get_exec_file
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|exec_file
condition|)
name|printf_unfiltered
argument_list|(
literal|"Attaching to program `%s', %s\n"
argument_list|,
name|exec_file
argument_list|,
name|target_pid_to_str
argument_list|(
name|pid_to_ptid
argument_list|(
name|pid
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf_unfiltered
argument_list|(
literal|"Attaching to %s\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|pid_to_ptid
argument_list|(
name|pid
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|inferior_ptid
operator|=
name|do_attach
argument_list|(
name|pid_to_ptid
argument_list|(
name|pid
argument_list|)
argument_list|)
expr_stmt|;
name|push_target
argument_list|(
operator|&
name|procfs_ops
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|procfs_post_attach
parameter_list|(
name|pid_t
name|pid
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SOLIB_CREATE_INFERIOR_HOOK
if|if
condition|(
name|exec_bfd
condition|)
name|SOLIB_CREATE_INFERIOR_HOOK
argument_list|(
name|pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|ptid_t
name|do_attach
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
name|procfs_status
name|status
decl_stmt|;
name|struct
name|sigevent
name|event
decl_stmt|;
name|char
name|path
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|path
argument_list|,
name|PATH_MAX
operator|-
literal|1
argument_list|,
literal|"%s/%d/as"
argument_list|,
name|nto_procfs_path
argument_list|,
name|PIDGET
argument_list|(
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
name|ctl_fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl_fd
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"Couldn't open proc file %s, error %d (%s)"
argument_list|,
name|path
argument_list|,
name|errno
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|devctl
argument_list|(
name|ctl_fd
argument_list|,
name|DCMD_PROC_STOP
argument_list|,
operator|&
name|status
argument_list|,
sizeof|sizeof
argument_list|(
name|status
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
name|EOK
condition|)
name|error
argument_list|(
literal|"Couldn't stop process"
argument_list|)
expr_stmt|;
comment|/* Define a sigevent for process stopped notification.  */
name|event
operator|.
name|sigev_notify
operator|=
name|SIGEV_SIGNAL_THREAD
expr_stmt|;
name|event
operator|.
name|sigev_signo
operator|=
name|SIGUSR1
expr_stmt|;
name|event
operator|.
name|sigev_code
operator|=
literal|0
expr_stmt|;
name|event
operator|.
name|sigev_value
operator|.
name|sival_ptr
operator|=
name|NULL
expr_stmt|;
name|event
operator|.
name|sigev_priority
operator|=
operator|-
literal|1
expr_stmt|;
name|devctl
argument_list|(
name|ctl_fd
argument_list|,
name|DCMD_PROC_EVENT
argument_list|,
operator|&
name|event
argument_list|,
sizeof|sizeof
argument_list|(
name|event
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|devctl
argument_list|(
name|ctl_fd
argument_list|,
name|DCMD_PROC_STATUS
argument_list|,
operator|&
name|status
argument_list|,
sizeof|sizeof
argument_list|(
name|status
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
name|EOK
operator|&&
name|status
operator|.
name|flags
operator|&
name|_DEBUG_FLAG_STOPPED
condition|)
name|SignalKill
argument_list|(
name|nto_node
argument_list|()
argument_list|,
name|PIDGET
argument_list|(
name|ptid
argument_list|)
argument_list|,
literal|0
argument_list|,
name|SIGCONT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|attach_flag
operator|=
literal|1
expr_stmt|;
name|nto_init_solib_absolute_prefix
argument_list|()
expr_stmt|;
return|return
name|ptid
return|;
block|}
end_function

begin_comment
comment|/* Ask the user what to do when an interrupt is received.  */
end_comment

begin_function
specifier|static
name|void
name|interrupt_query
parameter_list|(
name|void
parameter_list|)
block|{
name|target_terminal_ours
argument_list|()
expr_stmt|;
if|if
condition|(
name|query
argument_list|(
literal|"Interrupted while waiting for the program.\n\ Give up (and stop debugging it)? "
argument_list|)
condition|)
block|{
name|target_mourn_inferior
argument_list|()
expr_stmt|;
name|throw_exception
argument_list|(
name|RETURN_QUIT
argument_list|)
expr_stmt|;
block|}
name|target_terminal_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The user typed ^C twice.  */
end_comment

begin_function
specifier|static
name|void
name|nto_interrupt_twice
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
name|signal
argument_list|(
name|signo
argument_list|,
name|ofunc
argument_list|)
expr_stmt|;
name|interrupt_query
argument_list|()
expr_stmt|;
name|signal
argument_list|(
name|signo
argument_list|,
name|nto_interrupt_twice
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nto_interrupt
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
comment|/* If this doesn't work, try more severe steps.  */
name|signal
argument_list|(
name|signo
argument_list|,
name|nto_interrupt_twice
argument_list|)
expr_stmt|;
name|target_stop
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|ptid_t
name|procfs_wait
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
name|ourstatus
parameter_list|)
block|{
name|sigset_t
name|set
decl_stmt|;
name|siginfo_t
name|info
decl_stmt|;
name|procfs_status
name|status
decl_stmt|;
specifier|static
name|int
name|exit_signo
init|=
literal|0
decl_stmt|;
comment|/* To track signals that cause termination.  */
name|ourstatus
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_SPURIOUS
expr_stmt|;
if|if
condition|(
name|ptid_equal
argument_list|(
name|inferior_ptid
argument_list|,
name|null_ptid
argument_list|)
condition|)
block|{
name|ourstatus
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_0
expr_stmt|;
name|exit_signo
operator|=
literal|0
expr_stmt|;
return|return
name|null_ptid
return|;
block|}
name|sigemptyset
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|set
argument_list|,
name|SIGUSR1
argument_list|)
expr_stmt|;
name|devctl
argument_list|(
name|ctl_fd
argument_list|,
name|DCMD_PROC_STATUS
argument_list|,
operator|&
name|status
argument_list|,
sizeof|sizeof
argument_list|(
name|status
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|status
operator|.
name|flags
operator|&
name|_DEBUG_FLAG_ISTOP
operator|)
condition|)
block|{
name|ofunc
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|nto_interrupt
argument_list|)
expr_stmt|;
name|sigwaitinfo
argument_list|(
operator|&
name|set
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|ofunc
argument_list|)
expr_stmt|;
name|devctl
argument_list|(
name|ctl_fd
argument_list|,
name|DCMD_PROC_STATUS
argument_list|,
operator|&
name|status
argument_list|,
sizeof|sizeof
argument_list|(
name|status
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|.
name|flags
operator|&
name|_DEBUG_FLAG_SSTEP
condition|)
block|{
name|ourstatus
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
block|}
comment|/* Was it a breakpoint?  */
elseif|else
if|if
condition|(
name|status
operator|.
name|flags
operator|&
name|_DEBUG_FLAG_TRACE
condition|)
block|{
name|ourstatus
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|.
name|flags
operator|&
name|_DEBUG_FLAG_ISTOP
condition|)
block|{
switch|switch
condition|(
name|status
operator|.
name|why
condition|)
block|{
case|case
name|_DEBUG_WHY_SIGNALLED
case|:
name|ourstatus
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|target_signal_from_host
argument_list|(
name|status
operator|.
name|info
operator|.
name|si_signo
argument_list|)
expr_stmt|;
name|exit_signo
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|_DEBUG_WHY_FAULTED
case|:
name|ourstatus
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
if|if
condition|(
name|status
operator|.
name|info
operator|.
name|si_signo
operator|==
name|SIGTRAP
condition|)
block|{
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
literal|0
expr_stmt|;
name|exit_signo
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|target_signal_from_host
argument_list|(
name|status
operator|.
name|info
operator|.
name|si_signo
argument_list|)
expr_stmt|;
name|exit_signo
operator|=
name|ourstatus
operator|->
name|value
operator|.
name|sig
expr_stmt|;
block|}
break|break;
case|case
name|_DEBUG_WHY_TERMINATED
case|:
block|{
name|int
name|waitval
init|=
literal|0
decl_stmt|;
name|waitpid
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
operator|&
name|waitval
argument_list|,
name|WNOHANG
argument_list|)
expr_stmt|;
if|if
condition|(
name|exit_signo
condition|)
block|{
comment|/* Abnormal death.  */
name|ourstatus
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_SIGNALLED
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|exit_signo
expr_stmt|;
block|}
else|else
block|{
comment|/* Normal death.  */
name|ourstatus
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|integer
operator|=
name|WEXITSTATUS
argument_list|(
name|waitval
argument_list|)
expr_stmt|;
block|}
name|exit_signo
operator|=
literal|0
expr_stmt|;
break|break;
block|}
case|case
name|_DEBUG_WHY_REQUESTED
case|:
comment|/* We are assuming a requested stop is due to a SIGINT.  */
name|ourstatus
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_INT
expr_stmt|;
name|exit_signo
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
return|return
name|inferior_ptid
return|;
block|}
end_function

begin_comment
comment|/* Read the current values of the inferior's registers, both the    general register set and floating point registers (if supported)    and update gdb's idea of their current values.  */
end_comment

begin_function
specifier|static
name|void
name|procfs_fetch_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
union|union
block|{
name|procfs_greg
name|greg
decl_stmt|;
name|procfs_fpreg
name|fpreg
decl_stmt|;
name|procfs_altreg
name|altreg
decl_stmt|;
block|}
name|reg
union|;
name|int
name|regsize
decl_stmt|;
name|procfs_set_thread
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
if|if
condition|(
name|devctl
argument_list|(
name|ctl_fd
argument_list|,
name|DCMD_PROC_GETGREG
argument_list|,
operator|&
name|reg
argument_list|,
sizeof|sizeof
argument_list|(
name|reg
argument_list|)
argument_list|,
operator|&
name|regsize
argument_list|)
operator|==
name|EOK
condition|)
name|nto_supply_gregset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|reg
operator|.
name|greg
argument_list|)
expr_stmt|;
if|if
condition|(
name|devctl
argument_list|(
name|ctl_fd
argument_list|,
name|DCMD_PROC_GETFPREG
argument_list|,
operator|&
name|reg
argument_list|,
sizeof|sizeof
argument_list|(
name|reg
argument_list|)
argument_list|,
operator|&
name|regsize
argument_list|)
operator|==
name|EOK
condition|)
name|nto_supply_fpregset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|reg
operator|.
name|fpreg
argument_list|)
expr_stmt|;
if|if
condition|(
name|devctl
argument_list|(
name|ctl_fd
argument_list|,
name|DCMD_PROC_GETALTREG
argument_list|,
operator|&
name|reg
argument_list|,
sizeof|sizeof
argument_list|(
name|reg
argument_list|)
argument_list|,
operator|&
name|regsize
argument_list|)
operator|==
name|EOK
condition|)
name|nto_supply_altregset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|reg
operator|.
name|altreg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy LEN bytes to/from inferior's memory starting at MEMADDR    from/to debugger memory starting at MYADDR.  Copy from inferior    if DOWRITE is zero or to inferior if DOWRITE is nonzero.     Returns the length copied, which is either the LEN argument or    zero.  This xfer function does not do partial moves, since procfs_ops    doesn't allow memory operations to cross below us in the target stack    anyway.  */
end_comment

begin_function
specifier|static
name|int
name|procfs_xfer_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|dowrite
parameter_list|,
name|struct
name|mem_attrib
modifier|*
name|attrib
parameter_list|,
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
block|{
name|int
name|nbytes
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|ctl_fd
argument_list|,
operator|(
name|off_t
operator|)
name|memaddr
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|(
name|off_t
operator|)
name|memaddr
condition|)
block|{
if|if
condition|(
name|dowrite
condition|)
name|nbytes
operator|=
name|write
argument_list|(
name|ctl_fd
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|nbytes
operator|=
name|read
argument_list|(
name|ctl_fd
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|<
literal|0
condition|)
name|nbytes
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|nbytes
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Take a program previously attached to and detaches it.    The program resumes execution and will no longer stop    on signals, etc.  We'd better not have left any breakpoints    in the program or it'll die when it hits one.  */
end_comment

begin_function
specifier|static
name|void
name|procfs_detach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|int
name|siggnal
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|char
modifier|*
name|exec_file
init|=
name|get_exec_file
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|exec_file
operator|==
literal|0
condition|)
name|exec_file
operator|=
literal|""
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"Detaching from program: %s %s\n"
argument_list|,
name|exec_file
argument_list|,
name|target_pid_to_str
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|args
condition|)
name|siggnal
operator|=
name|atoi
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|siggnal
condition|)
name|SignalKill
argument_list|(
name|nto_node
argument_list|()
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
literal|0
argument_list|,
name|siggnal
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ctl_fd
argument_list|)
expr_stmt|;
name|ctl_fd
operator|=
operator|-
literal|1
expr_stmt|;
name|init_thread_list
argument_list|()
expr_stmt|;
name|inferior_ptid
operator|=
name|null_ptid
expr_stmt|;
name|attach_flag
operator|=
literal|0
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|procfs_ops
argument_list|)
expr_stmt|;
comment|/* Pop out of handling an inferior.  */
block|}
end_function

begin_function
specifier|static
name|int
name|procfs_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|procfs_break
name|brk
decl_stmt|;
name|brk
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|brk
operator|.
name|addr
operator|=
name|addr
expr_stmt|;
name|brk
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|errno
operator|=
name|devctl
argument_list|(
name|ctl_fd
argument_list|,
name|DCMD_PROC_BREAK
argument_list|,
operator|&
name|brk
argument_list|,
sizeof|sizeof
argument_list|(
name|brk
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
name|EOK
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|procfs_insert_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|contents_cache
parameter_list|)
block|{
return|return
name|procfs_breakpoint
argument_list|(
name|addr
argument_list|,
name|_DEBUG_BREAK_EXEC
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|procfs_remove_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|contents_cache
parameter_list|)
block|{
return|return
name|procfs_breakpoint
argument_list|(
name|addr
argument_list|,
name|_DEBUG_BREAK_EXEC
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|procfs_insert_hw_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|contents_cache
parameter_list|)
block|{
return|return
name|procfs_breakpoint
argument_list|(
name|addr
argument_list|,
name|_DEBUG_BREAK_EXEC
operator||
name|_DEBUG_BREAK_HW
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|procfs_remove_hw_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|contents_cache
parameter_list|)
block|{
return|return
name|procfs_breakpoint
argument_list|(
name|addr
argument_list|,
name|_DEBUG_BREAK_EXEC
operator||
name|_DEBUG_BREAK_HW
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|procfs_resume
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|step
parameter_list|,
name|enum
name|target_signal
name|signo
parameter_list|)
block|{
name|int
name|signal_to_pass
decl_stmt|;
name|procfs_status
name|status
decl_stmt|;
if|if
condition|(
name|ptid_equal
argument_list|(
name|inferior_ptid
argument_list|,
name|null_ptid
argument_list|)
condition|)
return|return;
name|procfs_set_thread
argument_list|(
name|ptid_equal
argument_list|(
name|ptid
argument_list|,
name|minus_one_ptid
argument_list|)
condition|?
name|inferior_ptid
else|:
name|ptid
argument_list|)
expr_stmt|;
name|run
operator|.
name|flags
operator|=
name|_DEBUG_RUN_FAULT
operator||
name|_DEBUG_RUN_TRACE
expr_stmt|;
if|if
condition|(
name|step
condition|)
name|run
operator|.
name|flags
operator||=
name|_DEBUG_RUN_STEP
expr_stmt|;
name|sigemptyset
argument_list|(
operator|(
name|sigset_t
operator|*
operator|)
operator|&
name|run
operator|.
name|fault
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|(
name|sigset_t
operator|*
operator|)
operator|&
name|run
operator|.
name|fault
argument_list|,
name|FLTBPT
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|(
name|sigset_t
operator|*
operator|)
operator|&
name|run
operator|.
name|fault
argument_list|,
name|FLTTRACE
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|(
name|sigset_t
operator|*
operator|)
operator|&
name|run
operator|.
name|fault
argument_list|,
name|FLTILL
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|(
name|sigset_t
operator|*
operator|)
operator|&
name|run
operator|.
name|fault
argument_list|,
name|FLTPRIV
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|(
name|sigset_t
operator|*
operator|)
operator|&
name|run
operator|.
name|fault
argument_list|,
name|FLTBOUNDS
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|(
name|sigset_t
operator|*
operator|)
operator|&
name|run
operator|.
name|fault
argument_list|,
name|FLTIOVF
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|(
name|sigset_t
operator|*
operator|)
operator|&
name|run
operator|.
name|fault
argument_list|,
name|FLTIZDIV
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|(
name|sigset_t
operator|*
operator|)
operator|&
name|run
operator|.
name|fault
argument_list|,
name|FLTFPE
argument_list|)
expr_stmt|;
comment|/* Peter V will be changing this at some point.  */
name|sigaddset
argument_list|(
operator|(
name|sigset_t
operator|*
operator|)
operator|&
name|run
operator|.
name|fault
argument_list|,
name|FLTPAGE
argument_list|)
expr_stmt|;
name|run
operator|.
name|flags
operator||=
name|_DEBUG_RUN_ARM
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|run
operator|.
name|trace
argument_list|)
expr_stmt|;
name|notice_signals
argument_list|()
expr_stmt|;
name|signal_to_pass
operator|=
name|target_signal_to_host
argument_list|(
name|signo
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal_to_pass
condition|)
block|{
name|devctl
argument_list|(
name|ctl_fd
argument_list|,
name|DCMD_PROC_STATUS
argument_list|,
operator|&
name|status
argument_list|,
sizeof|sizeof
argument_list|(
name|status
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|signal_to_pass
operator|=
name|target_signal_to_host
argument_list|(
name|signo
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|.
name|why
operator|&
operator|(
name|_DEBUG_WHY_SIGNALLED
operator||
name|_DEBUG_WHY_FAULTED
operator|)
condition|)
block|{
if|if
condition|(
name|signal_to_pass
operator|!=
name|status
operator|.
name|info
operator|.
name|si_signo
condition|)
block|{
name|SignalKill
argument_list|(
name|nto_node
argument_list|()
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
literal|0
argument_list|,
name|signal_to_pass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|run
operator|.
name|flags
operator||=
name|_DEBUG_RUN_CLRFLT
operator||
name|_DEBUG_RUN_CLRSIG
expr_stmt|;
block|}
else|else
comment|/* Let it kill the program without telling us.  */
name|sigdelset
argument_list|(
operator|&
name|run
operator|.
name|trace
argument_list|,
name|signal_to_pass
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|run
operator|.
name|flags
operator||=
name|_DEBUG_RUN_CLRSIG
operator||
name|_DEBUG_RUN_CLRFLT
expr_stmt|;
name|errno
operator|=
name|devctl
argument_list|(
name|ctl_fd
argument_list|,
name|DCMD_PROC_RUN
argument_list|,
operator|&
name|run
argument_list|,
sizeof|sizeof
argument_list|(
name|run
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
name|EOK
condition|)
block|{
name|perror
argument_list|(
literal|"run error!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|procfs_mourn_inferior
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ptid_equal
argument_list|(
name|inferior_ptid
argument_list|,
name|null_ptid
argument_list|)
condition|)
block|{
name|SignalKill
argument_list|(
name|nto_node
argument_list|()
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
literal|0
argument_list|,
name|SIGKILL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ctl_fd
argument_list|)
expr_stmt|;
block|}
name|inferior_ptid
operator|=
name|null_ptid
expr_stmt|;
name|init_thread_list
argument_list|()
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|procfs_ops
argument_list|)
expr_stmt|;
name|generic_mourn_inferior
argument_list|()
expr_stmt|;
name|attach_flag
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function breaks up an argument string into an argument    vector suitable for passing to execvp().    E.g., on "run a b c d" this routine would get as input    the string "a b c d", and as output it would fill in argv with    the four arguments "a", "b", "c", "d".  The only additional    functionality is simple quoting.  The gdb command:   	run a "b c d" f    will fill in argv with the three args "a", "b c d", "e".  */
end_comment

begin_function
specifier|static
name|void
name|breakup_args
parameter_list|(
name|char
modifier|*
name|scratch
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
modifier|*
name|pp
decl_stmt|,
modifier|*
name|cp
init|=
name|scratch
decl_stmt|;
name|char
name|quoting
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Scan past leading separators.  */
name|quoting
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|==
literal|' '
operator|||
operator|*
name|cp
operator|==
literal|'\t'
operator|||
operator|*
name|cp
operator|==
literal|'\n'
condition|)
name|cp
operator|++
expr_stmt|;
comment|/* Break if at end of string.  */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
break|break;
comment|/* Take an arg.  */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'"'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
name|quoting
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'"'
argument_list|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
operator|*
name|argv
operator|++
operator|=
name|cp
expr_stmt|;
comment|/* Scan for next arg separator.  */
name|pp
operator|=
name|cp
expr_stmt|;
if|if
condition|(
name|quoting
condition|)
name|cp
operator|=
name|strchr
argument_list|(
name|pp
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|!
name|quoting
operator|)
condition|)
name|cp
operator|=
name|strchr
argument_list|(
name|pp
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|cp
operator|=
name|strchr
argument_list|(
name|pp
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|cp
operator|=
name|strchr
argument_list|(
name|pp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* No separators => end of string => break.  */
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|pp
operator|=
name|cp
expr_stmt|;
break|break;
block|}
comment|/* Replace the separator with a terminator.  */
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* Execv requires a null-terminated arg vector.  */
operator|*
name|argv
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|procfs_create_inferior
parameter_list|(
name|char
modifier|*
name|exec_file
parameter_list|,
name|char
modifier|*
name|allargs
parameter_list|,
name|char
modifier|*
modifier|*
name|env
parameter_list|)
block|{
name|struct
name|inheritance
name|inherit
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|errn
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|,
modifier|*
name|args
decl_stmt|;
name|char
modifier|*
name|in
init|=
literal|""
decl_stmt|,
modifier|*
name|out
init|=
literal|""
decl_stmt|,
modifier|*
name|err
init|=
literal|""
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|fds
index|[
literal|3
index|]
decl_stmt|;
name|sigset_t
name|set
decl_stmt|;
name|argv
operator|=
name|xmalloc
argument_list|(
operator|(
operator|(
name|strlen
argument_list|(
name|allargs
argument_list|)
operator|+
literal|1
operator|)
operator|/
operator|(
name|unsigned
operator|)
literal|2
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|argv
argument_list|)
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
name|get_exec_file
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|argv
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|exec_file
condition|)
name|argv
index|[
literal|0
index|]
operator|=
name|exec_file
expr_stmt|;
else|else
return|return;
block|}
name|args
operator|=
name|xstrdup
argument_list|(
name|allargs
argument_list|)
expr_stmt|;
name|breakup_args
argument_list|(
name|args
argument_list|,
name|exec_file
condition|?
operator|&
name|argv
index|[
literal|1
index|]
else|:
operator|&
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|argv
operator|=
name|nto_parse_redirection
argument_list|(
name|argv
argument_list|,
operator|&
name|in
argument_list|,
operator|&
name|out
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
name|fds
index|[
literal|0
index|]
operator|=
name|STDIN_FILENO
expr_stmt|;
name|fds
index|[
literal|1
index|]
operator|=
name|STDOUT_FILENO
expr_stmt|;
name|fds
index|[
literal|2
index|]
operator|=
name|STDERR_FILENO
expr_stmt|;
comment|/* If the user specified I/O via gdb's --tty= arg, use it, but only      if the i/o is not also being specified via redirection.  */
if|if
condition|(
name|inferior_io_terminal
condition|)
block|{
if|if
condition|(
operator|!
name|in
index|[
literal|0
index|]
condition|)
name|in
operator|=
name|inferior_io_terminal
expr_stmt|;
if|if
condition|(
operator|!
name|out
index|[
literal|0
index|]
condition|)
name|out
operator|=
name|inferior_io_terminal
expr_stmt|;
if|if
condition|(
operator|!
name|err
index|[
literal|0
index|]
condition|)
name|err
operator|=
name|inferior_io_terminal
expr_stmt|;
block|}
if|if
condition|(
name|in
index|[
literal|0
index|]
condition|)
block|{
name|fd
operator|=
name|open
argument_list|(
name|in
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
name|perror
argument_list|(
name|in
argument_list|)
expr_stmt|;
else|else
name|fds
index|[
literal|0
index|]
operator|=
name|fd
expr_stmt|;
block|}
if|if
condition|(
name|out
index|[
literal|0
index|]
condition|)
block|{
name|fd
operator|=
name|open
argument_list|(
name|out
argument_list|,
name|O_WRONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
name|perror
argument_list|(
name|out
argument_list|)
expr_stmt|;
else|else
name|fds
index|[
literal|1
index|]
operator|=
name|fd
expr_stmt|;
block|}
if|if
condition|(
name|err
index|[
literal|0
index|]
condition|)
block|{
name|fd
operator|=
name|open
argument_list|(
name|err
argument_list|,
name|O_WRONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
condition|)
name|perror
argument_list|(
name|err
argument_list|)
expr_stmt|;
else|else
name|fds
index|[
literal|2
index|]
operator|=
name|fd
expr_stmt|;
block|}
comment|/* Clear any pending SIGUSR1's but keep the behavior the same.  */
name|signal
argument_list|(
name|SIGUSR1
argument_list|,
name|signal
argument_list|(
name|SIGUSR1
argument_list|,
name|SIG_IGN
argument_list|)
argument_list|)
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|set
argument_list|,
name|SIGUSR1
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_UNBLOCK
argument_list|,
operator|&
name|set
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|inherit
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|inherit
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ND_NODE_CMP
argument_list|(
name|nto_procfs_node
argument_list|,
name|ND_LOCAL_NODE
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|inherit
operator|.
name|nd
operator|=
name|nto_node
argument_list|()
expr_stmt|;
name|inherit
operator|.
name|flags
operator||=
name|SPAWN_SETND
expr_stmt|;
name|inherit
operator|.
name|flags
operator|&=
operator|~
name|SPAWN_EXEC
expr_stmt|;
block|}
name|inherit
operator|.
name|flags
operator||=
name|SPAWN_SETGROUP
operator||
name|SPAWN_HOLD
expr_stmt|;
name|inherit
operator|.
name|pgroup
operator|=
name|SPAWN_NEWPGROUP
expr_stmt|;
name|pid
operator|=
name|spawnp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|3
argument_list|,
name|fds
argument_list|,
operator|&
name|inherit
argument_list|,
name|argv
argument_list|,
name|ND_NODE_CMP
argument_list|(
name|nto_procfs_node
argument_list|,
name|ND_LOCAL_NODE
argument_list|)
operator|==
literal|0
condition|?
name|env
else|:
literal|0
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|set
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"Error spawning %s: %d (%s)"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|errno
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fds
index|[
literal|0
index|]
operator|!=
name|STDIN_FILENO
condition|)
name|close
argument_list|(
name|fds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|fds
index|[
literal|1
index|]
operator|!=
name|STDOUT_FILENO
condition|)
name|close
argument_list|(
name|fds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|fds
index|[
literal|2
index|]
operator|!=
name|STDERR_FILENO
condition|)
name|close
argument_list|(
name|fds
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|inferior_ptid
operator|=
name|do_attach
argument_list|(
name|pid_to_ptid
argument_list|(
name|pid
argument_list|)
argument_list|)
expr_stmt|;
name|attach_flag
operator|=
literal|0
expr_stmt|;
name|flags
operator|=
name|_DEBUG_FLAG_KLC
expr_stmt|;
comment|/* Kill-on-Last-Close flag.  */
name|errn
operator|=
name|devctl
argument_list|(
name|ctl_fd
argument_list|,
name|DCMD_PROC_SET_FLAG
argument_list|,
operator|&
name|flags
argument_list|,
sizeof|sizeof
argument_list|(
name|flags
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errn
operator|!=
name|EOK
condition|)
block|{
comment|/* FIXME: expected warning?  */
comment|/* warning( "Failed to set Kill-on-Last-Close flag: errno = %d(%s)\n",          errn, strerror(errn) ); */
block|}
name|push_target
argument_list|(
operator|&
name|procfs_ops
argument_list|)
expr_stmt|;
name|target_terminal_init
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SOLIB_CREATE_INFERIOR_HOOK
if|if
condition|(
name|exec_bfd
operator|!=
name|NULL
operator|||
operator|(
name|symfile_objfile
operator|!=
name|NULL
operator|&&
name|symfile_objfile
operator|->
name|obfd
operator|!=
name|NULL
operator|)
condition|)
name|SOLIB_CREATE_INFERIOR_HOOK
argument_list|(
name|pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|procfs_stop
parameter_list|(
name|void
parameter_list|)
block|{
name|devctl
argument_list|(
name|ctl_fd
argument_list|,
name|DCMD_PROC_STOP
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|procfs_kill_inferior
parameter_list|(
name|void
parameter_list|)
block|{
name|target_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store register REGNO, or all registers if REGNO == -1, from the contents    of REGISTERS.  */
end_comment

begin_function
specifier|static
name|void
name|procfs_prepare_to_store
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* Fill buf with regset and return devctl cmd to do the setting.  Return    -1 if we fail to get the regset.  Store size of regset in regsize.  */
end_comment

begin_function
specifier|static
name|int
name|get_regset
parameter_list|(
name|int
name|regset
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|bufsize
parameter_list|,
name|int
modifier|*
name|regsize
parameter_list|)
block|{
name|int
name|dev_get
decl_stmt|,
name|dev_set
decl_stmt|;
switch|switch
condition|(
name|regset
condition|)
block|{
case|case
name|NTO_REG_GENERAL
case|:
name|dev_get
operator|=
name|DCMD_PROC_GETGREG
expr_stmt|;
name|dev_set
operator|=
name|DCMD_PROC_SETGREG
expr_stmt|;
break|break;
case|case
name|NTO_REG_FLOAT
case|:
name|dev_get
operator|=
name|DCMD_PROC_GETFPREG
expr_stmt|;
name|dev_set
operator|=
name|DCMD_PROC_SETFPREG
expr_stmt|;
break|break;
case|case
name|NTO_REG_ALT
case|:
name|dev_get
operator|=
name|DCMD_PROC_GETALTREG
expr_stmt|;
name|dev_set
operator|=
name|DCMD_PROC_SETALTREG
expr_stmt|;
break|break;
case|case
name|NTO_REG_SYSTEM
case|:
default|default:
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|devctl
argument_list|(
name|ctl_fd
argument_list|,
name|dev_get
argument_list|,
operator|&
name|buf
argument_list|,
name|bufsize
argument_list|,
name|regsize
argument_list|)
operator|!=
name|EOK
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|dev_set
return|;
block|}
end_function

begin_function
name|void
name|procfs_store_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
union|union
block|{
name|procfs_greg
name|greg
decl_stmt|;
name|procfs_fpreg
name|fpreg
decl_stmt|;
name|procfs_altreg
name|altreg
decl_stmt|;
block|}
name|reg
union|;
name|unsigned
name|off
decl_stmt|;
name|int
name|len
decl_stmt|,
name|regset
decl_stmt|,
name|regsize
decl_stmt|,
name|dev_set
decl_stmt|,
name|err
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
if|if
condition|(
name|ptid_equal
argument_list|(
name|inferior_ptid
argument_list|,
name|null_ptid
argument_list|)
condition|)
return|return;
name|procfs_set_thread
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|regset
operator|=
name|NTO_REG_GENERAL
init|;
name|regset
operator|<
name|NTO_REG_END
condition|;
name|regset
operator|++
control|)
block|{
name|dev_set
operator|=
name|get_regset
argument_list|(
name|regset
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|reg
argument_list|,
sizeof|sizeof
argument_list|(
name|reg
argument_list|)
argument_list|,
operator|&
name|regsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_set
operator|==
operator|-
literal|1
condition|)
continue|continue;
if|if
condition|(
name|nto_regset_fill
argument_list|(
name|regset
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|reg
argument_list|)
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|err
operator|=
name|devctl
argument_list|(
name|ctl_fd
argument_list|,
name|dev_set
argument_list|,
operator|&
name|reg
argument_list|,
name|regsize
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|EOK
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Warning unable to write regset %d: %s\n"
argument_list|,
name|regno
argument_list|,
name|safe_strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|regset
operator|=
name|nto_regset_id
argument_list|(
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|regset
operator|==
operator|-
literal|1
condition|)
return|return;
name|dev_set
operator|=
name|get_regset
argument_list|(
name|regset
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|reg
argument_list|,
sizeof|sizeof
argument_list|(
name|reg
argument_list|)
argument_list|,
operator|&
name|regsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_set
operator|==
operator|-
literal|1
condition|)
return|return;
name|len
operator|=
name|nto_register_area
argument_list|(
name|regno
argument_list|,
name|regset
argument_list|,
operator|&
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|1
condition|)
return|return;
name|regcache_collect
argument_list|(
name|regno
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|reg
operator|+
name|off
argument_list|)
expr_stmt|;
name|err
operator|=
name|devctl
argument_list|(
name|ctl_fd
argument_list|,
name|dev_set
argument_list|,
operator|&
name|reg
argument_list|,
name|regsize
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|EOK
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Warning unable to write regset %d: %s\n"
argument_list|,
name|regno
argument_list|,
name|safe_strerror
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|notice_signals
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|signo
decl_stmt|;
for|for
control|(
name|signo
operator|=
literal|1
init|;
name|signo
operator|<
name|NSIG
condition|;
name|signo
operator|++
control|)
block|{
if|if
condition|(
name|signal_stop_state
argument_list|(
name|target_signal_from_host
argument_list|(
name|signo
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|signal_print_state
argument_list|(
name|target_signal_from_host
argument_list|(
name|signo
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|signal_pass_state
argument_list|(
name|target_signal_from_host
argument_list|(
name|signo
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
name|sigdelset
argument_list|(
operator|&
name|run
operator|.
name|trace
argument_list|,
name|signo
argument_list|)
expr_stmt|;
else|else
name|sigaddset
argument_list|(
operator|&
name|run
operator|.
name|trace
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* When the user changes the state of gdb's signal handling via the    "handle" command, this function gets called to see if any change    in the /proc interface is required.  It is also called internally    by other /proc interface functions to initialize the state of    the traced signal set.  */
end_comment

begin_function
specifier|static
name|void
name|procfs_notice_signals
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
name|sigemptyset
argument_list|(
operator|&
name|run
operator|.
name|trace
argument_list|)
expr_stmt|;
name|notice_signals
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|tidinfo
modifier|*
name|procfs_thread_info
parameter_list|(
name|pid_t
name|pid
parameter_list|,
name|short
name|tid
parameter_list|)
block|{
comment|/* NYI */
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|procfs_pid_to_str
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|pid
decl_stmt|,
name|tid
decl_stmt|,
name|n
decl_stmt|;
name|struct
name|tidinfo
modifier|*
name|tip
decl_stmt|;
name|pid
operator|=
name|ptid_get_pid
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
name|tid
operator|=
name|ptid_get_tid
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
name|n
operator|=
name|snprintf
argument_list|(
name|buf
argument_list|,
literal|1023
argument_list|,
literal|"process %d"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* NYI */
block|tip = procfs_thread_info (pid, tid);   if (tip != NULL)     snprintf (&buf[n], 1023, " (state = 0x%02x)", tip->state);
endif|#
directive|endif
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_procfs_ops
parameter_list|(
name|void
parameter_list|)
block|{
name|procfs_ops
operator|.
name|to_shortname
operator|=
literal|"procfs"
expr_stmt|;
name|procfs_ops
operator|.
name|to_longname
operator|=
literal|"QNX Neutrino procfs child process"
expr_stmt|;
name|procfs_ops
operator|.
name|to_doc
operator|=
literal|"QNX Neutrino procfs child process (started by the \"run\" command).\n\ 	target procfs<node>"
expr_stmt|;
name|procfs_ops
operator|.
name|to_open
operator|=
name|procfs_open
expr_stmt|;
name|procfs_ops
operator|.
name|to_attach
operator|=
name|procfs_attach
expr_stmt|;
name|procfs_ops
operator|.
name|to_post_attach
operator|=
name|procfs_post_attach
expr_stmt|;
name|procfs_ops
operator|.
name|to_detach
operator|=
name|procfs_detach
expr_stmt|;
name|procfs_ops
operator|.
name|to_resume
operator|=
name|procfs_resume
expr_stmt|;
name|procfs_ops
operator|.
name|to_wait
operator|=
name|procfs_wait
expr_stmt|;
name|procfs_ops
operator|.
name|to_fetch_registers
operator|=
name|procfs_fetch_registers
expr_stmt|;
name|procfs_ops
operator|.
name|to_store_registers
operator|=
name|procfs_store_registers
expr_stmt|;
name|procfs_ops
operator|.
name|to_prepare_to_store
operator|=
name|procfs_prepare_to_store
expr_stmt|;
name|procfs_ops
operator|.
name|to_xfer_memory
operator|=
name|procfs_xfer_memory
expr_stmt|;
name|procfs_ops
operator|.
name|to_files_info
operator|=
name|procfs_files_info
expr_stmt|;
name|procfs_ops
operator|.
name|to_insert_breakpoint
operator|=
name|procfs_insert_breakpoint
expr_stmt|;
name|procfs_ops
operator|.
name|to_remove_breakpoint
operator|=
name|procfs_remove_breakpoint
expr_stmt|;
name|procfs_ops
operator|.
name|to_can_use_hw_breakpoint
operator|=
name|procfs_can_use_hw_breakpoint
expr_stmt|;
name|procfs_ops
operator|.
name|to_insert_hw_breakpoint
operator|=
name|procfs_insert_hw_breakpoint
expr_stmt|;
name|procfs_ops
operator|.
name|to_remove_hw_breakpoint
operator|=
name|procfs_remove_breakpoint
expr_stmt|;
name|procfs_ops
operator|.
name|to_insert_watchpoint
operator|=
name|procfs_insert_hw_watchpoint
expr_stmt|;
name|procfs_ops
operator|.
name|to_remove_watchpoint
operator|=
name|procfs_remove_hw_watchpoint
expr_stmt|;
name|procfs_ops
operator|.
name|to_stopped_by_watchpoint
operator|=
name|procfs_stopped_by_watchpoint
expr_stmt|;
name|procfs_ops
operator|.
name|to_terminal_init
operator|=
name|terminal_init_inferior
expr_stmt|;
name|procfs_ops
operator|.
name|to_terminal_inferior
operator|=
name|terminal_inferior
expr_stmt|;
name|procfs_ops
operator|.
name|to_terminal_ours_for_output
operator|=
name|terminal_ours_for_output
expr_stmt|;
name|procfs_ops
operator|.
name|to_terminal_ours
operator|=
name|terminal_ours
expr_stmt|;
name|procfs_ops
operator|.
name|to_terminal_info
operator|=
name|child_terminal_info
expr_stmt|;
name|procfs_ops
operator|.
name|to_kill
operator|=
name|procfs_kill_inferior
expr_stmt|;
name|procfs_ops
operator|.
name|to_create_inferior
operator|=
name|procfs_create_inferior
expr_stmt|;
name|procfs_ops
operator|.
name|to_mourn_inferior
operator|=
name|procfs_mourn_inferior
expr_stmt|;
name|procfs_ops
operator|.
name|to_can_run
operator|=
name|procfs_can_run
expr_stmt|;
name|procfs_ops
operator|.
name|to_notice_signals
operator|=
name|procfs_notice_signals
expr_stmt|;
name|procfs_ops
operator|.
name|to_thread_alive
operator|=
name|procfs_thread_alive
expr_stmt|;
name|procfs_ops
operator|.
name|to_find_new_threads
operator|=
name|procfs_find_new_threads
expr_stmt|;
name|procfs_ops
operator|.
name|to_pid_to_str
operator|=
name|procfs_pid_to_str
expr_stmt|;
name|procfs_ops
operator|.
name|to_stop
operator|=
name|procfs_stop
expr_stmt|;
name|procfs_ops
operator|.
name|to_stratum
operator|=
name|process_stratum
expr_stmt|;
name|procfs_ops
operator|.
name|to_has_all_memory
operator|=
literal|1
expr_stmt|;
name|procfs_ops
operator|.
name|to_has_memory
operator|=
literal|1
expr_stmt|;
name|procfs_ops
operator|.
name|to_has_stack
operator|=
literal|1
expr_stmt|;
name|procfs_ops
operator|.
name|to_has_registers
operator|=
literal|1
expr_stmt|;
name|procfs_ops
operator|.
name|to_has_execution
operator|=
literal|1
expr_stmt|;
name|procfs_ops
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
name|procfs_ops
operator|.
name|to_have_continuable_watchpoint
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|OSTYPE_NTO
value|1
end_define

begin_function
name|void
name|_initialize_procfs
parameter_list|(
name|void
parameter_list|)
block|{
name|sigset_t
name|set
decl_stmt|;
name|init_procfs_ops
argument_list|()
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|procfs_ops
argument_list|)
expr_stmt|;
comment|/* We use SIGUSR1 to gain control after we block waiting for a process.      We use sigwaitevent to wait.  */
name|sigemptyset
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|set
argument_list|,
name|SIGUSR1
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|set
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Set up trace and fault sets, as gdb expects them.  */
name|sigemptyset
argument_list|(
operator|&
name|run
operator|.
name|trace
argument_list|)
expr_stmt|;
name|notice_signals
argument_list|()
expr_stmt|;
comment|/* Stuff some information.  */
name|nto_cpuinfo_flags
operator|=
name|SYSPAGE_ENTRY
argument_list|(
name|cpuinfo
argument_list|)
operator|->
name|flags
expr_stmt|;
name|nto_cpuinfo_valid
operator|=
literal|1
expr_stmt|;
name|add_info
argument_list|(
literal|"pidlist"
argument_list|,
name|procfs_pidlist
argument_list|,
literal|"pidlist"
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"meminfo"
argument_list|,
name|procfs_meminfo
argument_list|,
literal|"memory information"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|procfs_hw_watchpoint
parameter_list|(
name|int
name|addr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|procfs_break
name|brk
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|1
case|:
comment|/* Read.  */
name|brk
operator|.
name|type
operator|=
name|_DEBUG_BREAK_RD
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Read/Write.  */
name|brk
operator|.
name|type
operator|=
name|_DEBUG_BREAK_RW
expr_stmt|;
break|break;
default|default:
comment|/* Modify.  */
comment|/* FIXME: brk.type = _DEBUG_BREAK_RWM gives EINVAL for some reason.  */
name|brk
operator|.
name|type
operator|=
name|_DEBUG_BREAK_RW
expr_stmt|;
block|}
name|brk
operator|.
name|type
operator||=
name|_DEBUG_BREAK_HW
expr_stmt|;
comment|/* Always ask for HW.  */
name|brk
operator|.
name|addr
operator|=
name|addr
expr_stmt|;
name|brk
operator|.
name|size
operator|=
name|len
expr_stmt|;
name|errno
operator|=
name|devctl
argument_list|(
name|ctl_fd
argument_list|,
name|DCMD_PROC_BREAK
argument_list|,
operator|&
name|brk
argument_list|,
sizeof|sizeof
argument_list|(
name|brk
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
name|EOK
condition|)
block|{
name|perror
argument_list|(
literal|"Failed to set hardware watchpoint"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|procfs_can_use_hw_breakpoint
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|cnt
parameter_list|,
name|int
name|othertype
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|procfs_remove_hw_watchpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|type
parameter_list|)
block|{
return|return
name|procfs_hw_watchpoint
argument_list|(
name|addr
argument_list|,
operator|-
literal|1
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|procfs_insert_hw_watchpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|type
parameter_list|)
block|{
return|return
name|procfs_hw_watchpoint
argument_list|(
name|addr
argument_list|,
name|len
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|procfs_stopped_by_watchpoint
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

end_unit

