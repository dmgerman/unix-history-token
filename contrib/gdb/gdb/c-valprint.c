begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Support for printing C values for GDB, the GNU debugger.    Copyright 1986, 1988, 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997              Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"valprint.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"c-lang.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Print data of type TYPE located at VALADDR (within GDB), which came from    the inferior at address ADDRESS, onto stdio stream STREAM according to    FORMAT (a letter or 0 for natural format).  The data at VALADDR is in    target byte order.     If the data are a string pointer, returns the number of string characters    printed.     If DEREF_REF is nonzero, then dereference references, otherwise just print    them like pointers.     The PRETTY parameter controls prettyprinting.  */
end_comment

begin_function
name|int
name|c_val_print
parameter_list|(
name|type
parameter_list|,
name|valaddr
parameter_list|,
name|embedded_offset
parameter_list|,
name|address
parameter_list|,
name|stream
parameter_list|,
name|format
parameter_list|,
name|deref_ref
parameter_list|,
name|recurse
parameter_list|,
name|pretty
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|valaddr
decl_stmt|;
name|int
name|embedded_offset
decl_stmt|;
name|CORE_ADDR
name|address
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|format
decl_stmt|;
name|int
name|deref_ref
decl_stmt|;
name|int
name|recurse
decl_stmt|;
name|enum
name|val_prettyprint
name|pretty
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* Number of characters printed */
name|unsigned
name|len
decl_stmt|;
name|struct
name|type
modifier|*
name|elttype
decl_stmt|;
name|unsigned
name|eltlen
decl_stmt|;
name|LONGEST
name|val
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_ARRAY
case|:
name|elttype
operator|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|>
literal|0
operator|&&
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
block|{
name|eltlen
operator|=
name|TYPE_LENGTH
argument_list|(
name|elttype
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|/
name|eltlen
expr_stmt|;
if|if
condition|(
name|prettyprint_arrays
condition|)
block|{
name|print_spaces_filtered
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
comment|/* For an array of chars, print with string syntax.  */
if|if
condition|(
name|eltlen
operator|==
literal|1
operator|&&
operator|(
operator|(
name|TYPE_CODE
argument_list|(
name|elttype
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|)
operator|||
operator|(
operator|(
name|current_language
operator|->
name|la_language
operator|==
name|language_m2
operator|)
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|elttype
argument_list|)
operator|==
name|TYPE_CODE_CHAR
operator|)
operator|)
operator|)
operator|&&
operator|(
name|format
operator|==
literal|0
operator|||
name|format
operator|==
literal|'s'
operator|)
condition|)
block|{
comment|/* If requested, look for the first null char and only print 		 elements up to it.  */
if|if
condition|(
name|stop_print_at_null
condition|)
block|{
name|int
name|temp_len
decl_stmt|;
comment|/* Look for a NULL char. */
for|for
control|(
name|temp_len
operator|=
literal|0
init|;
operator|(
name|valaddr
operator|+
name|embedded_offset
operator|)
index|[
name|temp_len
index|]
operator|&&
name|temp_len
operator|<
name|len
operator|&&
name|temp_len
operator|<
name|print_max
condition|;
name|temp_len
operator|++
control|)
empty_stmt|;
name|len
operator|=
name|temp_len
expr_stmt|;
block|}
name|LA_PRINT_STRING
argument_list|(
name|stream
argument_list|,
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|len
argument_list|,
name|eltlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i
operator|=
name|len
expr_stmt|;
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
comment|/* If this is a virtual function table, print the 0th 		 entry specially, and the rest of the members normally.  */
if|if
condition|(
name|cp_is_vtbl_ptr_type
argument_list|(
name|elttype
argument_list|)
condition|)
block|{
name|i
operator|=
literal|1
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%d vtable entries"
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
literal|0
expr_stmt|;
block|}
name|val_print_array_elements
argument_list|(
name|type
argument_list|,
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|address
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* Array of unspecified length: treat like pointer to first elt.  */
name|addr
operator|=
name|address
expr_stmt|;
goto|goto
name|print_unpacked_pointer
goto|;
case|case
name|TYPE_CODE_PTR
case|:
if|if
condition|(
name|format
operator|&&
name|format
operator|!=
literal|'s'
condition|)
block|{
name|print_scalar_formatted
argument_list|(
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|vtblprint
operator|&&
name|cp_is_vtbl_ptr_type
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Print the unmangled name if desired.  */
comment|/* Print vtable entry - we only get here if we ARE using 	     -fvtable_thunks.  (Otherwise, look under TYPE_CODE_STRUCT.) */
name|print_address_demangle
argument_list|(
name|extract_address
argument_list|(
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|stream
argument_list|,
name|demangle
argument_list|)
expr_stmt|;
break|break;
block|}
name|elttype
operator|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|elttype
argument_list|)
operator|==
name|TYPE_CODE_METHOD
condition|)
block|{
name|cp_print_class_method
argument_list|(
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|type
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|elttype
argument_list|)
operator|==
name|TYPE_CODE_MEMBER
condition|)
block|{
name|cp_print_class_member
argument_list|(
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|TYPE_DOMAIN_TYPE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addr
operator|=
name|unpack_pointer
argument_list|(
name|type
argument_list|,
name|valaddr
operator|+
name|embedded_offset
argument_list|)
expr_stmt|;
name|print_unpacked_pointer
label|:
name|elttype
operator|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|elttype
argument_list|)
operator|==
name|TYPE_CODE_FUNC
condition|)
block|{
comment|/* Try to print what function it points to.  */
name|print_address_demangle
argument_list|(
name|addr
argument_list|,
name|stream
argument_list|,
name|demangle
argument_list|)
expr_stmt|;
comment|/* Return value is irrelevant except for string pointers.  */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|addressprint
operator|&&
name|format
operator|!=
literal|'s'
condition|)
block|{
name|print_address_numeric
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
comment|/* For a pointer to char or unsigned char, also print the string 	     pointed to, unless pointer is null.  */
comment|/* FIXME: need to handle wchar_t here... */
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|elttype
argument_list|)
operator|==
literal|1
operator|&&
name|TYPE_CODE
argument_list|(
name|elttype
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|&&
operator|(
name|format
operator|==
literal|0
operator|||
name|format
operator|==
literal|'s'
operator|)
operator|&&
name|addr
operator|!=
literal|0
condition|)
block|{
name|i
operator|=
name|val_print_string
argument_list|(
name|addr
argument_list|,
operator|-
literal|1
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|elttype
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp_is_vtbl_member
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* print vtbl's nicely */
name|CORE_ADDR
name|vt_address
init|=
name|unpack_pointer
argument_list|(
name|type
argument_list|,
name|valaddr
operator|+
name|embedded_offset
argument_list|)
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
init|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|vt_address
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|msymbol
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|vt_address
operator|==
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
operator|)
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"<"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|SYMBOL_SOURCE_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|">"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vt_address
operator|&&
name|vtblprint
condition|)
block|{
name|value_ptr
name|vt_val
decl_stmt|;
name|struct
name|symbol
modifier|*
name|wsym
init|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|NULL
decl_stmt|;
name|struct
name|type
modifier|*
name|wtype
decl_stmt|;
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|struct
name|block
modifier|*
name|block
init|=
operator|(
expr|struct
name|block
operator|*
operator|)
name|NULL
decl_stmt|;
name|int
name|is_this_fld
decl_stmt|;
if|if
condition|(
name|msymbol
operator|!=
name|NULL
condition|)
name|wsym
operator|=
name|lookup_symbol
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|,
name|block
argument_list|,
name|VAR_NAMESPACE
argument_list|,
operator|&
name|is_this_fld
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|wsym
condition|)
block|{
name|wtype
operator|=
name|SYMBOL_TYPE
argument_list|(
name|wsym
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wtype
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|vt_val
operator|=
name|value_at
argument_list|(
name|wtype
argument_list|,
name|vt_address
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|val_print
argument_list|(
name|VALUE_TYPE
argument_list|(
name|vt_val
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|vt_val
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|vt_val
argument_list|)
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
if|if
condition|(
name|pretty
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Return number of characters printed, including the terminating 	     '\0' if we reached the end.  val_print_string takes care including 	     the terminating '\0' if necessary.  */
return|return
name|i
return|;
block|}
break|break;
case|case
name|TYPE_CODE_MEMBER
case|:
name|error
argument_list|(
literal|"not implemented: member type in c_val_print"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_REF
case|:
name|elttype
operator|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|elttype
argument_list|)
operator|==
name|TYPE_CODE_MEMBER
condition|)
block|{
name|cp_print_class_member
argument_list|(
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|TYPE_DOMAIN_TYPE
argument_list|(
name|elttype
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|addressprint
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"@"
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|extract_address
argument_list|(
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|TARGET_PTR_BIT
operator|/
name|HOST_CHAR_BIT
argument_list|)
argument_list|,
literal|1
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|deref_ref
condition|)
name|fputs_filtered
argument_list|(
literal|": "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
comment|/* De-reference the reference.  */
if|if
condition|(
name|deref_ref
condition|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|elttype
argument_list|)
operator|!=
name|TYPE_CODE_UNDEF
condition|)
block|{
name|value_ptr
name|deref_val
init|=
name|value_at
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|unpack_pointer
argument_list|(
name|lookup_pointer_type
argument_list|(
name|builtin_type_void
argument_list|)
argument_list|,
name|valaddr
operator|+
name|embedded_offset
argument_list|)
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|val_print
argument_list|(
name|VALUE_TYPE
argument_list|(
name|deref_val
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|deref_val
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|deref_val
argument_list|)
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
block|}
else|else
name|fputs_filtered
argument_list|(
literal|"???"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_UNION
case|:
if|if
condition|(
name|recurse
operator|&&
operator|!
name|unionprint
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{...}"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Fall through.  */
case|case
name|TYPE_CODE_STRUCT
case|:
if|if
condition|(
name|vtblprint
operator|&&
name|cp_is_vtbl_ptr_type
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Print the unmangled name if desired.  */
comment|/* Print vtable entry - we only get here if NOT using 	     -fvtable_thunks.  (Otherwise, look under TYPE_CODE_PTR.) */
name|print_address_demangle
argument_list|(
name|extract_address
argument_list|(
name|valaddr
operator|+
name|embedded_offset
operator|+
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|VTBL_FNADDR_OFFSET
argument_list|)
operator|/
literal|8
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|VTBL_FNADDR_OFFSET
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|stream
argument_list|,
name|demangle
argument_list|)
expr_stmt|;
block|}
else|else
name|cp_print_value_fields
argument_list|(
name|type
argument_list|,
name|type
argument_list|,
name|valaddr
argument_list|,
name|embedded_offset
argument_list|,
name|address
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_ENUM
case|:
if|if
condition|(
name|format
condition|)
block|{
name|print_scalar_formatted
argument_list|(
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
block|}
name|len
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|val
operator|=
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
operator|+
name|embedded_offset
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|<
name|len
condition|)
block|{
name|fputs_filtered
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|print_longest
argument_list|(
name|stream
argument_list|,
literal|'d'
argument_list|,
literal|0
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_FUNC
case|:
if|if
condition|(
name|format
condition|)
block|{
name|print_scalar_formatted
argument_list|(
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FIXME, we should consider, at least for ANSI C language, eliminating 	 the distinction made between FUNCs and POINTERs to FUNCs.  */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"} "
argument_list|)
expr_stmt|;
comment|/* Try to print what function it points to, and its address.  */
name|print_address_demangle
argument_list|(
name|address
argument_list|,
name|stream
argument_list|,
name|demangle
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_BOOL
case|:
name|format
operator|=
name|format
condition|?
name|format
else|:
name|output_format
expr_stmt|;
if|if
condition|(
name|format
condition|)
name|print_scalar_formatted
argument_list|(
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
block|{
name|val
operator|=
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
operator|+
name|embedded_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|fputs_filtered
argument_list|(
literal|"false"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|==
literal|1
condition|)
name|fputs_filtered
argument_list|(
literal|"true"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|print_longest
argument_list|(
name|stream
argument_list|,
literal|'d'
argument_list|,
literal|0
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_RANGE
case|:
comment|/* FIXME: create_range_type does not set the unsigned bit in a 	 range type (I think it probably should copy it from the target 	 type), so we won't print values which are too large to 	 fit in a signed integer correctly.  */
comment|/* FIXME: Doesn't handle ranges of enums correctly.  (Can't just 	 print with the target type, though, because the size of our type 	 and the target type might differ).  */
comment|/* FALLTHROUGH */
case|case
name|TYPE_CODE_INT
case|:
name|format
operator|=
name|format
condition|?
name|format
else|:
name|output_format
expr_stmt|;
if|if
condition|(
name|format
condition|)
block|{
name|print_scalar_formatted
argument_list|(
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val_print_type_code_int
argument_list|(
name|type
argument_list|,
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* C and C++ has no single byte int type, char is used instead. 	     Since we don't know whether the value is really intended to 	     be used as an integer or a character, print the character 	     equivalent as well. */
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|==
literal|1
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|LA_PRINT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
operator|+
name|embedded_offset
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TYPE_CODE_CHAR
case|:
name|format
operator|=
name|format
condition|?
name|format
else|:
name|output_format
expr_stmt|;
if|if
condition|(
name|format
condition|)
block|{
name|print_scalar_formatted
argument_list|(
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
literal|"%u"
else|:
literal|"%d"
argument_list|,
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
operator|+
name|embedded_offset
argument_list|)
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|LA_PRINT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
operator|+
name|embedded_offset
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_FLT
case|:
if|if
condition|(
name|format
condition|)
block|{
name|print_scalar_formatted
argument_list|(
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|print_floating
argument_list|(
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|type
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_METHOD
case|:
name|cp_print_class_method
argument_list|(
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|lookup_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_VOID
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"void"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_ERROR
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<error type>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_UNDEF
case|:
comment|/* This happens (without TYPE_FLAG_STUB set) on systems which don't use 	 dbx xrefs (NO_DBX_XREFS in gcc) if a file has a "struct foo *bar" 	 and no complete type for struct foo in that file.  */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<incomplete type>"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Invalid C/C++ type code %d in symbol table."
argument_list|,
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|gdb_flush
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|c_value_print
parameter_list|(
name|val
parameter_list|,
name|stream
parameter_list|,
name|format
parameter_list|,
name|pretty
parameter_list|)
name|value_ptr
name|val
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|format
decl_stmt|;
name|enum
name|val_prettyprint
name|pretty
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|real_type
decl_stmt|;
name|int
name|full
decl_stmt|,
name|top
decl_stmt|,
name|using_enc
decl_stmt|;
comment|/* If it is a pointer, indicate what it points to.       Print type also if it is a reference.       C++: if it is a member pointer, we will take care      of that when we print it.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_REF
condition|)
block|{
comment|/* Hack:  remove (char *) for char strings.  Their 	 type is indicated by the quoted string anyway. */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|&&
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|==
name|NULL
operator|&&
name|TYPE_NAME
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|NULL
operator|&&
name|STREQ
argument_list|(
name|TYPE_NAME
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
literal|"char"
argument_list|)
condition|)
block|{
comment|/* Print nothing */
block|}
elseif|else
if|if
condition|(
name|objectprint
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_CLASS
operator|)
condition|)
block|{
comment|/* Pointer to class, check real type of object */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|type
operator|=
name|value_rtti_target_type
argument_list|(
name|val
argument_list|,
operator|&
name|full
argument_list|,
operator|&
name|top
argument_list|,
operator|&
name|using_enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
condition|)
block|{
comment|/* RTTI entry found */
name|type
operator|=
name|lookup_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No RTTI fields, do whatever we can */
name|type
operator|=
name|VALUE_ENCLOSING_TYPE
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" ?"
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|") "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* normal case */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|") "
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|objectprint
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_CLASS
operator|)
condition|)
block|{
comment|/* Attempt to determine real type of object */
name|real_type
operator|=
name|value_rtti_type
argument_list|(
name|val
argument_list|,
operator|&
name|full
argument_list|,
operator|&
name|top
argument_list|,
operator|&
name|using_enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_type
condition|)
block|{
comment|/* We have RTTI information, so use it */
name|val
operator|=
name|value_full_object
argument_list|(
name|val
argument_list|,
name|real_type
argument_list|,
name|full
argument_list|,
name|top
argument_list|,
name|using_enc
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"(%s%s) "
argument_list|,
name|TYPE_NAME
argument_list|(
name|real_type
argument_list|)
argument_list|,
name|full
condition|?
literal|""
else|:
literal|" [incomplete object]"
argument_list|)
expr_stmt|;
comment|/* Print out object: enclosing type is same as real_type if full */
return|return
name|val_print
argument_list|(
name|VALUE_ENCLOSING_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_CONTENTS_ALL
argument_list|(
name|val
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|pretty
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|!=
name|VALUE_ENCLOSING_TYPE
argument_list|(
name|val
argument_list|)
condition|)
block|{
comment|/* No RTTI information, so let's do our best */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"(%s ?) "
argument_list|,
name|TYPE_NAME
argument_list|(
name|VALUE_ENCLOSING_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val_print
argument_list|(
name|VALUE_ENCLOSING_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_CONTENTS_ALL
argument_list|(
name|val
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|pretty
argument_list|)
return|;
block|}
comment|/* Otherwise, we end up at the return outside this "if" */
block|}
return|return
name|val_print
argument_list|(
name|type
argument_list|,
name|VALUE_CONTENTS_ALL
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_EMBEDDED_OFFSET
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|pretty
argument_list|)
return|;
block|}
end_function

end_unit

