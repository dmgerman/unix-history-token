begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Support for printing C values for GDB, the GNU debugger.     Copyright 1986, 1988, 1989, 1991, 1992, 1993, 1994, 1995, 1996,    1997, 1998, 1999, 2000, 2001, 2003 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"valprint.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"c-lang.h"
end_include

begin_include
include|#
directive|include
file|"cp-abi.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Print function pointer with inferior address ADDRESS onto stdio    stream STREAM.  */
end_comment

begin_function
specifier|static
name|void
name|print_function_pointer_address
parameter_list|(
name|CORE_ADDR
name|address
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|CORE_ADDR
name|func_addr
init|=
name|gdbarch_convert_from_func_ptr_addr
argument_list|(
name|current_gdbarch
argument_list|,
name|address
argument_list|,
operator|&
name|current_target
argument_list|)
decl_stmt|;
comment|/* If the function pointer is represented by a description, print the      address of the description.  */
if|if
condition|(
name|addressprint
operator|&&
name|func_addr
operator|!=
name|address
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"@"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|address
argument_list|,
literal|1
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|": "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|print_address_demangle
argument_list|(
name|func_addr
argument_list|,
name|stream
argument_list|,
name|demangle
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print data of type TYPE located at VALADDR (within GDB), which came from    the inferior at address ADDRESS, onto stdio stream STREAM according to    FORMAT (a letter or 0 for natural format).  The data at VALADDR is in    target byte order.     If the data are a string pointer, returns the number of string characters    printed.     If DEREF_REF is nonzero, then dereference references, otherwise just print    them like pointers.     The PRETTY parameter controls prettyprinting.  */
end_comment

begin_function
name|int
name|c_val_print
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|valaddr
parameter_list|,
name|int
name|embedded_offset
parameter_list|,
name|CORE_ADDR
name|address
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|format
parameter_list|,
name|int
name|deref_ref
parameter_list|,
name|int
name|recurse
parameter_list|,
name|enum
name|val_prettyprint
name|pretty
parameter_list|)
block|{
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
comment|/* Number of characters printed */
name|unsigned
name|len
decl_stmt|;
name|struct
name|type
modifier|*
name|elttype
decl_stmt|;
name|unsigned
name|eltlen
decl_stmt|;
name|LONGEST
name|val
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_ARRAY
case|:
name|elttype
operator|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|>
literal|0
operator|&&
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
block|{
name|eltlen
operator|=
name|TYPE_LENGTH
argument_list|(
name|elttype
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|/
name|eltlen
expr_stmt|;
if|if
condition|(
name|prettyprint_arrays
condition|)
block|{
name|print_spaces_filtered
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
comment|/* For an array of chars, print with string syntax.  */
if|if
condition|(
name|eltlen
operator|==
literal|1
operator|&&
operator|(
operator|(
name|TYPE_CODE
argument_list|(
name|elttype
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|)
operator|||
operator|(
operator|(
name|current_language
operator|->
name|la_language
operator|==
name|language_m2
operator|)
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|elttype
argument_list|)
operator|==
name|TYPE_CODE_CHAR
operator|)
operator|)
operator|)
operator|&&
operator|(
name|format
operator|==
literal|0
operator|||
name|format
operator|==
literal|'s'
operator|)
condition|)
block|{
comment|/* If requested, look for the first null char and only print 	         elements up to it.  */
if|if
condition|(
name|stop_print_at_null
condition|)
block|{
name|unsigned
name|int
name|temp_len
decl_stmt|;
comment|/* Look for a NULL char. */
for|for
control|(
name|temp_len
operator|=
literal|0
init|;
operator|(
name|valaddr
operator|+
name|embedded_offset
operator|)
index|[
name|temp_len
index|]
operator|&&
name|temp_len
operator|<
name|len
operator|&&
name|temp_len
operator|<
name|print_max
condition|;
name|temp_len
operator|++
control|)
empty_stmt|;
name|len
operator|=
name|temp_len
expr_stmt|;
block|}
name|LA_PRINT_STRING
argument_list|(
name|stream
argument_list|,
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|len
argument_list|,
name|eltlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i
operator|=
name|len
expr_stmt|;
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
comment|/* If this is a virtual function table, print the 0th 	         entry specially, and the rest of the members normally.  */
if|if
condition|(
name|cp_is_vtbl_ptr_type
argument_list|(
name|elttype
argument_list|)
condition|)
block|{
name|i
operator|=
literal|1
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%d vtable entries"
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
literal|0
expr_stmt|;
block|}
name|val_print_array_elements
argument_list|(
name|type
argument_list|,
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|address
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* Array of unspecified length: treat like pointer to first elt.  */
name|addr
operator|=
name|address
expr_stmt|;
goto|goto
name|print_unpacked_pointer
goto|;
case|case
name|TYPE_CODE_PTR
case|:
if|if
condition|(
name|format
operator|&&
name|format
operator|!=
literal|'s'
condition|)
block|{
name|print_scalar_formatted
argument_list|(
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|vtblprint
operator|&&
name|cp_is_vtbl_ptr_type
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Print the unmangled name if desired.  */
comment|/* Print vtable entry - we only get here if we ARE using 	     -fvtable_thunks.  (Otherwise, look under TYPE_CODE_STRUCT.) */
name|CORE_ADDR
name|addr
init|=
name|extract_typed_address
argument_list|(
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|print_function_pointer_address
argument_list|(
name|addr
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
block|}
name|elttype
operator|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|elttype
argument_list|)
operator|==
name|TYPE_CODE_METHOD
condition|)
block|{
name|cp_print_class_method
argument_list|(
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|type
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|elttype
argument_list|)
operator|==
name|TYPE_CODE_MEMBER
condition|)
block|{
name|cp_print_class_member
argument_list|(
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|TYPE_DOMAIN_TYPE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addr
operator|=
name|unpack_pointer
argument_list|(
name|type
argument_list|,
name|valaddr
operator|+
name|embedded_offset
argument_list|)
expr_stmt|;
name|print_unpacked_pointer
label|:
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|elttype
argument_list|)
operator|==
name|TYPE_CODE_FUNC
condition|)
block|{
comment|/* Try to print what function it points to.  */
name|print_function_pointer_address
argument_list|(
name|addr
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* Return value is irrelevant except for string pointers.  */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|addressprint
operator|&&
name|format
operator|!=
literal|'s'
condition|)
block|{
name|print_address_numeric
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
comment|/* For a pointer to char or unsigned char, also print the string 	     pointed to, unless pointer is null.  */
comment|/* FIXME: need to handle wchar_t here... */
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|elttype
argument_list|)
operator|==
literal|1
operator|&&
name|TYPE_CODE
argument_list|(
name|elttype
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|&&
operator|(
name|format
operator|==
literal|0
operator|||
name|format
operator|==
literal|'s'
operator|)
operator|&&
name|addr
operator|!=
literal|0
condition|)
block|{
name|i
operator|=
name|val_print_string
argument_list|(
name|addr
argument_list|,
operator|-
literal|1
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|elttype
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp_is_vtbl_member
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* print vtbl's nicely */
name|CORE_ADDR
name|vt_address
init|=
name|unpack_pointer
argument_list|(
name|type
argument_list|,
name|valaddr
operator|+
name|embedded_offset
argument_list|)
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
init|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|vt_address
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|msymbol
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|vt_address
operator|==
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
operator|)
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"<"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|SYMBOL_PRINT_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|">"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vt_address
operator|&&
name|vtblprint
condition|)
block|{
name|struct
name|value
modifier|*
name|vt_val
decl_stmt|;
name|struct
name|symbol
modifier|*
name|wsym
init|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|NULL
decl_stmt|;
name|struct
name|type
modifier|*
name|wtype
decl_stmt|;
name|struct
name|block
modifier|*
name|block
init|=
operator|(
expr|struct
name|block
operator|*
operator|)
name|NULL
decl_stmt|;
name|int
name|is_this_fld
decl_stmt|;
if|if
condition|(
name|msymbol
operator|!=
name|NULL
condition|)
name|wsym
operator|=
name|lookup_symbol
argument_list|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|,
name|block
argument_list|,
name|VAR_DOMAIN
argument_list|,
operator|&
name|is_this_fld
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|wsym
condition|)
block|{
name|wtype
operator|=
name|SYMBOL_TYPE
argument_list|(
name|wsym
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wtype
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|vt_val
operator|=
name|value_at
argument_list|(
name|wtype
argument_list|,
name|vt_address
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|common_val_print
argument_list|(
name|vt_val
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
if|if
condition|(
name|pretty
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Return number of characters printed, including the terminating 	     '\0' if we reached the end.  val_print_string takes care including 	     the terminating '\0' if necessary.  */
return|return
name|i
return|;
block|}
break|break;
case|case
name|TYPE_CODE_MEMBER
case|:
name|error
argument_list|(
literal|"not implemented: member type in c_val_print"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_REF
case|:
name|elttype
operator|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|elttype
argument_list|)
operator|==
name|TYPE_CODE_MEMBER
condition|)
block|{
name|cp_print_class_member
argument_list|(
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|TYPE_DOMAIN_TYPE
argument_list|(
name|elttype
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|""
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|addressprint
condition|)
block|{
name|CORE_ADDR
name|addr
init|=
name|extract_typed_address
argument_list|(
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|type
argument_list|)
decl_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"@"
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|addr
argument_list|,
literal|1
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|deref_ref
condition|)
name|fputs_filtered
argument_list|(
literal|": "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
comment|/* De-reference the reference.  */
if|if
condition|(
name|deref_ref
condition|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|elttype
argument_list|)
operator|!=
name|TYPE_CODE_UNDEF
condition|)
block|{
name|struct
name|value
modifier|*
name|deref_val
init|=
name|value_at
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|unpack_pointer
argument_list|(
name|lookup_pointer_type
argument_list|(
name|builtin_type_void
argument_list|)
argument_list|,
name|valaddr
operator|+
name|embedded_offset
argument_list|)
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|common_val_print
argument_list|(
name|deref_val
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
block|}
else|else
name|fputs_filtered
argument_list|(
literal|"???"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_UNION
case|:
if|if
condition|(
name|recurse
operator|&&
operator|!
name|unionprint
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{...}"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Fall through.  */
case|case
name|TYPE_CODE_STRUCT
case|:
comment|/*FIXME: Abstract this away */
if|if
condition|(
name|vtblprint
operator|&&
name|cp_is_vtbl_ptr_type
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Print the unmangled name if desired.  */
comment|/* Print vtable entry - we only get here if NOT using 	     -fvtable_thunks.  (Otherwise, look under TYPE_CODE_PTR.) */
name|int
name|offset
init|=
operator|(
name|embedded_offset
operator|+
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|VTBL_FNADDR_OFFSET
argument_list|)
operator|/
literal|8
operator|)
decl_stmt|;
name|struct
name|type
modifier|*
name|field_type
init|=
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|VTBL_FNADDR_OFFSET
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|addr
init|=
name|extract_typed_address
argument_list|(
name|valaddr
operator|+
name|offset
argument_list|,
name|field_type
argument_list|)
decl_stmt|;
name|print_function_pointer_address
argument_list|(
name|addr
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
name|cp_print_value_fields
argument_list|(
name|type
argument_list|,
name|type
argument_list|,
name|valaddr
argument_list|,
name|embedded_offset
argument_list|,
name|address
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_ENUM
case|:
if|if
condition|(
name|format
condition|)
block|{
name|print_scalar_formatted
argument_list|(
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
block|}
name|len
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|val
operator|=
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
operator|+
name|embedded_offset
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|<
name|len
condition|)
block|{
name|fputs_filtered
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|print_longest
argument_list|(
name|stream
argument_list|,
literal|'d'
argument_list|,
literal|0
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_FUNC
case|:
if|if
condition|(
name|format
condition|)
block|{
name|print_scalar_formatted
argument_list|(
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FIXME, we should consider, at least for ANSI C language, eliminating          the distinction made between FUNCs and POINTERs to FUNCs.  */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"} "
argument_list|)
expr_stmt|;
comment|/* Try to print what function it points to, and its address.  */
name|print_address_demangle
argument_list|(
name|address
argument_list|,
name|stream
argument_list|,
name|demangle
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_BOOL
case|:
name|format
operator|=
name|format
condition|?
name|format
else|:
name|output_format
expr_stmt|;
if|if
condition|(
name|format
condition|)
name|print_scalar_formatted
argument_list|(
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
block|{
name|val
operator|=
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
operator|+
name|embedded_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|fputs_filtered
argument_list|(
literal|"false"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|==
literal|1
condition|)
name|fputs_filtered
argument_list|(
literal|"true"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|print_longest
argument_list|(
name|stream
argument_list|,
literal|'d'
argument_list|,
literal|0
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_RANGE
case|:
comment|/* FIXME: create_range_type does not set the unsigned bit in a          range type (I think it probably should copy it from the target          type), so we won't print values which are too large to          fit in a signed integer correctly.  */
comment|/* FIXME: Doesn't handle ranges of enums correctly.  (Can't just          print with the target type, though, because the size of our type          and the target type might differ).  */
comment|/* FALLTHROUGH */
case|case
name|TYPE_CODE_INT
case|:
name|format
operator|=
name|format
condition|?
name|format
else|:
name|output_format
expr_stmt|;
if|if
condition|(
name|format
condition|)
block|{
name|print_scalar_formatted
argument_list|(
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val_print_type_code_int
argument_list|(
name|type
argument_list|,
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* C and C++ has no single byte int type, char is used instead. 	     Since we don't know whether the value is really intended to 	     be used as an integer or a character, print the character 	     equivalent as well. */
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|==
literal|1
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|LA_PRINT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
operator|+
name|embedded_offset
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TYPE_CODE_CHAR
case|:
name|format
operator|=
name|format
condition|?
name|format
else|:
name|output_format
expr_stmt|;
if|if
condition|(
name|format
condition|)
block|{
name|print_scalar_formatted
argument_list|(
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
operator|+
name|embedded_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%u"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|val
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|val
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|LA_PRINT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|val
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_FLT
case|:
if|if
condition|(
name|format
condition|)
block|{
name|print_scalar_formatted
argument_list|(
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|print_floating
argument_list|(
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|type
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_METHOD
case|:
block|{
name|struct
name|value
modifier|*
name|v
init|=
name|value_at
argument_list|(
name|type
argument_list|,
name|address
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|cp_print_class_method
argument_list|(
name|VALUE_CONTENTS
argument_list|(
name|value_addr
argument_list|(
name|v
argument_list|)
argument_list|)
argument_list|,
name|lookup_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|TYPE_CODE_VOID
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"void"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_ERROR
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<error type>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_UNDEF
case|:
comment|/* This happens (without TYPE_FLAG_STUB set) on systems which don't use          dbx xrefs (NO_DBX_XREFS in gcc) if a file has a "struct foo *bar"          and no complete type for struct foo in that file.  */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<incomplete type>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_COMPLEX
case|:
if|if
condition|(
name|format
condition|)
name|print_scalar_formatted
argument_list|(
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|print_floating
argument_list|(
name|valaddr
operator|+
name|embedded_offset
argument_list|,
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" + "
argument_list|)
expr_stmt|;
if|if
condition|(
name|format
condition|)
name|print_scalar_formatted
argument_list|(
name|valaddr
operator|+
name|embedded_offset
operator|+
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|print_floating
argument_list|(
name|valaddr
operator|+
name|embedded_offset
operator|+
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" * I"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Invalid C/C++ type code %d in symbol table."
argument_list|,
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|gdb_flush
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|c_value_print
parameter_list|(
name|struct
name|value
modifier|*
name|val
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|format
parameter_list|,
name|enum
name|val_prettyprint
name|pretty
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|real_type
decl_stmt|;
name|int
name|full
decl_stmt|,
name|top
decl_stmt|,
name|using_enc
decl_stmt|;
comment|/* If it is a pointer, indicate what it points to.       Print type also if it is a reference.       C++: if it is a member pointer, we will take care      of that when we print it.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_REF
condition|)
block|{
comment|/* Hack:  remove (char *) for char strings.  Their          type is indicated by the quoted string anyway. */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|&&
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|==
name|NULL
operator|&&
name|TYPE_NAME
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|TYPE_NAME
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
literal|"char"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Print nothing */
block|}
elseif|else
if|if
condition|(
name|objectprint
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_CLASS
operator|)
condition|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_REF
condition|)
block|{
comment|/* Copy value, change to pointer, so we don't get an 	       * error about a non-pointer type in value_rtti_target_type 	       */
name|struct
name|value
modifier|*
name|temparg
decl_stmt|;
name|temparg
operator|=
name|value_copy
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|VALUE_TYPE
argument_list|(
name|temparg
argument_list|)
operator|=
name|lookup_pointer_type
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|temparg
expr_stmt|;
block|}
comment|/* Pointer to class, check real type of object */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|real_type
operator|=
name|value_rtti_target_type
argument_list|(
name|val
argument_list|,
operator|&
name|full
argument_list|,
operator|&
name|top
argument_list|,
operator|&
name|using_enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_type
condition|)
block|{
comment|/* RTTI entry found */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
block|{
comment|/* create a pointer type pointing to the real type */
name|type
operator|=
name|lookup_pointer_type
argument_list|(
name|real_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* create a reference type referencing the real type */
name|type
operator|=
name|lookup_reference_type
argument_list|(
name|real_type
argument_list|)
expr_stmt|;
block|}
comment|/* JYG: Need to adjust pointer value. */
name|val
operator|->
name|aligner
operator|.
name|contents
index|[
literal|0
index|]
operator|-=
name|top
expr_stmt|;
comment|/* Note: When we look up RTTI entries, we don't get any                   information on const or volatile attributes */
block|}
name|type_print
argument_list|(
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|") "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* normal case */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|") "
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|value_initialized
argument_list|(
name|val
argument_list|)
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" [uninitialized] "
argument_list|)
expr_stmt|;
if|if
condition|(
name|objectprint
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_CLASS
operator|)
condition|)
block|{
comment|/* Attempt to determine real type of object */
name|real_type
operator|=
name|value_rtti_type
argument_list|(
name|val
argument_list|,
operator|&
name|full
argument_list|,
operator|&
name|top
argument_list|,
operator|&
name|using_enc
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_type
condition|)
block|{
comment|/* We have RTTI information, so use it */
name|val
operator|=
name|value_full_object
argument_list|(
name|val
argument_list|,
name|real_type
argument_list|,
name|full
argument_list|,
name|top
argument_list|,
name|using_enc
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"(%s%s) "
argument_list|,
name|TYPE_NAME
argument_list|(
name|real_type
argument_list|)
argument_list|,
name|full
condition|?
literal|""
else|:
literal|" [incomplete object]"
argument_list|)
expr_stmt|;
comment|/* Print out object: enclosing type is same as real_type if full */
return|return
name|val_print
argument_list|(
name|VALUE_ENCLOSING_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_CONTENTS_ALL
argument_list|(
name|val
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|pretty
argument_list|)
return|;
comment|/* Note: When we look up RTTI entries, we don't get any information on              const or volatile attributes */
block|}
elseif|else
if|if
condition|(
name|type
operator|!=
name|VALUE_ENCLOSING_TYPE
argument_list|(
name|val
argument_list|)
condition|)
block|{
comment|/* No RTTI information, so let's do our best */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"(%s ?) "
argument_list|,
name|TYPE_NAME
argument_list|(
name|VALUE_ENCLOSING_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val_print
argument_list|(
name|VALUE_ENCLOSING_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_CONTENTS_ALL
argument_list|(
name|val
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|pretty
argument_list|)
return|;
block|}
comment|/* Otherwise, we end up at the return outside this "if" */
block|}
return|return
name|val_print
argument_list|(
name|type
argument_list|,
name|VALUE_CONTENTS_ALL
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_EMBEDDED_OFFSET
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|val
argument_list|)
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|pretty
argument_list|)
return|;
block|}
end_function

end_unit

