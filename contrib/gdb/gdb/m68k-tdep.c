begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target dependent code for the Motorola 68000 series.    Copyright (C) 1990, 1992 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Push an empty stack frame, to record the current PC, etc.  */
end_comment

begin_function
name|void
name|m68k_push_dummy_frame
parameter_list|()
block|{
specifier|register
name|CORE_ADDR
name|sp
init|=
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
decl_stmt|;
specifier|register
name|int
name|regnum
decl_stmt|;
name|char
name|raw_buffer
index|[
literal|12
index|]
decl_stmt|;
name|sp
operator|=
name|push_word
argument_list|(
name|sp
argument_list|,
name|read_register
argument_list|(
name|PC_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|=
name|push_word
argument_list|(
name|sp
argument_list|,
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|FP_REGNUM
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/* Always save the floating-point registers, whether they exist on      this target or not.  */
for|for
control|(
name|regnum
operator|=
name|FP0_REGNUM
operator|+
literal|7
init|;
name|regnum
operator|>=
name|FP0_REGNUM
condition|;
name|regnum
operator|--
control|)
block|{
name|read_register_bytes
argument_list|(
name|REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
argument_list|,
name|raw_buffer
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|sp
operator|=
name|push_bytes
argument_list|(
name|sp
argument_list|,
name|raw_buffer
argument_list|,
literal|12
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|regnum
operator|=
name|FP_REGNUM
operator|-
literal|1
init|;
name|regnum
operator|>=
literal|0
condition|;
name|regnum
operator|--
control|)
block|{
name|sp
operator|=
name|push_word
argument_list|(
name|sp
argument_list|,
name|read_register
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sp
operator|=
name|push_word
argument_list|(
name|sp
argument_list|,
name|read_register
argument_list|(
name|PS_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Discard from the stack the innermost frame,    restoring all saved registers.  */
end_comment

begin_function
name|void
name|m68k_pop_frame
parameter_list|()
block|{
specifier|register
name|struct
name|frame_info
modifier|*
name|frame
init|=
name|get_current_frame
argument_list|()
decl_stmt|;
specifier|register
name|CORE_ADDR
name|fp
decl_stmt|;
specifier|register
name|int
name|regnum
decl_stmt|;
name|struct
name|frame_saved_regs
name|fsr
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|char
name|raw_buffer
index|[
literal|12
index|]
decl_stmt|;
name|fp
operator|=
name|FRAME_FP
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|get_frame_saved_regs
argument_list|(
name|frame
argument_list|,
operator|&
name|fsr
argument_list|)
expr_stmt|;
for|for
control|(
name|regnum
operator|=
name|FP0_REGNUM
operator|+
literal|7
init|;
name|regnum
operator|>=
name|FP0_REGNUM
condition|;
name|regnum
operator|--
control|)
block|{
if|if
condition|(
name|fsr
operator|.
name|regs
index|[
name|regnum
index|]
condition|)
block|{
name|read_memory
argument_list|(
name|fsr
operator|.
name|regs
index|[
name|regnum
index|]
argument_list|,
name|raw_buffer
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|write_register_bytes
argument_list|(
name|REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
argument_list|,
name|raw_buffer
argument_list|,
literal|12
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|regnum
operator|=
name|FP_REGNUM
operator|-
literal|1
init|;
name|regnum
operator|>=
literal|0
condition|;
name|regnum
operator|--
control|)
block|{
if|if
condition|(
name|fsr
operator|.
name|regs
index|[
name|regnum
index|]
condition|)
block|{
name|write_register
argument_list|(
name|regnum
argument_list|,
name|read_memory_integer
argument_list|(
name|fsr
operator|.
name|regs
index|[
name|regnum
index|]
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fsr
operator|.
name|regs
index|[
name|PS_REGNUM
index|]
condition|)
block|{
name|write_register
argument_list|(
name|PS_REGNUM
argument_list|,
name|read_memory_integer
argument_list|(
name|fsr
operator|.
name|regs
index|[
name|PS_REGNUM
index|]
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|write_register
argument_list|(
name|FP_REGNUM
argument_list|,
name|read_memory_integer
argument_list|(
name|fp
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|PC_REGNUM
argument_list|,
name|read_memory_integer
argument_list|(
name|fp
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|fp
operator|+
literal|8
argument_list|)
expr_stmt|;
name|flush_cached_frames
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an ip value corresponding to the start of a function,    return the ip of the first instruction after the function     prologue.  This is the generic m68k support.  Machines which    require something different can override the SKIP_PROLOGUE    macro to point elsewhere.     Some instructions which typically may appear in a function    prologue include:     A link instruction, word form:  	link.w	%a6,&0			4e56  XXXX     A link instruction, long form:  	link.l  %fp,&F%1		480e  XXXX  XXXX     A movm instruction to preserve integer regs:  	movm.l&M%1,(4,%sp)		48ef  XXXX  XXXX     A fmovm instruction to preserve float regs:  	fmovm&FPM%1,(FPO%1,%sp)	f237  XXXX  XXXX  XXXX  XXXX     Some profiling setup code (FIXME, not recognized yet):  	lea.l   (.L3,%pc),%a1		43fb  XXXX  XXXX  XXXX 	bsr     _mcount			61ff  XXXX  XXXX    */
end_comment

begin_define
define|#
directive|define
name|P_LINK_L
value|0x480e
end_define

begin_define
define|#
directive|define
name|P_LINK_W
value|0x4e56
end_define

begin_define
define|#
directive|define
name|P_MOV_L
value|0x207c
end_define

begin_define
define|#
directive|define
name|P_JSR
value|0x4eb9
end_define

begin_define
define|#
directive|define
name|P_BSR
value|0x61ff
end_define

begin_define
define|#
directive|define
name|P_LEA_L
value|0x43fb
end_define

begin_define
define|#
directive|define
name|P_MOVM_L
value|0x48ef
end_define

begin_define
define|#
directive|define
name|P_FMOVM
value|0xf237
end_define

begin_define
define|#
directive|define
name|P_TRAP
value|0x4e40
end_define

begin_function
name|CORE_ADDR
name|m68k_skip_prologue
parameter_list|(
name|ip
parameter_list|)
name|CORE_ADDR
name|ip
decl_stmt|;
block|{
specifier|register
name|CORE_ADDR
name|limit
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
specifier|register
name|int
name|op
decl_stmt|;
comment|/* Find out if there is a known limit for the extent of the prologue.      If so, ensure we don't go past it.  If not, assume "infinity". */
name|sal
operator|=
name|find_pc_line
argument_list|(
name|ip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|limit
operator|=
operator|(
name|sal
operator|.
name|end
operator|)
condition|?
name|sal
operator|.
name|end
else|:
operator|(
name|CORE_ADDR
operator|)
operator|~
literal|0
expr_stmt|;
while|while
condition|(
name|ip
operator|<
name|limit
condition|)
block|{
name|op
operator|=
name|read_memory_integer
argument_list|(
name|ip
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|op
operator|&=
literal|0xFFFF
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|P_LINK_W
condition|)
block|{
name|ip
operator|+=
literal|4
expr_stmt|;
comment|/* Skip link.w */
block|}
elseif|else
if|if
condition|(
name|op
operator|==
literal|0x4856
condition|)
name|ip
operator|+=
literal|2
expr_stmt|;
comment|/* Skip pea %fp */
elseif|else
if|if
condition|(
name|op
operator|==
literal|0x2c4f
condition|)
name|ip
operator|+=
literal|2
expr_stmt|;
comment|/* Skip move.l %sp, %fp */
elseif|else
if|if
condition|(
name|op
operator|==
name|P_LINK_L
condition|)
block|{
name|ip
operator|+=
literal|6
expr_stmt|;
comment|/* Skip link.l */
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|P_MOVM_L
condition|)
block|{
name|ip
operator|+=
literal|6
expr_stmt|;
comment|/* Skip movm.l */
block|}
elseif|else
if|if
condition|(
name|op
operator|==
name|P_FMOVM
condition|)
block|{
name|ip
operator|+=
literal|10
expr_stmt|;
comment|/* Skip fmovm */
block|}
else|else
block|{
break|break;
comment|/* Found unknown code, bail out. */
block|}
block|}
return|return
operator|(
name|ip
operator|)
return|;
block|}
end_function

begin_function
name|void
name|m68k_find_saved_regs
parameter_list|(
name|frame_info
parameter_list|,
name|saved_regs
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame_info
decl_stmt|;
name|struct
name|frame_saved_regs
modifier|*
name|saved_regs
decl_stmt|;
block|{
specifier|register
name|int
name|regnum
decl_stmt|;
specifier|register
name|int
name|regmask
decl_stmt|;
specifier|register
name|CORE_ADDR
name|next_addr
decl_stmt|;
specifier|register
name|CORE_ADDR
name|pc
decl_stmt|;
comment|/* First possible address for a pc in a call dummy for this frame.  */
name|CORE_ADDR
name|possible_call_dummy_start
init|=
operator|(
name|frame_info
operator|)
operator|->
name|frame
operator|-
name|CALL_DUMMY_LENGTH
operator|-
name|FP_REGNUM
operator|*
literal|4
operator|-
literal|4
operator|-
literal|8
operator|*
literal|12
decl_stmt|;
name|int
name|nextinsn
decl_stmt|;
name|memset
argument_list|(
name|saved_regs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|saved_regs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|frame_info
operator|)
operator|->
name|pc
operator|>=
name|possible_call_dummy_start
operator|&&
operator|(
name|frame_info
operator|)
operator|->
name|pc
operator|<=
operator|(
name|frame_info
operator|)
operator|->
name|frame
condition|)
block|{
comment|/* It is a call dummy.  We could just stop now, since we know 	 what the call dummy saves and where.  But this code proceeds 	 to parse the "prologue" which is part of the call dummy. 	 This is needlessly complex and confusing.  FIXME.  */
name|next_addr
operator|=
operator|(
name|frame_info
operator|)
operator|->
name|frame
expr_stmt|;
name|pc
operator|=
name|possible_call_dummy_start
expr_stmt|;
block|}
else|else
block|{
name|pc
operator|=
name|get_pc_function_start
argument_list|(
operator|(
name|frame_info
operator|)
operator|->
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0x4856
operator|==
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|2
argument_list|)
operator|&&
literal|0x2c4f
operator|==
name|read_memory_integer
argument_list|(
name|pc
operator|+
literal|2
argument_list|,
literal|2
argument_list|)
condition|)
block|{
comment|/* 	    pea %fp             move.l %sp, %fp */
name|pc
operator|+=
literal|4
expr_stmt|;
name|next_addr
operator|=
name|frame_info
operator|->
name|frame
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|044016
operator|==
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|2
argument_list|)
condition|)
comment|/* link.l %fp */
comment|/* Find the address above the saved    	   regs using the amount of storage from the link instruction.  */
name|next_addr
operator|=
operator|(
name|frame_info
operator|)
operator|->
name|frame
operator|+
name|read_memory_integer
argument_list|(
name|pc
operator|+=
literal|2
argument_list|,
literal|4
argument_list|)
operator|,
name|pc
operator|+=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
literal|047126
operator|==
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|2
argument_list|)
condition|)
comment|/* link.w %fp */
comment|/* Find the address above the saved    	   regs using the amount of storage from the link instruction.  */
name|next_addr
operator|=
operator|(
name|frame_info
operator|)
operator|->
name|frame
operator|+
name|read_memory_integer
argument_list|(
name|pc
operator|+=
literal|2
argument_list|,
literal|2
argument_list|)
operator|,
name|pc
operator|+=
literal|2
expr_stmt|;
else|else
goto|goto
name|lose
goto|;
comment|/* If have an addal #-n, sp next, adjust next_addr.  */
if|if
condition|(
operator|(
literal|0177777
operator|&
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|2
argument_list|)
operator|)
operator|==
literal|0157774
condition|)
name|next_addr
operator|+=
name|read_memory_integer
argument_list|(
name|pc
operator|+=
literal|2
argument_list|,
literal|4
argument_list|)
operator|,
name|pc
operator|+=
literal|4
expr_stmt|;
block|}
name|regmask
operator|=
name|read_memory_integer
argument_list|(
name|pc
operator|+
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Here can come an fmovem.  Check for it.  */
name|nextinsn
operator|=
literal|0xffff
operator|&
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0xf227
operator|==
name|nextinsn
operator|&&
operator|(
name|regmask
operator|&
literal|0xff00
operator|)
operator|==
literal|0xe000
condition|)
block|{
name|pc
operator|+=
literal|4
expr_stmt|;
comment|/* Regmask's low bit is for register fp7, the first pushed */
for|for
control|(
name|regnum
operator|=
name|FP0_REGNUM
operator|+
literal|7
init|;
name|regnum
operator|>=
name|FP0_REGNUM
condition|;
name|regnum
operator|--
operator|,
name|regmask
operator|>>=
literal|1
control|)
if|if
condition|(
name|regmask
operator|&
literal|1
condition|)
name|saved_regs
operator|->
name|regs
index|[
name|regnum
index|]
operator|=
operator|(
name|next_addr
operator|-=
literal|12
operator|)
expr_stmt|;
name|regmask
operator|=
name|read_memory_integer
argument_list|(
name|pc
operator|+
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* next should be a moveml to (sp) or -(sp) or a movl r,-(sp) */
if|if
condition|(
literal|0044327
operator|==
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|pc
operator|+=
literal|4
expr_stmt|;
comment|/* Regmask's low bit is for register 0, the first written */
for|for
control|(
name|regnum
operator|=
literal|0
init|;
name|regnum
operator|<
literal|16
condition|;
name|regnum
operator|++
operator|,
name|regmask
operator|>>=
literal|1
control|)
if|if
condition|(
name|regmask
operator|&
literal|1
condition|)
name|saved_regs
operator|->
name|regs
index|[
name|regnum
index|]
operator|=
operator|(
name|next_addr
operator|+=
literal|4
operator|)
operator|-
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|0044347
operator|==
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|pc
operator|+=
literal|4
expr_stmt|;
comment|/* Regmask's low bit is for register 15, the first pushed */
for|for
control|(
name|regnum
operator|=
literal|15
init|;
name|regnum
operator|>=
literal|0
condition|;
name|regnum
operator|--
operator|,
name|regmask
operator|>>=
literal|1
control|)
if|if
condition|(
name|regmask
operator|&
literal|1
condition|)
name|saved_regs
operator|->
name|regs
index|[
name|regnum
index|]
operator|=
operator|(
name|next_addr
operator|-=
literal|4
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|0x2f00
operator|==
operator|(
literal|0xfff0
operator|&
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|2
argument_list|)
operator|)
condition|)
block|{
name|regnum
operator|=
literal|0xf
operator|&
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pc
operator|+=
literal|2
expr_stmt|;
name|saved_regs
operator|->
name|regs
index|[
name|regnum
index|]
operator|=
operator|(
name|next_addr
operator|-=
literal|4
operator|)
expr_stmt|;
comment|/* gcc, at least, may use a pair of movel instructions when saving 	 exactly 2 registers.  */
if|if
condition|(
literal|0x2f00
operator|==
operator|(
literal|0xfff0
operator|&
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|2
argument_list|)
operator|)
condition|)
block|{
name|regnum
operator|=
literal|0xf
operator|&
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pc
operator|+=
literal|2
expr_stmt|;
name|saved_regs
operator|->
name|regs
index|[
name|regnum
index|]
operator|=
operator|(
name|next_addr
operator|-=
literal|4
operator|)
expr_stmt|;
block|}
block|}
comment|/* fmovemx to index of sp may follow.  */
name|regmask
operator|=
name|read_memory_integer
argument_list|(
name|pc
operator|+
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|nextinsn
operator|=
literal|0xffff
operator|&
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0xf236
operator|==
name|nextinsn
operator|&&
operator|(
name|regmask
operator|&
literal|0xff00
operator|)
operator|==
literal|0xf000
condition|)
block|{
name|pc
operator|+=
literal|10
expr_stmt|;
comment|/* Regmask's low bit is for register fp0, the first written */
for|for
control|(
name|regnum
operator|=
name|FP0_REGNUM
operator|+
literal|7
init|;
name|regnum
operator|>=
name|FP0_REGNUM
condition|;
name|regnum
operator|--
operator|,
name|regmask
operator|>>=
literal|1
control|)
if|if
condition|(
name|regmask
operator|&
literal|1
condition|)
name|saved_regs
operator|->
name|regs
index|[
name|regnum
index|]
operator|=
operator|(
name|next_addr
operator|+=
literal|12
operator|)
operator|-
literal|12
expr_stmt|;
name|regmask
operator|=
name|read_memory_integer
argument_list|(
name|pc
operator|+
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* clrw -(sp); movw ccr,-(sp) may follow.  */
if|if
condition|(
literal|0x426742e7
operator|==
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|)
condition|)
name|saved_regs
operator|->
name|regs
index|[
name|PS_REGNUM
index|]
operator|=
operator|(
name|next_addr
operator|-=
literal|4
operator|)
expr_stmt|;
name|lose
label|:
empty_stmt|;
name|saved_regs
operator|->
name|regs
index|[
name|SP_REGNUM
index|]
operator|=
operator|(
name|frame_info
operator|)
operator|->
name|frame
operator|+
literal|8
expr_stmt|;
name|saved_regs
operator|->
name|regs
index|[
name|FP_REGNUM
index|]
operator|=
operator|(
name|frame_info
operator|)
operator|->
name|frame
expr_stmt|;
name|saved_regs
operator|->
name|regs
index|[
name|PC_REGNUM
index|]
operator|=
operator|(
name|frame_info
operator|)
operator|->
name|frame
operator|+
literal|4
expr_stmt|;
ifdef|#
directive|ifdef
name|SIG_SP_FP_OFFSET
comment|/* Adjust saved SP_REGNUM for fake _sigtramp frames.  */
if|if
condition|(
name|frame_info
operator|->
name|signal_handler_caller
operator|&&
name|frame_info
operator|->
name|next
condition|)
name|saved_regs
operator|->
name|regs
index|[
name|SP_REGNUM
index|]
operator|=
name|frame_info
operator|->
name|next
operator|->
name|frame
operator|+
name|SIG_SP_FP_OFFSET
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_PROC_FS
end_ifdef

begin_comment
comment|/* Target dependent support for /proc */
end_comment

begin_include
include|#
directive|include
file|<sys/procfs.h>
end_include

begin_comment
comment|/*  The /proc interface divides the target machine's register set up into     two different sets, the general register set (gregset) and the floating     point register set (fpregset).  For each set, there is an ioctl to get     the current register set and another ioctl to set the current values.      The actual structure passed through the ioctl interface is, of course,     naturally machine dependent, and is different for each set of registers.     For the m68k for example, the general register set is typically defined     by:  	typedef int gregset_t[18];  	#define	R_D0	0 	... 	#define	R_PS	17      and the floating point set by:      	typedef	struct fpregset { 	  int	f_pcr; 	  int	f_psr; 	  int	f_fpiaddr; 	  int	f_fpregs[8][3];		(8 regs, 96 bits each) 	} fpregset_t;      These routines provide the packing and unpacking of gregset_t and     fpregset_t formatted data.   */
end_comment

begin_comment
comment|/* Atari SVR4 has R_SR but not R_PS */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|R_PS
argument_list|)
operator|&&
name|defined
argument_list|(
name|R_SR
argument_list|)
end_if

begin_define
define|#
directive|define
name|R_PS
value|R_SR
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  Given a pointer to a general register set in /proc format (gregset_t *),     unpack the register contents and supply them as gdb's idea of the current     register values. */
end_comment

begin_function
name|void
name|supply_gregset
parameter_list|(
name|gregsetp
parameter_list|)
name|gregset_t
modifier|*
name|gregsetp
decl_stmt|;
block|{
specifier|register
name|int
name|regi
decl_stmt|;
specifier|register
name|greg_t
modifier|*
name|regp
init|=
operator|(
name|greg_t
operator|*
operator|)
name|gregsetp
decl_stmt|;
for|for
control|(
name|regi
operator|=
literal|0
init|;
name|regi
operator|<
name|R_PC
condition|;
name|regi
operator|++
control|)
block|{
name|supply_register
argument_list|(
name|regi
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|regi
operator|)
argument_list|)
expr_stmt|;
block|}
name|supply_register
argument_list|(
name|PS_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_PS
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|PC_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_PC
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fill_gregset
parameter_list|(
name|gregsetp
parameter_list|,
name|regno
parameter_list|)
name|gregset_t
modifier|*
name|gregsetp
decl_stmt|;
name|int
name|regno
decl_stmt|;
block|{
specifier|register
name|int
name|regi
decl_stmt|;
specifier|register
name|greg_t
modifier|*
name|regp
init|=
operator|(
name|greg_t
operator|*
operator|)
name|gregsetp
decl_stmt|;
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
for|for
control|(
name|regi
operator|=
literal|0
init|;
name|regi
operator|<
name|R_PC
condition|;
name|regi
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|regi
operator|)
condition|)
block|{
operator|*
operator|(
name|regp
operator|+
name|regi
operator|)
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regi
argument_list|)
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|PS_REGNUM
operator|)
condition|)
block|{
operator|*
operator|(
name|regp
operator|+
name|R_PS
operator|)
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|PS_REGNUM
argument_list|)
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|PC_REGNUM
operator|)
condition|)
block|{
operator|*
operator|(
name|regp
operator|+
name|R_PC
operator|)
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|PC_REGNUM
argument_list|)
index|]
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|FP0_REGNUM
argument_list|)
end_if

begin_comment
comment|/*  Given a pointer to a floating point register set in /proc format     (fpregset_t *), unpack the register contents and supply them as gdb's     idea of the current floating point register values. */
end_comment

begin_function
name|void
name|supply_fpregset
parameter_list|(
name|fpregsetp
parameter_list|)
name|fpregset_t
modifier|*
name|fpregsetp
decl_stmt|;
block|{
specifier|register
name|int
name|regi
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|;
for|for
control|(
name|regi
operator|=
name|FP0_REGNUM
init|;
name|regi
operator|<
name|FPC_REGNUM
condition|;
name|regi
operator|++
control|)
block|{
name|from
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|fpregsetp
operator|->
name|f_fpregs
index|[
name|regi
operator|-
name|FP0_REGNUM
index|]
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|supply_register
argument_list|(
name|regi
argument_list|,
name|from
argument_list|)
expr_stmt|;
block|}
name|supply_register
argument_list|(
name|FPC_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|fpregsetp
operator|->
name|f_pcr
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|FPS_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|fpregsetp
operator|->
name|f_psr
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|FPI_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|fpregsetp
operator|->
name|f_fpiaddr
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  Given a pointer to a floating point register set in /proc format     (fpregset_t *), update the register specified by REGNO from gdb's idea     of the current floating point register set.  If REGNO is -1, update     them all. */
end_comment

begin_function
name|void
name|fill_fpregset
parameter_list|(
name|fpregsetp
parameter_list|,
name|regno
parameter_list|)
name|fpregset_t
modifier|*
name|fpregsetp
decl_stmt|;
name|int
name|regno
decl_stmt|;
block|{
name|int
name|regi
decl_stmt|;
name|char
modifier|*
name|to
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|;
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
for|for
control|(
name|regi
operator|=
name|FP0_REGNUM
init|;
name|regi
operator|<
name|FPC_REGNUM
condition|;
name|regi
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|regi
operator|)
condition|)
block|{
name|from
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regi
argument_list|)
index|]
expr_stmt|;
name|to
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|fpregsetp
operator|->
name|f_fpregs
index|[
name|regi
operator|-
name|FP0_REGNUM
index|]
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regi
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|FPC_REGNUM
operator|)
condition|)
block|{
name|fpregsetp
operator|->
name|f_pcr
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FPC_REGNUM
argument_list|)
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|FPS_REGNUM
operator|)
condition|)
block|{
name|fpregsetp
operator|->
name|f_psr
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FPS_REGNUM
argument_list|)
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|FPI_REGNUM
operator|)
condition|)
block|{
name|fpregsetp
operator|->
name|f_fpiaddr
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FPI_REGNUM
argument_list|)
index|]
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined (FP0_REGNUM) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_PROC_FS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GET_LONGJMP_TARGET
end_ifdef

begin_comment
comment|/* Figure out where the longjmp will land.  Slurp the args out of the stack.    We expect the first arg to be a pointer to the jmp_buf structure from which    we extract the pc (JB_PC) that we will land at.  The pc is copied into PC.    This routine returns true on success. */
end_comment

begin_function
name|int
name|get_longjmp_target
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
modifier|*
name|pc
decl_stmt|;
block|{
name|char
name|buf
index|[
name|TARGET_PTR_BIT
operator|/
name|TARGET_CHAR_BIT
index|]
decl_stmt|;
name|CORE_ADDR
name|sp
decl_stmt|,
name|jb_addr
decl_stmt|;
name|sp
operator|=
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|sp
operator|+
name|SP_ARG0
argument_list|,
comment|/* Offset of first arg on stack */
name|buf
argument_list|,
name|TARGET_PTR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|)
condition|)
return|return
literal|0
return|;
name|jb_addr
operator|=
name|extract_address
argument_list|(
name|buf
argument_list|,
name|TARGET_PTR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|jb_addr
operator|+
name|JB_PC
operator|*
name|JB_ELEMENT_SIZE
argument_list|,
name|buf
argument_list|,
name|TARGET_PTR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|)
condition|)
return|return
literal|0
return|;
operator|*
name|pc
operator|=
name|extract_address
argument_list|(
name|buf
argument_list|,
name|TARGET_PTR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* GET_LONGJMP_TARGET */
end_comment

begin_comment
comment|/* Immediately after a function call, return the saved pc before the frame    is setup.  For sun3's, we check for the common case of being inside of a    system call, and if so, we know that Sun pushes the call # on the stack    prior to doing the trap. */
end_comment

begin_function
name|CORE_ADDR
name|m68k_saved_pc_after_call
parameter_list|(
name|frame
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|SYSCALL_TRAP
name|int
name|op
decl_stmt|;
name|op
operator|=
name|read_memory_integer
argument_list|(
name|frame
operator|->
name|pc
operator|-
name|SYSCALL_TRAP_OFFSET
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|SYSCALL_TRAP
condition|)
return|return
name|read_memory_integer
argument_list|(
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
return|;
else|else
endif|#
directive|endif
comment|/* SYSCALL_TRAP */
return|return
name|read_memory_integer
argument_list|(
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
argument_list|,
literal|4
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|_initialize_m68k_tdep
parameter_list|()
block|{
name|tm_print_insn
operator|=
name|print_insn_m68k
expr_stmt|;
block|}
end_function

end_unit

