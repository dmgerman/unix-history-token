begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Line completion stuff for GDB, the GNU debugger.    Copyright 2000, 2001 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"filenames.h"
end_include

begin_comment
comment|/* for DOSish file names */
end_comment

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"cli/cli-decode.h"
end_include

begin_comment
comment|/* FIXME: This is needed because of lookup_cmd_1().    We should be calling a hook instead so we eliminate the CLI dependency. */
end_comment

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_comment
comment|/* Needed for rl_completer_word_break_characters() and for    rl_filename_completion_function.  */
end_comment

begin_include
include|#
directive|include
file|"readline/readline.h"
end_include

begin_comment
comment|/* readline defines this.  */
end_comment

begin_undef
undef|#
directive|undef
name|savestring
end_undef

begin_include
include|#
directive|include
file|"completer.h"
end_include

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_function_decl
specifier|static
name|char
modifier|*
name|line_completion_function
parameter_list|(
specifier|const
name|char
modifier|*
name|text
parameter_list|,
name|int
name|matches
parameter_list|,
name|char
modifier|*
name|line_buffer
parameter_list|,
name|int
name|point
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* readline uses the word breaks for two things:    (1) In figuring out where to point the TEXT parameter to the    rl_completion_entry_function.  Since we don't use TEXT for much,    it doesn't matter a lot what the word breaks are for this purpose, but    it does affect how much stuff M-? lists.    (2) If one of the matches contains a word break character, readline    will quote it.  That's why we switch between    current_language->la_word_break_characters() and    gdb_completer_command_word_break_characters.  I'm not sure when    we need this behavior (perhaps for funky characters in C++ symbols?).  */
end_comment

begin_comment
comment|/* Variables which are necessary for fancy command line editing.  */
end_comment

begin_comment
comment|/* When completing on command names, we remove '-' from the list of    word break characters, since we use it in command names.  If the    readline library sees one in any of the current completion strings,    it thinks that the string needs to be quoted and automatically supplies    a leading quote. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|gdb_completer_command_word_break_characters
init|=
literal|" \t\n!@#$%^&*()+=|~`}{[]\"';:?/>.<,"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When completing on file names, we remove from the list of word    break characters any characters that are commonly used in file    names, such as '-', '+', '~', etc.  Otherwise, readline displays    incorrect completion candidates.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_DOS_BASED_FILE_SYSTEM
end_ifdef

begin_comment
comment|/* MS-DOS and MS-Windows use colon as part of the drive spec, and most    programs support @foo style response files.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|gdb_completer_file_name_break_characters
init|=
literal|" \t\n*|\"';?><@"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|char
modifier|*
name|gdb_completer_file_name_break_characters
init|=
literal|" \t\n*|\"';:?><"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* These are used when completing on locations, which can mix file    names and symbol names separated by a colon.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|gdb_completer_loc_break_characters
init|=
literal|" \t\n*|\"';:?><,"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Characters that can be used to quote completion strings.  Note that we    can't include '"' because the gdb C parser treats such quoted sequences    as strings. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|gdb_completer_quote_characters
init|=
literal|"'"
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Accessor for some completer data that may interest other files. */
end_comment

begin_function
name|char
modifier|*
name|get_gdb_completer_quote_characters
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|gdb_completer_quote_characters
return|;
block|}
end_function

begin_comment
comment|/* Line completion interface function for readline.  */
end_comment

begin_function
name|char
modifier|*
name|readline_line_completion_function
parameter_list|(
specifier|const
name|char
modifier|*
name|text
parameter_list|,
name|int
name|matches
parameter_list|)
block|{
return|return
name|line_completion_function
argument_list|(
name|text
argument_list|,
name|matches
argument_list|,
name|rl_line_buffer
argument_list|,
name|rl_point
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This can be used for functions which don't want to complete on symbols    but don't want to complete on anything else either.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|noop_completer
parameter_list|(
name|char
modifier|*
name|text
parameter_list|,
name|char
modifier|*
name|prefix
parameter_list|)
block|{
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Complete on filenames.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|filename_completer
parameter_list|(
name|char
modifier|*
name|text
parameter_list|,
name|char
modifier|*
name|word
parameter_list|)
block|{
name|int
name|subsequent_name
decl_stmt|;
name|char
modifier|*
modifier|*
name|return_val
decl_stmt|;
name|int
name|return_val_used
decl_stmt|;
name|int
name|return_val_alloced
decl_stmt|;
name|return_val_used
operator|=
literal|0
expr_stmt|;
comment|/* Small for testing.  */
name|return_val_alloced
operator|=
literal|1
expr_stmt|;
name|return_val
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|return_val_alloced
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|subsequent_name
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|rl_filename_completion_function
argument_list|(
name|text
argument_list|,
name|subsequent_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|return_val_used
operator|>=
name|return_val_alloced
condition|)
block|{
name|return_val_alloced
operator|*=
literal|2
expr_stmt|;
name|return_val
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|return_val
argument_list|,
name|return_val_alloced
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|return_val
index|[
name|return_val_used
operator|++
index|]
operator|=
name|p
expr_stmt|;
break|break;
block|}
comment|/* We need to set subsequent_name to a non-zero value before the 	 continue line below, because otherwise, if the first file seen 	 by GDB is a backup file whose name ends in a `~', we will loop 	 indefinitely.  */
name|subsequent_name
operator|=
literal|1
expr_stmt|;
comment|/* Like emacs, don't complete on old versions.  Especially useful          in the "source" command.  */
if|if
condition|(
name|p
index|[
name|strlen
argument_list|(
name|p
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'~'
condition|)
continue|continue;
block|{
name|char
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|word
operator|==
name|text
condition|)
comment|/* Return exactly p.  */
name|return_val
index|[
name|return_val_used
operator|++
index|]
operator|=
name|p
expr_stmt|;
elseif|else
if|if
condition|(
name|word
operator|>
name|text
condition|)
block|{
comment|/* Return some portion of p.  */
name|q
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|q
argument_list|,
name|p
operator|+
operator|(
name|word
operator|-
name|text
operator|)
argument_list|)
expr_stmt|;
name|return_val
index|[
name|return_val_used
operator|++
index|]
operator|=
name|q
expr_stmt|;
name|xfree
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Return some of TEXT plus p.  */
name|q
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
operator|(
name|text
operator|-
name|word
operator|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|q
argument_list|,
name|word
argument_list|,
name|text
operator|-
name|word
argument_list|)
expr_stmt|;
name|q
index|[
name|text
operator|-
name|word
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|q
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|return_val
index|[
name|return_val_used
operator|++
index|]
operator|=
name|q
expr_stmt|;
name|xfree
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|#
directive|if
literal|0
comment|/* There is no way to do this just long enough to affect quote inserting      without also affecting the next completion.  This should be fixed in      readline.  FIXME.  */
comment|/* Insure that readline does the right thing      with respect to inserting quotes.  */
block|rl_completer_word_break_characters = "";
endif|#
directive|endif
return|return
name|return_val
return|;
block|}
end_function

begin_comment
comment|/* Complete on locations, which might be of two possible forms:         file:line    or        symbol+offset     This is intended to be used in commands that set breakpoints etc.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|location_completer
parameter_list|(
name|char
modifier|*
name|text
parameter_list|,
name|char
modifier|*
name|word
parameter_list|)
block|{
name|int
name|n_syms
init|=
literal|0
decl_stmt|,
name|n_files
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|fn_list
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
modifier|*
name|list
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|quote_found
init|=
literal|0
decl_stmt|;
name|int
name|quoted
init|=
operator|*
name|text
operator|==
literal|'\''
operator|||
operator|*
name|text
operator|==
literal|'"'
decl_stmt|;
name|int
name|quote_char
init|=
literal|'\0'
decl_stmt|;
name|char
modifier|*
name|colon
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|file_to_match
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|symbol_start
init|=
name|text
decl_stmt|;
name|char
modifier|*
name|orig_text
init|=
name|text
decl_stmt|;
name|size_t
name|text_len
decl_stmt|;
comment|/* Do we have an unquoted colon, as in "break foo.c::bar"?  */
for|for
control|(
name|p
operator|=
name|text
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'\''
condition|)
name|p
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\''
operator|||
operator|*
name|p
operator|==
literal|'"'
condition|)
block|{
name|quote_found
operator|=
operator|*
name|p
expr_stmt|;
name|quote_char
operator|=
operator|*
name|p
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
name|quote_found
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
name|quote_found
condition|)
name|p
operator|++
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
name|quote_found
condition|)
name|quote_found
operator|=
literal|0
expr_stmt|;
else|else
break|break;
comment|/* hit the end of text */
block|}
if|#
directive|if
name|HAVE_DOS_BASED_FILE_SYSTEM
comment|/* If we have a DOS-style absolute file name at the beginning of 	 TEXT, and the colon after the drive letter is the only colon 	 we found, pretend the colon is not there.  */
elseif|else
if|if
condition|(
name|p
operator|<
name|text
operator|+
literal|3
operator|&&
operator|*
name|p
operator|==
literal|':'
operator|&&
name|p
operator|==
name|text
operator|+
literal|1
operator|+
name|quoted
condition|)
empty_stmt|;
endif|#
directive|endif
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|':'
operator|&&
operator|!
name|colon
condition|)
block|{
name|colon
operator|=
name|p
expr_stmt|;
name|symbol_start
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|current_language
operator|->
name|la_word_break_characters
argument_list|()
argument_list|,
operator|*
name|p
argument_list|)
condition|)
name|symbol_start
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|quoted
condition|)
name|text
operator|++
expr_stmt|;
name|text_len
operator|=
name|strlen
argument_list|(
name|text
argument_list|)
expr_stmt|;
comment|/* Where is the file name?  */
if|if
condition|(
name|colon
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|file_to_match
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|colon
operator|-
name|text
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|file_to_match
argument_list|,
name|text
argument_list|,
name|colon
operator|-
name|text
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Remove trailing colons and quotes from the file name.  */
for|for
control|(
name|s
operator|=
name|file_to_match
operator|+
operator|(
name|colon
operator|-
name|text
operator|)
init|;
name|s
operator|>
name|file_to_match
condition|;
name|s
operator|--
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|':'
operator|||
operator|*
name|s
operator|==
name|quote_char
condition|)
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* If the text includes a colon, they want completion only on a      symbol name after the colon.  Otherwise, we need to complete on      symbols as well as on files.  */
if|if
condition|(
name|colon
condition|)
block|{
name|list
operator|=
name|make_file_symbol_completion_list
argument_list|(
name|symbol_start
argument_list|,
name|word
argument_list|,
name|file_to_match
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|file_to_match
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|list
operator|=
name|make_symbol_completion_list
argument_list|(
name|symbol_start
argument_list|,
name|word
argument_list|)
expr_stmt|;
comment|/* If text includes characters which cannot appear in a file 	 name, they cannot be asking for completion on files.  */
if|if
condition|(
name|strcspn
argument_list|(
name|text
argument_list|,
name|gdb_completer_file_name_break_characters
argument_list|)
operator|==
name|text_len
condition|)
name|fn_list
operator|=
name|make_source_files_completion_list
argument_list|(
name|text
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
comment|/* How many completions do we have in both lists?  */
if|if
condition|(
name|fn_list
condition|)
for|for
control|(
init|;
name|fn_list
index|[
name|n_files
index|]
condition|;
name|n_files
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|list
condition|)
for|for
control|(
init|;
name|list
index|[
name|n_syms
index|]
condition|;
name|n_syms
operator|++
control|)
empty_stmt|;
comment|/* Make list[] large enough to hold both lists, then catenate      fn_list[] onto the end of list[].  */
if|if
condition|(
name|n_syms
operator|&&
name|n_files
condition|)
block|{
name|list
operator|=
name|xrealloc
argument_list|(
name|list
argument_list|,
operator|(
name|n_syms
operator|+
name|n_files
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|list
operator|+
name|n_syms
argument_list|,
name|fn_list
argument_list|,
operator|(
name|n_files
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|fn_list
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n_files
condition|)
block|{
comment|/* If we only have file names as possible completion, we should 	 bring them in sync with what rl_complete expects.  The 	 problem is that if the user types "break /foo/b TAB", and the 	 possible completions are "/foo/bar" and "/foo/baz" 	 rl_complete expects us to return "bar" and "baz", without the 	 leading directories, as possible completions, because `word' 	 starts at the "b".  But we ignore the value of `word' when we 	 call make_source_files_completion_list above (because that 	 would not DTRT when the completion results in both symbols 	 and file names), so make_source_files_completion_list returns 	 the full "/foo/bar" and "/foo/baz" strings.  This produces 	 wrong results when, e.g., there's only one possible 	 completion, because rl_complete will prepend "/foo/" to each 	 candidate completion.  The loop below removes that leading 	 part.  */
for|for
control|(
name|n_files
operator|=
literal|0
init|;
name|fn_list
index|[
name|n_files
index|]
condition|;
name|n_files
operator|++
control|)
block|{
name|memmove
argument_list|(
name|fn_list
index|[
name|n_files
index|]
argument_list|,
name|fn_list
index|[
name|n_files
index|]
operator|+
operator|(
name|word
operator|-
name|text
operator|)
argument_list|,
name|strlen
argument_list|(
name|fn_list
index|[
name|n_files
index|]
argument_list|)
operator|+
literal|1
operator|-
operator|(
name|word
operator|-
name|text
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Return just the file-name list as the result.  */
name|list
operator|=
name|fn_list
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|n_syms
condition|)
block|{
comment|/* No completions at all.  As the final resort, try completing 	 on the entire text as a symbol.  */
name|list
operator|=
name|make_symbol_completion_list
argument_list|(
name|orig_text
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
return|return
name|list
return|;
block|}
end_function

begin_comment
comment|/* Complete on command names.  Used by "help".  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|command_completer
parameter_list|(
name|char
modifier|*
name|text
parameter_list|,
name|char
modifier|*
name|word
parameter_list|)
block|{
return|return
name|complete_on_cmdlist
argument_list|(
name|cmdlist
argument_list|,
name|text
argument_list|,
name|word
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Here are some useful test cases for completion.  FIXME: These should    be put in the test suite.  They should be tested with both M-? and TAB.     "show output-" "radix"    "show output" "-radix"    "p" ambiguous (commands starting with p--path, print, printf, etc.)    "p "  ambiguous (all symbols)    "info t foo" no completions    "info t " no completions    "info t" ambiguous ("info target", "info terminal", etc.)    "info ajksdlfk" no completions    "info ajksdlfk " no completions    "info" " "    "info " ambiguous (all info commands)    "p \"a" no completions (string constant)    "p 'a" ambiguous (all symbols starting with a)    "p b-a" ambiguous (all symbols starting with a)    "p b-" ambiguous (all symbols)    "file Make" "file" (word break hard to screw up here)    "file ../gdb.stabs/we" "ird" (needs to not break word at slash)  */
end_comment

begin_comment
comment|/* Generate completions all at once.  Returns a NULL-terminated array    of strings.  Both the array and each element are allocated with    xmalloc.  It can also return NULL if there are no completions.     TEXT is the caller's idea of the "word" we are looking at.     LINE_BUFFER is available to be looked at; it contains the entire text    of the line.  POINT is the offset in that line of the cursor.  You    should pretend that the line ends at POINT.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|complete_line
parameter_list|(
specifier|const
name|char
modifier|*
name|text
parameter_list|,
name|char
modifier|*
name|line_buffer
parameter_list|,
name|int
name|point
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|list
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|tmp_command
decl_stmt|,
modifier|*
name|p
decl_stmt|;
comment|/* Pointer within tmp_command which corresponds to text.  */
name|char
modifier|*
name|word
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|,
modifier|*
name|result_list
decl_stmt|;
comment|/* Choose the default set of word break characters to break completions.      If we later find out that we are doing completions on command strings      (as opposed to strings supplied by the individual command completer      functions, which can be any string) then we will switch to the      special word break set for command strings, which leaves out the      '-' character used in some commands.  */
name|rl_completer_word_break_characters
operator|=
name|current_language
operator|->
name|la_word_break_characters
argument_list|()
expr_stmt|;
comment|/* Decide whether to complete on a list of gdb commands or on symbols. */
name|tmp_command
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|point
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|tmp_command
expr_stmt|;
name|strncpy
argument_list|(
name|tmp_command
argument_list|,
name|line_buffer
argument_list|,
name|point
argument_list|)
expr_stmt|;
name|tmp_command
index|[
name|point
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Since text always contains some number of characters leading up      to point, we can find the equivalent position in tmp_command      by subtracting that many characters from the end of tmp_command.  */
name|word
operator|=
name|tmp_command
operator|+
name|point
operator|-
name|strlen
argument_list|(
name|text
argument_list|)
expr_stmt|;
if|if
condition|(
name|point
operator|==
literal|0
condition|)
block|{
comment|/* An empty line we want to consider ambiguous; that is, it 	 could be any command.  */
name|c
operator|=
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
name|result_list
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
name|lookup_cmd_1
argument_list|(
operator|&
name|p
argument_list|,
name|cmdlist
argument_list|,
operator|&
name|result_list
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Move p up to the next interesting thing.  */
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
block|{
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|c
condition|)
block|{
comment|/* It is an unrecognized command.  So there are no 	 possible completions.  */
name|list
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
name|char
modifier|*
name|q
decl_stmt|;
comment|/* lookup_cmd_1 advances p up to the first ambiguous thing, but 	 doesn't advance over that thing itself.  Do so now.  */
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|q
operator|&&
operator|(
name|isalnum
argument_list|(
operator|*
name|q
argument_list|)
operator|||
operator|*
name|q
operator|==
literal|'-'
operator|||
operator|*
name|q
operator|==
literal|'_'
operator|)
condition|)
operator|++
name|q
expr_stmt|;
if|if
condition|(
name|q
operator|!=
name|tmp_command
operator|+
name|point
condition|)
block|{
comment|/* There is something beyond the ambiguous 	     command, so there are no possible completions.  For 	     example, "info t " or "info t foo" does not complete 	     to anything, because "info t" can be "info target" or 	     "info terminal".  */
name|list
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* We're trying to complete on the command which was ambiguous. 	     This we can deal with.  */
if|if
condition|(
name|result_list
condition|)
block|{
name|list
operator|=
name|complete_on_cmdlist
argument_list|(
operator|*
name|result_list
operator|->
name|prefixlist
argument_list|,
name|p
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|list
operator|=
name|complete_on_cmdlist
argument_list|(
name|cmdlist
argument_list|,
name|p
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
comment|/* Insure that readline does the right thing with respect to 	     inserting quotes.  */
name|rl_completer_word_break_characters
operator|=
name|gdb_completer_command_word_break_characters
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We've recognized a full command.  */
if|if
condition|(
name|p
operator|==
name|tmp_command
operator|+
name|point
condition|)
block|{
comment|/* There is no non-whitespace in the line beyond the command.  */
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
operator|||
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'\t'
condition|)
block|{
comment|/* The command is followed by whitespace; we need to complete 		 on whatever comes after command.  */
if|if
condition|(
name|c
operator|->
name|prefixlist
condition|)
block|{
comment|/* It is a prefix command; what comes after it is 		     a subcommand (e.g. "info ").  */
name|list
operator|=
name|complete_on_cmdlist
argument_list|(
operator|*
name|c
operator|->
name|prefixlist
argument_list|,
name|p
argument_list|,
name|word
argument_list|)
expr_stmt|;
comment|/* Insure that readline does the right thing 		         with respect to inserting quotes.  */
name|rl_completer_word_break_characters
operator|=
name|gdb_completer_command_word_break_characters
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|enums
condition|)
block|{
name|list
operator|=
name|complete_on_enum
argument_list|(
name|c
operator|->
name|enums
argument_list|,
name|p
argument_list|,
name|word
argument_list|)
expr_stmt|;
name|rl_completer_word_break_characters
operator|=
name|gdb_completer_command_word_break_characters
expr_stmt|;
block|}
else|else
block|{
comment|/* It is a normal command; what comes after it is 		     completed by the command's completer function.  */
if|if
condition|(
name|c
operator|->
name|completer
operator|==
name|filename_completer
condition|)
block|{
comment|/* Many commands which want to complete on 			 file names accept several file names, as 			 in "run foo bar>>baz".  So we don't want 			 to complete the entire text after the 			 command, just the last word.  To this 			 end, we need to find the beginning of the 			 file name by starting at `word' and going 			 backwards.  */
for|for
control|(
name|p
operator|=
name|word
init|;
name|p
operator|>
name|tmp_command
operator|&&
name|strchr
argument_list|(
name|gdb_completer_file_name_break_characters
argument_list|,
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
operator|==
name|NULL
condition|;
name|p
operator|--
control|)
empty_stmt|;
name|rl_completer_word_break_characters
operator|=
name|gdb_completer_file_name_break_characters
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|completer
operator|==
name|location_completer
condition|)
block|{
comment|/* Commands which complete on locations want to 			 see the entire argument.  */
for|for
control|(
name|p
operator|=
name|word
init|;
name|p
operator|>
name|tmp_command
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|' '
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\t'
condition|;
name|p
operator|--
control|)
empty_stmt|;
block|}
name|list
operator|=
call|(
modifier|*
name|c
operator|->
name|completer
call|)
argument_list|(
name|p
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* The command is not followed by whitespace; we need to 		 complete on the command itself.  e.g. "p" which is a 		 command itself but also can complete to "print", "ptype" 		 etc.  */
name|char
modifier|*
name|q
decl_stmt|;
comment|/* Find the command we are completing on.  */
name|q
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|q
operator|>
name|tmp_command
condition|)
block|{
if|if
condition|(
name|isalnum
argument_list|(
name|q
index|[
operator|-
literal|1
index|]
argument_list|)
operator|||
name|q
index|[
operator|-
literal|1
index|]
operator|==
literal|'-'
operator|||
name|q
index|[
operator|-
literal|1
index|]
operator|==
literal|'_'
condition|)
operator|--
name|q
expr_stmt|;
else|else
break|break;
block|}
name|list
operator|=
name|complete_on_cmdlist
argument_list|(
name|result_list
argument_list|,
name|q
argument_list|,
name|word
argument_list|)
expr_stmt|;
comment|/* Insure that readline does the right thing 		     with respect to inserting quotes.  */
name|rl_completer_word_break_characters
operator|=
name|gdb_completer_command_word_break_characters
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* There is non-whitespace beyond the command.  */
if|if
condition|(
name|c
operator|->
name|prefixlist
operator|&&
operator|!
name|c
operator|->
name|allow_unknown
condition|)
block|{
comment|/* It is an unrecognized subcommand of a prefix command, 		 e.g. "info adsfkdj".  */
name|list
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|enums
condition|)
block|{
name|list
operator|=
name|complete_on_enum
argument_list|(
name|c
operator|->
name|enums
argument_list|,
name|p
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* It is a normal command.  */
if|if
condition|(
name|c
operator|->
name|completer
operator|==
name|filename_completer
condition|)
block|{
comment|/* See the commentary above about the specifics 		     of file-name completion.  */
for|for
control|(
name|p
operator|=
name|word
init|;
name|p
operator|>
name|tmp_command
operator|&&
name|strchr
argument_list|(
name|gdb_completer_file_name_break_characters
argument_list|,
name|p
index|[
operator|-
literal|1
index|]
argument_list|)
operator|==
name|NULL
condition|;
name|p
operator|--
control|)
empty_stmt|;
name|rl_completer_word_break_characters
operator|=
name|gdb_completer_file_name_break_characters
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|completer
operator|==
name|location_completer
condition|)
block|{
for|for
control|(
name|p
operator|=
name|word
init|;
name|p
operator|>
name|tmp_command
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|' '
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\t'
condition|;
name|p
operator|--
control|)
empty_stmt|;
block|}
name|list
operator|=
call|(
modifier|*
name|c
operator|->
name|completer
call|)
argument_list|(
name|p
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|list
return|;
block|}
end_function

begin_comment
comment|/* Generate completions one by one for the completer.  Each time we are    called return another potential completion to the caller.    line_completion just completes on commands or passes the buck to the    command's completer function, the stuff specific to symbol completion    is in make_symbol_completion_list.     TEXT is the caller's idea of the "word" we are looking at.     MATCHES is the number of matches that have currently been collected from    calling this completion function.  When zero, then we need to initialize,    otherwise the initialization has already taken place and we can just    return the next potential completion string.     LINE_BUFFER is available to be looked at; it contains the entire text    of the line.  POINT is the offset in that line of the cursor.  You    should pretend that the line ends at POINT.     Returns NULL if there are no more completions, else a pointer to a string    which is a possible completion, it is the caller's responsibility to    free the string.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|line_completion_function
parameter_list|(
specifier|const
name|char
modifier|*
name|text
parameter_list|,
name|int
name|matches
parameter_list|,
name|char
modifier|*
name|line_buffer
parameter_list|,
name|int
name|point
parameter_list|)
block|{
specifier|static
name|char
modifier|*
modifier|*
name|list
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
comment|/* Cache of completions */
specifier|static
name|int
name|index
decl_stmt|;
comment|/* Next cached completion */
name|char
modifier|*
name|output
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|matches
operator|==
literal|0
condition|)
block|{
comment|/* The caller is beginning to accumulate a new set of completions, so          we need to find all of them now, and cache them for returning one at          a time on future calls. */
if|if
condition|(
name|list
condition|)
block|{
comment|/* Free the storage used by LIST, but not by the strings inside. 	     This is because rl_complete_internal () frees the strings. */
name|xfree
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
name|index
operator|=
literal|0
expr_stmt|;
name|list
operator|=
name|complete_line
argument_list|(
name|text
argument_list|,
name|line_buffer
argument_list|,
name|point
argument_list|)
expr_stmt|;
block|}
comment|/* If we found a list of potential completions during initialization then      dole them out one at a time.  The vector of completions is NULL      terminated, so after returning the last one, return NULL (and continue      to do so) each time we are called after that, until a new list is      available. */
if|if
condition|(
name|list
condition|)
block|{
name|output
operator|=
name|list
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|output
condition|)
block|{
name|index
operator|++
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
comment|/* Can't do this because readline hasn't yet checked the word breaks      for figuring out whether to insert a quote.  */
block|if (output == NULL)
comment|/* Make sure the word break characters are set back to normal for the        next time that readline tries to complete something.  */
block|rl_completer_word_break_characters =       current_language->la_word_break_characters();
endif|#
directive|endif
return|return
operator|(
name|output
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Skip over the possibly quoted word STR (as defined by the quote    characters QUOTECHARS and the the word break characters    BREAKCHARS).  Returns pointer to the location after the "word".  If    either QUOTECHARS or BREAKCHARS is NULL, use the same values used    by the completer.  */
end_comment

begin_function
name|char
modifier|*
name|skip_quoted_chars
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|char
modifier|*
name|quotechars
parameter_list|,
name|char
modifier|*
name|breakchars
parameter_list|)
block|{
name|char
name|quote_char
init|=
literal|'\0'
decl_stmt|;
name|char
modifier|*
name|scan
decl_stmt|;
if|if
condition|(
name|quotechars
operator|==
name|NULL
condition|)
name|quotechars
operator|=
name|gdb_completer_quote_characters
expr_stmt|;
if|if
condition|(
name|breakchars
operator|==
name|NULL
condition|)
name|breakchars
operator|=
name|current_language
operator|->
name|la_word_break_characters
argument_list|()
expr_stmt|;
for|for
control|(
name|scan
operator|=
name|str
init|;
operator|*
name|scan
operator|!=
literal|'\0'
condition|;
name|scan
operator|++
control|)
block|{
if|if
condition|(
name|quote_char
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Ignore everything until the matching close quote char */
if|if
condition|(
operator|*
name|scan
operator|==
name|quote_char
condition|)
block|{
comment|/* Found matching close quote. */
name|scan
operator|++
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|quotechars
argument_list|,
operator|*
name|scan
argument_list|)
condition|)
block|{
comment|/* Found start of a quoted string. */
name|quote_char
operator|=
operator|*
name|scan
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|breakchars
argument_list|,
operator|*
name|scan
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
return|return
operator|(
name|scan
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Skip over the possibly quoted word STR (as defined by the quote    characters and word break characters used by the completer).    Returns pointer to the location after the "word". */
end_comment

begin_function
name|char
modifier|*
name|skip_quoted
parameter_list|(
name|char
modifier|*
name|str
parameter_list|)
block|{
return|return
name|skip_quoted_chars
argument_list|(
name|str
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

end_unit

