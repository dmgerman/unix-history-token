begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Functions for manipulating expressions designed to be executed on the agent    Copyright 1998 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* $Id: ax-general.c,v 1.3 1998/12/02 23:22:58 msnyder Exp $ */
end_comment

begin_comment
comment|/* Despite what the above comment says about this file being part of    GDB, we would like to keep these functions free of GDB    dependencies, since we want to be able to use them in contexts    outside of GDB (test suites, the stub, etc.)  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"ax.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Functions for building expressions.  */
end_comment

begin_comment
comment|/* Allocate a new, empty agent expression.  */
end_comment

begin_function
name|struct
name|agent_expr
modifier|*
name|new_agent_expr
parameter_list|(
name|scope
parameter_list|)
name|CORE_ADDR
name|scope
decl_stmt|;
block|{
name|struct
name|agent_expr
modifier|*
name|x
init|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|x
argument_list|)
argument_list|)
decl_stmt|;
name|x
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|x
operator|->
name|size
operator|=
literal|1
expr_stmt|;
comment|/* Change this to a larger value once 				   reallocation code is tested.  */
name|x
operator|->
name|buf
operator|=
name|xmalloc
argument_list|(
name|x
operator|->
name|size
argument_list|)
expr_stmt|;
name|x
operator|->
name|scope
operator|=
name|scope
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Free a agent expression.  */
end_comment

begin_function
name|void
name|free_agent_expr
parameter_list|(
name|x
parameter_list|)
name|struct
name|agent_expr
modifier|*
name|x
decl_stmt|;
block|{
name|free
argument_list|(
name|x
operator|->
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make sure that X has room for at least N more bytes.  This doesn't    affect the length, just the allocated size.  */
end_comment

begin_function
specifier|static
name|void
name|grow_expr
parameter_list|(
name|x
parameter_list|,
name|n
parameter_list|)
name|struct
name|agent_expr
modifier|*
name|x
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
if|if
condition|(
name|x
operator|->
name|len
operator|+
name|n
operator|>
name|x
operator|->
name|size
condition|)
block|{
name|x
operator|->
name|size
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|size
operator|<
name|x
operator|->
name|len
operator|+
name|n
condition|)
name|x
operator|->
name|size
operator|=
name|x
operator|->
name|len
operator|+
name|n
operator|+
literal|10
expr_stmt|;
name|x
operator|->
name|buf
operator|=
name|xrealloc
argument_list|(
name|x
operator|->
name|buf
argument_list|,
name|x
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Append the low N bytes of VAL as an N-byte integer to the    expression X, in big-endian order.  */
end_comment

begin_function
specifier|static
name|void
name|append_const
parameter_list|(
name|x
parameter_list|,
name|val
parameter_list|,
name|n
parameter_list|)
name|struct
name|agent_expr
modifier|*
name|x
decl_stmt|;
name|LONGEST
name|val
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|grow_expr
argument_list|(
name|x
argument_list|,
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|x
operator|->
name|buf
index|[
name|x
operator|->
name|len
operator|+
name|i
index|]
operator|=
name|val
operator|&
literal|0xff
expr_stmt|;
name|val
operator|>>=
literal|8
expr_stmt|;
block|}
name|x
operator|->
name|len
operator|+=
name|n
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Extract an N-byte big-endian unsigned integer from expression X at    offset O.  */
end_comment

begin_function
specifier|static
name|LONGEST
name|read_const
parameter_list|(
name|x
parameter_list|,
name|o
parameter_list|,
name|n
parameter_list|)
name|struct
name|agent_expr
modifier|*
name|x
decl_stmt|;
name|int
name|o
decl_stmt|,
name|n
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|LONGEST
name|accum
init|=
literal|0
decl_stmt|;
comment|/* Make sure we're not reading off the end of the expression.  */
if|if
condition|(
name|o
operator|+
name|n
operator|>
name|x
operator|->
name|len
condition|)
name|error
argument_list|(
literal|"GDB bug: ax-general.c (read_const): incomplete constant"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|accum
operator|=
operator|(
name|accum
operator|<<
literal|8
operator|)
operator||
name|x
operator|->
name|buf
index|[
name|o
operator|+
name|i
index|]
expr_stmt|;
return|return
name|accum
return|;
block|}
end_function

begin_comment
comment|/* Append a simple operator OP to EXPR.  */
end_comment

begin_function
name|void
name|ax_simple
parameter_list|(
name|x
parameter_list|,
name|op
parameter_list|)
name|struct
name|agent_expr
modifier|*
name|x
decl_stmt|;
name|enum
name|agent_op
name|op
decl_stmt|;
block|{
name|grow_expr
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|x
operator|->
name|buf
index|[
name|x
operator|->
name|len
operator|++
index|]
operator|=
name|op
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Append a sign-extension or zero-extension instruction to EXPR, to    extend an N-bit value.  */
end_comment

begin_function
specifier|static
name|void
name|generic_ext
parameter_list|(
name|x
parameter_list|,
name|op
parameter_list|,
name|n
parameter_list|)
name|struct
name|agent_expr
modifier|*
name|x
decl_stmt|;
name|enum
name|agent_op
name|op
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
comment|/* N must fit in a byte.  */
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
literal|255
condition|)
name|error
argument_list|(
literal|"GDB bug: ax-general.c (generic_ext): bit count out of range"
argument_list|)
expr_stmt|;
comment|/* That had better be enough range.  */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
operator|*
literal|8
operator|>
literal|255
condition|)
name|error
argument_list|(
literal|"GDB bug: ax-general.c (generic_ext): opcode has inadequate range"
argument_list|)
expr_stmt|;
name|grow_expr
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|x
operator|->
name|buf
index|[
name|x
operator|->
name|len
operator|++
index|]
operator|=
name|op
expr_stmt|;
name|x
operator|->
name|buf
index|[
name|x
operator|->
name|len
operator|++
index|]
operator|=
name|n
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Append a sign-extension instruction to EXPR, to extend an N-bit value.  */
end_comment

begin_function
name|void
name|ax_ext
parameter_list|(
name|x
parameter_list|,
name|n
parameter_list|)
name|struct
name|agent_expr
modifier|*
name|x
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|generic_ext
argument_list|(
name|x
argument_list|,
name|aop_ext
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Append a zero-extension instruction to EXPR, to extend an N-bit value.  */
end_comment

begin_function
name|void
name|ax_zero_ext
parameter_list|(
name|x
parameter_list|,
name|n
parameter_list|)
name|struct
name|agent_expr
modifier|*
name|x
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|generic_ext
argument_list|(
name|x
argument_list|,
name|aop_zero_ext
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Append a trace_quick instruction to EXPR, to record N bytes.  */
end_comment

begin_function
name|void
name|ax_trace_quick
parameter_list|(
name|x
parameter_list|,
name|n
parameter_list|)
name|struct
name|agent_expr
modifier|*
name|x
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
comment|/* N must fit in a byte.  */
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>
literal|255
condition|)
name|error
argument_list|(
literal|"GDB bug: ax-general.c (ax_trace_quick): size out of range for trace_quick"
argument_list|)
expr_stmt|;
name|grow_expr
argument_list|(
name|x
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|x
operator|->
name|buf
index|[
name|x
operator|->
name|len
operator|++
index|]
operator|=
name|aop_trace_quick
expr_stmt|;
name|x
operator|->
name|buf
index|[
name|x
operator|->
name|len
operator|++
index|]
operator|=
name|n
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Append a goto op to EXPR.  OP is the actual op (must be aop_goto or    aop_if_goto).  We assume we don't know the target offset yet,    because it's probably a forward branch, so we leave space in EXPR    for the target, and return the offset in EXPR of that space, so we    can backpatch it once we do know the target offset.  Use ax_label    to do the backpatching.  */
end_comment

begin_function
name|int
name|ax_goto
parameter_list|(
name|x
parameter_list|,
name|op
parameter_list|)
name|struct
name|agent_expr
modifier|*
name|x
decl_stmt|;
name|enum
name|agent_op
name|op
decl_stmt|;
block|{
name|grow_expr
argument_list|(
name|x
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|x
operator|->
name|buf
index|[
name|x
operator|->
name|len
operator|+
literal|0
index|]
operator|=
name|op
expr_stmt|;
name|x
operator|->
name|buf
index|[
name|x
operator|->
name|len
operator|+
literal|1
index|]
operator|=
literal|0xff
expr_stmt|;
name|x
operator|->
name|buf
index|[
name|x
operator|->
name|len
operator|+
literal|2
index|]
operator|=
literal|0xff
expr_stmt|;
name|x
operator|->
name|len
operator|+=
literal|3
expr_stmt|;
return|return
name|x
operator|->
name|len
operator|-
literal|2
return|;
block|}
end_function

begin_comment
comment|/* Suppose a given call to ax_goto returns some value PATCH.  When you    know the offset TARGET that goto should jump to, call 	ax_label (EXPR, PATCH, TARGET)    to patch TARGET into the ax_goto instruction.  */
end_comment

begin_function
name|void
name|ax_label
parameter_list|(
name|x
parameter_list|,
name|patch
parameter_list|,
name|target
parameter_list|)
name|struct
name|agent_expr
modifier|*
name|x
decl_stmt|;
name|int
name|patch
decl_stmt|;
name|int
name|target
decl_stmt|;
block|{
comment|/* Make sure the value is in range.  Don't accept 0xffff as an      offset; that's our magic sentinel value for unpatched branches.  */
if|if
condition|(
name|target
operator|<
literal|0
operator|||
name|target
operator|>=
literal|0xffff
condition|)
name|error
argument_list|(
literal|"GDB bug: ax-general.c (ax_label): label target out of range"
argument_list|)
expr_stmt|;
name|x
operator|->
name|buf
index|[
name|patch
index|]
operator|=
operator|(
name|target
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|x
operator|->
name|buf
index|[
name|patch
operator|+
literal|1
index|]
operator|=
name|target
operator|&
literal|0xff
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Assemble code to push a constant on the stack.  */
end_comment

begin_function
name|void
name|ax_const_l
parameter_list|(
name|x
parameter_list|,
name|l
parameter_list|)
name|struct
name|agent_expr
modifier|*
name|x
decl_stmt|;
name|LONGEST
name|l
decl_stmt|;
block|{
specifier|static
name|enum
name|agent_op
name|ops
index|[]
init|=
block|{
name|aop_const8
block|,
name|aop_const16
block|,
name|aop_const32
block|,
name|aop_const64
block|}
decl_stmt|;
name|int
name|size
decl_stmt|;
name|int
name|op
decl_stmt|;
comment|/* How big is the number?  'op' keeps track of which opcode to use.      Notice that we don't really care whether the original number was      signed or unsigned; we always reproduce the value exactly, and      use the shortest representation.  */
for|for
control|(
name|op
operator|=
literal|0
operator|,
name|size
operator|=
literal|8
init|;
name|size
operator|<
literal|64
condition|;
name|size
operator|*=
literal|2
operator|,
name|op
operator|++
control|)
if|if
condition|(
operator|-
operator|(
operator|(
name|LONGEST
operator|)
literal|1
operator|<<
name|size
operator|)
operator|<=
name|l
operator|&&
name|l
operator|<
operator|(
operator|(
name|LONGEST
operator|)
literal|1
operator|<<
name|size
operator|)
condition|)
break|break;
comment|/* Emit the right opcode... */
name|ax_simple
argument_list|(
name|x
argument_list|,
name|ops
index|[
name|op
index|]
argument_list|)
expr_stmt|;
comment|/* Emit the low SIZE bytes as an unsigned number.  We know that      sign-extending this will yield l.  */
name|append_const
argument_list|(
name|x
argument_list|,
name|l
argument_list|,
name|size
operator|/
literal|8
argument_list|)
expr_stmt|;
comment|/* Now, if it was negative, and not full-sized, sign-extend it.  */
if|if
condition|(
name|l
operator|<
literal|0
operator|&&
name|size
operator|<
literal|64
condition|)
name|ax_ext
argument_list|(
name|x
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ax_const_d
parameter_list|(
name|x
parameter_list|,
name|d
parameter_list|)
name|struct
name|agent_expr
modifier|*
name|x
decl_stmt|;
name|LONGEST
name|d
decl_stmt|;
block|{
comment|/* FIXME: floating-point support not present yet.  */
name|error
argument_list|(
literal|"GDB bug: ax-general.c (ax_const_d): floating point not supported yet"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Assemble code to push the value of register number REG on the    stack.  */
end_comment

begin_function
name|void
name|ax_reg
parameter_list|(
name|x
parameter_list|,
name|reg
parameter_list|)
name|struct
name|agent_expr
modifier|*
name|x
decl_stmt|;
name|int
name|reg
decl_stmt|;
block|{
comment|/* Make sure the register number is in range.  */
if|if
condition|(
name|reg
operator|<
literal|0
operator|||
name|reg
operator|>
literal|0xffff
condition|)
name|error
argument_list|(
literal|"GDB bug: ax-general.c (ax_reg): register number out of range"
argument_list|)
expr_stmt|;
name|grow_expr
argument_list|(
name|x
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|x
operator|->
name|buf
index|[
name|x
operator|->
name|len
index|]
operator|=
name|aop_reg
expr_stmt|;
name|x
operator|->
name|buf
index|[
name|x
operator|->
name|len
operator|+
literal|1
index|]
operator|=
operator|(
name|reg
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|x
operator|->
name|buf
index|[
name|x
operator|->
name|len
operator|+
literal|2
index|]
operator|=
operator|(
name|reg
operator|)
operator|&
literal|0xff
expr_stmt|;
name|x
operator|->
name|len
operator|+=
literal|3
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions for disassembling agent expressions, and otherwise    debugging the expression compiler.  */
end_comment

begin_decl_stmt
name|struct
name|aop_map
name|aop_map
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"float"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 0x01 */
block|{
literal|"add"
block|,
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|1
block|}
block|,
comment|/* 0x02 */
block|{
literal|"sub"
block|,
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|1
block|}
block|,
comment|/* 0x03 */
block|{
literal|"mul"
block|,
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|1
block|}
block|,
comment|/* 0x04 */
block|{
literal|"div_signed"
block|,
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|1
block|}
block|,
comment|/* 0x05 */
block|{
literal|"div_unsigned"
block|,
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|1
block|}
block|,
comment|/* 0x06 */
block|{
literal|"rem_signed"
block|,
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|1
block|}
block|,
comment|/* 0x07 */
block|{
literal|"rem_unsigned"
block|,
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|1
block|}
block|,
comment|/* 0x08 */
block|{
literal|"lsh"
block|,
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|1
block|}
block|,
comment|/* 0x09 */
block|{
literal|"rsh_signed"
block|,
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|1
block|}
block|,
comment|/* 0x0a */
block|{
literal|"rsh_unsigned"
block|,
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|1
block|}
block|,
comment|/* 0x0b */
block|{
literal|"trace"
block|,
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|}
block|,
comment|/* 0x0c */
block|{
literal|"trace_quick"
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* 0x0d */
block|{
literal|"log_not"
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* 0x0e */
block|{
literal|"bit_and"
block|,
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|1
block|}
block|,
comment|/* 0x0f */
block|{
literal|"bit_or"
block|,
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|1
block|}
block|,
comment|/* 0x10 */
block|{
literal|"bit_xor"
block|,
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|1
block|}
block|,
comment|/* 0x11 */
block|{
literal|"bit_not"
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* 0x12 */
block|{
literal|"equal"
block|,
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|1
block|}
block|,
comment|/* 0x13 */
block|{
literal|"less_signed"
block|,
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|1
block|}
block|,
comment|/* 0x14 */
block|{
literal|"less_unsigned"
block|,
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|1
block|}
block|,
comment|/* 0x15 */
block|{
literal|"ext"
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* 0x16 */
block|{
literal|"ref8"
block|,
literal|0
block|,
literal|8
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* 0x17 */
block|{
literal|"ref16"
block|,
literal|0
block|,
literal|16
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* 0x18 */
block|{
literal|"ref32"
block|,
literal|0
block|,
literal|32
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* 0x19 */
block|{
literal|"ref64"
block|,
literal|0
block|,
literal|64
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* 0x1a */
block|{
literal|"ref_float"
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* 0x1b */
block|{
literal|"ref_double"
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* 0x1c */
block|{
literal|"ref_long_double"
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* 0x1d */
block|{
literal|"l_to_d"
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* 0x1e */
block|{
literal|"d_to_l"
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* 0x1f */
block|{
literal|"if_goto"
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* 0x20 */
block|{
literal|"goto"
block|,
literal|2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 0x21 */
block|{
literal|"const8"
block|,
literal|1
block|,
literal|8
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* 0x22 */
block|{
literal|"const16"
block|,
literal|2
block|,
literal|16
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* 0x23 */
block|{
literal|"const32"
block|,
literal|4
block|,
literal|32
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* 0x24 */
block|{
literal|"const64"
block|,
literal|8
block|,
literal|64
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* 0x25 */
block|{
literal|"reg"
block|,
literal|2
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
block|,
comment|/* 0x26 */
block|{
literal|"end"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 0x27 */
block|{
literal|"dup"
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|}
block|,
comment|/* 0x28 */
block|{
literal|"pop"
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
block|,
comment|/* 0x29 */
block|{
literal|"zero_ext"
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* 0x2a */
block|{
literal|"swap"
block|,
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|2
block|}
block|,
comment|/* 0x2b */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 0x2c */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 0x2d */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 0x2e */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* 0x2f */
block|{
literal|"trace16"
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
block|,
comment|/* 0x30 */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Disassemble the expression EXPR, writing to F.  */
end_comment

begin_function
name|void
name|ax_print
parameter_list|(
name|f
parameter_list|,
name|x
parameter_list|)
name|GDB_FILE
modifier|*
name|f
decl_stmt|;
name|struct
name|agent_expr
modifier|*
name|x
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|is_float
init|=
literal|0
decl_stmt|;
comment|/* Check the size of the name array against the number of entries in      the enum, to catch additions that people didn't sync.  */
if|if
condition|(
operator|(
sizeof|sizeof
argument_list|(
name|aop_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|aop_map
index|[
literal|0
index|]
argument_list|)
operator|)
operator|!=
name|aop_last
condition|)
name|error
argument_list|(
literal|"GDB bug: ax-general.c (ax_print): opcode map out of sync"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|x
operator|->
name|len
condition|;
control|)
block|{
name|enum
name|agent_op
name|op
init|=
name|x
operator|->
name|buf
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|op
operator|>=
operator|(
sizeof|sizeof
argument_list|(
name|aop_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|aop_map
index|[
literal|0
index|]
argument_list|)
operator|)
operator|||
operator|!
name|aop_map
index|[
name|op
index|]
operator|.
name|name
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|f
argument_list|,
literal|"%3d<bad opcode %02x>\n"
argument_list|,
name|i
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|i
operator|+
literal|1
operator|+
name|aop_map
index|[
name|op
index|]
operator|.
name|op_size
operator|>
name|x
operator|->
name|len
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|f
argument_list|,
literal|"%3d<incomplete opcode %s>\n"
argument_list|,
name|i
argument_list|,
name|aop_map
index|[
name|op
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
name|fprintf_filtered
argument_list|(
name|f
argument_list|,
literal|"%3d  %s"
argument_list|,
name|i
argument_list|,
name|aop_map
index|[
name|op
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|aop_map
index|[
name|op
index|]
operator|.
name|op_size
operator|>
literal|0
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|print_longest
argument_list|(
name|f
argument_list|,
literal|'d'
argument_list|,
literal|0
argument_list|,
name|read_const
argument_list|(
name|x
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|aop_map
index|[
name|op
index|]
operator|.
name|op_size
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|f
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|1
operator|+
name|aop_map
index|[
name|op
index|]
operator|.
name|op_size
expr_stmt|;
name|is_float
operator|=
operator|(
name|op
operator|==
name|aop_float
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Given an agent expression AX, fill in an agent_reqs structure REQS    describing it.  */
end_comment

begin_function
name|void
name|ax_reqs
parameter_list|(
name|ax
parameter_list|,
name|reqs
parameter_list|)
name|struct
name|agent_expr
modifier|*
name|ax
decl_stmt|;
name|struct
name|agent_reqs
modifier|*
name|reqs
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|height
decl_stmt|;
comment|/* Bit vector for registers used.  */
name|int
name|reg_mask_len
init|=
literal|1
decl_stmt|;
name|unsigned
name|char
modifier|*
name|reg_mask
init|=
name|xmalloc
argument_list|(
name|reg_mask_len
operator|*
sizeof|sizeof
argument_list|(
name|reg_mask
index|[
literal|0
index|]
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Jump target table.  targets[i] is non-zero iff there is a jump to      offset i.  */
name|char
modifier|*
name|targets
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|ax
operator|->
name|len
operator|*
sizeof|sizeof
argument_list|(
name|targets
index|[
literal|0
index|]
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Instruction boundary table.  boundary[i] is non-zero iff an      instruction starts at offset i.  */
name|char
modifier|*
name|boundary
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|ax
operator|->
name|len
operator|*
sizeof|sizeof
argument_list|(
name|boundary
index|[
literal|0
index|]
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Stack height record.  iff either targets[i] or boundary[i] is      non-zero, heights[i] is the height the stack should have before      executing the bytecode at that point.  */
name|int
modifier|*
name|heights
init|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|ax
operator|->
name|len
operator|*
sizeof|sizeof
argument_list|(
name|heights
index|[
literal|0
index|]
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Pointer to a description of the present op.  */
name|struct
name|aop_map
modifier|*
name|op
decl_stmt|;
name|memset
argument_list|(
name|reg_mask
argument_list|,
literal|0
argument_list|,
name|reg_mask_len
operator|*
sizeof|sizeof
argument_list|(
name|reg_mask
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|targets
argument_list|,
literal|0
argument_list|,
name|ax
operator|->
name|len
operator|*
sizeof|sizeof
argument_list|(
name|targets
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|boundary
argument_list|,
literal|0
argument_list|,
name|ax
operator|->
name|len
operator|*
sizeof|sizeof
argument_list|(
name|boundary
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|reqs
operator|->
name|max_height
operator|=
name|reqs
operator|->
name|min_height
operator|=
name|height
operator|=
literal|0
expr_stmt|;
name|reqs
operator|->
name|flaw
operator|=
name|agent_flaw_none
expr_stmt|;
name|reqs
operator|->
name|max_data_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ax
operator|->
name|len
condition|;
name|i
operator|+=
literal|1
operator|+
name|op
operator|->
name|op_size
control|)
block|{
if|if
condition|(
name|ax
operator|->
name|buf
index|[
name|i
index|]
operator|>
operator|(
sizeof|sizeof
argument_list|(
name|aop_map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|aop_map
index|[
literal|0
index|]
argument_list|)
operator|)
condition|)
block|{
name|reqs
operator|->
name|flaw
operator|=
name|agent_flaw_bad_instruction
expr_stmt|;
name|free
argument_list|(
name|reg_mask
argument_list|)
expr_stmt|;
return|return;
block|}
name|op
operator|=
operator|&
name|aop_map
index|[
name|ax
operator|->
name|buf
index|[
name|i
index|]
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|op
operator|->
name|name
condition|)
block|{
name|reqs
operator|->
name|flaw
operator|=
name|agent_flaw_bad_instruction
expr_stmt|;
name|free
argument_list|(
name|reg_mask
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|i
operator|+
literal|1
operator|+
name|op
operator|->
name|op_size
operator|>
name|ax
operator|->
name|len
condition|)
block|{
name|reqs
operator|->
name|flaw
operator|=
name|agent_flaw_incomplete_instruction
expr_stmt|;
name|free
argument_list|(
name|reg_mask
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If this instruction is a jump target, does the current stack          height match the stack height at the jump source?  */
if|if
condition|(
name|targets
index|[
name|i
index|]
operator|&&
operator|(
name|heights
index|[
name|i
index|]
operator|!=
name|height
operator|)
condition|)
block|{
name|reqs
operator|->
name|flaw
operator|=
name|agent_flaw_height_mismatch
expr_stmt|;
name|free
argument_list|(
name|reg_mask
argument_list|)
expr_stmt|;
return|return;
block|}
name|boundary
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|heights
index|[
name|i
index|]
operator|=
name|height
expr_stmt|;
name|height
operator|-=
name|op
operator|->
name|consumed
expr_stmt|;
if|if
condition|(
name|height
operator|<
name|reqs
operator|->
name|min_height
condition|)
name|reqs
operator|->
name|min_height
operator|=
name|height
expr_stmt|;
name|height
operator|+=
name|op
operator|->
name|produced
expr_stmt|;
if|if
condition|(
name|height
operator|>
name|reqs
operator|->
name|max_height
condition|)
name|reqs
operator|->
name|max_height
operator|=
name|height
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|data_size
operator|>
name|reqs
operator|->
name|max_data_size
condition|)
name|reqs
operator|->
name|max_data_size
operator|=
name|op
operator|->
name|data_size
expr_stmt|;
comment|/* For jump instructions, check that the target is a valid 	 offset.  If it is, record the fact that that location is a 	 jump target, and record the height we expect there.  */
if|if
condition|(
name|aop_goto
operator|==
name|op
operator|-
name|aop_map
operator|||
name|aop_if_goto
operator|==
name|op
operator|-
name|aop_map
condition|)
block|{
name|int
name|target
init|=
name|read_const
argument_list|(
name|ax
argument_list|,
name|i
operator|+
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|target
operator|<
literal|0
operator|||
name|target
operator|>=
name|ax
operator|->
name|len
condition|)
block|{
name|reqs
operator|->
name|flaw
operator|=
name|agent_flaw_bad_jump
expr_stmt|;
name|free
argument_list|(
name|reg_mask
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Have we already found other jumps to the same location?  */
elseif|else
if|if
condition|(
name|targets
index|[
name|target
index|]
condition|)
block|{
if|if
condition|(
name|heights
index|[
name|i
index|]
operator|!=
name|height
condition|)
block|{
name|reqs
operator|->
name|flaw
operator|=
name|agent_flaw_height_mismatch
expr_stmt|;
name|free
argument_list|(
name|reg_mask
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|targets
index|[
name|target
index|]
operator|=
literal|1
expr_stmt|;
name|heights
index|[
name|target
index|]
operator|=
name|height
expr_stmt|;
block|}
block|}
comment|/* For unconditional jumps with a successor, check that the          successor is a target, and pick up its stack height.  */
if|if
condition|(
name|aop_goto
operator|==
name|op
operator|-
name|aop_map
operator|&&
name|i
operator|+
literal|3
operator|<
name|ax
operator|->
name|len
condition|)
block|{
if|if
condition|(
operator|!
name|targets
index|[
name|i
operator|+
literal|3
index|]
condition|)
block|{
name|reqs
operator|->
name|flaw
operator|=
name|agent_flaw_hole
expr_stmt|;
name|free
argument_list|(
name|reg_mask
argument_list|)
expr_stmt|;
return|return;
block|}
name|height
operator|=
name|heights
index|[
name|i
operator|+
literal|3
index|]
expr_stmt|;
block|}
comment|/* For reg instructions, record the register in the bit mask.  */
if|if
condition|(
name|aop_reg
operator|==
name|op
operator|-
name|aop_map
condition|)
block|{
name|int
name|reg
init|=
name|read_const
argument_list|(
name|ax
argument_list|,
name|i
operator|+
literal|1
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|int
name|byte
init|=
name|reg
operator|/
literal|8
decl_stmt|;
comment|/* Grow the bit mask if necessary.  */
if|if
condition|(
name|byte
operator|>=
name|reg_mask_len
condition|)
block|{
comment|/* It's not appropriate to double here.  This isn't a                  string buffer.  */
name|int
name|new_len
init|=
name|byte
operator|+
literal|1
decl_stmt|;
name|reg_mask
operator|=
name|xrealloc
argument_list|(
name|reg_mask
argument_list|,
name|new_len
operator|*
sizeof|sizeof
argument_list|(
name|reg_mask
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|reg_mask
operator|+
name|reg_mask_len
argument_list|,
literal|0
argument_list|,
operator|(
name|new_len
operator|-
name|reg_mask_len
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|reg_mask
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|reg_mask_len
operator|=
name|new_len
expr_stmt|;
block|}
name|reg_mask
index|[
name|byte
index|]
operator||=
literal|1
operator|<<
operator|(
name|reg
operator|%
literal|8
operator|)
expr_stmt|;
block|}
block|}
comment|/* Check that all the targets are on boundaries.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ax
operator|->
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|targets
index|[
name|i
index|]
operator|&&
operator|!
name|boundary
index|[
name|i
index|]
condition|)
block|{
name|reqs
operator|->
name|flaw
operator|=
name|agent_flaw_bad_jump
expr_stmt|;
name|free
argument_list|(
name|reg_mask
argument_list|)
expr_stmt|;
return|return;
block|}
name|reqs
operator|->
name|final_height
operator|=
name|height
expr_stmt|;
name|reqs
operator|->
name|reg_mask_len
operator|=
name|reg_mask_len
expr_stmt|;
name|reqs
operator|->
name|reg_mask
operator|=
name|reg_mask
expr_stmt|;
block|}
end_function

end_unit

