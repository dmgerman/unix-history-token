begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Support routines for building symbol tables in GDB's internal format.    Copyright 1986-1999 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This module provides subroutines used for creating and adding to    the symbol table.  These routines are called from various symbol-    file-reading routines.     Routines to support specific debugging information formats (stabs,    DWARF, etc) belong somewhere else. */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_comment
comment|/* Needed for "struct complaint" */
end_comment

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"complaints.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_comment
comment|/* Ask buildsym.h to define the vars it normally declares `extern'.  */
end_comment

begin_define
define|#
directive|define
name|EXTERN
end_define

begin_comment
comment|/**/
end_comment

begin_include
include|#
directive|include
file|"buildsym.h"
end_include

begin_comment
comment|/* Our own declarations */
end_comment

begin_undef
undef|#
directive|undef
name|EXTERN
end_undef

begin_comment
comment|/* For cleanup_undefined_types and finish_global_stabs (somewhat    questionable--see comment where we call them).  */
end_comment

begin_include
include|#
directive|include
file|"stabsread.h"
end_include

begin_comment
comment|/* List of free `struct pending' structures for reuse.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pending
modifier|*
name|free_pendings
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if symtab has line number info.  This prevents an    otherwise empty symtab from being tossed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|have_line_numbers
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function_decl
specifier|static
name|int
name|compare_line_numbers
parameter_list|(
specifier|const
name|void
modifier|*
name|ln1p
parameter_list|,
specifier|const
name|void
modifier|*
name|ln2p
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Initial sizes of data structures.  These are realloc'd larger if    needed, and realloc'd down to the size actually used, when    completed.  */
end_comment

begin_define
define|#
directive|define
name|INITIAL_CONTEXT_STACK_SIZE
value|10
end_define

begin_define
define|#
directive|define
name|INITIAL_LINE_VECTOR_LENGTH
value|1000
end_define

begin_escape
end_escape

begin_comment
comment|/* Complaints about the symbols we have encountered.  */
end_comment

begin_decl_stmt
name|struct
name|complaint
name|block_end_complaint
init|=
block|{
literal|"block end address less than block start address in %s (patched it)"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|anon_block_end_complaint
init|=
block|{
literal|"block end address 0x%lx less than block start address 0x%lx (patched it)"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|innerblock_complaint
init|=
block|{
literal|"inner block not inside outer block in %s"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|innerblock_anon_complaint
init|=
block|{
literal|"inner block (0x%lx-0x%lx) not inside outer block (0x%lx-0x%lx)"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|blockvector_complaint
init|=
block|{
literal|"block at 0x%lx out of order"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* maintain the lists of symbols and blocks */
end_comment

begin_comment
comment|/* Add a symbol to one of the lists of symbols.  */
end_comment

begin_function
name|void
name|add_symbol_to_list
parameter_list|(
name|struct
name|symbol
modifier|*
name|symbol
parameter_list|,
name|struct
name|pending
modifier|*
modifier|*
name|listhead
parameter_list|)
block|{
specifier|register
name|struct
name|pending
modifier|*
name|link
decl_stmt|;
comment|/* If this is an alias for another symbol, don't add it.  */
if|if
condition|(
name|symbol
operator|->
name|ginfo
operator|.
name|name
operator|&&
name|symbol
operator|->
name|ginfo
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
return|return;
comment|/* We keep PENDINGSIZE symbols in each link of the list. If we      don't have a link with room in it, add a new link.  */
if|if
condition|(
operator|*
name|listhead
operator|==
name|NULL
operator|||
operator|(
operator|*
name|listhead
operator|)
operator|->
name|nsyms
operator|==
name|PENDINGSIZE
condition|)
block|{
if|if
condition|(
name|free_pendings
condition|)
block|{
name|link
operator|=
name|free_pendings
expr_stmt|;
name|free_pendings
operator|=
name|link
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|link
operator|=
operator|(
expr|struct
name|pending
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pending
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|link
operator|->
name|next
operator|=
operator|*
name|listhead
expr_stmt|;
operator|*
name|listhead
operator|=
name|link
expr_stmt|;
name|link
operator|->
name|nsyms
operator|=
literal|0
expr_stmt|;
block|}
operator|(
operator|*
name|listhead
operator|)
operator|->
name|symbol
index|[
operator|(
operator|*
name|listhead
operator|)
operator|->
name|nsyms
operator|++
index|]
operator|=
name|symbol
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find a symbol named NAME on a LIST.  NAME need not be    '\0'-terminated; LENGTH is the length of the name.  */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|find_symbol_in_list
parameter_list|(
name|struct
name|pending
modifier|*
name|list
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|j
decl_stmt|;
name|char
modifier|*
name|pp
decl_stmt|;
while|while
condition|(
name|list
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|j
operator|=
name|list
operator|->
name|nsyms
init|;
operator|--
name|j
operator|>=
literal|0
condition|;
control|)
block|{
name|pp
operator|=
name|SYMBOL_NAME
argument_list|(
name|list
operator|->
name|symbol
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pp
operator|==
operator|*
name|name
operator|&&
name|strncmp
argument_list|(
name|pp
argument_list|,
name|name
argument_list|,
name|length
argument_list|)
operator|==
literal|0
operator|&&
name|pp
index|[
name|length
index|]
operator|==
literal|'\0'
condition|)
block|{
return|return
operator|(
name|list
operator|->
name|symbol
index|[
name|j
index|]
operator|)
return|;
block|}
block|}
name|list
operator|=
name|list
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* At end of reading syms, or in case of quit, really free as many    `struct pending's as we can easily find. */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|really_free_pendings
parameter_list|(
name|int
name|foo
parameter_list|)
block|{
name|struct
name|pending
modifier|*
name|next
decl_stmt|,
modifier|*
name|next1
decl_stmt|;
for|for
control|(
name|next
operator|=
name|free_pendings
init|;
name|next
condition|;
name|next
operator|=
name|next1
control|)
block|{
name|next1
operator|=
name|next
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|next
argument_list|)
expr_stmt|;
block|}
name|free_pendings
operator|=
name|NULL
expr_stmt|;
name|free_pending_blocks
argument_list|()
expr_stmt|;
for|for
control|(
name|next
operator|=
name|file_symbols
init|;
name|next
operator|!=
name|NULL
condition|;
name|next
operator|=
name|next1
control|)
block|{
name|next1
operator|=
name|next
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|next
argument_list|)
expr_stmt|;
block|}
name|file_symbols
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|next
operator|=
name|global_symbols
init|;
name|next
operator|!=
name|NULL
condition|;
name|next
operator|=
name|next1
control|)
block|{
name|next1
operator|=
name|next
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|next
argument_list|)
expr_stmt|;
block|}
name|global_symbols
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is called to discard any pending blocks. */
end_comment

begin_function
name|void
name|free_pending_blocks
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
literal|0
comment|/* Now we make the links in the 				   symbol_obstack, so don't free 				   them.  */
block|struct pending_block *bnext, *bnext1;    for (bnext = pending_blocks; bnext; bnext = bnext1)     {       bnext1 = bnext->next;       free ((void *) bnext);     }
endif|#
directive|endif
name|pending_blocks
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Take one of the lists of symbols and make a block from it.  Keep    the order the symbols have in the list (reversed from the input    file).  Put the block on the list of pending blocks.  */
end_comment

begin_function
name|void
name|finish_block
parameter_list|(
name|struct
name|symbol
modifier|*
name|symbol
parameter_list|,
name|struct
name|pending
modifier|*
modifier|*
name|listhead
parameter_list|,
name|struct
name|pending_block
modifier|*
name|old_blocks
parameter_list|,
name|CORE_ADDR
name|start
parameter_list|,
name|CORE_ADDR
name|end
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
specifier|register
name|struct
name|pending
modifier|*
name|next
decl_stmt|,
modifier|*
name|next1
decl_stmt|;
specifier|register
name|struct
name|block
modifier|*
name|block
decl_stmt|;
specifier|register
name|struct
name|pending_block
modifier|*
name|pblock
decl_stmt|;
name|struct
name|pending_block
modifier|*
name|opblock
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
comment|/* Count the length of the list of symbols.  */
for|for
control|(
name|next
operator|=
operator|*
name|listhead
operator|,
name|i
operator|=
literal|0
init|;
name|next
condition|;
name|i
operator|+=
name|next
operator|->
name|nsyms
operator|,
name|next
operator|=
name|next
operator|->
name|next
control|)
block|{
comment|/* EMPTY */
empty_stmt|;
block|}
name|block
operator|=
operator|(
expr|struct
name|block
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|block
argument_list|)
operator|+
operator|(
operator|(
name|i
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
operator|*
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Copy the symbols into the block.  */
name|BLOCK_NSYMS
argument_list|(
name|block
argument_list|)
operator|=
name|i
expr_stmt|;
for|for
control|(
name|next
operator|=
operator|*
name|listhead
init|;
name|next
condition|;
name|next
operator|=
name|next
operator|->
name|next
control|)
block|{
for|for
control|(
name|j
operator|=
name|next
operator|->
name|nsyms
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|BLOCK_SYM
argument_list|(
name|block
argument_list|,
operator|--
name|i
argument_list|)
operator|=
name|next
operator|->
name|symbol
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
name|BLOCK_START
argument_list|(
name|block
argument_list|)
operator|=
name|start
expr_stmt|;
name|BLOCK_END
argument_list|(
name|block
argument_list|)
operator|=
name|end
expr_stmt|;
comment|/* Superblock filled in when containing block is made */
name|BLOCK_SUPERBLOCK
argument_list|(
name|block
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|BLOCK_GCC_COMPILED
argument_list|(
name|block
argument_list|)
operator|=
name|processing_gcc_compilation
expr_stmt|;
comment|/* Put the block in as the value of the symbol that names it.  */
if|if
condition|(
name|symbol
condition|)
block|{
name|struct
name|type
modifier|*
name|ftype
init|=
name|SYMBOL_TYPE
argument_list|(
name|symbol
argument_list|)
decl_stmt|;
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|symbol
argument_list|)
operator|=
name|block
expr_stmt|;
name|BLOCK_FUNCTION
argument_list|(
name|block
argument_list|)
operator|=
name|symbol
expr_stmt|;
if|if
condition|(
name|TYPE_NFIELDS
argument_list|(
name|ftype
argument_list|)
operator|<=
literal|0
condition|)
block|{
comment|/* No parameter type information is recorded with the 	     function's type.  Set that from the type of the 	     parameter symbols. */
name|int
name|nparams
init|=
literal|0
decl_stmt|,
name|iparams
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BLOCK_NSYMS
argument_list|(
name|block
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|block
argument_list|,
name|i
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
condition|)
block|{
case|case
name|LOC_ARG
case|:
case|case
name|LOC_REF_ARG
case|:
case|case
name|LOC_REGPARM
case|:
case|case
name|LOC_REGPARM_ADDR
case|:
case|case
name|LOC_BASEREG_ARG
case|:
case|case
name|LOC_LOCAL_ARG
case|:
name|nparams
operator|++
expr_stmt|;
break|break;
case|case
name|LOC_UNDEF
case|:
case|case
name|LOC_CONST
case|:
case|case
name|LOC_STATIC
case|:
case|case
name|LOC_INDIRECT
case|:
case|case
name|LOC_REGISTER
case|:
case|case
name|LOC_LOCAL
case|:
case|case
name|LOC_TYPEDEF
case|:
case|case
name|LOC_LABEL
case|:
case|case
name|LOC_BLOCK
case|:
case|case
name|LOC_CONST_BYTES
case|:
case|case
name|LOC_BASEREG
case|:
case|case
name|LOC_UNRESOLVED
case|:
case|case
name|LOC_OPTIMIZED_OUT
case|:
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|nparams
operator|>
literal|0
condition|)
block|{
name|TYPE_NFIELDS
argument_list|(
name|ftype
argument_list|)
operator|=
name|nparams
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|ftype
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|ftype
argument_list|,
name|nparams
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|iparams
operator|=
literal|0
init|;
name|iparams
operator|<
name|nparams
condition|;
name|i
operator|++
control|)
block|{
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|block
argument_list|,
name|i
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
condition|)
block|{
case|case
name|LOC_ARG
case|:
case|case
name|LOC_REF_ARG
case|:
case|case
name|LOC_REGPARM
case|:
case|case
name|LOC_REGPARM_ADDR
case|:
case|case
name|LOC_BASEREG_ARG
case|:
case|case
name|LOC_LOCAL_ARG
case|:
name|TYPE_FIELD_TYPE
argument_list|(
name|ftype
argument_list|,
name|iparams
argument_list|)
operator|=
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|iparams
operator|++
expr_stmt|;
break|break;
case|case
name|LOC_UNDEF
case|:
case|case
name|LOC_CONST
case|:
case|case
name|LOC_STATIC
case|:
case|case
name|LOC_INDIRECT
case|:
case|case
name|LOC_REGISTER
case|:
case|case
name|LOC_LOCAL
case|:
case|case
name|LOC_TYPEDEF
case|:
case|case
name|LOC_LABEL
case|:
case|case
name|LOC_BLOCK
case|:
case|case
name|LOC_CONST_BYTES
case|:
case|case
name|LOC_BASEREG
case|:
case|case
name|LOC_UNRESOLVED
case|:
case|case
name|LOC_OPTIMIZED_OUT
case|:
default|default:
break|break;
block|}
block|}
block|}
block|}
block|}
else|else
block|{
name|BLOCK_FUNCTION
argument_list|(
name|block
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Now "free" the links of the list, and empty the list.  */
for|for
control|(
name|next
operator|=
operator|*
name|listhead
init|;
name|next
condition|;
name|next
operator|=
name|next1
control|)
block|{
name|next1
operator|=
name|next
operator|->
name|next
expr_stmt|;
name|next
operator|->
name|next
operator|=
name|free_pendings
expr_stmt|;
name|free_pendings
operator|=
name|next
expr_stmt|;
block|}
operator|*
name|listhead
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
literal|1
comment|/* Check to be sure that the blocks have an end address that is      greater than starting address */
if|if
condition|(
name|BLOCK_END
argument_list|(
name|block
argument_list|)
operator|<
name|BLOCK_START
argument_list|(
name|block
argument_list|)
condition|)
block|{
if|if
condition|(
name|symbol
condition|)
block|{
name|complain
argument_list|(
operator|&
name|block_end_complaint
argument_list|,
name|SYMBOL_SOURCE_NAME
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|complain
argument_list|(
operator|&
name|anon_block_end_complaint
argument_list|,
name|BLOCK_END
argument_list|(
name|block
argument_list|)
argument_list|,
name|BLOCK_START
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Better than nothing */
name|BLOCK_END
argument_list|(
name|block
argument_list|)
operator|=
name|BLOCK_START
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Install this block as the superblock of all blocks made since the      start of this scope that don't have superblocks yet.  */
name|opblock
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|pblock
operator|=
name|pending_blocks
init|;
name|pblock
operator|!=
name|old_blocks
condition|;
name|pblock
operator|=
name|pblock
operator|->
name|next
control|)
block|{
if|if
condition|(
name|BLOCK_SUPERBLOCK
argument_list|(
name|pblock
operator|->
name|block
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|#
directive|if
literal|1
comment|/* Check to be sure the blocks are nested as we receive 	     them. If the compiler/assembler/linker work, this just 	     burns a small amount of time.  */
if|if
condition|(
name|BLOCK_START
argument_list|(
name|pblock
operator|->
name|block
argument_list|)
operator|<
name|BLOCK_START
argument_list|(
name|block
argument_list|)
operator|||
name|BLOCK_END
argument_list|(
name|pblock
operator|->
name|block
argument_list|)
operator|>
name|BLOCK_END
argument_list|(
name|block
argument_list|)
condition|)
block|{
if|if
condition|(
name|symbol
condition|)
block|{
name|complain
argument_list|(
operator|&
name|innerblock_complaint
argument_list|,
name|SYMBOL_SOURCE_NAME
argument_list|(
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|complain
argument_list|(
operator|&
name|innerblock_anon_complaint
argument_list|,
name|BLOCK_START
argument_list|(
name|pblock
operator|->
name|block
argument_list|)
argument_list|,
name|BLOCK_END
argument_list|(
name|pblock
operator|->
name|block
argument_list|)
argument_list|,
name|BLOCK_START
argument_list|(
name|block
argument_list|)
argument_list|,
name|BLOCK_END
argument_list|(
name|block
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|BLOCK_START
argument_list|(
name|pblock
operator|->
name|block
argument_list|)
operator|<
name|BLOCK_START
argument_list|(
name|block
argument_list|)
condition|)
name|BLOCK_START
argument_list|(
name|pblock
operator|->
name|block
argument_list|)
operator|=
name|BLOCK_START
argument_list|(
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|BLOCK_END
argument_list|(
name|pblock
operator|->
name|block
argument_list|)
operator|>
name|BLOCK_END
argument_list|(
name|block
argument_list|)
condition|)
name|BLOCK_END
argument_list|(
name|pblock
operator|->
name|block
argument_list|)
operator|=
name|BLOCK_END
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|BLOCK_SUPERBLOCK
argument_list|(
name|pblock
operator|->
name|block
argument_list|)
operator|=
name|block
expr_stmt|;
block|}
name|opblock
operator|=
name|pblock
expr_stmt|;
block|}
name|record_pending_block
argument_list|(
name|objfile
argument_list|,
name|block
argument_list|,
name|opblock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record BLOCK on the list of all blocks in the file.  Put it after    OPBLOCK, or at the beginning if opblock is NULL.  This puts the    block in the list after all its subblocks.     Allocate the pending block struct in the symbol_obstack to save    time.  This wastes a little space.  FIXME: Is it worth it?  */
end_comment

begin_function
name|void
name|record_pending_block
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|struct
name|block
modifier|*
name|block
parameter_list|,
name|struct
name|pending_block
modifier|*
name|opblock
parameter_list|)
block|{
specifier|register
name|struct
name|pending_block
modifier|*
name|pblock
decl_stmt|;
name|pblock
operator|=
operator|(
expr|struct
name|pending_block
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pending_block
argument_list|)
argument_list|)
expr_stmt|;
name|pblock
operator|->
name|block
operator|=
name|block
expr_stmt|;
if|if
condition|(
name|opblock
condition|)
block|{
name|pblock
operator|->
name|next
operator|=
name|opblock
operator|->
name|next
expr_stmt|;
name|opblock
operator|->
name|next
operator|=
name|pblock
expr_stmt|;
block|}
else|else
block|{
name|pblock
operator|->
name|next
operator|=
name|pending_blocks
expr_stmt|;
name|pending_blocks
operator|=
name|pblock
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Note that this is only used in this file and in dstread.c, which    should be fixed to not need direct access to this function.  When    that is done, it can be made static again. */
end_comment

begin_function
name|struct
name|blockvector
modifier|*
name|make_blockvector
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
specifier|register
name|struct
name|pending_block
modifier|*
name|next
decl_stmt|;
specifier|register
name|struct
name|blockvector
modifier|*
name|blockvector
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Count the length of the list of blocks.  */
for|for
control|(
name|next
operator|=
name|pending_blocks
operator|,
name|i
operator|=
literal|0
init|;
name|next
condition|;
name|next
operator|=
name|next
operator|->
name|next
operator|,
name|i
operator|++
control|)
block|{
empty_stmt|;
block|}
name|blockvector
operator|=
operator|(
expr|struct
name|blockvector
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|blockvector
argument_list|)
operator|+
operator|(
name|i
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|block
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Copy the blocks into the blockvector. This is done in reverse      order, which happens to put the blocks into the proper order      (ascending starting address). finish_block has hair to insert      each block into the list after its subblocks in order to make      sure this is true.  */
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|blockvector
argument_list|)
operator|=
name|i
expr_stmt|;
for|for
control|(
name|next
operator|=
name|pending_blocks
init|;
name|next
condition|;
name|next
operator|=
name|next
operator|->
name|next
control|)
block|{
name|BLOCKVECTOR_BLOCK
argument_list|(
name|blockvector
argument_list|,
operator|--
name|i
argument_list|)
operator|=
name|next
operator|->
name|block
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* Now we make the links in the 				   obstack, so don't free them.  */
comment|/* Now free the links of the list, and empty the list.  */
block|for (next = pending_blocks; next; next = next1)     {       next1 = next->next;       free (next);     }
endif|#
directive|endif
name|pending_blocks
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
literal|1
comment|/* FIXME, shut this off after a while 				   to speed up symbol reading.  */
comment|/* Some compilers output blocks in the wrong order, but we depend on      their being in the right order so we can binary search. Check the      order and moan about it.  FIXME.  */
if|if
condition|(
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|blockvector
argument_list|)
operator|>
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|blockvector
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|BLOCK_START
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|blockvector
argument_list|,
name|i
operator|-
literal|1
argument_list|)
argument_list|)
operator|>
name|BLOCK_START
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|blockvector
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
block|{
comment|/* FIXME-32x64: loses if CORE_ADDR doesn't fit in a 	         long.  Possible solutions include a version of 	         complain which takes a callback, a 	         sprintf_address_numeric to match 	         print_address_numeric, or a way to set up a GDB_FILE 	         which causes sprintf rather than fprintf to be 	         called.  */
name|complain
argument_list|(
operator|&
name|blockvector_complaint
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|BLOCK_START
argument_list|(
name|BLOCKVECTOR_BLOCK
argument_list|(
name|blockvector
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
return|return
operator|(
name|blockvector
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Start recording information about source code that came from an    included (or otherwise merged-in) source file with a different    name.  NAME is the name of the file (cannot be NULL), DIRNAME is    the directory in which it resides (or NULL if not known).  */
end_comment

begin_function
name|void
name|start_subfile
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|dirname
parameter_list|)
block|{
specifier|register
name|struct
name|subfile
modifier|*
name|subfile
decl_stmt|;
comment|/* See if this subfile is already known as a subfile of the current      main source file.  */
for|for
control|(
name|subfile
operator|=
name|subfiles
init|;
name|subfile
condition|;
name|subfile
operator|=
name|subfile
operator|->
name|next
control|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|subfile
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|current_subfile
operator|=
name|subfile
expr_stmt|;
return|return;
block|}
block|}
comment|/* This subfile is not known.  Add an entry for it. Make an entry      for this subfile in the list of all subfiles of the current main      source file.  */
name|subfile
operator|=
operator|(
expr|struct
name|subfile
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|subfile
argument_list|)
argument_list|)
expr_stmt|;
name|subfile
operator|->
name|next
operator|=
name|subfiles
expr_stmt|;
name|subfiles
operator|=
name|subfile
expr_stmt|;
name|current_subfile
operator|=
name|subfile
expr_stmt|;
comment|/* Save its name and compilation directory name */
name|subfile
operator|->
name|name
operator|=
operator|(
name|name
operator|==
name|NULL
operator|)
condition|?
name|NULL
else|:
name|savestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|subfile
operator|->
name|dirname
operator|=
operator|(
name|dirname
operator|==
name|NULL
operator|)
condition|?
name|NULL
else|:
name|savestring
argument_list|(
name|dirname
argument_list|,
name|strlen
argument_list|(
name|dirname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize line-number recording for this subfile.  */
name|subfile
operator|->
name|line_vector
operator|=
name|NULL
expr_stmt|;
comment|/* Default the source language to whatever can be deduced from the      filename.  If nothing can be deduced (such as for a C/C++ include      file with a ".h" extension), then inherit whatever language the      previous subfile had.  This kludgery is necessary because there      is no standard way in some object formats to record the source      language.  Also, when symtabs are allocated we try to deduce a      language then as well, but it is too late for us to use that      information while reading symbols, since symtabs aren't allocated      until after all the symbols have been processed for a given      source file. */
name|subfile
operator|->
name|language
operator|=
name|deduce_language_from_filename
argument_list|(
name|subfile
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|subfile
operator|->
name|language
operator|==
name|language_unknown
operator|&&
name|subfile
operator|->
name|next
operator|!=
name|NULL
condition|)
block|{
name|subfile
operator|->
name|language
operator|=
name|subfile
operator|->
name|next
operator|->
name|language
expr_stmt|;
block|}
comment|/* Initialize the debug format string to NULL.  We may supply it      later via a call to record_debugformat. */
name|subfile
operator|->
name|debugformat
operator|=
name|NULL
expr_stmt|;
comment|/* cfront output is a C program, so in most ways it looks like a C      program.  But to demangle we need to set the language to C++.  We      can distinguish cfront code by the fact that it has #line      directives which specify a file name ending in .C.         So if the filename of this subfile ends in .C, then change the      language of any pending subfiles from C to C++.  We also accept      any other C++ suffixes accepted by deduce_language_from_filename      (in particular, some people use .cxx with cfront).  */
comment|/* Likewise for f2c.  */
if|if
condition|(
name|subfile
operator|->
name|name
condition|)
block|{
name|struct
name|subfile
modifier|*
name|s
decl_stmt|;
name|enum
name|language
name|sublang
init|=
name|deduce_language_from_filename
argument_list|(
name|subfile
operator|->
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|sublang
operator|==
name|language_cplus
operator|||
name|sublang
operator|==
name|language_fortran
condition|)
for|for
control|(
name|s
operator|=
name|subfiles
init|;
name|s
operator|!=
name|NULL
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
name|s
operator|->
name|language
operator|==
name|language_c
condition|)
name|s
operator|->
name|language
operator|=
name|sublang
expr_stmt|;
block|}
comment|/* And patch up this file if necessary.  */
if|if
condition|(
name|subfile
operator|->
name|language
operator|==
name|language_c
operator|&&
name|subfile
operator|->
name|next
operator|!=
name|NULL
operator|&&
operator|(
name|subfile
operator|->
name|next
operator|->
name|language
operator|==
name|language_cplus
operator|||
name|subfile
operator|->
name|next
operator|->
name|language
operator|==
name|language_fortran
operator|)
condition|)
block|{
name|subfile
operator|->
name|language
operator|=
name|subfile
operator|->
name|next
operator|->
name|language
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* For stabs readers, the first N_SO symbol is assumed to be the    source file name, and the subfile struct is initialized using that    assumption.  If another N_SO symbol is later seen, immediately    following the first one, then the first one is assumed to be the    directory name and the second one is really the source file name.     So we have to patch up the subfile struct by moving the old name    value to dirname and remembering the new name.  Some sanity    checking is performed to ensure that the state of the subfile    struct is reasonable and that the old name we are assuming to be a    directory name actually is (by checking for a trailing '/'). */
end_comment

begin_function
name|void
name|patch_subfile_names
parameter_list|(
name|struct
name|subfile
modifier|*
name|subfile
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|subfile
operator|!=
name|NULL
operator|&&
name|subfile
operator|->
name|dirname
operator|==
name|NULL
operator|&&
name|subfile
operator|->
name|name
operator|!=
name|NULL
operator|&&
name|subfile
operator|->
name|name
index|[
name|strlen
argument_list|(
name|subfile
operator|->
name|name
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|subfile
operator|->
name|dirname
operator|=
name|subfile
operator|->
name|name
expr_stmt|;
name|subfile
operator|->
name|name
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|last_source_file
operator|=
name|name
expr_stmt|;
comment|/* Default the source language to whatever can be deduced from          the filename.  If nothing can be deduced (such as for a C/C++          include file with a ".h" extension), then inherit whatever          language the previous subfile had.  This kludgery is          necessary because there is no standard way in some object          formats to record the source language.  Also, when symtabs          are allocated we try to deduce a language then as well, but          it is too late for us to use that information while reading          symbols, since symtabs aren't allocated until after all the          symbols have been processed for a given source file. */
name|subfile
operator|->
name|language
operator|=
name|deduce_language_from_filename
argument_list|(
name|subfile
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|subfile
operator|->
name|language
operator|==
name|language_unknown
operator|&&
name|subfile
operator|->
name|next
operator|!=
name|NULL
condition|)
block|{
name|subfile
operator|->
name|language
operator|=
name|subfile
operator|->
name|next
operator|->
name|language
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handle the N_BINCL and N_EINCL symbol types that act like N_SOL for    switching source files (different subfiles, as we call them) within    one object file, but using a stack rather than in an arbitrary    order.  */
end_comment

begin_function
name|void
name|push_subfile
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|struct
name|subfile_stack
modifier|*
name|tem
init|=
operator|(
expr|struct
name|subfile_stack
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|subfile_stack
argument_list|)
argument_list|)
decl_stmt|;
name|tem
operator|->
name|next
operator|=
name|subfile_stack
expr_stmt|;
name|subfile_stack
operator|=
name|tem
expr_stmt|;
if|if
condition|(
name|current_subfile
operator|==
name|NULL
operator|||
name|current_subfile
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
name|tem
operator|->
name|name
operator|=
name|current_subfile
operator|->
name|name
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|pop_subfile
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|struct
name|subfile_stack
modifier|*
name|link
init|=
name|subfile_stack
decl_stmt|;
if|if
condition|(
name|link
operator|==
name|NULL
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
name|name
operator|=
name|link
operator|->
name|name
expr_stmt|;
name|subfile_stack
operator|=
name|link
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|link
argument_list|)
expr_stmt|;
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add a linetable entry for line number LINE and address PC to the    line vector for SUBFILE.  */
end_comment

begin_function
name|void
name|record_line
parameter_list|(
specifier|register
name|struct
name|subfile
modifier|*
name|subfile
parameter_list|,
name|int
name|line
parameter_list|,
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|struct
name|linetable_entry
modifier|*
name|e
decl_stmt|;
comment|/* Ignore the dummy line number in libg.o */
if|if
condition|(
name|line
operator|==
literal|0xffff
condition|)
block|{
return|return;
block|}
comment|/* Make sure line vector exists and is big enough.  */
if|if
condition|(
operator|!
name|subfile
operator|->
name|line_vector
condition|)
block|{
name|subfile
operator|->
name|line_vector_length
operator|=
name|INITIAL_LINE_VECTOR_LENGTH
expr_stmt|;
name|subfile
operator|->
name|line_vector
operator|=
operator|(
expr|struct
name|linetable
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|linetable
argument_list|)
operator|+
name|subfile
operator|->
name|line_vector_length
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|linetable_entry
argument_list|)
argument_list|)
expr_stmt|;
name|subfile
operator|->
name|line_vector
operator|->
name|nitems
operator|=
literal|0
expr_stmt|;
name|have_line_numbers
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|subfile
operator|->
name|line_vector
operator|->
name|nitems
operator|+
literal|1
operator|>=
name|subfile
operator|->
name|line_vector_length
condition|)
block|{
name|subfile
operator|->
name|line_vector_length
operator|*=
literal|2
expr_stmt|;
name|subfile
operator|->
name|line_vector
operator|=
operator|(
expr|struct
name|linetable
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|subfile
operator|->
name|line_vector
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|linetable
argument_list|)
operator|+
operator|(
name|subfile
operator|->
name|line_vector_length
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|linetable_entry
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|e
operator|=
name|subfile
operator|->
name|line_vector
operator|->
name|item
operator|+
name|subfile
operator|->
name|line_vector
operator|->
name|nitems
operator|++
expr_stmt|;
name|e
operator|->
name|line
operator|=
name|line
expr_stmt|;
name|e
operator|->
name|pc
operator|=
name|pc
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Needed in order to sort line tables from IBM xcoff files.  Sigh!  */
end_comment

begin_function
specifier|static
name|int
name|compare_line_numbers
parameter_list|(
specifier|const
name|void
modifier|*
name|ln1p
parameter_list|,
specifier|const
name|void
modifier|*
name|ln2p
parameter_list|)
block|{
name|struct
name|linetable_entry
modifier|*
name|ln1
init|=
operator|(
expr|struct
name|linetable_entry
operator|*
operator|)
name|ln1p
decl_stmt|;
name|struct
name|linetable_entry
modifier|*
name|ln2
init|=
operator|(
expr|struct
name|linetable_entry
operator|*
operator|)
name|ln2p
decl_stmt|;
comment|/* Note: this code does not assume that CORE_ADDRs can fit in ints.      Please keep it that way.  */
if|if
condition|(
name|ln1
operator|->
name|pc
operator|<
name|ln2
operator|->
name|pc
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ln1
operator|->
name|pc
operator|>
name|ln2
operator|->
name|pc
condition|)
return|return
literal|1
return|;
comment|/* If pc equal, sort by line.  I'm not sure whether this is optimum      behavior (see comment at struct linetable in symtab.h).  */
return|return
name|ln1
operator|->
name|line
operator|-
name|ln2
operator|->
name|line
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Start a new symtab for a new source file.  Called, for example,    when a stabs symbol of type N_SO is seen, or when a DWARF    TAG_compile_unit DIE is seen.  It indicates the start of data for    one original source file.  */
end_comment

begin_function
name|void
name|start_symtab
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|dirname
parameter_list|,
name|CORE_ADDR
name|start_addr
parameter_list|)
block|{
name|last_source_file
operator|=
name|name
expr_stmt|;
name|last_source_start_addr
operator|=
name|start_addr
expr_stmt|;
name|file_symbols
operator|=
name|NULL
expr_stmt|;
name|global_symbols
operator|=
name|NULL
expr_stmt|;
name|within_function
operator|=
literal|0
expr_stmt|;
name|have_line_numbers
operator|=
literal|0
expr_stmt|;
comment|/* Context stack is initially empty.  Allocate first one with room      for 10 levels; reuse it forever afterward.  */
if|if
condition|(
name|context_stack
operator|==
name|NULL
condition|)
block|{
name|context_stack_size
operator|=
name|INITIAL_CONTEXT_STACK_SIZE
expr_stmt|;
name|context_stack
operator|=
operator|(
expr|struct
name|context_stack
operator|*
operator|)
name|xmalloc
argument_list|(
name|context_stack_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|context_stack
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|context_stack_depth
operator|=
literal|0
expr_stmt|;
comment|/* Initialize the list of sub source files with one entry for this      file (the top-level source file).  */
name|subfiles
operator|=
name|NULL
expr_stmt|;
name|current_subfile
operator|=
name|NULL
expr_stmt|;
name|start_subfile
argument_list|(
name|name
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish the symbol definitions for one main source file, close off    all the lexical contexts for that file (creating struct block's for    them), then make the struct symtab for that file and put it in the    list of all such.     END_ADDR is the address of the end of the file's text.  SECTION is    the section number (in objfile->section_offsets) of the blockvector    and linetable.     Note that it is possible for end_symtab() to return NULL.  In    particular, for the DWARF case at least, it will return NULL when    it finds a compilation unit that has exactly one DIE, a    TAG_compile_unit DIE.  This can happen when we link in an object    file that was compiled from an empty source file.  Returning NULL    is probably not the correct thing to do, because then gdb will    never know about this empty file (FIXME). */
end_comment

begin_function
name|struct
name|symtab
modifier|*
name|end_symtab
parameter_list|(
name|CORE_ADDR
name|end_addr
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|int
name|section
parameter_list|)
block|{
specifier|register
name|struct
name|symtab
modifier|*
name|symtab
init|=
name|NULL
decl_stmt|;
specifier|register
name|struct
name|blockvector
modifier|*
name|blockvector
decl_stmt|;
specifier|register
name|struct
name|subfile
modifier|*
name|subfile
decl_stmt|;
specifier|register
name|struct
name|context_stack
modifier|*
name|cstk
decl_stmt|;
name|struct
name|subfile
modifier|*
name|nextsub
decl_stmt|;
comment|/* Finish the lexical context of the last function in the file; pop      the context stack.  */
if|if
condition|(
name|context_stack_depth
operator|>
literal|0
condition|)
block|{
name|cstk
operator|=
name|pop_context
argument_list|()
expr_stmt|;
comment|/* Make a block for the local symbols within.  */
name|finish_block
argument_list|(
name|cstk
operator|->
name|name
argument_list|,
operator|&
name|local_symbols
argument_list|,
name|cstk
operator|->
name|old_blocks
argument_list|,
name|cstk
operator|->
name|start_addr
argument_list|,
name|end_addr
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|context_stack_depth
operator|>
literal|0
condition|)
block|{
comment|/* This is said to happen with SCO.  The old coffread.c 	     code simply emptied the context stack, so we do the 	     same.  FIXME: Find out why it is happening.  This is not 	     believed to happen in most cases (even for coffread.c); 	     it used to be an abort().  */
specifier|static
name|struct
name|complaint
name|msg
init|=
block|{
literal|"Context stack not empty in end_symtab"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|complain
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
name|context_stack_depth
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Reordered executables may have out of order pending blocks; if      OBJF_REORDERED is true, then sort the pending blocks.  */
if|if
condition|(
operator|(
name|objfile
operator|->
name|flags
operator|&
name|OBJF_REORDERED
operator|)
operator|&&
name|pending_blocks
condition|)
block|{
comment|/* FIXME!  Remove this horrid bubble sort and use merge sort!!! */
name|int
name|swapped
decl_stmt|;
do|do
block|{
name|struct
name|pending_block
modifier|*
name|pb
decl_stmt|,
modifier|*
name|pbnext
decl_stmt|;
name|pb
operator|=
name|pending_blocks
expr_stmt|;
name|pbnext
operator|=
name|pb
operator|->
name|next
expr_stmt|;
name|swapped
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|pbnext
condition|)
block|{
comment|/* swap blocks if unordered! */
if|if
condition|(
name|BLOCK_START
argument_list|(
name|pb
operator|->
name|block
argument_list|)
operator|<
name|BLOCK_START
argument_list|(
name|pbnext
operator|->
name|block
argument_list|)
condition|)
block|{
name|struct
name|block
modifier|*
name|tmp
init|=
name|pb
operator|->
name|block
decl_stmt|;
name|pb
operator|->
name|block
operator|=
name|pbnext
operator|->
name|block
expr_stmt|;
name|pbnext
operator|->
name|block
operator|=
name|tmp
expr_stmt|;
name|swapped
operator|=
literal|1
expr_stmt|;
block|}
name|pb
operator|=
name|pbnext
expr_stmt|;
name|pbnext
operator|=
name|pbnext
operator|->
name|next
expr_stmt|;
block|}
block|}
do|while
condition|(
name|swapped
condition|)
do|;
block|}
comment|/* Cleanup any undefined types that have been left hanging around      (this needs to be done before the finish_blocks so that      file_symbols is still good).         Both cleanup_undefined_types and finish_global_stabs are stabs      specific, but harmless for other symbol readers, since on gdb      startup or when finished reading stabs, the state is set so these      are no-ops.  FIXME: Is this handled right in case of QUIT?  Can      we make this cleaner?  */
name|cleanup_undefined_types
argument_list|()
expr_stmt|;
name|finish_global_stabs
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|pending_blocks
operator|==
name|NULL
operator|&&
name|file_symbols
operator|==
name|NULL
operator|&&
name|global_symbols
operator|==
name|NULL
operator|&&
name|have_line_numbers
operator|==
literal|0
condition|)
block|{
comment|/* Ignore symtabs that have no functions with real debugging          info.  */
name|blockvector
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* Define the STATIC_BLOCK& GLOBAL_BLOCK, and build the          blockvector.  */
name|finish_block
argument_list|(
literal|0
argument_list|,
operator|&
name|file_symbols
argument_list|,
literal|0
argument_list|,
name|last_source_start_addr
argument_list|,
name|end_addr
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|finish_block
argument_list|(
literal|0
argument_list|,
operator|&
name|global_symbols
argument_list|,
literal|0
argument_list|,
name|last_source_start_addr
argument_list|,
name|end_addr
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|blockvector
operator|=
name|make_blockvector
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|PROCESS_LINENUMBER_HOOK
define|#
directive|define
name|PROCESS_LINENUMBER_HOOK
parameter_list|()
endif|#
directive|endif
name|PROCESS_LINENUMBER_HOOK
argument_list|()
expr_stmt|;
comment|/* Needed for xcoff. */
comment|/* Now create the symtab objects proper, one for each subfile.  */
comment|/* (The main file is the last one on the chain.)  */
for|for
control|(
name|subfile
operator|=
name|subfiles
init|;
name|subfile
condition|;
name|subfile
operator|=
name|nextsub
control|)
block|{
name|int
name|linetablesize
init|=
literal|0
decl_stmt|;
name|symtab
operator|=
name|NULL
expr_stmt|;
comment|/* If we have blocks of symbols, make a symtab. Otherwise, just          ignore this file and any line number info in it.  */
if|if
condition|(
name|blockvector
condition|)
block|{
if|if
condition|(
name|subfile
operator|->
name|line_vector
condition|)
block|{
name|linetablesize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|linetable
argument_list|)
operator|+
name|subfile
operator|->
name|line_vector
operator|->
name|nitems
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|linetable_entry
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* I think this is artifact from before it went on the 	         obstack. I doubt we'll need the memory between now 	         and when we free it later in this function.  */
comment|/* First, shrink the linetable to make more memory.  */
block|subfile->line_vector = (struct linetable *) 		xrealloc ((char *) subfile->line_vector, linetablesize);
endif|#
directive|endif
comment|/* Like the pending blocks, the line table may be 	         scrambled in reordered executables.  Sort it if 	         OBJF_REORDERED is true.  */
if|if
condition|(
name|objfile
operator|->
name|flags
operator|&
name|OBJF_REORDERED
condition|)
name|qsort
argument_list|(
name|subfile
operator|->
name|line_vector
operator|->
name|item
argument_list|,
name|subfile
operator|->
name|line_vector
operator|->
name|nitems
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|linetable_entry
argument_list|)
argument_list|,
name|compare_line_numbers
argument_list|)
expr_stmt|;
block|}
comment|/* Now, allocate a symbol table.  */
name|symtab
operator|=
name|allocate_symtab
argument_list|(
name|subfile
operator|->
name|name
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Fill in its components.  */
name|symtab
operator|->
name|blockvector
operator|=
name|blockvector
expr_stmt|;
if|if
condition|(
name|subfile
operator|->
name|line_vector
condition|)
block|{
comment|/* Reallocate the line table on the symbol obstack */
name|symtab
operator|->
name|linetable
operator|=
operator|(
expr|struct
name|linetable
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
name|linetablesize
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|symtab
operator|->
name|linetable
argument_list|,
name|subfile
operator|->
name|line_vector
argument_list|,
name|linetablesize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|symtab
operator|->
name|linetable
operator|=
name|NULL
expr_stmt|;
block|}
name|symtab
operator|->
name|block_line_section
operator|=
name|section
expr_stmt|;
if|if
condition|(
name|subfile
operator|->
name|dirname
condition|)
block|{
comment|/* Reallocate the dirname on the symbol obstack */
name|symtab
operator|->
name|dirname
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
name|strlen
argument_list|(
name|subfile
operator|->
name|dirname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|symtab
operator|->
name|dirname
argument_list|,
name|subfile
operator|->
name|dirname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|symtab
operator|->
name|dirname
operator|=
name|NULL
expr_stmt|;
block|}
name|symtab
operator|->
name|free_code
operator|=
name|free_linetable
expr_stmt|;
name|symtab
operator|->
name|free_ptr
operator|=
name|NULL
expr_stmt|;
comment|/* Use whatever language we have been using for this 	     subfile, not the one that was deduced in allocate_symtab 	     from the filename.  We already did our own deducing when 	     we created the subfile, and we may have altered our 	     opinion of what language it is from things we found in 	     the symbols. */
name|symtab
operator|->
name|language
operator|=
name|subfile
operator|->
name|language
expr_stmt|;
comment|/* Save the debug format string (if any) in the symtab */
if|if
condition|(
name|subfile
operator|->
name|debugformat
operator|!=
name|NULL
condition|)
block|{
name|symtab
operator|->
name|debugformat
operator|=
name|obsavestring
argument_list|(
name|subfile
operator|->
name|debugformat
argument_list|,
name|strlen
argument_list|(
name|subfile
operator|->
name|debugformat
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
block|}
comment|/* All symtabs for the main file and the subfiles share a 	     blockvector, so we need to clear primary for everything 	     but the main file.  */
name|symtab
operator|->
name|primary
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|subfile
operator|->
name|name
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|subfile
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|subfile
operator|->
name|dirname
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|subfile
operator|->
name|dirname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|subfile
operator|->
name|line_vector
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|subfile
operator|->
name|line_vector
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|subfile
operator|->
name|debugformat
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|subfile
operator|->
name|debugformat
argument_list|)
expr_stmt|;
block|}
name|nextsub
operator|=
name|subfile
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|subfile
argument_list|)
expr_stmt|;
block|}
comment|/* Set this for the main source file.  */
if|if
condition|(
name|symtab
condition|)
block|{
name|symtab
operator|->
name|primary
operator|=
literal|1
expr_stmt|;
block|}
name|last_source_file
operator|=
name|NULL
expr_stmt|;
name|current_subfile
operator|=
name|NULL
expr_stmt|;
return|return
name|symtab
return|;
block|}
end_function

begin_comment
comment|/* Push a context block.  Args are an identifying nesting level    (checkable when you pop it), and the starting PC address of this    context.  */
end_comment

begin_function
name|struct
name|context_stack
modifier|*
name|push_context
parameter_list|(
name|int
name|desc
parameter_list|,
name|CORE_ADDR
name|valu
parameter_list|)
block|{
specifier|register
name|struct
name|context_stack
modifier|*
name|new
decl_stmt|;
if|if
condition|(
name|context_stack_depth
operator|==
name|context_stack_size
condition|)
block|{
name|context_stack_size
operator|*=
literal|2
expr_stmt|;
name|context_stack
operator|=
operator|(
expr|struct
name|context_stack
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|context_stack
argument_list|,
operator|(
name|context_stack_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|context_stack
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|new
operator|=
operator|&
name|context_stack
index|[
name|context_stack_depth
operator|++
index|]
expr_stmt|;
name|new
operator|->
name|depth
operator|=
name|desc
expr_stmt|;
name|new
operator|->
name|locals
operator|=
name|local_symbols
expr_stmt|;
name|new
operator|->
name|params
operator|=
name|param_symbols
expr_stmt|;
name|new
operator|->
name|old_blocks
operator|=
name|pending_blocks
expr_stmt|;
name|new
operator|->
name|start_addr
operator|=
name|valu
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
name|local_symbols
operator|=
name|NULL
expr_stmt|;
name|param_symbols
operator|=
name|NULL
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compute a small integer hash code for the given name. */
end_comment

begin_function
name|int
name|hashname
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|name
decl_stmt|;
specifier|register
name|int
name|total
init|=
name|p
index|[
literal|0
index|]
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|c
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|total
operator|+=
name|c
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|c
condition|)
block|{
name|c
operator|=
name|p
index|[
literal|2
index|]
expr_stmt|;
name|total
operator|+=
name|c
operator|<<
literal|4
expr_stmt|;
if|if
condition|(
name|c
condition|)
block|{
name|total
operator|+=
name|p
index|[
literal|3
index|]
operator|<<
literal|6
expr_stmt|;
block|}
block|}
comment|/* Ensure result is positive.  */
if|if
condition|(
name|total
operator|<
literal|0
condition|)
block|{
name|total
operator|+=
operator|(
literal|1000
operator|<<
literal|6
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|total
operator|%
name|HASHSIZE
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|record_debugformat
parameter_list|(
name|char
modifier|*
name|format
parameter_list|)
block|{
name|current_subfile
operator|->
name|debugformat
operator|=
name|savestring
argument_list|(
name|format
argument_list|,
name|strlen
argument_list|(
name|format
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Merge the first symbol list SRCLIST into the second symbol list    TARGETLIST by repeated calls to add_symbol_to_list().  This    procedure "frees" each link of SRCLIST by adding it to the    free_pendings list.  Caller must set SRCLIST to a null list after    calling this function.     Void return. */
end_comment

begin_function
name|void
name|merge_symbol_lists
parameter_list|(
name|struct
name|pending
modifier|*
modifier|*
name|srclist
parameter_list|,
name|struct
name|pending
modifier|*
modifier|*
name|targetlist
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|srclist
operator|||
operator|!
operator|*
name|srclist
condition|)
return|return;
comment|/* Merge in elements from current link.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
operator|*
name|srclist
operator|)
operator|->
name|nsyms
condition|;
name|i
operator|++
control|)
name|add_symbol_to_list
argument_list|(
operator|(
operator|*
name|srclist
operator|)
operator|->
name|symbol
index|[
name|i
index|]
argument_list|,
name|targetlist
argument_list|)
expr_stmt|;
comment|/* Recurse on next.  */
name|merge_symbol_lists
argument_list|(
operator|&
operator|(
operator|*
name|srclist
operator|)
operator|->
name|next
argument_list|,
name|targetlist
argument_list|)
expr_stmt|;
comment|/* "Free" the current link.  */
operator|(
operator|*
name|srclist
operator|)
operator|->
name|next
operator|=
name|free_pendings
expr_stmt|;
name|free_pendings
operator|=
operator|(
operator|*
name|srclist
operator|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize anything that needs initializing when starting to read a    fresh piece of a symbol file, e.g. reading in the stuff    corresponding to a psymtab.  */
end_comment

begin_function
name|void
name|buildsym_init
parameter_list|()
block|{
name|free_pendings
operator|=
name|NULL
expr_stmt|;
name|file_symbols
operator|=
name|NULL
expr_stmt|;
name|global_symbols
operator|=
name|NULL
expr_stmt|;
name|pending_blocks
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize anything that needs initializing when a completely new    symbol file is specified (not just adding some symbols from another    file, e.g. a shared library).  */
end_comment

begin_function
name|void
name|buildsym_new_init
parameter_list|()
block|{
name|buildsym_init
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

