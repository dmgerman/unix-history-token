begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Remote debugging interface for Hitachi E7000 ICE, for GDB    Copyright 1993, 1994, 1996 Free Software Foundation, Inc.    Contributed by Cygnus Support.      Written by Steve Chamberlain for Cygnus Support.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* The E7000 is an in-circuit emulator for the Hitachi H8/300-H and    Hitachi-SH processor.  It has serial port and a lan port.       The monitor command set makes it difficult to load large ammounts of    data over the lan without using ftp - so try not to issue load    commands when communicating over ethernet; use the ftpload command.     The monitor pauses for a second when dumping srecords to the serial    line too, so we use a slower per byte mechanism but without the    startup overhead.  Even so, it's pretty slow... */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_include
include|#
directive|include
file|"remote-utils.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|HARD_BREAKPOINTS
end_define

begin_define
define|#
directive|define
name|BC_BREAKPOINTS
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CTRLC
value|0x03
end_define

begin_define
define|#
directive|define
name|ENQ
value|0x05
end_define

begin_define
define|#
directive|define
name|ACK
value|0x06
end_define

begin_define
define|#
directive|define
name|CTRLZ
value|0x1a
end_define

begin_decl_stmt
specifier|extern
name|void
name|notice_quit
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local function declarations.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|e7000_close
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|e7000_fetch_register
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|e7000_store_register
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|e7000_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|e7000_login_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|e7000_ftp_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|e7000_drain_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expect
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expect_full_prompt
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expect_prompt
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Variables. */
end_comment

begin_decl_stmt
specifier|static
name|serial_t
name|e7000_desc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if using the tcp serial driver.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|using_tcp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if using the pc isa card.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|using_pc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|e7000_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declaration */
end_comment

begin_decl_stmt
name|char
modifier|*
name|ENQSTRING
init|=
literal|"\005"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if some routine (as opposed to the user) wants echoing.    FIXME: Do this reentrantly with an extra parameter.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|echo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ctrl_c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|timeout
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Send data to e7000debug.  */
end_comment

begin_function
specifier|static
name|void
name|puts_e7000debug
parameter_list|(
name|buf
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|e7000_desc
condition|)
name|error
argument_list|(
literal|"Use \"target e7000 ...\" first."
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_debug
condition|)
name|printf
argument_list|(
literal|"Sending %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|SERIAL_WRITE
argument_list|(
name|e7000_desc
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"SERIAL_WRITE failed: %s\n"
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* And expect to see it echoed, unless using the pc interface */
if|#
directive|if
literal|0
block|if (!using_pc)
endif|#
directive|endif
name|expect
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|putchar_e7000
parameter_list|(
name|x
parameter_list|)
name|int
name|x
decl_stmt|;
block|{
name|char
name|b
index|[
literal|1
index|]
decl_stmt|;
name|b
index|[
literal|0
index|]
operator|=
name|x
expr_stmt|;
name|SERIAL_WRITE
argument_list|(
name|e7000_desc
argument_list|,
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|write_e7000
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|SERIAL_WRITE
argument_list|(
name|e7000_desc
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|normal
parameter_list|(
name|x
parameter_list|)
name|int
name|x
decl_stmt|;
block|{
if|if
condition|(
name|x
operator|==
literal|'\n'
condition|)
return|return
literal|'\r'
return|;
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Read a character from the remote system, doing all the fancy timeout    stuff.  */
end_comment

begin_function
specifier|static
name|int
name|readchar
parameter_list|(
name|timeout
parameter_list|)
name|int
name|timeout
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
do|do
block|{
name|c
operator|=
name|SERIAL_READCHAR
argument_list|(
name|e7000_desc
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|>
literal|127
condition|)
do|;
if|if
condition|(
name|c
operator|==
name|SERIAL_TIMEOUT
condition|)
block|{
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|echo
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
literal|"Timeout reading from remote system."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|remote_debug
condition|)
block|{
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
return|return
name|normal
argument_list|(
name|c
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|char * tl (x) {   static char b[8][10];   static int p;    p++;   p&= 7;   if (x>= ' ')      {        b[p][0] = x;       b[p][1] = 0;     }   else     {       sprintf(b[p], "<%d>", x);     }    return b[p]; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Scan input from the remote system, until STRING is found.  If    DISCARD is non-zero, then discard non-matching input, else print it    out.  Let the user break out immediately.  */
end_comment

begin_function
specifier|static
name|void
name|expect
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|string
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|nl
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
name|notice_quit
argument_list|()
expr_stmt|;
if|if
condition|(
name|quit_flag
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|ctrl_c
condition|)
block|{
name|putchar_e7000
argument_list|(
name|CTRLC
argument_list|)
expr_stmt|;
operator|--
name|ctrl_c
expr_stmt|;
block|}
else|else
block|{
name|quit
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|==
name|SERIAL_ERROR
condition|)
block|{
name|error
argument_list|(
literal|"Serial communication error"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|echo
operator|||
name|remote_debug
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\r'
operator|||
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
operator|!
name|nl
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|nl
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|nl
operator|=
literal|0
expr_stmt|;
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|normal
argument_list|(
name|c
argument_list|)
operator|==
name|normal
argument_list|(
operator|*
name|p
operator|++
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return;
block|}
else|else
block|{
name|p
operator|=
name|string
expr_stmt|;
if|if
condition|(
name|normal
argument_list|(
name|c
argument_list|)
operator|==
name|normal
argument_list|(
name|string
index|[
literal|0
index|]
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Keep discarding input until we see the e7000 prompt.     The convention for dealing with the prompt is that you    o give your command    o *then* wait for the prompt.     Thus the last thing that a procedure does with the serial line will    be an expect_prompt().  Exception: e7000_resume does not wait for    the prompt, because the terminal is being handed over to the    inferior.  However, the next thing which happens after that is a    e7000_wait which does wait for the prompt.  Note that this includes    abnormal exit, e.g. error().  This is necessary to prevent getting    into states from which we can't recover.  */
end_comment

begin_function
specifier|static
name|void
name|expect_prompt
parameter_list|()
block|{
name|expect
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|expect_full_prompt
parameter_list|()
block|{
name|expect
argument_list|(
literal|"\r:"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|convert_hex_digit
parameter_list|(
name|ch
parameter_list|)
name|int
name|ch
decl_stmt|;
block|{
if|if
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
return|return
name|ch
operator|-
literal|'0'
return|;
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'F'
condition|)
return|return
name|ch
operator|-
literal|'A'
operator|+
literal|10
return|;
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'f'
condition|)
return|return
name|ch
operator|-
literal|'a'
operator|+
literal|10
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_hex
parameter_list|(
name|start
parameter_list|)
name|int
modifier|*
name|start
decl_stmt|;
block|{
name|int
name|value
init|=
name|convert_hex_digit
argument_list|(
operator|*
name|start
argument_list|)
decl_stmt|;
name|int
name|try
decl_stmt|;
operator|*
name|start
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|try
operator|=
name|convert_hex_digit
argument_list|(
operator|*
name|start
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|value
operator|<<=
literal|4
expr_stmt|;
name|value
operator|+=
name|try
expr_stmt|;
operator|*
name|start
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Get N 32-bit words from remote, each preceded by a space, and put    them in registers starting at REGNO.  */
end_comment

begin_endif
unit|static void get_hex_regs (n, regno)      int n;      int regno; {   long val;   int i;    for (i = 0; i< n; i++)     {       int j;        val = 0;       for (j = 0; j< 8; j++) 	val = (val<< 4) + get_hex_digit (j == 0);       supply_register (regno++, (char *)&val);     } }
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is called not only when we first attach, but also when the    user types "run" after having attached.  */
end_comment

begin_function
specifier|static
name|void
name|e7000_create_inferior
parameter_list|(
name|execfile
parameter_list|,
name|args
parameter_list|,
name|env
parameter_list|)
name|char
modifier|*
name|execfile
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
name|char
modifier|*
modifier|*
name|env
decl_stmt|;
block|{
name|int
name|entry_pt
decl_stmt|;
if|if
condition|(
name|args
operator|&&
operator|*
name|args
condition|)
name|error
argument_list|(
literal|"Can't pass arguments to remote E7000DEBUG process"
argument_list|)
expr_stmt|;
if|if
condition|(
name|execfile
operator|==
literal|0
operator|||
name|exec_bfd
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No exec file specified"
argument_list|)
expr_stmt|;
name|entry_pt
operator|=
operator|(
name|int
operator|)
name|bfd_get_start_address
argument_list|(
name|exec_bfd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CREATE_INFERIOR_HOOK
name|CREATE_INFERIOR_HOOK
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* No process-ID */
endif|#
directive|endif
comment|/* The "process" (board) is already stopped awaiting our commands, and      the program is already downloaded.  We just set its PC and go.  */
name|clear_proceed_status
argument_list|()
expr_stmt|;
comment|/* Tell wait_for_inferior that we've started a new process.  */
name|init_wait_for_inferior
argument_list|()
expr_stmt|;
comment|/* Set up the "saved terminal modes" of the inferior      based on what modes we are starting it with.  */
name|target_terminal_init
argument_list|()
expr_stmt|;
comment|/* Install inferior's terminal modes.  */
name|target_terminal_inferior
argument_list|()
expr_stmt|;
comment|/* insert_step_breakpoint ();  FIXME, do we need this?  */
name|proceed
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|entry_pt
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Let 'er rip... */
block|}
end_function

begin_comment
comment|/* Open a connection to a remote debugger.  NAME is the filename used    for communication.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|baudrate
init|=
literal|9600
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|dev_name
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|machine
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|user
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|passwd
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dir
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Grab the next token and buy some space for it */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|next
parameter_list|(
name|ptr
parameter_list|)
name|char
modifier|*
modifier|*
name|ptr
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|r
decl_stmt|;
name|int
name|l
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|==
literal|' '
condition|)
name|p
operator|++
expr_stmt|;
name|s
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|(
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'\t'
operator|)
condition|)
block|{
name|l
operator|++
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
name|r
operator|=
name|xmalloc
argument_list|(
name|l
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|r
argument_list|,
name|s
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|r
index|[
name|l
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|ptr
operator|=
name|p
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|e7000_login_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|args
condition|)
block|{
name|machine
operator|=
name|next
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
name|user
operator|=
name|next
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
name|passwd
operator|=
name|next
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
name|dir
operator|=
name|next
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|printf
argument_list|(
literal|"Set info to %s %s %s %s\n"
argument_list|,
name|machine
argument_list|,
name|user
argument_list|,
name|passwd
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
argument_list|(
literal|"Syntax is ftplogin<machine><user><passwd><directory>"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Start an ftp transfer from the E7000 to a host */
end_comment

begin_function
specifier|static
name|void
name|e7000_ftp_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
comment|/* FIXME: arbitrary limit on machine names and such.  */
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|;
name|int
name|oldtimeout
init|=
name|timeout
decl_stmt|;
name|timeout
operator|=
literal|10
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"ftp %s\r"
argument_list|,
name|machine
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|" Username : "
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s\r"
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|" Password : "
argument_list|)
expr_stmt|;
name|write_e7000
argument_list|(
name|passwd
argument_list|)
expr_stmt|;
name|write_e7000
argument_list|(
literal|"\r"
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"success\r"
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"FTP>"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"cd %s\r"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"FTP>"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"ll 0;s:%s\r"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"FTP>"
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
literal|"bye\r"
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
name|timeout
operator|=
name|oldtimeout
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|e7000_open
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|int
name|loop
decl_stmt|;
name|char
name|junk
index|[
literal|100
index|]
decl_stmt|;
name|int
name|sync
decl_stmt|;
name|target_preopen
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|args
operator|&&
name|strcasecmp
argument_list|(
name|args
argument_list|,
literal|"pc"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|dev_name
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|args
condition|)
block|{
name|n
operator|=
name|sscanf
argument_list|(
name|args
argument_list|,
literal|" %s %d %s"
argument_list|,
name|dev_name
argument_list|,
operator|&
name|baudrate
argument_list|,
name|junk
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|!=
literal|1
operator|&&
name|n
operator|!=
literal|2
condition|)
block|{
name|error
argument_list|(
literal|"Bad arguments.  Usage:\ttarget e7000<device><speed>\n\ or \t\ttarget e7000<host>[:<port>]\n\ or \t\ttarget e7000 pc\n"
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|__GO32__
if|if
condition|(
name|n
operator|==
literal|1
operator|&&
name|strchr
argument_list|(
name|dev_name
argument_list|,
literal|':'
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Default to normal telnet port */
name|strcat
argument_list|(
name|dev_name
argument_list|,
literal|":23"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|push_target
argument_list|(
operator|&
name|e7000_ops
argument_list|)
expr_stmt|;
name|e7000_desc
operator|=
name|SERIAL_OPEN
argument_list|(
name|dev_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|e7000_desc
condition|)
name|perror_with_name
argument_list|(
name|dev_name
argument_list|)
expr_stmt|;
name|using_tcp
operator|=
name|strcmp
argument_list|(
name|e7000_desc
operator|->
name|ops
operator|->
name|name
argument_list|,
literal|"tcp"
argument_list|)
operator|==
literal|0
expr_stmt|;
name|using_pc
operator|=
name|strcmp
argument_list|(
name|e7000_desc
operator|->
name|ops
operator|->
name|name
argument_list|,
literal|"pc"
argument_list|)
operator|==
literal|0
expr_stmt|;
name|SERIAL_SETBAUDRATE
argument_list|(
name|e7000_desc
argument_list|,
name|baudrate
argument_list|)
expr_stmt|;
name|SERIAL_RAW
argument_list|(
name|e7000_desc
argument_list|)
expr_stmt|;
comment|/* Hello?  Are you there?  */
name|sync
operator|=
literal|0
expr_stmt|;
name|loop
operator|=
literal|0
expr_stmt|;
name|putchar_e7000
argument_list|(
name|CTRLC
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|sync
condition|)
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf_unfiltered
argument_list|(
literal|"[waiting for e7000...]\n"
argument_list|)
expr_stmt|;
name|write_e7000
argument_list|(
literal|"\r"
argument_list|)
expr_stmt|;
name|c
operator|=
name|SERIAL_READCHAR
argument_list|(
name|e7000_desc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|c
operator|!=
name|SERIAL_TIMEOUT
condition|)
block|{
comment|/* Dont echo cr's */
if|if
condition|(
name|from_tty
operator|&&
name|c
operator|!=
literal|'\r'
condition|)
block|{
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|':'
condition|)
name|sync
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|loop
operator|++
operator|==
literal|20
condition|)
block|{
name|putchar_e7000
argument_list|(
name|CTRLC
argument_list|)
expr_stmt|;
name|loop
operator|=
literal|0
expr_stmt|;
block|}
name|QUIT
expr_stmt|;
if|if
condition|(
name|quit_flag
condition|)
block|{
name|putchar_e7000
argument_list|(
name|CTRLC
argument_list|)
expr_stmt|;
name|quit_flag
operator|=
literal|0
expr_stmt|;
block|}
name|c
operator|=
name|SERIAL_READCHAR
argument_list|(
name|e7000_desc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|puts_e7000debug
argument_list|(
literal|"\r"
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|()
expr_stmt|;
name|puts_e7000debug
argument_list|(
literal|"b -\r"
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|()
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf_filtered
argument_list|(
literal|"Remote target %s connected to %s\n"
argument_list|,
name|target_shortname
argument_list|,
name|dev_name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GDB_TARGET_IS_H8300
name|h8300hmode
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Close out all files and local state before this target loses control. */
end_comment

begin_function
specifier|static
name|void
name|e7000_close
parameter_list|(
name|quitting
parameter_list|)
name|int
name|quitting
decl_stmt|;
block|{
if|if
condition|(
name|e7000_desc
condition|)
block|{
name|SERIAL_CLOSE
argument_list|(
name|e7000_desc
argument_list|)
expr_stmt|;
name|e7000_desc
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Terminate the open connection to the remote debugger.  Use this    when you want to detach and do something else with your gdb.  */
end_comment

begin_function
specifier|static
name|void
name|e7000_detach
parameter_list|(
name|from_tty
parameter_list|)
name|int
name|from_tty
decl_stmt|;
block|{
name|pop_target
argument_list|()
expr_stmt|;
comment|/* calls e7000_close to do the real work */
if|if
condition|(
name|from_tty
condition|)
name|printf
argument_list|(
literal|"Ending remote %s debugging\n"
argument_list|,
name|target_shortname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Tell the remote machine to resume.  */
end_comment

begin_function
specifier|static
name|void
name|e7000_resume
parameter_list|(
name|pid
parameter_list|,
name|step
parameter_list|,
name|sig
parameter_list|)
name|int
name|pid
decl_stmt|,
name|step
decl_stmt|,
name|sig
decl_stmt|;
block|{
if|if
condition|(
name|step
condition|)
name|puts_e7000debug
argument_list|(
literal|"S\r"
argument_list|)
expr_stmt|;
else|else
name|puts_e7000debug
argument_list|(
literal|"G\r"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read the remote registers into the block REGS.       For the H8/300 a register dump looks like:     PC=00021A  CCR=80:I*******    ER0 - ER3  0000000A 0000002E 0000002E 00000000    ER4 - ER7  00000000 00000000 00000000 00FFEFF6    000218           MOV.B     R1L,R2L    STEP NORMAL END or    BREAK POINT    */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GDB_TARGET_IS_H8300
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|want
init|=
literal|"PC=%p CCR=%c\n\  ER0 - ER3  %0 %1 %2 %3\n\  ER4 - ER7  %4 %5 %6 %7\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|want_nopc
init|=
literal|"%p CCR=%c\n\  ER0 - ER3  %0 %1 %2 %3\n\  ER4 - ER7  %4 %5 %6 %7"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|GDB_TARGET_IS_SH
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|want
init|=
literal|"PC=%16 SR=%22\n\ PR=%17 GBR=%18 VBR=%19\n\ MACH=%20 MACL=%21\n\ R0-7  %0 %1 %2 %3 %4 %5 %6 %7\n\ R8-15 %8 %9 %10 %11 %12 %13 %14 %15\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|want_nopc
init|=
literal|"%16 SR=%22\n\  PR=%17 GBR=%18 VBR=%19\n\  MACH=%20 MACL=%21\n\  R0-7  %0 %1 %2 %3 %4 %5 %6 %7\n\  R8-15 %8 %9 %10 %11 %12 %13 %14 %15"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|gch
parameter_list|()
block|{
name|int
name|c
init|=
name|readchar
argument_list|(
name|timeout
argument_list|)
decl_stmt|;
if|if
condition|(
name|remote_debug
condition|)
block|{
if|if
condition|(
name|c
operator|>=
literal|' '
condition|)
name|printf
argument_list|(
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|gbyte
parameter_list|()
block|{
name|int
name|high
init|=
name|convert_hex_digit
argument_list|(
name|gch
argument_list|()
argument_list|)
decl_stmt|;
name|int
name|low
init|=
name|convert_hex_digit
argument_list|(
name|gch
argument_list|()
argument_list|)
decl_stmt|;
return|return
operator|(
name|high
operator|<<
literal|4
operator|)
operator|+
name|low
return|;
block|}
end_function

begin_decl_stmt
name|void
name|fetch_regs_from_dump
argument_list|(
name|nextchar
argument_list|,
name|want
argument_list|)
name|int
argument_list|(
operator|*
name|nextchar
argument_list|)
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|want
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|regno
decl_stmt|;
name|char
name|buf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|int
name|thischar
init|=
name|nextchar
argument_list|()
decl_stmt|;
while|while
condition|(
operator|*
name|want
condition|)
block|{
switch|switch
condition|(
operator|*
name|want
condition|)
block|{
case|case
literal|'\n'
case|:
comment|/* Skip to end of line and then eat all new line type stuff */
while|while
condition|(
name|thischar
operator|!=
literal|'\n'
operator|&&
name|thischar
operator|!=
literal|'\r'
condition|)
name|thischar
operator|=
name|nextchar
argument_list|()
expr_stmt|;
while|while
condition|(
name|thischar
operator|==
literal|'\n'
operator|||
name|thischar
operator|==
literal|'\r'
condition|)
name|thischar
operator|=
name|nextchar
argument_list|()
expr_stmt|;
name|want
operator|++
expr_stmt|;
break|break;
case|case
literal|' '
case|:
while|while
condition|(
name|thischar
operator|==
literal|' '
operator|||
name|thischar
operator|==
literal|'\t'
operator|||
name|thischar
operator|==
literal|'\r'
operator|||
name|thischar
operator|==
literal|'\n'
condition|)
name|thischar
operator|=
name|nextchar
argument_list|()
expr_stmt|;
name|want
operator|++
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|*
name|want
operator|==
name|thischar
condition|)
block|{
name|want
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|want
condition|)
name|thischar
operator|=
name|nextchar
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|thischar
operator|==
literal|' '
operator|||
name|thischar
operator|==
literal|'\n'
operator|||
name|thischar
operator|==
literal|'\r'
condition|)
block|{
name|thischar
operator|=
name|nextchar
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"out of sync in fetch registers wanted<%s>, got<%c 0x%x>"
argument_list|,
name|want
argument_list|,
name|thischar
argument_list|,
name|thischar
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'%'
case|:
comment|/* Got a register command */
name|want
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|want
condition|)
block|{
ifdef|#
directive|ifdef
name|PC_REGNUM
case|case
literal|'p'
case|:
name|regno
operator|=
name|PC_REGNUM
expr_stmt|;
name|want
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CCR_REGNUM
case|case
literal|'c'
case|:
name|regno
operator|=
name|CCR_REGNUM
expr_stmt|;
name|want
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SP_REGNUM
case|case
literal|'s'
case|:
name|regno
operator|=
name|SP_REGNUM
expr_stmt|;
name|want
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FP_REGNUM
case|case
literal|'f'
case|:
name|regno
operator|=
name|FP_REGNUM
expr_stmt|;
name|want
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
if|if
condition|(
name|isdigit
argument_list|(
name|want
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|want
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|regno
operator|=
operator|(
name|want
index|[
literal|0
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
name|want
index|[
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
name|want
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|regno
operator|=
name|want
index|[
literal|0
index|]
operator|-
literal|'0'
expr_stmt|;
name|want
operator|++
expr_stmt|;
block|}
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
block|}
name|store_signed_integer
argument_list|(
name|buf
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|,
operator|(
name|LONGEST
operator|)
name|get_hex
argument_list|(
operator|&
name|thischar
argument_list|,
name|nextchar
argument_list|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_block

begin_function
specifier|static
name|void
name|e7000_fetch_registers
parameter_list|()
block|{
name|int
name|regno
decl_stmt|;
name|puts_e7000debug
argument_list|(
literal|"R\r"
argument_list|)
expr_stmt|;
name|fetch_regs_from_dump
argument_list|(
name|gch
argument_list|,
name|want
argument_list|)
expr_stmt|;
comment|/* And supply the extra ones the simulator uses */
for|for
control|(
name|regno
operator|=
name|NUM_REALREGS
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
block|{
name|int
name|buf
init|=
literal|0
decl_stmt|;
name|supply_register
argument_list|(
name|regno
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
operator|&
name|buf
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Fetch register REGNO, or all registers if REGNO is -1.  Returns    errno value.  */
end_comment

begin_function
specifier|static
name|void
name|e7000_fetch_register
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|e7000_fetch_registers
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store the remote registers from the contents of the block REGS.  */
end_comment

begin_function
specifier|static
name|void
name|e7000_store_registers
parameter_list|()
block|{
name|int
name|regno
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REALREGS
condition|;
name|regno
operator|++
control|)
name|e7000_store_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|registers_changed
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store register REGNO, or all if REGNO == 0.  Return errno value.  */
end_comment

begin_function
specifier|static
name|void
name|e7000_store_register
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|;
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
name|e7000_store_registers
argument_list|()
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|GDB_TARGET_IS_H8300
if|if
condition|(
name|regno
operator|<=
literal|7
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".ER%d %x\r"
argument_list|,
name|regno
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regno
operator|==
name|PC_REGNUM
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".PC %x\r"
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regno
operator|==
name|CCR_REGNUM
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".CCR %x\r"
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* GDB_TARGET_IS_H8300 */
ifdef|#
directive|ifdef
name|GDB_TARGET_IS_SH
switch|switch
condition|(
name|regno
condition|)
block|{
default|default:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".R%d %x\r"
argument_list|,
name|regno
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|PC_REGNUM
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".PC %x\r"
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|SR_REGNUM
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".SR %x\r"
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|PR_REGNUM
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".PR %x\r"
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|GBR_REGNUM
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".GBR %x\r"
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|VBR_REGNUM
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".VBR %x\r"
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|MACH_REGNUM
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".MACH %x\r"
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|MACL_REGNUM
case|:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|".MACL %x\r"
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* GDB_TARGET_IS_SH */
name|expect_prompt
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get ready to modify the registers array.  On machines which store    individual registers, this doesn't need to do anything.  On machines    which store all the registers in one fell swoop, this makes sure    that registers contains all the registers from the program being    debugged.  */
end_comment

begin_function
specifier|static
name|void
name|e7000_prepare_to_store
parameter_list|()
block|{
comment|/* Do nothing, since we can store individual regs */
block|}
end_function

begin_function
specifier|static
name|void
name|e7000_files_info
parameter_list|()
block|{
name|printf
argument_list|(
literal|"\tAttached to %s at %d baud.\n"
argument_list|,
name|dev_name
argument_list|,
name|baudrate
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|stickbyte
parameter_list|(
name|where
parameter_list|,
name|what
parameter_list|)
name|char
modifier|*
name|where
decl_stmt|;
name|unsigned
name|int
name|what
decl_stmt|;
block|{
specifier|static
name|CONST
name|char
name|digs
index|[]
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
name|where
index|[
literal|0
index|]
operator|=
name|digs
index|[
operator|(
name|what
operator|>>
literal|4
operator|)
operator|&
literal|0xf
index|]
expr_stmt|;
name|where
index|[
literal|1
index|]
operator|=
name|digs
index|[
operator|(
name|what
operator|&
literal|0xf
operator|)
operator|&
literal|0xf
index|]
expr_stmt|;
return|return
name|what
return|;
block|}
end_function

begin_comment
comment|/* Write a small ammount of memory. */
end_comment

begin_function
specifier|static
name|int
name|write_small
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|memaddr
operator|+
name|i
operator|)
operator|&
literal|3
operator|)
operator|==
literal|0
operator|&&
operator|(
name|i
operator|+
literal|3
operator|<
name|len
operator|)
condition|)
block|{
comment|/* Can be done with a long word */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"m %x %x%02x%02x%02x;l\r"
argument_list|,
name|memaddr
operator|+
name|i
argument_list|,
name|myaddr
index|[
name|i
index|]
argument_list|,
name|myaddr
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|myaddr
index|[
name|i
operator|+
literal|2
index|]
argument_list|,
name|myaddr
index|[
name|i
operator|+
literal|3
index|]
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"m %x %x\r"
argument_list|,
name|memaddr
operator|+
name|i
argument_list|,
name|myaddr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
name|expect_prompt
argument_list|()
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* Write a large ammount of memory, this only works with the serial    mode enabled.  Command is sent as  	il ;s:s\r	 -><- il ;s:s\r<-  	ENQ 	ACK		-><- LO s\r 	Srecords... 	^Z		-><-	ENQ 	ACK		-><-	:   	   */
end_comment

begin_function
specifier|static
name|int
name|write_large
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
define|#
directive|define
name|maxstride
value|128
name|int
name|stride
decl_stmt|;
name|puts_e7000debug
argument_list|(
literal|"IL ;S:FK\r"
argument_list|)
expr_stmt|;
name|expect
argument_list|(
name|ENQSTRING
argument_list|)
expr_stmt|;
name|putchar_e7000
argument_list|(
name|ACK
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"LO FK\r"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
name|stride
control|)
block|{
name|char
name|compose
index|[
name|maxstride
operator|*
literal|2
operator|+
literal|50
index|]
decl_stmt|;
name|int
name|address
init|=
name|i
operator|+
name|memaddr
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|check_sum
decl_stmt|;
name|int
name|where
init|=
literal|0
decl_stmt|;
name|int
name|alen
decl_stmt|;
name|stride
operator|=
name|len
operator|-
name|i
expr_stmt|;
if|if
condition|(
name|stride
operator|>
name|maxstride
condition|)
name|stride
operator|=
name|maxstride
expr_stmt|;
name|compose
index|[
name|where
operator|++
index|]
operator|=
literal|'S'
expr_stmt|;
name|check_sum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|address
operator|>=
literal|0xffffff
condition|)
name|alen
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|address
operator|>=
literal|0xffff
condition|)
name|alen
operator|=
literal|3
expr_stmt|;
else|else
name|alen
operator|=
literal|2
expr_stmt|;
comment|/* Insert type. */
name|compose
index|[
name|where
operator|++
index|]
operator|=
name|alen
operator|-
literal|1
operator|+
literal|'0'
expr_stmt|;
comment|/* Insert length. */
name|check_sum
operator|+=
name|stickbyte
argument_list|(
name|compose
operator|+
name|where
argument_list|,
name|alen
operator|+
name|stride
operator|+
literal|1
argument_list|)
expr_stmt|;
name|where
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
name|alen
operator|>
literal|0
condition|)
block|{
name|alen
operator|--
expr_stmt|;
name|check_sum
operator|+=
name|stickbyte
argument_list|(
name|compose
operator|+
name|where
argument_list|,
name|address
operator|>>
operator|(
literal|8
operator|*
operator|(
name|alen
operator|)
operator|)
argument_list|)
expr_stmt|;
name|where
operator|+=
literal|2
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|stride
condition|;
name|j
operator|++
control|)
block|{
name|check_sum
operator|+=
name|stickbyte
argument_list|(
name|compose
operator|+
name|where
argument_list|,
name|myaddr
index|[
name|i
operator|+
name|j
index|]
argument_list|)
expr_stmt|;
name|where
operator|+=
literal|2
expr_stmt|;
block|}
name|stickbyte
argument_list|(
name|compose
operator|+
name|where
argument_list|,
operator|~
name|check_sum
argument_list|)
expr_stmt|;
name|where
operator|+=
literal|2
expr_stmt|;
name|compose
index|[
name|where
operator|++
index|]
operator|=
literal|'\r'
expr_stmt|;
name|compose
index|[
name|where
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|compose
index|[
name|where
operator|++
index|]
operator|=
literal|0
expr_stmt|;
name|SERIAL_WRITE
argument_list|(
name|e7000_desc
argument_list|,
name|compose
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|j
operator|=
name|SERIAL_READCHAR
argument_list|(
name|e7000_desc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|==
name|SERIAL_TIMEOUT
condition|)
block|{
comment|/* This is ok - nothing there */
block|}
elseif|else
if|if
condition|(
name|j
operator|==
name|ENQ
condition|)
block|{
comment|/* Hmm, it's trying to tell us something */
name|expect
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Error writing memory"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"@%d}@"
argument_list|,
name|j
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|j
operator|=
name|SERIAL_READCHAR
argument_list|(
name|e7000_desc
argument_list|,
literal|0
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"@{%d}@"
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Send the trailer record */
name|write_e7000
argument_list|(
literal|"S70500000000FA\r"
argument_list|)
expr_stmt|;
name|putchar_e7000
argument_list|(
name|CTRLZ
argument_list|)
expr_stmt|;
name|expect
argument_list|(
name|ENQSTRING
argument_list|)
expr_stmt|;
name|putchar_e7000
argument_list|(
name|ACK
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|":"
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* Copy LEN bytes of data from debugger memory at MYADDR to inferior's    memory at MEMADDR.  Returns length moved.     Can't use the Srecord load over ethernet, so don't use fast method    then.  */
end_comment

begin_function
specifier|static
name|int
name|e7000_write_inferior_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
if|if
condition|(
name|len
operator|<
literal|16
operator|||
name|using_tcp
operator|||
name|using_pc
condition|)
return|return
name|write_small
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
return|;
else|else
return|return
name|write_large
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read LEN bytes from inferior memory at MEMADDR.  Put the result    at debugger address MYADDR.  Returns length moved.     Small transactions we send   m<addr>;l   and receive     00000000 12345678 ?  */
end_comment

begin_function
specifier|static
name|int
name|e7000_read_inferior_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|count
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|;
comment|/* Starting address of this pass.  */
comment|/*  printf("READ INF %x %x %d\n", memaddr, myaddr, len);*/
if|if
condition|(
operator|(
operator|(
name|memaddr
operator|-
literal|1
operator|)
operator|+
name|len
operator|)
operator|<
name|memaddr
condition|)
block|{
name|errno
operator|=
name|EIO
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"m %x;l\r"
argument_list|,
name|memaddr
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|len
condition|;
name|count
operator|+=
literal|4
control|)
block|{
comment|/* Suck away the address */
name|c
operator|=
name|gch
argument_list|()
expr_stmt|;
while|while
condition|(
name|c
operator|!=
literal|' '
condition|)
name|c
operator|=
name|gch
argument_list|()
expr_stmt|;
name|c
operator|=
name|gch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'*'
condition|)
block|{
comment|/* Some kind of error */
name|expect_prompt
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
while|while
condition|(
name|c
operator|!=
literal|' '
condition|)
name|c
operator|=
name|gch
argument_list|()
expr_stmt|;
comment|/* Now read in the data */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|int
name|b
init|=
name|gbyte
argument_list|()
decl_stmt|;
if|if
condition|(
name|count
operator|+
name|i
operator|<
name|len
condition|)
block|{
name|myaddr
index|[
name|count
operator|+
name|i
index|]
operator|=
name|b
expr_stmt|;
block|}
block|}
comment|/* Skip the trailing ? and send a . to end and a cr for more */
name|gch
argument_list|()
expr_stmt|;
name|gch
argument_list|()
expr_stmt|;
if|if
condition|(
name|count
operator|+
literal|4
operator|>=
name|len
condition|)
name|puts_e7000debug
argument_list|(
literal|".\r"
argument_list|)
expr_stmt|;
else|else
name|puts_e7000debug
argument_list|(
literal|"\r"
argument_list|)
expr_stmt|;
block|}
name|expect_prompt
argument_list|()
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*   For large transfers we used to send     d<addr><endaddr>\r    and receive<ADDR><    D   A   T   A><   ASCII CODE>    000000  5F FD FD FF DF 7F DF FF  01 00 01 00 02 00 08 04  "_..............."    000010  FF D7 FF 7F D7 F1 7F FF  00 05 00 00 08 00 40 00  "..............@."    000020  7F FD FF F7 7F FF FF F7  00 00 00 00 00 00 00 00  "................"    A cost in chars for each transaction of 80 + 5*n-bytes.     Large transactions could be done with the srecord load code, but   there is a pause for a second before dumping starts, which slows the   average rate down! */
end_comment

begin_comment
unit|static int e7000_read_inferior_memory (memaddr, myaddr, len)      CORE_ADDR memaddr;      unsigned char *myaddr;      int len; {   int count;   int c;   char buf[200];
comment|/* Starting address of this pass.  */
end_comment

begin_comment
unit|if (((memaddr - 1) + len)< memaddr)     {       errno = EIO;       return 0;     }    sprintf (buf, "d %x %x\r", memaddr, memaddr + len - 1);   puts_e7000debug (buf);    count = 0;   c = gch ();
comment|/* First skip the command */
end_comment

begin_comment
unit|while (c == '\n')     c = gch ();    while (c == ' ')     c = gch ();   if (c == '*')     {       expect ("\r");       return -1;     }
comment|/* Skip the title line */
end_comment

begin_comment
unit|while (c != '\n')     c = gch ();   c = gch ();   while (count< len)     {
comment|/* Skip the address */
end_comment

begin_comment
unit|while (c<= ' ') 	c = gch ();        get_hex (&c);
comment|/* read in the bytes on the line */
end_comment

begin_comment
unit|while (c != '"'&& count< len) 	{ 	  if (c == ' ') 	    c = gch (); 	  else 	    { 	      myaddr[count++] = get_hex (&c); 	    } 	}        while (c != '\n') 	c = gch ();     }    while (c != ':')     c = gch ();    return len; }  static int fast_but_for_the_pause_e7000_read_inferior_memory (memaddr, myaddr, len)      CORE_ADDR memaddr;      char *myaddr;      int len; {   int loop;   int c;   char buf[200];    if (((memaddr - 1) + len)< memaddr)     {       errno = EIO;       return 0;     }    sprintf (buf, "is %x@%x:s\r", memaddr, len);   puts_e7000debug (buf);   gch ();   c = gch ();   if (c != ENQ)     {
comment|/* Got an error */
end_comment

begin_comment
unit|error ("Memory read error");     }   putchar_e7000 (ACK);   expect ("SV s");   loop = 1;   while (loop)     {       int type;       int length;       int addr;       int i;        c = gch ();       switch (c) 	{ 	case ENQ:
comment|/* ENQ, at the end */
end_comment

begin_comment
unit|loop = 0; 	  break; 	case 'S':
comment|/* Start of an Srecord */
end_comment

begin_comment
unit|type = gch (); 	  length = gbyte (); 	  switch (type) 	    { 	    case '7':
comment|/* Termination record, ignore */
end_comment

begin_comment
unit|case '0': 	    case '8': 	    case '9':
comment|/* Header record - ignore it */
end_comment

begin_comment
unit|while (length--) 		{ 		  gbyte (); 		} 	      break; 	    case '1': 	    case '2': 	    case '3': 	      { 		int alen;  		alen = type - '0' + 1; 		addr = 0; 		while (alen--) 		  { 		    addr = (addr<< 8) + gbyte (); 		    length--; 		  }  		for (i = 0; i< length - 1; i++) 		  myaddr[i + addr - memaddr] = gbyte ();  		gbyte ();
comment|/* Ignore checksum */
end_comment

begin_endif
unit|} 	    } 	}     }    putchar_e7000 (ACK);   expect ("TOP ADDRESS =");   expect ("END ADDRESS =");   expect (":");    return len; }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|e7000_xfer_inferior_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|write
parameter_list|,
name|target
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|write
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
comment|/* ignored */
block|{
if|if
condition|(
name|write
condition|)
return|return
name|e7000_write_inferior_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
return|;
else|else
return|return
name|e7000_read_inferior_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|e7000_kill
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{ }
end_function

begin_function
specifier|static
name|void
name|e7000_load
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|asection
modifier|*
name|section
decl_stmt|;
name|bfd
modifier|*
name|pbfd
decl_stmt|;
name|bfd_vma
name|entry
decl_stmt|;
name|int
name|i
decl_stmt|;
define|#
directive|define
name|WRITESIZE
value|0x1000
name|char
name|buf
index|[
literal|2
operator|+
literal|4
operator|+
literal|4
operator|+
name|WRITESIZE
index|]
decl_stmt|;
comment|/* `DT' +<addr> +<len> +<data> */
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|quiet
decl_stmt|;
name|int
name|nostart
decl_stmt|;
name|time_t
name|start_time
decl_stmt|,
name|end_time
decl_stmt|;
comment|/* Start and end times of download */
name|unsigned
name|long
name|data_count
decl_stmt|;
comment|/* Number of bytes transferred to memory */
if|if
condition|(
operator|!
name|strchr
argument_list|(
name|dev_name
argument_list|,
literal|':'
argument_list|)
condition|)
block|{
name|generic_load
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
return|return;
block|}
name|buf
index|[
literal|0
index|]
operator|=
literal|'D'
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'T'
expr_stmt|;
name|quiet
operator|=
literal|0
expr_stmt|;
name|nostart
operator|=
literal|0
expr_stmt|;
name|filename
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|*
name|args
operator|!=
literal|'\000'
condition|)
block|{
name|char
modifier|*
name|arg
decl_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|args
argument_list|)
condition|)
name|args
operator|++
expr_stmt|;
name|arg
operator|=
name|args
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|args
operator|!=
literal|'\000'
operator|)
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|args
argument_list|)
condition|)
name|args
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|args
operator|!=
literal|'\000'
condition|)
operator|*
name|args
operator|++
operator|=
literal|'\000'
expr_stmt|;
if|if
condition|(
operator|*
name|arg
operator|!=
literal|'-'
condition|)
name|filename
operator|=
name|arg
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"-quiet"
argument_list|,
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|quiet
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"-nostart"
argument_list|,
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|nostart
operator|=
literal|1
expr_stmt|;
else|else
name|error
argument_list|(
literal|"unknown option `%s'"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|filename
condition|)
name|filename
operator|=
name|get_exec_file
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|pbfd
operator|=
name|bfd_openr
argument_list|(
name|filename
argument_list|,
name|gnutarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|pbfd
operator|==
name|NULL
condition|)
block|{
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|bfd_close
argument_list|,
name|pbfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|pbfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
name|error
argument_list|(
literal|"\"%s\" is not an object file: %s"
argument_list|,
name|filename
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|start_time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|data_count
operator|=
literal|0
expr_stmt|;
name|puts_e7000debug
argument_list|(
literal|"mw\r"
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"\nOK"
argument_list|)
expr_stmt|;
for|for
control|(
name|section
operator|=
name|pbfd
operator|->
name|sections
init|;
name|section
condition|;
name|section
operator|=
name|section
operator|->
name|next
control|)
block|{
if|if
condition|(
name|bfd_get_section_flags
argument_list|(
name|pbfd
argument_list|,
name|section
argument_list|)
operator|&
name|SEC_LOAD
condition|)
block|{
name|bfd_vma
name|section_address
decl_stmt|;
name|bfd_size_type
name|section_size
decl_stmt|;
name|file_ptr
name|fptr
decl_stmt|;
name|section_address
operator|=
name|bfd_get_section_vma
argument_list|(
name|pbfd
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|section_size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf_filtered
argument_list|(
literal|"[Loading section %s at 0x%x (%d bytes)]\n"
argument_list|,
name|bfd_get_section_name
argument_list|(
name|pbfd
argument_list|,
name|section
argument_list|)
argument_list|,
name|section_address
argument_list|,
name|section_size
argument_list|)
expr_stmt|;
name|fptr
operator|=
literal|0
expr_stmt|;
name|data_count
operator|+=
name|section_size
expr_stmt|;
while|while
condition|(
name|section_size
operator|>
literal|0
condition|)
block|{
name|int
name|count
decl_stmt|;
specifier|static
name|char
name|inds
index|[]
init|=
literal|"|/-\\"
decl_stmt|;
specifier|static
name|int
name|k
init|=
literal|0
decl_stmt|;
name|QUIT
expr_stmt|;
name|count
operator|=
name|min
argument_list|(
name|section_size
argument_list|,
name|WRITESIZE
argument_list|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|section_address
operator|>>
literal|24
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|section_address
operator|>>
literal|16
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
name|section_address
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
literal|5
index|]
operator|=
name|section_address
expr_stmt|;
name|buf
index|[
literal|6
index|]
operator|=
name|count
operator|>>
literal|24
expr_stmt|;
name|buf
index|[
literal|7
index|]
operator|=
name|count
operator|>>
literal|16
expr_stmt|;
name|buf
index|[
literal|8
index|]
operator|=
name|count
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
literal|9
index|]
operator|=
name|count
expr_stmt|;
name|bfd_get_section_contents
argument_list|(
name|pbfd
argument_list|,
name|section
argument_list|,
name|buf
operator|+
literal|10
argument_list|,
name|fptr
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|SERIAL_WRITE
argument_list|(
name|e7000_desc
argument_list|,
name|buf
argument_list|,
name|count
operator|+
literal|10
argument_list|)
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"e7000_load: SERIAL_WRITE failed: %s\n"
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"OK"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\r%c"
argument_list|,
name|inds
index|[
name|k
operator|++
operator|%
literal|4
index|]
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|section_address
operator|+=
name|count
expr_stmt|;
name|fptr
operator|+=
name|count
expr_stmt|;
name|section_size
operator|-=
name|count
expr_stmt|;
block|}
block|}
block|}
name|write_e7000
argument_list|(
literal|"ED"
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|()
expr_stmt|;
name|end_time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* Finally, make the PC point at the start address */
if|if
condition|(
name|exec_bfd
condition|)
name|write_pc
argument_list|(
name|bfd_get_start_address
argument_list|(
name|exec_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
literal|0
expr_stmt|;
comment|/* No process now */
comment|/* This is necessary because many things were based on the PC at the time that    we attached to the monitor, which is no longer valid now that we have loaded    new code (and just changed the PC).  Another way to do this might be to call    normal_stop, except that the stack may not be valid, and things would get    horribly confused... */
name|clear_symtab_users
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|nostart
condition|)
block|{
name|entry
operator|=
name|bfd_get_start_address
argument_list|(
name|pbfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf_unfiltered
argument_list|(
literal|"[Starting %s at 0x%x]\n"
argument_list|,
name|filename
argument_list|,
name|entry
argument_list|)
expr_stmt|;
comment|/*      start_routine (entry);*/
block|}
name|printf_filtered
argument_list|(
literal|"Transfer rate: %d bits/sec.\n"
argument_list|,
operator|(
name|data_count
operator|*
literal|8
operator|)
operator|/
operator|(
name|end_time
operator|-
name|start_time
operator|)
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clean up when a program exits.     The program actually lives on in the remote processor's RAM, and may be    run again without a download.  Don't leave it full of breakpoint    instructions.  */
end_comment

begin_function
specifier|static
name|void
name|e7000_mourn_inferior
parameter_list|()
block|{
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|e7000_ops
argument_list|)
expr_stmt|;
name|generic_mourn_inferior
argument_list|()
expr_stmt|;
comment|/* Do all the proper things now */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HARD_BREAKPOINTS
end_ifdef

begin_define
define|#
directive|define
name|MAX_E7000DEBUG_BREAKPOINTS
value|(BC_BREAKPOINTS ? 5 :  200)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MAX_E7000DEBUG_BREAKPOINTS
value|200
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|memory_breakpoint_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|breakaddr
index|[
name|MAX_E7000DEBUG_BREAKPOINTS
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|e7000_insert_breakpoint
parameter_list|(
name|addr
parameter_list|,
name|shadow
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|shadow
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|;
specifier|static
name|char
name|nop
index|[
literal|2
index|]
init|=
name|NOP
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|MAX_E7000DEBUG_BREAKPOINTS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|breakaddr
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|breakaddr
index|[
name|i
index|]
operator|=
name|addr
expr_stmt|;
comment|/* Save old contents, and insert a nop in the space */
ifdef|#
directive|ifdef
name|HARD_BREAKPOINTS
if|if
condition|(
name|BC_BREAKPOINTS
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"BC%d A=%x\r"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"B %x\r"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|#
directive|if
literal|0
block|e7000_read_inferior_memory (addr, shadow, 2); 	e7000_write_inferior_memory (addr, nop, 2);
endif|#
directive|endif
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"B %x\r"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|expect_prompt
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
name|error
argument_list|(
literal|"Too many breakpoints (> %d) for the E7000\n"
argument_list|,
name|MAX_E7000DEBUG_BREAKPOINTS
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|e7000_remove_breakpoint
parameter_list|(
name|addr
parameter_list|,
name|shadow
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|shadow
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_E7000DEBUG_BREAKPOINTS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|breakaddr
index|[
name|i
index|]
operator|==
name|addr
condition|)
block|{
name|breakaddr
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|HARD_BREAKPOINTS
if|if
condition|(
name|BC_BREAKPOINTS
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"BC%d - \r"
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"B - %x\r"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|expect_prompt
argument_list|()
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"B - %x\r"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Replace the insn under the break */
block|e7000_write_inferior_memory (addr, shadow, 2);
endif|#
directive|endif
endif|#
directive|endif
return|return
literal|0
return|;
block|}
name|warning
argument_list|(
literal|"Can't find breakpoint associated with 0x%x\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Put a command string, in args, out to STDBUG.  Output from STDBUG    is placed on the users terminal until the prompt is seen. */
end_comment

begin_function
specifier|static
name|void
name|e7000_command
parameter_list|(
name|args
parameter_list|,
name|fromtty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|fromtty
decl_stmt|;
block|{
comment|/* FIXME: arbitrary limit on length of args.  */
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|;
name|echo
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|e7000_desc
condition|)
name|error
argument_list|(
literal|"e7000 target not open."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
block|{
name|puts_e7000debug
argument_list|(
literal|"\r"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s\r"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|echo
operator|++
expr_stmt|;
name|ctrl_c
operator|=
literal|2
expr_stmt|;
name|expect_full_prompt
argument_list|()
expr_stmt|;
name|echo
operator|--
expr_stmt|;
name|ctrl_c
operator|=
literal|0
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Who knows what the command did... */
name|registers_changed
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|e7000_drain_command
parameter_list|(
name|args
parameter_list|,
name|fromtty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|fromtty
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|puts_e7000debug
argument_list|(
literal|"end\r"
argument_list|)
expr_stmt|;
name|putchar_e7000
argument_list|(
name|CTRLC
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|SERIAL_READCHAR
argument_list|(
name|e7000_desc
argument_list|,
literal|1
argument_list|)
operator|!=
name|SERIAL_TIMEOUT
operator|)
condition|)
block|{
if|if
condition|(
name|quit_flag
condition|)
block|{
name|putchar_e7000
argument_list|(
name|CTRLC
argument_list|)
expr_stmt|;
name|quit_flag
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|>
literal|' '
operator|&&
name|c
operator|<
literal|127
condition|)
name|printf
argument_list|(
literal|"%c"
argument_list|,
name|c
operator|&
literal|0xff
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"<%x>"
argument_list|,
name|c
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|NITEMS
value|7
end_define

begin_function
specifier|static
name|int
name|why_stop
parameter_list|()
block|{
specifier|static
name|char
modifier|*
name|strings
index|[
name|NITEMS
index|]
init|=
block|{
literal|"STEP NORMAL"
block|,
literal|"BREAK POINT"
block|,
literal|"BREAK KEY"
block|,
literal|"BREAK CONDI"
block|,
literal|"CYCLE ACCESS"
block|,
literal|"ILLEGAL INSTRUCTION"
block|,
literal|"WRITE PROTECT"
block|,   }
decl_stmt|;
name|char
modifier|*
name|p
index|[
name|NITEMS
index|]
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NITEMS
condition|;
operator|++
name|i
control|)
name|p
index|[
name|i
index|]
operator|=
name|strings
index|[
name|i
index|]
expr_stmt|;
name|c
operator|=
name|gch
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NITEMS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
operator|*
operator|(
name|p
index|[
name|i
index|]
operator|)
condition|)
block|{
name|p
index|[
name|i
index|]
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|p
index|[
name|i
index|]
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* found one of the choices */
return|return
name|i
return|;
block|}
block|}
else|else
name|p
index|[
name|i
index|]
operator|=
name|strings
index|[
name|i
index|]
expr_stmt|;
block|}
name|c
operator|=
name|gch
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Suck characters, if a string match, then return the strings index    otherwise echo them.  */
end_comment

begin_function
name|int
name|expect_n
parameter_list|(
name|strings
parameter_list|)
name|char
modifier|*
modifier|*
name|strings
decl_stmt|;
block|{
name|char
argument_list|*
operator|(
name|ptr
index|[
literal|10
index|]
operator|)
argument_list|;
name|int
name|n
argument_list|;
name|int
name|c
argument_list|;
name|char
name|saveaway
index|[
literal|100
index|]
argument_list|;
name|char
operator|*
name|buffer
operator|=
name|saveaway
argument_list|;
comment|/* Count number of expect strings  */
argument_list|for
operator|(
name|n
operator|=
literal|0
expr|;
name|strings
index|[
name|n
index|]
expr|;
name|n
operator|++
operator|)
block|{
name|ptr
index|[
name|n
index|]
operator|=
name|strings
index|[
name|n
index|]
block|;     }
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|gotone
init|=
literal|0
decl_stmt|;
name|c
operator|=
name|SERIAL_READCHAR
argument_list|(
name|e7000_desc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|SERIAL_TIMEOUT
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"[waiting for e7000...]\n"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|__GO32__
if|if
condition|(
name|kbhit
argument_list|()
condition|)
block|{
name|int
name|k
init|=
name|getkey
argument_list|()
decl_stmt|;
if|if
condition|(
name|k
operator|==
literal|1
condition|)
name|quit_flag
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|quit_flag
condition|)
block|{
name|putchar_e7000
argument_list|(
name|CTRLC
argument_list|)
expr_stmt|;
comment|/* interrupt the running program */
name|quit_flag
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
name|ptr
index|[
name|i
index|]
index|[
literal|0
index|]
condition|)
block|{
name|ptr
index|[
name|i
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|ptr
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
comment|/* Gone all the way */
return|return
name|i
return|;
block|}
name|gotone
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ptr
index|[
name|i
index|]
operator|=
name|strings
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gotone
condition|)
block|{
comment|/* Save it up incase we find that there was no match */
operator|*
name|buffer
operator|++
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|buffer
operator|!=
name|saveaway
condition|)
block|{
operator|*
name|buffer
operator|++
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|saveaway
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
name|SERIAL_TIMEOUT
condition|)
block|{
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* We subtract two from the pc here rather than use    DECR_PC_AFTER_BREAK since the e7000 doesn't always add two to the    pc, and the simulators never do. */
end_comment

begin_function
specifier|static
name|void
name|sub2_from_pc
parameter_list|()
block|{
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|char
name|buf2
index|[
literal|200
index|]
decl_stmt|;
name|store_signed_integer
argument_list|(
name|buf
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|PC_REGNUM
argument_list|)
argument_list|,
name|read_register
argument_list|(
name|PC_REGNUM
argument_list|)
operator|-
literal|2
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|PC_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf2
argument_list|,
literal|".PC %x\r"
argument_list|,
name|read_register
argument_list|(
name|PC_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|puts_e7000debug
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|WAS_SLEEP
value|0
end_define

begin_define
define|#
directive|define
name|WAS_INT
value|1
end_define

begin_define
define|#
directive|define
name|WAS_RUNNING
value|2
end_define

begin_define
define|#
directive|define
name|WAS_OTHER
value|3
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|estrings
index|[]
init|=
block|{
literal|"** SLEEP"
block|,
literal|"BREAK !"
block|,
literal|"** PC"
block|,
literal|"PC"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Wait until the remote machine stops, then return, storing status in    STATUS just as `wait' would.  */
end_comment

begin_function
specifier|static
name|int
name|e7000_wait
parameter_list|(
name|pid
parameter_list|,
name|status
parameter_list|)
name|int
name|pid
decl_stmt|;
name|struct
name|target_waitstatus
modifier|*
name|status
decl_stmt|;
block|{
name|int
name|stop_reason
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|int
name|running_count
init|=
literal|0
decl_stmt|;
name|int
name|had_sleep
init|=
literal|0
decl_stmt|;
name|int
name|loop
init|=
literal|1
decl_stmt|;
comment|/* Then echo chars until PC= string seen */
name|gch
argument_list|()
expr_stmt|;
comment|/* Drop cr */
name|gch
argument_list|()
expr_stmt|;
comment|/* and space */
while|while
condition|(
name|loop
condition|)
block|{
switch|switch
condition|(
name|expect_n
argument_list|(
name|estrings
argument_list|)
condition|)
block|{
case|case
name|WAS_OTHER
case|:
comment|/* how did this happen ? */
name|loop
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|WAS_SLEEP
case|:
name|had_sleep
operator|=
literal|1
expr_stmt|;
name|putchar_e7000
argument_list|(
name|CTRLC
argument_list|)
expr_stmt|;
name|loop
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|WAS_INT
case|:
name|loop
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|WAS_RUNNING
case|:
name|running_count
operator|++
expr_stmt|;
if|if
condition|(
name|running_count
operator|==
literal|20
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"[running...]\n"
argument_list|)
expr_stmt|;
name|running_count
operator|=
literal|0
expr_stmt|;
block|}
break|break;
default|default:
comment|/* error? */
break|break;
block|}
block|}
comment|/* Skip till the PC= */
name|expect
argument_list|(
literal|"="
argument_list|)
expr_stmt|;
name|fetch_regs_from_dump
argument_list|(
name|gch
argument_list|,
name|want_nopc
argument_list|)
expr_stmt|;
comment|/* And supply the extra ones the simulator uses */
for|for
control|(
name|regno
operator|=
name|NUM_REALREGS
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
block|{
name|int
name|buf
init|=
literal|0
decl_stmt|;
name|supply_register
argument_list|(
name|regno
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|buf
argument_list|)
expr_stmt|;
block|}
name|stop_reason
operator|=
name|why_stop
argument_list|()
expr_stmt|;
name|expect_full_prompt
argument_list|()
expr_stmt|;
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
switch|switch
condition|(
name|stop_reason
condition|)
block|{
case|case
literal|1
case|:
comment|/* Breakpoint */
name|write_pc
argument_list|(
name|read_pc
argument_list|()
argument_list|)
expr_stmt|;
comment|/* PC is always off by 2 for breakpoints */
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* Single step */
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Interrupt */
if|if
condition|(
name|had_sleep
condition|)
block|{
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
name|sub2_from_pc
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_INT
expr_stmt|;
block|}
break|break;
case|case
literal|3
case|:
break|break;
case|case
literal|4
case|:
name|printf_unfiltered
argument_list|(
literal|"a cycle address error?\n"
argument_list|)
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_UNKNOWN
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_ILL
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_SEGV
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* Anything else (NITEMS + 1) */
name|printf_unfiltered
argument_list|(
literal|"a write protect error?\n"
argument_list|)
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_UNKNOWN
expr_stmt|;
break|break;
default|default:
comment|/* Get the user's attention - this should never happen. */
name|abort
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Define the target subroutine names. */
end_comment

begin_decl_stmt
name|struct
name|target_ops
name|e7000_ops
init|=
block|{
literal|"e7000"
block|,
literal|"Remote Hitachi e7000 target"
block|,
literal|"Use a remote Hitachi e7000 ICE connected by a serial line,\n\ or a network connection.\n\ Arguments are the name of the device for the serial line,\n\ the speed to connect at in bits per second.\n\ eg\n\ target e7000 /dev/ttya 9600\n\ target e7000 foobar"
block|,
name|e7000_open
block|,
comment|/* to_open */
name|e7000_close
block|,
comment|/* to_close */
literal|0
block|,
comment|/* to_attach */
name|e7000_detach
block|,
comment|/* to_detach */
name|e7000_resume
block|,
comment|/* to_resume */
name|e7000_wait
block|,
comment|/* to_wait */
name|e7000_fetch_register
block|,
comment|/* to_fetch_registers */
name|e7000_store_register
block|,
comment|/* to_store_registers */
name|e7000_prepare_to_store
block|,
comment|/* to_prepare_to_store */
name|e7000_xfer_inferior_memory
block|,
comment|/* to_xfer_memory */
name|e7000_files_info
block|,
comment|/* to_files_info */
name|e7000_insert_breakpoint
block|,
comment|/* to_insert_breakpoint */
name|e7000_remove_breakpoint
block|,
comment|/* to_remove_breakpoint */
literal|0
block|,
comment|/* to_terminal_init */
literal|0
block|,
comment|/* to_terminal_inferior */
literal|0
block|,
comment|/* to_terminal_ours_for_output */
literal|0
block|,
comment|/* to_terminal_ours */
literal|0
block|,
comment|/* to_terminal_info */
name|e7000_kill
block|,
comment|/* to_kill */
name|e7000_load
block|,
comment|/* to_load */
literal|0
block|,
comment|/* to_lookup_symbol */
name|e7000_create_inferior
block|,
comment|/* to_create_inferior */
name|e7000_mourn_inferior
block|,
comment|/* to_mourn_inferior */
literal|0
block|,
comment|/* to_can_run */
literal|0
block|,
comment|/* to_notice_signals */
literal|0
block|,
comment|/* to_thread_alive */
literal|0
block|,
comment|/* to_stop */
name|process_stratum
block|,
comment|/* to_stratum */
literal|0
block|,
comment|/* next (unused) */
literal|1
block|,
comment|/* to_has_all_memory */
literal|1
block|,
comment|/* to_has_memory */
literal|1
block|,
comment|/* to_has_stack */
literal|1
block|,
comment|/* to_has_registers */
literal|1
block|,
comment|/* to_has_execution */
literal|0
block|,
comment|/* to_sections */
literal|0
block|,
comment|/* to_sections_end */
name|OPS_MAGIC
block|,
comment|/* Always the last thing */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_remote_e7000
parameter_list|()
block|{
name|add_target
argument_list|(
operator|&
name|e7000_ops
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"e7000<command>"
argument_list|,
name|class_obscure
argument_list|,
name|e7000_command
argument_list|,
literal|"Send a command to the e7000 monitor."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"ftplogin<machine><name><passwd><dir>"
argument_list|,
name|class_obscure
argument_list|,
name|e7000_login_command
argument_list|,
literal|"Login to machine and change to directory."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"ftpload<file>"
argument_list|,
name|class_obscure
argument_list|,
name|e7000_ftp_command
argument_list|,
literal|"Fetch and load a file from previously described place."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"drain"
argument_list|,
name|class_obscure
argument_list|,
name|e7000_drain_command
argument_list|,
literal|"Drain pending e7000 text buffers."
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

