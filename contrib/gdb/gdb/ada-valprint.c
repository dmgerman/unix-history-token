begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Support for printing Ada values for GDB, the GNU debugger.      Copyright 1986, 1988, 1989, 1991, 1992, 1993, 1994, 1997, 2001              Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"valprint.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"annotate.h"
end_include

begin_include
include|#
directive|include
file|"ada-lang.h"
end_include

begin_include
include|#
directive|include
file|"c-lang.h"
end_include

begin_include
include|#
directive|include
file|"infcall.h"
end_include

begin_comment
comment|/* Encapsulates arguments to ada_val_print. */
end_comment

begin_struct
struct|struct
name|ada_val_print_args
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|valaddr0
decl_stmt|;
name|int
name|embedded_offset
decl_stmt|;
name|CORE_ADDR
name|address
decl_stmt|;
name|struct
name|ui_file
modifier|*
name|stream
decl_stmt|;
name|int
name|format
decl_stmt|;
name|int
name|deref_ref
decl_stmt|;
name|int
name|recurse
decl_stmt|;
name|enum
name|val_prettyprint
name|pretty
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|print_record
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|enum
name|val_prettyprint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|print_field_values
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|enum
name|val_prettyprint
parameter_list|,
name|int
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|print_variant_part
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|enum
name|val_prettyprint
parameter_list|,
name|int
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|val_print_packed_array_elements
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|char
modifier|*
name|valaddr
parameter_list|,
name|int
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|enum
name|val_prettyprint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|adjust_type_signedness
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ada_val_print_stub
parameter_list|(
name|void
modifier|*
name|args0
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ada_val_print_1
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|CORE_ADDR
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|enum
name|val_prettyprint
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Make TYPE unsigned if its range of values includes no negatives. */
end_comment

begin_function
specifier|static
name|void
name|adjust_type_signedness
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|!=
name|NULL
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_RANGE
operator|&&
name|TYPE_LOW_BOUND
argument_list|(
name|type
argument_list|)
operator|>=
literal|0
condition|)
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator||=
name|TYPE_FLAG_UNSIGNED
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Assuming TYPE is a simple array type, prints its lower bound on STREAM,    if non-standard (i.e., other than 1 for numbers, other than lower bound    of index type for enumerated type). Returns 1 if something printed,     otherwise 0. */
end_comment

begin_function
specifier|static
name|int
name|print_optional_low_bound
parameter_list|(
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|index_type
decl_stmt|;
name|long
name|low_bound
decl_stmt|;
name|index_type
operator|=
name|TYPE_INDEX_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|low_bound
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|index_type
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|index_type
argument_list|)
operator|==
name|TYPE_CODE_RANGE
condition|)
block|{
name|low_bound
operator|=
name|TYPE_LOW_BOUND
argument_list|(
name|index_type
argument_list|)
expr_stmt|;
name|index_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|index_type
argument_list|)
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|index_type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_ENUM
case|:
if|if
condition|(
name|low_bound
operator|==
name|TYPE_FIELD_BITPOS
argument_list|(
name|index_type
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|TYPE_CODE_UNDEF
case|:
name|index_type
operator|=
name|builtin_type_long
expr_stmt|;
comment|/* FALL THROUGH */
default|default:
if|if
condition|(
name|low_bound
operator|==
literal|1
condition|)
return|return
literal|0
return|;
break|break;
block|}
name|ada_print_scalar
argument_list|(
name|index_type
argument_list|,
operator|(
name|LONGEST
operator|)
name|low_bound
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" => "
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  Version of val_print_array_elements for GNAT-style packed arrays.     Prints elements of packed array of type TYPE at bit offset     BITOFFSET from VALADDR on STREAM.  Formats according to FORMAT and     separates with commas. RECURSE is the recursion (nesting) level.     If PRETTY, uses "prettier" format. TYPE must have been decoded (as     by ada_coerce_to_simple_array).  */
end_comment

begin_function
specifier|static
name|void
name|val_print_packed_array_elements
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|valaddr
parameter_list|,
name|int
name|bitoffset
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|format
parameter_list|,
name|int
name|recurse
parameter_list|,
name|enum
name|val_prettyprint
name|pretty
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|things_printed
init|=
literal|0
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
name|struct
name|type
modifier|*
name|elttype
decl_stmt|;
name|unsigned
name|eltlen
decl_stmt|;
comment|/* Position of the array element we are examining to see      whether it is repeated.  */
name|unsigned
name|int
name|rep1
decl_stmt|;
comment|/* Number of repetitions we have detected so far.  */
name|unsigned
name|int
name|reps
decl_stmt|;
name|unsigned
name|long
name|bitsize
init|=
name|TYPE_FIELD_BITSIZE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|struct
name|value
modifier|*
name|mark
init|=
name|value_mark
argument_list|()
decl_stmt|;
name|elttype
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|eltlen
operator|=
name|TYPE_LENGTH
argument_list|(
name|check_typedef
argument_list|(
name|elttype
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|LONGEST
name|low
decl_stmt|,
name|high
decl_stmt|;
if|if
condition|(
name|get_discrete_bounds
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|high
argument_list|)
operator|<
literal|0
condition|)
name|len
operator|=
literal|1
expr_stmt|;
else|else
name|len
operator|=
name|high
operator|-
name|low
operator|+
literal|1
expr_stmt|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
name|annotate_array_section_begin
argument_list|(
name|i
argument_list|,
name|elttype
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|len
operator|&&
name|things_printed
operator|<
name|print_max
condition|)
block|{
name|struct
name|value
modifier|*
name|v0
decl_stmt|,
modifier|*
name|v1
decl_stmt|;
name|int
name|i0
decl_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|prettyprint_arrays
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|",\n"
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
name|wrap_here
argument_list|(
name|n_spaces
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|)
argument_list|)
expr_stmt|;
name|i0
operator|=
name|i
expr_stmt|;
name|v0
operator|=
name|ada_value_primitive_packed_val
argument_list|(
name|NULL
argument_list|,
name|valaddr
argument_list|,
operator|(
name|i0
operator|*
name|bitsize
operator|)
operator|/
name|HOST_CHAR_BIT
argument_list|,
operator|(
name|i0
operator|*
name|bitsize
operator|)
operator|%
name|HOST_CHAR_BIT
argument_list|,
name|bitsize
argument_list|,
name|elttype
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|i
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|len
condition|)
break|break;
name|v1
operator|=
name|ada_value_primitive_packed_val
argument_list|(
name|NULL
argument_list|,
name|valaddr
argument_list|,
operator|(
name|i
operator|*
name|bitsize
operator|)
operator|/
name|HOST_CHAR_BIT
argument_list|,
operator|(
name|i
operator|*
name|bitsize
operator|)
operator|%
name|HOST_CHAR_BIT
argument_list|,
name|bitsize
argument_list|,
name|elttype
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|VALUE_CONTENTS
argument_list|(
name|v0
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|v1
argument_list|)
argument_list|,
name|eltlen
argument_list|)
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|-
name|i0
operator|>
name|repeat_count_threshold
condition|)
block|{
name|val_print
argument_list|(
name|elttype
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|v0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
name|annotate_elt_rep
argument_list|(
name|i
operator|-
name|i0
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<repeats %u times>"
argument_list|,
name|i
operator|-
name|i0
argument_list|)
expr_stmt|;
name|annotate_elt_rep_end
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|+=
literal|1
control|)
block|{
if|if
condition|(
name|j
operator|>
name|i0
condition|)
block|{
if|if
condition|(
name|prettyprint_arrays
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|",\n"
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
name|wrap_here
argument_list|(
name|n_spaces
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|val_print
argument_list|(
name|elttype
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|v0
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
name|annotate_elt
argument_list|()
expr_stmt|;
block|}
block|}
name|things_printed
operator|+=
name|i
operator|-
name|i0
expr_stmt|;
block|}
name|annotate_array_section_end
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|len
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
block|}
name|value_free_to_mark
argument_list|(
name|mark
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|type
modifier|*
name|printable_val_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|valaddr
parameter_list|)
block|{
return|return
name|ada_to_fixed_type
argument_list|(
name|ada_aligned_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|valaddr
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Print the character C on STREAM as part of the contents of a literal    string whose delimiter is QUOTER.  TYPE_LEN is the length in bytes    (1 or 2) of the character. */
end_comment

begin_function
name|void
name|ada_emit_char
parameter_list|(
name|int
name|c
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|quoter
parameter_list|,
name|int
name|type_len
parameter_list|)
block|{
if|if
condition|(
name|type_len
operator|!=
literal|2
condition|)
name|type_len
operator|=
literal|1
expr_stmt|;
name|c
operator|&=
operator|(
literal|1
operator|<<
operator|(
name|type_len
operator|*
name|TARGET_CHAR_BIT
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|isascii
argument_list|(
name|c
argument_list|)
operator|&&
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|quoter
operator|&&
name|c
operator|==
literal|'"'
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"[\"%c\"]"
argument_list|,
name|quoter
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"[\"%0*x\"]"
argument_list|,
name|type_len
operator|*
literal|2
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Character #I of STRING, given that TYPE_LEN is the size in bytes (1    or 2) of a character. */
end_comment

begin_function
specifier|static
name|int
name|char_at
parameter_list|(
name|char
modifier|*
name|string
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|type_len
parameter_list|)
block|{
if|if
condition|(
name|type_len
operator|==
literal|1
condition|)
return|return
name|string
index|[
name|i
index|]
return|;
else|else
return|return
operator|(
name|int
operator|)
name|extract_unsigned_integer
argument_list|(
name|string
operator|+
literal|2
operator|*
name|i
argument_list|,
literal|2
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|ada_printchar
parameter_list|(
name|int
name|c
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|fputs_filtered
argument_list|(
literal|"'"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|ada_emit_char
argument_list|(
name|c
argument_list|,
name|stream
argument_list|,
literal|'\''
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"'"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* [From print_type_scalar in typeprint.c].   Print VAL on STREAM in a    form appropriate for TYPE. */
end_comment

begin_function
name|void
name|ada_print_scalar
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|LONGEST
name|val
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_ENUM
case|:
name|len
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|==
name|val
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|<
name|len
condition|)
block|{
name|fputs_filtered
argument_list|(
name|ada_enum_name
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|print_longest
argument_list|(
name|stream
argument_list|,
literal|'d'
argument_list|,
literal|0
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_INT
case|:
name|print_longest
argument_list|(
name|stream
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
literal|'u'
else|:
literal|'d'
argument_list|,
literal|0
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_CHAR
case|:
name|LA_PRINT_CHAR
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|val
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_BOOL
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|val
condition|?
literal|"true"
else|:
literal|"false"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_RANGE
case|:
name|ada_print_scalar
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|val
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|TYPE_CODE_UNDEF
case|:
case|case
name|TYPE_CODE_PTR
case|:
case|case
name|TYPE_CODE_ARRAY
case|:
case|case
name|TYPE_CODE_STRUCT
case|:
case|case
name|TYPE_CODE_UNION
case|:
case|case
name|TYPE_CODE_FUNC
case|:
case|case
name|TYPE_CODE_FLT
case|:
case|case
name|TYPE_CODE_VOID
case|:
case|case
name|TYPE_CODE_SET
case|:
case|case
name|TYPE_CODE_STRING
case|:
case|case
name|TYPE_CODE_ERROR
case|:
case|case
name|TYPE_CODE_MEMBER
case|:
case|case
name|TYPE_CODE_METHOD
case|:
case|case
name|TYPE_CODE_REF
case|:
name|warning
argument_list|(
literal|"internal error: unhandled type in ada_print_scalar"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Invalid type code in symbol table."
argument_list|)
expr_stmt|;
block|}
name|gdb_flush
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the character string STRING, printing at most LENGTH characters.    Printing stops early if the number hits print_max; repeat counts    are printed as appropriate.  Print ellipses at the end if we    had to stop before printing LENGTH characters, or if    FORCE_ELLIPSES.   TYPE_LEN is the length (1 or 2) of the character type.  */
end_comment

begin_function
specifier|static
name|void
name|printstr
parameter_list|(
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|char
modifier|*
name|string
parameter_list|,
name|unsigned
name|int
name|length
parameter_list|,
name|int
name|force_ellipses
parameter_list|,
name|int
name|type_len
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|things_printed
init|=
literal|0
decl_stmt|;
name|int
name|in_quotes
init|=
literal|0
decl_stmt|;
name|int
name|need_comma
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"\"\""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
operator|&&
name|things_printed
operator|<
name|print_max
condition|;
name|i
operator|+=
literal|1
control|)
block|{
comment|/* Position of the character we are examining          to see whether it is repeated.  */
name|unsigned
name|int
name|rep1
decl_stmt|;
comment|/* Number of repetitions we have detected so far.  */
name|unsigned
name|int
name|reps
decl_stmt|;
name|QUIT
expr_stmt|;
if|if
condition|(
name|need_comma
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|0
expr_stmt|;
block|}
name|rep1
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|reps
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|rep1
operator|<
name|length
operator|&&
name|char_at
argument_list|(
name|string
argument_list|,
name|rep1
argument_list|,
name|type_len
argument_list|)
operator|==
name|char_at
argument_list|(
name|string
argument_list|,
name|i
argument_list|,
name|type_len
argument_list|)
condition|)
block|{
name|rep1
operator|+=
literal|1
expr_stmt|;
name|reps
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|reps
operator|>
name|repeat_count_threshold
condition|)
block|{
if|if
condition|(
name|in_quotes
condition|)
block|{
if|if
condition|(
name|inspect_it
condition|)
name|fputs_filtered
argument_list|(
literal|"\\\", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|"\", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|in_quotes
operator|=
literal|0
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
literal|"'"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|ada_emit_char
argument_list|(
name|char_at
argument_list|(
name|string
argument_list|,
name|i
argument_list|,
name|type_len
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|'\''
argument_list|,
name|type_len
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"'"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<repeats %u times>"
argument_list|,
name|reps
argument_list|)
expr_stmt|;
name|i
operator|=
name|rep1
operator|-
literal|1
expr_stmt|;
name|things_printed
operator|+=
name|repeat_count_threshold
expr_stmt|;
name|need_comma
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|in_quotes
condition|)
block|{
if|if
condition|(
name|inspect_it
condition|)
name|fputs_filtered
argument_list|(
literal|"\\\""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|"\""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|in_quotes
operator|=
literal|1
expr_stmt|;
block|}
name|ada_emit_char
argument_list|(
name|char_at
argument_list|(
name|string
argument_list|,
name|i
argument_list|,
name|type_len
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|'"'
argument_list|,
name|type_len
argument_list|)
expr_stmt|;
name|things_printed
operator|+=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Terminate the quotes if necessary.  */
if|if
condition|(
name|in_quotes
condition|)
block|{
if|if
condition|(
name|inspect_it
condition|)
name|fputs_filtered
argument_list|(
literal|"\\\""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|"\""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|force_ellipses
operator|||
name|i
operator|<
name|length
condition|)
name|fputs_filtered
argument_list|(
literal|"..."
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ada_printstr
parameter_list|(
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|char
modifier|*
name|string
parameter_list|,
name|unsigned
name|int
name|length
parameter_list|,
name|int
name|force_ellipses
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|printstr
argument_list|(
name|stream
argument_list|,
name|string
argument_list|,
name|length
argument_list|,
name|force_ellipses
argument_list|,
name|width
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print data of type TYPE located at VALADDR (within GDB), which came from    the inferior at address ADDRESS, onto stdio stream STREAM according to    FORMAT (a letter as for the printf % codes or 0 for natural format).      The data at VALADDR is in target byte order.     If the data is printed as a string, returns the number of string characters    printed.     If DEREF_REF is nonzero, then dereference references, otherwise just print    them like pointers.     RECURSE indicates the amount of indentation to supply before    continuation lines; this amount is roughly twice the value of RECURSE.     When PRETTY is non-zero, prints record fields on separate lines.    (For some reason, the current version of gdb instead uses a global    variable---prettyprint_arrays--- to causes a similar effect on    arrays.)  */
end_comment

begin_function
name|int
name|ada_val_print
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|valaddr0
parameter_list|,
name|int
name|embedded_offset
parameter_list|,
name|CORE_ADDR
name|address
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|format
parameter_list|,
name|int
name|deref_ref
parameter_list|,
name|int
name|recurse
parameter_list|,
name|enum
name|val_prettyprint
name|pretty
parameter_list|)
block|{
name|struct
name|ada_val_print_args
name|args
decl_stmt|;
name|args
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|args
operator|.
name|valaddr0
operator|=
name|valaddr0
expr_stmt|;
name|args
operator|.
name|embedded_offset
operator|=
name|embedded_offset
expr_stmt|;
name|args
operator|.
name|address
operator|=
name|address
expr_stmt|;
name|args
operator|.
name|stream
operator|=
name|stream
expr_stmt|;
name|args
operator|.
name|format
operator|=
name|format
expr_stmt|;
name|args
operator|.
name|deref_ref
operator|=
name|deref_ref
expr_stmt|;
name|args
operator|.
name|recurse
operator|=
name|recurse
expr_stmt|;
name|args
operator|.
name|pretty
operator|=
name|pretty
expr_stmt|;
return|return
name|catch_errors
argument_list|(
name|ada_val_print_stub
argument_list|,
operator|&
name|args
argument_list|,
name|NULL
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Helper for ada_val_print; used as argument to catch_errors to    unmarshal the arguments to ada_val_print_1, which does the work. */
end_comment

begin_function
specifier|static
name|int
name|ada_val_print_stub
parameter_list|(
name|void
modifier|*
name|args0
parameter_list|)
block|{
name|struct
name|ada_val_print_args
modifier|*
name|argsp
init|=
operator|(
expr|struct
name|ada_val_print_args
operator|*
operator|)
name|args0
decl_stmt|;
return|return
name|ada_val_print_1
argument_list|(
name|argsp
operator|->
name|type
argument_list|,
name|argsp
operator|->
name|valaddr0
argument_list|,
name|argsp
operator|->
name|embedded_offset
argument_list|,
name|argsp
operator|->
name|address
argument_list|,
name|argsp
operator|->
name|stream
argument_list|,
name|argsp
operator|->
name|format
argument_list|,
name|argsp
operator|->
name|deref_ref
argument_list|,
name|argsp
operator|->
name|recurse
argument_list|,
name|argsp
operator|->
name|pretty
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* See the comment on ada_val_print.  This function differs in that it  * does not catch evaluation errors (leaving that to ada_val_print). */
end_comment

begin_function
specifier|static
name|int
name|ada_val_print_1
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|valaddr0
parameter_list|,
name|int
name|embedded_offset
parameter_list|,
name|CORE_ADDR
name|address
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|format
parameter_list|,
name|int
name|deref_ref
parameter_list|,
name|int
name|recurse
parameter_list|,
name|enum
name|val_prettyprint
name|pretty
parameter_list|)
block|{
name|unsigned
name|int
name|len
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|type
modifier|*
name|elttype
decl_stmt|;
name|unsigned
name|int
name|eltlen
decl_stmt|;
name|LONGEST
name|val
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|valaddr
init|=
name|valaddr0
operator|+
name|embedded_offset
decl_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ada_is_array_descriptor
argument_list|(
name|type
argument_list|)
operator|||
name|ada_is_packed_array_type
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|int
name|retn
decl_stmt|;
name|struct
name|value
modifier|*
name|mark
init|=
name|value_mark
argument_list|()
decl_stmt|;
name|struct
name|value
modifier|*
name|val
decl_stmt|;
name|val
operator|=
name|value_from_contents_and_address
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|val
operator|=
name|ada_coerce_to_simple_array_ptr
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|NULL
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"(null)"
argument_list|)
expr_stmt|;
name|retn
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|retn
operator|=
name|ada_val_print_1
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
name|value_free_to_mark
argument_list|(
name|mark
argument_list|)
expr_stmt|;
return|return
name|retn
return|;
block|}
name|valaddr
operator|=
name|ada_aligned_value_addr
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
expr_stmt|;
name|embedded_offset
operator|-=
name|valaddr
operator|-
name|valaddr0
operator|-
name|embedded_offset
expr_stmt|;
name|type
operator|=
name|printable_val_type
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
default|default:
return|return
name|c_val_print
argument_list|(
name|type
argument_list|,
name|valaddr0
argument_list|,
name|embedded_offset
argument_list|,
name|address
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|)
return|;
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_RANGE
case|:
if|if
condition|(
name|ada_is_fixed_point_type
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|LONGEST
name|v
init|=
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|len
operator|<
literal|4
condition|?
literal|"%.11g"
else|:
literal|"%.17g"
argument_list|,
operator|(
name|double
operator|)
name|ada_fixed_to_float
argument_list|(
name|type
argument_list|,
name|v
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|ada_is_vax_floating_type
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|struct
name|value
modifier|*
name|val
init|=
name|value_from_contents_and_address
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
name|address
argument_list|)
decl_stmt|;
name|struct
name|value
modifier|*
name|func
init|=
name|ada_vax_float_print_function
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|func
operator|!=
literal|0
condition|)
block|{
specifier|static
name|struct
name|type
modifier|*
name|parray_of_char
init|=
name|NULL
decl_stmt|;
name|struct
name|value
modifier|*
name|printable_val
decl_stmt|;
if|if
condition|(
name|parray_of_char
operator|==
name|NULL
condition|)
name|parray_of_char
operator|=
name|make_pointer_type
argument_list|(
name|create_array_type
argument_list|(
name|NULL
argument_list|,
name|builtin_type_char
argument_list|,
name|create_range_type
argument_list|(
name|NULL
argument_list|,
name|builtin_type_int
argument_list|,
literal|0
argument_list|,
literal|32
argument_list|)
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|printable_val
operator|=
name|value_ind
argument_list|(
name|value_cast
argument_list|(
name|parray_of_char
argument_list|,
name|call_function_by_hand
argument_list|(
name|func
argument_list|,
literal|1
argument_list|,
operator|&
name|val
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|printable_val
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* No special printing function.  Do as best we can. */
block|}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_RANGE
condition|)
block|{
name|struct
name|type
modifier|*
name|target_type
init|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_LENGTH
argument_list|(
name|target_type
argument_list|)
condition|)
block|{
comment|/* Obscure case of range type that has different length from 	         its base type.  Perform a conversion, or we will get a 	         nonsense value.  Actually, we could use the same 	         code regardless of lengths; I'm just avoiding a cast. */
name|struct
name|value
modifier|*
name|v
init|=
name|value_cast
argument_list|(
name|target_type
argument_list|,
name|value_from_contents_and_address
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|ada_val_print_1
argument_list|(
name|target_type
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|v
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
return|;
block|}
else|else
return|return
name|ada_val_print_1
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|valaddr0
argument_list|,
name|embedded_offset
argument_list|,
name|address
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|)
return|;
block|}
else|else
block|{
name|format
operator|=
name|format
condition|?
name|format
else|:
name|output_format
expr_stmt|;
if|if
condition|(
name|format
condition|)
block|{
name|print_scalar_formatted
argument_list|(
name|valaddr
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val_print_type_code_int
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|ada_is_character_type
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|ada_printchar
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
case|case
name|TYPE_CODE_ENUM
case|:
if|if
condition|(
name|format
condition|)
block|{
name|print_scalar_formatted
argument_list|(
name|valaddr
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
block|}
name|len
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|val
operator|=
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|<
name|len
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|ada_enum_name
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'\''
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%ld %s"
argument_list|,
operator|(
name|long
operator|)
name|val
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
name|name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|print_longest
argument_list|(
name|stream
argument_list|,
literal|'d'
argument_list|,
literal|0
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_UNION
case|:
case|case
name|TYPE_CODE_STRUCT
case|:
if|if
condition|(
name|ada_is_bogus_array_descriptor
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"(...?)"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|print_record
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
name|TYPE_CODE_ARRAY
case|:
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|>
literal|0
operator|&&
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
block|{
name|elttype
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|eltlen
operator|=
name|TYPE_LENGTH
argument_list|(
name|elttype
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|/
name|eltlen
expr_stmt|;
comment|/* For an array of chars, print with string syntax.  */
if|if
condition|(
name|ada_is_string_type
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|format
operator|==
literal|0
operator|||
name|format
operator|==
literal|'s'
operator|)
condition|)
block|{
if|if
condition|(
name|prettyprint_arrays
condition|)
block|{
name|print_spaces_filtered
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
comment|/* If requested, look for the first null char and only print 	         elements up to it.  */
if|if
condition|(
name|stop_print_at_null
condition|)
block|{
name|int
name|temp_len
decl_stmt|;
comment|/* Look for a NULL char. */
for|for
control|(
name|temp_len
operator|=
literal|0
init|;
name|temp_len
operator|<
name|len
operator|&&
name|temp_len
operator|<
name|print_max
operator|&&
name|char_at
argument_list|(
name|valaddr
argument_list|,
name|temp_len
argument_list|,
name|eltlen
argument_list|)
operator|!=
literal|0
condition|;
name|temp_len
operator|+=
literal|1
control|)
empty_stmt|;
name|len
operator|=
name|temp_len
expr_stmt|;
block|}
name|printstr
argument_list|(
name|stream
argument_list|,
name|valaddr
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|eltlen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
literal|0
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|print_optional_low_bound
argument_list|(
name|stream
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FIELD_BITSIZE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
name|val_print_packed_array_elements
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
else|else
name|val_print_array_elements
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
name|address
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
name|gdb_flush
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
case|case
name|TYPE_CODE_REF
case|:
name|elttype
operator|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|addressprint
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"@"
argument_list|)
expr_stmt|;
comment|/* Extract an address, assume that the address is unsigned.  */
name|print_address_numeric
argument_list|(
name|extract_unsigned_integer
argument_list|(
name|valaddr
argument_list|,
name|TARGET_PTR_BIT
operator|/
name|HOST_CHAR_BIT
argument_list|)
argument_list|,
literal|1
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|deref_ref
condition|)
name|fputs_filtered
argument_list|(
literal|": "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
comment|/* De-reference the reference */
if|if
condition|(
name|deref_ref
condition|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|elttype
argument_list|)
operator|!=
name|TYPE_CODE_UNDEF
condition|)
block|{
name|LONGEST
name|deref_val_int
init|=
operator|(
name|LONGEST
operator|)
name|unpack_pointer
argument_list|(
name|lookup_pointer_type
argument_list|(
name|builtin_type_void
argument_list|)
argument_list|,
name|valaddr
argument_list|)
decl_stmt|;
if|if
condition|(
name|deref_val_int
operator|!=
literal|0
condition|)
block|{
name|struct
name|value
modifier|*
name|deref_val
init|=
name|ada_value_ind
argument_list|(
name|value_from_longest
argument_list|(
name|lookup_pointer_type
argument_list|(
name|elttype
argument_list|)
argument_list|,
name|deref_val_int
argument_list|)
argument_list|)
decl_stmt|;
name|val_print
argument_list|(
name|VALUE_TYPE
argument_list|(
name|deref_val
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|deref_val
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|deref_val
argument_list|)
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
block|}
else|else
name|fputs_filtered
argument_list|(
literal|"(null)"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
name|fputs_filtered
argument_list|(
literal|"???"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|print_variant_part
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|field_num
parameter_list|,
name|char
modifier|*
name|valaddr
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|format
parameter_list|,
name|int
name|recurse
parameter_list|,
name|enum
name|val_prettyprint
name|pretty
parameter_list|,
name|int
name|comma_needed
parameter_list|,
name|struct
name|type
modifier|*
name|outer_type
parameter_list|,
name|char
modifier|*
name|outer_valaddr
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|var_type
init|=
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|field_num
argument_list|)
decl_stmt|;
name|int
name|which
init|=
name|ada_which_variant_applies
argument_list|(
name|var_type
argument_list|,
name|outer_type
argument_list|,
name|outer_valaddr
argument_list|)
decl_stmt|;
if|if
condition|(
name|which
operator|<
literal|0
condition|)
return|return
literal|0
return|;
else|else
return|return
name|print_field_values
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|var_type
argument_list|,
name|which
argument_list|)
argument_list|,
name|valaddr
operator|+
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|field_num
argument_list|)
operator|/
name|HOST_CHAR_BIT
operator|+
name|TYPE_FIELD_BITPOS
argument_list|(
name|var_type
argument_list|,
name|which
argument_list|)
operator|/
name|HOST_CHAR_BIT
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|,
name|comma_needed
argument_list|,
name|outer_type
argument_list|,
name|outer_valaddr
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ada_value_print
parameter_list|(
name|struct
name|value
modifier|*
name|val0
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|format
parameter_list|,
name|enum
name|val_prettyprint
name|pretty
parameter_list|)
block|{
name|char
modifier|*
name|valaddr
init|=
name|VALUE_CONTENTS
argument_list|(
name|val0
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|address
init|=
name|VALUE_ADDRESS
argument_list|(
name|val0
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|val0
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|type
init|=
name|ada_to_fixed_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val0
argument_list|)
argument_list|,
name|valaddr
argument_list|,
name|address
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|struct
name|value
modifier|*
name|val
init|=
name|value_from_contents_and_address
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
name|address
argument_list|)
decl_stmt|;
comment|/* If it is a pointer, indicate what it points to. */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_REF
condition|)
block|{
comment|/* Hack:  remove (char *) for char strings.  Their          type is indicated by the quoted string anyway. */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|&&
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|&&
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|&&
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Print nothing */
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|") "
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ada_is_array_descriptor
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|") "
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ada_is_bogus_array_descriptor
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|") (...?)"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
operator|(
name|val_print
argument_list|(
name|type
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|,
literal|0
argument_list|,
name|address
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|pretty
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_record
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|valaddr
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|format
parameter_list|,
name|int
name|recurse
parameter_list|,
name|enum
name|val_prettyprint
name|pretty
parameter_list|)
block|{
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
if|if
condition|(
name|print_field_values
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|,
literal|0
argument_list|,
name|type
argument_list|,
name|valaddr
argument_list|)
operator|!=
literal|0
operator|&&
name|pretty
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print out fields of value at VALADDR having structure type TYPE.       TYPE, VALADDR, STREAM, FORMAT, RECURSE, and PRETTY have the    same meanings as in ada_print_value and ada_val_print.        OUTER_TYPE and OUTER_VALADDR give type and address of enclosing record    (used to get discriminant values when printing variant parts).     COMMA_NEEDED is 1 if fields have been printed at the current recursion     level, so that a comma is needed before any field printed by this    call.      Returns 1 if COMMA_NEEDED or any fields were printed. */
end_comment

begin_function
specifier|static
name|int
name|print_field_values
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|valaddr
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|format
parameter_list|,
name|int
name|recurse
parameter_list|,
name|enum
name|val_prettyprint
name|pretty
parameter_list|,
name|int
name|comma_needed
parameter_list|,
name|struct
name|type
modifier|*
name|outer_type
parameter_list|,
name|char
modifier|*
name|outer_valaddr
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|len
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
literal|1
control|)
block|{
if|if
condition|(
name|ada_is_ignored_field
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|ada_is_wrapper_field
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|comma_needed
operator|=
name|print_field_values
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|valaddr
operator|+
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|/
name|HOST_CHAR_BIT
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|,
name|comma_needed
argument_list|,
name|type
argument_list|,
name|valaddr
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|ada_is_variant_part
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|comma_needed
operator|=
name|print_variant_part
argument_list|(
name|type
argument_list|,
name|i
argument_list|,
name|valaddr
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|,
name|comma_needed
argument_list|,
name|outer_type
argument_list|,
name|outer_valaddr
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|comma_needed
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|comma_needed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pretty
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wrap_here
argument_list|(
name|n_spaces
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inspect_it
condition|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
name|fputs_filtered
argument_list|(
literal|"\"( ptr \""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|"\"( nodef \""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_symbol_filtered
argument_list|(
name|stream
argument_list|,
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|language_cplus
argument_list|,
name|DMGL_NO_OPTS
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"\" \""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_symbol_filtered
argument_list|(
name|stream
argument_list|,
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|language_cplus
argument_list|,
name|DMGL_NO_OPTS
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"\") \""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|annotate_field_begin
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%.*s"
argument_list|,
name|ada_name_prefix_len
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|annotate_field_name_end
argument_list|()
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" => "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|annotate_field_value
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_FIELD_PACKED
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|struct
name|value
modifier|*
name|v
decl_stmt|;
comment|/* Bitfields require special handling, especially due to byte 	     order problems.  */
if|if
condition|(
name|TYPE_CPLUS_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
operator|&&
name|TYPE_FIELD_IGNORE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"<optimized out or zero length>"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|bit_pos
init|=
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|bit_size
init|=
name|TYPE_FIELD_BITSIZE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|adjust_type_signedness
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|=
name|ada_value_primitive_packed_val
argument_list|(
name|NULL
argument_list|,
name|valaddr
argument_list|,
name|bit_pos
operator|/
name|HOST_CHAR_BIT
argument_list|,
name|bit_pos
operator|%
name|HOST_CHAR_BIT
argument_list|,
name|bit_size
argument_list|,
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|val_print
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|v
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|ada_val_print
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|valaddr
operator|+
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|/
name|HOST_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
name|annotate_field_end
argument_list|()
expr_stmt|;
block|}
return|return
name|comma_needed
return|;
block|}
end_function

end_unit

