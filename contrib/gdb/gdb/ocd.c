begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target communications support for Macraigor Systems' On-Chip Debugging    Copyright 1996, 1997 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdb-stabs.h"
end_include

begin_include
include|#
directive|include
file|"dcache.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_include
include|#
directive|include
file|"ocd.h"
end_include

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ocd_read_bytes
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
name|memaddr
operator|,
name|char
operator|*
name|myaddr
operator|,
name|int
name|len
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ocd_start_remote
name|PARAMS
argument_list|(
operator|(
name|PTR
name|dummy
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|readchar
name|PARAMS
argument_list|(
operator|(
name|int
name|timeout
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reset_packet
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|output_packet
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_quoted_char
name|PARAMS
argument_list|(
operator|(
name|int
name|timeout
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|put_quoted_char
name|PARAMS
argument_list|(
operator|(
name|int
name|c
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ocd_interrupt
name|PARAMS
argument_list|(
operator|(
name|int
name|signo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ocd_interrupt_twice
name|PARAMS
argument_list|(
operator|(
name|int
name|signo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|interrupt_query
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|ocd_do_command
name|PARAMS
argument_list|(
operator|(
name|int
name|cmd
operator|,
name|int
operator|*
name|statusp
operator|,
name|int
operator|*
name|lenp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ocd_put_packet
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|char
operator|*
name|packet
operator|,
name|int
name|pktlen
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|ocd_get_packet
name|PARAMS
argument_list|(
operator|(
name|int
name|cmd
operator|,
name|int
operator|*
name|pktlen
operator|,
name|int
name|timeout
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|target_ops
modifier|*
name|current_ops
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|last_run_status
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This was 5 seconds, which is a long time to sit and wait.    Unless this is going though some terminal server or multiplexer or    other form of hairy serial connection, I would think 2 seconds would    be plenty.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* FIXME: Change to allow option to set timeout value on a per target    basis. */
end_comment

begin_endif
unit|static int remote_timeout = 2;
endif|#
directive|endif
end_endif

begin_comment
comment|/* Descriptor for I/O to remote machine.  Initialize it to NULL so that    ocd_open knows that we don't have a file open when the program    starts.  */
end_comment

begin_decl_stmt
specifier|static
name|serial_t
name|ocd_desc
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|void
name|ocd_error
parameter_list|(
name|s
parameter_list|,
name|error_code
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|error_code
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|fputs_filtered
argument_list|(
name|s
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|error_code
condition|)
block|{
case|case
literal|0x1
case|:
name|s
operator|=
literal|"Unknown fault"
expr_stmt|;
break|break;
case|case
literal|0x2
case|:
name|s
operator|=
literal|"Power failed"
expr_stmt|;
break|break;
case|case
literal|0x3
case|:
name|s
operator|=
literal|"Cable disconnected"
expr_stmt|;
break|break;
case|case
literal|0x4
case|:
name|s
operator|=
literal|"Couldn't enter OCD mode"
expr_stmt|;
break|break;
case|case
literal|0x5
case|:
name|s
operator|=
literal|"Target stuck in reset"
expr_stmt|;
break|break;
case|case
literal|0x6
case|:
name|s
operator|=
literal|"OCD hasn't been initialized"
expr_stmt|;
break|break;
case|case
literal|0x7
case|:
name|s
operator|=
literal|"Write verify failed"
expr_stmt|;
break|break;
case|case
literal|0x8
case|:
name|s
operator|=
literal|"Reg buff error (during MPC5xx fp reg read/write)"
expr_stmt|;
break|break;
case|case
literal|0x9
case|:
name|s
operator|=
literal|"Invalid CPU register access attempt failed"
expr_stmt|;
break|break;
case|case
literal|0x11
case|:
name|s
operator|=
literal|"Bus error"
expr_stmt|;
break|break;
case|case
literal|0x12
case|:
name|s
operator|=
literal|"Checksum error"
expr_stmt|;
break|break;
case|case
literal|0x13
case|:
name|s
operator|=
literal|"Illegal command"
expr_stmt|;
break|break;
case|case
literal|0x14
case|:
name|s
operator|=
literal|"Parameter error"
expr_stmt|;
break|break;
case|case
literal|0x15
case|:
name|s
operator|=
literal|"Internal error"
expr_stmt|;
break|break;
case|case
literal|0x80
case|:
name|s
operator|=
literal|"Flash erase error"
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Unknown error code %d"
argument_list|,
name|error_code
argument_list|)
expr_stmt|;
name|s
operator|=
name|buf
expr_stmt|;
block|}
name|error
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  Return nonzero if the thread TH is still alive on the remote system.  */
end_comment

begin_function
name|int
name|ocd_thread_alive
parameter_list|(
name|th
parameter_list|)
name|int
name|th
decl_stmt|;
block|{
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Clean up connection to a remote debugger.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|ocd_close
parameter_list|(
name|quitting
parameter_list|)
name|int
name|quitting
decl_stmt|;
block|{
if|if
condition|(
name|ocd_desc
condition|)
name|SERIAL_CLOSE
argument_list|(
name|ocd_desc
argument_list|)
expr_stmt|;
name|ocd_desc
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stub for catch_errors.  */
end_comment

begin_function
specifier|static
name|int
name|ocd_start_remote
parameter_list|(
name|dummy
parameter_list|)
name|PTR
name|dummy
decl_stmt|;
block|{
name|unsigned
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|pktlen
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|error_code
decl_stmt|;
name|int
name|speed
decl_stmt|;
name|enum
name|ocd_target_type
name|target_type
decl_stmt|;
name|target_type
operator|=
operator|*
operator|(
expr|enum
name|ocd_target_type
operator|*
operator|)
name|dummy
expr_stmt|;
name|immediate_quit
operator|=
literal|1
expr_stmt|;
comment|/* Allow user to interrupt it */
name|SERIAL_SEND_BREAK
argument_list|(
name|ocd_desc
argument_list|)
expr_stmt|;
comment|/* Wake up the wiggler */
name|speed
operator|=
literal|80
expr_stmt|;
comment|/* Divide clock by 4000 */
name|buf
index|[
literal|0
index|]
operator|=
name|OCD_INIT
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|speed
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|speed
operator|&
literal|0xff
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|target_type
expr_stmt|;
name|ocd_put_packet
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Init OCD params */
name|p
operator|=
name|ocd_get_packet
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|,
operator|&
name|pktlen
argument_list|,
name|remote_timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|pktlen
operator|<
literal|2
condition|)
name|error
argument_list|(
literal|"Truncated response packet from OCD device"
argument_list|)
expr_stmt|;
name|status
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|error_code
operator|=
name|p
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|error_code
operator|!=
literal|0
condition|)
name|ocd_error
argument_list|(
literal|"OCD_INIT:"
argument_list|,
name|error_code
argument_list|)
expr_stmt|;
name|ocd_do_command
argument_list|(
name|OCD_AYT
argument_list|,
operator|&
name|status
argument_list|,
operator|&
name|pktlen
argument_list|)
expr_stmt|;
name|p
operator|=
name|ocd_do_command
argument_list|(
name|OCD_GET_VERSION
argument_list|,
operator|&
name|status
argument_list|,
operator|&
name|pktlen
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"[Wiggler version %x.%x, capability 0x%x]\n"
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
operator|(
name|p
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
name|p
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Reset the target */
block|ocd_do_command (OCD_RESET_RUN,&status,&pktlen);
comment|/*  ocd_do_command (OCD_RESET,&status,&pktlen);*/
endif|#
directive|endif
comment|/* If processor is still running, stop it.  */
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|OCD_FLAG_BDM
operator|)
condition|)
name|ocd_stop
argument_list|()
expr_stmt|;
if|#
directive|if
literal|1
comment|/* When using a target box, we want to asynchronously return status when      target stops.  The OCD_SET_CTL_FLAGS command is ignored by Wigglers.dll      when using a parallel Wiggler */
name|buf
index|[
literal|0
index|]
operator|=
name|OCD_SET_CTL_FLAGS
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
literal|1
expr_stmt|;
name|ocd_put_packet
argument_list|(
name|buf
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|p
operator|=
name|ocd_get_packet
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|,
operator|&
name|pktlen
argument_list|,
name|remote_timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|pktlen
operator|<
literal|2
condition|)
name|error
argument_list|(
literal|"Truncated response packet from OCD device"
argument_list|)
expr_stmt|;
name|status
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|error_code
operator|=
name|p
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|error_code
operator|!=
literal|0
condition|)
name|ocd_error
argument_list|(
literal|"OCD_SET_CTL_FLAGS:"
argument_list|,
name|error_code
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|immediate_quit
operator|=
literal|0
expr_stmt|;
comment|/* This is really the job of start_remote however, that makes an assumption    that the target is about to print out a status message of some sort.  That    doesn't happen here (in fact, it may not be possible to get the monitor to    send the appropriate packet).  */
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|registers_changed
argument_list|()
expr_stmt|;
name|stop_pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
name|read_fp
argument_list|()
argument_list|,
name|stop_pc
argument_list|)
argument_list|)
expr_stmt|;
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|print_stack_frame
argument_list|(
name|selected_frame
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|OCD_LOG_FILE
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|3
expr_stmt|;
comment|/* close existing WIGGLERS.LOG */
name|ocd_put_packet
argument_list|(
name|buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|p
operator|=
name|ocd_get_packet
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|,
operator|&
name|pktlen
argument_list|,
name|remote_timeout
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|OCD_LOG_FILE
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|2
expr_stmt|;
comment|/* append to existing WIGGLERS.LOG */
name|ocd_put_packet
argument_list|(
name|buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|p
operator|=
name|ocd_get_packet
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|,
operator|&
name|pktlen
argument_list|,
name|remote_timeout
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Open a connection to a remote debugger.    NAME is the filename used for communication.  */
end_comment

begin_decl_stmt
specifier|static
name|DCACHE
modifier|*
name|ocd_dcache
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|ocd_open
parameter_list|(
name|name
parameter_list|,
name|from_tty
parameter_list|,
name|target_type
parameter_list|,
name|ops
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|enum
name|ocd_target_type
name|target_type
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|ops
decl_stmt|;
block|{
name|unsigned
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|pktlen
decl_stmt|;
if|if
condition|(
name|name
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"To open an OCD connection, you need to specify the\n\ device the OCD device is attached to (e.g. /dev/ttya)."
argument_list|)
expr_stmt|;
name|target_preopen
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
name|current_ops
operator|=
name|ops
expr_stmt|;
name|unpush_target
argument_list|(
name|current_ops
argument_list|)
expr_stmt|;
name|ocd_dcache
operator|=
name|dcache_init
argument_list|(
name|ocd_read_bytes
argument_list|,
name|ocd_write_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"wiggler"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ocd_desc
operator|=
name|SERIAL_OPEN
argument_list|(
literal|"ocd"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ocd_desc
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|OCD_LOG_FILE
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
comment|/* open new or overwrite existing WIGGLERS.LOG */
name|ocd_put_packet
argument_list|(
name|buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|p
operator|=
name|ocd_get_packet
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|,
operator|&
name|pktlen
argument_list|,
name|remote_timeout
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|OCD_SET_CONNECTION
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|0x01
expr_stmt|;
comment|/* atoi (name[11]); */
name|ocd_put_packet
argument_list|(
name|buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|p
operator|=
name|ocd_get_packet
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|,
operator|&
name|pktlen
argument_list|,
name|remote_timeout
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* not using Wigglers.dll */
block|{
name|ocd_desc
operator|=
name|SERIAL_OPEN
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ocd_desc
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|baud_rate
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|SERIAL_SETBAUDRATE
argument_list|(
name|ocd_desc
argument_list|,
name|baud_rate
argument_list|)
condition|)
block|{
name|SERIAL_CLOSE
argument_list|(
name|ocd_desc
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|SERIAL_RAW
argument_list|(
name|ocd_desc
argument_list|)
expr_stmt|;
comment|/* If there is something sitting in the buffer we might take it as a      response to a command, which would be bad.  */
name|SERIAL_FLUSH_INPUT
argument_list|(
name|ocd_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|puts_filtered
argument_list|(
literal|"Remote target wiggler connected to "
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|push_target
argument_list|(
name|current_ops
argument_list|)
expr_stmt|;
comment|/* Switch to using remote target now */
comment|/* Without this, some commands which require an active target (such as kill)      won't work.  This variable serves (at least) double duty as both the pid      of the target process (if it has such), and as a flag indicating that a      target is active.  These functions should be split out into seperate      variables, especially since GDB will someday have a notion of debugging      several processes.  */
name|inferior_pid
operator|=
literal|42000
expr_stmt|;
comment|/* Start the remote connection; if error (0), discard this target.      In particular, if the user quits, be sure to discard it      (we'd be in an inconsistent state otherwise).  */
if|if
condition|(
operator|!
name|catch_errors
argument_list|(
name|ocd_start_remote
argument_list|,
operator|&
name|target_type
argument_list|,
literal|"Couldn't establish connection to remote target\n"
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
condition|)
block|{
name|pop_target
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"Failed to connect to OCD."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This takes a program previously attached to and detaches it.  After    this is done, GDB can be used to debug some other program.  We    better not have left any breakpoints in the target program or it'll    die when it hits one.  */
end_comment

begin_function
name|void
name|ocd_detach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|args
condition|)
name|error
argument_list|(
literal|"Argument given to \"detach\" when remotely debugging."
argument_list|)
expr_stmt|;
name|pop_target
argument_list|()
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|puts_filtered
argument_list|(
literal|"Ending remote debugging.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Tell the remote machine to resume.  */
end_comment

begin_function
name|void
name|ocd_resume
parameter_list|(
name|pid
parameter_list|,
name|step
parameter_list|,
name|siggnal
parameter_list|)
name|int
name|pid
decl_stmt|,
name|step
decl_stmt|;
name|enum
name|target_signal
name|siggnal
decl_stmt|;
block|{
name|int
name|pktlen
decl_stmt|;
name|dcache_flush
argument_list|(
name|ocd_dcache
argument_list|)
expr_stmt|;
if|if
condition|(
name|step
condition|)
name|ocd_do_command
argument_list|(
name|OCD_STEP
argument_list|,
operator|&
name|last_run_status
argument_list|,
operator|&
name|pktlen
argument_list|)
expr_stmt|;
else|else
name|ocd_do_command
argument_list|(
name|OCD_RUN
argument_list|,
operator|&
name|last_run_status
argument_list|,
operator|&
name|pktlen
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|ocd_stop
parameter_list|()
block|{
name|int
name|status
decl_stmt|;
name|int
name|pktlen
decl_stmt|;
name|ocd_do_command
argument_list|(
name|OCD_STOP
argument_list|,
operator|&
name|status
argument_list|,
operator|&
name|pktlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|OCD_FLAG_BDM
operator|)
condition|)
name|error
argument_list|(
literal|"Can't stop target via BDM"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|ocd_interrupt_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Send ^C to target to halt it.  Target will respond, and send us a    packet.  */
end_comment

begin_function
specifier|static
name|void
name|ocd_interrupt
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
comment|/* If this doesn't work, try more severe steps.  */
name|signal
argument_list|(
name|signo
argument_list|,
name|ocd_interrupt_twice
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_debug
condition|)
name|printf_unfiltered
argument_list|(
literal|"ocd_interrupt called\n"
argument_list|)
expr_stmt|;
block|{
name|char
name|buf
index|[
literal|1
index|]
decl_stmt|;
name|ocd_stop
argument_list|()
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|OCD_AYT
expr_stmt|;
name|ocd_put_packet
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ocd_interrupt_flag
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|ofunc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* The user typed ^C twice.  */
end_comment

begin_function
specifier|static
name|void
name|ocd_interrupt_twice
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|signal
argument_list|(
name|signo
argument_list|,
name|ofunc
argument_list|)
expr_stmt|;
name|interrupt_query
argument_list|()
expr_stmt|;
name|signal
argument_list|(
name|signo
argument_list|,
name|ocd_interrupt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Ask the user what to do when an interrupt is received.  */
end_comment

begin_function
specifier|static
name|void
name|interrupt_query
parameter_list|()
block|{
name|target_terminal_ours
argument_list|()
expr_stmt|;
if|if
condition|(
name|query
argument_list|(
literal|"Interrupted while waiting for the program.\n\ Give up (and stop debugging it)? "
argument_list|)
condition|)
block|{
name|target_mourn_inferior
argument_list|()
expr_stmt|;
name|return_to_top_level
argument_list|(
name|RETURN_QUIT
argument_list|)
expr_stmt|;
block|}
name|target_terminal_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If nonzero, ignore the next kill.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|kill_kludge
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Wait until the remote machine stops, then return,    storing status in STATUS just as `wait' would.    Returns "pid" (though it's not clear what, if anything, that    means in the case of this target).  */
end_comment

begin_function
name|int
name|ocd_wait
parameter_list|()
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|error_code
decl_stmt|;
name|int
name|pktlen
decl_stmt|;
name|char
name|buf
index|[
literal|1
index|]
decl_stmt|;
name|ocd_interrupt_flag
operator|=
literal|0
expr_stmt|;
comment|/* Target might already be stopped by the time we get here. */
comment|/* If we aren't already stopped, we need to loop until we've dropped      back into BDM mode */
while|while
condition|(
operator|!
operator|(
name|last_run_status
operator|&
name|OCD_FLAG_BDM
operator|)
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|OCD_AYT
expr_stmt|;
name|ocd_put_packet
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|ocd_get_packet
argument_list|(
name|OCD_AYT
argument_list|,
operator|&
name|pktlen
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ofunc
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|ocd_interrupt
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|ofunc
argument_list|)
expr_stmt|;
if|if
condition|(
name|pktlen
operator|<
literal|2
condition|)
name|error
argument_list|(
literal|"Truncated response packet from OCD device"
argument_list|)
expr_stmt|;
name|last_run_status
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|error_code
operator|=
name|p
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|error_code
operator|!=
literal|0
condition|)
name|ocd_error
argument_list|(
literal|"target_wait:"
argument_list|,
name|error_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_run_status
operator|&
name|OCD_FLAG_PWF
condition|)
name|error
argument_list|(
literal|"OCD device lost VCC at BDM interface."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|last_run_status
operator|&
name|OCD_FLAG_CABLE_DISC
condition|)
name|error
argument_list|(
literal|"OCD device cable appears to have been disconnected."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ocd_interrupt_flag
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Read registers from the OCD device.  Specify the starting and ending    register number.  Return the number of regs actually read in *NUMREGS.    Returns a pointer to a static array containing the register contents.  */
end_comment

begin_function
name|unsigned
name|char
modifier|*
name|ocd_read_bdm_registers
parameter_list|(
name|first_bdm_regno
parameter_list|,
name|last_bdm_regno
parameter_list|,
name|reglen
parameter_list|)
name|int
name|first_bdm_regno
decl_stmt|;
name|int
name|last_bdm_regno
decl_stmt|;
name|int
modifier|*
name|reglen
decl_stmt|;
block|{
name|unsigned
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|char
modifier|*
name|regs
decl_stmt|;
name|int
name|error_code
decl_stmt|,
name|status
decl_stmt|;
name|int
name|pktlen
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|OCD_READ_REGS
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|first_bdm_regno
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|first_bdm_regno
operator|&
literal|0xff
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|last_bdm_regno
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
name|last_bdm_regno
operator|&
literal|0xff
expr_stmt|;
name|ocd_put_packet
argument_list|(
name|buf
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|p
operator|=
name|ocd_get_packet
argument_list|(
name|OCD_READ_REGS
argument_list|,
operator|&
name|pktlen
argument_list|,
name|remote_timeout
argument_list|)
expr_stmt|;
name|status
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|error_code
operator|=
name|p
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|error_code
operator|!=
literal|0
condition|)
name|ocd_error
argument_list|(
literal|"read_bdm_registers:"
argument_list|,
name|error_code
argument_list|)
expr_stmt|;
name|i
operator|=
name|p
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|i
operator|=
literal|256
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|pktlen
operator|-
literal|4
operator|||
operator|(
operator|(
name|i
operator|&
literal|3
operator|)
operator|!=
literal|0
operator|)
condition|)
name|error
argument_list|(
literal|"Register block size bad:  %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
operator|*
name|reglen
operator|=
name|i
expr_stmt|;
name|regs
operator|=
name|p
operator|+
literal|4
expr_stmt|;
return|return
name|regs
return|;
block|}
end_function

begin_comment
comment|/* Read register BDM_REGNO and returns its value ala read_register() */
end_comment

begin_function
name|CORE_ADDR
name|ocd_read_bdm_register
parameter_list|(
name|bdm_regno
parameter_list|)
name|int
name|bdm_regno
decl_stmt|;
block|{
name|int
name|reglen
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|CORE_ADDR
name|regval
decl_stmt|;
name|p
operator|=
name|ocd_read_bdm_registers
argument_list|(
name|bdm_regno
argument_list|,
name|bdm_regno
argument_list|,
operator|&
name|reglen
argument_list|)
expr_stmt|;
name|regval
operator|=
name|extract_unsigned_integer
argument_list|(
name|p
argument_list|,
name|reglen
argument_list|)
expr_stmt|;
return|return
name|regval
return|;
block|}
end_function

begin_function
name|void
name|ocd_write_bdm_registers
parameter_list|(
name|first_bdm_regno
parameter_list|,
name|regptr
parameter_list|,
name|reglen
parameter_list|)
name|int
name|first_bdm_regno
decl_stmt|;
name|unsigned
name|char
modifier|*
name|regptr
decl_stmt|;
name|int
name|reglen
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|error_code
decl_stmt|,
name|status
decl_stmt|;
name|int
name|pktlen
decl_stmt|;
name|buf
operator|=
name|alloca
argument_list|(
literal|4
operator|+
name|reglen
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|OCD_WRITE_REGS
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|first_bdm_regno
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|first_bdm_regno
operator|&
literal|0xff
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|reglen
expr_stmt|;
name|memcpy
argument_list|(
name|buf
operator|+
literal|4
argument_list|,
name|regptr
argument_list|,
name|reglen
argument_list|)
expr_stmt|;
name|ocd_put_packet
argument_list|(
name|buf
argument_list|,
literal|4
operator|+
name|reglen
argument_list|)
expr_stmt|;
name|p
operator|=
name|ocd_get_packet
argument_list|(
name|OCD_WRITE_REGS
argument_list|,
operator|&
name|pktlen
argument_list|,
name|remote_timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|pktlen
operator|<
literal|3
condition|)
name|error
argument_list|(
literal|"Truncated response packet from OCD device"
argument_list|)
expr_stmt|;
name|status
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|error_code
operator|=
name|p
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|error_code
operator|!=
literal|0
condition|)
name|ocd_error
argument_list|(
literal|"ocd_write_bdm_registers:"
argument_list|,
name|error_code
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ocd_write_bdm_register
parameter_list|(
name|bdm_regno
parameter_list|,
name|reg
parameter_list|)
name|int
name|bdm_regno
decl_stmt|;
name|CORE_ADDR
name|reg
decl_stmt|;
block|{
name|unsigned
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|ocd_write_bdm_registers
argument_list|(
name|bdm_regno
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|ocd_prepare_to_store
parameter_list|()
block|{ }
end_function

begin_escape
end_escape

begin_comment
comment|/* Write memory data directly to the remote machine.    This does not inform the data cache; the data cache uses this.    MEMADDR is the address in the remote memory space.    MYADDR is the address of the buffer in our space.    LEN is the number of bytes.     Returns number of bytes transferred, or 0 for error.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|write_mem_command
init|=
name|OCD_WRITE_MEM
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|ocd_write_bytes
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|256
operator|+
literal|10
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|origlen
decl_stmt|;
name|origlen
operator|=
name|len
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|write_mem_command
expr_stmt|;
name|buf
index|[
literal|5
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Write as bytes */
name|buf
index|[
literal|6
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Don't verify */
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|int
name|numbytes
decl_stmt|;
name|int
name|pktlen
decl_stmt|;
name|int
name|status
decl_stmt|,
name|error_code
decl_stmt|;
name|numbytes
operator|=
name|min
argument_list|(
name|len
argument_list|,
literal|256
operator|-
literal|8
argument_list|)
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|memaddr
operator|>>
literal|24
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|memaddr
operator|>>
literal|16
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|memaddr
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
name|memaddr
expr_stmt|;
name|buf
index|[
literal|7
index|]
operator|=
name|numbytes
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|buf
index|[
literal|8
index|]
argument_list|,
name|myaddr
argument_list|,
name|numbytes
argument_list|)
expr_stmt|;
name|ocd_put_packet
argument_list|(
name|buf
argument_list|,
literal|8
operator|+
name|numbytes
argument_list|)
expr_stmt|;
name|p
operator|=
name|ocd_get_packet
argument_list|(
name|OCD_WRITE_MEM
argument_list|,
operator|&
name|pktlen
argument_list|,
name|remote_timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|pktlen
operator|<
literal|3
condition|)
name|error
argument_list|(
literal|"Truncated response packet from OCD device"
argument_list|)
expr_stmt|;
name|status
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|error_code
operator|=
name|p
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|error_code
operator|==
literal|0x11
condition|)
comment|/* Got a bus error? */
block|{
name|CORE_ADDR
name|error_address
decl_stmt|;
name|error_address
operator|=
name|p
index|[
literal|3
index|]
operator|<<
literal|24
expr_stmt|;
name|error_address
operator||=
name|p
index|[
literal|4
index|]
operator|<<
literal|16
expr_stmt|;
name|error_address
operator||=
name|p
index|[
literal|5
index|]
operator|<<
literal|8
expr_stmt|;
name|error_address
operator||=
name|p
index|[
literal|6
index|]
expr_stmt|;
name|numbytes
operator|=
name|error_address
operator|-
name|memaddr
expr_stmt|;
name|len
operator|-=
name|numbytes
expr_stmt|;
name|errno
operator|=
name|EIO
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|error_code
operator|!=
literal|0
condition|)
name|ocd_error
argument_list|(
literal|"ocd_write_bytes:"
argument_list|,
name|error_code
argument_list|)
expr_stmt|;
name|len
operator|-=
name|numbytes
expr_stmt|;
name|memaddr
operator|+=
name|numbytes
expr_stmt|;
name|myaddr
operator|+=
name|numbytes
expr_stmt|;
block|}
return|return
name|origlen
operator|-
name|len
return|;
block|}
end_function

begin_comment
comment|/* Read memory data directly from the remote machine.    This does not use the data cache; the data cache uses this.    MEMADDR is the address in the remote memory space.    MYADDR is the address of the buffer in our space.    LEN is the number of bytes.     Returns number of bytes transferred, or 0 for error.  */
end_comment

begin_function
specifier|static
name|int
name|ocd_read_bytes
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|256
operator|+
literal|10
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|origlen
decl_stmt|;
name|origlen
operator|=
name|len
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|OCD_READ_MEM
expr_stmt|;
name|buf
index|[
literal|5
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Read as bytes */
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|int
name|numbytes
decl_stmt|;
name|int
name|pktlen
decl_stmt|;
name|int
name|status
decl_stmt|,
name|error_code
decl_stmt|;
name|numbytes
operator|=
name|min
argument_list|(
name|len
argument_list|,
literal|256
operator|-
literal|7
argument_list|)
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|memaddr
operator|>>
literal|24
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|memaddr
operator|>>
literal|16
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|memaddr
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
name|memaddr
expr_stmt|;
name|buf
index|[
literal|6
index|]
operator|=
name|numbytes
expr_stmt|;
name|ocd_put_packet
argument_list|(
name|buf
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|p
operator|=
name|ocd_get_packet
argument_list|(
name|OCD_READ_MEM
argument_list|,
operator|&
name|pktlen
argument_list|,
name|remote_timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|pktlen
operator|<
literal|4
condition|)
name|error
argument_list|(
literal|"Truncated response packet from OCD device"
argument_list|)
expr_stmt|;
name|status
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|error_code
operator|=
name|p
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|error_code
operator|==
literal|0x11
condition|)
comment|/* Got a bus error? */
block|{
name|CORE_ADDR
name|error_address
decl_stmt|;
name|error_address
operator|=
name|p
index|[
literal|3
index|]
operator|<<
literal|24
expr_stmt|;
name|error_address
operator||=
name|p
index|[
literal|4
index|]
operator|<<
literal|16
expr_stmt|;
name|error_address
operator||=
name|p
index|[
literal|5
index|]
operator|<<
literal|8
expr_stmt|;
name|error_address
operator||=
name|p
index|[
literal|6
index|]
expr_stmt|;
name|numbytes
operator|=
name|error_address
operator|-
name|memaddr
expr_stmt|;
name|len
operator|-=
name|numbytes
expr_stmt|;
name|errno
operator|=
name|EIO
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|error_code
operator|!=
literal|0
condition|)
name|ocd_error
argument_list|(
literal|"ocd_read_bytes:"
argument_list|,
name|error_code
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|myaddr
argument_list|,
operator|&
name|p
index|[
literal|4
index|]
argument_list|,
name|numbytes
argument_list|)
expr_stmt|;
name|len
operator|-=
name|numbytes
expr_stmt|;
name|memaddr
operator|+=
name|numbytes
expr_stmt|;
name|myaddr
operator|+=
name|numbytes
expr_stmt|;
block|}
return|return
name|origlen
operator|-
name|len
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read or write LEN bytes from inferior memory at MEMADDR, transferring    to or from debugger address MYADDR.  Write to inferior if SHOULD_WRITE is    nonzero.  Returns length of data written or read; 0 for error.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|ocd_xfer_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|should_write
parameter_list|,
name|target
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|should_write
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
comment|/* ignored */
block|{
return|return
name|dcache_xfer_memory
argument_list|(
name|ocd_dcache
argument_list|,
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|,
name|should_write
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|ocd_files_info
parameter_list|(
name|ignore
parameter_list|)
name|struct
name|target_ops
modifier|*
name|ignore
decl_stmt|;
block|{
name|puts_filtered
argument_list|(
literal|"Debugging a target over a serial line.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Stuff for dealing with the packets which are part of this protocol.    See comment at top of file for details.  */
end_comment

begin_comment
comment|/* Read a single character from the remote side, handling wierd errors. */
end_comment

begin_function
specifier|static
name|int
name|readchar
parameter_list|(
name|timeout
parameter_list|)
name|int
name|timeout
decl_stmt|;
block|{
name|int
name|ch
decl_stmt|;
name|ch
operator|=
name|SERIAL_READCHAR
argument_list|(
name|ocd_desc
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|SERIAL_EOF
case|:
name|error
argument_list|(
literal|"Remote connection closed"
argument_list|)
expr_stmt|;
case|case
name|SERIAL_ERROR
case|:
name|perror_with_name
argument_list|(
literal|"Remote communication error"
argument_list|)
expr_stmt|;
case|case
name|SERIAL_TIMEOUT
case|:
default|default:
return|return
name|ch
return|;
block|}
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Read a character from the data stream, dequoting as necessary.  SYN is    treated special.  Any SYNs appearing in the data stream are returned as the    distinct value RAW_SYN (which has a value> 8 bits and therefore cannot be    mistaken for real data).  */
end_comment

begin_comment
unit|static int get_quoted_char (timeout)      int timeout; {   int ch;    ch = readchar (timeout);    switch (ch)     {     case SERIAL_TIMEOUT:       error ("Timeout in mid-packet, aborting");     case SYN:       return RAW_SYN;     case DLE:       ch = readchar (timeout);       if (ch == SYN) 	return RAW_SYN;       return ch& ~0100;     default:       return ch;     } }  static unsigned char pkt[256 * 2 + 10], *pktp;
comment|/* Worst case */
end_comment

begin_comment
unit|static void reset_packet () {   pktp = pkt; }  static void output_packet () {   if (SERIAL_WRITE (ocd_desc, pkt, pktp - pkt))     perror_with_name ("output_packet: write failed");    reset_packet (); }
comment|/* Output a quoted character.  SYNs and DLEs are quoted.  Everything else goes    through untouched.  */
end_comment

begin_comment
unit|static void put_quoted_char (c)      int c; {   switch (c)     {     case SYN:     case DLE:       *pktp++ = DLE;       c |= 0100;     }    *pktp++ = c; }
comment|/* Send a packet to the OCD device.  The packet framed by a SYN character,    a byte count and a checksum.  The byte count only counts the number of    bytes between the count and the checksum.  A count of zero actually    means 256.  Any SYNs within the packet (including the checksum and    count) must be quoted.  The quote character must be quoted as well.    Quoting is done by replacing the character with the two-character sequence    DLE, {char} | 0100.  Note that the quoting mechanism has no effect on the    byte count. */
end_comment

begin_comment
unit|static void stu_put_packet (buf, len)      unsigned char *buf;      int len; {   unsigned char checksum;   unsigned char c;    if (len == 0 || len> 256)     abort ();
comment|/* Can't represent 0 length packet */
end_comment

begin_else
unit|reset_packet ();    checksum = 0;    put_quoted_char (RAW_SYN);    c = len;    do     {       checksum += c;        put_quoted_char (c);        c = *buf++;     }   while (len--> 0);    put_quoted_char (-checksum& 0xff);    output_packet (); }
else|#
directive|else
end_else

begin_comment
comment|/* Send a packet to the OCD device.  The packet framed by a SYN character,    a byte count and a checksum.  The byte count only counts the number of    bytes between the count and the checksum.  A count of zero actually    means 256.  Any SYNs within the packet (including the checksum and    count) must be quoted.  The quote character must be quoted as well.    Quoting is done by replacing the character with the two-character sequence    DLE, {char} | 0100.  Note that the quoting mechanism has no effect on the    byte count.  */
end_comment

begin_function
specifier|static
name|void
name|ocd_put_packet
parameter_list|(
name|buf
parameter_list|,
name|len
parameter_list|)
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|unsigned
name|char
name|checksum
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
name|unsigned
name|char
modifier|*
name|packet
decl_stmt|,
modifier|*
name|packet_ptr
decl_stmt|;
name|packet
operator|=
name|alloca
argument_list|(
name|len
operator|+
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* packet + SYN + checksum */
name|packet_ptr
operator|=
name|packet
expr_stmt|;
name|checksum
operator|=
literal|0
expr_stmt|;
operator|*
name|packet_ptr
operator|++
operator|=
literal|0x55
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|c
operator|=
operator|*
name|buf
operator|++
expr_stmt|;
name|checksum
operator|+=
name|c
expr_stmt|;
operator|*
name|packet_ptr
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|packet_ptr
operator|++
operator|=
operator|-
name|checksum
expr_stmt|;
if|if
condition|(
name|SERIAL_WRITE
argument_list|(
name|ocd_desc
argument_list|,
name|packet
argument_list|,
name|packet_ptr
operator|-
name|packet
argument_list|)
condition|)
name|perror_with_name
argument_list|(
literal|"output_packet: write failed"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Get a packet from the OCD device.  Timeout is only enforced for the    first byte of the packet.  Subsequent bytes are expected to arrive in    time<= remote_timeout.  Returns a pointer to a static buffer containing    the payload of the packet.  *LENP contains the length of the packet. */
end_comment

begin_comment
unit|static unsigned char * stu_get_packet (cmd, lenp, timeout)      unsigned char cmd;      int *lenp; {   int ch;   int len;   static unsigned char buf[256 + 10], *p;   unsigned char checksum;   find_packet:    ch = get_quoted_char (timeout);    if (ch< 0)     error ("get_packet (readchar): %d", ch);    if (ch != RAW_SYN)     goto find_packet;   found_syn:
comment|/* Found the start of a packet */
end_comment

begin_comment
unit|p = buf;   checksum = 0;    len = get_quoted_char (remote_timeout);    if (len == RAW_SYN)     goto found_syn;    checksum += len;    if (len == 0)     len = 256;    len++;
comment|/* Include checksum */
end_comment

begin_else
unit|while (len--> 0)     {       ch = get_quoted_char (remote_timeout);       if (ch == RAW_SYN) 	goto found_syn;        *p++ = ch;       checksum += ch;     }    if (checksum != 0)     goto find_packet;    if (cmd != buf[0])     error ("Response phase error.  Got 0x%x, expected 0x%x", buf[0], cmd);    *lenp = p - buf - 1;   return buf; }
else|#
directive|else
end_else

begin_comment
comment|/* Get a packet from the OCD device.  Timeout is only enforced for the    first byte of the packet.  Subsequent bytes are expected to arrive in    time<= remote_timeout.  Returns a pointer to a static buffer containing    the payload of the packet.  *LENP contains the length of the packet. */
end_comment

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|ocd_get_packet
parameter_list|(
name|cmd
parameter_list|,
name|lenp
parameter_list|,
name|timeout
parameter_list|)
name|int
name|cmd
decl_stmt|;
name|int
modifier|*
name|lenp
decl_stmt|;
block|{
name|int
name|ch
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
name|unsigned
name|char
name|packet
index|[
literal|512
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|packet_ptr
decl_stmt|;
name|unsigned
name|char
name|checksum
decl_stmt|;
name|ch
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"ocd_get_packet (readchar): %d"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
literal|0x55
condition|)
name|error
argument_list|(
literal|"ocd_get_packet (readchar): %d"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
comment|/* Found the start of a packet */
name|packet_ptr
operator|=
name|packet
expr_stmt|;
name|checksum
operator|=
literal|0
expr_stmt|;
comment|/* Read command char.  That sort of tells us how long the packet is. */
name|ch
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"ocd_get_packet (readchar): %d"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
operator|*
name|packet_ptr
operator|++
operator|=
name|ch
expr_stmt|;
name|checksum
operator|+=
name|ch
expr_stmt|;
comment|/* Get status. */
name|ch
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"ocd_get_packet (readchar): %d"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
operator|*
name|packet_ptr
operator|++
operator|=
name|ch
expr_stmt|;
name|checksum
operator|+=
name|ch
expr_stmt|;
comment|/* Get error code. */
name|ch
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"ocd_get_packet (readchar): %d"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
operator|*
name|packet_ptr
operator|++
operator|=
name|ch
expr_stmt|;
name|checksum
operator|+=
name|ch
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
comment|/* Figure out length of packet */
block|{
case|case
literal|0x7
case|:
comment|/* Write verify error? */
name|len
operator|=
literal|8
expr_stmt|;
comment|/* write address, value read back */
break|break;
case|case
literal|0x11
case|:
comment|/* Bus error? */
comment|/* write address, read flag */
case|case
literal|0x15
case|:
comment|/* Internal error */
name|len
operator|=
literal|5
expr_stmt|;
comment|/* error code, vector */
break|break;
default|default:
comment|/* Error w/no params */
name|len
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|0x0
case|:
comment|/* Normal result */
switch|switch
condition|(
name|packet
index|[
literal|0
index|]
condition|)
block|{
case|case
name|OCD_AYT
case|:
comment|/* Are You There? */
case|case
name|OCD_SET_BAUD_RATE
case|:
comment|/* Set Baud Rate */
case|case
name|OCD_INIT
case|:
comment|/* Initialize OCD device */
case|case
name|OCD_SET_SPEED
case|:
comment|/* Set Speed */
case|case
name|OCD_SET_FUNC_CODE
case|:
comment|/* Set Function Code */
case|case
name|OCD_SET_CTL_FLAGS
case|:
comment|/* Set Control Flags */
case|case
name|OCD_SET_BUF_ADDR
case|:
comment|/* Set Register Buffer Address */
case|case
name|OCD_RUN
case|:
comment|/* Run Target from PC  */
case|case
name|OCD_RUN_ADDR
case|:
comment|/* Run Target from Specified Address  */
case|case
name|OCD_STOP
case|:
comment|/* Stop Target */
case|case
name|OCD_RESET_RUN
case|:
comment|/* Reset Target and Run */
case|case
name|OCD_RESET
case|:
comment|/* Reset Target and Halt */
case|case
name|OCD_STEP
case|:
comment|/* Single Step */
case|case
name|OCD_WRITE_REGS
case|:
comment|/* Write Register */
case|case
name|OCD_WRITE_MEM
case|:
comment|/* Write Memory */
case|case
name|OCD_FILL_MEM
case|:
comment|/* Fill Memory */
case|case
name|OCD_MOVE_MEM
case|:
comment|/* Move Memory */
case|case
name|OCD_WRITE_INT_MEM
case|:
comment|/* Write Internal Memory */
case|case
name|OCD_JUMP
case|:
comment|/* Jump to Subroutine */
case|case
name|OCD_ERASE_FLASH
case|:
comment|/* Erase flash memory */
case|case
name|OCD_PROGRAM_FLASH
case|:
comment|/* Write flash memory */
case|case
name|OCD_EXIT_MON
case|:
comment|/* Exit the flash programming monitor  */
case|case
name|OCD_ENTER_MON
case|:
comment|/* Enter the flash programming monitor  */
case|case
name|OCD_LOG_FILE
case|:
comment|/* Make Wigglers.dll save Wigglers.log */
case|case
name|OCD_SET_CONNECTION
case|:
comment|/* Set type of connection in Wigglers.dll */
name|len
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OCD_GET_VERSION
case|:
comment|/* Get Version */
name|len
operator|=
literal|10
expr_stmt|;
break|break;
case|case
name|OCD_GET_STATUS_MASK
case|:
comment|/* Get Status Mask */
name|len
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OCD_GET_CTRS
case|:
comment|/* Get Error Counters */
case|case
name|OCD_READ_REGS
case|:
comment|/* Read Register */
case|case
name|OCD_READ_MEM
case|:
comment|/* Read Memory */
case|case
name|OCD_READ_INT_MEM
case|:
comment|/* Read Internal Memory */
name|len
operator|=
literal|257
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"ocd_get_packet: unknown packet type 0x%x\n"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|len
operator|==
literal|257
condition|)
comment|/* Byte stream? */
block|{
comment|/* Yes, byte streams contain the length */
name|ch
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"ocd_get_packet (readchar): %d"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
operator|*
name|packet_ptr
operator|++
operator|=
name|ch
expr_stmt|;
name|checksum
operator|+=
name|ch
expr_stmt|;
name|len
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|len
operator|=
literal|256
expr_stmt|;
block|}
while|while
condition|(
name|len
operator|--
operator|>=
literal|0
condition|)
comment|/* Do rest of packet and checksum */
block|{
name|ch
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"ocd_get_packet (readchar): %d"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
operator|*
name|packet_ptr
operator|++
operator|=
name|ch
expr_stmt|;
name|checksum
operator|+=
name|ch
expr_stmt|;
block|}
if|if
condition|(
name|checksum
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"ocd_get_packet: bad packet checksum"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|!=
operator|-
literal|1
operator|&&
name|cmd
operator|!=
name|packet
index|[
literal|0
index|]
condition|)
name|error
argument_list|(
literal|"Response phase error.  Got 0x%x, expected 0x%x"
argument_list|,
name|packet
index|[
literal|0
index|]
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
operator|*
name|lenp
operator|=
name|packet_ptr
operator|-
name|packet
operator|-
literal|1
expr_stmt|;
comment|/* Subtract checksum byte */
return|return
name|packet
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Execute a simple (one-byte) command.  Returns a pointer to the data    following the error code.  */
end_comment

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|ocd_do_command
parameter_list|(
name|cmd
parameter_list|,
name|statusp
parameter_list|,
name|lenp
parameter_list|)
name|int
name|cmd
decl_stmt|;
name|int
modifier|*
name|statusp
decl_stmt|;
name|int
modifier|*
name|lenp
decl_stmt|;
block|{
name|unsigned
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|status
decl_stmt|,
name|error_code
decl_stmt|;
name|char
name|errbuf
index|[
literal|100
index|]
decl_stmt|;
name|unsigned
name|char
name|logbuf
index|[
literal|100
index|]
decl_stmt|;
name|int
name|logpktlen
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|cmd
expr_stmt|;
name|ocd_put_packet
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Send command */
name|p
operator|=
name|ocd_get_packet
argument_list|(
operator|*
name|buf
argument_list|,
name|lenp
argument_list|,
name|remote_timeout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|lenp
operator|<
literal|3
condition|)
name|error
argument_list|(
literal|"Truncated response packet from OCD device"
argument_list|)
expr_stmt|;
name|status
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|error_code
operator|=
name|p
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|error_code
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|errbuf
argument_list|,
literal|"ocd_do_command (0x%x):"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|ocd_error
argument_list|(
name|errbuf
argument_list|,
name|error_code
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|OCD_FLAG_PWF
condition|)
name|error
argument_list|(
literal|"OCD device can't detect VCC at BDM interface."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|&
name|OCD_FLAG_CABLE_DISC
condition|)
name|error
argument_list|(
literal|"BDM cable appears to be disconnected."
argument_list|)
expr_stmt|;
operator|*
name|statusp
operator|=
name|status
expr_stmt|;
name|logbuf
index|[
literal|0
index|]
operator|=
name|OCD_LOG_FILE
expr_stmt|;
name|logbuf
index|[
literal|1
index|]
operator|=
literal|3
expr_stmt|;
comment|/* close existing WIGGLERS.LOG */
name|ocd_put_packet
argument_list|(
name|logbuf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ocd_get_packet
argument_list|(
name|logbuf
index|[
literal|0
index|]
argument_list|,
operator|&
name|logpktlen
argument_list|,
name|remote_timeout
argument_list|)
expr_stmt|;
name|logbuf
index|[
literal|0
index|]
operator|=
name|OCD_LOG_FILE
expr_stmt|;
name|logbuf
index|[
literal|1
index|]
operator|=
literal|2
expr_stmt|;
comment|/* append to existing WIGGLERS.LOG */
name|ocd_put_packet
argument_list|(
name|logbuf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ocd_get_packet
argument_list|(
name|logbuf
index|[
literal|0
index|]
argument_list|,
operator|&
name|logpktlen
argument_list|,
name|remote_timeout
argument_list|)
expr_stmt|;
return|return
name|p
operator|+
literal|3
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|ocd_kill
parameter_list|()
block|{
comment|/* For some mysterious reason, wait_for_inferior calls kill instead of      mourn after it gets TARGET_WAITKIND_SIGNALLED.  Work around it.  */
if|if
condition|(
name|kill_kludge
condition|)
block|{
name|kill_kludge
operator|=
literal|0
expr_stmt|;
name|target_mourn_inferior
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Don't wait for it to die.  I'm not really sure it matters whether      we do or not.  */
name|target_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ocd_mourn
parameter_list|()
block|{
name|unpush_target
argument_list|(
name|current_ops
argument_list|)
expr_stmt|;
name|generic_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* All we actually do is set the PC to the start address of exec_bfd, and start    the program at that point.  */
end_comment

begin_function
name|void
name|ocd_create_inferior
parameter_list|(
name|exec_file
parameter_list|,
name|args
parameter_list|,
name|env
parameter_list|)
name|char
modifier|*
name|exec_file
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
name|char
modifier|*
modifier|*
name|env
decl_stmt|;
block|{
if|if
condition|(
name|args
operator|&&
operator|(
operator|*
name|args
operator|!=
literal|'\000'
operator|)
condition|)
name|error
argument_list|(
literal|"Args are not supported by BDM."
argument_list|)
expr_stmt|;
name|clear_proceed_status
argument_list|()
expr_stmt|;
name|proceed
argument_list|(
name|bfd_get_start_address
argument_list|(
name|exec_bfd
argument_list|)
argument_list|,
name|TARGET_SIGNAL_0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ocd_load
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|generic_load
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
literal|0
expr_stmt|;
comment|/* This is necessary because many things were based on the PC at the time that    we attached to the monitor, which is no longer valid now that we have loaded    new code (and just changed the PC).  Another way to do this might be to call    normal_stop, except that the stack may not be valid, and things would get    horribly confused... */
name|clear_symtab_users
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This should be defined for each target */
end_comment

begin_comment
comment|/* But we want to be able to compile this file for some configurations    not yet supported fully */
end_comment

begin_define
define|#
directive|define
name|BDM_BREAKPOINT
value|{0x0,0x0,0x0,0x0}
end_define

begin_comment
comment|/* For ppc 8xx */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|BDM_BREAKPOINT
value|{0x4a,0xfa}
end_define

begin_comment
comment|/* BGND insn used for CPU32 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BDM (at least on CPU32) uses a different breakpoint */
end_comment

begin_function
name|int
name|ocd_insert_breakpoint
parameter_list|(
name|addr
parameter_list|,
name|contents_cache
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|contents_cache
decl_stmt|;
block|{
specifier|static
name|char
name|break_insn
index|[]
init|=
name|BDM_BREAKPOINT
decl_stmt|;
name|int
name|val
decl_stmt|;
name|val
operator|=
name|target_read_memory
argument_list|(
name|addr
argument_list|,
name|contents_cache
argument_list|,
sizeof|sizeof
argument_list|(
name|break_insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|val
operator|=
name|target_write_memory
argument_list|(
name|addr
argument_list|,
name|break_insn
argument_list|,
sizeof|sizeof
argument_list|(
name|break_insn
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|int
name|ocd_remove_breakpoint
parameter_list|(
name|addr
parameter_list|,
name|contents_cache
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|contents_cache
decl_stmt|;
block|{
specifier|static
name|char
name|break_insn
index|[]
init|=
name|BDM_BREAKPOINT
decl_stmt|;
name|int
name|val
decl_stmt|;
name|val
operator|=
name|target_write_memory
argument_list|(
name|addr
argument_list|,
name|contents_cache
argument_list|,
sizeof|sizeof
argument_list|(
name|break_insn
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bdm_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|error
argument_list|(
literal|"bdm command must be followed by `reset'"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bdm_reset_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|status
decl_stmt|,
name|pktlen
decl_stmt|;
if|if
condition|(
operator|!
name|ocd_desc
condition|)
name|error
argument_list|(
literal|"Not connected to OCD device."
argument_list|)
expr_stmt|;
name|ocd_do_command
argument_list|(
name|OCD_RESET
argument_list|,
operator|&
name|status
argument_list|,
operator|&
name|pktlen
argument_list|)
expr_stmt|;
name|dcache_flush
argument_list|(
name|ocd_dcache
argument_list|)
expr_stmt|;
name|registers_changed
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bdm_restart_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|status
decl_stmt|,
name|pktlen
decl_stmt|;
if|if
condition|(
operator|!
name|ocd_desc
condition|)
name|error
argument_list|(
literal|"Not connected to OCD device."
argument_list|)
expr_stmt|;
name|ocd_do_command
argument_list|(
name|OCD_RESET_RUN
argument_list|,
operator|&
name|status
argument_list|,
operator|&
name|pktlen
argument_list|)
expr_stmt|;
name|last_run_status
operator|=
name|status
expr_stmt|;
name|clear_proceed_status
argument_list|()
expr_stmt|;
name|wait_for_inferior
argument_list|()
expr_stmt|;
name|normal_stop
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Temporary replacement for target_store_registers().  This prevents    generic_load from trying to set the PC.  */
end_comment

begin_function
specifier|static
name|void
name|noop_store_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{ }
end_function

begin_function
specifier|static
name|void
name|bdm_update_flash_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|status
decl_stmt|,
name|pktlen
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|void
argument_list|(
argument|*store_registers_tmp
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ocd_desc
condition|)
name|error
argument_list|(
literal|"Not connected to OCD device."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
name|error
argument_list|(
literal|"Must specify file containing new OCD code."
argument_list|)
expr_stmt|;
comment|/*  old_chain = make_cleanup (flash_cleanup, 0);*/
name|ocd_do_command
argument_list|(
name|OCD_ENTER_MON
argument_list|,
operator|&
name|status
argument_list|,
operator|&
name|pktlen
argument_list|)
expr_stmt|;
name|ocd_do_command
argument_list|(
name|OCD_ERASE_FLASH
argument_list|,
operator|&
name|status
argument_list|,
operator|&
name|pktlen
argument_list|)
expr_stmt|;
name|write_mem_command
operator|=
name|OCD_PROGRAM_FLASH
expr_stmt|;
name|store_registers_tmp
operator|=
name|current_target
operator|.
name|to_store_registers
expr_stmt|;
name|current_target
operator|.
name|to_store_registers
operator|=
name|noop_store_registers
expr_stmt|;
name|generic_load
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|current_target
operator|.
name|to_store_registers
operator|=
name|store_registers_tmp
expr_stmt|;
name|write_mem_command
operator|=
name|OCD_WRITE_MEM
expr_stmt|;
name|ocd_do_command
argument_list|(
name|OCD_EXIT_MON
argument_list|,
operator|&
name|status
argument_list|,
operator|&
name|pktlen
argument_list|)
expr_stmt|;
comment|/*  discard_cleanups (old_chain);*/
block|}
end_function

begin_function
specifier|static
name|void
name|bdm_read_register_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
comment|/* XXX repeat should go on to the next register */
if|if
condition|(
operator|!
name|ocd_desc
condition|)
name|error
argument_list|(
literal|"Not connected to OCD device."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
name|error
argument_list|(
literal|"Must specify BDM register number."
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|_initialize_remote_ocd
parameter_list|()
block|{
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|cmdlist
decl_stmt|;
specifier|static
name|struct
name|cmd_list_element
modifier|*
name|ocd_cmd_list
init|=
name|NULL
decl_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"remotetimeout"
argument_list|,
name|no_class
argument_list|,
name|var_integer
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|remote_timeout
argument_list|,
literal|"Set timeout value for remote read.\n"
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"ocd"
argument_list|,
name|class_obscure
argument_list|,
name|bdm_command
argument_list|,
literal|""
argument_list|,
operator|&
name|ocd_cmd_list
argument_list|,
literal|"ocd "
argument_list|,
literal|0
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"reset"
argument_list|,
name|class_obscure
argument_list|,
name|bdm_reset_command
argument_list|,
literal|""
argument_list|,
operator|&
name|ocd_cmd_list
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"restart"
argument_list|,
name|class_obscure
argument_list|,
name|bdm_restart_command
argument_list|,
literal|""
argument_list|,
operator|&
name|ocd_cmd_list
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"update-flash"
argument_list|,
name|class_obscure
argument_list|,
name|bdm_update_flash_command
argument_list|,
literal|""
argument_list|,
operator|&
name|ocd_cmd_list
argument_list|)
expr_stmt|;
comment|/*  add_cmd ("read-register", class_obscure, bdm_read_register_command, "",&ocd_cmd_list);*/
block|}
end_function

end_unit

