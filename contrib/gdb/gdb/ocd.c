begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target communications support for Macraigor Systems' On-Chip Debugging     Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2004 Free    Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdb-stabs.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_include
include|#
directive|include
file|"ocd.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_function_decl
specifier|static
name|int
name|ocd_read_bytes
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ocd_start_remote
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|readchar
parameter_list|(
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ocd_interrupt
parameter_list|(
name|int
name|signo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ocd_interrupt_twice
parameter_list|(
name|int
name|signo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|interrupt_query
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|char
modifier|*
name|ocd_do_command
parameter_list|(
name|int
name|cmd
parameter_list|,
name|int
modifier|*
name|statusp
parameter_list|,
name|int
modifier|*
name|lenp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ocd_put_packet
parameter_list|(
name|unsigned
name|char
modifier|*
name|packet
parameter_list|,
name|int
name|pktlen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|char
modifier|*
name|ocd_get_packet
parameter_list|(
name|int
name|cmd
parameter_list|,
name|int
modifier|*
name|pktlen
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|target_ops
modifier|*
name|current_ops
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|last_run_status
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Descriptor for I/O to remote machine.  Initialize it to NULL so that    ocd_open knows that we don't have a file open when the program    starts.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|serial
modifier|*
name|ocd_desc
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|void
name|ocd_error
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|int
name|error_code
parameter_list|)
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|fputs_filtered
argument_list|(
name|s
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|error_code
condition|)
block|{
case|case
literal|0x1
case|:
name|s
operator|=
literal|"Unknown fault"
expr_stmt|;
break|break;
case|case
literal|0x2
case|:
name|s
operator|=
literal|"Power failed"
expr_stmt|;
break|break;
case|case
literal|0x3
case|:
name|s
operator|=
literal|"Cable disconnected"
expr_stmt|;
break|break;
case|case
literal|0x4
case|:
name|s
operator|=
literal|"Couldn't enter OCD mode"
expr_stmt|;
break|break;
case|case
literal|0x5
case|:
name|s
operator|=
literal|"Target stuck in reset"
expr_stmt|;
break|break;
case|case
literal|0x6
case|:
name|s
operator|=
literal|"OCD hasn't been initialized"
expr_stmt|;
break|break;
case|case
literal|0x7
case|:
name|s
operator|=
literal|"Write verify failed"
expr_stmt|;
break|break;
case|case
literal|0x8
case|:
name|s
operator|=
literal|"Reg buff error (during MPC5xx fp reg read/write)"
expr_stmt|;
break|break;
case|case
literal|0x9
case|:
name|s
operator|=
literal|"Invalid CPU register access attempt failed"
expr_stmt|;
break|break;
case|case
literal|0x11
case|:
name|s
operator|=
literal|"Bus error"
expr_stmt|;
break|break;
case|case
literal|0x12
case|:
name|s
operator|=
literal|"Checksum error"
expr_stmt|;
break|break;
case|case
literal|0x13
case|:
name|s
operator|=
literal|"Illegal command"
expr_stmt|;
break|break;
case|case
literal|0x14
case|:
name|s
operator|=
literal|"Parameter error"
expr_stmt|;
break|break;
case|case
literal|0x15
case|:
name|s
operator|=
literal|"Internal error"
expr_stmt|;
break|break;
case|case
literal|0x80
case|:
name|s
operator|=
literal|"Flash erase error"
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Unknown error code %d"
argument_list|,
name|error_code
argument_list|)
expr_stmt|;
name|s
operator|=
name|buf
expr_stmt|;
block|}
name|error
argument_list|(
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  Return nonzero if the thread TH is still alive on the remote system.  */
end_comment

begin_function
name|int
name|ocd_thread_alive
parameter_list|(
name|ptid_t
name|th
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Clean up connection to a remote debugger.  */
end_comment

begin_function
name|void
name|ocd_close
parameter_list|(
name|int
name|quitting
parameter_list|)
block|{
if|if
condition|(
name|ocd_desc
condition|)
name|serial_close
argument_list|(
name|ocd_desc
argument_list|)
expr_stmt|;
name|ocd_desc
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stub for catch_errors.  */
end_comment

begin_function
specifier|static
name|int
name|ocd_start_remote
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|unsigned
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|pktlen
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|error_code
decl_stmt|;
name|int
name|speed
decl_stmt|;
name|enum
name|ocd_target_type
name|target_type
decl_stmt|;
name|target_type
operator|=
operator|*
operator|(
expr|enum
name|ocd_target_type
operator|*
operator|)
name|dummy
expr_stmt|;
name|immediate_quit
operator|++
expr_stmt|;
comment|/* Allow user to interrupt it */
name|serial_send_break
argument_list|(
name|ocd_desc
argument_list|)
expr_stmt|;
comment|/* Wake up the wiggler */
name|speed
operator|=
literal|80
expr_stmt|;
comment|/* Divide clock by 4000 */
name|buf
index|[
literal|0
index|]
operator|=
name|OCD_INIT
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|speed
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|speed
operator|&
literal|0xff
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|target_type
expr_stmt|;
name|ocd_put_packet
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Init OCD params */
name|p
operator|=
name|ocd_get_packet
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|,
operator|&
name|pktlen
argument_list|,
name|remote_timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|pktlen
operator|<
literal|2
condition|)
name|error
argument_list|(
literal|"Truncated response packet from OCD device"
argument_list|)
expr_stmt|;
name|status
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|error_code
operator|=
name|p
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|error_code
operator|!=
literal|0
condition|)
name|ocd_error
argument_list|(
literal|"OCD_INIT:"
argument_list|,
name|error_code
argument_list|)
expr_stmt|;
name|ocd_do_command
argument_list|(
name|OCD_AYT
argument_list|,
operator|&
name|status
argument_list|,
operator|&
name|pktlen
argument_list|)
expr_stmt|;
name|p
operator|=
name|ocd_do_command
argument_list|(
name|OCD_GET_VERSION
argument_list|,
operator|&
name|status
argument_list|,
operator|&
name|pktlen
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"[Wiggler version %x.%x, capability 0x%x]\n"
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
operator|(
name|p
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
name|p
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* If processor is still running, stop it.  */
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|OCD_FLAG_BDM
operator|)
condition|)
name|ocd_stop
argument_list|()
expr_stmt|;
comment|/* When using a target box, we want to asynchronously return status when      target stops.  The OCD_SET_CTL_FLAGS command is ignored by Wigglers.dll      when using a parallel Wiggler */
name|buf
index|[
literal|0
index|]
operator|=
name|OCD_SET_CTL_FLAGS
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
literal|1
expr_stmt|;
name|ocd_put_packet
argument_list|(
name|buf
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|p
operator|=
name|ocd_get_packet
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|,
operator|&
name|pktlen
argument_list|,
name|remote_timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|pktlen
operator|<
literal|2
condition|)
name|error
argument_list|(
literal|"Truncated response packet from OCD device"
argument_list|)
expr_stmt|;
name|status
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|error_code
operator|=
name|p
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|error_code
operator|!=
literal|0
condition|)
name|ocd_error
argument_list|(
literal|"OCD_SET_CTL_FLAGS:"
argument_list|,
name|error_code
argument_list|)
expr_stmt|;
name|immediate_quit
operator|--
expr_stmt|;
comment|/* This is really the job of start_remote however, that makes an assumption    that the target is about to print out a status message of some sort.  That    doesn't happen here (in fact, it may not be possible to get the monitor to    send the appropriate packet).  */
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|registers_changed
argument_list|()
expr_stmt|;
name|stop_pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
name|print_stack_frame
argument_list|(
name|get_selected_frame
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|OCD_LOG_FILE
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|3
expr_stmt|;
comment|/* close existing WIGGLERS.LOG */
name|ocd_put_packet
argument_list|(
name|buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|p
operator|=
name|ocd_get_packet
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|,
operator|&
name|pktlen
argument_list|,
name|remote_timeout
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|OCD_LOG_FILE
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|2
expr_stmt|;
comment|/* append to existing WIGGLERS.LOG */
name|ocd_put_packet
argument_list|(
name|buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|p
operator|=
name|ocd_get_packet
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|,
operator|&
name|pktlen
argument_list|,
name|remote_timeout
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Open a connection to a remote debugger.    NAME is the filename used for communication.  */
end_comment

begin_function
name|void
name|ocd_open
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|enum
name|ocd_target_type
name|target_type
parameter_list|,
name|struct
name|target_ops
modifier|*
name|ops
parameter_list|)
block|{
name|unsigned
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|pktlen
decl_stmt|;
if|if
condition|(
name|name
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"To open an OCD connection, you need to specify the\n\ device the OCD device is attached to (e.g. /dev/ttya)."
argument_list|)
expr_stmt|;
name|target_preopen
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
name|current_ops
operator|=
name|ops
expr_stmt|;
name|unpush_target
argument_list|(
name|current_ops
argument_list|)
expr_stmt|;
name|ocd_desc
operator|=
name|serial_open
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ocd_desc
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|baud_rate
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|serial_setbaudrate
argument_list|(
name|ocd_desc
argument_list|,
name|baud_rate
argument_list|)
condition|)
block|{
name|serial_close
argument_list|(
name|ocd_desc
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|serial_raw
argument_list|(
name|ocd_desc
argument_list|)
expr_stmt|;
comment|/* If there is something sitting in the buffer we might take it as a      response to a command, which would be bad.  */
name|serial_flush_input
argument_list|(
name|ocd_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|puts_filtered
argument_list|(
literal|"Remote target wiggler connected to "
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|push_target
argument_list|(
name|current_ops
argument_list|)
expr_stmt|;
comment|/* Switch to using remote target now */
comment|/* Without this, some commands which require an active target (such as kill)      won't work.  This variable serves (at least) double duty as both the pid      of the target process (if it has such), and as a flag indicating that a      target is active.  These functions should be split out into seperate      variables, especially since GDB will someday have a notion of debugging      several processes.  */
name|inferior_ptid
operator|=
name|pid_to_ptid
argument_list|(
literal|42000
argument_list|)
expr_stmt|;
comment|/* Start the remote connection; if error (0), discard this target.      In particular, if the user quits, be sure to discard it      (we'd be in an inconsistent state otherwise).  */
if|if
condition|(
operator|!
name|catch_errors
argument_list|(
name|ocd_start_remote
argument_list|,
operator|&
name|target_type
argument_list|,
literal|"Couldn't establish connection to remote target\n"
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
condition|)
block|{
name|pop_target
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"Failed to connect to OCD."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This takes a program previously attached to and detaches it.  After    this is done, GDB can be used to debug some other program.  We    better not have left any breakpoints in the target program or it'll    die when it hits one.  */
end_comment

begin_function
name|void
name|ocd_detach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|args
condition|)
name|error
argument_list|(
literal|"Argument given to \"detach\" when remotely debugging."
argument_list|)
expr_stmt|;
name|pop_target
argument_list|()
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|puts_filtered
argument_list|(
literal|"Ending remote debugging.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Tell the remote machine to resume.  */
end_comment

begin_function
name|void
name|ocd_resume
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|step
parameter_list|,
name|enum
name|target_signal
name|siggnal
parameter_list|)
block|{
name|int
name|pktlen
decl_stmt|;
if|if
condition|(
name|step
condition|)
name|ocd_do_command
argument_list|(
name|OCD_STEP
argument_list|,
operator|&
name|last_run_status
argument_list|,
operator|&
name|pktlen
argument_list|)
expr_stmt|;
else|else
name|ocd_do_command
argument_list|(
name|OCD_RUN
argument_list|,
operator|&
name|last_run_status
argument_list|,
operator|&
name|pktlen
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|ocd_stop
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|int
name|pktlen
decl_stmt|;
name|ocd_do_command
argument_list|(
name|OCD_STOP
argument_list|,
operator|&
name|status
argument_list|,
operator|&
name|pktlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|status
operator|&
name|OCD_FLAG_BDM
operator|)
condition|)
name|error
argument_list|(
literal|"Can't stop target via BDM"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|volatile
name|int
name|ocd_interrupt_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Send ^C to target to halt it.  Target will respond, and send us a    packet.  */
end_comment

begin_function
specifier|static
name|void
name|ocd_interrupt
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
comment|/* If this doesn't work, try more severe steps.  */
name|signal
argument_list|(
name|signo
argument_list|,
name|ocd_interrupt_twice
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_debug
condition|)
name|printf_unfiltered
argument_list|(
literal|"ocd_interrupt called\n"
argument_list|)
expr_stmt|;
block|{
name|char
name|buf
index|[
literal|1
index|]
decl_stmt|;
name|ocd_stop
argument_list|()
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|OCD_AYT
expr_stmt|;
name|ocd_put_packet
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ocd_interrupt_flag
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|ofunc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* The user typed ^C twice.  */
end_comment

begin_function
specifier|static
name|void
name|ocd_interrupt_twice
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
name|signal
argument_list|(
name|signo
argument_list|,
name|ofunc
argument_list|)
expr_stmt|;
name|interrupt_query
argument_list|()
expr_stmt|;
name|signal
argument_list|(
name|signo
argument_list|,
name|ocd_interrupt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Ask the user what to do when an interrupt is received.  */
end_comment

begin_function
specifier|static
name|void
name|interrupt_query
parameter_list|(
name|void
parameter_list|)
block|{
name|target_terminal_ours
argument_list|()
expr_stmt|;
if|if
condition|(
name|query
argument_list|(
literal|"Interrupted while waiting for the program.\n\ Give up (and stop debugging it)? "
argument_list|)
condition|)
block|{
name|target_mourn_inferior
argument_list|()
expr_stmt|;
name|throw_exception
argument_list|(
name|RETURN_QUIT
argument_list|)
expr_stmt|;
block|}
name|target_terminal_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If nonzero, ignore the next kill.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|kill_kludge
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Wait until the remote machine stops, then return,    storing status in STATUS just as `wait' would.    Returns "pid" (though it's not clear what, if anything, that    means in the case of this target).  */
end_comment

begin_function
name|int
name|ocd_wait
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|error_code
decl_stmt|;
name|int
name|pktlen
decl_stmt|;
name|char
name|buf
index|[
literal|1
index|]
decl_stmt|;
name|ocd_interrupt_flag
operator|=
literal|0
expr_stmt|;
comment|/* Target might already be stopped by the time we get here. */
comment|/* If we aren't already stopped, we need to loop until we've dropped      back into BDM mode */
while|while
condition|(
operator|!
operator|(
name|last_run_status
operator|&
name|OCD_FLAG_BDM
operator|)
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|OCD_AYT
expr_stmt|;
name|ocd_put_packet
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|ocd_get_packet
argument_list|(
name|OCD_AYT
argument_list|,
operator|&
name|pktlen
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ofunc
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|ocd_interrupt
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|ofunc
argument_list|)
expr_stmt|;
if|if
condition|(
name|pktlen
operator|<
literal|2
condition|)
name|error
argument_list|(
literal|"Truncated response packet from OCD device"
argument_list|)
expr_stmt|;
name|last_run_status
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|error_code
operator|=
name|p
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|error_code
operator|!=
literal|0
condition|)
name|ocd_error
argument_list|(
literal|"target_wait:"
argument_list|,
name|error_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_run_status
operator|&
name|OCD_FLAG_PWF
condition|)
name|error
argument_list|(
literal|"OCD device lost VCC at BDM interface."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|last_run_status
operator|&
name|OCD_FLAG_CABLE_DISC
condition|)
name|error
argument_list|(
literal|"OCD device cable appears to have been disconnected."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ocd_interrupt_flag
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Read registers from the OCD device.  Specify the starting and ending    register number.  Return the number of regs actually read in *NUMREGS.    Returns a pointer to a static array containing the register contents.  */
end_comment

begin_function
name|unsigned
name|char
modifier|*
name|ocd_read_bdm_registers
parameter_list|(
name|int
name|first_bdm_regno
parameter_list|,
name|int
name|last_bdm_regno
parameter_list|,
name|int
modifier|*
name|reglen
parameter_list|)
block|{
name|unsigned
name|char
name|buf
index|[
literal|10
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|char
modifier|*
name|regs
decl_stmt|;
name|int
name|error_code
decl_stmt|,
name|status
decl_stmt|;
name|int
name|pktlen
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|OCD_READ_REGS
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|first_bdm_regno
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|first_bdm_regno
operator|&
literal|0xff
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|last_bdm_regno
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
name|last_bdm_regno
operator|&
literal|0xff
expr_stmt|;
name|ocd_put_packet
argument_list|(
name|buf
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|p
operator|=
name|ocd_get_packet
argument_list|(
name|OCD_READ_REGS
argument_list|,
operator|&
name|pktlen
argument_list|,
name|remote_timeout
argument_list|)
expr_stmt|;
name|status
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|error_code
operator|=
name|p
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|error_code
operator|!=
literal|0
condition|)
name|ocd_error
argument_list|(
literal|"read_bdm_registers:"
argument_list|,
name|error_code
argument_list|)
expr_stmt|;
name|i
operator|=
name|p
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|i
operator|=
literal|256
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|pktlen
operator|-
literal|4
operator|||
operator|(
operator|(
name|i
operator|&
literal|3
operator|)
operator|!=
literal|0
operator|)
condition|)
name|error
argument_list|(
literal|"Register block size bad:  %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
operator|*
name|reglen
operator|=
name|i
expr_stmt|;
name|regs
operator|=
name|p
operator|+
literal|4
expr_stmt|;
return|return
name|regs
return|;
block|}
end_function

begin_comment
comment|/* Read register BDM_REGNO and returns its value ala read_register() */
end_comment

begin_function
name|CORE_ADDR
name|ocd_read_bdm_register
parameter_list|(
name|int
name|bdm_regno
parameter_list|)
block|{
name|int
name|reglen
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|CORE_ADDR
name|regval
decl_stmt|;
name|p
operator|=
name|ocd_read_bdm_registers
argument_list|(
name|bdm_regno
argument_list|,
name|bdm_regno
argument_list|,
operator|&
name|reglen
argument_list|)
expr_stmt|;
name|regval
operator|=
name|extract_unsigned_integer
argument_list|(
name|p
argument_list|,
name|reglen
argument_list|)
expr_stmt|;
return|return
name|regval
return|;
block|}
end_function

begin_function
name|void
name|ocd_write_bdm_registers
parameter_list|(
name|int
name|first_bdm_regno
parameter_list|,
name|unsigned
name|char
modifier|*
name|regptr
parameter_list|,
name|int
name|reglen
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|error_code
decl_stmt|,
name|status
decl_stmt|;
name|int
name|pktlen
decl_stmt|;
name|buf
operator|=
name|alloca
argument_list|(
literal|4
operator|+
name|reglen
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|OCD_WRITE_REGS
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|first_bdm_regno
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|first_bdm_regno
operator|&
literal|0xff
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|reglen
expr_stmt|;
name|memcpy
argument_list|(
name|buf
operator|+
literal|4
argument_list|,
name|regptr
argument_list|,
name|reglen
argument_list|)
expr_stmt|;
name|ocd_put_packet
argument_list|(
name|buf
argument_list|,
literal|4
operator|+
name|reglen
argument_list|)
expr_stmt|;
name|p
operator|=
name|ocd_get_packet
argument_list|(
name|OCD_WRITE_REGS
argument_list|,
operator|&
name|pktlen
argument_list|,
name|remote_timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|pktlen
operator|<
literal|3
condition|)
name|error
argument_list|(
literal|"Truncated response packet from OCD device"
argument_list|)
expr_stmt|;
name|status
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|error_code
operator|=
name|p
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|error_code
operator|!=
literal|0
condition|)
name|ocd_error
argument_list|(
literal|"ocd_write_bdm_registers:"
argument_list|,
name|error_code
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ocd_write_bdm_register
parameter_list|(
name|int
name|bdm_regno
parameter_list|,
name|CORE_ADDR
name|reg
parameter_list|)
block|{
name|unsigned
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|ocd_write_bdm_registers
argument_list|(
name|bdm_regno
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|ocd_prepare_to_store
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_escape
end_escape

begin_comment
comment|/* Write memory data directly to the remote machine.    This does not inform the data cache; the data cache uses this.    MEMADDR is the address in the remote memory space.    MYADDR is the address of the buffer in our space.    LEN is the number of bytes.     Returns number of bytes transferred, or 0 for error.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|write_mem_command
init|=
name|OCD_WRITE_MEM
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|ocd_write_bytes
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|char
name|buf
index|[
literal|256
operator|+
literal|10
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|origlen
decl_stmt|;
name|origlen
operator|=
name|len
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|write_mem_command
expr_stmt|;
name|buf
index|[
literal|5
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Write as bytes */
name|buf
index|[
literal|6
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Don't verify */
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|int
name|numbytes
decl_stmt|;
name|int
name|pktlen
decl_stmt|;
name|int
name|status
decl_stmt|,
name|error_code
decl_stmt|;
name|numbytes
operator|=
name|min
argument_list|(
name|len
argument_list|,
literal|256
operator|-
literal|8
argument_list|)
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|memaddr
operator|>>
literal|24
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|memaddr
operator|>>
literal|16
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|memaddr
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
name|memaddr
expr_stmt|;
name|buf
index|[
literal|7
index|]
operator|=
name|numbytes
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|buf
index|[
literal|8
index|]
argument_list|,
name|myaddr
argument_list|,
name|numbytes
argument_list|)
expr_stmt|;
name|ocd_put_packet
argument_list|(
name|buf
argument_list|,
literal|8
operator|+
name|numbytes
argument_list|)
expr_stmt|;
name|p
operator|=
name|ocd_get_packet
argument_list|(
name|OCD_WRITE_MEM
argument_list|,
operator|&
name|pktlen
argument_list|,
name|remote_timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|pktlen
operator|<
literal|3
condition|)
name|error
argument_list|(
literal|"Truncated response packet from OCD device"
argument_list|)
expr_stmt|;
name|status
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|error_code
operator|=
name|p
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|error_code
operator|==
literal|0x11
condition|)
comment|/* Got a bus error? */
block|{
name|CORE_ADDR
name|error_address
decl_stmt|;
name|error_address
operator|=
name|p
index|[
literal|3
index|]
operator|<<
literal|24
expr_stmt|;
name|error_address
operator||=
name|p
index|[
literal|4
index|]
operator|<<
literal|16
expr_stmt|;
name|error_address
operator||=
name|p
index|[
literal|5
index|]
operator|<<
literal|8
expr_stmt|;
name|error_address
operator||=
name|p
index|[
literal|6
index|]
expr_stmt|;
name|numbytes
operator|=
name|error_address
operator|-
name|memaddr
expr_stmt|;
name|len
operator|-=
name|numbytes
expr_stmt|;
name|errno
operator|=
name|EIO
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|error_code
operator|!=
literal|0
condition|)
name|ocd_error
argument_list|(
literal|"ocd_write_bytes:"
argument_list|,
name|error_code
argument_list|)
expr_stmt|;
name|len
operator|-=
name|numbytes
expr_stmt|;
name|memaddr
operator|+=
name|numbytes
expr_stmt|;
name|myaddr
operator|+=
name|numbytes
expr_stmt|;
block|}
return|return
name|origlen
operator|-
name|len
return|;
block|}
end_function

begin_comment
comment|/* Read memory data directly from the remote machine.    This does not use the data cache; the data cache uses this.    MEMADDR is the address in the remote memory space.    MYADDR is the address of the buffer in our space.    LEN is the number of bytes.     Returns number of bytes transferred, or 0 for error.  */
end_comment

begin_function
specifier|static
name|int
name|ocd_read_bytes
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|char
name|buf
index|[
literal|256
operator|+
literal|10
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|origlen
decl_stmt|;
name|origlen
operator|=
name|len
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|OCD_READ_MEM
expr_stmt|;
name|buf
index|[
literal|5
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Read as bytes */
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|int
name|numbytes
decl_stmt|;
name|int
name|pktlen
decl_stmt|;
name|int
name|status
decl_stmt|,
name|error_code
decl_stmt|;
name|numbytes
operator|=
name|min
argument_list|(
name|len
argument_list|,
literal|256
operator|-
literal|7
argument_list|)
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|memaddr
operator|>>
literal|24
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|memaddr
operator|>>
literal|16
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
name|memaddr
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
name|memaddr
expr_stmt|;
name|buf
index|[
literal|6
index|]
operator|=
name|numbytes
expr_stmt|;
name|ocd_put_packet
argument_list|(
name|buf
argument_list|,
literal|7
argument_list|)
expr_stmt|;
name|p
operator|=
name|ocd_get_packet
argument_list|(
name|OCD_READ_MEM
argument_list|,
operator|&
name|pktlen
argument_list|,
name|remote_timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|pktlen
operator|<
literal|4
condition|)
name|error
argument_list|(
literal|"Truncated response packet from OCD device"
argument_list|)
expr_stmt|;
name|status
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|error_code
operator|=
name|p
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|error_code
operator|==
literal|0x11
condition|)
comment|/* Got a bus error? */
block|{
name|CORE_ADDR
name|error_address
decl_stmt|;
name|error_address
operator|=
name|p
index|[
literal|3
index|]
operator|<<
literal|24
expr_stmt|;
name|error_address
operator||=
name|p
index|[
literal|4
index|]
operator|<<
literal|16
expr_stmt|;
name|error_address
operator||=
name|p
index|[
literal|5
index|]
operator|<<
literal|8
expr_stmt|;
name|error_address
operator||=
name|p
index|[
literal|6
index|]
expr_stmt|;
name|numbytes
operator|=
name|error_address
operator|-
name|memaddr
expr_stmt|;
name|len
operator|-=
name|numbytes
expr_stmt|;
name|errno
operator|=
name|EIO
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|error_code
operator|!=
literal|0
condition|)
name|ocd_error
argument_list|(
literal|"ocd_read_bytes:"
argument_list|,
name|error_code
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|myaddr
argument_list|,
operator|&
name|p
index|[
literal|4
index|]
argument_list|,
name|numbytes
argument_list|)
expr_stmt|;
name|len
operator|-=
name|numbytes
expr_stmt|;
name|memaddr
operator|+=
name|numbytes
expr_stmt|;
name|myaddr
operator|+=
name|numbytes
expr_stmt|;
block|}
return|return
name|origlen
operator|-
name|len
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read or write LEN bytes from inferior memory at MEMADDR, transferring    to or from debugger address MYADDR.  Write to inferior if SHOULD_WRITE is    nonzero.  Returns length of data written or read; 0 for error.  TARGET    is ignored.  */
end_comment

begin_function
name|int
name|ocd_xfer_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|should_write
parameter_list|,
name|struct
name|mem_attrib
modifier|*
name|attrib
parameter_list|,
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
if|if
condition|(
name|should_write
condition|)
name|res
operator|=
name|ocd_write_bytes
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|ocd_read_bytes
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|ocd_files_info
parameter_list|(
name|struct
name|target_ops
modifier|*
name|ignore
parameter_list|)
block|{
name|puts_filtered
argument_list|(
literal|"Debugging a target over a serial line.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Stuff for dealing with the packets which are part of this protocol.    See comment at top of file for details.  */
end_comment

begin_comment
comment|/* Read a single character from the remote side, handling wierd errors. */
end_comment

begin_function
specifier|static
name|int
name|readchar
parameter_list|(
name|int
name|timeout
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
name|ch
operator|=
name|serial_readchar
argument_list|(
name|ocd_desc
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|SERIAL_EOF
case|:
name|error
argument_list|(
literal|"Remote connection closed"
argument_list|)
expr_stmt|;
case|case
name|SERIAL_ERROR
case|:
name|perror_with_name
argument_list|(
literal|"Remote communication error"
argument_list|)
expr_stmt|;
case|case
name|SERIAL_TIMEOUT
case|:
default|default:
return|return
name|ch
return|;
block|}
block|}
end_function

begin_comment
comment|/* Send a packet to the OCD device.  The packet framed by a SYN character,    a byte count and a checksum.  The byte count only counts the number of    bytes between the count and the checksum.  A count of zero actually    means 256.  Any SYNs within the packet (including the checksum and    count) must be quoted.  The quote character must be quoted as well.    Quoting is done by replacing the character with the two-character sequence    DLE, {char} | 0100.  Note that the quoting mechanism has no effect on the    byte count.  */
end_comment

begin_function
specifier|static
name|void
name|ocd_put_packet
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|unsigned
name|char
name|checksum
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
name|unsigned
name|char
modifier|*
name|packet
decl_stmt|,
modifier|*
name|packet_ptr
decl_stmt|;
name|packet
operator|=
name|alloca
argument_list|(
name|len
operator|+
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* packet + SYN + checksum */
name|packet_ptr
operator|=
name|packet
expr_stmt|;
name|checksum
operator|=
literal|0
expr_stmt|;
operator|*
name|packet_ptr
operator|++
operator|=
literal|0x55
expr_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
name|c
operator|=
operator|*
name|buf
operator|++
expr_stmt|;
name|checksum
operator|+=
name|c
expr_stmt|;
operator|*
name|packet_ptr
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|packet_ptr
operator|++
operator|=
operator|-
name|checksum
expr_stmt|;
if|if
condition|(
name|serial_write
argument_list|(
name|ocd_desc
argument_list|,
name|packet
argument_list|,
name|packet_ptr
operator|-
name|packet
argument_list|)
condition|)
name|perror_with_name
argument_list|(
literal|"output_packet: write failed"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get a packet from the OCD device.  Timeout is only enforced for the    first byte of the packet.  Subsequent bytes are expected to arrive in    time<= remote_timeout.  Returns a pointer to a static buffer containing    the payload of the packet.  *LENP contains the length of the packet.  */
end_comment

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|ocd_get_packet
parameter_list|(
name|int
name|cmd
parameter_list|,
name|int
modifier|*
name|lenp
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
name|int
name|len
decl_stmt|;
specifier|static
name|unsigned
name|char
name|packet
index|[
literal|512
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|packet_ptr
decl_stmt|;
name|unsigned
name|char
name|checksum
decl_stmt|;
name|ch
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"ocd_get_packet (readchar): %d"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
literal|0x55
condition|)
name|error
argument_list|(
literal|"ocd_get_packet (readchar): %d"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
comment|/* Found the start of a packet */
name|packet_ptr
operator|=
name|packet
expr_stmt|;
name|checksum
operator|=
literal|0
expr_stmt|;
comment|/* Read command char.  That sort of tells us how long the packet is. */
name|ch
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"ocd_get_packet (readchar): %d"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
operator|*
name|packet_ptr
operator|++
operator|=
name|ch
expr_stmt|;
name|checksum
operator|+=
name|ch
expr_stmt|;
comment|/* Get status. */
name|ch
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"ocd_get_packet (readchar): %d"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
operator|*
name|packet_ptr
operator|++
operator|=
name|ch
expr_stmt|;
name|checksum
operator|+=
name|ch
expr_stmt|;
comment|/* Get error code. */
name|ch
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"ocd_get_packet (readchar): %d"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
operator|*
name|packet_ptr
operator|++
operator|=
name|ch
expr_stmt|;
name|checksum
operator|+=
name|ch
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
comment|/* Figure out length of packet */
block|{
case|case
literal|0x7
case|:
comment|/* Write verify error? */
name|len
operator|=
literal|8
expr_stmt|;
comment|/* write address, value read back */
break|break;
case|case
literal|0x11
case|:
comment|/* Bus error? */
comment|/* write address, read flag */
case|case
literal|0x15
case|:
comment|/* Internal error */
name|len
operator|=
literal|5
expr_stmt|;
comment|/* error code, vector */
break|break;
default|default:
comment|/* Error w/no params */
name|len
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|0x0
case|:
comment|/* Normal result */
switch|switch
condition|(
name|packet
index|[
literal|0
index|]
condition|)
block|{
case|case
name|OCD_AYT
case|:
comment|/* Are You There? */
case|case
name|OCD_SET_BAUD_RATE
case|:
comment|/* Set Baud Rate */
case|case
name|OCD_INIT
case|:
comment|/* Initialize OCD device */
case|case
name|OCD_SET_SPEED
case|:
comment|/* Set Speed */
case|case
name|OCD_SET_FUNC_CODE
case|:
comment|/* Set Function Code */
case|case
name|OCD_SET_CTL_FLAGS
case|:
comment|/* Set Control Flags */
case|case
name|OCD_SET_BUF_ADDR
case|:
comment|/* Set Register Buffer Address */
case|case
name|OCD_RUN
case|:
comment|/* Run Target from PC  */
case|case
name|OCD_RUN_ADDR
case|:
comment|/* Run Target from Specified Address  */
case|case
name|OCD_STOP
case|:
comment|/* Stop Target */
case|case
name|OCD_RESET_RUN
case|:
comment|/* Reset Target and Run */
case|case
name|OCD_RESET
case|:
comment|/* Reset Target and Halt */
case|case
name|OCD_STEP
case|:
comment|/* Single Step */
case|case
name|OCD_WRITE_REGS
case|:
comment|/* Write Register */
case|case
name|OCD_WRITE_MEM
case|:
comment|/* Write Memory */
case|case
name|OCD_FILL_MEM
case|:
comment|/* Fill Memory */
case|case
name|OCD_MOVE_MEM
case|:
comment|/* Move Memory */
case|case
name|OCD_WRITE_INT_MEM
case|:
comment|/* Write Internal Memory */
case|case
name|OCD_JUMP
case|:
comment|/* Jump to Subroutine */
case|case
name|OCD_ERASE_FLASH
case|:
comment|/* Erase flash memory */
case|case
name|OCD_PROGRAM_FLASH
case|:
comment|/* Write flash memory */
case|case
name|OCD_EXIT_MON
case|:
comment|/* Exit the flash programming monitor  */
case|case
name|OCD_ENTER_MON
case|:
comment|/* Enter the flash programming monitor  */
case|case
name|OCD_LOG_FILE
case|:
comment|/* Make Wigglers.dll save Wigglers.log */
case|case
name|OCD_SET_CONNECTION
case|:
comment|/* Set type of connection in Wigglers.dll */
name|len
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OCD_GET_VERSION
case|:
comment|/* Get Version */
name|len
operator|=
literal|10
expr_stmt|;
break|break;
case|case
name|OCD_GET_STATUS_MASK
case|:
comment|/* Get Status Mask */
name|len
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OCD_GET_CTRS
case|:
comment|/* Get Error Counters */
case|case
name|OCD_READ_REGS
case|:
comment|/* Read Register */
case|case
name|OCD_READ_MEM
case|:
comment|/* Read Memory */
case|case
name|OCD_READ_INT_MEM
case|:
comment|/* Read Internal Memory */
name|len
operator|=
literal|257
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"ocd_get_packet: unknown packet type 0x%x\n"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|len
operator|==
literal|257
condition|)
comment|/* Byte stream? */
block|{
comment|/* Yes, byte streams contain the length */
name|ch
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"ocd_get_packet (readchar): %d"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
operator|*
name|packet_ptr
operator|++
operator|=
name|ch
expr_stmt|;
name|checksum
operator|+=
name|ch
expr_stmt|;
name|len
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|len
operator|=
literal|256
expr_stmt|;
block|}
while|while
condition|(
name|len
operator|--
operator|>=
literal|0
condition|)
comment|/* Do rest of packet and checksum */
block|{
name|ch
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"ocd_get_packet (readchar): %d"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
operator|*
name|packet_ptr
operator|++
operator|=
name|ch
expr_stmt|;
name|checksum
operator|+=
name|ch
expr_stmt|;
block|}
if|if
condition|(
name|checksum
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"ocd_get_packet: bad packet checksum"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|!=
operator|-
literal|1
operator|&&
name|cmd
operator|!=
name|packet
index|[
literal|0
index|]
condition|)
name|error
argument_list|(
literal|"Response phase error.  Got 0x%x, expected 0x%x"
argument_list|,
name|packet
index|[
literal|0
index|]
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
operator|*
name|lenp
operator|=
name|packet_ptr
operator|-
name|packet
operator|-
literal|1
expr_stmt|;
comment|/* Subtract checksum byte */
return|return
name|packet
return|;
block|}
end_function

begin_comment
comment|/* Execute a simple (one-byte) command.  Returns a pointer to the data    following the error code.  */
end_comment

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|ocd_do_command
parameter_list|(
name|int
name|cmd
parameter_list|,
name|int
modifier|*
name|statusp
parameter_list|,
name|int
modifier|*
name|lenp
parameter_list|)
block|{
name|unsigned
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|status
decl_stmt|,
name|error_code
decl_stmt|;
name|char
name|errbuf
index|[
literal|100
index|]
decl_stmt|;
name|unsigned
name|char
name|logbuf
index|[
literal|100
index|]
decl_stmt|;
name|int
name|logpktlen
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|cmd
expr_stmt|;
name|ocd_put_packet
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Send command */
name|p
operator|=
name|ocd_get_packet
argument_list|(
operator|*
name|buf
argument_list|,
name|lenp
argument_list|,
name|remote_timeout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|lenp
operator|<
literal|3
condition|)
name|error
argument_list|(
literal|"Truncated response packet from OCD device"
argument_list|)
expr_stmt|;
name|status
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|error_code
operator|=
name|p
index|[
literal|2
index|]
expr_stmt|;
if|if
condition|(
name|error_code
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|errbuf
argument_list|,
literal|"ocd_do_command (0x%x):"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|ocd_error
argument_list|(
name|errbuf
argument_list|,
name|error_code
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&
name|OCD_FLAG_PWF
condition|)
name|error
argument_list|(
literal|"OCD device can't detect VCC at BDM interface."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
operator|&
name|OCD_FLAG_CABLE_DISC
condition|)
name|error
argument_list|(
literal|"BDM cable appears to be disconnected."
argument_list|)
expr_stmt|;
operator|*
name|statusp
operator|=
name|status
expr_stmt|;
name|logbuf
index|[
literal|0
index|]
operator|=
name|OCD_LOG_FILE
expr_stmt|;
name|logbuf
index|[
literal|1
index|]
operator|=
literal|3
expr_stmt|;
comment|/* close existing WIGGLERS.LOG */
name|ocd_put_packet
argument_list|(
name|logbuf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ocd_get_packet
argument_list|(
name|logbuf
index|[
literal|0
index|]
argument_list|,
operator|&
name|logpktlen
argument_list|,
name|remote_timeout
argument_list|)
expr_stmt|;
name|logbuf
index|[
literal|0
index|]
operator|=
name|OCD_LOG_FILE
expr_stmt|;
name|logbuf
index|[
literal|1
index|]
operator|=
literal|2
expr_stmt|;
comment|/* append to existing WIGGLERS.LOG */
name|ocd_put_packet
argument_list|(
name|logbuf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ocd_get_packet
argument_list|(
name|logbuf
index|[
literal|0
index|]
argument_list|,
operator|&
name|logpktlen
argument_list|,
name|remote_timeout
argument_list|)
expr_stmt|;
return|return
name|p
operator|+
literal|3
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|ocd_kill
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* For some mysterious reason, wait_for_inferior calls kill instead of      mourn after it gets TARGET_WAITKIND_SIGNALLED.  Work around it.  */
if|if
condition|(
name|kill_kludge
condition|)
block|{
name|kill_kludge
operator|=
literal|0
expr_stmt|;
name|target_mourn_inferior
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Don't wait for it to die.  I'm not really sure it matters whether      we do or not.  */
name|target_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ocd_mourn
parameter_list|(
name|void
parameter_list|)
block|{
name|unpush_target
argument_list|(
name|current_ops
argument_list|)
expr_stmt|;
name|generic_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* All we actually do is set the PC to the start address of exec_bfd, and start    the program at that point.  */
end_comment

begin_function
name|void
name|ocd_create_inferior
parameter_list|(
name|char
modifier|*
name|exec_file
parameter_list|,
name|char
modifier|*
name|args
parameter_list|,
name|char
modifier|*
modifier|*
name|env
parameter_list|)
block|{
if|if
condition|(
name|args
operator|&&
operator|(
operator|*
name|args
operator|!=
literal|'\000'
operator|)
condition|)
name|error
argument_list|(
literal|"Args are not supported by BDM."
argument_list|)
expr_stmt|;
name|clear_proceed_status
argument_list|()
expr_stmt|;
name|proceed
argument_list|(
name|bfd_get_start_address
argument_list|(
name|exec_bfd
argument_list|)
argument_list|,
name|TARGET_SIGNAL_0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ocd_load
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|generic_load
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|inferior_ptid
operator|=
name|null_ptid
expr_stmt|;
comment|/* This is necessary because many things were based on the PC at the time that    we attached to the monitor, which is no longer valid now that we have loaded    new code (and just changed the PC).  Another way to do this might be to call    normal_stop, except that the stack may not be valid, and things would get    horribly confused... */
name|clear_symtab_users
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This should be defined for each target */
end_comment

begin_comment
comment|/* But we want to be able to compile this file for some configurations    not yet supported fully */
end_comment

begin_define
define|#
directive|define
name|BDM_BREAKPOINT
value|{0x0,0x0,0x0,0x0}
end_define

begin_comment
comment|/* For ppc 8xx */
end_comment

begin_comment
comment|/* BDM (at least on CPU32) uses a different breakpoint */
end_comment

begin_function
name|int
name|ocd_insert_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|contents_cache
parameter_list|)
block|{
specifier|static
name|char
name|break_insn
index|[]
init|=
name|BDM_BREAKPOINT
decl_stmt|;
name|int
name|val
decl_stmt|;
name|val
operator|=
name|target_read_memory
argument_list|(
name|addr
argument_list|,
name|contents_cache
argument_list|,
sizeof|sizeof
argument_list|(
name|break_insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|val
operator|=
name|target_write_memory
argument_list|(
name|addr
argument_list|,
name|break_insn
argument_list|,
sizeof|sizeof
argument_list|(
name|break_insn
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|int
name|ocd_remove_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|contents_cache
parameter_list|)
block|{
specifier|static
name|char
name|break_insn
index|[]
init|=
name|BDM_BREAKPOINT
decl_stmt|;
name|int
name|val
decl_stmt|;
name|val
operator|=
name|target_write_memory
argument_list|(
name|addr
argument_list|,
name|contents_cache
argument_list|,
sizeof|sizeof
argument_list|(
name|break_insn
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bdm_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|error
argument_list|(
literal|"bdm command must be followed by `reset'"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bdm_reset_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|int
name|status
decl_stmt|,
name|pktlen
decl_stmt|;
if|if
condition|(
operator|!
name|ocd_desc
condition|)
name|error
argument_list|(
literal|"Not connected to OCD device."
argument_list|)
expr_stmt|;
name|ocd_do_command
argument_list|(
name|OCD_RESET
argument_list|,
operator|&
name|status
argument_list|,
operator|&
name|pktlen
argument_list|)
expr_stmt|;
name|dcache_invalidate
argument_list|(
name|target_dcache
argument_list|)
expr_stmt|;
name|registers_changed
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bdm_restart_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|int
name|status
decl_stmt|,
name|pktlen
decl_stmt|;
if|if
condition|(
operator|!
name|ocd_desc
condition|)
name|error
argument_list|(
literal|"Not connected to OCD device."
argument_list|)
expr_stmt|;
name|ocd_do_command
argument_list|(
name|OCD_RESET_RUN
argument_list|,
operator|&
name|status
argument_list|,
operator|&
name|pktlen
argument_list|)
expr_stmt|;
name|last_run_status
operator|=
name|status
expr_stmt|;
name|clear_proceed_status
argument_list|()
expr_stmt|;
name|wait_for_inferior
argument_list|()
expr_stmt|;
name|normal_stop
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Temporary replacement for target_store_registers().  This prevents    generic_load from trying to set the PC.  */
end_comment

begin_function
specifier|static
name|void
name|noop_store_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|bdm_update_flash_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|int
name|status
decl_stmt|,
name|pktlen
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|void
function_decl|(
modifier|*
name|store_registers_tmp
function_decl|)
parameter_list|(
name|int
parameter_list|)
function_decl|;
if|if
condition|(
operator|!
name|ocd_desc
condition|)
name|error
argument_list|(
literal|"Not connected to OCD device."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
name|error
argument_list|(
literal|"Must specify file containing new OCD code."
argument_list|)
expr_stmt|;
comment|/*  old_chain = make_cleanup (flash_cleanup, 0); */
name|ocd_do_command
argument_list|(
name|OCD_ENTER_MON
argument_list|,
operator|&
name|status
argument_list|,
operator|&
name|pktlen
argument_list|)
expr_stmt|;
name|ocd_do_command
argument_list|(
name|OCD_ERASE_FLASH
argument_list|,
operator|&
name|status
argument_list|,
operator|&
name|pktlen
argument_list|)
expr_stmt|;
name|write_mem_command
operator|=
name|OCD_PROGRAM_FLASH
expr_stmt|;
name|store_registers_tmp
operator|=
name|current_target
operator|.
name|to_store_registers
expr_stmt|;
name|current_target
operator|.
name|to_store_registers
operator|=
name|noop_store_registers
expr_stmt|;
name|generic_load
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|current_target
operator|.
name|to_store_registers
operator|=
name|store_registers_tmp
expr_stmt|;
name|write_mem_command
operator|=
name|OCD_WRITE_MEM
expr_stmt|;
name|ocd_do_command
argument_list|(
name|OCD_EXIT_MON
argument_list|,
operator|&
name|status
argument_list|,
operator|&
name|pktlen
argument_list|)
expr_stmt|;
comment|/*  discard_cleanups (old_chain); */
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|extern
name|initialize_file_ftype
name|_initialize_remote_ocd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -Wmissing-prototypes */
end_comment

begin_function
name|void
name|_initialize_remote_ocd
parameter_list|(
name|void
parameter_list|)
block|{
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|cmdlist
decl_stmt|;
specifier|static
name|struct
name|cmd_list_element
modifier|*
name|ocd_cmd_list
init|=
name|NULL
decl_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"remotetimeout"
argument_list|,
name|no_class
argument_list|,
name|var_integer
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|remote_timeout
argument_list|,
literal|"Set timeout value for remote read.\n"
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"ocd"
argument_list|,
name|class_obscure
argument_list|,
name|bdm_command
argument_list|,
literal|""
argument_list|,
operator|&
name|ocd_cmd_list
argument_list|,
literal|"ocd "
argument_list|,
literal|0
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"reset"
argument_list|,
name|class_obscure
argument_list|,
name|bdm_reset_command
argument_list|,
literal|""
argument_list|,
operator|&
name|ocd_cmd_list
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"restart"
argument_list|,
name|class_obscure
argument_list|,
name|bdm_restart_command
argument_list|,
literal|""
argument_list|,
operator|&
name|ocd_cmd_list
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"update-flash"
argument_list|,
name|class_obscure
argument_list|,
name|bdm_update_flash_command
argument_list|,
literal|""
argument_list|,
operator|&
name|ocd_cmd_list
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

