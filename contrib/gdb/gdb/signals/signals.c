begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target signal translation functions for GDB.    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,    2000, 2001, 2002 Free Software Foundation, Inc.    Contributed by Cygnus Support.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GDBSERVER
end_ifdef

begin_include
include|#
directive|include
file|"server.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_comment
comment|/* This table must match in order and size the signals in enum target_signal    in target.h.  */
end_comment

begin_comment
comment|/* *INDENT-OFF* */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
block|}
name|signals
index|[]
init|=
block|{
block|{
literal|"0"
block|,
literal|"Signal 0"
block|}
block|,
block|{
literal|"SIGHUP"
block|,
literal|"Hangup"
block|}
block|,
block|{
literal|"SIGINT"
block|,
literal|"Interrupt"
block|}
block|,
block|{
literal|"SIGQUIT"
block|,
literal|"Quit"
block|}
block|,
block|{
literal|"SIGILL"
block|,
literal|"Illegal instruction"
block|}
block|,
block|{
literal|"SIGTRAP"
block|,
literal|"Trace/breakpoint trap"
block|}
block|,
block|{
literal|"SIGABRT"
block|,
literal|"Aborted"
block|}
block|,
block|{
literal|"SIGEMT"
block|,
literal|"Emulation trap"
block|}
block|,
block|{
literal|"SIGFPE"
block|,
literal|"Arithmetic exception"
block|}
block|,
block|{
literal|"SIGKILL"
block|,
literal|"Killed"
block|}
block|,
block|{
literal|"SIGBUS"
block|,
literal|"Bus error"
block|}
block|,
block|{
literal|"SIGSEGV"
block|,
literal|"Segmentation fault"
block|}
block|,
block|{
literal|"SIGSYS"
block|,
literal|"Bad system call"
block|}
block|,
block|{
literal|"SIGPIPE"
block|,
literal|"Broken pipe"
block|}
block|,
block|{
literal|"SIGALRM"
block|,
literal|"Alarm clock"
block|}
block|,
block|{
literal|"SIGTERM"
block|,
literal|"Terminated"
block|}
block|,
block|{
literal|"SIGURG"
block|,
literal|"Urgent I/O condition"
block|}
block|,
block|{
literal|"SIGSTOP"
block|,
literal|"Stopped (signal)"
block|}
block|,
block|{
literal|"SIGTSTP"
block|,
literal|"Stopped (user)"
block|}
block|,
block|{
literal|"SIGCONT"
block|,
literal|"Continued"
block|}
block|,
block|{
literal|"SIGCHLD"
block|,
literal|"Child status changed"
block|}
block|,
block|{
literal|"SIGTTIN"
block|,
literal|"Stopped (tty input)"
block|}
block|,
block|{
literal|"SIGTTOU"
block|,
literal|"Stopped (tty output)"
block|}
block|,
block|{
literal|"SIGIO"
block|,
literal|"I/O possible"
block|}
block|,
block|{
literal|"SIGXCPU"
block|,
literal|"CPU time limit exceeded"
block|}
block|,
block|{
literal|"SIGXFSZ"
block|,
literal|"File size limit exceeded"
block|}
block|,
block|{
literal|"SIGVTALRM"
block|,
literal|"Virtual timer expired"
block|}
block|,
block|{
literal|"SIGPROF"
block|,
literal|"Profiling timer expired"
block|}
block|,
block|{
literal|"SIGWINCH"
block|,
literal|"Window size changed"
block|}
block|,
block|{
literal|"SIGLOST"
block|,
literal|"Resource lost"
block|}
block|,
block|{
literal|"SIGUSR1"
block|,
literal|"User defined signal 1"
block|}
block|,
block|{
literal|"SIGUSR2"
block|,
literal|"User defined signal 2"
block|}
block|,
block|{
literal|"SIGPWR"
block|,
literal|"Power fail/restart"
block|}
block|,
block|{
literal|"SIGPOLL"
block|,
literal|"Pollable event occurred"
block|}
block|,
block|{
literal|"SIGWIND"
block|,
literal|"SIGWIND"
block|}
block|,
block|{
literal|"SIGPHONE"
block|,
literal|"SIGPHONE"
block|}
block|,
block|{
literal|"SIGWAITING"
block|,
literal|"Process's LWPs are blocked"
block|}
block|,
block|{
literal|"SIGLWP"
block|,
literal|"Signal LWP"
block|}
block|,
block|{
literal|"SIGDANGER"
block|,
literal|"Swap space dangerously low"
block|}
block|,
block|{
literal|"SIGGRANT"
block|,
literal|"Monitor mode granted"
block|}
block|,
block|{
literal|"SIGRETRACT"
block|,
literal|"Need to relinquish monitor mode"
block|}
block|,
block|{
literal|"SIGMSG"
block|,
literal|"Monitor mode data available"
block|}
block|,
block|{
literal|"SIGSOUND"
block|,
literal|"Sound completed"
block|}
block|,
block|{
literal|"SIGSAK"
block|,
literal|"Secure attention"
block|}
block|,
block|{
literal|"SIGPRIO"
block|,
literal|"SIGPRIO"
block|}
block|,
block|{
literal|"SIG33"
block|,
literal|"Real-time event 33"
block|}
block|,
block|{
literal|"SIG34"
block|,
literal|"Real-time event 34"
block|}
block|,
block|{
literal|"SIG35"
block|,
literal|"Real-time event 35"
block|}
block|,
block|{
literal|"SIG36"
block|,
literal|"Real-time event 36"
block|}
block|,
block|{
literal|"SIG37"
block|,
literal|"Real-time event 37"
block|}
block|,
block|{
literal|"SIG38"
block|,
literal|"Real-time event 38"
block|}
block|,
block|{
literal|"SIG39"
block|,
literal|"Real-time event 39"
block|}
block|,
block|{
literal|"SIG40"
block|,
literal|"Real-time event 40"
block|}
block|,
block|{
literal|"SIG41"
block|,
literal|"Real-time event 41"
block|}
block|,
block|{
literal|"SIG42"
block|,
literal|"Real-time event 42"
block|}
block|,
block|{
literal|"SIG43"
block|,
literal|"Real-time event 43"
block|}
block|,
block|{
literal|"SIG44"
block|,
literal|"Real-time event 44"
block|}
block|,
block|{
literal|"SIG45"
block|,
literal|"Real-time event 45"
block|}
block|,
block|{
literal|"SIG46"
block|,
literal|"Real-time event 46"
block|}
block|,
block|{
literal|"SIG47"
block|,
literal|"Real-time event 47"
block|}
block|,
block|{
literal|"SIG48"
block|,
literal|"Real-time event 48"
block|}
block|,
block|{
literal|"SIG49"
block|,
literal|"Real-time event 49"
block|}
block|,
block|{
literal|"SIG50"
block|,
literal|"Real-time event 50"
block|}
block|,
block|{
literal|"SIG51"
block|,
literal|"Real-time event 51"
block|}
block|,
block|{
literal|"SIG52"
block|,
literal|"Real-time event 52"
block|}
block|,
block|{
literal|"SIG53"
block|,
literal|"Real-time event 53"
block|}
block|,
block|{
literal|"SIG54"
block|,
literal|"Real-time event 54"
block|}
block|,
block|{
literal|"SIG55"
block|,
literal|"Real-time event 55"
block|}
block|,
block|{
literal|"SIG56"
block|,
literal|"Real-time event 56"
block|}
block|,
block|{
literal|"SIG57"
block|,
literal|"Real-time event 57"
block|}
block|,
block|{
literal|"SIG58"
block|,
literal|"Real-time event 58"
block|}
block|,
block|{
literal|"SIG59"
block|,
literal|"Real-time event 59"
block|}
block|,
block|{
literal|"SIG60"
block|,
literal|"Real-time event 60"
block|}
block|,
block|{
literal|"SIG61"
block|,
literal|"Real-time event 61"
block|}
block|,
block|{
literal|"SIG62"
block|,
literal|"Real-time event 62"
block|}
block|,
block|{
literal|"SIG63"
block|,
literal|"Real-time event 63"
block|}
block|,
block|{
literal|"SIGCANCEL"
block|,
literal|"LWP internal signal"
block|}
block|,
block|{
literal|"SIG32"
block|,
literal|"Real-time event 32"
block|}
block|,
block|{
literal|"SIG64"
block|,
literal|"Real-time event 64"
block|}
block|,
block|{
literal|"SIG65"
block|,
literal|"Real-time event 65"
block|}
block|,
block|{
literal|"SIG66"
block|,
literal|"Real-time event 66"
block|}
block|,
block|{
literal|"SIG67"
block|,
literal|"Real-time event 67"
block|}
block|,
block|{
literal|"SIG68"
block|,
literal|"Real-time event 68"
block|}
block|,
block|{
literal|"SIG69"
block|,
literal|"Real-time event 69"
block|}
block|,
block|{
literal|"SIG70"
block|,
literal|"Real-time event 70"
block|}
block|,
block|{
literal|"SIG71"
block|,
literal|"Real-time event 71"
block|}
block|,
block|{
literal|"SIG72"
block|,
literal|"Real-time event 72"
block|}
block|,
block|{
literal|"SIG73"
block|,
literal|"Real-time event 73"
block|}
block|,
block|{
literal|"SIG74"
block|,
literal|"Real-time event 74"
block|}
block|,
block|{
literal|"SIG75"
block|,
literal|"Real-time event 75"
block|}
block|,
block|{
literal|"SIG76"
block|,
literal|"Real-time event 76"
block|}
block|,
block|{
literal|"SIG77"
block|,
literal|"Real-time event 77"
block|}
block|,
block|{
literal|"SIG78"
block|,
literal|"Real-time event 78"
block|}
block|,
block|{
literal|"SIG79"
block|,
literal|"Real-time event 79"
block|}
block|,
block|{
literal|"SIG80"
block|,
literal|"Real-time event 80"
block|}
block|,
block|{
literal|"SIG81"
block|,
literal|"Real-time event 81"
block|}
block|,
block|{
literal|"SIG82"
block|,
literal|"Real-time event 82"
block|}
block|,
block|{
literal|"SIG83"
block|,
literal|"Real-time event 83"
block|}
block|,
block|{
literal|"SIG84"
block|,
literal|"Real-time event 84"
block|}
block|,
block|{
literal|"SIG85"
block|,
literal|"Real-time event 85"
block|}
block|,
block|{
literal|"SIG86"
block|,
literal|"Real-time event 86"
block|}
block|,
block|{
literal|"SIG87"
block|,
literal|"Real-time event 87"
block|}
block|,
block|{
literal|"SIG88"
block|,
literal|"Real-time event 88"
block|}
block|,
block|{
literal|"SIG89"
block|,
literal|"Real-time event 89"
block|}
block|,
block|{
literal|"SIG90"
block|,
literal|"Real-time event 90"
block|}
block|,
block|{
literal|"SIG91"
block|,
literal|"Real-time event 91"
block|}
block|,
block|{
literal|"SIG92"
block|,
literal|"Real-time event 92"
block|}
block|,
block|{
literal|"SIG93"
block|,
literal|"Real-time event 93"
block|}
block|,
block|{
literal|"SIG94"
block|,
literal|"Real-time event 94"
block|}
block|,
block|{
literal|"SIG95"
block|,
literal|"Real-time event 95"
block|}
block|,
block|{
literal|"SIG96"
block|,
literal|"Real-time event 96"
block|}
block|,
block|{
literal|"SIG97"
block|,
literal|"Real-time event 97"
block|}
block|,
block|{
literal|"SIG98"
block|,
literal|"Real-time event 98"
block|}
block|,
block|{
literal|"SIG99"
block|,
literal|"Real-time event 99"
block|}
block|,
block|{
literal|"SIG100"
block|,
literal|"Real-time event 100"
block|}
block|,
block|{
literal|"SIG101"
block|,
literal|"Real-time event 101"
block|}
block|,
block|{
literal|"SIG102"
block|,
literal|"Real-time event 102"
block|}
block|,
block|{
literal|"SIG103"
block|,
literal|"Real-time event 103"
block|}
block|,
block|{
literal|"SIG104"
block|,
literal|"Real-time event 104"
block|}
block|,
block|{
literal|"SIG105"
block|,
literal|"Real-time event 105"
block|}
block|,
block|{
literal|"SIG106"
block|,
literal|"Real-time event 106"
block|}
block|,
block|{
literal|"SIG107"
block|,
literal|"Real-time event 107"
block|}
block|,
block|{
literal|"SIG108"
block|,
literal|"Real-time event 108"
block|}
block|,
block|{
literal|"SIG109"
block|,
literal|"Real-time event 109"
block|}
block|,
block|{
literal|"SIG110"
block|,
literal|"Real-time event 110"
block|}
block|,
block|{
literal|"SIG111"
block|,
literal|"Real-time event 111"
block|}
block|,
block|{
literal|"SIG112"
block|,
literal|"Real-time event 112"
block|}
block|,
block|{
literal|"SIG113"
block|,
literal|"Real-time event 113"
block|}
block|,
block|{
literal|"SIG114"
block|,
literal|"Real-time event 114"
block|}
block|,
block|{
literal|"SIG115"
block|,
literal|"Real-time event 115"
block|}
block|,
block|{
literal|"SIG116"
block|,
literal|"Real-time event 116"
block|}
block|,
block|{
literal|"SIG117"
block|,
literal|"Real-time event 117"
block|}
block|,
block|{
literal|"SIG118"
block|,
literal|"Real-time event 118"
block|}
block|,
block|{
literal|"SIG119"
block|,
literal|"Real-time event 119"
block|}
block|,
block|{
literal|"SIG120"
block|,
literal|"Real-time event 120"
block|}
block|,
block|{
literal|"SIG121"
block|,
literal|"Real-time event 121"
block|}
block|,
block|{
literal|"SIG122"
block|,
literal|"Real-time event 122"
block|}
block|,
block|{
literal|"SIG123"
block|,
literal|"Real-time event 123"
block|}
block|,
block|{
literal|"SIG124"
block|,
literal|"Real-time event 124"
block|}
block|,
block|{
literal|"SIG125"
block|,
literal|"Real-time event 125"
block|}
block|,
block|{
literal|"SIG126"
block|,
literal|"Real-time event 126"
block|}
block|,
block|{
literal|"SIG127"
block|,
literal|"Real-time event 127"
block|}
block|,
if|#
directive|if
name|defined
argument_list|(
name|MACH
argument_list|)
operator|||
name|defined
argument_list|(
name|__MACH__
argument_list|)
comment|/* Mach exceptions */
block|{
literal|"EXC_BAD_ACCESS"
block|,
literal|"Could not access memory"
block|}
block|,
block|{
literal|"EXC_BAD_INSTRUCTION"
block|,
literal|"Illegal instruction/operand"
block|}
block|,
block|{
literal|"EXC_ARITHMETIC"
block|,
literal|"Arithmetic exception"
block|}
block|,
block|{
literal|"EXC_EMULATION"
block|,
literal|"Emulation instruction"
block|}
block|,
block|{
literal|"EXC_SOFTWARE"
block|,
literal|"Software generated exception"
block|}
block|,
block|{
literal|"EXC_BREAKPOINT"
block|,
literal|"Breakpoint"
block|}
block|,
endif|#
directive|endif
block|{
literal|"SIGINFO"
block|,
literal|"Information request"
block|}
block|,
block|{
name|NULL
block|,
literal|"Unknown signal"
block|}
block|,
block|{
name|NULL
block|,
literal|"Internal error: printing TARGET_SIGNAL_DEFAULT"
block|}
block|,
comment|/* Last entry, used to check whether the table is the right size.  */
block|{
name|NULL
block|,
literal|"TARGET_SIGNAL_MAGIC"
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* *INDENT-ON* */
end_comment

begin_comment
comment|/* Return the string for a signal.  */
end_comment

begin_function
name|char
modifier|*
name|target_signal_to_string
parameter_list|(
name|enum
name|target_signal
name|sig
parameter_list|)
block|{
if|if
condition|(
operator|(
name|sig
operator|>=
name|TARGET_SIGNAL_FIRST
operator|)
operator|&&
operator|(
name|sig
operator|<=
name|TARGET_SIGNAL_LAST
operator|)
condition|)
return|return
name|signals
index|[
name|sig
index|]
operator|.
name|string
return|;
else|else
return|return
name|signals
index|[
name|TARGET_SIGNAL_UNKNOWN
index|]
operator|.
name|string
return|;
block|}
end_function

begin_comment
comment|/* Return the name for a signal.  */
end_comment

begin_function
name|char
modifier|*
name|target_signal_to_name
parameter_list|(
name|enum
name|target_signal
name|sig
parameter_list|)
block|{
if|if
condition|(
operator|(
name|sig
operator|>=
name|TARGET_SIGNAL_FIRST
operator|)
operator|&&
operator|(
name|sig
operator|<=
name|TARGET_SIGNAL_LAST
operator|)
operator|&&
name|signals
index|[
name|sig
index|]
operator|.
name|name
operator|!=
name|NULL
condition|)
return|return
name|signals
index|[
name|sig
index|]
operator|.
name|name
return|;
else|else
comment|/* I think the code which prints this will always print it along        with the string, so no need to be verbose (very old comment).  */
return|return
literal|"?"
return|;
block|}
end_function

begin_comment
comment|/* Given a name, return its signal.  */
end_comment

begin_function
name|enum
name|target_signal
name|target_signal_from_name
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|enum
name|target_signal
name|sig
decl_stmt|;
comment|/* It's possible we also should allow "SIGCLD" as well as "SIGCHLD"      for TARGET_SIGNAL_SIGCHLD.  SIGIOT, on the other hand, is more      questionable; seems like by now people should call it SIGABRT      instead.  */
comment|/* This ugly cast brought to you by the native VAX compiler.  */
for|for
control|(
name|sig
operator|=
name|TARGET_SIGNAL_HUP
init|;
name|signals
index|[
name|sig
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|sig
operator|=
operator|(
expr|enum
name|target_signal
operator|)
operator|(
operator|(
name|int
operator|)
name|sig
operator|+
literal|1
operator|)
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|signals
index|[
name|sig
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|sig
return|;
return|return
name|TARGET_SIGNAL_UNKNOWN
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following functions are to help certain targets deal    with the signal/waitstatus stuff.  They could just as well be in    a file called native-utils.c or unixwaitstatus-utils.c or whatever.  */
end_comment

begin_comment
comment|/* Convert host signal to our signals.  */
end_comment

begin_function
name|enum
name|target_signal
name|target_signal_from_host
parameter_list|(
name|int
name|hostsig
parameter_list|)
block|{
comment|/* A switch statement would make sense but would require special kludges      to deal with the cases where more than one signal has the same number.  */
if|if
condition|(
name|hostsig
operator|==
literal|0
condition|)
return|return
name|TARGET_SIGNAL_0
return|;
if|#
directive|if
name|defined
argument_list|(
name|SIGHUP
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGHUP
condition|)
return|return
name|TARGET_SIGNAL_HUP
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGINT
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGINT
condition|)
return|return
name|TARGET_SIGNAL_INT
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGQUIT
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGQUIT
condition|)
return|return
name|TARGET_SIGNAL_QUIT
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGILL
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGILL
condition|)
return|return
name|TARGET_SIGNAL_ILL
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGTRAP
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGTRAP
condition|)
return|return
name|TARGET_SIGNAL_TRAP
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGABRT
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGABRT
condition|)
return|return
name|TARGET_SIGNAL_ABRT
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGEMT
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGEMT
condition|)
return|return
name|TARGET_SIGNAL_EMT
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGFPE
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGFPE
condition|)
return|return
name|TARGET_SIGNAL_FPE
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGKILL
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGKILL
condition|)
return|return
name|TARGET_SIGNAL_KILL
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGBUS
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGBUS
condition|)
return|return
name|TARGET_SIGNAL_BUS
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGSEGV
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGSEGV
condition|)
return|return
name|TARGET_SIGNAL_SEGV
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGSYS
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGSYS
condition|)
return|return
name|TARGET_SIGNAL_SYS
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPIPE
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGPIPE
condition|)
return|return
name|TARGET_SIGNAL_PIPE
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGALRM
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGALRM
condition|)
return|return
name|TARGET_SIGNAL_ALRM
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGTERM
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGTERM
condition|)
return|return
name|TARGET_SIGNAL_TERM
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGUSR1
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGUSR1
condition|)
return|return
name|TARGET_SIGNAL_USR1
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGUSR2
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGUSR2
condition|)
return|return
name|TARGET_SIGNAL_USR2
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGCLD
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGCLD
condition|)
return|return
name|TARGET_SIGNAL_CHLD
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGCHLD
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGCHLD
condition|)
return|return
name|TARGET_SIGNAL_CHLD
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPWR
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGPWR
condition|)
return|return
name|TARGET_SIGNAL_PWR
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGWINCH
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGWINCH
condition|)
return|return
name|TARGET_SIGNAL_WINCH
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGURG
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGURG
condition|)
return|return
name|TARGET_SIGNAL_URG
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGIO
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGIO
condition|)
return|return
name|TARGET_SIGNAL_IO
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPOLL
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGPOLL
condition|)
return|return
name|TARGET_SIGNAL_POLL
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGSTOP
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGSTOP
condition|)
return|return
name|TARGET_SIGNAL_STOP
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGTSTP
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGTSTP
condition|)
return|return
name|TARGET_SIGNAL_TSTP
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGCONT
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGCONT
condition|)
return|return
name|TARGET_SIGNAL_CONT
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGTTIN
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGTTIN
condition|)
return|return
name|TARGET_SIGNAL_TTIN
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGTTOU
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGTTOU
condition|)
return|return
name|TARGET_SIGNAL_TTOU
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGVTALRM
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGVTALRM
condition|)
return|return
name|TARGET_SIGNAL_VTALRM
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPROF
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGPROF
condition|)
return|return
name|TARGET_SIGNAL_PROF
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGXCPU
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGXCPU
condition|)
return|return
name|TARGET_SIGNAL_XCPU
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGXFSZ
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGXFSZ
condition|)
return|return
name|TARGET_SIGNAL_XFSZ
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGWIND
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGWIND
condition|)
return|return
name|TARGET_SIGNAL_WIND
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPHONE
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGPHONE
condition|)
return|return
name|TARGET_SIGNAL_PHONE
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGLOST
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGLOST
condition|)
return|return
name|TARGET_SIGNAL_LOST
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGWAITING
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGWAITING
condition|)
return|return
name|TARGET_SIGNAL_WAITING
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGCANCEL
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGCANCEL
condition|)
return|return
name|TARGET_SIGNAL_CANCEL
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGLWP
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGLWP
condition|)
return|return
name|TARGET_SIGNAL_LWP
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGDANGER
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGDANGER
condition|)
return|return
name|TARGET_SIGNAL_DANGER
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGGRANT
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGGRANT
condition|)
return|return
name|TARGET_SIGNAL_GRANT
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGRETRACT
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGRETRACT
condition|)
return|return
name|TARGET_SIGNAL_RETRACT
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGMSG
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGMSG
condition|)
return|return
name|TARGET_SIGNAL_MSG
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGSOUND
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGSOUND
condition|)
return|return
name|TARGET_SIGNAL_SOUND
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGSAK
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGSAK
condition|)
return|return
name|TARGET_SIGNAL_SAK
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPRIO
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGPRIO
condition|)
return|return
name|TARGET_SIGNAL_PRIO
return|;
endif|#
directive|endif
comment|/* Mach exceptions.  Assumes that the values for EXC_ are positive! */
if|#
directive|if
name|defined
argument_list|(
name|EXC_BAD_ACCESS
argument_list|)
operator|&&
name|defined
argument_list|(
name|_NSIG
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|_NSIG
operator|+
name|EXC_BAD_ACCESS
condition|)
return|return
name|TARGET_EXC_BAD_ACCESS
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EXC_BAD_INSTRUCTION
argument_list|)
operator|&&
name|defined
argument_list|(
name|_NSIG
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|_NSIG
operator|+
name|EXC_BAD_INSTRUCTION
condition|)
return|return
name|TARGET_EXC_BAD_INSTRUCTION
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EXC_ARITHMETIC
argument_list|)
operator|&&
name|defined
argument_list|(
name|_NSIG
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|_NSIG
operator|+
name|EXC_ARITHMETIC
condition|)
return|return
name|TARGET_EXC_ARITHMETIC
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EXC_EMULATION
argument_list|)
operator|&&
name|defined
argument_list|(
name|_NSIG
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|_NSIG
operator|+
name|EXC_EMULATION
condition|)
return|return
name|TARGET_EXC_EMULATION
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EXC_SOFTWARE
argument_list|)
operator|&&
name|defined
argument_list|(
name|_NSIG
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|_NSIG
operator|+
name|EXC_SOFTWARE
condition|)
return|return
name|TARGET_EXC_SOFTWARE
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EXC_BREAKPOINT
argument_list|)
operator|&&
name|defined
argument_list|(
name|_NSIG
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|_NSIG
operator|+
name|EXC_BREAKPOINT
condition|)
return|return
name|TARGET_EXC_BREAKPOINT
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGINFO
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGINFO
condition|)
return|return
name|TARGET_SIGNAL_INFO
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|REALTIME_LO
argument_list|)
if|if
condition|(
name|hostsig
operator|>=
name|REALTIME_LO
operator|&&
name|hostsig
operator|<
name|REALTIME_HI
condition|)
block|{
comment|/* This block of TARGET_SIGNAL_REALTIME value is in order.  */
if|if
condition|(
literal|33
operator|<=
name|hostsig
operator|&&
name|hostsig
operator|<=
literal|63
condition|)
return|return
operator|(
expr|enum
name|target_signal
operator|)
operator|(
name|hostsig
operator|-
literal|33
operator|+
operator|(
name|int
operator|)
name|TARGET_SIGNAL_REALTIME_33
operator|)
return|;
elseif|else
if|if
condition|(
name|hostsig
operator|==
literal|32
condition|)
return|return
name|TARGET_SIGNAL_REALTIME_32
return|;
elseif|else
if|if
condition|(
literal|64
operator|<=
name|hostsig
operator|&&
name|hostsig
operator|<=
literal|127
condition|)
return|return
operator|(
expr|enum
name|target_signal
operator|)
operator|(
name|hostsig
operator|-
literal|64
operator|+
operator|(
name|int
operator|)
name|TARGET_SIGNAL_REALTIME_64
operator|)
return|;
else|else
name|error
argument_list|(
literal|"GDB bug: target.c (target_signal_from_host): unrecognized real-time signal"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGRTMIN
argument_list|)
if|if
condition|(
name|hostsig
operator|>=
name|SIGRTMIN
operator|&&
name|hostsig
operator|<=
name|SIGRTMAX
condition|)
block|{
comment|/* This block of TARGET_SIGNAL_REALTIME value is in order.  */
if|if
condition|(
literal|33
operator|<=
name|hostsig
operator|&&
name|hostsig
operator|<=
literal|63
condition|)
return|return
operator|(
expr|enum
name|target_signal
operator|)
operator|(
name|hostsig
operator|-
literal|33
operator|+
operator|(
name|int
operator|)
name|TARGET_SIGNAL_REALTIME_33
operator|)
return|;
elseif|else
if|if
condition|(
name|hostsig
operator|==
literal|64
condition|)
return|return
name|TARGET_SIGNAL_REALTIME_64
return|;
else|else
name|error
argument_list|(
literal|"GDB bug: target.c (target_signal_from_host): unrecognized real-time signal"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|TARGET_SIGNAL_UNKNOWN
return|;
block|}
end_function

begin_comment
comment|/* Convert a OURSIG (an enum target_signal) to the form used by the    target operating system (refered to as the ``host'') or zero if the    equivalent host signal is not available.  Set/clear OURSIG_OK    accordingly. */
end_comment

begin_function
specifier|static
name|int
name|do_target_signal_to_host
parameter_list|(
name|enum
name|target_signal
name|oursig
parameter_list|,
name|int
modifier|*
name|oursig_ok
parameter_list|)
block|{
operator|*
name|oursig_ok
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|oursig
condition|)
block|{
case|case
name|TARGET_SIGNAL_0
case|:
return|return
literal|0
return|;
if|#
directive|if
name|defined
argument_list|(
name|SIGHUP
argument_list|)
case|case
name|TARGET_SIGNAL_HUP
case|:
return|return
name|SIGHUP
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGINT
argument_list|)
case|case
name|TARGET_SIGNAL_INT
case|:
return|return
name|SIGINT
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGQUIT
argument_list|)
case|case
name|TARGET_SIGNAL_QUIT
case|:
return|return
name|SIGQUIT
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGILL
argument_list|)
case|case
name|TARGET_SIGNAL_ILL
case|:
return|return
name|SIGILL
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGTRAP
argument_list|)
case|case
name|TARGET_SIGNAL_TRAP
case|:
return|return
name|SIGTRAP
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGABRT
argument_list|)
case|case
name|TARGET_SIGNAL_ABRT
case|:
return|return
name|SIGABRT
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGEMT
argument_list|)
case|case
name|TARGET_SIGNAL_EMT
case|:
return|return
name|SIGEMT
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGFPE
argument_list|)
case|case
name|TARGET_SIGNAL_FPE
case|:
return|return
name|SIGFPE
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGKILL
argument_list|)
case|case
name|TARGET_SIGNAL_KILL
case|:
return|return
name|SIGKILL
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGBUS
argument_list|)
case|case
name|TARGET_SIGNAL_BUS
case|:
return|return
name|SIGBUS
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGSEGV
argument_list|)
case|case
name|TARGET_SIGNAL_SEGV
case|:
return|return
name|SIGSEGV
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGSYS
argument_list|)
case|case
name|TARGET_SIGNAL_SYS
case|:
return|return
name|SIGSYS
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPIPE
argument_list|)
case|case
name|TARGET_SIGNAL_PIPE
case|:
return|return
name|SIGPIPE
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGALRM
argument_list|)
case|case
name|TARGET_SIGNAL_ALRM
case|:
return|return
name|SIGALRM
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGTERM
argument_list|)
case|case
name|TARGET_SIGNAL_TERM
case|:
return|return
name|SIGTERM
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGUSR1
argument_list|)
case|case
name|TARGET_SIGNAL_USR1
case|:
return|return
name|SIGUSR1
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGUSR2
argument_list|)
case|case
name|TARGET_SIGNAL_USR2
case|:
return|return
name|SIGUSR2
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGCHLD
argument_list|)
operator|||
name|defined
argument_list|(
name|SIGCLD
argument_list|)
case|case
name|TARGET_SIGNAL_CHLD
case|:
if|#
directive|if
name|defined
argument_list|(
name|SIGCHLD
argument_list|)
return|return
name|SIGCHLD
return|;
else|#
directive|else
return|return
name|SIGCLD
return|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* SIGCLD or SIGCHLD */
if|#
directive|if
name|defined
argument_list|(
name|SIGPWR
argument_list|)
case|case
name|TARGET_SIGNAL_PWR
case|:
return|return
name|SIGPWR
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGWINCH
argument_list|)
case|case
name|TARGET_SIGNAL_WINCH
case|:
return|return
name|SIGWINCH
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGURG
argument_list|)
case|case
name|TARGET_SIGNAL_URG
case|:
return|return
name|SIGURG
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGIO
argument_list|)
case|case
name|TARGET_SIGNAL_IO
case|:
return|return
name|SIGIO
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPOLL
argument_list|)
case|case
name|TARGET_SIGNAL_POLL
case|:
return|return
name|SIGPOLL
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGSTOP
argument_list|)
case|case
name|TARGET_SIGNAL_STOP
case|:
return|return
name|SIGSTOP
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGTSTP
argument_list|)
case|case
name|TARGET_SIGNAL_TSTP
case|:
return|return
name|SIGTSTP
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGCONT
argument_list|)
case|case
name|TARGET_SIGNAL_CONT
case|:
return|return
name|SIGCONT
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGTTIN
argument_list|)
case|case
name|TARGET_SIGNAL_TTIN
case|:
return|return
name|SIGTTIN
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGTTOU
argument_list|)
case|case
name|TARGET_SIGNAL_TTOU
case|:
return|return
name|SIGTTOU
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGVTALRM
argument_list|)
case|case
name|TARGET_SIGNAL_VTALRM
case|:
return|return
name|SIGVTALRM
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPROF
argument_list|)
case|case
name|TARGET_SIGNAL_PROF
case|:
return|return
name|SIGPROF
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGXCPU
argument_list|)
case|case
name|TARGET_SIGNAL_XCPU
case|:
return|return
name|SIGXCPU
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGXFSZ
argument_list|)
case|case
name|TARGET_SIGNAL_XFSZ
case|:
return|return
name|SIGXFSZ
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGWIND
argument_list|)
case|case
name|TARGET_SIGNAL_WIND
case|:
return|return
name|SIGWIND
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPHONE
argument_list|)
case|case
name|TARGET_SIGNAL_PHONE
case|:
return|return
name|SIGPHONE
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGLOST
argument_list|)
case|case
name|TARGET_SIGNAL_LOST
case|:
return|return
name|SIGLOST
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGWAITING
argument_list|)
case|case
name|TARGET_SIGNAL_WAITING
case|:
return|return
name|SIGWAITING
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGCANCEL
argument_list|)
case|case
name|TARGET_SIGNAL_CANCEL
case|:
return|return
name|SIGCANCEL
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGLWP
argument_list|)
case|case
name|TARGET_SIGNAL_LWP
case|:
return|return
name|SIGLWP
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGDANGER
argument_list|)
case|case
name|TARGET_SIGNAL_DANGER
case|:
return|return
name|SIGDANGER
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGGRANT
argument_list|)
case|case
name|TARGET_SIGNAL_GRANT
case|:
return|return
name|SIGGRANT
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGRETRACT
argument_list|)
case|case
name|TARGET_SIGNAL_RETRACT
case|:
return|return
name|SIGRETRACT
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGMSG
argument_list|)
case|case
name|TARGET_SIGNAL_MSG
case|:
return|return
name|SIGMSG
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGSOUND
argument_list|)
case|case
name|TARGET_SIGNAL_SOUND
case|:
return|return
name|SIGSOUND
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGSAK
argument_list|)
case|case
name|TARGET_SIGNAL_SAK
case|:
return|return
name|SIGSAK
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPRIO
argument_list|)
case|case
name|TARGET_SIGNAL_PRIO
case|:
return|return
name|SIGPRIO
return|;
endif|#
directive|endif
comment|/* Mach exceptions.  Assumes that the values for EXC_ are positive! */
if|#
directive|if
name|defined
argument_list|(
name|EXC_BAD_ACCESS
argument_list|)
operator|&&
name|defined
argument_list|(
name|_NSIG
argument_list|)
case|case
name|TARGET_EXC_BAD_ACCESS
case|:
return|return
name|_NSIG
operator|+
name|EXC_BAD_ACCESS
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EXC_BAD_INSTRUCTION
argument_list|)
operator|&&
name|defined
argument_list|(
name|_NSIG
argument_list|)
case|case
name|TARGET_EXC_BAD_INSTRUCTION
case|:
return|return
name|_NSIG
operator|+
name|EXC_BAD_INSTRUCTION
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EXC_ARITHMETIC
argument_list|)
operator|&&
name|defined
argument_list|(
name|_NSIG
argument_list|)
case|case
name|TARGET_EXC_ARITHMETIC
case|:
return|return
name|_NSIG
operator|+
name|EXC_ARITHMETIC
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EXC_EMULATION
argument_list|)
operator|&&
name|defined
argument_list|(
name|_NSIG
argument_list|)
case|case
name|TARGET_EXC_EMULATION
case|:
return|return
name|_NSIG
operator|+
name|EXC_EMULATION
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EXC_SOFTWARE
argument_list|)
operator|&&
name|defined
argument_list|(
name|_NSIG
argument_list|)
case|case
name|TARGET_EXC_SOFTWARE
case|:
return|return
name|_NSIG
operator|+
name|EXC_SOFTWARE
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EXC_BREAKPOINT
argument_list|)
operator|&&
name|defined
argument_list|(
name|_NSIG
argument_list|)
case|case
name|TARGET_EXC_BREAKPOINT
case|:
return|return
name|_NSIG
operator|+
name|EXC_BREAKPOINT
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGINFO
argument_list|)
case|case
name|TARGET_SIGNAL_INFO
case|:
return|return
name|SIGINFO
return|;
endif|#
directive|endif
default|default:
if|#
directive|if
name|defined
argument_list|(
name|REALTIME_LO
argument_list|)
if|if
condition|(
name|oursig
operator|>=
name|TARGET_SIGNAL_REALTIME_33
operator|&&
name|oursig
operator|<=
name|TARGET_SIGNAL_REALTIME_63
condition|)
block|{
comment|/* This block of signals is continuous, and              TARGET_SIGNAL_REALTIME_33 is 33 by definition.  */
name|int
name|retsig
init|=
operator|(
name|int
operator|)
name|oursig
operator|-
operator|(
name|int
operator|)
name|TARGET_SIGNAL_REALTIME_33
operator|+
literal|33
decl_stmt|;
if|if
condition|(
name|retsig
operator|>=
name|REALTIME_LO
operator|&&
name|retsig
operator|<
name|REALTIME_HI
condition|)
return|return
name|retsig
return|;
block|}
if|#
directive|if
operator|(
name|REALTIME_LO
operator|<
literal|33
operator|)
elseif|else
if|if
condition|(
name|oursig
operator|==
name|TARGET_SIGNAL_REALTIME_32
condition|)
block|{
comment|/* TARGET_SIGNAL_REALTIME_32 isn't contiguous with              TARGET_SIGNAL_REALTIME_33.  It is 32 by definition.  */
return|return
literal|32
return|;
block|}
endif|#
directive|endif
if|#
directive|if
operator|(
name|REALTIME_HI
operator|>
literal|64
operator|)
if|if
condition|(
name|oursig
operator|>=
name|TARGET_SIGNAL_REALTIME_64
operator|&&
name|oursig
operator|<=
name|TARGET_SIGNAL_REALTIME_127
condition|)
block|{
comment|/* This block of signals is continuous, and              TARGET_SIGNAL_REALTIME_64 is 64 by definition.  */
name|int
name|retsig
init|=
operator|(
name|int
operator|)
name|oursig
operator|-
operator|(
name|int
operator|)
name|TARGET_SIGNAL_REALTIME_64
operator|+
literal|64
decl_stmt|;
if|if
condition|(
name|retsig
operator|>=
name|REALTIME_LO
operator|&&
name|retsig
operator|<
name|REALTIME_HI
condition|)
return|return
name|retsig
return|;
block|}
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGRTMIN
argument_list|)
if|if
condition|(
name|oursig
operator|>=
name|TARGET_SIGNAL_REALTIME_33
operator|&&
name|oursig
operator|<=
name|TARGET_SIGNAL_REALTIME_63
condition|)
block|{
comment|/* This block of signals is continuous, and              TARGET_SIGNAL_REALTIME_33 is 33 by definition.  */
name|int
name|retsig
init|=
operator|(
name|int
operator|)
name|oursig
operator|-
operator|(
name|int
operator|)
name|TARGET_SIGNAL_REALTIME_33
operator|+
literal|33
decl_stmt|;
if|if
condition|(
name|retsig
operator|>=
name|SIGRTMIN
operator|&&
name|retsig
operator|<=
name|SIGRTMAX
condition|)
return|return
name|retsig
return|;
block|}
elseif|else
if|if
condition|(
name|oursig
operator|==
name|TARGET_SIGNAL_REALTIME_64
condition|)
return|return
literal|64
return|;
endif|#
directive|endif
operator|*
name|oursig_ok
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
name|int
name|target_signal_to_host_p
parameter_list|(
name|enum
name|target_signal
name|oursig
parameter_list|)
block|{
name|int
name|oursig_ok
decl_stmt|;
name|do_target_signal_to_host
argument_list|(
name|oursig
argument_list|,
operator|&
name|oursig_ok
argument_list|)
expr_stmt|;
return|return
name|oursig_ok
return|;
block|}
end_function

begin_function
name|int
name|target_signal_to_host
parameter_list|(
name|enum
name|target_signal
name|oursig
parameter_list|)
block|{
name|int
name|oursig_ok
decl_stmt|;
name|int
name|targ_signo
init|=
name|do_target_signal_to_host
argument_list|(
name|oursig
argument_list|,
operator|&
name|oursig_ok
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|oursig_ok
condition|)
block|{
comment|/* The user might be trying to do "signal SIGSAK" where this system          doesn't have SIGSAK.  */
name|warning
argument_list|(
literal|"Signal %s does not exist on this system.\n"
argument_list|,
name|target_signal_to_name
argument_list|(
name|oursig
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
name|targ_signo
return|;
block|}
end_function

begin_comment
comment|/* In some circumstances we allow a command to specify a numeric    signal.  The idea is to keep these circumstances limited so that    users (and scripts) develop portable habits.  For comparison,    POSIX.2 `kill' requires that 1,2,3,6,9,14, and 15 work (and using a    numeric signal at all is obsolescent.  We are slightly more    lenient and allow 1-15 which should match host signal numbers on    most systems.  Use of symbolic signal names is strongly encouraged.  */
end_comment

begin_function
name|enum
name|target_signal
name|target_signal_from_command
parameter_list|(
name|int
name|num
parameter_list|)
block|{
if|if
condition|(
name|num
operator|>=
literal|1
operator|&&
name|num
operator|<=
literal|15
condition|)
return|return
operator|(
expr|enum
name|target_signal
operator|)
name|num
return|;
name|error
argument_list|(
literal|"Only signals 1-15 are valid as numeric signals.\n\ Use \"info signals\" for a list of symbolic signals."
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|GDBSERVER
end_ifndef

begin_function
name|void
name|_initialize_signals
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|signals
index|[
name|TARGET_SIGNAL_LAST
index|]
operator|.
name|string
argument_list|,
literal|"TARGET_SIGNAL_MAGIC"
argument_list|)
operator|!=
literal|0
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"failed internal consistency check"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

