begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* nto-tdep.c - general QNX Neutrino target functionality.     Copyright 2003 Free Software Foundation, Inc.     Contributed by QNX Software Systems Ltd.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"nto-tdep.h"
end_include

begin_include
include|#
directive|include
file|"top.h"
end_include

begin_include
include|#
directive|include
file|"cli/cli-decode.h"
end_include

begin_include
include|#
directive|include
file|"cli/cli-cmds.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"gdbarch.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"solib-svr4.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__CYGWIN__
end_ifdef

begin_include
include|#
directive|include
file|<sys/cygwin.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__CYGWIN__
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|default_nto_target
index|[]
init|=
literal|"C:\\QNXsdk\\target\\qnx6"
decl_stmt|;
end_decl_stmt

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__sun__
argument_list|)
operator|||
name|defined
argument_list|(
name|linux
argument_list|)
end_elif

begin_decl_stmt
specifier|static
name|char
name|default_nto_target
index|[]
init|=
literal|"/opt/QNXsdk/target/qnx6"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|char
name|default_nto_target
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|nto_target_ops
name|current_nto_target
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|nto_target
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|getenv
argument_list|(
literal|"QNX_TARGET"
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|__CYGWIN__
specifier|static
name|char
name|buf
index|[
name|PATH_MAX
index|]
decl_stmt|;
if|if
condition|(
name|p
condition|)
name|cygwin_conv_to_posix_path
argument_list|(
name|p
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|cygwin_conv_to_posix_path
argument_list|(
name|default_nto_target
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
else|#
directive|else
return|return
name|p
condition|?
name|p
else|:
name|default_nto_target
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Take a string such as i386, rs6000, etc. and map it onto CPUTYPE_X86,    CPUTYPE_PPC, etc. as defined in nto-share/dsmsgs.h.  */
end_comment

begin_function
name|int
name|nto_map_arch_to_cputype
parameter_list|(
specifier|const
name|char
modifier|*
name|arch
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arch
argument_list|,
literal|"i386"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|arch
argument_list|,
literal|"x86"
argument_list|)
condition|)
return|return
name|CPUTYPE_X86
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arch
argument_list|,
literal|"rs6000"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|arch
argument_list|,
literal|"powerpc"
argument_list|)
condition|)
return|return
name|CPUTYPE_PPC
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arch
argument_list|,
literal|"mips"
argument_list|)
condition|)
return|return
name|CPUTYPE_MIPS
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arch
argument_list|,
literal|"arm"
argument_list|)
condition|)
return|return
name|CPUTYPE_ARM
return|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arch
argument_list|,
literal|"sh"
argument_list|)
condition|)
return|return
name|CPUTYPE_SH
return|;
return|return
name|CPUTYPE_UNKNOWN
return|;
block|}
end_function

begin_function
name|int
name|nto_find_and_open_solib
parameter_list|(
name|char
modifier|*
name|solib
parameter_list|,
name|unsigned
name|o_flags
parameter_list|,
name|char
modifier|*
modifier|*
name|temp_pathname
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|,
name|arch_path
index|[
name|PATH_MAX
index|]
decl_stmt|,
modifier|*
name|nto_root
decl_stmt|,
modifier|*
name|endian
decl_stmt|;
specifier|const
name|char
modifier|*
name|arch
decl_stmt|;
name|char
modifier|*
name|path_fmt
init|=
literal|"%s/lib:%s/usr/lib:%s/usr/photon/lib\ :%s/usr/photon/dll:%s/lib/dll"
decl_stmt|;
name|nto_root
operator|=
name|nto_target
argument_list|()
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|TARGET_ARCHITECTURE
operator|->
name|arch_name
argument_list|,
literal|"i386"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|arch
operator|=
literal|"x86"
expr_stmt|;
name|endian
operator|=
literal|""
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|TARGET_ARCHITECTURE
operator|->
name|arch_name
argument_list|,
literal|"rs6000"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|TARGET_ARCHITECTURE
operator|->
name|arch_name
argument_list|,
literal|"powerpc"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|arch
operator|=
literal|"ppc"
expr_stmt|;
name|endian
operator|=
literal|"be"
expr_stmt|;
block|}
else|else
block|{
name|arch
operator|=
name|TARGET_ARCHITECTURE
operator|->
name|arch_name
expr_stmt|;
name|endian
operator|=
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|?
literal|"be"
else|:
literal|"le"
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|arch_path
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|nto_root
argument_list|,
name|arch
argument_list|,
name|endian
argument_list|)
expr_stmt|;
name|buf
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|path_fmt
argument_list|)
operator|+
name|strlen
argument_list|(
name|arch_path
argument_list|)
operator|*
literal|5
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|path_fmt
argument_list|,
name|arch_path
argument_list|,
name|arch_path
argument_list|,
name|arch_path
argument_list|,
name|arch_path
argument_list|,
name|arch_path
argument_list|)
expr_stmt|;
return|return
name|openp
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|solib
argument_list|,
name|o_flags
argument_list|,
literal|0
argument_list|,
name|temp_pathname
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|nto_init_solib_absolute_prefix
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|buf
index|[
name|PATH_MAX
operator|*
literal|2
index|]
decl_stmt|,
name|arch_path
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
modifier|*
name|nto_root
decl_stmt|,
modifier|*
name|endian
decl_stmt|;
specifier|const
name|char
modifier|*
name|arch
decl_stmt|;
name|nto_root
operator|=
name|nto_target
argument_list|()
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|TARGET_ARCHITECTURE
operator|->
name|arch_name
argument_list|,
literal|"i386"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|arch
operator|=
literal|"x86"
expr_stmt|;
name|endian
operator|=
literal|""
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|TARGET_ARCHITECTURE
operator|->
name|arch_name
argument_list|,
literal|"rs6000"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|TARGET_ARCHITECTURE
operator|->
name|arch_name
argument_list|,
literal|"powerpc"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|arch
operator|=
literal|"ppc"
expr_stmt|;
name|endian
operator|=
literal|"be"
expr_stmt|;
block|}
else|else
block|{
name|arch
operator|=
name|TARGET_ARCHITECTURE
operator|->
name|arch_name
expr_stmt|;
name|endian
operator|=
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|?
literal|"be"
else|:
literal|"le"
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|arch_path
argument_list|,
literal|"%s/%s%s"
argument_list|,
name|nto_root
argument_list|,
name|arch
argument_list|,
name|endian
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"set solib-absolute-prefix %s"
argument_list|,
name|arch_path
argument_list|)
expr_stmt|;
name|execute_command
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
modifier|*
name|nto_parse_redirection
parameter_list|(
name|char
modifier|*
name|pargv
index|[]
parameter_list|,
name|char
modifier|*
modifier|*
name|pin
parameter_list|,
name|char
modifier|*
modifier|*
name|pout
parameter_list|,
name|char
modifier|*
modifier|*
name|perr
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|in
decl_stmt|,
modifier|*
name|out
decl_stmt|,
modifier|*
name|err
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|argc
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|pargv
index|[
name|n
index|]
condition|;
name|n
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|in
operator|=
literal|""
expr_stmt|;
name|out
operator|=
literal|""
expr_stmt|;
name|err
operator|=
literal|""
expr_stmt|;
name|argv
operator|=
name|xcalloc
argument_list|(
name|n
operator|+
literal|1
argument_list|,
sizeof|sizeof
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|argc
operator|=
name|n
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|argc
condition|;
name|n
operator|++
control|)
block|{
name|p
operator|=
name|pargv
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'>'
condition|)
block|{
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
name|out
operator|=
name|p
expr_stmt|;
else|else
name|out
operator|=
name|pargv
index|[
operator|++
name|n
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'<'
condition|)
block|{
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
name|in
operator|=
name|p
expr_stmt|;
else|else
name|in
operator|=
name|pargv
index|[
operator|++
name|n
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'2'
operator|&&
operator|*
name|p
operator|++
operator|==
literal|'>'
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'&'
operator|&&
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|'1'
condition|)
name|err
operator|=
name|out
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
condition|)
name|err
operator|=
name|p
expr_stmt|;
else|else
name|err
operator|=
name|pargv
index|[
operator|++
name|n
index|]
expr_stmt|;
block|}
else|else
name|argv
index|[
name|i
operator|++
index|]
operator|=
name|pargv
index|[
name|n
index|]
expr_stmt|;
block|}
operator|*
name|pin
operator|=
name|in
expr_stmt|;
operator|*
name|pout
operator|=
name|out
expr_stmt|;
operator|*
name|perr
operator|=
name|err
expr_stmt|;
return|return
name|argv
return|;
block|}
end_function

begin_comment
comment|/* The struct lm_info, LM_ADDR, and nto_truncate_ptr are copied from    solib-svr4.c to support nto_relocate_section_addresses    which is different from the svr4 version.  */
end_comment

begin_struct
struct|struct
name|lm_info
block|{
comment|/* Pointer to copy of link map from inferior.  The type is char *      rather than void *, so that we may use byte offsets to find the      various fields without the need for a cast.  */
name|char
modifier|*
name|lm
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|CORE_ADDR
name|LM_ADDR
parameter_list|(
name|struct
name|so_list
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|link_map_offsets
modifier|*
name|lmo
init|=
name|nto_fetch_link_map_offsets
argument_list|()
decl_stmt|;
return|return
operator|(
name|CORE_ADDR
operator|)
name|extract_signed_integer
argument_list|(
name|so
operator|->
name|lm_info
operator|->
name|lm
operator|+
name|lmo
operator|->
name|l_addr_offset
argument_list|,
name|lmo
operator|->
name|l_addr_size
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|nto_truncate_ptr
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|)
block|{
if|if
condition|(
name|TARGET_PTR_BIT
operator|==
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
operator|*
literal|8
condition|)
comment|/* We don't need to truncate anything, and the bit twiddling below        will fail due to overflow problems.  */
return|return
name|addr
return|;
else|else
return|return
name|addr
operator|&
operator|(
operator|(
operator|(
name|CORE_ADDR
operator|)
literal|1
operator|<<
name|TARGET_PTR_BIT
operator|)
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|Elf_Internal_Phdr
modifier|*
name|find_load_phdr
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|Elf_Internal_Phdr
modifier|*
name|phdr
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
condition|)
return|return
name|NULL
return|;
name|phdr
operator|=
name|elf_tdata
argument_list|(
name|abfd
argument_list|)
operator|->
name|phdr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_phnum
condition|;
name|i
operator|++
operator|,
name|phdr
operator|++
control|)
block|{
if|if
condition|(
name|phdr
operator|->
name|p_type
operator|==
name|PT_LOAD
operator|&&
operator|(
name|phdr
operator|->
name|p_flags
operator|&
name|PF_X
operator|)
condition|)
return|return
name|phdr
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|nto_relocate_section_addresses
parameter_list|(
name|struct
name|so_list
modifier|*
name|so
parameter_list|,
name|struct
name|section_table
modifier|*
name|sec
parameter_list|)
block|{
comment|/* Neutrino treats the l_addr base address field in link.h as different than      the base address in the System V ABI and so the offset needs to be      calculated and applied to relocations.  */
name|Elf_Internal_Phdr
modifier|*
name|phdr
init|=
name|find_load_phdr
argument_list|(
name|sec
operator|->
name|bfd
argument_list|)
decl_stmt|;
name|unsigned
name|vaddr
init|=
name|phdr
condition|?
name|phdr
operator|->
name|p_vaddr
else|:
literal|0
decl_stmt|;
name|sec
operator|->
name|addr
operator|=
name|nto_truncate_ptr
argument_list|(
name|sec
operator|->
name|addr
operator|+
name|LM_ADDR
argument_list|(
name|so
argument_list|)
operator|-
name|vaddr
argument_list|)
expr_stmt|;
name|sec
operator|->
name|endaddr
operator|=
name|nto_truncate_ptr
argument_list|(
name|sec
operator|->
name|endaddr
operator|+
name|LM_ADDR
argument_list|(
name|so
argument_list|)
operator|-
name|vaddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fetch_core_registers
parameter_list|(
name|char
modifier|*
name|core_reg_sect
parameter_list|,
name|unsigned
name|core_reg_size
parameter_list|,
name|int
name|which
parameter_list|,
name|CORE_ADDR
name|reg_addr
parameter_list|)
block|{
name|nto_regset_t
name|regset
decl_stmt|;
comment|/* See corelow.c:get_core_registers for values of WHICH.  */
if|if
condition|(
name|which
operator|==
literal|0
condition|)
block|{
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|regset
argument_list|,
name|core_reg_sect
argument_list|,
name|min
argument_list|(
name|core_reg_size
argument_list|,
sizeof|sizeof
argument_list|(
name|regset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|nto_supply_gregset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|regset
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|which
operator|==
literal|2
condition|)
block|{
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|regset
argument_list|,
name|core_reg_sect
argument_list|,
name|min
argument_list|(
name|core_reg_size
argument_list|,
sizeof|sizeof
argument_list|(
name|regset
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|nto_supply_fpregset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|regset
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|nto_dummy_supply_regset
parameter_list|(
name|char
modifier|*
name|regs
parameter_list|)
block|{
comment|/* Do nothing.  */
block|}
end_function

begin_comment
comment|/* Register that we are able to handle ELF file formats using standard    procfs "regset" structures.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|core_fns
name|regset_core_fns
init|=
block|{
name|bfd_target_elf_flavour
block|,
comment|/* core_flavour */
name|default_check_format
block|,
comment|/* check_format */
name|default_core_sniffer
block|,
comment|/* core_sniffer */
name|fetch_core_registers
block|,
comment|/* core_read_registers */
name|NULL
comment|/* next */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_nto_tdep
parameter_list|(
name|void
parameter_list|)
block|{
name|add_setshow_cmd
argument_list|(
literal|"nto-debug"
argument_list|,
name|class_maintenance
argument_list|,
name|var_zinteger
argument_list|,
operator|&
name|nto_internal_debugging
argument_list|,
literal|"Set QNX NTO internal debugging.\n\ When non-zero, nto specific debug info is\n\ displayed. Different information is displayed\n\ for different positive values."
argument_list|,
literal|"Show QNX NTO internal debugging.\n"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|setdebuglist
argument_list|,
operator|&
name|showdebuglist
argument_list|)
expr_stmt|;
comment|/* We use SIG45 for pulses, or something, so nostop, noprint      and pass them.  */
name|signal_stop_update
argument_list|(
name|target_signal_from_name
argument_list|(
literal|"SIG45"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|signal_print_update
argument_list|(
name|target_signal_from_name
argument_list|(
literal|"SIG45"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|signal_pass_update
argument_list|(
name|target_signal_from_name
argument_list|(
literal|"SIG45"
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* By default we don't want to stop on these two, but we do want to pass.  */
if|#
directive|if
name|defined
argument_list|(
name|SIGSELECT
argument_list|)
name|signal_stop_update
argument_list|(
name|SIGSELECT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|signal_print_update
argument_list|(
name|SIGSELECT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|signal_pass_update
argument_list|(
name|SIGSELECT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPHOTON
argument_list|)
name|signal_stop_update
argument_list|(
name|SIGPHOTON
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|signal_print_update
argument_list|(
name|SIGPHOTON
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|signal_pass_update
argument_list|(
name|SIGPHOTON
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Register core file support.  */
name|add_core_fns
argument_list|(
operator|&
name|regset_core_fns
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

