begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Caching code.    Copyright 1992, 1993, 1995, 1996, 1998, 1999, 2000, 2001    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"dcache.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_comment
comment|/* The data cache could lead to incorrect results because it doesn't    know about volatile variables, thus making it impossible to debug    functions which use memory mapped I/O devices.  Set the nocache    memory region attribute in those cases.     In general the dcache speeds up performance, some speed improvement    comes from the actual caching mechanism, but the major gain is in    the reduction of the remote protocol overhead; instead of reading    or writing a large area of memory in 4 byte requests, the cache    bundles up the requests into 32 byte (actually LINE_SIZE) chunks.    Reducing the overhead to an eighth of what it was.  This is very    obvious when displaying a large amount of data,     eg, x/200x 0      caching     |   no    yes     ----------------------------     first time  |   4 sec  2 sec improvement due to chunking     second time |   4 sec  0 sec improvement due to caching     The cache structure is unusual, we keep a number of cache blocks    (DCACHE_SIZE) and each one caches a LINE_SIZEed area of memory.    Within each line we remember the address of the line (always a    multiple of the LINE_SIZE) and a vector of bytes over the range.    There's another vector which contains the state of the bytes.     ENTRY_BAD means that the byte is just plain wrong, and has no    correspondence with anything else (as it would when the cache is    turned on, but nothing has been done to it.     ENTRY_DIRTY means that the byte has some data in it which should be    written out to the remote target one day, but contains correct    data.     ENTRY_OK means that the data is the same in the cache as it is in    remote memory.      The ENTRY_DIRTY state is necessary because GDB likes to write large    lumps of memory in small bits.  If the caching mechanism didn't    maintain the DIRTY information, then something like a two byte    write would mean that the entire cache line would have to be read,    the two bytes modified and then written out again.  The alternative    would be to not read in the cache line in the first place, and just    write the two bytes directly into target memory.  The trouble with    that is that it really nails performance, because of the remote    protocol overhead.  This way, all those little writes are bundled    up into an entire cache line write in one go, without having to    read the cache line in the first place.  */
end_comment

begin_comment
comment|/* NOTE: Interaction of dcache and memory region attributes     As there is no requirement that memory region attributes be aligned    to or be a multiple of the dcache page size, dcache_read_line() and    dcache_write_line() must break up the page by memory region.  If a    chunk does not have the cache attribute set, an invalid memory type    is set, etc., then the chunk is skipped.  Those chunks are handled    in target_xfer_memory() (or target_xfer_memory_partial()).     This doesn't occur very often.  The most common occurance is when    the last bit of the .text segment and the first bit of the .data    segment fall within the same dcache page with a ro/cacheable memory    region defined for the .text segment and a rw/non-cacheable memory    region defined for the .data segment. */
end_comment

begin_comment
comment|/* This value regulates the number of cache blocks stored.    Smaller values reduce the time spent searching for a cache    line, and reduce memory requirements, but increase the risk    of a line not being in memory */
end_comment

begin_define
define|#
directive|define
name|DCACHE_SIZE
value|64
end_define

begin_comment
comment|/* This value regulates the size of a cache line.  Smaller values    reduce the time taken to read a single byte, but reduce overall    throughput.  */
end_comment

begin_define
define|#
directive|define
name|LINE_SIZE_POWER
value|(5)
end_define

begin_define
define|#
directive|define
name|LINE_SIZE
value|(1<< LINE_SIZE_POWER)
end_define

begin_comment
comment|/* Each cache block holds LINE_SIZE bytes of data    starting at a multiple-of-LINE_SIZE address.  */
end_comment

begin_define
define|#
directive|define
name|LINE_SIZE_MASK
value|((LINE_SIZE - 1))
end_define

begin_define
define|#
directive|define
name|XFORM
parameter_list|(
name|x
parameter_list|)
value|((x)& LINE_SIZE_MASK)
end_define

begin_define
define|#
directive|define
name|MASK
parameter_list|(
name|x
parameter_list|)
value|((x)& ~LINE_SIZE_MASK)
end_define

begin_define
define|#
directive|define
name|ENTRY_BAD
value|0
end_define

begin_comment
comment|/* data at this byte is wrong */
end_comment

begin_define
define|#
directive|define
name|ENTRY_DIRTY
value|1
end_define

begin_comment
comment|/* data at this byte needs to be written back */
end_comment

begin_define
define|#
directive|define
name|ENTRY_OK
value|2
end_define

begin_comment
comment|/* data at this byte is same as in memory */
end_comment

begin_struct
struct|struct
name|dcache_block
block|{
name|struct
name|dcache_block
modifier|*
name|p
decl_stmt|;
comment|/* next in list */
name|CORE_ADDR
name|addr
decl_stmt|;
comment|/* Address for which data is recorded.  */
name|char
name|data
index|[
name|LINE_SIZE
index|]
decl_stmt|;
comment|/* bytes at given address */
name|unsigned
name|char
name|state
index|[
name|LINE_SIZE
index|]
decl_stmt|;
comment|/* what state the data is in */
comment|/* whether anything in state is dirty - used to speed up the         dirty scan. */
name|int
name|anydirty
decl_stmt|;
name|int
name|refs
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* FIXME: dcache_struct used to have a cache_has_stuff field that was    used to record whether the cache had been accessed.  This was used    to invalidate the cache whenever caching was (re-)enabled (if the    cache was disabled and later re-enabled, it could contain stale    data).  This was not needed because the cache is write through and    the code that enables, disables, and deletes memory region all    invalidate the cache.     This is overkill, since it also invalidates cache lines from    unrelated regions.  One way this could be addressed by adding a    new function that takes an address and a length and invalidates    only those cache lines that match. */
end_comment

begin_struct
struct|struct
name|dcache_struct
block|{
comment|/* free list */
name|struct
name|dcache_block
modifier|*
name|free_head
decl_stmt|;
name|struct
name|dcache_block
modifier|*
name|free_tail
decl_stmt|;
comment|/* in use list */
name|struct
name|dcache_block
modifier|*
name|valid_head
decl_stmt|;
name|struct
name|dcache_block
modifier|*
name|valid_tail
decl_stmt|;
comment|/* The cache itself. */
name|struct
name|dcache_block
modifier|*
name|the_cache
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|dcache_poke_byte
parameter_list|(
name|DCACHE
modifier|*
name|dcache
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dcache_peek_byte
parameter_list|(
name|DCACHE
modifier|*
name|dcache
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|dcache_block
modifier|*
name|dcache_hit
parameter_list|(
name|DCACHE
modifier|*
name|dcache
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dcache_write_line
parameter_list|(
name|DCACHE
modifier|*
name|dcache
parameter_list|,
name|struct
name|dcache_block
modifier|*
name|db
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dcache_read_line
parameter_list|(
name|DCACHE
modifier|*
name|dcache
parameter_list|,
name|struct
name|dcache_block
modifier|*
name|db
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|dcache_block
modifier|*
name|dcache_alloc
parameter_list|(
name|DCACHE
modifier|*
name|dcache
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dcache_writeback
parameter_list|(
name|DCACHE
modifier|*
name|dcache
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dcache_info
parameter_list|(
name|char
modifier|*
name|exp
parameter_list|,
name|int
name|tty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|_initialize_dcache
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|dcache_enabled_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|DCACHE
modifier|*
name|last_cache
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used by info dcache */
end_comment

begin_comment
comment|/* Free all the data cache blocks, thus discarding all cached data.  */
end_comment

begin_function
name|void
name|dcache_invalidate
parameter_list|(
name|DCACHE
modifier|*
name|dcache
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|dcache
operator|->
name|valid_head
operator|=
literal|0
expr_stmt|;
name|dcache
operator|->
name|valid_tail
operator|=
literal|0
expr_stmt|;
name|dcache
operator|->
name|free_head
operator|=
literal|0
expr_stmt|;
name|dcache
operator|->
name|free_tail
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DCACHE_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|dcache_block
modifier|*
name|db
init|=
name|dcache
operator|->
name|the_cache
operator|+
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|dcache
operator|->
name|free_head
condition|)
name|dcache
operator|->
name|free_head
operator|=
name|db
expr_stmt|;
else|else
name|dcache
operator|->
name|free_tail
operator|->
name|p
operator|=
name|db
expr_stmt|;
name|dcache
operator|->
name|free_tail
operator|=
name|db
expr_stmt|;
name|db
operator|->
name|p
operator|=
literal|0
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* If addr is present in the dcache, return the address of the block    containing it. */
end_comment

begin_function
specifier|static
name|struct
name|dcache_block
modifier|*
name|dcache_hit
parameter_list|(
name|DCACHE
modifier|*
name|dcache
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|)
block|{
specifier|register
name|struct
name|dcache_block
modifier|*
name|db
decl_stmt|;
comment|/* Search all cache blocks for one that is at this address.  */
name|db
operator|=
name|dcache
operator|->
name|valid_head
expr_stmt|;
while|while
condition|(
name|db
condition|)
block|{
if|if
condition|(
name|MASK
argument_list|(
name|addr
argument_list|)
operator|==
name|db
operator|->
name|addr
condition|)
block|{
name|db
operator|->
name|refs
operator|++
expr_stmt|;
return|return
name|db
return|;
block|}
name|db
operator|=
name|db
operator|->
name|p
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Make sure that anything in this line which needs to    be written is. */
end_comment

begin_function
specifier|static
name|int
name|dcache_write_line
parameter_list|(
name|DCACHE
modifier|*
name|dcache
parameter_list|,
specifier|register
name|struct
name|dcache_block
modifier|*
name|db
parameter_list|)
block|{
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|res
decl_stmt|;
name|int
name|reg_len
decl_stmt|;
name|struct
name|mem_region
modifier|*
name|region
decl_stmt|;
if|if
condition|(
operator|!
name|db
operator|->
name|anydirty
condition|)
return|return
literal|1
return|;
name|len
operator|=
name|LINE_SIZE
expr_stmt|;
name|memaddr
operator|=
name|db
operator|->
name|addr
expr_stmt|;
name|myaddr
operator|=
name|db
operator|->
name|data
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|int
name|s
decl_stmt|;
name|int
name|e
decl_stmt|;
name|int
name|dirty_len
decl_stmt|;
name|region
operator|=
name|lookup_mem_region
argument_list|(
name|memaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|memaddr
operator|+
name|len
operator|<
name|region
operator|->
name|hi
condition|)
name|reg_len
operator|=
name|len
expr_stmt|;
else|else
name|reg_len
operator|=
name|region
operator|->
name|hi
operator|-
name|memaddr
expr_stmt|;
if|if
condition|(
operator|!
name|region
operator|->
name|attrib
operator|.
name|cache
operator|||
name|region
operator|->
name|attrib
operator|.
name|mode
operator|==
name|MEM_RO
condition|)
block|{
name|memaddr
operator|+=
name|reg_len
expr_stmt|;
name|myaddr
operator|+=
name|reg_len
expr_stmt|;
name|len
operator|-=
name|reg_len
expr_stmt|;
continue|continue;
block|}
while|while
condition|(
name|reg_len
operator|>
literal|0
condition|)
block|{
name|s
operator|=
name|XFORM
argument_list|(
name|memaddr
argument_list|)
expr_stmt|;
while|while
condition|(
name|reg_len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|db
operator|->
name|state
index|[
name|s
index|]
operator|==
name|ENTRY_DIRTY
condition|)
break|break;
name|s
operator|++
expr_stmt|;
name|reg_len
operator|--
expr_stmt|;
name|memaddr
operator|++
expr_stmt|;
name|myaddr
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
name|e
operator|=
name|s
expr_stmt|;
while|while
condition|(
name|reg_len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|db
operator|->
name|state
index|[
name|e
index|]
operator|!=
name|ENTRY_DIRTY
condition|)
break|break;
name|e
operator|++
expr_stmt|;
name|reg_len
operator|--
expr_stmt|;
block|}
name|dirty_len
operator|=
name|e
operator|-
name|s
expr_stmt|;
while|while
condition|(
name|dirty_len
operator|>
literal|0
condition|)
block|{
name|res
operator|=
name|do_xfer_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|dirty_len
argument_list|,
literal|1
argument_list|,
operator|&
name|region
operator|->
name|attrib
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
name|memset
argument_list|(
operator|&
name|db
operator|->
name|state
index|[
name|XFORM
argument_list|(
name|memaddr
argument_list|)
index|]
argument_list|,
name|ENTRY_OK
argument_list|,
name|res
argument_list|)
expr_stmt|;
name|memaddr
operator|+=
name|res
expr_stmt|;
name|myaddr
operator|+=
name|res
expr_stmt|;
name|len
operator|-=
name|res
expr_stmt|;
name|dirty_len
operator|-=
name|res
expr_stmt|;
block|}
block|}
block|}
name|db
operator|->
name|anydirty
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Read cache line */
end_comment

begin_function
specifier|static
name|int
name|dcache_read_line
parameter_list|(
name|DCACHE
modifier|*
name|dcache
parameter_list|,
name|struct
name|dcache_block
modifier|*
name|db
parameter_list|)
block|{
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|res
decl_stmt|;
name|int
name|reg_len
decl_stmt|;
name|struct
name|mem_region
modifier|*
name|region
decl_stmt|;
comment|/* If there are any dirty bytes in the line, it must be written      before a new line can be read */
if|if
condition|(
name|db
operator|->
name|anydirty
condition|)
block|{
if|if
condition|(
operator|!
name|dcache_write_line
argument_list|(
name|dcache
argument_list|,
name|db
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
name|len
operator|=
name|LINE_SIZE
expr_stmt|;
name|memaddr
operator|=
name|db
operator|->
name|addr
expr_stmt|;
name|myaddr
operator|=
name|db
operator|->
name|data
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|region
operator|=
name|lookup_mem_region
argument_list|(
name|memaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|memaddr
operator|+
name|len
operator|<
name|region
operator|->
name|hi
condition|)
name|reg_len
operator|=
name|len
expr_stmt|;
else|else
name|reg_len
operator|=
name|region
operator|->
name|hi
operator|-
name|memaddr
expr_stmt|;
if|if
condition|(
operator|!
name|region
operator|->
name|attrib
operator|.
name|cache
operator|||
name|region
operator|->
name|attrib
operator|.
name|mode
operator|==
name|MEM_WO
condition|)
block|{
name|memaddr
operator|+=
name|reg_len
expr_stmt|;
name|myaddr
operator|+=
name|reg_len
expr_stmt|;
name|len
operator|-=
name|reg_len
expr_stmt|;
continue|continue;
block|}
while|while
condition|(
name|reg_len
operator|>
literal|0
condition|)
block|{
name|res
operator|=
name|do_xfer_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|reg_len
argument_list|,
literal|0
argument_list|,
operator|&
name|region
operator|->
name|attrib
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
name|memaddr
operator|+=
name|res
expr_stmt|;
name|myaddr
operator|+=
name|res
expr_stmt|;
name|len
operator|-=
name|res
expr_stmt|;
name|reg_len
operator|-=
name|res
expr_stmt|;
block|}
block|}
name|memset
argument_list|(
name|db
operator|->
name|state
argument_list|,
name|ENTRY_OK
argument_list|,
sizeof|sizeof
argument_list|(
name|db
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|db
operator|->
name|anydirty
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Get a free cache block, put or keep it on the valid list,    and return its address.  */
end_comment

begin_function
specifier|static
name|struct
name|dcache_block
modifier|*
name|dcache_alloc
parameter_list|(
name|DCACHE
modifier|*
name|dcache
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|)
block|{
specifier|register
name|struct
name|dcache_block
modifier|*
name|db
decl_stmt|;
comment|/* Take something from the free list */
name|db
operator|=
name|dcache
operator|->
name|free_head
expr_stmt|;
if|if
condition|(
name|db
condition|)
block|{
name|dcache
operator|->
name|free_head
operator|=
name|db
operator|->
name|p
expr_stmt|;
block|}
else|else
block|{
comment|/* Nothing left on free list, so grab one from the valid list */
name|db
operator|=
name|dcache
operator|->
name|valid_head
expr_stmt|;
if|if
condition|(
operator|!
name|dcache_write_line
argument_list|(
name|dcache
argument_list|,
name|db
argument_list|)
condition|)
return|return
name|NULL
return|;
name|dcache
operator|->
name|valid_head
operator|=
name|db
operator|->
name|p
expr_stmt|;
block|}
name|db
operator|->
name|addr
operator|=
name|MASK
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|db
operator|->
name|refs
operator|=
literal|0
expr_stmt|;
name|db
operator|->
name|anydirty
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|db
operator|->
name|state
argument_list|,
name|ENTRY_BAD
argument_list|,
sizeof|sizeof
argument_list|(
name|db
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
comment|/* append this line to end of valid list */
if|if
condition|(
operator|!
name|dcache
operator|->
name|valid_head
condition|)
name|dcache
operator|->
name|valid_head
operator|=
name|db
expr_stmt|;
else|else
name|dcache
operator|->
name|valid_tail
operator|->
name|p
operator|=
name|db
expr_stmt|;
name|dcache
operator|->
name|valid_tail
operator|=
name|db
expr_stmt|;
name|db
operator|->
name|p
operator|=
literal|0
expr_stmt|;
return|return
name|db
return|;
block|}
end_function

begin_comment
comment|/* Writeback any dirty lines. */
end_comment

begin_function
specifier|static
name|int
name|dcache_writeback
parameter_list|(
name|DCACHE
modifier|*
name|dcache
parameter_list|)
block|{
name|struct
name|dcache_block
modifier|*
name|db
decl_stmt|;
name|db
operator|=
name|dcache
operator|->
name|valid_head
expr_stmt|;
while|while
condition|(
name|db
condition|)
block|{
if|if
condition|(
operator|!
name|dcache_write_line
argument_list|(
name|dcache
argument_list|,
name|db
argument_list|)
condition|)
return|return
literal|0
return|;
name|db
operator|=
name|db
operator|->
name|p
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Using the data cache DCACHE return the contents of the byte at    address ADDR in the remote machine.       Returns 0 on error. */
end_comment

begin_function
specifier|static
name|int
name|dcache_peek_byte
parameter_list|(
name|DCACHE
modifier|*
name|dcache
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|ptr
parameter_list|)
block|{
specifier|register
name|struct
name|dcache_block
modifier|*
name|db
init|=
name|dcache_hit
argument_list|(
name|dcache
argument_list|,
name|addr
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|db
condition|)
block|{
name|db
operator|=
name|dcache_alloc
argument_list|(
name|dcache
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|db
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|db
operator|->
name|state
index|[
name|XFORM
argument_list|(
name|addr
argument_list|)
index|]
operator|==
name|ENTRY_BAD
condition|)
block|{
if|if
condition|(
operator|!
name|dcache_read_line
argument_list|(
name|dcache
argument_list|,
name|db
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
operator|*
name|ptr
operator|=
name|db
operator|->
name|data
index|[
name|XFORM
argument_list|(
name|addr
argument_list|)
index|]
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Write the byte at PTR into ADDR in the data cache.    Return zero on write error.  */
end_comment

begin_function
specifier|static
name|int
name|dcache_poke_byte
parameter_list|(
name|DCACHE
modifier|*
name|dcache
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|ptr
parameter_list|)
block|{
specifier|register
name|struct
name|dcache_block
modifier|*
name|db
init|=
name|dcache_hit
argument_list|(
name|dcache
argument_list|,
name|addr
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|db
condition|)
block|{
name|db
operator|=
name|dcache_alloc
argument_list|(
name|dcache
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|db
condition|)
return|return
literal|0
return|;
block|}
name|db
operator|->
name|data
index|[
name|XFORM
argument_list|(
name|addr
argument_list|)
index|]
operator|=
operator|*
name|ptr
expr_stmt|;
name|db
operator|->
name|state
index|[
name|XFORM
argument_list|(
name|addr
argument_list|)
index|]
operator|=
name|ENTRY_DIRTY
expr_stmt|;
name|db
operator|->
name|anydirty
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Initialize the data cache.  */
end_comment

begin_function
name|DCACHE
modifier|*
name|dcache_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|csize
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|dcache_block
argument_list|)
operator|*
name|DCACHE_SIZE
decl_stmt|;
name|DCACHE
modifier|*
name|dcache
decl_stmt|;
name|dcache
operator|=
operator|(
name|DCACHE
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|dcache
argument_list|)
argument_list|)
expr_stmt|;
name|dcache
operator|->
name|the_cache
operator|=
operator|(
expr|struct
name|dcache_block
operator|*
operator|)
name|xmalloc
argument_list|(
name|csize
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|dcache
operator|->
name|the_cache
argument_list|,
literal|0
argument_list|,
name|csize
argument_list|)
expr_stmt|;
name|dcache_invalidate
argument_list|(
name|dcache
argument_list|)
expr_stmt|;
name|last_cache
operator|=
name|dcache
expr_stmt|;
return|return
name|dcache
return|;
block|}
end_function

begin_comment
comment|/* Free a data cache */
end_comment

begin_function
name|void
name|dcache_free
parameter_list|(
name|DCACHE
modifier|*
name|dcache
parameter_list|)
block|{
if|if
condition|(
name|last_cache
operator|==
name|dcache
condition|)
name|last_cache
operator|=
name|NULL
expr_stmt|;
name|xfree
argument_list|(
name|dcache
operator|->
name|the_cache
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|dcache
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read or write LEN bytes from inferior memory at MEMADDR, transferring    to or from debugger address MYADDR.  Write to inferior if SHOULD_WRITE is    nonzero.      Returns length of data written or read; 0 for error.       This routine is indended to be called by remote_xfer_ functions. */
end_comment

begin_function
name|int
name|dcache_xfer_memory
parameter_list|(
name|DCACHE
modifier|*
name|dcache
parameter_list|,
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|should_write
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
function_decl|(
modifier|*
name|xfunc
function_decl|)
parameter_list|(
name|DCACHE
modifier|*
name|dcache
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|ptr
parameter_list|)
function_decl|;
name|xfunc
operator|=
name|should_write
condition|?
name|dcache_poke_byte
else|:
name|dcache_peek_byte
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|xfunc
argument_list|(
name|dcache
argument_list|,
name|memaddr
operator|+
name|i
argument_list|,
name|myaddr
operator|+
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
comment|/* FIXME: There may be some benefit from moving the cache writeback      to a higher layer, as it could occur after a sequence of smaller      writes have been completed (as when a stack frame is constructed      for an inferior function call).  Note that only moving it up one      level to target_xfer_memory() (also target_xfer_memory_partial())      is not sufficent, since we want to coalesce memory transfers that      are "logically" connected but not actually a single call to one      of the memory transfer functions. */
if|if
condition|(
name|should_write
condition|)
name|dcache_writeback
argument_list|(
name|dcache
argument_list|)
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dcache_info
parameter_list|(
name|char
modifier|*
name|exp
parameter_list|,
name|int
name|tty
parameter_list|)
block|{
name|struct
name|dcache_block
modifier|*
name|p
decl_stmt|;
name|printf_filtered
argument_list|(
literal|"Dcache line width %d, depth %d\n"
argument_list|,
name|LINE_SIZE
argument_list|,
name|DCACHE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_cache
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Cache state:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|last_cache
operator|->
name|valid_head
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|p
control|)
block|{
name|int
name|j
decl_stmt|;
name|printf_filtered
argument_list|(
literal|"Line at %s, referenced %d times\n"
argument_list|,
name|paddr
argument_list|(
name|p
operator|->
name|addr
argument_list|)
argument_list|,
name|p
operator|->
name|refs
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|LINE_SIZE
condition|;
name|j
operator|++
control|)
name|printf_filtered
argument_list|(
literal|"%02x"
argument_list|,
name|p
operator|->
name|data
index|[
name|j
index|]
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|LINE_SIZE
condition|;
name|j
operator|++
control|)
name|printf_filtered
argument_list|(
literal|"%2x"
argument_list|,
name|p
operator|->
name|state
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|_initialize_dcache
parameter_list|(
name|void
parameter_list|)
block|{
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"remotecache"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dcache_enabled_p
argument_list|,
literal|"\ Set cache use for remote targets.\n\ When on, use data caching for remote targets.  For many remote targets\n\ this option can offer better throughput for reading target memory.\n\ Unfortunately, gdb does not currently know anything about volatile\n\ registers and thus data caching will produce incorrect results with\n\ volatile registers are in use.  By default, this option is off."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"dcache"
argument_list|,
name|dcache_info
argument_list|,
literal|"Print information on the dcache performance."
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

