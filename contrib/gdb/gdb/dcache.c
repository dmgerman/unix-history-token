begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Caching code.  Typically used by remote back ends for    caching remote memory.     Copyright 1992, 1993, 1995, 1998 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"dcache.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_comment
comment|/*     The data cache could lead to incorrect results because it doesn't know    about volatile variables, thus making it impossible to debug    functions which use memory mapped I/O devices.     set remotecache 0     In those cases.     In general the dcache speeds up performance, some speed improvement    comes from the actual caching mechanism, but the major gain is in    the reduction of the remote protocol overhead; instead of reading    or writing a large area of memory in 4 byte requests, the cache    bundles up the requests into 32 byte (actually LINE_SIZE) chunks.    Reducing the overhead to an eighth of what it was.  This is very    obvious when displaying a large amount of data,     eg, x/200x 0      caching     |   no    yes     ----------------------------     first time  |   4 sec  2 sec improvement due to chunking     second time |   4 sec  0 sec improvement due to caching     The cache structure is unusual, we keep a number of cache blocks    (DCACHE_SIZE) and each one caches a LINE_SIZEed area of memory.    Within each line we remember the address of the line (always a    multiple of the LINE_SIZE) and a vector of bytes over the range.    There's another vector which contains the state of the bytes.     ENTRY_BAD means that the byte is just plain wrong, and has no    correspondence with anything else (as it would when the cache is    turned on, but nothing has been done to it.     ENTRY_DIRTY means that the byte has some data in it which should be    written out to the remote target one day, but contains correct    data.  ENTRY_OK means that the data is the same in the cache as it    is in remote memory.      The ENTRY_DIRTY state is necessary because GDB likes to write large    lumps of memory in small bits.  If the caching mechanism didn't    maintain the DIRTY information, then something like a two byte    write would mean that the entire cache line would have to be read,    the two bytes modified and then written out again.  The alternative    would be to not read in the cache line in the first place, and just    write the two bytes directly into target memory.  The trouble with    that is that it really nails performance, because of the remote    protocol overhead.  This way, all those little writes are bundled    up into an entire cache line write in one go, without having to    read the cache line in the first place.     */
end_comment

begin_comment
comment|/* This value regulates the number of cache blocks stored.    Smaller values reduce the time spent searching for a cache    line, and reduce memory requirements, but increase the risk    of a line not being in memory */
end_comment

begin_define
define|#
directive|define
name|DCACHE_SIZE
value|64
end_define

begin_comment
comment|/* This value regulates the size of a cache line.  Smaller values    reduce the time taken to read a single byte, but reduce overall    throughput.  */
end_comment

begin_define
define|#
directive|define
name|LINE_SIZE_POWER
value|(5)
end_define

begin_define
define|#
directive|define
name|LINE_SIZE
value|(1<< LINE_SIZE_POWER)
end_define

begin_comment
comment|/* Each cache block holds LINE_SIZE bytes of data    starting at a multiple-of-LINE_SIZE address.  */
end_comment

begin_define
define|#
directive|define
name|LINE_SIZE_MASK
value|((LINE_SIZE - 1))
end_define

begin_define
define|#
directive|define
name|XFORM
parameter_list|(
name|x
parameter_list|)
value|((x)& LINE_SIZE_MASK)
end_define

begin_define
define|#
directive|define
name|MASK
parameter_list|(
name|x
parameter_list|)
value|((x)& ~LINE_SIZE_MASK)
end_define

begin_define
define|#
directive|define
name|ENTRY_BAD
value|0
end_define

begin_comment
comment|/* data at this byte is wrong */
end_comment

begin_define
define|#
directive|define
name|ENTRY_DIRTY
value|1
end_define

begin_comment
comment|/* data at this byte needs to be written back */
end_comment

begin_define
define|#
directive|define
name|ENTRY_OK
value|2
end_define

begin_comment
comment|/* data at this byte is same as in memory */
end_comment

begin_struct
struct|struct
name|dcache_block
block|{
name|struct
name|dcache_block
modifier|*
name|p
decl_stmt|;
comment|/* next in list */
name|CORE_ADDR
name|addr
decl_stmt|;
comment|/* Address for which data is recorded.  */
name|char
name|data
index|[
name|LINE_SIZE
index|]
decl_stmt|;
comment|/* bytes at given address */
name|unsigned
name|char
name|state
index|[
name|LINE_SIZE
index|]
decl_stmt|;
comment|/* what state the data is in */
comment|/* whether anything in state is dirty - used to speed up the       dirty scan. */
name|int
name|anydirty
decl_stmt|;
name|int
name|refs
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|dcache_struct
block|{
comment|/* Function to actually read the target memory. */
name|memxferfunc
name|read_memory
decl_stmt|;
comment|/* Function to actually write the target memory */
name|memxferfunc
name|write_memory
decl_stmt|;
comment|/* free list */
name|struct
name|dcache_block
modifier|*
name|free_head
decl_stmt|;
name|struct
name|dcache_block
modifier|*
name|free_tail
decl_stmt|;
comment|/* in use list */
name|struct
name|dcache_block
modifier|*
name|valid_head
decl_stmt|;
name|struct
name|dcache_block
modifier|*
name|valid_tail
decl_stmt|;
comment|/* The cache itself. */
name|struct
name|dcache_block
modifier|*
name|the_cache
decl_stmt|;
comment|/* potentially, if the cache was enabled, and then turned off, and      then turned on again, the stuff in it could be stale, so this is      used to mark it */
name|int
name|cache_has_stuff
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|dcache_poke_byte
name|PARAMS
argument_list|(
operator|(
name|DCACHE
operator|*
name|dcache
operator|,
name|CORE_ADDR
name|addr
operator|,
name|char
operator|*
name|ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dcache_peek_byte
name|PARAMS
argument_list|(
operator|(
name|DCACHE
operator|*
name|dcache
operator|,
name|CORE_ADDR
name|addr
operator|,
name|char
operator|*
name|ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|dcache_block
modifier|*
name|dcache_hit
name|PARAMS
argument_list|(
operator|(
name|DCACHE
operator|*
name|dcache
operator|,
name|CORE_ADDR
name|addr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dcache_write_line
name|PARAMS
argument_list|(
operator|(
name|DCACHE
operator|*
name|dcache
operator|,
expr|struct
name|dcache_block
operator|*
name|db
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|dcache_block
modifier|*
name|dcache_alloc
name|PARAMS
argument_list|(
operator|(
name|DCACHE
operator|*
name|dcache
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dcache_writeback
name|PARAMS
argument_list|(
operator|(
name|DCACHE
operator|*
name|dcache
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dcache_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|exp
operator|,
name|int
name|tty
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|_initialize_dcache
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|remote_dcache
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|DCACHE
modifier|*
name|last_cache
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used by info dcache */
end_comment

begin_comment
comment|/* Free all the data cache blocks, thus discarding all cached data.  */
end_comment

begin_function
name|void
name|dcache_flush
parameter_list|(
name|dcache
parameter_list|)
name|DCACHE
modifier|*
name|dcache
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|dcache
operator|->
name|valid_head
operator|=
literal|0
expr_stmt|;
name|dcache
operator|->
name|valid_tail
operator|=
literal|0
expr_stmt|;
name|dcache
operator|->
name|free_head
operator|=
literal|0
expr_stmt|;
name|dcache
operator|->
name|free_tail
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DCACHE_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|dcache_block
modifier|*
name|db
init|=
name|dcache
operator|->
name|the_cache
operator|+
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|dcache
operator|->
name|free_head
condition|)
name|dcache
operator|->
name|free_head
operator|=
name|db
expr_stmt|;
else|else
name|dcache
operator|->
name|free_tail
operator|->
name|p
operator|=
name|db
expr_stmt|;
name|dcache
operator|->
name|free_tail
operator|=
name|db
expr_stmt|;
name|db
operator|->
name|p
operator|=
literal|0
expr_stmt|;
block|}
name|dcache
operator|->
name|cache_has_stuff
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* If addr is present in the dcache, return the address of the block    containing it. */
end_comment

begin_function
specifier|static
name|struct
name|dcache_block
modifier|*
name|dcache_hit
parameter_list|(
name|dcache
parameter_list|,
name|addr
parameter_list|)
name|DCACHE
modifier|*
name|dcache
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
specifier|register
name|struct
name|dcache_block
modifier|*
name|db
decl_stmt|;
comment|/* Search all cache blocks for one that is at this address.  */
name|db
operator|=
name|dcache
operator|->
name|valid_head
expr_stmt|;
while|while
condition|(
name|db
condition|)
block|{
if|if
condition|(
name|MASK
argument_list|(
name|addr
argument_list|)
operator|==
name|db
operator|->
name|addr
condition|)
block|{
name|db
operator|->
name|refs
operator|++
expr_stmt|;
return|return
name|db
return|;
block|}
name|db
operator|=
name|db
operator|->
name|p
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Make sure that anything in this line which needs to    be written is. */
end_comment

begin_function
specifier|static
name|int
name|dcache_write_line
parameter_list|(
name|dcache
parameter_list|,
name|db
parameter_list|)
name|DCACHE
modifier|*
name|dcache
decl_stmt|;
specifier|register
name|struct
name|dcache_block
modifier|*
name|db
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|int
name|e
decl_stmt|;
name|s
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|db
operator|->
name|anydirty
condition|)
block|{
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|LINE_SIZE
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
name|db
operator|->
name|state
index|[
name|s
index|]
operator|==
name|ENTRY_DIRTY
condition|)
block|{
name|int
name|len
init|=
literal|0
decl_stmt|;
for|for
control|(
name|e
operator|=
name|s
init|;
name|e
operator|<
name|LINE_SIZE
condition|;
name|e
operator|++
operator|,
name|len
operator|++
control|)
if|if
condition|(
name|db
operator|->
name|state
index|[
name|e
index|]
operator|!=
name|ENTRY_DIRTY
condition|)
break|break;
block|{
comment|/* all bytes from s..s+len-1 need to 		   be written out */
name|int
name|done
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|done
operator|<
name|len
condition|)
block|{
name|int
name|t
init|=
name|dcache
operator|->
name|write_memory
argument_list|(
name|db
operator|->
name|addr
operator|+
name|s
operator|+
name|done
argument_list|,
name|db
operator|->
name|data
operator|+
name|s
operator|+
name|done
argument_list|,
name|len
operator|-
name|done
argument_list|)
decl_stmt|;
if|if
condition|(
name|t
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|done
operator|+=
name|t
expr_stmt|;
block|}
name|memset
argument_list|(
name|db
operator|->
name|state
operator|+
name|s
argument_list|,
name|ENTRY_OK
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|s
operator|=
name|e
expr_stmt|;
block|}
block|}
block|}
name|db
operator|->
name|anydirty
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Get a free cache block, put or keep it on the valid list,    and return its address.  The caller should store into the block    the address and data that it describes, then remque it from the    free list and insert it into the valid list.  This procedure    prevents errors from creeping in if a memory retrieval is    interrupted (which used to put garbage blocks in the valid    list...).  */
end_comment

begin_function
specifier|static
name|struct
name|dcache_block
modifier|*
name|dcache_alloc
parameter_list|(
name|dcache
parameter_list|)
name|DCACHE
modifier|*
name|dcache
decl_stmt|;
block|{
specifier|register
name|struct
name|dcache_block
modifier|*
name|db
decl_stmt|;
if|if
condition|(
name|remote_dcache
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Take something from the free list */
name|db
operator|=
name|dcache
operator|->
name|free_head
expr_stmt|;
if|if
condition|(
name|db
condition|)
block|{
name|dcache
operator|->
name|free_head
operator|=
name|db
operator|->
name|p
expr_stmt|;
block|}
else|else
block|{
comment|/* Nothing left on free list, so grab one from the valid list */
name|db
operator|=
name|dcache
operator|->
name|valid_head
expr_stmt|;
name|dcache
operator|->
name|valid_head
operator|=
name|db
operator|->
name|p
expr_stmt|;
name|dcache_write_line
argument_list|(
name|dcache
argument_list|,
name|db
argument_list|)
expr_stmt|;
block|}
comment|/* append this line to end of valid list */
if|if
condition|(
operator|!
name|dcache
operator|->
name|valid_head
condition|)
name|dcache
operator|->
name|valid_head
operator|=
name|db
expr_stmt|;
else|else
name|dcache
operator|->
name|valid_tail
operator|->
name|p
operator|=
name|db
expr_stmt|;
name|dcache
operator|->
name|valid_tail
operator|=
name|db
expr_stmt|;
name|db
operator|->
name|p
operator|=
literal|0
expr_stmt|;
return|return
name|db
return|;
block|}
end_function

begin_comment
comment|/* Using the data cache DCACHE return the contents of the byte at    address ADDR in the remote machine.       Returns 0 on error. */
end_comment

begin_function
specifier|static
name|int
name|dcache_peek_byte
parameter_list|(
name|dcache
parameter_list|,
name|addr
parameter_list|,
name|ptr
parameter_list|)
name|DCACHE
modifier|*
name|dcache
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
block|{
specifier|register
name|struct
name|dcache_block
modifier|*
name|db
init|=
name|dcache_hit
argument_list|(
name|dcache
argument_list|,
name|addr
argument_list|)
decl_stmt|;
name|int
name|ok
init|=
literal|1
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|db
operator|==
literal|0
operator|||
name|db
operator|->
name|state
index|[
name|XFORM
argument_list|(
name|addr
argument_list|)
index|]
operator|==
name|ENTRY_BAD
condition|)
block|{
if|if
condition|(
name|db
condition|)
block|{
name|dcache_write_line
argument_list|(
name|dcache
argument_list|,
name|db
argument_list|)
expr_stmt|;
block|}
else|else
name|db
operator|=
name|dcache_alloc
argument_list|(
name|dcache
argument_list|)
expr_stmt|;
name|immediate_quit
operator|++
expr_stmt|;
name|db
operator|->
name|addr
operator|=
name|MASK
argument_list|(
name|addr
argument_list|)
expr_stmt|;
while|while
condition|(
name|done
operator|<
name|LINE_SIZE
condition|)
block|{
name|int
name|try
init|=
call|(
modifier|*
name|dcache
operator|->
name|read_memory
call|)
argument_list|(
name|db
operator|->
name|addr
operator|+
name|done
argument_list|,
name|db
operator|->
name|data
operator|+
name|done
argument_list|,
name|LINE_SIZE
operator|-
name|done
argument_list|)
decl_stmt|;
if|if
condition|(
name|try
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|done
operator|+=
name|try
expr_stmt|;
block|}
name|immediate_quit
operator|--
expr_stmt|;
name|memset
argument_list|(
name|db
operator|->
name|state
argument_list|,
name|ENTRY_OK
argument_list|,
sizeof|sizeof
argument_list|(
name|db
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|db
operator|->
name|anydirty
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|ptr
operator|=
name|db
operator|->
name|data
index|[
name|XFORM
argument_list|(
name|addr
argument_list|)
index|]
expr_stmt|;
return|return
name|ok
return|;
block|}
end_function

begin_comment
comment|/* Writeback any dirty lines to the remote. */
end_comment

begin_function
specifier|static
name|int
name|dcache_writeback
parameter_list|(
name|dcache
parameter_list|)
name|DCACHE
modifier|*
name|dcache
decl_stmt|;
block|{
name|struct
name|dcache_block
modifier|*
name|db
decl_stmt|;
name|db
operator|=
name|dcache
operator|->
name|valid_head
expr_stmt|;
while|while
condition|(
name|db
condition|)
block|{
if|if
condition|(
operator|!
name|dcache_write_line
argument_list|(
name|dcache
argument_list|,
name|db
argument_list|)
condition|)
return|return
literal|0
return|;
name|db
operator|=
name|db
operator|->
name|p
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Using the data cache DCACHE return the contents of the word at    address ADDR in the remote machine.  */
end_comment

begin_function
name|int
name|dcache_fetch
parameter_list|(
name|dcache
parameter_list|,
name|addr
parameter_list|)
name|DCACHE
modifier|*
name|dcache
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
name|int
name|res
decl_stmt|;
if|if
condition|(
name|dcache_xfer_memory
argument_list|(
name|dcache
argument_list|,
name|addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|res
argument_list|,
sizeof|sizeof
name|res
argument_list|,
literal|0
argument_list|)
operator|!=
sizeof|sizeof
name|res
condition|)
name|memory_error
argument_list|(
name|EIO
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Write the byte at PTR into ADDR in the data cache.    Return zero on write error.  */
end_comment

begin_function
specifier|static
name|int
name|dcache_poke_byte
parameter_list|(
name|dcache
parameter_list|,
name|addr
parameter_list|,
name|ptr
parameter_list|)
name|DCACHE
modifier|*
name|dcache
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
block|{
specifier|register
name|struct
name|dcache_block
modifier|*
name|db
init|=
name|dcache_hit
argument_list|(
name|dcache
argument_list|,
name|addr
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|db
condition|)
block|{
name|db
operator|=
name|dcache_alloc
argument_list|(
name|dcache
argument_list|)
expr_stmt|;
name|db
operator|->
name|addr
operator|=
name|MASK
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|db
operator|->
name|state
argument_list|,
name|ENTRY_BAD
argument_list|,
sizeof|sizeof
argument_list|(
name|db
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|db
operator|->
name|data
index|[
name|XFORM
argument_list|(
name|addr
argument_list|)
index|]
operator|=
operator|*
name|ptr
expr_stmt|;
name|db
operator|->
name|state
index|[
name|XFORM
argument_list|(
name|addr
argument_list|)
index|]
operator|=
name|ENTRY_DIRTY
expr_stmt|;
name|db
operator|->
name|anydirty
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Write the word at ADDR both in the data cache and in the remote machine.      Return zero on write error.  */
end_comment

begin_function
name|int
name|dcache_poke
parameter_list|(
name|dcache
parameter_list|,
name|addr
parameter_list|,
name|data
parameter_list|)
name|DCACHE
modifier|*
name|dcache
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|data
decl_stmt|;
block|{
if|if
condition|(
name|dcache_xfer_memory
argument_list|(
name|dcache
argument_list|,
name|addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|data
argument_list|,
sizeof|sizeof
name|data
argument_list|,
literal|1
argument_list|)
operator|!=
sizeof|sizeof
name|data
condition|)
return|return
literal|0
return|;
return|return
name|dcache_writeback
argument_list|(
name|dcache
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Initialize the data cache.  */
end_comment

begin_function
name|DCACHE
modifier|*
name|dcache_init
parameter_list|(
name|reading
parameter_list|,
name|writing
parameter_list|)
name|memxferfunc
name|reading
decl_stmt|;
name|memxferfunc
name|writing
decl_stmt|;
block|{
name|int
name|csize
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|dcache_block
argument_list|)
operator|*
name|DCACHE_SIZE
decl_stmt|;
name|DCACHE
modifier|*
name|dcache
decl_stmt|;
name|dcache
operator|=
operator|(
name|DCACHE
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|dcache
argument_list|)
argument_list|)
expr_stmt|;
name|dcache
operator|->
name|read_memory
operator|=
name|reading
expr_stmt|;
name|dcache
operator|->
name|write_memory
operator|=
name|writing
expr_stmt|;
name|dcache
operator|->
name|the_cache
operator|=
operator|(
expr|struct
name|dcache_block
operator|*
operator|)
name|xmalloc
argument_list|(
name|csize
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|dcache
operator|->
name|the_cache
argument_list|,
literal|0
argument_list|,
name|csize
argument_list|)
expr_stmt|;
name|dcache_flush
argument_list|(
name|dcache
argument_list|)
expr_stmt|;
name|last_cache
operator|=
name|dcache
expr_stmt|;
return|return
name|dcache
return|;
block|}
end_function

begin_comment
comment|/* Read or write LEN bytes from inferior memory at MEMADDR, transferring    to or from debugger address MYADDR.  Write to inferior if SHOULD_WRITE is    nonzero.      Returns length of data written or read; 0 for error.       This routine is indended to be called by remote_xfer_ functions. */
end_comment

begin_function
name|int
name|dcache_xfer_memory
parameter_list|(
name|dcache
parameter_list|,
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|should_write
parameter_list|)
name|DCACHE
modifier|*
name|dcache
decl_stmt|;
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|should_write
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|remote_dcache
condition|)
block|{
name|int
argument_list|(
argument|*xfunc
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|DCACHE
operator|*
name|dcache
operator|,
name|CORE_ADDR
name|addr
operator|,
name|char
operator|*
name|ptr
operator|)
argument_list|)
expr_stmt|;
name|xfunc
operator|=
name|should_write
condition|?
name|dcache_poke_byte
else|:
name|dcache_peek_byte
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|xfunc
argument_list|(
name|dcache
argument_list|,
name|memaddr
operator|+
name|i
argument_list|,
name|myaddr
operator|+
name|i
argument_list|)
condition|)
return|return
literal|0
return|;
block|}
name|dcache
operator|->
name|cache_has_stuff
operator|=
literal|1
expr_stmt|;
name|dcache_writeback
argument_list|(
name|dcache
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memxferfunc
name|xfunc
decl_stmt|;
name|xfunc
operator|=
name|should_write
condition|?
name|dcache
operator|->
name|write_memory
else|:
name|dcache
operator|->
name|read_memory
expr_stmt|;
if|if
condition|(
name|dcache
operator|->
name|cache_has_stuff
condition|)
name|dcache_flush
argument_list|(
name|dcache
argument_list|)
expr_stmt|;
name|len
operator|=
name|xfunc
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dcache_info
parameter_list|(
name|exp
parameter_list|,
name|tty
parameter_list|)
name|char
modifier|*
name|exp
decl_stmt|;
name|int
name|tty
decl_stmt|;
block|{
name|struct
name|dcache_block
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|remote_dcache
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Dcache not enabled\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf_filtered
argument_list|(
literal|"Dcache enabled, line width %d, depth %d\n"
argument_list|,
name|LINE_SIZE
argument_list|,
name|DCACHE_SIZE
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Cache state:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|last_cache
operator|->
name|valid_head
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|p
control|)
block|{
name|int
name|j
decl_stmt|;
name|printf_filtered
argument_list|(
literal|"Line at %08xd, referenced %d times\n"
argument_list|,
name|p
operator|->
name|addr
argument_list|,
name|p
operator|->
name|refs
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|LINE_SIZE
condition|;
name|j
operator|++
control|)
name|printf_filtered
argument_list|(
literal|"%02x"
argument_list|,
name|p
operator|->
name|data
index|[
name|j
index|]
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|LINE_SIZE
condition|;
name|j
operator|++
control|)
name|printf_filtered
argument_list|(
literal|" %2x"
argument_list|,
name|p
operator|->
name|state
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|_initialize_dcache
parameter_list|()
block|{
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"remotecache"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|remote_dcache
argument_list|,
literal|"\ Set cache use for remote targets.\n\ When on, use data caching for remote targets.  For many remote targets\n\ this option can offer better throughput for reading target memory.\n\ Unfortunately, gdb does not currently know anything about volatile\n\ registers and thus data caching will produce incorrect results with\n\ volatile registers are in use.  By default, this option is on."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"dcache"
argument_list|,
name|dcache_info
argument_list|,
literal|"Print information on the dcache performance."
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

