begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Remote debugging interface to m32r and mon2000 ROM monitors for GDB,     the GNU debugger.    Copyright 1996 Free Software Foundation, Inc.     Adapted by Michael Snyder of Cygnus Support.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This module defines communication with the Mitsubishi m32r monitor */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"monitor.h"
end_include

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_comment
comment|/* for generic load */
end_comment

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_comment
comment|/* for time_t */
end_comment

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_comment
comment|/* for ALL_OBJFILES etc. */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|report_transfer_performance
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
operator|,
name|time_t
operator|,
name|time_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|_MSC_VER
end_ifndef

begin_comment
comment|/*  * All this stuff just to get my host computer's IP address!  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_comment
comment|/* for hostent */
end_comment

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_comment
comment|/* for struct in_addr */
end_comment

begin_if
if|#
directive|if
literal|1
end_if

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_comment
comment|/* for inet_ntoa */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
modifier|*
name|board_addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* user-settable IP address for M32R-EVA */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|server_addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* user-settable IP address for gdb host */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|download_path
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* user-settable path for SREC files     */
end_comment

begin_comment
comment|/*   * Function: m32r_load_1 (helper function)  */
end_comment

begin_function
specifier|static
name|void
name|m32r_load_section
parameter_list|(
name|abfd
parameter_list|,
name|s
parameter_list|,
name|data_count
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|unsigned
name|int
modifier|*
name|data_count
decl_stmt|;
block|{
if|if
condition|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
condition|)
block|{
name|bfd_size_type
name|section_size
init|=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
decl_stmt|;
name|bfd_vma
name|section_base
init|=
name|bfd_section_lma
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|buffer
decl_stmt|,
name|i
decl_stmt|;
operator|*
name|data_count
operator|+=
name|section_size
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Loading section %s, size 0x%lx lma "
argument_list|,
name|bfd_section_name
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
argument_list|,
name|section_size
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|section_base
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|monitor_printf
argument_list|(
literal|"%x mw\r"
argument_list|,
name|section_base
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|section_size
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|QUIT
expr_stmt|;
name|monitor_expect
argument_list|(
literal|" -> "
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|buffer
argument_list|,
name|i
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|monitor_printf
argument_list|(
literal|"%x\n"
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
name|monitor_expect
argument_list|(
literal|" -> "
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|monitor_printf
argument_list|(
literal|"q\n"
argument_list|)
expr_stmt|;
name|monitor_expect_prompt
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|m32r_load_1
parameter_list|(
name|dummy
parameter_list|)
name|void
modifier|*
name|dummy
decl_stmt|;
block|{
name|int
name|data_count
init|=
literal|0
decl_stmt|;
name|bfd_map_over_sections
argument_list|(
operator|(
name|bfd
operator|*
operator|)
name|dummy
argument_list|,
name|m32r_load_section
argument_list|,
operator|&
name|data_count
argument_list|)
expr_stmt|;
return|return
name|data_count
return|;
block|}
end_function

begin_comment
comment|/*   * Function: m32r_load (an alternate way to load)   */
end_comment

begin_function
specifier|static
name|void
name|m32r_load
parameter_list|(
name|filename
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|extern
name|int
name|inferior_pid
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|data_count
init|=
literal|0
decl_stmt|;
name|time_t
name|start_time
decl_stmt|,
name|end_time
decl_stmt|;
comment|/* for timing of download */
if|if
condition|(
name|filename
operator|==
name|NULL
operator|||
name|filename
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|filename
operator|=
name|get_exec_file
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|abfd
operator|=
name|bfd_openr
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abfd
condition|)
name|error
argument_list|(
literal|"Unable to open file %s\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_check_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"File is not an object file\n"
argument_list|)
expr_stmt|;
name|start_time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|for (s = abfd->sections; s; s = s->next)     if (s->flags& SEC_LOAD)       { 	bfd_size_type section_size = bfd_section_size (abfd, s); 	bfd_vma       section_base = bfd_section_vma  (abfd, s); 	unsigned int  buffer;  	data_count += section_size;  	printf_filtered ("Loading section %s, size 0x%lx vma ", 			 bfd_section_name (abfd, s), section_size); 	print_address_numeric (section_base, 1, gdb_stdout); 	printf_filtered ("\n");  	gdb_flush (gdb_stdout); 	monitor_printf ("%x mw\r" , section_base); 	for (i = 0; i< section_size; i += 4) 	  { 	    monitor_expect (" -> ", NULL, 0); 	    bfd_get_section_contents (abfd, s, (char *)&buffer, i, 4); 	    monitor_printf ("%x\n", buffer); 	  } 	monitor_expect (" -> ", NULL, 0); 	monitor_printf ("q\n"); 	monitor_expect_prompt (NULL, 0);       }
else|#
directive|else
if|if
condition|(
operator|!
operator|(
name|catch_errors
argument_list|(
name|m32r_load_1
argument_list|,
name|abfd
argument_list|,
literal|"Load aborted!\n"
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
operator|)
condition|)
block|{
name|monitor_printf
argument_list|(
literal|"q\n"
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|end_time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Start address 0x%lx\n"
argument_list|,
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|report_transfer_performance
argument_list|(
name|data_count
argument_list|,
name|start_time
argument_list|,
name|end_time
argument_list|)
expr_stmt|;
comment|/* Finally, make the PC point at the start address */
if|if
condition|(
name|exec_bfd
condition|)
name|write_pc
argument_list|(
name|bfd_get_start_address
argument_list|(
name|exec_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
literal|0
expr_stmt|;
comment|/* No process now */
comment|/* This is necessary because many things were based on the PC at the      time that we attached to the monitor, which is no longer valid      now that we have loaded new code (and just changed the PC).      Another way to do this might be to call normal_stop, except that      the stack may not be valid, and things would get horribly      confused... */
name|clear_symtab_users
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|m32r_load_gen
parameter_list|(
name|filename
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|generic_load
argument_list|(
name|filename
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|m32r_open
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|args
operator|,
name|int
name|from_tty
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mon2000_open
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|args
operator|,
name|int
name|from_tty
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This array of registers needs to match the indexes used by GDB. The    whole reason this exists is because the various ROM monitors use    different names than GDB does, and don't support all the registers    either. So, typing "info reg sp" becomes an "A7". */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|m32r_regnames
index|[]
init|=
block|{
literal|"r0"
block|,
literal|"r1"
block|,
literal|"r2"
block|,
literal|"r3"
block|,
literal|"r4"
block|,
literal|"r5"
block|,
literal|"r6"
block|,
literal|"r7"
block|,
literal|"r8"
block|,
literal|"r9"
block|,
literal|"r10"
block|,
literal|"r11"
block|,
literal|"r12"
block|,
literal|"r13"
block|,
literal|"r14"
block|,
literal|"r15"
block|,
literal|"psw"
block|,
literal|"cbr"
block|,
literal|"spi"
block|,
literal|"spu"
block|,
literal|"bpc"
block|,
literal|"pc"
block|,
literal|"accl"
block|,
literal|"acch"
block|,  }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|m32r_supply_register
parameter_list|(
name|regname
parameter_list|,
name|regnamelen
parameter_list|,
name|val
parameter_list|,
name|vallen
parameter_list|)
name|char
modifier|*
name|regname
decl_stmt|;
name|int
name|regnamelen
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|vallen
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|;
name|int
name|num_regs
init|=
sizeof|sizeof
argument_list|(
name|m32r_regnames
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|m32r_regnames
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|num_regs
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|regname
argument_list|,
name|m32r_regnames
index|[
name|regno
index|]
argument_list|,
name|regnamelen
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|regno
operator|>=
name|num_regs
condition|)
return|return;
comment|/* no match */
if|if
condition|(
name|regno
operator|==
name|ACCL_REGNUM
condition|)
block|{
comment|/* special handling for 64-bit acc reg */
name|monitor_supply_register
argument_list|(
name|ACCH_REGNUM
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|=
operator|(
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|val
argument_list|,
literal|':'
argument_list|)
condition|)
comment|/* skip past ':' to get 2nd word */
name|monitor_supply_register
argument_list|(
name|ACCL_REGNUM
argument_list|,
name|val
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|monitor_supply_register
argument_list|(
name|regno
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|PSW_REGNUM
condition|)
block|{
name|unsigned
name|long
name|psw
init|=
name|strtoul
argument_list|(
name|val
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
decl_stmt|;
name|char
modifier|*
name|zero
init|=
literal|"00000000"
decl_stmt|,
modifier|*
name|one
init|=
literal|"00000001"
decl_stmt|;
ifdef|#
directive|ifdef
name|SM_REGNUM
comment|/* Stack mode bit */
name|monitor_supply_register
argument_list|(
name|SM_REGNUM
argument_list|,
operator|(
name|psw
operator|&
literal|0x80
operator|)
condition|?
name|one
else|:
name|zero
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BSM_REGNUM
comment|/* Backup stack mode bit */
name|monitor_supply_register
argument_list|(
name|BSM_REGNUM
argument_list|,
operator|(
name|psw
operator|&
literal|0x8000
operator|)
condition|?
name|one
else|:
name|zero
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IE_REGNUM
comment|/* Interrupt enable bit */
name|monitor_supply_register
argument_list|(
name|IE_REGNUM
argument_list|,
operator|(
name|psw
operator|&
literal|0x40
operator|)
condition|?
name|one
else|:
name|zero
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BIE_REGNUM
comment|/* Backup interrupt enable bit */
name|monitor_supply_register
argument_list|(
name|BIE_REGNUM
argument_list|,
operator|(
name|psw
operator|&
literal|0x4000
operator|)
condition|?
name|one
else|:
name|zero
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|COND_REGNUM
comment|/* Condition bit (carry etc.) */
name|monitor_supply_register
argument_list|(
name|COND_REGNUM
argument_list|,
operator|(
name|psw
operator|&
literal|0x1
operator|)
condition|?
name|one
else|:
name|zero
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CBR_REGNUM
name|monitor_supply_register
argument_list|(
name|CBR_REGNUM
argument_list|,
operator|(
name|psw
operator|&
literal|0x1
operator|)
condition|?
name|one
else|:
name|zero
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BPC_REGNUM
name|monitor_supply_register
argument_list|(
name|BPC_REGNUM
argument_list|,
name|zero
argument_list|)
expr_stmt|;
comment|/* KLUDGE:   (???????) */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BCARRY_REGNUM
name|monitor_supply_register
argument_list|(
name|BCARRY_REGNUM
argument_list|,
name|zero
argument_list|)
expr_stmt|;
comment|/* KLUDGE: (??????) */
endif|#
directive|endif
block|}
if|if
condition|(
name|regno
operator|==
name|SPI_REGNUM
operator|||
name|regno
operator|==
name|SPU_REGNUM
condition|)
block|{
comment|/* special handling for stack pointer (spu or spi) */
name|unsigned
name|long
name|stackmode
init|=
name|read_register
argument_list|(
name|PSW_REGNUM
argument_list|)
operator|&
literal|0x80
decl_stmt|;
if|if
condition|(
name|regno
operator|==
name|SPI_REGNUM
operator|&&
operator|!
name|stackmode
condition|)
comment|/* SP == SPI */
name|monitor_supply_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|SPU_REGNUM
operator|&&
name|stackmode
condition|)
comment|/* SP == SPU */
name|monitor_supply_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* m32r RevC board monitor */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|target_ops
name|m32r_ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|m32r_inits
index|[]
init|=
block|{
literal|"\r"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|monitor_ops
name|m32r_cmds
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|init_m32r_cmds
parameter_list|(
name|void
parameter_list|)
block|{
name|m32r_cmds
operator|.
name|flags
operator|=
name|MO_CLR_BREAK_USES_ADDR
operator||
name|MO_REGISTER_VALUE_FIRST
expr_stmt|;
name|m32r_cmds
operator|.
name|init
operator|=
name|m32r_inits
expr_stmt|;
comment|/* Init strings */
name|m32r_cmds
operator|.
name|cont
operator|=
literal|"go\r"
expr_stmt|;
comment|/* continue command */
name|m32r_cmds
operator|.
name|step
operator|=
literal|"step\r"
expr_stmt|;
comment|/* single step */
name|m32r_cmds
operator|.
name|stop
operator|=
name|NULL
expr_stmt|;
comment|/* interrupt command */
name|m32r_cmds
operator|.
name|set_break
operator|=
literal|"%x +bp\r"
expr_stmt|;
comment|/* set a breakpoint */
name|m32r_cmds
operator|.
name|clr_break
operator|=
literal|"%x -bp\r"
expr_stmt|;
comment|/* clear a breakpoint */
name|m32r_cmds
operator|.
name|clr_all_break
operator|=
literal|"bpoff\r"
expr_stmt|;
comment|/* clear all breakpoints */
name|m32r_cmds
operator|.
name|fill
operator|=
literal|"%x %x %x fill\r"
expr_stmt|;
comment|/* fill (start length val) */
name|m32r_cmds
operator|.
name|setmem
operator|.
name|cmdb
operator|=
literal|"%x 1 %x fill\r"
expr_stmt|;
comment|/* setmem.cmdb (addr, value) */
name|m32r_cmds
operator|.
name|setmem
operator|.
name|cmdw
operator|=
literal|"%x 1 %x fillh\r"
expr_stmt|;
comment|/* setmem.cmdw (addr, value) */
name|m32r_cmds
operator|.
name|setmem
operator|.
name|cmdl
operator|=
literal|"%x 1 %x fillw\r"
expr_stmt|;
comment|/* setmem.cmdl (addr, value) */
name|m32r_cmds
operator|.
name|setmem
operator|.
name|cmdll
operator|=
name|NULL
expr_stmt|;
comment|/* setmem.cmdll (addr, value) */
name|m32r_cmds
operator|.
name|setmem
operator|.
name|resp_delim
operator|=
name|NULL
expr_stmt|;
comment|/* setmem.resp_delim */
name|m32r_cmds
operator|.
name|setmem
operator|.
name|term
operator|=
name|NULL
expr_stmt|;
comment|/* setmem.term */
name|m32r_cmds
operator|.
name|setmem
operator|.
name|term_cmd
operator|=
name|NULL
expr_stmt|;
comment|/* setmem.term_cmd */
name|m32r_cmds
operator|.
name|getmem
operator|.
name|cmdb
operator|=
literal|"%x %x dump\r"
expr_stmt|;
comment|/* getmem.cmdb (addr, len) */
name|m32r_cmds
operator|.
name|getmem
operator|.
name|cmdw
operator|=
name|NULL
expr_stmt|;
comment|/* getmem.cmdw (addr, len) */
name|m32r_cmds
operator|.
name|getmem
operator|.
name|cmdl
operator|=
name|NULL
expr_stmt|;
comment|/* getmem.cmdl (addr, len) */
name|m32r_cmds
operator|.
name|getmem
operator|.
name|cmdll
operator|=
name|NULL
expr_stmt|;
comment|/* getmem.cmdll (addr, len) */
name|m32r_cmds
operator|.
name|getmem
operator|.
name|resp_delim
operator|=
literal|": "
expr_stmt|;
comment|/* getmem.resp_delim */
name|m32r_cmds
operator|.
name|getmem
operator|.
name|term
operator|=
name|NULL
expr_stmt|;
comment|/* getmem.term */
name|m32r_cmds
operator|.
name|getmem
operator|.
name|term_cmd
operator|=
name|NULL
expr_stmt|;
comment|/* getmem.term_cmd */
name|m32r_cmds
operator|.
name|setreg
operator|.
name|cmd
operator|=
literal|"%x to %%%s\r"
expr_stmt|;
comment|/* setreg.cmd (name, value) */
name|m32r_cmds
operator|.
name|setreg
operator|.
name|resp_delim
operator|=
name|NULL
expr_stmt|;
comment|/* setreg.resp_delim */
name|m32r_cmds
operator|.
name|setreg
operator|.
name|term
operator|=
name|NULL
expr_stmt|;
comment|/* setreg.term */
name|m32r_cmds
operator|.
name|setreg
operator|.
name|term_cmd
operator|=
name|NULL
expr_stmt|;
comment|/* setreg.term_cmd */
name|m32r_cmds
operator|.
name|getreg
operator|.
name|cmd
operator|=
name|NULL
expr_stmt|;
comment|/* getreg.cmd (name) */
name|m32r_cmds
operator|.
name|getreg
operator|.
name|resp_delim
operator|=
name|NULL
expr_stmt|;
comment|/* getreg.resp_delim */
name|m32r_cmds
operator|.
name|getreg
operator|.
name|term
operator|=
name|NULL
expr_stmt|;
comment|/* getreg.term */
name|m32r_cmds
operator|.
name|getreg
operator|.
name|term_cmd
operator|=
name|NULL
expr_stmt|;
comment|/* getreg.term_cmd */
name|m32r_cmds
operator|.
name|dump_registers
operator|=
literal|".reg\r"
expr_stmt|;
comment|/* dump_registers */
name|m32r_cmds
operator|.
name|register_pattern
operator|=
literal|"\\(\\w+\\) += \\([0-9a-fA-F]+\\b\\)"
expr_stmt|;
comment|/* register_pattern */
name|m32r_cmds
operator|.
name|supply_register
operator|=
name|m32r_supply_register
expr_stmt|;
comment|/* supply_register */
name|m32r_cmds
operator|.
name|load_routine
operator|=
name|NULL
expr_stmt|;
comment|/* load_routine (defaults to SRECs) */
name|m32r_cmds
operator|.
name|load
operator|=
name|NULL
expr_stmt|;
comment|/* download command */
name|m32r_cmds
operator|.
name|loadresp
operator|=
name|NULL
expr_stmt|;
comment|/* load response */
name|m32r_cmds
operator|.
name|prompt
operator|=
literal|"ok "
expr_stmt|;
comment|/* monitor command prompt */
name|m32r_cmds
operator|.
name|line_term
operator|=
literal|"\r"
expr_stmt|;
comment|/* end-of-line terminator */
name|m32r_cmds
operator|.
name|cmd_end
operator|=
name|NULL
expr_stmt|;
comment|/* optional command terminator */
name|m32r_cmds
operator|.
name|target
operator|=
operator|&
name|m32r_ops
expr_stmt|;
comment|/* target operations */
name|m32r_cmds
operator|.
name|stopbits
operator|=
name|SERIAL_1_STOPBITS
expr_stmt|;
comment|/* number of stop bits */
name|m32r_cmds
operator|.
name|regnames
operator|=
name|m32r_regnames
expr_stmt|;
comment|/* registers names */
name|m32r_cmds
operator|.
name|magic
operator|=
name|MONITOR_OPS_MAGIC
expr_stmt|;
comment|/* magic */
block|}
end_function

begin_comment
comment|/* init_m32r_cmds */
end_comment

begin_function
specifier|static
name|void
name|m32r_open
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|monitor_open
argument_list|(
name|args
argument_list|,
operator|&
name|m32r_cmds
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mon2000 monitor (MSA2000 board) */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|target_ops
name|mon2000_ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|monitor_ops
name|mon2000_cmds
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|init_mon2000_cmds
parameter_list|(
name|void
parameter_list|)
block|{
name|mon2000_cmds
operator|.
name|flags
operator|=
name|MO_CLR_BREAK_USES_ADDR
operator||
name|MO_REGISTER_VALUE_FIRST
expr_stmt|;
name|mon2000_cmds
operator|.
name|init
operator|=
name|m32r_inits
expr_stmt|;
comment|/* Init strings */
name|mon2000_cmds
operator|.
name|cont
operator|=
literal|"go\r"
expr_stmt|;
comment|/* continue command */
name|mon2000_cmds
operator|.
name|step
operator|=
literal|"step\r"
expr_stmt|;
comment|/* single step */
name|mon2000_cmds
operator|.
name|stop
operator|=
name|NULL
expr_stmt|;
comment|/* interrupt command */
name|mon2000_cmds
operator|.
name|set_break
operator|=
literal|"%x +bp\r"
expr_stmt|;
comment|/* set a breakpoint */
name|mon2000_cmds
operator|.
name|clr_break
operator|=
literal|"%x -bp\r"
expr_stmt|;
comment|/* clear a breakpoint */
name|mon2000_cmds
operator|.
name|clr_all_break
operator|=
literal|"bpoff\r"
expr_stmt|;
comment|/* clear all breakpoints */
name|mon2000_cmds
operator|.
name|fill
operator|=
literal|"%x %x %x fill\r"
expr_stmt|;
comment|/* fill (start length val) */
name|mon2000_cmds
operator|.
name|setmem
operator|.
name|cmdb
operator|=
literal|"%x 1 %x fill\r"
expr_stmt|;
comment|/* setmem.cmdb (addr, value) */
name|mon2000_cmds
operator|.
name|setmem
operator|.
name|cmdw
operator|=
literal|"%x 1 %x fillh\r"
expr_stmt|;
comment|/* setmem.cmdw (addr, value) */
name|mon2000_cmds
operator|.
name|setmem
operator|.
name|cmdl
operator|=
literal|"%x 1 %x fillw\r"
expr_stmt|;
comment|/* setmem.cmdl (addr, value) */
name|mon2000_cmds
operator|.
name|setmem
operator|.
name|cmdll
operator|=
name|NULL
expr_stmt|;
comment|/* setmem.cmdll (addr, value) */
name|mon2000_cmds
operator|.
name|setmem
operator|.
name|resp_delim
operator|=
name|NULL
expr_stmt|;
comment|/* setmem.resp_delim */
name|mon2000_cmds
operator|.
name|setmem
operator|.
name|term
operator|=
name|NULL
expr_stmt|;
comment|/* setmem.term */
name|mon2000_cmds
operator|.
name|setmem
operator|.
name|term_cmd
operator|=
name|NULL
expr_stmt|;
comment|/* setmem.term_cmd */
name|mon2000_cmds
operator|.
name|getmem
operator|.
name|cmdb
operator|=
literal|"%x %x dump\r"
expr_stmt|;
comment|/* getmem.cmdb (addr, len) */
name|mon2000_cmds
operator|.
name|getmem
operator|.
name|cmdw
operator|=
name|NULL
expr_stmt|;
comment|/* getmem.cmdw (addr, len) */
name|mon2000_cmds
operator|.
name|getmem
operator|.
name|cmdl
operator|=
name|NULL
expr_stmt|;
comment|/* getmem.cmdl (addr, len) */
name|mon2000_cmds
operator|.
name|getmem
operator|.
name|cmdll
operator|=
name|NULL
expr_stmt|;
comment|/* getmem.cmdll (addr, len) */
name|mon2000_cmds
operator|.
name|getmem
operator|.
name|resp_delim
operator|=
literal|": "
expr_stmt|;
comment|/* getmem.resp_delim */
name|mon2000_cmds
operator|.
name|getmem
operator|.
name|term
operator|=
name|NULL
expr_stmt|;
comment|/* getmem.term */
name|mon2000_cmds
operator|.
name|getmem
operator|.
name|term_cmd
operator|=
name|NULL
expr_stmt|;
comment|/* getmem.term_cmd */
name|mon2000_cmds
operator|.
name|setreg
operator|.
name|cmd
operator|=
literal|"%x to %%%s\r"
expr_stmt|;
comment|/* setreg.cmd (name, value) */
name|mon2000_cmds
operator|.
name|setreg
operator|.
name|resp_delim
operator|=
name|NULL
expr_stmt|;
comment|/* setreg.resp_delim */
name|mon2000_cmds
operator|.
name|setreg
operator|.
name|term
operator|=
name|NULL
expr_stmt|;
comment|/* setreg.term */
name|mon2000_cmds
operator|.
name|setreg
operator|.
name|term_cmd
operator|=
name|NULL
expr_stmt|;
comment|/* setreg.term_cmd */
name|mon2000_cmds
operator|.
name|getreg
operator|.
name|cmd
operator|=
name|NULL
expr_stmt|;
comment|/* getreg.cmd (name) */
name|mon2000_cmds
operator|.
name|getreg
operator|.
name|resp_delim
operator|=
name|NULL
expr_stmt|;
comment|/* getreg.resp_delim */
name|mon2000_cmds
operator|.
name|getreg
operator|.
name|term
operator|=
name|NULL
expr_stmt|;
comment|/* getreg.term */
name|mon2000_cmds
operator|.
name|getreg
operator|.
name|term_cmd
operator|=
name|NULL
expr_stmt|;
comment|/* getreg.term_cmd */
name|mon2000_cmds
operator|.
name|dump_registers
operator|=
literal|".reg\r"
expr_stmt|;
comment|/* dump_registers */
name|mon2000_cmds
operator|.
name|register_pattern
operator|=
literal|"\\(\\w+\\) += \\([0-9a-fA-F]+\\b\\)"
expr_stmt|;
comment|/* register_pattern */
name|mon2000_cmds
operator|.
name|supply_register
operator|=
name|m32r_supply_register
expr_stmt|;
comment|/* supply_register */
name|mon2000_cmds
operator|.
name|load_routine
operator|=
name|NULL
expr_stmt|;
comment|/* load_routine (defaults to SRECs) */
name|mon2000_cmds
operator|.
name|load
operator|=
name|NULL
expr_stmt|;
comment|/* download command */
name|mon2000_cmds
operator|.
name|loadresp
operator|=
name|NULL
expr_stmt|;
comment|/* load response */
name|mon2000_cmds
operator|.
name|prompt
operator|=
literal|"Mon2000>"
expr_stmt|;
comment|/* monitor command prompt */
name|mon2000_cmds
operator|.
name|line_term
operator|=
literal|"\r"
expr_stmt|;
comment|/* end-of-line terminator */
name|mon2000_cmds
operator|.
name|cmd_end
operator|=
name|NULL
expr_stmt|;
comment|/* optional command terminator */
name|mon2000_cmds
operator|.
name|target
operator|=
operator|&
name|mon2000_ops
expr_stmt|;
comment|/* target operations */
name|mon2000_cmds
operator|.
name|stopbits
operator|=
name|SERIAL_1_STOPBITS
expr_stmt|;
comment|/* number of stop bits */
name|mon2000_cmds
operator|.
name|regnames
operator|=
name|m32r_regnames
expr_stmt|;
comment|/* registers names */
name|mon2000_cmds
operator|.
name|magic
operator|=
name|MONITOR_OPS_MAGIC
expr_stmt|;
comment|/* magic */
block|}
end_function

begin_comment
comment|/* init_mon2000_cmds */
end_comment

begin_function
specifier|static
name|void
name|mon2000_open
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|monitor_open
argument_list|(
name|args
argument_list|,
operator|&
name|mon2000_cmds
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_MSC_VER
end_ifndef

begin_comment
comment|/* Function: set_board_address    Tell the BootOne monitor what it's ethernet IP address is. */
end_comment

begin_function
specifier|static
name|void
name|m32r_set_board_address
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|resp_len
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
name|args
operator|&&
operator|*
name|args
condition|)
block|{
name|monitor_printf
argument_list|(
literal|"ulip %s\n"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|resp_len
operator|=
name|monitor_expect_prompt
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* now parse the result for success */
block|}
else|else
name|error
argument_list|(
literal|"Requires argument (IP address for M32R-EVA board)"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function: set_server_address    Tell the BootOne monitor what gdb's ethernet IP address is. */
end_comment

begin_function
specifier|static
name|void
name|m32r_set_server_address
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|resp_len
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
name|args
operator|&&
operator|*
name|args
condition|)
block|{
name|monitor_printf
argument_list|(
literal|"uhip %s\n"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|resp_len
operator|=
name|monitor_expect_prompt
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* now parse the result for success */
block|}
else|else
name|error
argument_list|(
literal|"Requires argument (IP address of GDB's host computer)"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function: set_download_path    Tell the BootOne monitor the default path for downloadable SREC files. */
end_comment

begin_function
specifier|static
name|void
name|m32r_set_download_path
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|resp_len
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
name|args
operator|&&
operator|*
name|args
condition|)
block|{
name|monitor_printf
argument_list|(
literal|"up %s\n"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|resp_len
operator|=
name|monitor_expect_prompt
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* now parse the result for success */
block|}
else|else
name|error
argument_list|(
literal|"Requires argument (default path for downloadable SREC files)"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|m32r_upload_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|time_t
name|start_time
decl_stmt|,
name|end_time
decl_stmt|;
comment|/* for timing of download */
specifier|extern
name|int
name|inferior_pid
decl_stmt|;
name|int
name|resp_len
decl_stmt|,
name|data_count
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hostent
decl_stmt|;
name|struct
name|in_addr
name|inet_addr
decl_stmt|;
comment|/* first check to see if there's an ethernet port! */
name|monitor_printf
argument_list|(
literal|"ust\r"
argument_list|)
expr_stmt|;
name|resp_len
operator|=
name|monitor_expect_prompt
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strchr
argument_list|(
name|buf
argument_list|,
literal|':'
argument_list|)
condition|)
name|error
argument_list|(
literal|"No ethernet connection!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|board_addr
operator|==
literal|0
condition|)
block|{
comment|/* scan second colon in the output from the "ust" command */
name|char
modifier|*
name|myIPaddress
init|=
name|strchr
argument_list|(
name|strchr
argument_list|(
name|buf
argument_list|,
literal|':'
argument_list|)
operator|+
literal|1
argument_list|,
literal|':'
argument_list|)
operator|+
literal|1
decl_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|myIPaddress
argument_list|)
condition|)
name|myIPaddress
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|myIPaddress
argument_list|,
literal|"0.0."
argument_list|,
literal|4
argument_list|)
condition|)
comment|/* empty */
name|error
argument_list|(
literal|"Please use 'set board-address' to set the M32R-EVA board's IP address."
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|myIPaddress
argument_list|,
literal|'('
argument_list|)
condition|)
operator|*
operator|(
name|strchr
argument_list|(
name|myIPaddress
argument_list|,
literal|'('
argument_list|)
operator|)
operator|=
literal|'\0'
expr_stmt|;
comment|/* delete trailing junk */
name|board_addr
operator|=
name|strsave
argument_list|(
name|myIPaddress
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|server_addr
operator|==
literal|0
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|gethostname
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
name|hostent
operator|=
name|gethostbyname
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostent
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
literal|1
name|memcpy
argument_list|(
operator|&
name|inet_addr
operator|.
name|s_addr
argument_list|,
name|hostent
operator|->
name|h_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|inet_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
expr_stmt|;
name|server_addr
operator|=
operator|(
name|char
operator|*
operator|)
name|inet_ntoa
argument_list|(
name|inet_addr
argument_list|)
expr_stmt|;
else|#
directive|else
name|server_addr
operator|=
operator|(
name|char
operator|*
operator|)
name|inet_ntoa
argument_list|(
name|hostent
operator|->
name|h_addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|server_addr
operator|==
literal|0
condition|)
comment|/* failed? */
name|error
argument_list|(
literal|"Need to know gdb host computer's IP address (use 'set server-address')"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|args
operator|==
literal|0
operator|||
name|args
index|[
literal|0
index|]
operator|==
literal|0
condition|)
comment|/* no args: upload the current file */
name|args
operator|=
name|get_exec_file
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|!=
literal|'/'
operator|&&
name|download_path
operator|==
literal|0
condition|)
if|if
condition|(
name|current_directory
condition|)
name|download_path
operator|=
name|strsave
argument_list|(
name|current_directory
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Need to know default download path (use 'set download-path')"
argument_list|)
expr_stmt|;
name|start_time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|monitor_printf
argument_list|(
literal|"uhip %s\r"
argument_list|,
name|server_addr
argument_list|)
expr_stmt|;
name|resp_len
operator|=
name|monitor_expect_prompt
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* parse result? */
name|monitor_printf
argument_list|(
literal|"ulip %s\r"
argument_list|,
name|board_addr
argument_list|)
expr_stmt|;
name|resp_len
operator|=
name|monitor_expect_prompt
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* parse result? */
if|if
condition|(
name|args
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
name|monitor_printf
argument_list|(
literal|"up %s\r"
argument_list|,
name|download_path
argument_list|)
expr_stmt|;
comment|/* use default path */
else|else
name|monitor_printf
argument_list|(
literal|"up\r"
argument_list|)
expr_stmt|;
comment|/* rooted filename/path */
name|resp_len
operator|=
name|monitor_expect_prompt
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* parse result? */
if|if
condition|(
name|strrchr
argument_list|(
name|args
argument_list|,
literal|'.'
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|strrchr
argument_list|(
name|args
argument_list|,
literal|'.'
argument_list|)
argument_list|,
literal|".srec"
argument_list|)
condition|)
name|monitor_printf
argument_list|(
literal|"ul %s\r"
argument_list|,
name|args
argument_list|)
expr_stmt|;
else|else
comment|/* add ".srec" suffix */
name|monitor_printf
argument_list|(
literal|"ul %s.srec\r"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|resp_len
operator|=
name|monitor_expect_prompt
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* parse result? */
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|strstr
argument_list|(
name|buf
argument_list|,
literal|"complete"
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Upload file not found: %s.srec\nCheck IP addresses and download path."
argument_list|,
name|args
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|" -- Ethernet load complete.\n"
argument_list|)
expr_stmt|;
name|end_time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|abfd
operator|=
name|bfd_openr
argument_list|(
name|args
argument_list|,
literal|0
argument_list|)
condition|)
block|{
comment|/* Download is done -- print section statistics */
if|if
condition|(
name|bfd_check_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"File is not an object file\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
condition|)
block|{
name|bfd_size_type
name|section_size
init|=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
decl_stmt|;
name|bfd_vma
name|section_base
init|=
name|bfd_section_lma
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|buffer
decl_stmt|;
name|data_count
operator|+=
name|section_size
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Loading section %s, size 0x%lx lma "
argument_list|,
name|bfd_section_name
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
argument_list|,
name|section_size
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|section_base
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
comment|/* Finally, make the PC point at the start address */
name|write_pc
argument_list|(
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
name|report_transfer_performance
argument_list|(
name|data_count
argument_list|,
name|start_time
argument_list|,
name|end_time
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Start address 0x%lx\n"
argument_list|,
name|bfd_get_start_address
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|inferior_pid
operator|=
literal|0
expr_stmt|;
comment|/* No process now */
comment|/* This is necessary because many things were based on the PC at the      time that we attached to the monitor, which is no longer valid      now that we have loaded new code (and just changed the PC).      Another way to do this might be to call normal_stop, except that      the stack may not be valid, and things would get horribly      confused... */
name|clear_symtab_users
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! _MSC_VER */
end_comment

begin_function
name|void
name|_initialize_m32r_rom
parameter_list|()
block|{
comment|/* Initialize m32r RevC monitor target */
name|init_m32r_cmds
argument_list|()
expr_stmt|;
name|init_monitor_ops
argument_list|(
operator|&
name|m32r_ops
argument_list|)
expr_stmt|;
name|m32r_ops
operator|.
name|to_shortname
operator|=
literal|"m32r"
expr_stmt|;
name|m32r_ops
operator|.
name|to_longname
operator|=
literal|"m32r monitor"
expr_stmt|;
name|m32r_ops
operator|.
name|to_load
operator|=
name|m32r_load_gen
expr_stmt|;
comment|/* monitor lacks a download command */
name|m32r_ops
operator|.
name|to_doc
operator|=
literal|"Debug via the m32r monitor.\n\ Specify the serial device it is connected to (e.g. /dev/ttya)."
expr_stmt|;
name|m32r_ops
operator|.
name|to_open
operator|=
name|m32r_open
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|m32r_ops
argument_list|)
expr_stmt|;
comment|/* Initialize mon2000 monitor target */
name|init_mon2000_cmds
argument_list|()
expr_stmt|;
name|init_monitor_ops
argument_list|(
operator|&
name|mon2000_ops
argument_list|)
expr_stmt|;
name|mon2000_ops
operator|.
name|to_shortname
operator|=
literal|"mon2000"
expr_stmt|;
name|mon2000_ops
operator|.
name|to_longname
operator|=
literal|"Mon2000 monitor"
expr_stmt|;
name|mon2000_ops
operator|.
name|to_load
operator|=
name|m32r_load_gen
expr_stmt|;
comment|/* monitor lacks a download command */
name|mon2000_ops
operator|.
name|to_doc
operator|=
literal|"Debug via the Mon2000 monitor.\n\ Specify the serial device it is connected to (e.g. /dev/ttya)."
expr_stmt|;
name|mon2000_ops
operator|.
name|to_open
operator|=
name|mon2000_open
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|mon2000_ops
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|_MSC_VER
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"download-path"
argument_list|,
name|class_obscure
argument_list|,
name|var_string
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|download_path
argument_list|,
literal|"Set the default path for downloadable SREC files."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"board-address"
argument_list|,
name|class_obscure
argument_list|,
name|var_string
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|board_addr
argument_list|,
literal|"Set IP address for M32R-EVA target board."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"server-address"
argument_list|,
name|class_obscure
argument_list|,
name|var_string
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|server_addr
argument_list|,
literal|"Set IP address for download server (GDB's host computer)."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"upload"
argument_list|,
name|class_obscure
argument_list|,
name|m32r_upload_command
argument_list|,
literal|"Upload the srec file via the monitor's Ethernet upload capability."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"tload"
argument_list|,
name|class_obscure
argument_list|,
name|m32r_load
argument_list|,
literal|"test upload command."
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

