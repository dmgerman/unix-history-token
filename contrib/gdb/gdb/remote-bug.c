begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Remote debugging interface for Motorola's MVME187BUG monitor, an embedded    monitor for the m88k.     Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,    2002 Free Software Foundation, Inc.     Contributed by Cygnus Support.  Written by K. Richard Pixley.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"terminal.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_include
include|#
directive|include
file|"remote-utils.h"
end_include

begin_comment
comment|/* External data declarations */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|stop_soon_quietly
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for wait_for_inferior */
end_comment

begin_comment
comment|/* Forward data declarations */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|bug_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declaration */
end_comment

begin_comment
comment|/* Forward function declarations */
end_comment

begin_function_decl
specifier|static
name|int
name|bug_clear_breakpoints
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bug_read_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|unsigned
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bug_write_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|unsigned
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* This variable is somewhat arbitrary.  It's here so that it can be    set from within a running gdb.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|srec_max_retries
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Each S-record download to the target consists of an S0 header    record, some number of S3 data records, and one S7 termination    record.  I call this download a "frame".  Srec_frame says how many    bytes will be represented in each frame.  */
end_comment

begin_define
define|#
directive|define
name|SREC_SIZE
value|160
end_define

begin_decl_stmt
specifier|static
name|int
name|srec_frame
init|=
name|SREC_SIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This variable determines how many bytes will be represented in each    S3 s-record.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|srec_bytes
init|=
literal|40
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* At one point it appeared to me as though the bug monitor could not    really be expected to receive two sequential characters at 9600    baud reliably.  Echo-pacing is an attempt to force data across the    line even in this condition.  Specifically, in echo-pace mode, each    character is sent one at a time and we look for the echo before    sending the next.  This is excruciatingly slow.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|srec_echo_pace
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How long to wait after an srec for a possible error message.    Similar to the above, I tried sleeping after sending each S3 record    in hopes that I might actually see error messages from the bug    monitor.  This might actually work if we were to use sleep    intervals smaller than 1 second.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|srec_sleep
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Every srec_noise records, flub the checksum.  This is a debugging    feature.  Set the variable to something other than 1 in order to    inject *deliberate* checksum errors.  One might do this if one    wanted to test error handling and recovery.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|srec_noise
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Called when SIGALRM signal sent due to alarm() timeout.  */
end_comment

begin_comment
comment|/* Number of SIGTRAPs we need to simulate.  That is, the next    NEED_ARTIFICIAL_TRAP calls to bug_wait should just return    SIGTRAP without actually waiting for anything.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|need_artificial_trap
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Download a file specified in 'args', to the bug.  */
end_comment

begin_function
specifier|static
name|void
name|bug_load
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|fromtty
parameter_list|)
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|char
name|buffer
index|[
literal|1024
index|]
decl_stmt|;
name|sr_check_open
argument_list|()
expr_stmt|;
name|inferior_ptid
operator|=
name|null_ptid
expr_stmt|;
name|abfd
operator|=
name|bfd_openr
argument_list|(
name|args
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abfd
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Unable to open file %s\n"
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bfd_check_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"File is not an object file\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|s
operator|=
name|abfd
operator|->
name|sections
expr_stmt|;
while|while
condition|(
name|s
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
name|srec_frame
operator|=
name|SREC_SIZE
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
condition|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|buffer
init|=
name|xmalloc
argument_list|(
name|srec_frame
argument_list|)
decl_stmt|;
name|printf_filtered
argument_list|(
literal|"%s\t: 0x%4lx .. 0x%4lx  "
argument_list|,
name|s
operator|->
name|name
argument_list|,
name|s
operator|->
name|vma
argument_list|,
name|s
operator|->
name|vma
operator|+
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|_raw_size
condition|;
name|i
operator|+=
name|srec_frame
control|)
block|{
if|if
condition|(
name|srec_frame
operator|>
name|s
operator|->
name|_raw_size
operator|-
name|i
condition|)
name|srec_frame
operator|=
name|s
operator|->
name|_raw_size
operator|-
name|i
expr_stmt|;
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|buffer
argument_list|,
name|i
argument_list|,
name|srec_frame
argument_list|)
expr_stmt|;
name|bug_write_memory
argument_list|(
name|s
operator|->
name|vma
operator|+
name|i
argument_list|,
name|buffer
argument_list|,
name|srec_frame
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|s
operator|->
name|next
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"rs ip %lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|abfd
operator|->
name|start_address
argument_list|)
expr_stmt|;
name|sr_write_cr
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|gr_expect_prompt
argument_list|()
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char * get_word (char **p) {   char *s = *p;   char *word;   char *copy;   size_t len;    while (isspace (*s))     s++;    word = s;    len = 0;    while (*s&& !isspace (*s))     {       s++;       len++;      }   copy = xmalloc (len + 1);   memcpy (copy, word, len);   copy[len] = 0;   *p = s;   return copy; }
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|gr_settings
name|bug_settings
init|=
block|{
literal|"Bug>"
block|,
comment|/* prompt */
operator|&
name|bug_ops
block|,
comment|/* ops */
name|bug_clear_breakpoints
block|,
comment|/* clear_all_breakpoints */
name|gr_generic_checkin
block|,
comment|/* checkin */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cpu_check_strings
index|[]
init|=
block|{
literal|"="
block|,
literal|"Invalid Register"
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|bug_open
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
name|args
operator|=
literal|""
expr_stmt|;
name|gr_open
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|,
operator|&
name|bug_settings
argument_list|)
expr_stmt|;
comment|/* decide *now* whether we are on an 88100 or an 88110 */
name|sr_write_cr
argument_list|(
literal|"rs cr06"
argument_list|)
expr_stmt|;
name|sr_expect
argument_list|(
literal|"rs cr06"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|gr_multi_scan
argument_list|(
name|cpu_check_strings
argument_list|,
literal|0
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* this is an m88100 */
name|target_is_m88110
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* this is an m88110 */
name|target_is_m88110
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"failed internal consistency check"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Tell the remote machine to resume.  */
end_comment

begin_function
name|void
name|bug_resume
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|step
parameter_list|,
name|enum
name|target_signal
name|sig
parameter_list|)
block|{
if|if
condition|(
name|step
condition|)
block|{
name|sr_write_cr
argument_list|(
literal|"t"
argument_list|)
expr_stmt|;
comment|/* Force the next bug_wait to return a trap.  Not doing anything          about I/O from the target means that the user has to type          "continue" to see any.  FIXME, this should be fixed.  */
name|need_artificial_trap
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|sr_write_cr
argument_list|(
literal|"g"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Wait until the remote machine stops, then return,    storing status in STATUS just as `wait' would.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|wait_strings
index|[]
init|=
block|{
literal|"At Breakpoint"
block|,
literal|"Exception: Data Access Fault (Local Bus Timeout)"
block|,
literal|"\r8??\?-Bug>"
block|,
comment|/* The '\?' avoids creating a trigraph */
literal|"\r197-Bug>"
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|ptid_t
name|bug_wait
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
name|status
parameter_list|)
block|{
name|int
name|old_timeout
init|=
name|sr_get_timeout
argument_list|()
decl_stmt|;
name|int
name|old_immediate_quit
init|=
name|immediate_quit
decl_stmt|;
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|integer
operator|=
literal|0
expr_stmt|;
comment|/* read off leftovers from resume so that the rest can be passed      back out as stdout.  */
if|if
condition|(
name|need_artificial_trap
operator|==
literal|0
condition|)
block|{
name|sr_expect
argument_list|(
literal|"Effective address: "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sr_get_hex_word
argument_list|()
expr_stmt|;
name|sr_expect
argument_list|(
literal|"\r\n"
argument_list|)
expr_stmt|;
block|}
name|sr_set_timeout
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Don't time out -- user program is running. */
name|immediate_quit
operator|=
literal|1
expr_stmt|;
comment|/* Helps ability to QUIT */
switch|switch
condition|(
name|gr_multi_scan
argument_list|(
name|wait_strings
argument_list|,
name|need_artificial_trap
operator|==
literal|0
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* breakpoint case */
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
comment|/* user output from the target can be discarded here. (?) */
name|gr_expect_prompt
argument_list|()
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* bus error */
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_BUS
expr_stmt|;
comment|/* user output from the target can be discarded here. (?) */
name|gr_expect_prompt
argument_list|()
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* normal case */
case|case
literal|3
case|:
if|if
condition|(
name|need_artificial_trap
operator|!=
literal|0
condition|)
block|{
comment|/* stepping */
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
name|need_artificial_trap
operator|--
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* exit case */
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|integer
operator|=
literal|0
expr_stmt|;
break|break;
block|}
case|case
operator|-
literal|1
case|:
comment|/* trouble */
default|default:
name|fprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Trouble reading target during wait\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|sr_set_timeout
argument_list|(
name|old_timeout
argument_list|)
expr_stmt|;
name|immediate_quit
operator|=
name|old_immediate_quit
expr_stmt|;
return|return
name|inferior_ptid
return|;
block|}
end_function

begin_comment
comment|/* Return the name of register number REGNO    in the form input and output by bug.     Returns a pointer to a static buffer containing the answer.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_reg_name
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|rn
index|[]
init|=
block|{
literal|"r00"
block|,
literal|"r01"
block|,
literal|"r02"
block|,
literal|"r03"
block|,
literal|"r04"
block|,
literal|"r05"
block|,
literal|"r06"
block|,
literal|"r07"
block|,
literal|"r08"
block|,
literal|"r09"
block|,
literal|"r10"
block|,
literal|"r11"
block|,
literal|"r12"
block|,
literal|"r13"
block|,
literal|"r14"
block|,
literal|"r15"
block|,
literal|"r16"
block|,
literal|"r17"
block|,
literal|"r18"
block|,
literal|"r19"
block|,
literal|"r20"
block|,
literal|"r21"
block|,
literal|"r22"
block|,
literal|"r23"
block|,
literal|"r24"
block|,
literal|"r25"
block|,
literal|"r26"
block|,
literal|"r27"
block|,
literal|"r28"
block|,
literal|"r29"
block|,
literal|"r30"
block|,
literal|"r31"
block|,
comment|/* these get confusing because we omit a few and switch some ordering around. */
literal|"cr01"
block|,
comment|/* 32 = psr */
literal|"fcr62"
block|,
comment|/* 33 = fpsr */
literal|"fcr63"
block|,
comment|/* 34 = fpcr */
literal|"ip"
block|,
comment|/* this is something of a cheat. */
comment|/* 35 = sxip */
literal|"cr05"
block|,
comment|/* 36 = snip */
literal|"cr06"
block|,
comment|/* 37 = sfip */
literal|"x00"
block|,
literal|"x01"
block|,
literal|"x02"
block|,
literal|"x03"
block|,
literal|"x04"
block|,
literal|"x05"
block|,
literal|"x06"
block|,
literal|"x07"
block|,
literal|"x08"
block|,
literal|"x09"
block|,
literal|"x10"
block|,
literal|"x11"
block|,
literal|"x12"
block|,
literal|"x13"
block|,
literal|"x14"
block|,
literal|"x15"
block|,
literal|"x16"
block|,
literal|"x17"
block|,
literal|"x18"
block|,
literal|"x19"
block|,
literal|"x20"
block|,
literal|"x21"
block|,
literal|"x22"
block|,
literal|"x23"
block|,
literal|"x24"
block|,
literal|"x25"
block|,
literal|"x26"
block|,
literal|"x27"
block|,
literal|"x28"
block|,
literal|"x29"
block|,
literal|"x30"
block|,
literal|"x31"
block|,   }
decl_stmt|;
return|return
name|rn
index|[
name|regno
index|]
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* not currently used */
end_comment

begin_comment
comment|/* Read from remote while the input matches STRING.  Return zero on    success, -1 on failure.  */
end_comment

begin_endif
unit|static int bug_scan (char *s) {   int c;    while (*s)     {       c = sr_readchar ();       if (c != *s++) 	{ 	  fflush (stdout); 	  printf ("\nNext character is '%c' - %d and s is \"%s\".\n", c, c, --s); 	  return (-1); 	}     }    return (0); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* never */
end_comment

begin_function
specifier|static
name|int
name|bug_srec_write_cr
parameter_list|(
name|char
modifier|*
name|s
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|s
decl_stmt|;
if|if
condition|(
name|srec_echo_pace
condition|)
for|for
control|(
name|p
operator|=
name|s
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
name|sr_get_debug
argument_list|()
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"%c"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
do|do
name|serial_write
argument_list|(
name|sr_get_desc
argument_list|()
argument_list|,
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
name|sr_pollchar
argument_list|()
operator|!=
operator|*
name|p
condition|)
do|;
block|}
else|else
block|{
name|sr_write_cr
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/*       return(bug_scan (s) || bug_scan ("\n")); */
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Store register REGNO, or all if REGNO == -1. */
end_comment

begin_function
specifier|static
name|void
name|bug_fetch_register
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|sr_check_open
argument_list|()
expr_stmt|;
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
condition|;
operator|++
name|i
control|)
name|bug_fetch_register
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|target_is_m88110
operator|&&
name|regno
operator|==
name|SFIP_REGNUM
condition|)
block|{
comment|/* m88110 has no sfip. */
name|long
name|l
init|=
literal|0
decl_stmt|;
name|supply_register
argument_list|(
name|regno
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|l
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regno
operator|<
name|XFP_REGNUM
condition|)
block|{
name|char
name|buffer
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|sr_write
argument_list|(
literal|"rs "
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|sr_write_cr
argument_list|(
name|get_reg_name
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|sr_expect
argument_list|(
literal|"="
argument_list|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|buffer
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|,
name|sr_get_hex_word
argument_list|()
argument_list|)
expr_stmt|;
name|gr_expect_prompt
argument_list|()
expr_stmt|;
name|supply_register
argument_list|(
name|regno
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Float register so we need to parse a strange data format. */
name|long
name|p
decl_stmt|;
name|unsigned
name|char
name|fpreg_buf
index|[
literal|10
index|]
decl_stmt|;
name|sr_write
argument_list|(
literal|"rs "
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|sr_write
argument_list|(
name|get_reg_name
argument_list|(
name|regno
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|get_reg_name
argument_list|(
name|regno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sr_write_cr
argument_list|(
literal|";d"
argument_list|)
expr_stmt|;
name|sr_expect
argument_list|(
literal|"rs"
argument_list|)
expr_stmt|;
name|sr_expect
argument_list|(
name|get_reg_name
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|sr_expect
argument_list|(
literal|";d"
argument_list|)
expr_stmt|;
name|sr_expect
argument_list|(
literal|"="
argument_list|)
expr_stmt|;
comment|/* sign */
name|p
operator|=
name|sr_get_hex_digit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fpreg_buf
index|[
literal|0
index|]
operator|=
name|p
operator|<<
literal|7
expr_stmt|;
comment|/* exponent */
name|sr_expect
argument_list|(
literal|"_"
argument_list|)
expr_stmt|;
name|p
operator|=
name|sr_get_hex_digit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fpreg_buf
index|[
literal|0
index|]
operator|+=
operator|(
name|p
operator|<<
literal|4
operator|)
expr_stmt|;
name|fpreg_buf
index|[
literal|0
index|]
operator|+=
name|sr_get_hex_digit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fpreg_buf
index|[
literal|1
index|]
operator|=
name|sr_get_hex_digit
argument_list|(
literal|1
argument_list|)
operator|<<
literal|4
expr_stmt|;
comment|/* fraction */
name|sr_expect
argument_list|(
literal|"_"
argument_list|)
expr_stmt|;
name|fpreg_buf
index|[
literal|1
index|]
operator|+=
name|sr_get_hex_digit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fpreg_buf
index|[
literal|2
index|]
operator|=
operator|(
name|sr_get_hex_digit
argument_list|(
literal|1
argument_list|)
operator|<<
literal|4
operator|)
operator|+
name|sr_get_hex_digit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fpreg_buf
index|[
literal|3
index|]
operator|=
operator|(
name|sr_get_hex_digit
argument_list|(
literal|1
argument_list|)
operator|<<
literal|4
operator|)
operator|+
name|sr_get_hex_digit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fpreg_buf
index|[
literal|4
index|]
operator|=
operator|(
name|sr_get_hex_digit
argument_list|(
literal|1
argument_list|)
operator|<<
literal|4
operator|)
operator|+
name|sr_get_hex_digit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fpreg_buf
index|[
literal|5
index|]
operator|=
operator|(
name|sr_get_hex_digit
argument_list|(
literal|1
argument_list|)
operator|<<
literal|4
operator|)
operator|+
name|sr_get_hex_digit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fpreg_buf
index|[
literal|6
index|]
operator|=
operator|(
name|sr_get_hex_digit
argument_list|(
literal|1
argument_list|)
operator|<<
literal|4
operator|)
operator|+
name|sr_get_hex_digit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fpreg_buf
index|[
literal|7
index|]
operator|=
operator|(
name|sr_get_hex_digit
argument_list|(
literal|1
argument_list|)
operator|<<
literal|4
operator|)
operator|+
name|sr_get_hex_digit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fpreg_buf
index|[
literal|8
index|]
operator|=
literal|0
expr_stmt|;
name|fpreg_buf
index|[
literal|9
index|]
operator|=
literal|0
expr_stmt|;
name|gr_expect_prompt
argument_list|()
expr_stmt|;
name|supply_register
argument_list|(
name|regno
argument_list|,
name|fpreg_buf
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* Store register REGNO, or all if REGNO == -1. */
end_comment

begin_function
specifier|static
name|void
name|bug_store_register
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|char
name|buffer
index|[
literal|1024
index|]
decl_stmt|;
name|sr_check_open
argument_list|()
expr_stmt|;
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
condition|;
operator|++
name|i
control|)
name|bug_store_register
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|regname
decl_stmt|;
name|regname
operator|=
name|get_reg_name
argument_list|(
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_is_m88110
operator|&&
name|regno
operator|==
name|SFIP_REGNUM
condition|)
return|return;
elseif|else
if|if
condition|(
name|regno
operator|<
name|XFP_REGNUM
condition|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"rs %s %08lx"
argument_list|,
name|regname
argument_list|,
operator|(
name|long
operator|)
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|unsigned
name|char
modifier|*
name|fpreg_buf
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"rs %s %1x_%02x%1x_%1x%02x%02x%02x%02x%02x%02x;d"
argument_list|,
name|regname
argument_list|,
comment|/* sign */
operator|(
name|fpreg_buf
index|[
literal|0
index|]
operator|>>
literal|7
operator|)
operator|&
literal|0xf
argument_list|,
comment|/* exponent */
name|fpreg_buf
index|[
literal|0
index|]
operator|&
literal|0x7f
argument_list|,
operator|(
name|fpreg_buf
index|[
literal|1
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xf
argument_list|,
comment|/* fraction */
name|fpreg_buf
index|[
literal|1
index|]
operator|&
literal|0xf
argument_list|,
name|fpreg_buf
index|[
literal|2
index|]
argument_list|,
name|fpreg_buf
index|[
literal|3
index|]
argument_list|,
name|fpreg_buf
index|[
literal|4
index|]
argument_list|,
name|fpreg_buf
index|[
literal|5
index|]
argument_list|,
name|fpreg_buf
index|[
literal|6
index|]
argument_list|,
name|fpreg_buf
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
block|}
name|sr_write_cr
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|gr_expect_prompt
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* Transfer LEN bytes between GDB address MYADDR and target address    MEMADDR.  If WRITE is non-zero, transfer them to the target,    otherwise transfer them from the target.  TARGET is unused.     Returns the number of bytes transferred. */
end_comment

begin_function
name|int
name|bug_xfer_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|write
parameter_list|,
name|struct
name|mem_attrib
modifier|*
name|attrib
parameter_list|,
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|write
condition|)
name|res
operator|=
name|bug_write_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|bug_read_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|start_load
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|command
decl_stmt|;
name|command
operator|=
operator|(
name|srec_echo_pace
condition|?
literal|"lo 0 ;x"
else|:
literal|"lo 0"
operator|)
expr_stmt|;
name|sr_write_cr
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|sr_expect
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|sr_expect
argument_list|(
literal|"\r\n"
argument_list|)
expr_stmt|;
name|bug_srec_write_cr
argument_list|(
literal|"S0030000FC"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* This is an extremely vulnerable and fragile function.  I've made    considerable attempts to make this deterministic, but I've    certainly forgotten something.  The trouble is that S-records are    only a partial file format, not a protocol.  Worse, apparently the    m88k bug monitor does not run in real time while receiving    S-records.  Hence, we must pay excruciating attention to when and    where error messages are returned, and what has actually been sent.     Each call represents a chunk of memory to be sent to the target.    We break that chunk into an S0 header record, some number of S3    data records each containing srec_bytes, and an S7 termination    record.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|srecord_strings
index|[]
init|=
block|{
literal|"S-RECORD"
block|,
literal|"-Bug>"
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|bug_write_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|unsigned
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|done
decl_stmt|;
name|int
name|checksum
decl_stmt|;
name|int
name|x
decl_stmt|;
name|int
name|retries
decl_stmt|;
name|char
modifier|*
name|buffer
init|=
name|alloca
argument_list|(
operator|(
name|srec_bytes
operator|+
literal|8
operator|)
operator|<<
literal|1
argument_list|)
decl_stmt|;
name|retries
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|done
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|retries
operator|>
name|srec_max_retries
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|retries
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|sr_get_debug
argument_list|()
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"\n<retrying...>\n"
argument_list|)
expr_stmt|;
comment|/* This gr_expect_prompt call is extremely important.  Without 	     it, we will tend to resend our packet so fast that it 	     will arrive before the bug monitor is ready to receive 	     it.  This would lead to a very ugly resend loop.  */
name|gr_expect_prompt
argument_list|()
expr_stmt|;
block|}
name|start_load
argument_list|()
expr_stmt|;
while|while
condition|(
name|done
operator|<
name|len
condition|)
block|{
name|int
name|thisgo
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|buffer
decl_stmt|;
name|CORE_ADDR
name|address
decl_stmt|;
name|checksum
operator|=
literal|0
expr_stmt|;
name|thisgo
operator|=
name|len
operator|-
name|done
expr_stmt|;
if|if
condition|(
name|thisgo
operator|>
name|srec_bytes
condition|)
name|thisgo
operator|=
name|srec_bytes
expr_stmt|;
name|address
operator|=
name|memaddr
operator|+
name|done
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"S3%02X%08lX"
argument_list|,
name|thisgo
operator|+
literal|4
operator|+
literal|1
argument_list|,
operator|(
name|long
operator|)
name|address
argument_list|)
expr_stmt|;
name|buf
operator|+=
literal|12
expr_stmt|;
name|checksum
operator|+=
operator|(
name|thisgo
operator|+
literal|4
operator|+
literal|1
operator|+
operator|(
name|address
operator|&
literal|0xff
operator|)
operator|+
operator|(
operator|(
name|address
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
operator|+
operator|(
operator|(
name|address
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
operator|+
operator|(
operator|(
name|address
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|thisgo
condition|;
name|idx
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%02X"
argument_list|,
name|myaddr
index|[
name|idx
operator|+
name|done
index|]
argument_list|)
expr_stmt|;
name|checksum
operator|+=
name|myaddr
index|[
name|idx
operator|+
name|done
index|]
expr_stmt|;
name|buf
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|srec_noise
operator|>
literal|0
condition|)
block|{
comment|/* FIXME-NOW: insert a deliberate error every now and then. 	         This is intended for testing/debugging the error handling 	         stuff.  */
specifier|static
name|int
name|counter
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|++
name|counter
operator|>
name|srec_noise
condition|)
block|{
name|counter
operator|=
literal|0
expr_stmt|;
operator|++
name|checksum
expr_stmt|;
block|}
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%02X"
argument_list|,
operator|~
name|checksum
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|bug_srec_write_cr
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|srec_sleep
operator|!=
literal|0
condition|)
name|sleep
argument_list|(
name|srec_sleep
argument_list|)
expr_stmt|;
comment|/* This pollchar is probably redundant to the gr_multi_scan 	     below.  Trouble is, we can't be sure when or where an 	     error message will appear.  Apparently, when running at 	     full speed from a typical sun4, error messages tend to 	     appear to arrive only *after* the s7 record.   */
if|if
condition|(
operator|(
name|x
operator|=
name|sr_pollchar
argument_list|()
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|sr_get_debug
argument_list|()
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"\n<retrying...>\n"
argument_list|)
expr_stmt|;
operator|++
name|retries
expr_stmt|;
comment|/* flush any remaining input and verify that we are back 	         at the prompt level. */
name|gr_expect_prompt
argument_list|()
expr_stmt|;
comment|/* start all over again. */
name|start_load
argument_list|()
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|done
operator|+=
name|thisgo
expr_stmt|;
block|}
name|bug_srec_write_cr
argument_list|(
literal|"S7060000000000F9"
argument_list|)
expr_stmt|;
operator|++
name|retries
expr_stmt|;
comment|/* Having finished the load, we need to figure out whether we          had any errors.  */
block|}
do|while
condition|(
name|gr_multi_scan
argument_list|(
name|srecord_strings
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
do|;
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Copy LEN bytes of data from debugger memory at MYADDR    to inferior's memory at MEMADDR.  Returns errno value.    * sb/sh instructions don't work on unaligned addresses, when TU=1.  */
end_comment

begin_comment
comment|/* Read LEN bytes from inferior memory at MEMADDR.  Put the result    at debugger address MYADDR.  Returns errno value.  */
end_comment

begin_function
specifier|static
name|int
name|bug_read_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|unsigned
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|char
name|request
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|type
decl_stmt|;
name|char
name|size
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
name|unsigned
name|int
name|inaddr
decl_stmt|;
name|unsigned
name|int
name|checksum
decl_stmt|;
name|sprintf
argument_list|(
name|request
argument_list|,
literal|"du 0 %lx:&%d"
argument_list|,
operator|(
name|long
operator|)
name|memaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sr_write_cr
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|p
operator|=
name|buffer
operator|=
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
comment|/* scan up through the header */
name|sr_expect
argument_list|(
literal|"S0030000FC"
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|buffer
operator|+
name|len
condition|)
block|{
comment|/* scan off any white space. */
while|while
condition|(
name|sr_readchar
argument_list|()
operator|!=
literal|'S'
condition|)
empty_stmt|;
empty_stmt|;
comment|/* what kind of s-rec? */
name|type
operator|=
name|sr_readchar
argument_list|()
expr_stmt|;
comment|/* scan record size */
name|sr_get_hex_byte
argument_list|(
operator|&
name|size
argument_list|)
expr_stmt|;
name|checksum
operator|=
name|size
expr_stmt|;
operator|--
name|size
expr_stmt|;
name|inaddr
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
goto|goto
name|done
goto|;
case|case
literal|'3'
case|:
name|sr_get_hex_byte
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|inaddr
operator|=
operator|(
name|inaddr
operator|<<
literal|8
operator|)
operator|+
name|c
expr_stmt|;
name|checksum
operator|+=
name|c
expr_stmt|;
operator|--
name|size
expr_stmt|;
comment|/* intentional fall through */
case|case
literal|'2'
case|:
name|sr_get_hex_byte
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|inaddr
operator|=
operator|(
name|inaddr
operator|<<
literal|8
operator|)
operator|+
name|c
expr_stmt|;
name|checksum
operator|+=
name|c
expr_stmt|;
operator|--
name|size
expr_stmt|;
comment|/* intentional fall through */
case|case
literal|'1'
case|:
name|sr_get_hex_byte
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|inaddr
operator|=
operator|(
name|inaddr
operator|<<
literal|8
operator|)
operator|+
name|c
expr_stmt|;
name|checksum
operator|+=
name|c
expr_stmt|;
operator|--
name|size
expr_stmt|;
name|sr_get_hex_byte
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|inaddr
operator|=
operator|(
name|inaddr
operator|<<
literal|8
operator|)
operator|+
name|c
expr_stmt|;
name|checksum
operator|+=
name|c
expr_stmt|;
operator|--
name|size
expr_stmt|;
break|break;
default|default:
comment|/* bonk */
name|error
argument_list|(
literal|"reading s-records."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inaddr
operator|<
name|memaddr
operator|||
operator|(
name|memaddr
operator|+
name|len
operator|)
operator|<
operator|(
name|inaddr
operator|+
name|size
operator|)
condition|)
name|error
argument_list|(
literal|"srec out of memory range."
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|buffer
operator|+
name|inaddr
operator|-
name|memaddr
condition|)
name|error
argument_list|(
literal|"srec out of sequence."
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|size
condition|;
operator|--
name|size
operator|,
operator|++
name|p
control|)
block|{
name|sr_get_hex_byte
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|checksum
operator|+=
operator|*
name|p
expr_stmt|;
block|}
name|sr_get_hex_byte
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
operator|(
operator|~
name|checksum
operator|&
literal|0xff
operator|)
condition|)
name|error
argument_list|(
literal|"bad s-rec checksum"
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|gr_expect_prompt
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|buffer
operator|+
name|len
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|memcpy
argument_list|(
name|myaddr
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MAX_BREAKS
value|16
end_define

begin_decl_stmt
specifier|static
name|int
name|num_brkpts
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Insert a breakpoint at ADDR.  SAVE is normally the address of the    pattern buffer where the instruction that the breakpoint overwrites    is saved.  It is unused here since the bug is responsible for    saving/restoring the original instruction. */
end_comment

begin_function
specifier|static
name|int
name|bug_insert_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|save
parameter_list|)
block|{
name|sr_check_open
argument_list|()
expr_stmt|;
if|if
condition|(
name|num_brkpts
operator|<
name|MAX_BREAKS
condition|)
block|{
name|char
name|buffer
index|[
literal|100
index|]
decl_stmt|;
name|num_brkpts
operator|++
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"br %lx"
argument_list|,
operator|(
name|long
operator|)
name|addr
argument_list|)
expr_stmt|;
name|sr_write_cr
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|gr_expect_prompt
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Too many break points, break point not installed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Remove a breakpoint at ADDR.  SAVE is normally the previously    saved pattern, but is unused here since the bug is responsible    for saving/restoring instructions. */
end_comment

begin_function
specifier|static
name|int
name|bug_remove_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|save
parameter_list|)
block|{
if|if
condition|(
name|num_brkpts
operator|>
literal|0
condition|)
block|{
name|char
name|buffer
index|[
literal|100
index|]
decl_stmt|;
name|num_brkpts
operator|--
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"nobr %lx"
argument_list|,
operator|(
name|long
operator|)
name|addr
argument_list|)
expr_stmt|;
name|sr_write_cr
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|gr_expect_prompt
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Clear the bugs notion of what the break points are */
end_comment

begin_function
specifier|static
name|int
name|bug_clear_breakpoints
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|sr_is_open
argument_list|()
condition|)
block|{
name|sr_write_cr
argument_list|(
literal|"nobr"
argument_list|)
expr_stmt|;
name|sr_expect
argument_list|(
literal|"nobr"
argument_list|)
expr_stmt|;
name|gr_expect_prompt
argument_list|()
expr_stmt|;
block|}
name|num_brkpts
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|target_ops
name|bug_ops
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|init_bug_ops
parameter_list|(
name|void
parameter_list|)
block|{
name|bug_ops
operator|.
name|to_shortname
operator|=
literal|"bug"
expr_stmt|;
literal|"Remote BUG monitor"
operator|,
name|bug_ops
operator|.
name|to_longname
operator|=
literal|"Use the mvme187 board running the BUG monitor connected by a serial line."
expr_stmt|;
name|bug_ops
operator|.
name|to_doc
operator|=
literal|" "
expr_stmt|;
name|bug_ops
operator|.
name|to_open
operator|=
name|bug_open
expr_stmt|;
name|bug_ops
operator|.
name|to_close
operator|=
name|gr_close
expr_stmt|;
name|bug_ops
operator|.
name|to_attach
operator|=
literal|0
expr_stmt|;
name|bug_ops
operator|.
name|to_post_attach
operator|=
name|NULL
expr_stmt|;
name|bug_ops
operator|.
name|to_require_attach
operator|=
name|NULL
expr_stmt|;
name|bug_ops
operator|.
name|to_detach
operator|=
name|gr_detach
expr_stmt|;
name|bug_ops
operator|.
name|to_require_detach
operator|=
name|NULL
expr_stmt|;
name|bug_ops
operator|.
name|to_resume
operator|=
name|bug_resume
expr_stmt|;
name|bug_ops
operator|.
name|to_wait
operator|=
name|bug_wait
expr_stmt|;
name|bug_ops
operator|.
name|to_post_wait
operator|=
name|NULL
expr_stmt|;
name|bug_ops
operator|.
name|to_fetch_registers
operator|=
name|bug_fetch_register
expr_stmt|;
name|bug_ops
operator|.
name|to_store_registers
operator|=
name|bug_store_register
expr_stmt|;
name|bug_ops
operator|.
name|to_prepare_to_store
operator|=
name|gr_prepare_to_store
expr_stmt|;
name|bug_ops
operator|.
name|to_xfer_memory
operator|=
name|bug_xfer_memory
expr_stmt|;
name|bug_ops
operator|.
name|to_files_info
operator|=
name|gr_files_info
expr_stmt|;
name|bug_ops
operator|.
name|to_insert_breakpoint
operator|=
name|bug_insert_breakpoint
expr_stmt|;
name|bug_ops
operator|.
name|to_remove_breakpoint
operator|=
name|bug_remove_breakpoint
expr_stmt|;
name|bug_ops
operator|.
name|to_terminal_init
operator|=
literal|0
expr_stmt|;
name|bug_ops
operator|.
name|to_terminal_inferior
operator|=
literal|0
expr_stmt|;
name|bug_ops
operator|.
name|to_terminal_ours_for_output
operator|=
literal|0
expr_stmt|;
name|bug_ops
operator|.
name|to_terminal_ours
operator|=
literal|0
expr_stmt|;
name|bug_ops
operator|.
name|to_terminal_info
operator|=
literal|0
expr_stmt|;
name|bug_ops
operator|.
name|to_kill
operator|=
name|gr_kill
expr_stmt|;
name|bug_ops
operator|.
name|to_load
operator|=
name|bug_load
expr_stmt|;
name|bug_ops
operator|.
name|to_lookup_symbol
operator|=
literal|0
expr_stmt|;
name|bug_ops
operator|.
name|to_create_inferior
operator|=
name|gr_create_inferior
expr_stmt|;
name|bug_ops
operator|.
name|to_post_startup_inferior
operator|=
name|NULL
expr_stmt|;
name|bug_ops
operator|.
name|to_acknowledge_created_inferior
operator|=
name|NULL
expr_stmt|;
name|bug_ops
operator|.
name|to_clone_and_follow_inferior
operator|=
name|NULL
expr_stmt|;
name|bug_ops
operator|.
name|to_post_follow_inferior_by_clone
operator|=
name|NULL
expr_stmt|;
name|bug_ops
operator|.
name|to_insert_fork_catchpoint
operator|=
name|NULL
expr_stmt|;
name|bug_ops
operator|.
name|to_remove_fork_catchpoint
operator|=
name|NULL
expr_stmt|;
name|bug_ops
operator|.
name|to_insert_vfork_catchpoint
operator|=
name|NULL
expr_stmt|;
name|bug_ops
operator|.
name|to_remove_vfork_catchpoint
operator|=
name|NULL
expr_stmt|;
name|bug_ops
operator|.
name|to_has_forked
operator|=
name|NULL
expr_stmt|;
name|bug_ops
operator|.
name|to_has_vforked
operator|=
name|NULL
expr_stmt|;
name|bug_ops
operator|.
name|to_can_follow_vfork_prior_to_exec
operator|=
name|NULL
expr_stmt|;
name|bug_ops
operator|.
name|to_post_follow_vfork
operator|=
name|NULL
expr_stmt|;
name|bug_ops
operator|.
name|to_insert_exec_catchpoint
operator|=
name|NULL
expr_stmt|;
name|bug_ops
operator|.
name|to_remove_exec_catchpoint
operator|=
name|NULL
expr_stmt|;
name|bug_ops
operator|.
name|to_has_execd
operator|=
name|NULL
expr_stmt|;
name|bug_ops
operator|.
name|to_reported_exec_events_per_exec_call
operator|=
name|NULL
expr_stmt|;
name|bug_ops
operator|.
name|to_has_exited
operator|=
name|NULL
expr_stmt|;
name|bug_ops
operator|.
name|to_mourn_inferior
operator|=
name|gr_mourn
expr_stmt|;
name|bug_ops
operator|.
name|to_can_run
operator|=
literal|0
expr_stmt|;
name|bug_ops
operator|.
name|to_notice_signals
operator|=
literal|0
expr_stmt|;
name|bug_ops
operator|.
name|to_thread_alive
operator|=
literal|0
expr_stmt|;
name|bug_ops
operator|.
name|to_stop
operator|=
literal|0
expr_stmt|;
name|bug_ops
operator|.
name|to_pid_to_exec_file
operator|=
name|NULL
expr_stmt|;
name|bug_ops
operator|.
name|to_stratum
operator|=
name|process_stratum
expr_stmt|;
name|bug_ops
operator|.
name|DONT_USE
operator|=
literal|0
expr_stmt|;
name|bug_ops
operator|.
name|to_has_all_memory
operator|=
literal|1
expr_stmt|;
name|bug_ops
operator|.
name|to_has_memory
operator|=
literal|1
expr_stmt|;
name|bug_ops
operator|.
name|to_has_stack
operator|=
literal|1
expr_stmt|;
name|bug_ops
operator|.
name|to_has_registers
operator|=
literal|0
expr_stmt|;
name|bug_ops
operator|.
name|to_has_execution
operator|=
literal|0
expr_stmt|;
name|bug_ops
operator|.
name|to_sections
operator|=
literal|0
expr_stmt|;
name|bug_ops
operator|.
name|to_sections_end
operator|=
literal|0
expr_stmt|;
name|bug_ops
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
comment|/* Always the last thing */
block|}
end_function

begin_comment
comment|/* init_bug_ops */
end_comment

begin_function
name|void
name|_initialize_remote_bug
parameter_list|(
name|void
parameter_list|)
block|{
name|init_bug_ops
argument_list|()
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|bug_ops
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"srec-bytes"
argument_list|,
name|class_support
argument_list|,
name|var_uinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|srec_bytes
argument_list|,
literal|"\ Set the number of bytes represented in each S-record.\n\ This affects the communication protocol with the remote target."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"srec-max-retries"
argument_list|,
name|class_support
argument_list|,
name|var_uinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|srec_max_retries
argument_list|,
literal|"\ Set the number of retries for shipping S-records.\n\ This affects the communication protocol with the remote target."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This needs to set SREC_SIZE, not srec_frame which gets changed at the      end of a download.  But do we need the option at all?  */
block|add_show_from_set     (add_set_cmd ("srec-frame", class_support, var_uinteger, 		  (char *)&srec_frame, 		  "\ Set the number of bytes in an S-record frame.\n\ This affects the communication protocol with the remote target.",&setlist),&showlist);
endif|#
directive|endif
comment|/* 0 */
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"srec-noise"
argument_list|,
name|class_support
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|srec_noise
argument_list|,
literal|"\ Set number of S-record to send before deliberately flubbing a checksum.\n\ Zero means flub none at all.  This affects the communication protocol\n\ with the remote target."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"srec-sleep"
argument_list|,
name|class_support
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|srec_sleep
argument_list|,
literal|"\ Set number of seconds to sleep after an S-record for a possible error message to arrive.\n\ This affects the communication protocol with the remote target."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"srec-echo-pace"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|srec_echo_pace
argument_list|,
literal|"\ Set echo-verification.\n\ When on, use verification by echo when downloading S-records.  This is\n\ much slower, but generally more reliable."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

