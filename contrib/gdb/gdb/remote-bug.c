begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Remote debugging interface for Motorola's MVME187BUG monitor, an embedded    monitor for the m88k.     Copyright 1992, 1993 Free Software Foundation, Inc.    Contributed by Cygnus Support.  Written by K. Richard Pixley.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"terminal.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"remote-utils.h"
end_include

begin_function_decl
specifier|extern
name|int
name|sleep
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* External data declarations */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|stop_soon_quietly
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for wait_for_inferior */
end_comment

begin_comment
comment|/* Forward data declarations */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|bug_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declaration */
end_comment

begin_comment
comment|/* Forward function declarations */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bug_clear_breakpoints
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bug_read_memory
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
name|memaddr
operator|,
name|unsigned
name|char
operator|*
name|myaddr
operator|,
name|int
name|len
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bug_write_memory
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
name|memaddr
operator|,
name|unsigned
name|char
operator|*
name|myaddr
operator|,
name|int
name|len
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This variable is somewhat arbitrary.  It's here so that it can be    set from within a running gdb.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|srec_max_retries
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Each S-record download to the target consists of an S0 header    record, some number of S3 data records, and one S7 termination    record.  I call this download a "frame".  Srec_frame says how many    bytes will be represented in each frame.  */
end_comment

begin_define
define|#
directive|define
name|SREC_SIZE
value|160
end_define

begin_decl_stmt
specifier|static
name|int
name|srec_frame
init|=
name|SREC_SIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This variable determines how many bytes will be represented in each    S3 s-record.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|srec_bytes
init|=
literal|40
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* At one point it appeared to me as though the bug monitor could not    really be expected to receive two sequential characters at 9600    baud reliably.  Echo-pacing is an attempt to force data across the    line even in this condition.  Specifically, in echo-pace mode, each    character is sent one at a time and we look for the echo before    sending the next.  This is excruciatingly slow.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|srec_echo_pace
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How long to wait after an srec for a possible error message.    Similar to the above, I tried sleeping after sending each S3 record    in hopes that I might actually see error messages from the bug    monitor.  This might actually work if we were to use sleep    intervals smaller than 1 second.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|srec_sleep
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Every srec_noise records, flub the checksum.  This is a debugging    feature.  Set the variable to something other than 1 in order to    inject *deliberate* checksum errors.  One might do this if one    wanted to test error handling and recovery.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|srec_noise
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Called when SIGALRM signal sent due to alarm() timeout.  */
end_comment

begin_comment
comment|/* Number of SIGTRAPs we need to simulate.  That is, the next    NEED_ARTIFICIAL_TRAP calls to bug_wait should just return    SIGTRAP without actually waiting for anything.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|need_artificial_trap
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Download a file specified in 'args', to the bug.  */
end_comment

begin_function
specifier|static
name|void
name|bug_load
parameter_list|(
name|args
parameter_list|,
name|fromtty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|fromtty
decl_stmt|;
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|char
name|buffer
index|[
literal|1024
index|]
decl_stmt|;
name|sr_check_open
argument_list|()
expr_stmt|;
name|dcache_flush
argument_list|(
name|gr_get_dcache
argument_list|()
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
literal|0
expr_stmt|;
name|abfd
operator|=
name|bfd_openr
argument_list|(
name|args
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abfd
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Unable to open file %s\n"
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bfd_check_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"File is not an object file\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|s
operator|=
name|abfd
operator|->
name|sections
expr_stmt|;
while|while
condition|(
name|s
operator|!=
operator|(
name|asection
operator|*
operator|)
name|NULL
condition|)
block|{
name|srec_frame
operator|=
name|SREC_SIZE
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
condition|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|buffer
init|=
name|xmalloc
argument_list|(
name|srec_frame
argument_list|)
decl_stmt|;
name|printf_filtered
argument_list|(
literal|"%s\t: 0x%4x .. 0x%4x  "
argument_list|,
name|s
operator|->
name|name
argument_list|,
name|s
operator|->
name|vma
argument_list|,
name|s
operator|->
name|vma
operator|+
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|_raw_size
condition|;
name|i
operator|+=
name|srec_frame
control|)
block|{
if|if
condition|(
name|srec_frame
operator|>
name|s
operator|->
name|_raw_size
operator|-
name|i
condition|)
name|srec_frame
operator|=
name|s
operator|->
name|_raw_size
operator|-
name|i
expr_stmt|;
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|buffer
argument_list|,
name|i
argument_list|,
name|srec_frame
argument_list|)
expr_stmt|;
name|bug_write_memory
argument_list|(
name|s
operator|->
name|vma
operator|+
name|i
argument_list|,
name|buffer
argument_list|,
name|srec_frame
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|s
operator|->
name|next
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"rs ip %lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|abfd
operator|->
name|start_address
argument_list|)
expr_stmt|;
name|sr_write_cr
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|gr_expect_prompt
argument_list|()
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char * get_word (p)      char **p; {   char *s = *p;   char *word;   char *copy;   size_t len;    while (isspace (*s))     s++;    word = s;    len = 0;    while (*s&& !isspace (*s))     {       s++;       len++;      }   copy = xmalloc (len + 1);   memcpy (copy, word, len);   copy[len] = 0;   *p = s;   return copy; }
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|gr_settings
name|bug_settings
init|=
block|{
name|NULL
block|,
comment|/* dcache */
literal|"Bug>"
block|,
comment|/* prompt */
operator|&
name|bug_ops
block|,
comment|/* ops */
name|bug_clear_breakpoints
block|,
comment|/* clear_all_breakpoints */
name|bug_read_memory
block|,
comment|/* readfunc */
name|bug_write_memory
block|,
comment|/* writefunc */
name|gr_generic_checkin
block|,
comment|/* checkin */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cpu_check_strings
index|[]
init|=
block|{
literal|"="
block|,
literal|"Invalid Register"
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|bug_open
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
name|args
operator|=
literal|""
expr_stmt|;
name|gr_open
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|,
operator|&
name|bug_settings
argument_list|)
expr_stmt|;
comment|/* decide *now* whether we are on an 88100 or an 88110 */
name|sr_write_cr
argument_list|(
literal|"rs cr06"
argument_list|)
expr_stmt|;
name|sr_expect
argument_list|(
literal|"rs cr06"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|gr_multi_scan
argument_list|(
name|cpu_check_strings
argument_list|,
literal|0
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* this is an m88100 */
name|target_is_m88110
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* this is an m88110 */
name|target_is_m88110
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Tell the remote machine to resume.  */
end_comment

begin_function
name|void
name|bug_resume
parameter_list|(
name|pid
parameter_list|,
name|step
parameter_list|,
name|sig
parameter_list|)
name|int
name|pid
decl_stmt|,
name|step
decl_stmt|;
name|enum
name|target_signal
name|sig
decl_stmt|;
block|{
name|dcache_flush
argument_list|(
name|gr_get_dcache
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|step
condition|)
block|{
name|sr_write_cr
argument_list|(
literal|"t"
argument_list|)
expr_stmt|;
comment|/* Force the next bug_wait to return a trap.  Not doing anything        about I/O from the target means that the user has to type        "continue" to see any.  FIXME, this should be fixed.  */
name|need_artificial_trap
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|sr_write_cr
argument_list|(
literal|"g"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Wait until the remote machine stops, then return,    storing status in STATUS just as `wait' would.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|wait_strings
index|[]
init|=
block|{
literal|"At Breakpoint"
block|,
literal|"Exception: Data Access Fault (Local Bus Timeout)"
block|,
literal|"\r8???-Bug>"
block|,
literal|"\r197-Bug>"
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|bug_wait
parameter_list|(
name|pid
parameter_list|,
name|status
parameter_list|)
name|int
name|pid
decl_stmt|;
name|struct
name|target_waitstatus
modifier|*
name|status
decl_stmt|;
block|{
name|int
name|old_timeout
init|=
name|sr_get_timeout
argument_list|()
decl_stmt|;
name|int
name|old_immediate_quit
init|=
name|immediate_quit
decl_stmt|;
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|integer
operator|=
literal|0
expr_stmt|;
comment|/* read off leftovers from resume so that the rest can be passed      back out as stdout.  */
if|if
condition|(
name|need_artificial_trap
operator|==
literal|0
condition|)
block|{
name|sr_expect
argument_list|(
literal|"Effective address: "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sr_get_hex_word
argument_list|()
expr_stmt|;
name|sr_expect
argument_list|(
literal|"\r\n"
argument_list|)
expr_stmt|;
block|}
name|sr_set_timeout
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Don't time out -- user program is running. */
name|immediate_quit
operator|=
literal|1
expr_stmt|;
comment|/* Helps ability to QUIT */
switch|switch
condition|(
name|gr_multi_scan
argument_list|(
name|wait_strings
argument_list|,
name|need_artificial_trap
operator|==
literal|0
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* breakpoint case */
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
comment|/* user output from the target can be discarded here. (?) */
name|gr_expect_prompt
argument_list|()
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* bus error */
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_BUS
expr_stmt|;
comment|/* user output from the target can be discarded here. (?) */
name|gr_expect_prompt
argument_list|()
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* normal case */
case|case
literal|3
case|:
if|if
condition|(
name|need_artificial_trap
operator|!=
literal|0
condition|)
block|{
comment|/* stepping */
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
name|need_artificial_trap
operator|--
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* exit case */
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|integer
operator|=
literal|0
expr_stmt|;
break|break;
block|}
case|case
operator|-
literal|1
case|:
comment|/* trouble */
default|default:
name|fprintf_filtered
argument_list|(
name|stderr
argument_list|,
literal|"Trouble reading target during wait\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|sr_set_timeout
argument_list|(
name|old_timeout
argument_list|)
expr_stmt|;
name|immediate_quit
operator|=
name|old_immediate_quit
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the name of register number REGNO    in the form input and output by bug.     Returns a pointer to a static buffer containing the answer.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_reg_name
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|rn
index|[]
init|=
block|{
literal|"r00"
block|,
literal|"r01"
block|,
literal|"r02"
block|,
literal|"r03"
block|,
literal|"r04"
block|,
literal|"r05"
block|,
literal|"r06"
block|,
literal|"r07"
block|,
literal|"r08"
block|,
literal|"r09"
block|,
literal|"r10"
block|,
literal|"r11"
block|,
literal|"r12"
block|,
literal|"r13"
block|,
literal|"r14"
block|,
literal|"r15"
block|,
literal|"r16"
block|,
literal|"r17"
block|,
literal|"r18"
block|,
literal|"r19"
block|,
literal|"r20"
block|,
literal|"r21"
block|,
literal|"r22"
block|,
literal|"r23"
block|,
literal|"r24"
block|,
literal|"r25"
block|,
literal|"r26"
block|,
literal|"r27"
block|,
literal|"r28"
block|,
literal|"r29"
block|,
literal|"r30"
block|,
literal|"r31"
block|,
comment|/* these get confusing because we omit a few and switch some ordering around. */
literal|"cr01"
block|,
comment|/* 32 = psr */
literal|"fcr62"
block|,
comment|/* 33 = fpsr*/
literal|"fcr63"
block|,
comment|/* 34 = fpcr */
literal|"ip"
block|,
comment|/* this is something of a cheat. */
comment|/* 35 = sxip */
literal|"cr05"
block|,
comment|/* 36 = snip */
literal|"cr06"
block|,
comment|/* 37 = sfip */
literal|"x00"
block|,
literal|"x01"
block|,
literal|"x02"
block|,
literal|"x03"
block|,
literal|"x04"
block|,
literal|"x05"
block|,
literal|"x06"
block|,
literal|"x07"
block|,
literal|"x08"
block|,
literal|"x09"
block|,
literal|"x10"
block|,
literal|"x11"
block|,
literal|"x12"
block|,
literal|"x13"
block|,
literal|"x14"
block|,
literal|"x15"
block|,
literal|"x16"
block|,
literal|"x17"
block|,
literal|"x18"
block|,
literal|"x19"
block|,
literal|"x20"
block|,
literal|"x21"
block|,
literal|"x22"
block|,
literal|"x23"
block|,
literal|"x24"
block|,
literal|"x25"
block|,
literal|"x26"
block|,
literal|"x27"
block|,
literal|"x28"
block|,
literal|"x29"
block|,
literal|"x30"
block|,
literal|"x31"
block|,   }
decl_stmt|;
return|return
name|rn
index|[
name|regno
index|]
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* not currently used */
end_comment

begin_comment
comment|/* Read from remote while the input matches STRING.  Return zero on    success, -1 on failure.  */
end_comment

begin_endif
unit|static int bug_scan (s)      char *s; {   int c;    while (*s)     {       c = sr_readchar();       if (c != *s++) 	{ 	  fflush(stdout); 	  printf("\nNext character is '%c' - %d and s is \"%s\".\n", c, c, --s); 	  return(-1); 	}     }    return(0); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* never */
end_comment

begin_function
specifier|static
name|int
name|bug_srec_write_cr
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|s
decl_stmt|;
if|if
condition|(
name|srec_echo_pace
condition|)
for|for
control|(
name|p
operator|=
name|s
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
name|sr_get_debug
argument_list|()
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"%c"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
do|do
name|SERIAL_WRITE
argument_list|(
name|sr_get_desc
argument_list|()
argument_list|,
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
name|sr_pollchar
argument_list|()
operator|!=
operator|*
name|p
condition|)
do|;
block|}
else|else
block|{
name|sr_write_cr
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/*       return(bug_scan (s) || bug_scan ("\n")); */
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Store register REGNO, or all if REGNO == -1. */
end_comment

begin_function
specifier|static
name|void
name|bug_fetch_register
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|sr_check_open
argument_list|()
expr_stmt|;
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
condition|;
operator|++
name|i
control|)
name|bug_fetch_register
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|target_is_m88110
operator|&&
name|regno
operator|==
name|SFIP_REGNUM
condition|)
block|{
comment|/* m88110 has no sfip. */
name|long
name|l
init|=
literal|0
decl_stmt|;
name|supply_register
argument_list|(
name|regno
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|l
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regno
operator|<
name|XFP_REGNUM
condition|)
block|{
name|char
name|buffer
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|sr_write
argument_list|(
literal|"rs "
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|sr_write_cr
argument_list|(
name|get_reg_name
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|sr_expect
argument_list|(
literal|"="
argument_list|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|buffer
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|,
name|sr_get_hex_word
argument_list|()
argument_list|)
expr_stmt|;
name|gr_expect_prompt
argument_list|()
expr_stmt|;
name|supply_register
argument_list|(
name|regno
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Float register so we need to parse a strange data format. */
name|long
name|p
decl_stmt|;
name|unsigned
name|char
name|fpreg_buf
index|[
literal|10
index|]
decl_stmt|;
name|sr_write
argument_list|(
literal|"rs "
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|sr_write
argument_list|(
name|get_reg_name
argument_list|(
name|regno
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|get_reg_name
argument_list|(
name|regno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sr_write_cr
argument_list|(
literal|";d"
argument_list|)
expr_stmt|;
name|sr_expect
argument_list|(
literal|"rs"
argument_list|)
expr_stmt|;
name|sr_expect
argument_list|(
name|get_reg_name
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|sr_expect
argument_list|(
literal|";d"
argument_list|)
expr_stmt|;
name|sr_expect
argument_list|(
literal|"="
argument_list|)
expr_stmt|;
comment|/* sign */
name|p
operator|=
name|sr_get_hex_digit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fpreg_buf
index|[
literal|0
index|]
operator|=
name|p
operator|<<
literal|7
expr_stmt|;
comment|/* exponent */
name|sr_expect
argument_list|(
literal|"_"
argument_list|)
expr_stmt|;
name|p
operator|=
name|sr_get_hex_digit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fpreg_buf
index|[
literal|0
index|]
operator|+=
operator|(
name|p
operator|<<
literal|4
operator|)
expr_stmt|;
name|fpreg_buf
index|[
literal|0
index|]
operator|+=
name|sr_get_hex_digit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fpreg_buf
index|[
literal|1
index|]
operator|=
name|sr_get_hex_digit
argument_list|(
literal|1
argument_list|)
operator|<<
literal|4
expr_stmt|;
comment|/* fraction */
name|sr_expect
argument_list|(
literal|"_"
argument_list|)
expr_stmt|;
name|fpreg_buf
index|[
literal|1
index|]
operator|+=
name|sr_get_hex_digit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fpreg_buf
index|[
literal|2
index|]
operator|=
operator|(
name|sr_get_hex_digit
argument_list|(
literal|1
argument_list|)
operator|<<
literal|4
operator|)
operator|+
name|sr_get_hex_digit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fpreg_buf
index|[
literal|3
index|]
operator|=
operator|(
name|sr_get_hex_digit
argument_list|(
literal|1
argument_list|)
operator|<<
literal|4
operator|)
operator|+
name|sr_get_hex_digit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fpreg_buf
index|[
literal|4
index|]
operator|=
operator|(
name|sr_get_hex_digit
argument_list|(
literal|1
argument_list|)
operator|<<
literal|4
operator|)
operator|+
name|sr_get_hex_digit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fpreg_buf
index|[
literal|5
index|]
operator|=
operator|(
name|sr_get_hex_digit
argument_list|(
literal|1
argument_list|)
operator|<<
literal|4
operator|)
operator|+
name|sr_get_hex_digit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fpreg_buf
index|[
literal|6
index|]
operator|=
operator|(
name|sr_get_hex_digit
argument_list|(
literal|1
argument_list|)
operator|<<
literal|4
operator|)
operator|+
name|sr_get_hex_digit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fpreg_buf
index|[
literal|7
index|]
operator|=
operator|(
name|sr_get_hex_digit
argument_list|(
literal|1
argument_list|)
operator|<<
literal|4
operator|)
operator|+
name|sr_get_hex_digit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|fpreg_buf
index|[
literal|8
index|]
operator|=
literal|0
expr_stmt|;
name|fpreg_buf
index|[
literal|9
index|]
operator|=
literal|0
expr_stmt|;
name|gr_expect_prompt
argument_list|()
expr_stmt|;
name|supply_register
argument_list|(
name|regno
argument_list|,
name|fpreg_buf
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* Store register REGNO, or all if REGNO == -1. */
end_comment

begin_function
specifier|static
name|void
name|bug_store_register
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|char
name|buffer
index|[
literal|1024
index|]
decl_stmt|;
name|sr_check_open
argument_list|()
expr_stmt|;
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
condition|;
operator|++
name|i
control|)
name|bug_store_register
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|regname
decl_stmt|;
name|regname
operator|=
name|get_reg_name
argument_list|(
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_is_m88110
operator|&&
name|regno
operator|==
name|SFIP_REGNUM
condition|)
return|return;
elseif|else
if|if
condition|(
name|regno
operator|<
name|XFP_REGNUM
condition|)
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"rs %s %08x"
argument_list|,
name|regname
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|unsigned
name|char
modifier|*
name|fpreg_buf
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"rs %s %1x_%02x%1x_%1x%02x%02x%02x%02x%02x%02x;d"
argument_list|,
name|regname
argument_list|,
comment|/* sign */
operator|(
name|fpreg_buf
index|[
literal|0
index|]
operator|>>
literal|7
operator|)
operator|&
literal|0xf
argument_list|,
comment|/* exponent */
name|fpreg_buf
index|[
literal|0
index|]
operator|&
literal|0x7f
argument_list|,
operator|(
name|fpreg_buf
index|[
literal|1
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xf
argument_list|,
comment|/* fraction */
name|fpreg_buf
index|[
literal|1
index|]
operator|&
literal|0xf
argument_list|,
name|fpreg_buf
index|[
literal|2
index|]
argument_list|,
name|fpreg_buf
index|[
literal|3
index|]
argument_list|,
name|fpreg_buf
index|[
literal|4
index|]
argument_list|,
name|fpreg_buf
index|[
literal|5
index|]
argument_list|,
name|fpreg_buf
index|[
literal|6
index|]
argument_list|,
name|fpreg_buf
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
block|}
name|sr_write_cr
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|gr_expect_prompt
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|int
name|bug_xfer_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|write
parameter_list|,
name|target
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|write
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
comment|/* ignored */
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Round starting address down to longword boundary.  */
specifier|register
name|CORE_ADDR
name|addr
decl_stmt|;
comment|/* Round ending address up; get number of longwords that makes.  */
specifier|register
name|int
name|count
decl_stmt|;
comment|/* Allocate buffer of that many longwords.  */
specifier|register
name|int
modifier|*
name|buffer
decl_stmt|;
name|addr
operator|=
name|memaddr
operator|&
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|count
operator|=
operator|(
operator|(
operator|(
name|memaddr
operator|+
name|len
operator|)
operator|-
name|addr
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|buffer
operator|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
condition|)
block|{
comment|/* Fill start and end extra bytes of buffer with existing memory data.  */
if|if
condition|(
name|addr
operator|!=
name|memaddr
operator|||
name|len
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
block|{
comment|/* Need part of initial word -- fetch it.  */
name|buffer
index|[
literal|0
index|]
operator|=
name|gr_fetch_word
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|>
literal|1
condition|)
comment|/* FIXME, avoid if even boundary */
block|{
name|buffer
index|[
name|count
operator|-
literal|1
index|]
operator|=
name|gr_fetch_word
argument_list|(
name|addr
operator|+
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Copy data to be written over corresponding part of buffer */
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
operator|(
name|memaddr
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Write the entire buffer.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|gr_store_word
argument_list|(
name|addr
argument_list|,
name|buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
block|}
else|else
block|{
comment|/* Read all the longwords */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|buffer
index|[
name|i
index|]
operator|=
name|gr_fetch_word
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
block|{
return|return
literal|0
return|;
block|}
name|QUIT
expr_stmt|;
block|}
comment|/* Copy appropriate bytes out of the buffer.  */
name|memcpy
argument_list|(
name|myaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
operator|(
name|memaddr
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|start_load
parameter_list|()
block|{
name|char
modifier|*
name|command
decl_stmt|;
name|command
operator|=
operator|(
name|srec_echo_pace
condition|?
literal|"lo 0 ;x"
else|:
literal|"lo 0"
operator|)
expr_stmt|;
name|sr_write_cr
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|sr_expect
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|sr_expect
argument_list|(
literal|"\r\n"
argument_list|)
expr_stmt|;
name|bug_srec_write_cr
argument_list|(
literal|"S0030000FC"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* This is an extremely vulnerable and fragile function.  I've made    considerable attempts to make this deterministic, but I've    certainly forgotten something.  The trouble is that S-records are    only a partial file format, not a protocol.  Worse, apparently the    m88k bug monitor does not run in real time while receiving    S-records.  Hence, we must pay excruciating attention to when and    where error messages are returned, and what has actually been sent.     Each call represents a chunk of memory to be sent to the target.    We break that chunk into an S0 header record, some number of S3    data records each containing srec_bytes, and an S7 termination    record.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|srecord_strings
index|[]
init|=
block|{
literal|"S-RECORD"
block|,
literal|"-Bug>"
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|bug_write_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|done
decl_stmt|;
name|int
name|checksum
decl_stmt|;
name|int
name|x
decl_stmt|;
name|int
name|retries
decl_stmt|;
name|char
modifier|*
name|buffer
init|=
name|alloca
argument_list|(
operator|(
name|srec_bytes
operator|+
literal|8
operator|)
operator|<<
literal|1
argument_list|)
decl_stmt|;
name|retries
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|done
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|retries
operator|>
name|srec_max_retries
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|retries
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|sr_get_debug
argument_list|()
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"\n<retrying...>\n"
argument_list|)
expr_stmt|;
comment|/* This gr_expect_prompt call is extremely important.  Without 	     it, we will tend to resend our packet so fast that it 	     will arrive before the bug monitor is ready to receive 	     it.  This would lead to a very ugly resend loop.  */
name|gr_expect_prompt
argument_list|()
expr_stmt|;
block|}
name|start_load
argument_list|()
expr_stmt|;
while|while
condition|(
name|done
operator|<
name|len
condition|)
block|{
name|int
name|thisgo
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|buffer
decl_stmt|;
name|CORE_ADDR
name|address
decl_stmt|;
name|checksum
operator|=
literal|0
expr_stmt|;
name|thisgo
operator|=
name|len
operator|-
name|done
expr_stmt|;
if|if
condition|(
name|thisgo
operator|>
name|srec_bytes
condition|)
name|thisgo
operator|=
name|srec_bytes
expr_stmt|;
name|address
operator|=
name|memaddr
operator|+
name|done
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"S3%02X%08X"
argument_list|,
name|thisgo
operator|+
literal|4
operator|+
literal|1
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|buf
operator|+=
literal|12
expr_stmt|;
name|checksum
operator|+=
operator|(
name|thisgo
operator|+
literal|4
operator|+
literal|1
operator|+
operator|(
name|address
operator|&
literal|0xff
operator|)
operator|+
operator|(
operator|(
name|address
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
operator|+
operator|(
operator|(
name|address
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
operator|+
operator|(
operator|(
name|address
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|thisgo
condition|;
name|idx
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%02X"
argument_list|,
name|myaddr
index|[
name|idx
operator|+
name|done
index|]
argument_list|)
expr_stmt|;
name|checksum
operator|+=
name|myaddr
index|[
name|idx
operator|+
name|done
index|]
expr_stmt|;
name|buf
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|srec_noise
operator|>
literal|0
condition|)
block|{
comment|/* FIXME-NOW: insert a deliberate error every now and then. 		 This is intended for testing/debugging the error handling 		 stuff.  */
specifier|static
name|int
name|counter
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|++
name|counter
operator|>
name|srec_noise
condition|)
block|{
name|counter
operator|=
literal|0
expr_stmt|;
operator|++
name|checksum
expr_stmt|;
block|}
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%02X"
argument_list|,
operator|~
name|checksum
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|bug_srec_write_cr
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|srec_sleep
operator|!=
literal|0
condition|)
name|sleep
argument_list|(
name|srec_sleep
argument_list|)
expr_stmt|;
comment|/* This pollchar is probably redundant to the gr_multi_scan 	     below.  Trouble is, we can't be sure when or where an 	     error message will appear.  Apparently, when running at 	     full speed from a typical sun4, error messages tend to 	     appear to arrive only *after* the s7 record.   */
if|if
condition|(
operator|(
name|x
operator|=
name|sr_pollchar
argument_list|()
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|sr_get_debug
argument_list|()
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"\n<retrying...>\n"
argument_list|)
expr_stmt|;
operator|++
name|retries
expr_stmt|;
comment|/* flush any remaining input and verify that we are back 		 at the prompt level. */
name|gr_expect_prompt
argument_list|()
expr_stmt|;
comment|/* start all over again. */
name|start_load
argument_list|()
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|done
operator|+=
name|thisgo
expr_stmt|;
block|}
name|bug_srec_write_cr
argument_list|(
literal|"S7060000000000F9"
argument_list|)
expr_stmt|;
operator|++
name|retries
expr_stmt|;
comment|/* Having finished the load, we need to figure out whether we 	 had any errors.  */
block|}
do|while
condition|(
name|gr_multi_scan
argument_list|(
name|srecord_strings
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
do|;
empty_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Copy LEN bytes of data from debugger memory at MYADDR    to inferior's memory at MEMADDR.  Returns errno value.  * sb/sh instructions don't work on unaligned addresses, when TU=1.  */
end_comment

begin_comment
comment|/* Read LEN bytes from inferior memory at MEMADDR.  Put the result    at debugger address MYADDR.  Returns errno value.  */
end_comment

begin_function
specifier|static
name|int
name|bug_read_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
name|request
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|type
decl_stmt|;
name|char
name|size
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
name|unsigned
name|int
name|inaddr
decl_stmt|;
name|unsigned
name|int
name|checksum
decl_stmt|;
name|sprintf
argument_list|(
name|request
argument_list|,
literal|"du 0 %x:&%d"
argument_list|,
name|memaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|sr_write_cr
argument_list|(
name|request
argument_list|)
expr_stmt|;
name|p
operator|=
name|buffer
operator|=
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
comment|/* scan up through the header */
name|sr_expect
argument_list|(
literal|"S0030000FC"
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|buffer
operator|+
name|len
condition|)
block|{
comment|/* scan off any white space. */
while|while
condition|(
name|sr_readchar
argument_list|()
operator|!=
literal|'S'
condition|)
empty_stmt|;
empty_stmt|;
comment|/* what kind of s-rec? */
name|type
operator|=
name|sr_readchar
argument_list|()
expr_stmt|;
comment|/* scan record size */
name|sr_get_hex_byte
argument_list|(
operator|&
name|size
argument_list|)
expr_stmt|;
name|checksum
operator|=
name|size
expr_stmt|;
operator|--
name|size
expr_stmt|;
name|inaddr
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
goto|goto
name|done
goto|;
case|case
literal|'3'
case|:
name|sr_get_hex_byte
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|inaddr
operator|=
operator|(
name|inaddr
operator|<<
literal|8
operator|)
operator|+
name|c
expr_stmt|;
name|checksum
operator|+=
name|c
expr_stmt|;
operator|--
name|size
expr_stmt|;
comment|/* intentional fall through */
case|case
literal|'2'
case|:
name|sr_get_hex_byte
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|inaddr
operator|=
operator|(
name|inaddr
operator|<<
literal|8
operator|)
operator|+
name|c
expr_stmt|;
name|checksum
operator|+=
name|c
expr_stmt|;
operator|--
name|size
expr_stmt|;
comment|/* intentional fall through */
case|case
literal|'1'
case|:
name|sr_get_hex_byte
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|inaddr
operator|=
operator|(
name|inaddr
operator|<<
literal|8
operator|)
operator|+
name|c
expr_stmt|;
name|checksum
operator|+=
name|c
expr_stmt|;
operator|--
name|size
expr_stmt|;
name|sr_get_hex_byte
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|inaddr
operator|=
operator|(
name|inaddr
operator|<<
literal|8
operator|)
operator|+
name|c
expr_stmt|;
name|checksum
operator|+=
name|c
expr_stmt|;
operator|--
name|size
expr_stmt|;
break|break;
default|default:
comment|/* bonk */
name|error
argument_list|(
literal|"reading s-records."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inaddr
operator|<
name|memaddr
operator|||
operator|(
name|memaddr
operator|+
name|len
operator|)
operator|<
operator|(
name|inaddr
operator|+
name|size
operator|)
condition|)
name|error
argument_list|(
literal|"srec out of memory range."
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|buffer
operator|+
name|inaddr
operator|-
name|memaddr
condition|)
name|error
argument_list|(
literal|"srec out of sequence."
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|size
condition|;
operator|--
name|size
operator|,
operator|++
name|p
control|)
block|{
name|sr_get_hex_byte
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|checksum
operator|+=
operator|*
name|p
expr_stmt|;
block|}
name|sr_get_hex_byte
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
operator|(
operator|~
name|checksum
operator|&
literal|0xff
operator|)
condition|)
name|error
argument_list|(
literal|"bad s-rec checksum"
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|gr_expect_prompt
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|buffer
operator|+
name|len
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|memcpy
argument_list|(
name|myaddr
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MAX_BREAKS
value|16
end_define

begin_decl_stmt
specifier|static
name|int
name|num_brkpts
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|bug_insert_breakpoint
parameter_list|(
name|addr
parameter_list|,
name|save
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|save
decl_stmt|;
comment|/* Throw away, let bug save instructions */
block|{
name|sr_check_open
argument_list|()
expr_stmt|;
if|if
condition|(
name|num_brkpts
operator|<
name|MAX_BREAKS
condition|)
block|{
name|char
name|buffer
index|[
literal|100
index|]
decl_stmt|;
name|num_brkpts
operator|++
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"br %x"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|sr_write_cr
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|gr_expect_prompt
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stderr
argument_list|,
literal|"Too many break points, break point not installed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|bug_remove_breakpoint
parameter_list|(
name|addr
parameter_list|,
name|save
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|save
decl_stmt|;
comment|/* Throw away, let bug save instructions */
block|{
if|if
condition|(
name|num_brkpts
operator|>
literal|0
condition|)
block|{
name|char
name|buffer
index|[
literal|100
index|]
decl_stmt|;
name|num_brkpts
operator|--
expr_stmt|;
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"nobr %x"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|sr_write_cr
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|gr_expect_prompt
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Clear the bugs notion of what the break points are */
end_comment

begin_function
specifier|static
name|int
name|bug_clear_breakpoints
parameter_list|()
block|{
if|if
condition|(
name|sr_is_open
argument_list|()
condition|)
block|{
name|sr_write_cr
argument_list|(
literal|"nobr"
argument_list|)
expr_stmt|;
name|sr_expect
argument_list|(
literal|"nobr"
argument_list|)
expr_stmt|;
name|gr_expect_prompt
argument_list|()
expr_stmt|;
block|}
name|num_brkpts
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|target_ops
name|bug_ops
init|=
block|{
literal|"bug"
block|,
literal|"Remote BUG monitor"
block|,
literal|"Use the mvme187 board running the BUG monitor connected by a serial line."
block|,
name|bug_open
block|,
name|gr_close
block|,
literal|0
block|,
name|gr_detach
block|,
name|bug_resume
block|,
name|bug_wait
block|,
comment|/* attach */
name|bug_fetch_register
block|,
name|bug_store_register
block|,
name|gr_prepare_to_store
block|,
name|bug_xfer_memory
block|,
name|gr_files_info
block|,
name|bug_insert_breakpoint
block|,
name|bug_remove_breakpoint
block|,
comment|/* Breakpoints */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* Terminal handling */
name|gr_kill
block|,
comment|/* FIXME, kill */
name|bug_load
block|,
literal|0
block|,
comment|/* lookup_symbol */
name|gr_create_inferior
block|,
comment|/* create_inferior */
name|gr_mourn
block|,
comment|/* mourn_inferior FIXME */
literal|0
block|,
comment|/* can_run */
literal|0
block|,
comment|/* notice_signals */
name|process_stratum
block|,
literal|0
block|,
comment|/* next */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* all mem, mem, stack, regs, exec */
literal|0
block|,
literal|0
block|,
comment|/* Section pointers */
name|OPS_MAGIC
block|,
comment|/* Always the last thing */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_remote_bug
parameter_list|()
block|{
name|add_target
argument_list|(
operator|&
name|bug_ops
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"srec-bytes"
argument_list|,
name|class_support
argument_list|,
name|var_uinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|srec_bytes
argument_list|,
literal|"\ Set the number of bytes represented in each S-record.\n\ This affects the communication protocol with the remote target."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"srec-max-retries"
argument_list|,
name|class_support
argument_list|,
name|var_uinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|srec_max_retries
argument_list|,
literal|"\ Set the number of retries for shipping S-records.\n\ This affects the communication protocol with the remote target."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This needs to set SREC_SIZE, not srec_frame which gets changed at the      end of a download.  But do we need the option at all?  */
block|add_show_from_set     (add_set_cmd ("srec-frame", class_support, var_uinteger, 		  (char *)&srec_frame, 		  "\ Set the number of bytes in an S-record frame.\n\ This affects the communication protocol with the remote target.",&setlist),&showlist);
endif|#
directive|endif
comment|/* 0 */
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"srec-noise"
argument_list|,
name|class_support
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|srec_noise
argument_list|,
literal|"\ Set number of S-record to send before deliberately flubbing a checksum.\n\ Zero means flub none at all.  This affects the communication protocol\n\ with the remote target."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"srec-sleep"
argument_list|,
name|class_support
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|srec_sleep
argument_list|,
literal|"\ Set number of seconds to sleep after an S-record for a possible error message to arrive.\n\ This affects the communication protocol with the remote target."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"srec-echo-pace"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|srec_echo_pace
argument_list|,
literal|"\ Set echo-verification.\n\ When on, use verification by echo when downloading S-records.  This is\n\ much slower, but generally more reliable."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

