begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Support routines for manipulating internal types for GDB.    Copyright 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2002, 2003,    2004 Free Software Foundation, Inc.    Contributed by Cygnus Support, using pieces from other GDB modules.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"complaints.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"wrapper.h"
end_include

begin_include
include|#
directive|include
file|"cp-abi.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_comment
comment|/* These variables point to the objects    representing the predefined C data types.  */
end_comment

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_void
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_char
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_true_char
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_short
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_int
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_long
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_long_long
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_signed_char
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_unsigned_char
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_unsigned_short
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_unsigned_int
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_unsigned_long
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_unsigned_long_long
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_float
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_double
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_long_double
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_complex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_double_complex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_int0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_int8
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_uint8
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_int16
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_uint16
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_int32
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_uint32
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_int64
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_uint64
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_int128
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_uint128
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_bool
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 128 bit long vector types */
end_comment

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_v2_double
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_v4_float
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_v2_int64
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_v4_int32
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_v8_int16
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_v16_int8
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 64 bit long vector types */
end_comment

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_v2_float
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_v2_int32
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_v4_int16
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_v8_int8
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_v4sf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_v4si
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_v16qi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_v8qi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_v8hi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_v4hi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_v2si
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_vec64
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_vec64i
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_vec128
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_vec128i
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_ieee_single_big
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_ieee_single_little
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_ieee_double_big
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_ieee_double_little
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_ieee_double_littlebyte_bigword
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_i387_ext
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_m68881_ext
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_i960_ext
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_m88110_ext
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_m88110_harris_ext
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_arm_ext_big
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_arm_ext_littlebyte_bigword
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_ia64_spill_big
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_ia64_spill_little
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_ia64_quad_big
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_ia64_quad_little
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_void_data_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_void_func_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_CORE_ADDR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_bfd_vma
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|opaque_type_resolution
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|overload_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|extra
block|{
name|char
name|str
index|[
literal|128
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* maximum extension is 128! FIXME */
end_comment

begin_function_decl
specifier|static
name|void
name|print_bit_vector
parameter_list|(
name|B_TYPE
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_arg_types
parameter_list|(
name|struct
name|field
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_fn_fieldlists
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_cplus_stuff
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|virtual_base_list_aux
parameter_list|(
name|struct
name|type
modifier|*
name|dclass
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Alloc a new type structure and fill it with some defaults.  If    OBJFILE is non-NULL, then allocate the space for the type structure    in that objfile's objfile_obstack.  Otherwise allocate the new type structure    by xmalloc () (for permanent types).  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|alloc_type
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
comment|/* Alloc the structure and start off with all fields zeroed. */
if|if
condition|(
name|objfile
operator|==
name|NULL
condition|)
block|{
name|type
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_MAIN_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|main_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_MAIN_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|main_type
argument_list|)
argument_list|)
expr_stmt|;
name|OBJSTAT
argument_list|(
name|objfile
argument_list|,
name|n_types
operator|++
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|TYPE_MAIN_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|main_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize the fields that might not be zero. */
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_UNDEF
expr_stmt|;
name|TYPE_OBJFILE
argument_list|(
name|type
argument_list|)
operator|=
name|objfile
expr_stmt|;
name|TYPE_VPTR_FIELDNO
argument_list|(
name|type
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
name|TYPE_CHAIN
argument_list|(
name|type
argument_list|)
operator|=
name|type
expr_stmt|;
comment|/* Chain back to itself.  */
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Alloc a new type instance structure, fill it with some defaults,    and point it at OLDTYPE.  Allocate the new type instance from the    same place as OLDTYPE.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|alloc_type_instance
parameter_list|(
name|struct
name|type
modifier|*
name|oldtype
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
comment|/* Allocate the structure.  */
if|if
condition|(
name|TYPE_OBJFILE
argument_list|(
name|oldtype
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|type
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|TYPE_OBJFILE
argument_list|(
name|oldtype
argument_list|)
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|type
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|TYPE_MAIN_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_MAIN_TYPE
argument_list|(
name|oldtype
argument_list|)
expr_stmt|;
name|TYPE_CHAIN
argument_list|(
name|type
argument_list|)
operator|=
name|type
expr_stmt|;
comment|/* Chain back to itself for now.  */
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Clear all remnants of the previous type at TYPE, in preparation for    replacing it with something else.  */
end_comment

begin_function
specifier|static
name|void
name|smash_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|memset
argument_list|(
name|TYPE_MAIN_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|main_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For now, delete the rings.  */
name|TYPE_CHAIN
argument_list|(
name|type
argument_list|)
operator|=
name|type
expr_stmt|;
comment|/* For now, leave the pointer/reference types alone.  */
block|}
end_function

begin_comment
comment|/* Lookup a pointer to a type TYPE.  TYPEPTR, if nonzero, points    to a pointer to memory where the pointer type should be stored.    If *TYPEPTR is zero, update it to point to the pointer type we return.    We allocate new memory if needed.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|make_pointer_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|type
modifier|*
modifier|*
name|typeptr
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|ntype
decl_stmt|;
comment|/* New type */
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|ntype
operator|=
name|TYPE_POINTER_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntype
condition|)
block|{
if|if
condition|(
name|typeptr
operator|==
literal|0
condition|)
return|return
name|ntype
return|;
comment|/* Don't care about alloc, and have new type.  */
elseif|else
if|if
condition|(
operator|*
name|typeptr
operator|==
literal|0
condition|)
block|{
operator|*
name|typeptr
operator|=
name|ntype
expr_stmt|;
comment|/* Tracking alloc, and we have new type.  */
return|return
name|ntype
return|;
block|}
block|}
if|if
condition|(
name|typeptr
operator|==
literal|0
operator|||
operator|*
name|typeptr
operator|==
literal|0
condition|)
comment|/* We'll need to allocate one.  */
block|{
name|ntype
operator|=
name|alloc_type
argument_list|(
name|TYPE_OBJFILE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|typeptr
condition|)
operator|*
name|typeptr
operator|=
name|ntype
expr_stmt|;
block|}
else|else
comment|/* We have storage, but need to reset it.  */
block|{
name|ntype
operator|=
operator|*
name|typeptr
expr_stmt|;
name|objfile
operator|=
name|TYPE_OBJFILE
argument_list|(
name|ntype
argument_list|)
expr_stmt|;
name|smash_type
argument_list|(
name|ntype
argument_list|)
expr_stmt|;
name|TYPE_OBJFILE
argument_list|(
name|ntype
argument_list|)
operator|=
name|objfile
expr_stmt|;
block|}
name|TYPE_TARGET_TYPE
argument_list|(
name|ntype
argument_list|)
operator|=
name|type
expr_stmt|;
name|TYPE_POINTER_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|ntype
expr_stmt|;
comment|/* FIXME!  Assume the machine has only one representation for pointers!  */
name|TYPE_LENGTH
argument_list|(
name|ntype
argument_list|)
operator|=
name|TARGET_PTR_BIT
operator|/
name|TARGET_CHAR_BIT
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|ntype
argument_list|)
operator|=
name|TYPE_CODE_PTR
expr_stmt|;
comment|/* Mark pointers as unsigned.  The target converts between pointers      and addresses (CORE_ADDRs) using POINTER_TO_ADDRESS() and      ADDRESS_TO_POINTER(). */
name|TYPE_FLAGS
argument_list|(
name|ntype
argument_list|)
operator||=
name|TYPE_FLAG_UNSIGNED
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_POINTER_TYPE
argument_list|(
name|type
argument_list|)
condition|)
comment|/* Remember it, if don't have one.  */
name|TYPE_POINTER_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|ntype
expr_stmt|;
return|return
name|ntype
return|;
block|}
end_function

begin_comment
comment|/* Given a type TYPE, return a type of pointers to that type.    May need to construct such a type if this is the first use.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|lookup_pointer_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
return|return
name|make_pointer_type
argument_list|(
name|type
argument_list|,
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Lookup a C++ `reference' to a type TYPE.  TYPEPTR, if nonzero, points    to a pointer to memory where the reference type should be stored.    If *TYPEPTR is zero, update it to point to the reference type we return.    We allocate new memory if needed.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|make_reference_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|type
modifier|*
modifier|*
name|typeptr
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|ntype
decl_stmt|;
comment|/* New type */
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|ntype
operator|=
name|TYPE_REFERENCE_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntype
condition|)
block|{
if|if
condition|(
name|typeptr
operator|==
literal|0
condition|)
return|return
name|ntype
return|;
comment|/* Don't care about alloc, and have new type.  */
elseif|else
if|if
condition|(
operator|*
name|typeptr
operator|==
literal|0
condition|)
block|{
operator|*
name|typeptr
operator|=
name|ntype
expr_stmt|;
comment|/* Tracking alloc, and we have new type.  */
return|return
name|ntype
return|;
block|}
block|}
if|if
condition|(
name|typeptr
operator|==
literal|0
operator|||
operator|*
name|typeptr
operator|==
literal|0
condition|)
comment|/* We'll need to allocate one.  */
block|{
name|ntype
operator|=
name|alloc_type
argument_list|(
name|TYPE_OBJFILE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|typeptr
condition|)
operator|*
name|typeptr
operator|=
name|ntype
expr_stmt|;
block|}
else|else
comment|/* We have storage, but need to reset it.  */
block|{
name|ntype
operator|=
operator|*
name|typeptr
expr_stmt|;
name|objfile
operator|=
name|TYPE_OBJFILE
argument_list|(
name|ntype
argument_list|)
expr_stmt|;
name|smash_type
argument_list|(
name|ntype
argument_list|)
expr_stmt|;
name|TYPE_OBJFILE
argument_list|(
name|ntype
argument_list|)
operator|=
name|objfile
expr_stmt|;
block|}
name|TYPE_TARGET_TYPE
argument_list|(
name|ntype
argument_list|)
operator|=
name|type
expr_stmt|;
name|TYPE_REFERENCE_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|ntype
expr_stmt|;
comment|/* FIXME!  Assume the machine has only one representation for references,      and that it matches the (only) representation for pointers!  */
name|TYPE_LENGTH
argument_list|(
name|ntype
argument_list|)
operator|=
name|TARGET_PTR_BIT
operator|/
name|TARGET_CHAR_BIT
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|ntype
argument_list|)
operator|=
name|TYPE_CODE_REF
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_REFERENCE_TYPE
argument_list|(
name|type
argument_list|)
condition|)
comment|/* Remember it, if don't have one.  */
name|TYPE_REFERENCE_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|ntype
expr_stmt|;
return|return
name|ntype
return|;
block|}
end_function

begin_comment
comment|/* Same as above, but caller doesn't care about memory allocation details.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|lookup_reference_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
return|return
name|make_reference_type
argument_list|(
name|type
argument_list|,
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Lookup a function type that returns type TYPE.  TYPEPTR, if nonzero, points    to a pointer to memory where the function type should be stored.    If *TYPEPTR is zero, update it to point to the function type we return.    We allocate new memory if needed.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|make_function_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|type
modifier|*
modifier|*
name|typeptr
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|ntype
decl_stmt|;
comment|/* New type */
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
if|if
condition|(
name|typeptr
operator|==
literal|0
operator|||
operator|*
name|typeptr
operator|==
literal|0
condition|)
comment|/* We'll need to allocate one.  */
block|{
name|ntype
operator|=
name|alloc_type
argument_list|(
name|TYPE_OBJFILE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|typeptr
condition|)
operator|*
name|typeptr
operator|=
name|ntype
expr_stmt|;
block|}
else|else
comment|/* We have storage, but need to reset it.  */
block|{
name|ntype
operator|=
operator|*
name|typeptr
expr_stmt|;
name|objfile
operator|=
name|TYPE_OBJFILE
argument_list|(
name|ntype
argument_list|)
expr_stmt|;
name|smash_type
argument_list|(
name|ntype
argument_list|)
expr_stmt|;
name|TYPE_OBJFILE
argument_list|(
name|ntype
argument_list|)
operator|=
name|objfile
expr_stmt|;
block|}
name|TYPE_TARGET_TYPE
argument_list|(
name|ntype
argument_list|)
operator|=
name|type
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|ntype
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|ntype
argument_list|)
operator|=
name|TYPE_CODE_FUNC
expr_stmt|;
return|return
name|ntype
return|;
block|}
end_function

begin_comment
comment|/* Given a type TYPE, return a type of functions that return that type.    May need to construct such a type if this is the first use.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|lookup_function_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
return|return
name|make_function_type
argument_list|(
name|type
argument_list|,
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Identify address space identifier by name --    return the integer flag defined in gdbtypes.h.  */
end_comment

begin_function
specifier|extern
name|int
name|address_space_name_to_int
parameter_list|(
name|char
modifier|*
name|space_identifier
parameter_list|)
block|{
name|struct
name|gdbarch
modifier|*
name|gdbarch
init|=
name|current_gdbarch
decl_stmt|;
name|int
name|type_flags
decl_stmt|;
comment|/* Check for known address space delimiters. */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|space_identifier
argument_list|,
literal|"code"
argument_list|)
condition|)
return|return
name|TYPE_FLAG_CODE_SPACE
return|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|space_identifier
argument_list|,
literal|"data"
argument_list|)
condition|)
return|return
name|TYPE_FLAG_DATA_SPACE
return|;
elseif|else
if|if
condition|(
name|gdbarch_address_class_name_to_type_flags_p
argument_list|(
name|gdbarch
argument_list|)
operator|&&
name|gdbarch_address_class_name_to_type_flags
argument_list|(
name|gdbarch
argument_list|,
name|space_identifier
argument_list|,
operator|&
name|type_flags
argument_list|)
condition|)
return|return
name|type_flags
return|;
else|else
name|error
argument_list|(
literal|"Unknown address space specifier: \"%s\""
argument_list|,
name|space_identifier
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Identify address space identifier by integer flag as defined in     gdbtypes.h -- return the string version of the adress space name. */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|address_space_int_to_name
parameter_list|(
name|int
name|space_flag
parameter_list|)
block|{
name|struct
name|gdbarch
modifier|*
name|gdbarch
init|=
name|current_gdbarch
decl_stmt|;
if|if
condition|(
name|space_flag
operator|&
name|TYPE_FLAG_CODE_SPACE
condition|)
return|return
literal|"code"
return|;
elseif|else
if|if
condition|(
name|space_flag
operator|&
name|TYPE_FLAG_DATA_SPACE
condition|)
return|return
literal|"data"
return|;
elseif|else
if|if
condition|(
operator|(
name|space_flag
operator|&
name|TYPE_FLAG_ADDRESS_CLASS_ALL
operator|)
operator|&&
name|gdbarch_address_class_type_flags_to_name_p
argument_list|(
name|gdbarch
argument_list|)
condition|)
return|return
name|gdbarch_address_class_type_flags_to_name
argument_list|(
name|gdbarch
argument_list|,
name|space_flag
argument_list|)
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Create a new type with instance flags NEW_FLAGS, based on TYPE.    If STORAGE is non-NULL, create the new type instance there.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|make_qualified_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|new_flags
parameter_list|,
name|struct
name|type
modifier|*
name|storage
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|ntype
decl_stmt|;
name|ntype
operator|=
name|type
expr_stmt|;
do|do
block|{
if|if
condition|(
name|TYPE_INSTANCE_FLAGS
argument_list|(
name|ntype
argument_list|)
operator|==
name|new_flags
condition|)
return|return
name|ntype
return|;
name|ntype
operator|=
name|TYPE_CHAIN
argument_list|(
name|ntype
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ntype
operator|!=
name|type
condition|)
do|;
comment|/* Create a new type instance.  */
if|if
condition|(
name|storage
operator|==
name|NULL
condition|)
name|ntype
operator|=
name|alloc_type_instance
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
block|{
name|ntype
operator|=
name|storage
expr_stmt|;
name|TYPE_MAIN_TYPE
argument_list|(
name|ntype
argument_list|)
operator|=
name|TYPE_MAIN_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_CHAIN
argument_list|(
name|ntype
argument_list|)
operator|=
name|ntype
expr_stmt|;
block|}
comment|/* Pointers or references to the original type are not relevant to      the new type.  */
name|TYPE_POINTER_TYPE
argument_list|(
name|ntype
argument_list|)
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
literal|0
expr_stmt|;
name|TYPE_REFERENCE_TYPE
argument_list|(
name|ntype
argument_list|)
operator|=
operator|(
expr|struct
name|type
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* Chain the new qualified type to the old type.  */
name|TYPE_CHAIN
argument_list|(
name|ntype
argument_list|)
operator|=
name|TYPE_CHAIN
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_CHAIN
argument_list|(
name|type
argument_list|)
operator|=
name|ntype
expr_stmt|;
comment|/* Now set the instance flags and return the new type.  */
name|TYPE_INSTANCE_FLAGS
argument_list|(
name|ntype
argument_list|)
operator|=
name|new_flags
expr_stmt|;
comment|/* Set length of new type to that of the original type.  */
name|TYPE_LENGTH
argument_list|(
name|ntype
argument_list|)
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|ntype
return|;
block|}
end_function

begin_comment
comment|/* Make an address-space-delimited variant of a type -- a type that    is identical to the one supplied except that it has an address    space attribute attached to it (such as "code" or "data").     The space attributes "code" and "data" are for Harvard architectures.    The address space attributes are for architectures which have    alternately sized pointers or pointers with alternate representations.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|make_type_with_address_space
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|space_flag
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|ntype
decl_stmt|;
name|int
name|new_flags
init|=
operator|(
operator|(
name|TYPE_INSTANCE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&
operator|~
operator|(
name|TYPE_FLAG_CODE_SPACE
operator||
name|TYPE_FLAG_DATA_SPACE
operator||
name|TYPE_FLAG_ADDRESS_CLASS_ALL
operator|)
operator|)
operator||
name|space_flag
operator|)
decl_stmt|;
return|return
name|make_qualified_type
argument_list|(
name|type
argument_list|,
name|new_flags
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make a "c-v" variant of a type -- a type that is identical to the    one supplied except that it may have const or volatile attributes    CNST is a flag for setting the const attribute    VOLTL is a flag for setting the volatile attribute    TYPE is the base type whose variant we are creating.    TYPEPTR, if nonzero, points    to a pointer to memory where the reference type should be stored.    If *TYPEPTR is zero, update it to point to the reference type we return.    We allocate new memory if needed.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|make_cv_type
parameter_list|(
name|int
name|cnst
parameter_list|,
name|int
name|voltl
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|type
modifier|*
modifier|*
name|typeptr
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|ntype
decl_stmt|;
comment|/* New type */
name|struct
name|type
modifier|*
name|tmp_type
init|=
name|type
decl_stmt|;
comment|/* tmp type */
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|int
name|new_flags
init|=
operator|(
name|TYPE_INSTANCE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&
operator|~
operator|(
name|TYPE_FLAG_CONST
operator||
name|TYPE_FLAG_VOLATILE
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|cnst
condition|)
name|new_flags
operator||=
name|TYPE_FLAG_CONST
expr_stmt|;
if|if
condition|(
name|voltl
condition|)
name|new_flags
operator||=
name|TYPE_FLAG_VOLATILE
expr_stmt|;
if|if
condition|(
name|typeptr
operator|&&
operator|*
name|typeptr
operator|!=
name|NULL
condition|)
block|{
comment|/* Objfile is per-core-type.  This const-qualified type had best 	 belong to the same objfile as the type it is qualifying, unless 	 we are overwriting a stub type, in which case the safest thing 	 to do is to copy the core type into the new objfile.  */
name|gdb_assert
argument_list|(
name|TYPE_OBJFILE
argument_list|(
operator|*
name|typeptr
argument_list|)
operator|==
name|TYPE_OBJFILE
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_STUB
argument_list|(
operator|*
name|typeptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_OBJFILE
argument_list|(
operator|*
name|typeptr
argument_list|)
operator|!=
name|TYPE_OBJFILE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|TYPE_MAIN_TYPE
argument_list|(
operator|*
name|typeptr
argument_list|)
operator|=
name|TYPE_ALLOC
argument_list|(
operator|*
name|typeptr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|main_type
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|TYPE_MAIN_TYPE
argument_list|(
operator|*
name|typeptr
argument_list|)
operator|=
operator|*
name|TYPE_MAIN_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
block|}
name|ntype
operator|=
name|make_qualified_type
argument_list|(
name|type
argument_list|,
name|new_flags
argument_list|,
name|typeptr
condition|?
operator|*
name|typeptr
else|:
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|typeptr
operator|!=
name|NULL
condition|)
operator|*
name|typeptr
operator|=
name|ntype
expr_stmt|;
return|return
name|ntype
return|;
block|}
end_function

begin_comment
comment|/* Replace the contents of ntype with the type *type.  This changes the    contents, rather than the pointer for TYPE_MAIN_TYPE (ntype); thus    the changes are propogated to all types in the TYPE_CHAIN.     In order to build recursive types, it's inevitable that we'll need    to update types in place --- but this sort of indiscriminate    smashing is ugly, and needs to be replaced with something more    controlled.  TYPE_MAIN_TYPE is a step in this direction; it's not    clear if more steps are needed.  */
end_comment

begin_function
name|void
name|replace_type
parameter_list|(
name|struct
name|type
modifier|*
name|ntype
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|chain
decl_stmt|;
operator|*
name|TYPE_MAIN_TYPE
argument_list|(
name|ntype
argument_list|)
operator|=
operator|*
name|TYPE_MAIN_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* The type length is not a part of the main type.  Update it for each      type on the variant chain.  */
name|chain
operator|=
name|ntype
expr_stmt|;
do|do
block|{
comment|/* Assert that this element of the chain has no address-class bits        set in its flags.  Such type variants might have type lengths        which are supposed to be different from the non-address-class        variants.  This assertion shouldn't ever be triggered because        symbol readers which do construct address-class variants don't        call replace_type().  */
name|gdb_assert
argument_list|(
name|TYPE_ADDRESS_CLASS_ALL
argument_list|(
name|chain
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|ntype
argument_list|)
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|chain
operator|=
name|TYPE_CHAIN
argument_list|(
name|chain
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ntype
operator|!=
name|chain
condition|)
do|;
comment|/* Assert that the two types have equivalent instance qualifiers.      This should be true for at least all of our debug readers.  */
name|gdb_assert
argument_list|(
name|TYPE_INSTANCE_FLAGS
argument_list|(
name|ntype
argument_list|)
operator|==
name|TYPE_INSTANCE_FLAGS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implement direct support for MEMBER_TYPE in GNU C++.    May need to construct such a type if this is the first use.    The TYPE is the type of the member.  The DOMAIN is the type    of the aggregate that the member belongs to.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|lookup_member_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|type
modifier|*
name|domain
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|mtype
decl_stmt|;
name|mtype
operator|=
name|alloc_type
argument_list|(
name|TYPE_OBJFILE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|smash_to_member_type
argument_list|(
name|mtype
argument_list|,
name|domain
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|mtype
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Allocate a stub method whose return type is TYPE.      This apparently happens for speed of symbol reading, since parsing    out the arguments to the method is cpu-intensive, the way we are doing    it.  So, we will fill in arguments later.    This always returns a fresh type.   */
end_comment

begin_function
name|struct
name|type
modifier|*
name|allocate_stub_method
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|mtype
decl_stmt|;
name|mtype
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_METHOD
argument_list|,
literal|1
argument_list|,
name|TYPE_FLAG_STUB
argument_list|,
name|NULL
argument_list|,
name|TYPE_OBJFILE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|mtype
argument_list|)
operator|=
name|type
expr_stmt|;
comment|/*  _DOMAIN_TYPE (mtype) = unknown yet */
return|return
operator|(
name|mtype
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Create a range type using either a blank type supplied in RESULT_TYPE,    or creating a new type, inheriting the objfile from INDEX_TYPE.     Indices will be of type INDEX_TYPE, and will range from LOW_BOUND to    HIGH_BOUND, inclusive.     FIXME:  Maybe we should check the TYPE_CODE of RESULT_TYPE to make    sure it is TYPE_CODE_UNDEF before we bash it into a range type? */
end_comment

begin_function
name|struct
name|type
modifier|*
name|create_range_type
parameter_list|(
name|struct
name|type
modifier|*
name|result_type
parameter_list|,
name|struct
name|type
modifier|*
name|index_type
parameter_list|,
name|int
name|low_bound
parameter_list|,
name|int
name|high_bound
parameter_list|)
block|{
if|if
condition|(
name|result_type
operator|==
name|NULL
condition|)
block|{
name|result_type
operator|=
name|alloc_type
argument_list|(
name|TYPE_OBJFILE
argument_list|(
name|index_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|TYPE_CODE
argument_list|(
name|result_type
argument_list|)
operator|=
name|TYPE_CODE_RANGE
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|result_type
argument_list|)
operator|=
name|index_type
expr_stmt|;
if|if
condition|(
name|TYPE_STUB
argument_list|(
name|index_type
argument_list|)
condition|)
name|TYPE_FLAGS
argument_list|(
name|result_type
argument_list|)
operator||=
name|TYPE_FLAG_TARGET_STUB
expr_stmt|;
else|else
name|TYPE_LENGTH
argument_list|(
name|result_type
argument_list|)
operator|=
name|TYPE_LENGTH
argument_list|(
name|check_typedef
argument_list|(
name|index_type
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|result_type
argument_list|)
operator|=
literal|2
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|result_type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|result_type
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|result_type
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_FIELD_BITPOS
argument_list|(
name|result_type
argument_list|,
literal|0
argument_list|)
operator|=
name|low_bound
expr_stmt|;
name|TYPE_FIELD_BITPOS
argument_list|(
name|result_type
argument_list|,
literal|1
argument_list|)
operator|=
name|high_bound
expr_stmt|;
name|TYPE_FIELD_TYPE
argument_list|(
name|result_type
argument_list|,
literal|0
argument_list|)
operator|=
name|builtin_type_int
expr_stmt|;
comment|/* FIXME */
name|TYPE_FIELD_TYPE
argument_list|(
name|result_type
argument_list|,
literal|1
argument_list|)
operator|=
name|builtin_type_int
expr_stmt|;
comment|/* FIXME */
if|if
condition|(
name|low_bound
operator|>=
literal|0
condition|)
name|TYPE_FLAGS
argument_list|(
name|result_type
argument_list|)
operator||=
name|TYPE_FLAG_UNSIGNED
expr_stmt|;
return|return
operator|(
name|result_type
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Set *LOWP and *HIGHP to the lower and upper bounds of discrete type TYPE.    Return 1 of type is a range type, 0 if it is discrete (and bounds    will fit in LONGEST), or -1 otherwise. */
end_comment

begin_function
name|int
name|get_discrete_bounds
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|LONGEST
modifier|*
name|lowp
parameter_list|,
name|LONGEST
modifier|*
name|highp
parameter_list|)
block|{
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_RANGE
case|:
operator|*
name|lowp
operator|=
name|TYPE_LOW_BOUND
argument_list|(
name|type
argument_list|)
expr_stmt|;
operator|*
name|highp
operator|=
name|TYPE_HIGH_BOUND
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|TYPE_CODE_ENUM
case|:
if|if
condition|(
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* The enums may not be sorted by value, so search all 	     entries */
name|int
name|i
decl_stmt|;
operator|*
name|lowp
operator|=
operator|*
name|highp
operator|=
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|<
operator|*
name|lowp
condition|)
operator|*
name|lowp
operator|=
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|>
operator|*
name|highp
condition|)
operator|*
name|highp
operator|=
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* Set unsigned indicator if warranted. */
if|if
condition|(
operator|*
name|lowp
operator|>=
literal|0
condition|)
block|{
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator||=
name|TYPE_FLAG_UNSIGNED
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|lowp
operator|=
literal|0
expr_stmt|;
operator|*
name|highp
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
literal|0
return|;
case|case
name|TYPE_CODE_BOOL
case|:
operator|*
name|lowp
operator|=
literal|0
expr_stmt|;
operator|*
name|highp
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
case|case
name|TYPE_CODE_INT
case|:
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|>
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
condition|)
comment|/* Too big */
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
block|{
operator|*
name|lowp
operator|=
operator|-
operator|(
literal|1
operator|<<
operator|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|*
name|TARGET_CHAR_BIT
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
operator|*
name|highp
operator|=
operator|-
operator|*
name|lowp
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* ... fall through for unsigned ints ... */
case|case
name|TYPE_CODE_CHAR
case|:
operator|*
name|lowp
operator|=
literal|0
expr_stmt|;
comment|/* This round-about calculation is to avoid shifting by          TYPE_LENGTH (type) * TARGET_CHAR_BIT, which will not work          if TYPE_LENGTH (type) == sizeof (LONGEST). */
operator|*
name|highp
operator|=
literal|1
operator|<<
operator|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|*
name|TARGET_CHAR_BIT
operator|-
literal|1
operator|)
expr_stmt|;
operator|*
name|highp
operator|=
operator|(
operator|*
name|highp
operator|-
literal|1
operator|)
operator||
operator|*
name|highp
expr_stmt|;
return|return
literal|0
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Create an array type using either a blank type supplied in RESULT_TYPE,    or creating a new type, inheriting the objfile from RANGE_TYPE.     Elements will be of type ELEMENT_TYPE, the indices will be of type    RANGE_TYPE.     FIXME:  Maybe we should check the TYPE_CODE of RESULT_TYPE to make    sure it is TYPE_CODE_UNDEF before we bash it into an array type? */
end_comment

begin_function
name|struct
name|type
modifier|*
name|create_array_type
parameter_list|(
name|struct
name|type
modifier|*
name|result_type
parameter_list|,
name|struct
name|type
modifier|*
name|element_type
parameter_list|,
name|struct
name|type
modifier|*
name|range_type
parameter_list|)
block|{
name|LONGEST
name|low_bound
decl_stmt|,
name|high_bound
decl_stmt|;
if|if
condition|(
name|result_type
operator|==
name|NULL
condition|)
block|{
name|result_type
operator|=
name|alloc_type
argument_list|(
name|TYPE_OBJFILE
argument_list|(
name|range_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|TYPE_CODE
argument_list|(
name|result_type
argument_list|)
operator|=
name|TYPE_CODE_ARRAY
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|result_type
argument_list|)
operator|=
name|element_type
expr_stmt|;
if|if
condition|(
name|get_discrete_bounds
argument_list|(
name|range_type
argument_list|,
operator|&
name|low_bound
argument_list|,
operator|&
name|high_bound
argument_list|)
operator|<
literal|0
condition|)
name|low_bound
operator|=
name|high_bound
operator|=
literal|0
expr_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|element_type
argument_list|)
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|result_type
argument_list|)
operator|=
name|TYPE_LENGTH
argument_list|(
name|element_type
argument_list|)
operator|*
operator|(
name|high_bound
operator|-
name|low_bound
operator|+
literal|1
operator|)
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|result_type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|result_type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|result_type
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|result_type
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_FIELD_TYPE
argument_list|(
name|result_type
argument_list|,
literal|0
argument_list|)
operator|=
name|range_type
expr_stmt|;
name|TYPE_VPTR_FIELDNO
argument_list|(
name|result_type
argument_list|)
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* TYPE_FLAG_TARGET_STUB will take care of zero length arrays */
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|result_type
argument_list|)
operator|==
literal|0
condition|)
name|TYPE_FLAGS
argument_list|(
name|result_type
argument_list|)
operator||=
name|TYPE_FLAG_TARGET_STUB
expr_stmt|;
return|return
operator|(
name|result_type
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Create a string type using either a blank type supplied in RESULT_TYPE,    or creating a new type.  String types are similar enough to array of    char types that we can use create_array_type to build the basic type    and then bash it into a string type.     For fixed length strings, the range type contains 0 as the lower    bound and the length of the string minus one as the upper bound.     FIXME:  Maybe we should check the TYPE_CODE of RESULT_TYPE to make    sure it is TYPE_CODE_UNDEF before we bash it into a string type? */
end_comment

begin_function
name|struct
name|type
modifier|*
name|create_string_type
parameter_list|(
name|struct
name|type
modifier|*
name|result_type
parameter_list|,
name|struct
name|type
modifier|*
name|range_type
parameter_list|)
block|{
name|result_type
operator|=
name|create_array_type
argument_list|(
name|result_type
argument_list|,
operator|*
name|current_language
operator|->
name|string_char_type
argument_list|,
name|range_type
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|result_type
argument_list|)
operator|=
name|TYPE_CODE_STRING
expr_stmt|;
return|return
operator|(
name|result_type
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|type
modifier|*
name|create_set_type
parameter_list|(
name|struct
name|type
modifier|*
name|result_type
parameter_list|,
name|struct
name|type
modifier|*
name|domain_type
parameter_list|)
block|{
name|LONGEST
name|low_bound
decl_stmt|,
name|high_bound
decl_stmt|,
name|bit_length
decl_stmt|;
if|if
condition|(
name|result_type
operator|==
name|NULL
condition|)
block|{
name|result_type
operator|=
name|alloc_type
argument_list|(
name|TYPE_OBJFILE
argument_list|(
name|domain_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|TYPE_CODE
argument_list|(
name|result_type
argument_list|)
operator|=
name|TYPE_CODE_SET
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|result_type
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|result_type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|result_type
argument_list|,
literal|1
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|result_type
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_STUB
argument_list|(
name|domain_type
argument_list|)
condition|)
block|{
if|if
condition|(
name|get_discrete_bounds
argument_list|(
name|domain_type
argument_list|,
operator|&
name|low_bound
argument_list|,
operator|&
name|high_bound
argument_list|)
operator|<
literal|0
condition|)
name|low_bound
operator|=
name|high_bound
operator|=
literal|0
expr_stmt|;
name|bit_length
operator|=
name|high_bound
operator|-
name|low_bound
operator|+
literal|1
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|result_type
argument_list|)
operator|=
operator|(
name|bit_length
operator|+
name|TARGET_CHAR_BIT
operator|-
literal|1
operator|)
operator|/
name|TARGET_CHAR_BIT
expr_stmt|;
block|}
name|TYPE_FIELD_TYPE
argument_list|(
name|result_type
argument_list|,
literal|0
argument_list|)
operator|=
name|domain_type
expr_stmt|;
if|if
condition|(
name|low_bound
operator|>=
literal|0
condition|)
name|TYPE_FLAGS
argument_list|(
name|result_type
argument_list|)
operator||=
name|TYPE_FLAG_UNSIGNED
expr_stmt|;
return|return
operator|(
name|result_type
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Construct and return a type of the form: 	struct NAME { ELT_TYPE ELT_NAME[N]; }    We use these types for SIMD registers.  For example, the type of    the SSE registers on the late x86-family processors is: 	struct __builtin_v4sf { float f[4]; }    built by the function call: 	init_simd_type ("__builtin_v4sf", builtin_type_float, "f", 4)    The type returned is a permanent type, allocated using malloc; it    doesn't live in any objfile's obstack.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|init_simd_type
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|type
modifier|*
name|elt_type
parameter_list|,
name|char
modifier|*
name|elt_name
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|simd_type
decl_stmt|;
name|struct
name|type
modifier|*
name|array_type
decl_stmt|;
name|simd_type
operator|=
name|init_composite_type
argument_list|(
name|name
argument_list|,
name|TYPE_CODE_STRUCT
argument_list|)
expr_stmt|;
name|array_type
operator|=
name|create_array_type
argument_list|(
literal|0
argument_list|,
name|elt_type
argument_list|,
name|create_range_type
argument_list|(
literal|0
argument_list|,
name|builtin_type_int
argument_list|,
literal|0
argument_list|,
name|n
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|append_composite_type_field
argument_list|(
name|simd_type
argument_list|,
name|elt_name
argument_list|,
name|array_type
argument_list|)
expr_stmt|;
return|return
name|simd_type
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|type
modifier|*
name|init_vector_type
parameter_list|(
name|struct
name|type
modifier|*
name|elt_type
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|array_type
decl_stmt|;
name|array_type
operator|=
name|create_array_type
argument_list|(
literal|0
argument_list|,
name|elt_type
argument_list|,
name|create_range_type
argument_list|(
literal|0
argument_list|,
name|builtin_type_int
argument_list|,
literal|0
argument_list|,
name|n
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_FLAGS
argument_list|(
name|array_type
argument_list|)
operator||=
name|TYPE_FLAG_VECTOR
expr_stmt|;
return|return
name|array_type
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|type
modifier|*
name|build_builtin_type_vec64
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Construct a type for the 64 bit registers.  The type we're      building is this: */
if|#
directive|if
literal|0
block|union __gdb_builtin_type_vec64   {     int64_t uint64;     float v2_float[2];     int32_t v2_int32[2];     int16_t v4_int16[4];     int8_t v8_int8[8];   };
endif|#
directive|endif
name|struct
name|type
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|init_composite_type
argument_list|(
literal|"__gdb_builtin_type_vec64"
argument_list|,
name|TYPE_CODE_UNION
argument_list|)
expr_stmt|;
name|append_composite_type_field
argument_list|(
name|t
argument_list|,
literal|"uint64"
argument_list|,
name|builtin_type_int64
argument_list|)
expr_stmt|;
name|append_composite_type_field
argument_list|(
name|t
argument_list|,
literal|"v2_float"
argument_list|,
name|builtin_type_v2_float
argument_list|)
expr_stmt|;
name|append_composite_type_field
argument_list|(
name|t
argument_list|,
literal|"v2_int32"
argument_list|,
name|builtin_type_v2_int32
argument_list|)
expr_stmt|;
name|append_composite_type_field
argument_list|(
name|t
argument_list|,
literal|"v4_int16"
argument_list|,
name|builtin_type_v4_int16
argument_list|)
expr_stmt|;
name|append_composite_type_field
argument_list|(
name|t
argument_list|,
literal|"v8_int8"
argument_list|,
name|builtin_type_v8_int8
argument_list|)
expr_stmt|;
name|TYPE_FLAGS
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_FLAG_VECTOR
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|=
literal|"builtin_type_vec64"
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|type
modifier|*
name|build_builtin_type_vec64i
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Construct a type for the 64 bit registers.  The type we're      building is this: */
if|#
directive|if
literal|0
block|union __gdb_builtin_type_vec64i    {     int64_t uint64;     int32_t v2_int32[2];     int16_t v4_int16[4];     int8_t v8_int8[8];   };
endif|#
directive|endif
name|struct
name|type
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|init_composite_type
argument_list|(
literal|"__gdb_builtin_type_vec64i"
argument_list|,
name|TYPE_CODE_UNION
argument_list|)
expr_stmt|;
name|append_composite_type_field
argument_list|(
name|t
argument_list|,
literal|"uint64"
argument_list|,
name|builtin_type_int64
argument_list|)
expr_stmt|;
name|append_composite_type_field
argument_list|(
name|t
argument_list|,
literal|"v2_int32"
argument_list|,
name|builtin_type_v2_int32
argument_list|)
expr_stmt|;
name|append_composite_type_field
argument_list|(
name|t
argument_list|,
literal|"v4_int16"
argument_list|,
name|builtin_type_v4_int16
argument_list|)
expr_stmt|;
name|append_composite_type_field
argument_list|(
name|t
argument_list|,
literal|"v8_int8"
argument_list|,
name|builtin_type_v8_int8
argument_list|)
expr_stmt|;
name|TYPE_FLAGS
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_FLAG_VECTOR
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|=
literal|"builtin_type_vec64i"
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|type
modifier|*
name|build_builtin_type_vec128
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Construct a type for the 128 bit registers.  The type we're      building is this: */
if|#
directive|if
literal|0
block|union __gdb_builtin_type_vec128    {     int128_t uint128;     float v4_float[4];     int32_t v4_int32[4];     int16_t v8_int16[8];     int8_t v16_int8[16];   };
endif|#
directive|endif
name|struct
name|type
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|init_composite_type
argument_list|(
literal|"__gdb_builtin_type_vec128"
argument_list|,
name|TYPE_CODE_UNION
argument_list|)
expr_stmt|;
name|append_composite_type_field
argument_list|(
name|t
argument_list|,
literal|"uint128"
argument_list|,
name|builtin_type_int128
argument_list|)
expr_stmt|;
name|append_composite_type_field
argument_list|(
name|t
argument_list|,
literal|"v4_float"
argument_list|,
name|builtin_type_v4_float
argument_list|)
expr_stmt|;
name|append_composite_type_field
argument_list|(
name|t
argument_list|,
literal|"v4_int32"
argument_list|,
name|builtin_type_v4_int32
argument_list|)
expr_stmt|;
name|append_composite_type_field
argument_list|(
name|t
argument_list|,
literal|"v8_int16"
argument_list|,
name|builtin_type_v8_int16
argument_list|)
expr_stmt|;
name|append_composite_type_field
argument_list|(
name|t
argument_list|,
literal|"v16_int8"
argument_list|,
name|builtin_type_v16_int8
argument_list|)
expr_stmt|;
name|TYPE_FLAGS
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_FLAG_VECTOR
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|=
literal|"builtin_type_vec128"
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|type
modifier|*
name|build_builtin_type_vec128i
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 128-bit Intel SIMD registers */
name|struct
name|type
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|init_composite_type
argument_list|(
literal|"__gdb_builtin_type_vec128i"
argument_list|,
name|TYPE_CODE_UNION
argument_list|)
expr_stmt|;
name|append_composite_type_field
argument_list|(
name|t
argument_list|,
literal|"v4_float"
argument_list|,
name|builtin_type_v4_float
argument_list|)
expr_stmt|;
name|append_composite_type_field
argument_list|(
name|t
argument_list|,
literal|"v2_double"
argument_list|,
name|builtin_type_v2_double
argument_list|)
expr_stmt|;
name|append_composite_type_field
argument_list|(
name|t
argument_list|,
literal|"v16_int8"
argument_list|,
name|builtin_type_v16_int8
argument_list|)
expr_stmt|;
name|append_composite_type_field
argument_list|(
name|t
argument_list|,
literal|"v8_int16"
argument_list|,
name|builtin_type_v8_int16
argument_list|)
expr_stmt|;
name|append_composite_type_field
argument_list|(
name|t
argument_list|,
literal|"v4_int32"
argument_list|,
name|builtin_type_v4_int32
argument_list|)
expr_stmt|;
name|append_composite_type_field
argument_list|(
name|t
argument_list|,
literal|"v2_int64"
argument_list|,
name|builtin_type_v2_int64
argument_list|)
expr_stmt|;
name|append_composite_type_field
argument_list|(
name|t
argument_list|,
literal|"uint128"
argument_list|,
name|builtin_type_int128
argument_list|)
expr_stmt|;
name|TYPE_FLAGS
argument_list|(
name|t
argument_list|)
operator||=
name|TYPE_FLAG_VECTOR
expr_stmt|;
name|TYPE_NAME
argument_list|(
name|t
argument_list|)
operator|=
literal|"builtin_type_vec128i"
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Smash TYPE to be a type of members of DOMAIN with type TO_TYPE.     A MEMBER is a wierd thing -- it amounts to a typed offset into    a struct, e.g. "an int at offset 8".  A MEMBER TYPE doesn't    include the offset (that's the value of the MEMBER itself), but does    include the structure type into which it points (for some reason).     When "smashing" the type, we preserve the objfile that the    old type pointed to, since we aren't changing where the type is actually    allocated.  */
end_comment

begin_function
name|void
name|smash_to_member_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|type
modifier|*
name|domain
parameter_list|,
name|struct
name|type
modifier|*
name|to_type
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|objfile
operator|=
name|TYPE_OBJFILE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|smash_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_OBJFILE
argument_list|(
name|type
argument_list|)
operator|=
name|objfile
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|to_type
expr_stmt|;
name|TYPE_DOMAIN_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|domain
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* In practice, this is never needed.  */
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_MEMBER
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Smash TYPE to be a type of method of DOMAIN with type TO_TYPE.    METHOD just means `function that gets an extra "this" argument'.     When "smashing" the type, we preserve the objfile that the    old type pointed to, since we aren't changing where the type is actually    allocated.  */
end_comment

begin_function
name|void
name|smash_to_method_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|type
modifier|*
name|domain
parameter_list|,
name|struct
name|type
modifier|*
name|to_type
parameter_list|,
name|struct
name|field
modifier|*
name|args
parameter_list|,
name|int
name|nargs
parameter_list|,
name|int
name|varargs
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|objfile
operator|=
name|TYPE_OBJFILE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|smash_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_OBJFILE
argument_list|(
name|type
argument_list|)
operator|=
name|objfile
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|to_type
expr_stmt|;
name|TYPE_DOMAIN_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|domain
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|args
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|nargs
expr_stmt|;
if|if
condition|(
name|varargs
condition|)
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator||=
name|TYPE_FLAG_VARARGS
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* In practice, this is never needed.  */
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_METHOD
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a typename for a struct/union/enum type without "struct ",    "union ", or "enum ".  If the type has a NULL name, return NULL.  */
end_comment

begin_function
name|char
modifier|*
name|type_name_no_tag
parameter_list|(
specifier|const
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
if|if
condition|(
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
return|;
comment|/* Is there code which expects this to return the name if there is no      tag name?  My guess is that this is mainly used for C++ in cases where      the two will always be the same.  */
return|return
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Lookup a primitive type named NAME.     Return zero if NAME is not a primitive type. */
end_comment

begin_function
name|struct
name|type
modifier|*
name|lookup_primitive_typename
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|type
modifier|*
modifier|*
specifier|const
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|current_language
operator|->
name|la_builtin_type_vector
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|TYPE_NAME
argument_list|(
operator|*
operator|*
name|p
argument_list|)
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
operator|*
operator|*
name|p
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Lookup a typedef or primitive type named NAME,    visible in lexical block BLOCK.    If NOERR is nonzero, return zero if NAME is not suitably defined.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|lookup_typename
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|block
modifier|*
name|block
parameter_list|,
name|int
name|noerr
parameter_list|)
block|{
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|type
modifier|*
name|tmp
decl_stmt|;
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|name
argument_list|,
name|block
argument_list|,
name|VAR_DOMAIN
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
operator|||
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_TYPEDEF
condition|)
block|{
name|tmp
operator|=
name|lookup_primitive_typename
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
block|{
return|return
operator|(
name|tmp
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|tmp
operator|&&
name|noerr
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"No type named %s."
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|type
modifier|*
name|lookup_unsigned_typename
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|uns
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|10
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|uns
argument_list|,
literal|"unsigned "
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|uns
operator|+
literal|9
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|lookup_typename
argument_list|(
name|uns
argument_list|,
operator|(
expr|struct
name|block
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|type
modifier|*
name|lookup_signed_typename
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|uns
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|8
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|uns
argument_list|,
literal|"signed "
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|uns
operator|+
literal|7
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|t
operator|=
name|lookup_typename
argument_list|(
name|uns
argument_list|,
operator|(
expr|struct
name|block
operator|*
operator|)
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* If we don't find "signed FOO" just try again with plain "FOO". */
if|if
condition|(
name|t
operator|!=
name|NULL
condition|)
return|return
name|t
return|;
return|return
name|lookup_typename
argument_list|(
name|name
argument_list|,
operator|(
expr|struct
name|block
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Lookup a structure type named "struct NAME",    visible in lexical block BLOCK.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|lookup_struct
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|block
modifier|*
name|block
parameter_list|)
block|{
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|name
argument_list|,
name|block
argument_list|,
name|STRUCT_DOMAIN
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"No struct type named %s."
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
condition|)
block|{
name|error
argument_list|(
literal|"This context has class, union or enum %s, not a struct."
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Lookup a union type named "union NAME",    visible in lexical block BLOCK.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|lookup_union
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|block
modifier|*
name|block
parameter_list|)
block|{
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|type
modifier|*
name|t
decl_stmt|;
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|name
argument_list|,
name|block
argument_list|,
name|STRUCT_DOMAIN
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"No union type named %s."
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|t
operator|=
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_CODE_UNION
condition|)
return|return
operator|(
name|t
operator|)
return|;
comment|/* C++ unions may come out with TYPE_CODE_CLASS, but we look at    * a further "declared_type" field to discover it is really a union.    */
if|if
condition|(
name|HAVE_CPLUS_STRUCT
argument_list|(
name|t
argument_list|)
condition|)
if|if
condition|(
name|TYPE_DECLARED_TYPE
argument_list|(
name|t
argument_list|)
operator|==
name|DECLARED_TYPE_UNION
condition|)
return|return
operator|(
name|t
operator|)
return|;
comment|/* If we get here, it's not a union */
name|error
argument_list|(
literal|"This context has class, struct or enum %s, not a union."
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Lookup an enum type named "enum NAME",    visible in lexical block BLOCK.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|lookup_enum
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|block
modifier|*
name|block
parameter_list|)
block|{
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|name
argument_list|,
name|block
argument_list|,
name|STRUCT_DOMAIN
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"No enum type named %s."
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_ENUM
condition|)
block|{
name|error
argument_list|(
literal|"This context has class, struct or union %s, not an enum."
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Lookup a template type named "template NAME<TYPE>",    visible in lexical block BLOCK.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|lookup_template_type
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|block
modifier|*
name|block
parameter_list|)
block|{
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|char
modifier|*
name|nam
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
operator|+
literal|4
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|nam
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|nam
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|nam
argument_list|,
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|nam
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
comment|/* FIXME, extra space still introduced in gcc? */
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|nam
argument_list|,
name|block
argument_list|,
name|VAR_DOMAIN
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"No template type named %s."
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
condition|)
block|{
name|error
argument_list|(
literal|"This context has class, union or enum %s, not a struct."
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Given a type TYPE, lookup the type of the component of type named NAME.       TYPE can be either a struct or union, or a pointer or reference to a struct or    union.  If it is a pointer or reference, its target type is automatically used.    Thus '.' and '->' are interchangable, as specified for the definitions of the    expression element types STRUCTOP_STRUCT and STRUCTOP_PTR.     If NOERR is nonzero, return zero if NAME is not suitably defined.    If NAME is the name of a baseclass type, return that type.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|lookup_struct_elt_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|noerr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_PTR
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_REF
condition|)
break|break;
name|type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_UNION
condition|)
block|{
name|target_terminal_ours
argument_list|()
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Type "
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|type
argument_list|,
literal|""
argument_list|,
name|gdb_stderr
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|" is not a structure or union type."
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* FIXME:  This change put in by Michael seems incorrect for the case where      the structure tag name is the same as the member name.  I.E. when doing      "ptype bell->bar" for "struct foo { int bar; int foo; } bell;"      Disabled by fnf. */
block|{     char *typename;      typename = type_name_no_tag (type);     if (typename != NULL&& strcmp (typename, name) == 0)       return type;   }
endif|#
directive|endif
for|for
control|(
name|i
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|;
name|i
operator|--
control|)
block|{
name|char
modifier|*
name|t_field_name
init|=
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|t_field_name
operator|&&
operator|(
name|strcmp_iw
argument_list|(
name|t_field_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
return|return
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
return|;
block|}
block|}
comment|/* OK, it's not in this class.  Recursively check the baseclasses.  */
for|for
control|(
name|i
operator|=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|struct
name|type
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|lookup_struct_elt_type
argument_list|(
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|name
argument_list|,
name|noerr
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|NULL
condition|)
block|{
return|return
name|t
return|;
block|}
block|}
if|if
condition|(
name|noerr
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|target_terminal_ours
argument_list|()
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Type "
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|type
argument_list|,
literal|""
argument_list|,
name|gdb_stderr
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|" has no component named "
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|name
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"."
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|type
operator|*
operator|)
operator|-
literal|1
return|;
comment|/* For lint */
block|}
end_function

begin_comment
comment|/* If possible, make the vptr_fieldno and vptr_basetype fields of TYPE    valid.  Callers should be aware that in some cases (for example,    the type or one of its baseclasses is a stub type and we are    debugging a .o file), this function will not be able to find the virtual    function table pointer, and vptr_fieldno will remain -1 and vptr_basetype    will remain NULL.  */
end_comment

begin_function
name|void
name|fill_in_vptr_fieldno
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_VPTR_FIELDNO
argument_list|(
name|type
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* We must start at zero in case the first (and only) baseclass is          virtual (and hence we cannot share the table pointer).  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|type
modifier|*
name|baseclass
init|=
name|check_typedef
argument_list|(
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|fill_in_vptr_fieldno
argument_list|(
name|baseclass
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_VPTR_FIELDNO
argument_list|(
name|baseclass
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|TYPE_VPTR_FIELDNO
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_VPTR_FIELDNO
argument_list|(
name|baseclass
argument_list|)
expr_stmt|;
name|TYPE_VPTR_BASETYPE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_VPTR_BASETYPE
argument_list|(
name|baseclass
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Find the method and field indices for the destructor in class type T.    Return 1 if the destructor was found, otherwise, return 0.  */
end_comment

begin_function
name|int
name|get_destructor_fn_field
parameter_list|(
name|struct
name|type
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|method_indexp
parameter_list|,
name|int
modifier|*
name|field_indexp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_NFN_FIELDS
argument_list|(
name|t
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
name|struct
name|fn_field
modifier|*
name|f
init|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|is_destructor_name
argument_list|(
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|method_indexp
operator|=
name|i
expr_stmt|;
operator|*
name|field_indexp
operator|=
name|j
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|stub_noname_complaint
parameter_list|(
name|void
parameter_list|)
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"stub type has NULL name"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Added by Bryan Boreham, Kewill, Sun Sep 17 18:07:17 1989.     If this is a stubbed struct (i.e. declared as struct foo *), see if    we can find a full definition in some other file. If so, copy this    definition, so we can use it in future.  There used to be a comment (but    not any code) that if we don't find a full definition, we'd set a flag    so we don't spend time in the future checking the same type.  That would    be a mistake, though--we might load in more symbols which contain a    full definition for the type.     This used to be coded as a macro, but I don't think it is called     often enough to merit such treatment.  */
end_comment

begin_comment
comment|/* Find the real type of TYPE.  This function returns the real type, after    removing all layers of typedefs and completing opaque or stub types.    Completion changes the TYPE argument, but stripping of typedefs does    not.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|check_typedef
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|orig_type
init|=
name|type
decl_stmt|;
name|int
name|is_const
decl_stmt|,
name|is_volatile
decl_stmt|;
while|while
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_TYPEDEF
condition|)
block|{
if|if
condition|(
operator|!
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
comment|/* It is dangerous to call lookup_symbol if we are currently 	     reading a symtab.  Infinite recursion is one danger. */
if|if
condition|(
name|currently_reading_symtab
condition|)
return|return
name|type
return|;
name|name
operator|=
name|type_name_no_tag
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* FIXME: shouldn't we separately check the TYPE_NAME and the 	     TYPE_TAG_NAME, and look in STRUCT_DOMAIN and/or VAR_DOMAIN 	     as appropriate?  (this code was written before TYPE_NAME and 	     TYPE_TAG_NAME were separate).  */
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|stub_noname_complaint
argument_list|()
expr_stmt|;
return|return
name|type
return|;
block|}
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
name|STRUCT_DOMAIN
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
else|else
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|alloc_type
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* TYPE_CODE_UNDEF */
block|}
name|type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
name|is_const
operator|=
name|TYPE_CONST
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|is_volatile
operator|=
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* If this is a struct/class/union with no fields, then check whether a      full definition exists somewhere else.  This is for systems where a      type definition with no fields is issued for such types, instead of      identifying them as stub types in the first place */
if|if
condition|(
name|TYPE_IS_OPAQUE
argument_list|(
name|type
argument_list|)
operator|&&
name|opaque_type_resolution
operator|&&
operator|!
name|currently_reading_symtab
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|type_name_no_tag
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|newtype
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|stub_noname_complaint
argument_list|()
expr_stmt|;
return|return
name|type
return|;
block|}
name|newtype
operator|=
name|lookup_transparent_type
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|newtype
condition|)
name|make_cv_type
argument_list|(
name|is_const
argument_list|,
name|is_volatile
argument_list|,
name|newtype
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
block|}
comment|/* Otherwise, rely on the stub flag being set for opaque/stubbed types */
elseif|else
if|if
condition|(
name|TYPE_STUB
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|currently_reading_symtab
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|type_name_no_tag
argument_list|(
name|type
argument_list|)
decl_stmt|;
comment|/* FIXME: shouldn't we separately check the TYPE_NAME and the          TYPE_TAG_NAME, and look in STRUCT_DOMAIN and/or VAR_DOMAIN          as appropriate?  (this code was written before TYPE_NAME and          TYPE_TAG_NAME were separate).  */
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|stub_noname_complaint
argument_list|()
expr_stmt|;
return|return
name|type
return|;
block|}
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|name
argument_list|,
literal|0
argument_list|,
name|STRUCT_DOMAIN
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
name|make_cv_type
argument_list|(
name|is_const
argument_list|,
name|is_volatile
argument_list|,
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_TARGET_STUB
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|struct
name|type
modifier|*
name|range_type
decl_stmt|;
name|struct
name|type
modifier|*
name|target_type
init|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_STUB
argument_list|(
name|target_type
argument_list|)
operator|||
name|TYPE_TARGET_STUB
argument_list|(
name|target_type
argument_list|)
condition|)
block|{ 	}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
operator|&&
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|==
literal|1
operator|&&
operator|(
name|TYPE_CODE
argument_list|(
name|range_type
operator|=
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_RANGE
operator|)
condition|)
block|{
comment|/* Now recompute the length of the array type, based on its 	     number of elements and the target type's length.  */
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
operator|(
operator|(
name|TYPE_FIELD_BITPOS
argument_list|(
name|range_type
argument_list|,
literal|1
argument_list|)
operator|-
name|TYPE_FIELD_BITPOS
argument_list|(
name|range_type
argument_list|,
literal|0
argument_list|)
operator|+
literal|1
operator|)
operator|*
name|TYPE_LENGTH
argument_list|(
name|target_type
argument_list|)
operator|)
expr_stmt|;
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&=
operator|~
name|TYPE_FLAG_TARGET_STUB
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_RANGE
condition|)
block|{
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_LENGTH
argument_list|(
name|target_type
argument_list|)
expr_stmt|;
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&=
operator|~
name|TYPE_FLAG_TARGET_STUB
expr_stmt|;
block|}
block|}
comment|/* Cache TYPE_LENGTH for future use. */
name|TYPE_LENGTH
argument_list|(
name|orig_type
argument_list|)
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Parse a type expression in the string [P..P+LENGTH).  If an error occurs,    silently return builtin_type_void. */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|safe_parse_type
parameter_list|(
name|char
modifier|*
name|p
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|struct
name|ui_file
modifier|*
name|saved_gdb_stderr
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
comment|/* Suppress error messages. */
name|saved_gdb_stderr
operator|=
name|gdb_stderr
expr_stmt|;
name|gdb_stderr
operator|=
name|ui_file_new
argument_list|()
expr_stmt|;
comment|/* Call parse_and_eval_type() without fear of longjmp()s. */
if|if
condition|(
operator|!
name|gdb_parse_and_eval_type
argument_list|(
name|p
argument_list|,
name|length
argument_list|,
operator|&
name|type
argument_list|)
condition|)
name|type
operator|=
name|builtin_type_void
expr_stmt|;
comment|/* Stop suppressing error messages. */
name|ui_file_delete
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
name|gdb_stderr
operator|=
name|saved_gdb_stderr
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Ugly hack to convert method stubs into method types.     He ain't kiddin'.  This demangles the name of the method into a string    including argument types, parses out each argument type, generates    a string casting a zero to that type, evaluates the string, and stuffs    the resulting type into an argtype vector!!!  Then it knows the type    of the whole function (including argument types for overloading),    which info used to be in the stab's but was removed to hack back    the space required for them.  */
end_comment

begin_function
specifier|static
name|void
name|check_stub_method
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|method_id
parameter_list|,
name|int
name|signature_id
parameter_list|)
block|{
name|struct
name|fn_field
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|mangled_name
init|=
name|gdb_mangle_name
argument_list|(
name|type
argument_list|,
name|method_id
argument_list|,
name|signature_id
argument_list|)
decl_stmt|;
name|char
modifier|*
name|demangled_name
init|=
name|cplus_demangle
argument_list|(
name|mangled_name
argument_list|,
name|DMGL_PARAMS
operator||
name|DMGL_ANSI
argument_list|)
decl_stmt|;
name|char
modifier|*
name|argtypetext
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|depth
init|=
literal|0
decl_stmt|,
name|argcount
init|=
literal|1
decl_stmt|;
name|struct
name|field
modifier|*
name|argtypes
decl_stmt|;
name|struct
name|type
modifier|*
name|mtype
decl_stmt|;
comment|/* Make sure we got back a function string that we can use.  */
if|if
condition|(
name|demangled_name
condition|)
name|p
operator|=
name|strchr
argument_list|(
name|demangled_name
argument_list|,
literal|'('
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|demangled_name
operator|==
name|NULL
operator|||
name|p
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Internal: Cannot demangle mangled name `%s'."
argument_list|,
name|mangled_name
argument_list|)
expr_stmt|;
comment|/* Now, read in the parameters that define this type.  */
name|p
operator|+=
literal|1
expr_stmt|;
name|argtypetext
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'('
operator|||
operator|*
name|p
operator|==
literal|'<'
condition|)
block|{
name|depth
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|')'
operator|||
operator|*
name|p
operator|==
literal|'>'
condition|)
block|{
name|depth
operator|-=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|','
operator|&&
name|depth
operator|==
literal|0
condition|)
block|{
name|argcount
operator|+=
literal|1
expr_stmt|;
block|}
name|p
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* If we read one argument and it was ``void'', don't count it.  */
if|if
condition|(
name|strncmp
argument_list|(
name|argtypetext
argument_list|,
literal|"(void)"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
name|argcount
operator|-=
literal|1
expr_stmt|;
comment|/* We need one extra slot, for the THIS pointer.  */
name|argtypes
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
operator|(
name|argcount
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|argtypetext
expr_stmt|;
comment|/* Add THIS pointer for non-static methods.  */
name|f
operator|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|type
argument_list|,
name|method_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FN_FIELD_STATIC_P
argument_list|(
name|f
argument_list|,
name|signature_id
argument_list|)
condition|)
name|argcount
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|argtypes
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|lookup_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|argcount
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|!=
literal|')'
condition|)
comment|/* () means no args, skip while */
block|{
name|depth
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
name|depth
operator|<=
literal|0
operator|&&
operator|(
operator|*
name|p
operator|==
literal|','
operator|||
operator|*
name|p
operator|==
literal|')'
operator|)
condition|)
block|{
comment|/* Avoid parsing of ellipsis, they will be handled below. 	         Also avoid ``void'' as above.  */
if|if
condition|(
name|strncmp
argument_list|(
name|argtypetext
argument_list|,
literal|"..."
argument_list|,
name|p
operator|-
name|argtypetext
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|argtypetext
argument_list|,
literal|"void"
argument_list|,
name|p
operator|-
name|argtypetext
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|argtypes
index|[
name|argcount
index|]
operator|.
name|type
operator|=
name|safe_parse_type
argument_list|(
name|argtypetext
argument_list|,
name|p
operator|-
name|argtypetext
argument_list|)
expr_stmt|;
name|argcount
operator|+=
literal|1
expr_stmt|;
block|}
name|argtypetext
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'('
operator|||
operator|*
name|p
operator|==
literal|'<'
condition|)
block|{
name|depth
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|')'
operator|||
operator|*
name|p
operator|==
literal|'>'
condition|)
block|{
name|depth
operator|-=
literal|1
expr_stmt|;
block|}
name|p
operator|+=
literal|1
expr_stmt|;
block|}
block|}
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|signature_id
argument_list|)
operator|=
name|mangled_name
expr_stmt|;
comment|/* Now update the old "stub" type into a real type.  */
name|mtype
operator|=
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|f
argument_list|,
name|signature_id
argument_list|)
expr_stmt|;
name|TYPE_DOMAIN_TYPE
argument_list|(
name|mtype
argument_list|)
operator|=
name|type
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|mtype
argument_list|)
operator|=
name|argtypes
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|mtype
argument_list|)
operator|=
name|argcount
expr_stmt|;
name|TYPE_FLAGS
argument_list|(
name|mtype
argument_list|)
operator|&=
operator|~
name|TYPE_FLAG_STUB
expr_stmt|;
name|TYPE_FN_FIELD_STUB
argument_list|(
name|f
argument_list|,
name|signature_id
argument_list|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
index|[
operator|-
literal|2
index|]
operator|==
literal|'.'
condition|)
name|TYPE_FLAGS
argument_list|(
name|mtype
argument_list|)
operator||=
name|TYPE_FLAG_VARARGS
expr_stmt|;
name|xfree
argument_list|(
name|demangled_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is the external interface to check_stub_method, above.  This function    unstubs all of the signatures for TYPE's METHOD_ID method name.  After    calling this function TYPE_FN_FIELD_STUB will be cleared for each signature    and TYPE_FN_FIELDLIST_NAME will be correct.     This function unfortunately can not die until stabs do.  */
end_comment

begin_function
name|void
name|check_stub_method_group
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|method_id
parameter_list|)
block|{
name|int
name|len
init|=
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|type
argument_list|,
name|method_id
argument_list|)
decl_stmt|;
name|struct
name|fn_field
modifier|*
name|f
init|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|type
argument_list|,
name|method_id
argument_list|)
decl_stmt|;
name|int
name|j
decl_stmt|,
name|found_stub
init|=
literal|0
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|TYPE_FN_FIELD_STUB
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
block|{
name|found_stub
operator|=
literal|1
expr_stmt|;
name|check_stub_method
argument_list|(
name|type
argument_list|,
name|method_id
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
comment|/* GNU v3 methods with incorrect names were corrected when we read in      type information, because it was cheaper to do it then.  The only GNU v2      methods with incorrect method names are operators and destructors;      destructors were also corrected when we read in type information.       Therefore the only thing we need to handle here are v2 operator      names.  */
if|if
condition|(
name|found_stub
operator|&&
name|strncmp
argument_list|(
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"_Z"
argument_list|,
literal|2
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|ret
decl_stmt|;
name|char
name|dem_opname
index|[
literal|256
index|]
decl_stmt|;
name|ret
operator|=
name|cplus_demangle_opname
argument_list|(
name|TYPE_FN_FIELDLIST_NAME
argument_list|(
name|type
argument_list|,
name|method_id
argument_list|)
argument_list|,
name|dem_opname
argument_list|,
name|DMGL_ANSI
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|ret
operator|=
name|cplus_demangle_opname
argument_list|(
name|TYPE_FN_FIELDLIST_NAME
argument_list|(
name|type
argument_list|,
name|method_id
argument_list|)
argument_list|,
name|dem_opname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|TYPE_FN_FIELDLIST_NAME
argument_list|(
name|type
argument_list|,
name|method_id
argument_list|)
operator|=
name|xstrdup
argument_list|(
name|dem_opname
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|const
name|struct
name|cplus_struct_type
name|cplus_struct_default
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|allocate_cplus_struct_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
if|if
condition|(
operator|!
name|HAVE_CPLUS_STRUCT
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|TYPE_CPLUS_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|cplus_struct_type
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cplus_struct_type
argument_list|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|TYPE_CPLUS_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|)
operator|=
name|cplus_struct_default
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Helper function to initialize the standard scalar types.     If NAME is non-NULL and OBJFILE is non-NULL, then we make a copy    of the string pointed to by name in the objfile_obstack for that objfile,    and initialize the type name to that copy.  There are places (mipsread.c    in particular, where init_type is called with a NULL value for NAME). */
end_comment

begin_function
name|struct
name|type
modifier|*
name|init_type
parameter_list|(
name|enum
name|type_code
name|code
parameter_list|,
name|int
name|length
parameter_list|,
name|int
name|flags
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|type
operator|=
name|alloc_type
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|code
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|length
expr_stmt|;
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator||=
name|flags
expr_stmt|;
if|if
condition|(
operator|(
name|name
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|objfile
operator|!=
name|NULL
operator|)
condition|)
block|{
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|obsavestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|name
expr_stmt|;
block|}
comment|/* C++ fancies.  */
if|if
condition|(
name|name
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"char"
argument_list|)
operator|==
literal|0
condition|)
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator||=
name|TYPE_FLAG_NOSIGN
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|code
operator|==
name|TYPE_CODE_UNION
operator|||
name|code
operator|==
name|TYPE_CODE_NAMESPACE
condition|)
block|{
name|INIT_CPLUS_SPECIFIC
argument_list|(
name|type
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Helper function.  Create an empty composite type.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|init_composite_type
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|enum
name|type_code
name|code
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|t
decl_stmt|;
name|gdb_assert
argument_list|(
name|code
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|code
operator|==
name|TYPE_CODE_UNION
argument_list|)
expr_stmt|;
name|t
operator|=
name|init_type
argument_list|(
name|code
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TYPE_TAG_NAME
argument_list|(
name|t
argument_list|)
operator|=
name|name
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Helper function.  Append a field to a composite type.  */
end_comment

begin_function
name|void
name|append_composite_type_field
parameter_list|(
name|struct
name|type
modifier|*
name|t
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|type
modifier|*
name|field
parameter_list|)
block|{
name|struct
name|field
modifier|*
name|f
decl_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_NFIELDS
argument_list|(
name|t
argument_list|)
operator|+
literal|1
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|xrealloc
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|TYPE_NFIELDS
argument_list|(
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|=
operator|&
operator|(
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
index|[
name|TYPE_NFIELDS
argument_list|(
name|t
argument_list|)
operator|-
literal|1
index|]
operator|)
expr_stmt|;
name|memset
argument_list|(
name|f
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|f
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|FIELD_TYPE
argument_list|(
name|f
index|[
literal|0
index|]
argument_list|)
operator|=
name|field
expr_stmt|;
name|FIELD_NAME
argument_list|(
name|f
index|[
literal|0
index|]
argument_list|)
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_CODE_UNION
condition|)
block|{
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|t
argument_list|)
operator|<
name|TYPE_LENGTH
argument_list|(
name|field
argument_list|)
condition|)
name|TYPE_LENGTH
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_LENGTH
argument_list|(
name|field
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
condition|)
block|{
name|TYPE_LENGTH
argument_list|(
name|t
argument_list|)
operator|=
name|TYPE_LENGTH
argument_list|(
name|t
argument_list|)
operator|+
name|TYPE_LENGTH
argument_list|(
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NFIELDS
argument_list|(
name|t
argument_list|)
operator|>
literal|1
condition|)
block|{
name|FIELD_BITPOS
argument_list|(
name|f
index|[
literal|0
index|]
argument_list|)
operator|=
operator|(
name|FIELD_BITPOS
argument_list|(
name|f
index|[
operator|-
literal|1
index|]
argument_list|)
operator|+
name|TYPE_LENGTH
argument_list|(
name|field
argument_list|)
operator|*
name|TARGET_CHAR_BIT
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Look up a fundamental type for the specified objfile.    May need to construct such a type if this is the first use.     Some object file formats (ELF, COFF, etc) do not define fundamental    types such as "int" or "double".  Others (stabs for example), do    define fundamental types.     For the formats which don't provide fundamental types, gdb can create    such types, using defaults reasonable for the current language and    the current target machine.     NOTE:  This routine is obsolescent.  Each debugging format reader    should manage it's own fundamental types, either creating them from    suitable defaults or reading them from the debugging information,    whichever is appropriate.  The DWARF reader has already been    fixed to do this.  Once the other readers are fixed, this routine    will go away.  Also note that fundamental types should be managed    on a compilation unit basis in a multi-language environment, not    on a linkage unit basis as is done here. */
end_comment

begin_function
name|struct
name|type
modifier|*
name|lookup_fundamental_type
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|int
name|typeid
parameter_list|)
block|{
name|struct
name|type
modifier|*
modifier|*
name|typep
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
if|if
condition|(
name|typeid
operator|<
literal|0
operator|||
name|typeid
operator|>=
name|FT_NUM_MEMBERS
condition|)
block|{
name|error
argument_list|(
literal|"internal error - invalid fundamental type id %d"
argument_list|,
name|typeid
argument_list|)
expr_stmt|;
block|}
comment|/* If this is the first time we need a fundamental type for this objfile      then we need to initialize the vector of type pointers. */
if|if
condition|(
name|objfile
operator|->
name|fundamental_types
operator|==
name|NULL
condition|)
block|{
name|nbytes
operator|=
name|FT_NUM_MEMBERS
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|fundamental_types
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|objfile
operator|->
name|fundamental_types
argument_list|,
literal|0
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|OBJSTAT
argument_list|(
name|objfile
argument_list|,
name|n_types
operator|+=
name|FT_NUM_MEMBERS
argument_list|)
expr_stmt|;
block|}
comment|/* Look for this particular type in the fundamental type vector.  If one is      not found, create and install one appropriate for the current language. */
name|typep
operator|=
name|objfile
operator|->
name|fundamental_types
operator|+
name|typeid
expr_stmt|;
if|if
condition|(
operator|*
name|typep
operator|==
name|NULL
condition|)
block|{
operator|*
name|typep
operator|=
name|create_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|typeid
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|*
name|typep
operator|)
return|;
block|}
end_function

begin_function
name|int
name|can_dereference
parameter_list|(
name|struct
name|type
modifier|*
name|t
parameter_list|)
block|{
comment|/* FIXME: Should we return true for references as well as pointers?  */
name|CHECK_TYPEDEF
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|t
operator|!=
name|NULL
operator|&&
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|&&
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|t
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_VOID
operator|)
return|;
block|}
end_function

begin_function
name|int
name|is_integral_type
parameter_list|(
name|struct
name|type
modifier|*
name|t
parameter_list|)
block|{
name|CHECK_TYPEDEF
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|t
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|)
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_CODE_ENUM
operator|)
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_CODE_CHAR
operator|)
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_CODE_RANGE
operator|)
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|t
argument_list|)
operator|==
name|TYPE_CODE_BOOL
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Check whether BASE is an ancestor or base class or DCLASS     Return 1 if so, and 0 if not.    Note: callers may want to check for identity of the types before    calling this function -- identical types are considered to satisfy    the ancestor relationship even if they're identical */
end_comment

begin_function
name|int
name|is_ancestor
parameter_list|(
name|struct
name|type
modifier|*
name|base
parameter_list|,
name|struct
name|type
modifier|*
name|dclass
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|dclass
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|==
name|dclass
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|base
argument_list|)
operator|&&
name|TYPE_NAME
argument_list|(
name|dclass
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|TYPE_NAME
argument_list|(
name|base
argument_list|)
argument_list|,
name|TYPE_NAME
argument_list|(
name|dclass
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_N_BASECLASSES
argument_list|(
name|dclass
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|is_ancestor
argument_list|(
name|base
argument_list|,
name|TYPE_BASECLASS
argument_list|(
name|dclass
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* See whether DCLASS has a virtual table.  This routine is aimed at    the HP/Taligent ANSI C++ runtime model, and may not work with other    runtime models.  Return 1 => Yes, 0 => No.  */
end_comment

begin_function
name|int
name|has_vtable
parameter_list|(
name|struct
name|type
modifier|*
name|dclass
parameter_list|)
block|{
comment|/* In the HP ANSI C++ runtime model, a class has a vtable only if it      has virtual functions or virtual bases.  */
name|int
name|i
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|dclass
argument_list|)
operator|!=
name|TYPE_CODE_CLASS
condition|)
return|return
literal|0
return|;
comment|/* First check for the presence of virtual bases */
if|if
condition|(
name|TYPE_FIELD_VIRTUAL_BITS
argument_list|(
name|dclass
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_N_BASECLASSES
argument_list|(
name|dclass
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|B_TST
argument_list|(
name|TYPE_FIELD_VIRTUAL_BITS
argument_list|(
name|dclass
argument_list|)
argument_list|,
name|i
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Next check for virtual functions */
if|if
condition|(
name|TYPE_FN_FIELDLISTS
argument_list|(
name|dclass
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_NFN_FIELDS
argument_list|(
name|dclass
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TYPE_FN_FIELD_VIRTUAL_P
argument_list|(
name|TYPE_FN_FIELDLIST1
argument_list|(
name|dclass
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Recurse on non-virtual bases to see if any of them needs a vtable */
if|if
condition|(
name|TYPE_FIELD_VIRTUAL_BITS
argument_list|(
name|dclass
argument_list|)
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_N_BASECLASSES
argument_list|(
name|dclass
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|!
name|B_TST
argument_list|(
name|TYPE_FIELD_VIRTUAL_BITS
argument_list|(
name|dclass
argument_list|)
argument_list|,
name|i
argument_list|)
operator|)
operator|&&
operator|(
name|has_vtable
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|dclass
argument_list|,
name|i
argument_list|)
argument_list|)
operator|)
condition|)
return|return
literal|1
return|;
comment|/* Well, maybe we don't need a virtual table */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to the "primary base class" of DCLASS.     A NULL return indicates that DCLASS has no primary base, or that it    couldn't be found (insufficient information).     This routine is aimed at the HP/Taligent ANSI C++ runtime model,    and may not work with other runtime models.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|primary_base_class
parameter_list|(
name|struct
name|type
modifier|*
name|dclass
parameter_list|)
block|{
comment|/* In HP ANSI C++'s runtime model, a "primary base class" of a class      is the first directly inherited, non-virtual base class that      requires a virtual table */
name|int
name|i
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|dclass
argument_list|)
operator|!=
name|TYPE_CODE_CLASS
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_N_BASECLASSES
argument_list|(
name|dclass
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|TYPE_FIELD_VIRTUAL
argument_list|(
name|dclass
argument_list|,
name|i
argument_list|)
operator|&&
name|has_vtable
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|dclass
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
return|return
name|TYPE_FIELD_TYPE
argument_list|(
name|dclass
argument_list|,
name|i
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Global manipulated by virtual_base_list[_aux]() */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|vbase
modifier|*
name|current_vbase_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return a pointer to a null-terminated list of struct vbase    items. The vbasetype pointer of each item in the list points to the    type information for a virtual base of the argument DCLASS.     Helper function for virtual_base_list().     Note: the list goes backward, right-to-left. virtual_base_list()    copies the items out in reverse order.  */
end_comment

begin_function
specifier|static
name|void
name|virtual_base_list_aux
parameter_list|(
name|struct
name|type
modifier|*
name|dclass
parameter_list|)
block|{
name|struct
name|vbase
modifier|*
name|tmp_vbase
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|dclass
argument_list|)
operator|!=
name|TYPE_CODE_CLASS
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_N_BASECLASSES
argument_list|(
name|dclass
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* Recurse on this ancestor, first */
name|virtual_base_list_aux
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|dclass
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this current base is itself virtual, add it to the list */
if|if
condition|(
name|BASETYPE_VIA_VIRTUAL
argument_list|(
name|dclass
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|struct
name|type
modifier|*
name|basetype
init|=
name|TYPE_FIELD_TYPE
argument_list|(
name|dclass
argument_list|,
name|i
argument_list|)
decl_stmt|;
comment|/* Check if base already recorded */
name|tmp_vbase
operator|=
name|current_vbase_list
expr_stmt|;
while|while
condition|(
name|tmp_vbase
condition|)
block|{
if|if
condition|(
name|tmp_vbase
operator|->
name|vbasetype
operator|==
name|basetype
condition|)
break|break;
comment|/* found it */
name|tmp_vbase
operator|=
name|tmp_vbase
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tmp_vbase
condition|)
comment|/* normal exit from loop */
block|{
comment|/* Allocate new item for this virtual base */
name|tmp_vbase
operator|=
operator|(
expr|struct
name|vbase
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vbase
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Stick it on at the end of the list */
name|tmp_vbase
operator|->
name|vbasetype
operator|=
name|basetype
expr_stmt|;
name|tmp_vbase
operator|->
name|next
operator|=
name|current_vbase_list
expr_stmt|;
name|current_vbase_list
operator|=
name|tmp_vbase
expr_stmt|;
block|}
block|}
comment|/* if virtual */
block|}
comment|/* for loop over bases */
block|}
end_function

begin_comment
comment|/* Compute the list of virtual bases in the right order.  Virtual    bases are laid out in the object's memory area in order of their    occurrence in a depth-first, left-to-right search through the    ancestors.     Argument DCLASS is the type whose virtual bases are required.    Return value is the address of a null-terminated array of pointers    to struct type items.     This routine is aimed at the HP/Taligent ANSI C++ runtime model,    and may not work with other runtime models.     This routine merely hands off the argument to virtual_base_list_aux()    and then copies the result into an array to save space.  */
end_comment

begin_function
name|struct
name|type
modifier|*
modifier|*
name|virtual_base_list
parameter_list|(
name|struct
name|type
modifier|*
name|dclass
parameter_list|)
block|{
name|struct
name|vbase
modifier|*
name|tmp_vbase
decl_stmt|;
name|struct
name|vbase
modifier|*
name|tmp_vbase_2
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|count
decl_stmt|;
name|struct
name|type
modifier|*
modifier|*
name|vbase_array
decl_stmt|;
name|current_vbase_list
operator|=
name|NULL
expr_stmt|;
name|virtual_base_list_aux
argument_list|(
name|dclass
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tmp_vbase
operator|=
name|current_vbase_list
init|;
name|tmp_vbase
operator|!=
name|NULL
condition|;
name|i
operator|++
operator|,
name|tmp_vbase
operator|=
name|tmp_vbase
operator|->
name|next
control|)
comment|/* no body */
empty_stmt|;
name|count
operator|=
name|i
expr_stmt|;
name|vbase_array
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|count
operator|-
literal|1
operator|,
name|tmp_vbase
operator|=
name|current_vbase_list
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
operator|,
name|tmp_vbase
operator|=
name|tmp_vbase
operator|->
name|next
control|)
name|vbase_array
index|[
name|i
index|]
operator|=
name|tmp_vbase
operator|->
name|vbasetype
expr_stmt|;
comment|/* Get rid of constructed chain */
name|tmp_vbase_2
operator|=
name|tmp_vbase
operator|=
name|current_vbase_list
expr_stmt|;
while|while
condition|(
name|tmp_vbase
condition|)
block|{
name|tmp_vbase
operator|=
name|tmp_vbase
operator|->
name|next
expr_stmt|;
name|xfree
argument_list|(
name|tmp_vbase_2
argument_list|)
expr_stmt|;
name|tmp_vbase_2
operator|=
name|tmp_vbase
expr_stmt|;
block|}
name|vbase_array
index|[
name|count
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|vbase_array
return|;
block|}
end_function

begin_comment
comment|/* Return the length of the virtual base list of the type DCLASS.  */
end_comment

begin_function
name|int
name|virtual_base_list_length
parameter_list|(
name|struct
name|type
modifier|*
name|dclass
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|vbase
modifier|*
name|tmp_vbase
decl_stmt|;
name|current_vbase_list
operator|=
name|NULL
expr_stmt|;
name|virtual_base_list_aux
argument_list|(
name|dclass
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tmp_vbase
operator|=
name|current_vbase_list
init|;
name|tmp_vbase
operator|!=
name|NULL
condition|;
name|i
operator|++
operator|,
name|tmp_vbase
operator|=
name|tmp_vbase
operator|->
name|next
control|)
comment|/* no body */
empty_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Return the number of elements of the virtual base list of the type    DCLASS, ignoring those appearing in the primary base (and its    primary base, recursively).  */
end_comment

begin_function
name|int
name|virtual_base_list_length_skip_primaries
parameter_list|(
name|struct
name|type
modifier|*
name|dclass
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|vbase
modifier|*
name|tmp_vbase
decl_stmt|;
name|struct
name|type
modifier|*
name|primary
decl_stmt|;
name|primary
operator|=
name|TYPE_RUNTIME_PTR
argument_list|(
name|dclass
argument_list|)
condition|?
name|TYPE_PRIMARY_BASE
argument_list|(
name|dclass
argument_list|)
else|:
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|primary
condition|)
return|return
name|virtual_base_list_length
argument_list|(
name|dclass
argument_list|)
return|;
name|current_vbase_list
operator|=
name|NULL
expr_stmt|;
name|virtual_base_list_aux
argument_list|(
name|dclass
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tmp_vbase
operator|=
name|current_vbase_list
init|;
name|tmp_vbase
operator|!=
name|NULL
condition|;
name|tmp_vbase
operator|=
name|tmp_vbase
operator|->
name|next
control|)
block|{
if|if
condition|(
name|virtual_base_index
argument_list|(
name|tmp_vbase
operator|->
name|vbasetype
argument_list|,
name|primary
argument_list|)
operator|>=
literal|0
condition|)
continue|continue;
name|i
operator|++
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Return the index (position) of type BASE, which is a virtual base    class of DCLASS, in the latter's virtual base list.  A return of -1    indicates "not found" or a problem.  */
end_comment

begin_function
name|int
name|virtual_base_index
parameter_list|(
name|struct
name|type
modifier|*
name|base
parameter_list|,
name|struct
name|type
modifier|*
name|dclass
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|vbase
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|dclass
argument_list|)
operator|!=
name|TYPE_CODE_CLASS
operator|)
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|base
argument_list|)
operator|!=
name|TYPE_CODE_CLASS
operator|)
condition|)
return|return
operator|-
literal|1
return|;
name|i
operator|=
literal|0
expr_stmt|;
name|vbase
operator|=
name|virtual_base_list
argument_list|(
name|dclass
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|vbase
condition|)
block|{
if|if
condition|(
name|vbase
operator|==
name|base
condition|)
break|break;
name|vbase
operator|=
name|virtual_base_list
argument_list|(
name|dclass
argument_list|)
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
return|return
name|vbase
condition|?
name|i
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return the index (position) of type BASE, which is a virtual base    class of DCLASS, in the latter's virtual base list. Skip over all    bases that may appear in the virtual base list of the primary base    class of DCLASS (recursively).  A return of -1 indicates "not    found" or a problem.  */
end_comment

begin_function
name|int
name|virtual_base_index_skip_primaries
parameter_list|(
name|struct
name|type
modifier|*
name|base
parameter_list|,
name|struct
name|type
modifier|*
name|dclass
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|vbase
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|type
modifier|*
name|primary
decl_stmt|;
if|if
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|dclass
argument_list|)
operator|!=
name|TYPE_CODE_CLASS
operator|)
operator|||
operator|(
name|TYPE_CODE
argument_list|(
name|base
argument_list|)
operator|!=
name|TYPE_CODE_CLASS
operator|)
condition|)
return|return
operator|-
literal|1
return|;
name|primary
operator|=
name|TYPE_RUNTIME_PTR
argument_list|(
name|dclass
argument_list|)
condition|?
name|TYPE_PRIMARY_BASE
argument_list|(
name|dclass
argument_list|)
else|:
name|NULL
expr_stmt|;
name|j
operator|=
operator|-
literal|1
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|vbase
operator|=
name|virtual_base_list
argument_list|(
name|dclass
argument_list|)
index|[
literal|0
index|]
expr_stmt|;
while|while
condition|(
name|vbase
condition|)
block|{
if|if
condition|(
operator|!
name|primary
operator|||
operator|(
name|virtual_base_index_skip_primaries
argument_list|(
name|vbase
argument_list|,
name|primary
argument_list|)
operator|<
literal|0
operator|)
condition|)
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|vbase
operator|==
name|base
condition|)
break|break;
name|vbase
operator|=
name|virtual_base_list
argument_list|(
name|dclass
argument_list|)
index|[
operator|++
name|i
index|]
expr_stmt|;
block|}
return|return
name|vbase
condition|?
name|j
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return position of a derived class DCLASS in the list of  * primary bases starting with the remotest ancestor.  * Position returned is 0-based. */
end_comment

begin_function
name|int
name|class_index_in_primary_list
parameter_list|(
name|struct
name|type
modifier|*
name|dclass
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|pbc
decl_stmt|;
comment|/* primary base class */
comment|/* Simply recurse on primary base */
name|pbc
operator|=
name|TYPE_PRIMARY_BASE
argument_list|(
name|dclass
argument_list|)
expr_stmt|;
if|if
condition|(
name|pbc
condition|)
return|return
literal|1
operator|+
name|class_index_in_primary_list
argument_list|(
name|pbc
argument_list|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return a count of the number of virtual functions a type has.  * This includes all the virtual functions it inherits from its  * base classes too.  */
end_comment

begin_comment
comment|/* pai: FIXME This doesn't do the right thing: count redefined virtual  * functions only once (latest redefinition)  */
end_comment

begin_function
name|int
name|count_virtual_fns
parameter_list|(
name|struct
name|type
modifier|*
name|dclass
parameter_list|)
block|{
name|int
name|fn
decl_stmt|,
name|oi
decl_stmt|;
comment|/* function and overloaded instance indices */
name|int
name|vfuncs
decl_stmt|;
comment|/* count to return */
comment|/* recurse on bases that can share virtual table */
name|struct
name|type
modifier|*
name|pbc
init|=
name|primary_base_class
argument_list|(
name|dclass
argument_list|)
decl_stmt|;
if|if
condition|(
name|pbc
condition|)
name|vfuncs
operator|=
name|count_virtual_fns
argument_list|(
name|pbc
argument_list|)
expr_stmt|;
else|else
name|vfuncs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|fn
operator|=
literal|0
init|;
name|fn
operator|<
name|TYPE_NFN_FIELDS
argument_list|(
name|dclass
argument_list|)
condition|;
name|fn
operator|++
control|)
for|for
control|(
name|oi
operator|=
literal|0
init|;
name|oi
operator|<
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|dclass
argument_list|,
name|fn
argument_list|)
condition|;
name|oi
operator|++
control|)
if|if
condition|(
name|TYPE_FN_FIELD_VIRTUAL_P
argument_list|(
name|TYPE_FN_FIELDLIST1
argument_list|(
name|dclass
argument_list|,
name|fn
argument_list|)
argument_list|,
name|oi
argument_list|)
condition|)
name|vfuncs
operator|++
expr_stmt|;
return|return
name|vfuncs
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions for overload resolution begin here */
end_comment

begin_comment
comment|/* Compare two badness vectors A and B and return the result.  * 0 => A and B are identical  * 1 => A and B are incomparable  * 2 => A is better than B  * 3 => A is worse than B */
end_comment

begin_function
name|int
name|compare_badness
parameter_list|(
name|struct
name|badness_vector
modifier|*
name|a
parameter_list|,
name|struct
name|badness_vector
modifier|*
name|b
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|short
name|found_pos
init|=
literal|0
decl_stmt|;
comment|/* any positives in c? */
name|short
name|found_neg
init|=
literal|0
decl_stmt|;
comment|/* any negatives in c? */
comment|/* differing lengths => incomparable */
if|if
condition|(
name|a
operator|->
name|length
operator|!=
name|b
operator|->
name|length
condition|)
return|return
literal|1
return|;
comment|/* Subtract b from a */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|a
operator|->
name|length
condition|;
name|i
operator|++
control|)
block|{
name|tmp
operator|=
name|a
operator|->
name|rank
index|[
name|i
index|]
operator|-
name|b
operator|->
name|rank
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|tmp
operator|>
literal|0
condition|)
name|found_pos
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|tmp
operator|<
literal|0
condition|)
name|found_neg
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|found_pos
condition|)
block|{
if|if
condition|(
name|found_neg
condition|)
return|return
literal|1
return|;
comment|/* incomparable */
else|else
return|return
literal|3
return|;
comment|/* A> B */
block|}
else|else
comment|/* no positives */
block|{
if|if
condition|(
name|found_neg
condition|)
return|return
literal|2
return|;
comment|/* A< B */
else|else
return|return
literal|0
return|;
comment|/* A == B */
block|}
block|}
end_function

begin_comment
comment|/* Rank a function by comparing its parameter types (PARMS, length NPARMS),  * to the types of an argument list (ARGS, length NARGS).  * Return a pointer to a badness vector. This has NARGS + 1 entries. */
end_comment

begin_function
name|struct
name|badness_vector
modifier|*
name|rank_function
parameter_list|(
name|struct
name|type
modifier|*
modifier|*
name|parms
parameter_list|,
name|int
name|nparms
parameter_list|,
name|struct
name|type
modifier|*
modifier|*
name|args
parameter_list|,
name|int
name|nargs
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|badness_vector
modifier|*
name|bv
decl_stmt|;
name|int
name|min_len
init|=
name|nparms
operator|<
name|nargs
condition|?
name|nparms
else|:
name|nargs
decl_stmt|;
name|bv
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|badness_vector
argument_list|)
argument_list|)
expr_stmt|;
name|bv
operator|->
name|length
operator|=
name|nargs
operator|+
literal|1
expr_stmt|;
comment|/* add 1 for the length-match rank */
name|bv
operator|->
name|rank
operator|=
name|xmalloc
argument_list|(
operator|(
name|nargs
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* First compare the lengths of the supplied lists.    * If there is a mismatch, set it to a high value. */
comment|/* pai/1997-06-03 FIXME: when we have debug info about default    * arguments and ellipsis parameter lists, we should consider those    * and rank the length-match more finely. */
name|LENGTH_MATCH
argument_list|(
name|bv
argument_list|)
operator|=
operator|(
name|nargs
operator|!=
name|nparms
operator|)
condition|?
name|LENGTH_MISMATCH_BADNESS
else|:
literal|0
expr_stmt|;
comment|/* Now rank all the parameters of the candidate function */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|min_len
condition|;
name|i
operator|++
control|)
name|bv
operator|->
name|rank
index|[
name|i
index|]
operator|=
name|rank_one_type
argument_list|(
name|parms
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
name|args
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* If more arguments than parameters, add dummy entries */
for|for
control|(
name|i
operator|=
name|min_len
operator|+
literal|1
init|;
name|i
operator|<=
name|nargs
condition|;
name|i
operator|++
control|)
name|bv
operator|->
name|rank
index|[
name|i
index|]
operator|=
name|TOO_FEW_PARAMS_BADNESS
expr_stmt|;
return|return
name|bv
return|;
block|}
end_function

begin_comment
comment|/* Compare the names of two integer types, assuming that any sign    qualifiers have been checked already.  We do it this way because    there may be an "int" in the name of one of the types.  */
end_comment

begin_function
specifier|static
name|int
name|integer_types_same_name_p
parameter_list|(
specifier|const
name|char
modifier|*
name|first
parameter_list|,
specifier|const
name|char
modifier|*
name|second
parameter_list|)
block|{
name|int
name|first_p
decl_stmt|,
name|second_p
decl_stmt|;
comment|/* If both are shorts, return 1; if neither is a short, keep checking.  */
name|first_p
operator|=
operator|(
name|strstr
argument_list|(
name|first
argument_list|,
literal|"short"
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
name|second_p
operator|=
operator|(
name|strstr
argument_list|(
name|second
argument_list|,
literal|"short"
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|first_p
operator|&&
name|second_p
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|first_p
operator|||
name|second_p
condition|)
return|return
literal|0
return|;
comment|/* Likewise for long.  */
name|first_p
operator|=
operator|(
name|strstr
argument_list|(
name|first
argument_list|,
literal|"long"
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
name|second_p
operator|=
operator|(
name|strstr
argument_list|(
name|second
argument_list|,
literal|"long"
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|first_p
operator|&&
name|second_p
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|first_p
operator|||
name|second_p
condition|)
return|return
literal|0
return|;
comment|/* Likewise for char.  */
name|first_p
operator|=
operator|(
name|strstr
argument_list|(
name|first
argument_list|,
literal|"char"
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
name|second_p
operator|=
operator|(
name|strstr
argument_list|(
name|second
argument_list|,
literal|"char"
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|first_p
operator|&&
name|second_p
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|first_p
operator|||
name|second_p
condition|)
return|return
literal|0
return|;
comment|/* They must both be ints.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Compare one type (PARM) for compatibility with another (ARG).  * PARM is intended to be the parameter type of a function; and  * ARG is the supplied argument's type.  This function tests if  * the latter can be converted to the former.  *  * Return 0 if they are identical types;  * Otherwise, return an integer which corresponds to how compatible  * PARM is to ARG. The higher the return value, the worse the match.  * Generally the "bad" conversions are all uniformly assigned a 100 */
end_comment

begin_function
name|int
name|rank_one_type
parameter_list|(
name|struct
name|type
modifier|*
name|parm
parameter_list|,
name|struct
name|type
modifier|*
name|arg
parameter_list|)
block|{
comment|/* Identical type pointers */
comment|/* However, this still doesn't catch all cases of same type for arg    * and param. The reason is that builtin types are different from    * the same ones constructed from the object. */
if|if
condition|(
name|parm
operator|==
name|arg
condition|)
return|return
literal|0
return|;
comment|/* Resolve typedefs */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TYPE_CODE_TYPEDEF
condition|)
name|parm
operator|=
name|check_typedef
argument_list|(
name|parm
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TYPE_CODE_TYPEDEF
condition|)
name|arg
operator|=
name|check_typedef
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/*      Well, damnit, if the names are exactly the same,      i'll say they are exactly the same. This happens when we generate      method stubs. The types won't point to the same address, but they      really are the same.   */
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|parm
argument_list|)
operator|&&
name|TYPE_NAME
argument_list|(
name|arg
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|TYPE_NAME
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TYPE_NAME
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Check if identical after resolving typedefs */
if|if
condition|(
name|parm
operator|==
name|arg
condition|)
return|return
literal|0
return|;
comment|/* See through references, since we can almost make non-references      references. */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|arg
argument_list|)
operator|==
name|TYPE_CODE_REF
condition|)
return|return
operator|(
name|rank_one_type
argument_list|(
name|parm
argument_list|,
name|TYPE_TARGET_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|+
name|REFERENCE_CONVERSION_BADNESS
operator|)
return|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|parm
argument_list|)
operator|==
name|TYPE_CODE_REF
condition|)
return|return
operator|(
name|rank_one_type
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|arg
argument_list|)
operator|+
name|REFERENCE_CONVERSION_BADNESS
operator|)
return|;
if|if
condition|(
name|overload_debug
condition|)
comment|/* Debugging only. */
name|fprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"------ Arg is %s [%d], parm is %s [%d]\n"
argument_list|,
name|TYPE_NAME
argument_list|(
name|arg
argument_list|)
argument_list|,
name|TYPE_CODE
argument_list|(
name|arg
argument_list|)
argument_list|,
name|TYPE_NAME
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TYPE_CODE
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* x -> y means arg of type x being supplied for parameter of type y */
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|parm
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_PTR
case|:
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_PTR
case|:
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_VOID
condition|)
return|return
name|VOID_PTR_CONVERSION_BADNESS
return|;
else|else
return|return
name|rank_one_type
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TYPE_TARGET_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
return|;
case|case
name|TYPE_CODE_ARRAY
case|:
return|return
name|rank_one_type
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TYPE_TARGET_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
return|;
case|case
name|TYPE_CODE_FUNC
case|:
return|return
name|rank_one_type
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|arg
argument_list|)
return|;
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_ENUM
case|:
case|case
name|TYPE_CODE_CHAR
case|:
case|case
name|TYPE_CODE_RANGE
case|:
case|case
name|TYPE_CODE_BOOL
case|:
return|return
name|POINTER_CONVERSION_BADNESS
return|;
default|default:
return|return
name|INCOMPATIBLE_TYPE_BADNESS
return|;
block|}
case|case
name|TYPE_CODE_ARRAY
case|:
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_PTR
case|:
case|case
name|TYPE_CODE_ARRAY
case|:
return|return
name|rank_one_type
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TYPE_TARGET_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|INCOMPATIBLE_TYPE_BADNESS
return|;
block|}
case|case
name|TYPE_CODE_FUNC
case|:
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_PTR
case|:
comment|/* funcptr -> func */
return|return
name|rank_one_type
argument_list|(
name|parm
argument_list|,
name|TYPE_TARGET_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|INCOMPATIBLE_TYPE_BADNESS
return|;
block|}
case|case
name|TYPE_CODE_INT
case|:
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_INT
case|:
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|arg
argument_list|)
operator|==
name|TYPE_LENGTH
argument_list|(
name|parm
argument_list|)
condition|)
block|{
comment|/* Deal with signed, unsigned, and plain chars and 	         signed and unsigned ints */
if|if
condition|(
name|TYPE_NOSIGN
argument_list|(
name|parm
argument_list|)
condition|)
block|{
comment|/* This case only for character types */
if|if
condition|(
name|TYPE_NOSIGN
argument_list|(
name|arg
argument_list|)
condition|)
comment|/* plain char -> plain char */
return|return
literal|0
return|;
else|else
return|return
name|INTEGER_CONVERSION_BADNESS
return|;
comment|/* signed/unsigned char -> plain char */
block|}
elseif|else
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|parm
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|arg
argument_list|)
condition|)
block|{
comment|/* unsigned int -> unsigned int, or unsigned long -> unsigned long */
if|if
condition|(
name|integer_types_same_name_p
argument_list|(
name|TYPE_NAME
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TYPE_NAME
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|integer_types_same_name_p
argument_list|(
name|TYPE_NAME
argument_list|(
name|arg
argument_list|)
argument_list|,
literal|"int"
argument_list|)
operator|&&
name|integer_types_same_name_p
argument_list|(
name|TYPE_NAME
argument_list|(
name|parm
argument_list|)
argument_list|,
literal|"long"
argument_list|)
condition|)
return|return
name|INTEGER_PROMOTION_BADNESS
return|;
comment|/* unsigned int -> unsigned long */
else|else
return|return
name|INTEGER_CONVERSION_BADNESS
return|;
comment|/* unsigned long -> unsigned int */
block|}
else|else
block|{
if|if
condition|(
name|integer_types_same_name_p
argument_list|(
name|TYPE_NAME
argument_list|(
name|arg
argument_list|)
argument_list|,
literal|"long"
argument_list|)
operator|&&
name|integer_types_same_name_p
argument_list|(
name|TYPE_NAME
argument_list|(
name|parm
argument_list|)
argument_list|,
literal|"int"
argument_list|)
condition|)
return|return
name|INTEGER_CONVERSION_BADNESS
return|;
comment|/* signed long -> unsigned int */
else|else
return|return
name|INTEGER_CONVERSION_BADNESS
return|;
comment|/* signed int/long -> unsigned int/long */
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|TYPE_NOSIGN
argument_list|(
name|arg
argument_list|)
operator|&&
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|arg
argument_list|)
condition|)
block|{
if|if
condition|(
name|integer_types_same_name_p
argument_list|(
name|TYPE_NAME
argument_list|(
name|parm
argument_list|)
argument_list|,
name|TYPE_NAME
argument_list|(
name|arg
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|integer_types_same_name_p
argument_list|(
name|TYPE_NAME
argument_list|(
name|arg
argument_list|)
argument_list|,
literal|"int"
argument_list|)
operator|&&
name|integer_types_same_name_p
argument_list|(
name|TYPE_NAME
argument_list|(
name|parm
argument_list|)
argument_list|,
literal|"long"
argument_list|)
condition|)
return|return
name|INTEGER_PROMOTION_BADNESS
return|;
else|else
return|return
name|INTEGER_CONVERSION_BADNESS
return|;
block|}
else|else
return|return
name|INTEGER_CONVERSION_BADNESS
return|;
block|}
elseif|else
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|arg
argument_list|)
operator|<
name|TYPE_LENGTH
argument_list|(
name|parm
argument_list|)
condition|)
return|return
name|INTEGER_PROMOTION_BADNESS
return|;
else|else
return|return
name|INTEGER_CONVERSION_BADNESS
return|;
case|case
name|TYPE_CODE_ENUM
case|:
case|case
name|TYPE_CODE_CHAR
case|:
case|case
name|TYPE_CODE_RANGE
case|:
case|case
name|TYPE_CODE_BOOL
case|:
return|return
name|INTEGER_PROMOTION_BADNESS
return|;
case|case
name|TYPE_CODE_FLT
case|:
return|return
name|INT_FLOAT_CONVERSION_BADNESS
return|;
case|case
name|TYPE_CODE_PTR
case|:
return|return
name|NS_POINTER_CONVERSION_BADNESS
return|;
default|default:
return|return
name|INCOMPATIBLE_TYPE_BADNESS
return|;
block|}
break|break;
case|case
name|TYPE_CODE_ENUM
case|:
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_CHAR
case|:
case|case
name|TYPE_CODE_RANGE
case|:
case|case
name|TYPE_CODE_BOOL
case|:
case|case
name|TYPE_CODE_ENUM
case|:
return|return
name|INTEGER_CONVERSION_BADNESS
return|;
case|case
name|TYPE_CODE_FLT
case|:
return|return
name|INT_FLOAT_CONVERSION_BADNESS
return|;
default|default:
return|return
name|INCOMPATIBLE_TYPE_BADNESS
return|;
block|}
break|break;
case|case
name|TYPE_CODE_CHAR
case|:
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_RANGE
case|:
case|case
name|TYPE_CODE_BOOL
case|:
case|case
name|TYPE_CODE_ENUM
case|:
return|return
name|INTEGER_CONVERSION_BADNESS
return|;
case|case
name|TYPE_CODE_FLT
case|:
return|return
name|INT_FLOAT_CONVERSION_BADNESS
return|;
case|case
name|TYPE_CODE_INT
case|:
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|arg
argument_list|)
operator|>
name|TYPE_LENGTH
argument_list|(
name|parm
argument_list|)
condition|)
return|return
name|INTEGER_CONVERSION_BADNESS
return|;
elseif|else
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|arg
argument_list|)
operator|<
name|TYPE_LENGTH
argument_list|(
name|parm
argument_list|)
condition|)
return|return
name|INTEGER_PROMOTION_BADNESS
return|;
comment|/*>>> !! else fall through !!<<< */
case|case
name|TYPE_CODE_CHAR
case|:
comment|/* Deal with signed, unsigned, and plain chars for C++ 	     and with int cases falling through from previous case */
if|if
condition|(
name|TYPE_NOSIGN
argument_list|(
name|parm
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_NOSIGN
argument_list|(
name|arg
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
return|return
name|INTEGER_CONVERSION_BADNESS
return|;
block|}
elseif|else
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|parm
argument_list|)
condition|)
block|{
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|arg
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
return|return
name|INTEGER_PROMOTION_BADNESS
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|TYPE_NOSIGN
argument_list|(
name|arg
argument_list|)
operator|&&
operator|!
name|TYPE_UNSIGNED
argument_list|(
name|arg
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
return|return
name|INTEGER_CONVERSION_BADNESS
return|;
default|default:
return|return
name|INCOMPATIBLE_TYPE_BADNESS
return|;
block|}
break|break;
case|case
name|TYPE_CODE_RANGE
case|:
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_CHAR
case|:
case|case
name|TYPE_CODE_RANGE
case|:
case|case
name|TYPE_CODE_BOOL
case|:
case|case
name|TYPE_CODE_ENUM
case|:
return|return
name|INTEGER_CONVERSION_BADNESS
return|;
case|case
name|TYPE_CODE_FLT
case|:
return|return
name|INT_FLOAT_CONVERSION_BADNESS
return|;
default|default:
return|return
name|INCOMPATIBLE_TYPE_BADNESS
return|;
block|}
break|break;
case|case
name|TYPE_CODE_BOOL
case|:
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_CHAR
case|:
case|case
name|TYPE_CODE_RANGE
case|:
case|case
name|TYPE_CODE_ENUM
case|:
case|case
name|TYPE_CODE_FLT
case|:
case|case
name|TYPE_CODE_PTR
case|:
return|return
name|BOOLEAN_CONVERSION_BADNESS
return|;
case|case
name|TYPE_CODE_BOOL
case|:
return|return
literal|0
return|;
default|default:
return|return
name|INCOMPATIBLE_TYPE_BADNESS
return|;
block|}
break|break;
case|case
name|TYPE_CODE_FLT
case|:
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_FLT
case|:
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|arg
argument_list|)
operator|<
name|TYPE_LENGTH
argument_list|(
name|parm
argument_list|)
condition|)
return|return
name|FLOAT_PROMOTION_BADNESS
return|;
elseif|else
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|arg
argument_list|)
operator|==
name|TYPE_LENGTH
argument_list|(
name|parm
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
return|return
name|FLOAT_CONVERSION_BADNESS
return|;
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_BOOL
case|:
case|case
name|TYPE_CODE_ENUM
case|:
case|case
name|TYPE_CODE_RANGE
case|:
case|case
name|TYPE_CODE_CHAR
case|:
return|return
name|INT_FLOAT_CONVERSION_BADNESS
return|;
default|default:
return|return
name|INCOMPATIBLE_TYPE_BADNESS
return|;
block|}
break|break;
case|case
name|TYPE_CODE_COMPLEX
case|:
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
comment|/* Strictly not needed for C++, but... */
case|case
name|TYPE_CODE_FLT
case|:
return|return
name|FLOAT_PROMOTION_BADNESS
return|;
case|case
name|TYPE_CODE_COMPLEX
case|:
return|return
literal|0
return|;
default|default:
return|return
name|INCOMPATIBLE_TYPE_BADNESS
return|;
block|}
break|break;
case|case
name|TYPE_CODE_STRUCT
case|:
comment|/* currently same as TYPE_CODE_CLASS */
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_STRUCT
case|:
comment|/* Check for derivation */
if|if
condition|(
name|is_ancestor
argument_list|(
name|parm
argument_list|,
name|arg
argument_list|)
condition|)
return|return
name|BASE_CONVERSION_BADNESS
return|;
comment|/* else fall through */
default|default:
return|return
name|INCOMPATIBLE_TYPE_BADNESS
return|;
block|}
break|break;
case|case
name|TYPE_CODE_UNION
case|:
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_UNION
case|:
default|default:
return|return
name|INCOMPATIBLE_TYPE_BADNESS
return|;
block|}
break|break;
case|case
name|TYPE_CODE_MEMBER
case|:
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
default|default:
return|return
name|INCOMPATIBLE_TYPE_BADNESS
return|;
block|}
break|break;
case|case
name|TYPE_CODE_METHOD
case|:
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
default|default:
return|return
name|INCOMPATIBLE_TYPE_BADNESS
return|;
block|}
break|break;
case|case
name|TYPE_CODE_REF
case|:
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
default|default:
return|return
name|INCOMPATIBLE_TYPE_BADNESS
return|;
block|}
break|break;
case|case
name|TYPE_CODE_SET
case|:
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|arg
argument_list|)
condition|)
block|{
comment|/* Not in C++ */
case|case
name|TYPE_CODE_SET
case|:
return|return
name|rank_one_type
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|parm
argument_list|,
literal|0
argument_list|)
argument_list|,
name|TYPE_FIELD_TYPE
argument_list|(
name|arg
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|INCOMPATIBLE_TYPE_BADNESS
return|;
block|}
break|break;
case|case
name|TYPE_CODE_VOID
case|:
default|default:
return|return
name|INCOMPATIBLE_TYPE_BADNESS
return|;
block|}
comment|/* switch (TYPE_CODE (arg)) */
block|}
end_function

begin_comment
comment|/* End of functions for overload resolution */
end_comment

begin_function
specifier|static
name|void
name|print_bit_vector
parameter_list|(
name|B_TYPE
modifier|*
name|bits
parameter_list|,
name|int
name|nbits
parameter_list|)
block|{
name|int
name|bitno
decl_stmt|;
for|for
control|(
name|bitno
operator|=
literal|0
init|;
name|bitno
operator|<
name|nbits
condition|;
name|bitno
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|bitno
operator|%
literal|8
operator|)
operator|==
literal|0
condition|)
block|{
name|puts_filtered
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|B_TST
argument_list|(
name|bits
argument_list|,
name|bitno
argument_list|)
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"1"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Note the first arg should be the "this" pointer, we may not want to    include it since we may get into a infinitely recursive situation.  */
end_comment

begin_function
specifier|static
name|void
name|print_arg_types
parameter_list|(
name|struct
name|field
modifier|*
name|args
parameter_list|,
name|int
name|nargs
parameter_list|,
name|int
name|spaces
parameter_list|)
block|{
if|if
condition|(
name|args
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
name|recursive_dump_type
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|type
argument_list|,
name|spaces
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dump_fn_fieldlists
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|spaces
parameter_list|)
block|{
name|int
name|method_idx
decl_stmt|;
name|int
name|overload_idx
decl_stmt|;
name|struct
name|fn_field
modifier|*
name|f
decl_stmt|;
name|printfi_filtered
argument_list|(
name|spaces
argument_list|,
literal|"fn_fieldlists "
argument_list|)
expr_stmt|;
name|gdb_print_host_address
argument_list|(
name|TYPE_FN_FIELDLISTS
argument_list|(
name|type
argument_list|)
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|method_idx
operator|=
literal|0
init|;
name|method_idx
operator|<
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
condition|;
name|method_idx
operator|++
control|)
block|{
name|f
operator|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|type
argument_list|,
name|method_idx
argument_list|)
expr_stmt|;
name|printfi_filtered
argument_list|(
name|spaces
operator|+
literal|2
argument_list|,
literal|"[%d] name '%s' ("
argument_list|,
name|method_idx
argument_list|,
name|TYPE_FN_FIELDLIST_NAME
argument_list|(
name|type
argument_list|,
name|method_idx
argument_list|)
argument_list|)
expr_stmt|;
name|gdb_print_host_address
argument_list|(
name|TYPE_FN_FIELDLIST_NAME
argument_list|(
name|type
argument_list|,
name|method_idx
argument_list|)
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|") length %d\n"
argument_list|,
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|type
argument_list|,
name|method_idx
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|overload_idx
operator|=
literal|0
init|;
name|overload_idx
operator|<
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|type
argument_list|,
name|method_idx
argument_list|)
condition|;
name|overload_idx
operator|++
control|)
block|{
name|printfi_filtered
argument_list|(
name|spaces
operator|+
literal|4
argument_list|,
literal|"[%d] physname '%s' ("
argument_list|,
name|overload_idx
argument_list|,
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|overload_idx
argument_list|)
argument_list|)
expr_stmt|;
name|gdb_print_host_address
argument_list|(
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|overload_idx
argument_list|)
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
name|printfi_filtered
argument_list|(
name|spaces
operator|+
literal|8
argument_list|,
literal|"type "
argument_list|)
expr_stmt|;
name|gdb_print_host_address
argument_list|(
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|f
argument_list|,
name|overload_idx
argument_list|)
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|recursive_dump_type
argument_list|(
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|f
argument_list|,
name|overload_idx
argument_list|)
argument_list|,
name|spaces
operator|+
literal|8
operator|+
literal|2
argument_list|)
expr_stmt|;
name|printfi_filtered
argument_list|(
name|spaces
operator|+
literal|8
argument_list|,
literal|"args "
argument_list|)
expr_stmt|;
name|gdb_print_host_address
argument_list|(
name|TYPE_FN_FIELD_ARGS
argument_list|(
name|f
argument_list|,
name|overload_idx
argument_list|)
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|print_arg_types
argument_list|(
name|TYPE_FN_FIELD_ARGS
argument_list|(
name|f
argument_list|,
name|overload_idx
argument_list|)
argument_list|,
name|TYPE_NFIELDS
argument_list|(
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|f
argument_list|,
name|overload_idx
argument_list|)
argument_list|)
argument_list|,
name|spaces
argument_list|)
expr_stmt|;
name|printfi_filtered
argument_list|(
name|spaces
operator|+
literal|8
argument_list|,
literal|"fcontext "
argument_list|)
expr_stmt|;
name|gdb_print_host_address
argument_list|(
name|TYPE_FN_FIELD_FCONTEXT
argument_list|(
name|f
argument_list|,
name|overload_idx
argument_list|)
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printfi_filtered
argument_list|(
name|spaces
operator|+
literal|8
argument_list|,
literal|"is_const %d\n"
argument_list|,
name|TYPE_FN_FIELD_CONST
argument_list|(
name|f
argument_list|,
name|overload_idx
argument_list|)
argument_list|)
expr_stmt|;
name|printfi_filtered
argument_list|(
name|spaces
operator|+
literal|8
argument_list|,
literal|"is_volatile %d\n"
argument_list|,
name|TYPE_FN_FIELD_VOLATILE
argument_list|(
name|f
argument_list|,
name|overload_idx
argument_list|)
argument_list|)
expr_stmt|;
name|printfi_filtered
argument_list|(
name|spaces
operator|+
literal|8
argument_list|,
literal|"is_private %d\n"
argument_list|,
name|TYPE_FN_FIELD_PRIVATE
argument_list|(
name|f
argument_list|,
name|overload_idx
argument_list|)
argument_list|)
expr_stmt|;
name|printfi_filtered
argument_list|(
name|spaces
operator|+
literal|8
argument_list|,
literal|"is_protected %d\n"
argument_list|,
name|TYPE_FN_FIELD_PROTECTED
argument_list|(
name|f
argument_list|,
name|overload_idx
argument_list|)
argument_list|)
expr_stmt|;
name|printfi_filtered
argument_list|(
name|spaces
operator|+
literal|8
argument_list|,
literal|"is_stub %d\n"
argument_list|,
name|TYPE_FN_FIELD_STUB
argument_list|(
name|f
argument_list|,
name|overload_idx
argument_list|)
argument_list|)
expr_stmt|;
name|printfi_filtered
argument_list|(
name|spaces
operator|+
literal|8
argument_list|,
literal|"voffset %u\n"
argument_list|,
name|TYPE_FN_FIELD_VOFFSET
argument_list|(
name|f
argument_list|,
name|overload_idx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_cplus_stuff
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|spaces
parameter_list|)
block|{
name|printfi_filtered
argument_list|(
name|spaces
argument_list|,
literal|"n_baseclasses %d\n"
argument_list|,
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|printfi_filtered
argument_list|(
name|spaces
argument_list|,
literal|"nfn_fields %d\n"
argument_list|,
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|printfi_filtered
argument_list|(
name|spaces
argument_list|,
literal|"nfn_fields_total %d\n"
argument_list|,
name|TYPE_NFN_FIELDS_TOTAL
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|>
literal|0
condition|)
block|{
name|printfi_filtered
argument_list|(
name|spaces
argument_list|,
literal|"virtual_field_bits (%d bits at *"
argument_list|,
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|gdb_print_host_address
argument_list|(
name|TYPE_FIELD_VIRTUAL_BITS
argument_list|(
name|type
argument_list|)
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
name|print_bit_vector
argument_list|(
name|TYPE_FIELD_VIRTUAL_BITS
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|TYPE_FIELD_PRIVATE_BITS
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|printfi_filtered
argument_list|(
name|spaces
argument_list|,
literal|"private_field_bits (%d bits at *"
argument_list|,
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|gdb_print_host_address
argument_list|(
name|TYPE_FIELD_PRIVATE_BITS
argument_list|(
name|type
argument_list|)
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
name|print_bit_vector
argument_list|(
name|TYPE_FIELD_PRIVATE_BITS
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_FIELD_PROTECTED_BITS
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|printfi_filtered
argument_list|(
name|spaces
argument_list|,
literal|"protected_field_bits (%d bits at *"
argument_list|,
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|gdb_print_host_address
argument_list|(
name|TYPE_FIELD_PROTECTED_BITS
argument_list|(
name|type
argument_list|)
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
name|print_bit_vector
argument_list|(
name|TYPE_FIELD_PROTECTED_BITS
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
operator|>
literal|0
condition|)
block|{
name|dump_fn_fieldlists
argument_list|(
name|type
argument_list|,
name|spaces
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_bound_type
parameter_list|(
name|int
name|bt
parameter_list|)
block|{
switch|switch
condition|(
name|bt
condition|)
block|{
case|case
name|BOUND_CANNOT_BE_DETERMINED
case|:
name|printf_filtered
argument_list|(
literal|"(BOUND_CANNOT_BE_DETERMINED)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BOUND_BY_REF_ON_STACK
case|:
name|printf_filtered
argument_list|(
literal|"(BOUND_BY_REF_ON_STACK)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BOUND_BY_VALUE_ON_STACK
case|:
name|printf_filtered
argument_list|(
literal|"(BOUND_BY_VALUE_ON_STACK)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BOUND_BY_REF_IN_REG
case|:
name|printf_filtered
argument_list|(
literal|"(BOUND_BY_REF_IN_REG)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BOUND_BY_VALUE_IN_REG
case|:
name|printf_filtered
argument_list|(
literal|"(BOUND_BY_VALUE_IN_REG)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BOUND_SIMPLE
case|:
name|printf_filtered
argument_list|(
literal|"(BOUND_SIMPLE)"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf_filtered
argument_list|(
literal|"(unknown bound type)"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|dont_print_type_obstack
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|recursive_dump_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|spaces
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
if|if
condition|(
name|spaces
operator|==
literal|0
condition|)
name|obstack_begin
argument_list|(
operator|&
name|dont_print_type_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|>
literal|0
operator|||
operator|(
name|TYPE_CPLUS_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|&&
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
operator|>
literal|0
operator|)
condition|)
block|{
name|struct
name|type
modifier|*
modifier|*
name|first_dont_print
init|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|dont_print_type_obstack
argument_list|)
decl_stmt|;
name|int
name|i
init|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|obstack_next_free
argument_list|(
operator|&
name|dont_print_type_obstack
argument_list|)
operator|-
name|first_dont_print
decl_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|first_dont_print
index|[
name|i
index|]
condition|)
block|{
name|printfi_filtered
argument_list|(
name|spaces
argument_list|,
literal|"type node "
argument_list|)
expr_stmt|;
name|gdb_print_host_address
argument_list|(
name|type
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"<same as already seen type>\n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|obstack_ptr_grow
argument_list|(
operator|&
name|dont_print_type_obstack
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
name|printfi_filtered
argument_list|(
name|spaces
argument_list|,
literal|"type node "
argument_list|)
expr_stmt|;
name|gdb_print_host_address
argument_list|(
name|type
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printfi_filtered
argument_list|(
name|spaces
argument_list|,
literal|"name '%s' ("
argument_list|,
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
condition|?
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
else|:
literal|"<NULL>"
argument_list|)
expr_stmt|;
name|gdb_print_host_address
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
name|printfi_filtered
argument_list|(
name|spaces
argument_list|,
literal|"tagname '%s' ("
argument_list|,
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
condition|?
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
else|:
literal|"<NULL>"
argument_list|)
expr_stmt|;
name|gdb_print_host_address
argument_list|(
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
name|printfi_filtered
argument_list|(
name|spaces
argument_list|,
literal|"code 0x%x "
argument_list|,
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_UNDEF
case|:
name|printf_filtered
argument_list|(
literal|"(TYPE_CODE_UNDEF)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_PTR
case|:
name|printf_filtered
argument_list|(
literal|"(TYPE_CODE_PTR)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_ARRAY
case|:
name|printf_filtered
argument_list|(
literal|"(TYPE_CODE_ARRAY)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_STRUCT
case|:
name|printf_filtered
argument_list|(
literal|"(TYPE_CODE_STRUCT)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_UNION
case|:
name|printf_filtered
argument_list|(
literal|"(TYPE_CODE_UNION)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_ENUM
case|:
name|printf_filtered
argument_list|(
literal|"(TYPE_CODE_ENUM)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_FUNC
case|:
name|printf_filtered
argument_list|(
literal|"(TYPE_CODE_FUNC)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_INT
case|:
name|printf_filtered
argument_list|(
literal|"(TYPE_CODE_INT)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_FLT
case|:
name|printf_filtered
argument_list|(
literal|"(TYPE_CODE_FLT)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_VOID
case|:
name|printf_filtered
argument_list|(
literal|"(TYPE_CODE_VOID)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_SET
case|:
name|printf_filtered
argument_list|(
literal|"(TYPE_CODE_SET)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_RANGE
case|:
name|printf_filtered
argument_list|(
literal|"(TYPE_CODE_RANGE)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_STRING
case|:
name|printf_filtered
argument_list|(
literal|"(TYPE_CODE_STRING)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_BITSTRING
case|:
name|printf_filtered
argument_list|(
literal|"(TYPE_CODE_BITSTRING)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_ERROR
case|:
name|printf_filtered
argument_list|(
literal|"(TYPE_CODE_ERROR)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_MEMBER
case|:
name|printf_filtered
argument_list|(
literal|"(TYPE_CODE_MEMBER)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_METHOD
case|:
name|printf_filtered
argument_list|(
literal|"(TYPE_CODE_METHOD)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_REF
case|:
name|printf_filtered
argument_list|(
literal|"(TYPE_CODE_REF)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_CHAR
case|:
name|printf_filtered
argument_list|(
literal|"(TYPE_CODE_CHAR)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_BOOL
case|:
name|printf_filtered
argument_list|(
literal|"(TYPE_CODE_BOOL)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_COMPLEX
case|:
name|printf_filtered
argument_list|(
literal|"(TYPE_CODE_COMPLEX)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_TYPEDEF
case|:
name|printf_filtered
argument_list|(
literal|"(TYPE_CODE_TYPEDEF)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_TEMPLATE
case|:
name|printf_filtered
argument_list|(
literal|"(TYPE_CODE_TEMPLATE)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_TEMPLATE_ARG
case|:
name|printf_filtered
argument_list|(
literal|"(TYPE_CODE_TEMPLATE_ARG)"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_NAMESPACE
case|:
name|printf_filtered
argument_list|(
literal|"(TYPE_CODE_NAMESPACE)"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf_filtered
argument_list|(
literal|"(UNKNOWN TYPE CODE)"
argument_list|)
expr_stmt|;
break|break;
block|}
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printfi_filtered
argument_list|(
name|spaces
argument_list|,
literal|"length %d\n"
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|printfi_filtered
argument_list|(
name|spaces
argument_list|,
literal|"upper_bound_type 0x%x "
argument_list|,
name|TYPE_ARRAY_UPPER_BOUND_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|print_bound_type
argument_list|(
name|TYPE_ARRAY_UPPER_BOUND_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printfi_filtered
argument_list|(
name|spaces
argument_list|,
literal|"lower_bound_type 0x%x "
argument_list|,
name|TYPE_ARRAY_LOWER_BOUND_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|print_bound_type
argument_list|(
name|TYPE_ARRAY_LOWER_BOUND_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printfi_filtered
argument_list|(
name|spaces
argument_list|,
literal|"objfile "
argument_list|)
expr_stmt|;
name|gdb_print_host_address
argument_list|(
name|TYPE_OBJFILE
argument_list|(
name|type
argument_list|)
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printfi_filtered
argument_list|(
name|spaces
argument_list|,
literal|"target_type "
argument_list|)
expr_stmt|;
name|gdb_print_host_address
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|recursive_dump_type
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|spaces
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
name|printfi_filtered
argument_list|(
name|spaces
argument_list|,
literal|"pointer_type "
argument_list|)
expr_stmt|;
name|gdb_print_host_address
argument_list|(
name|TYPE_POINTER_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printfi_filtered
argument_list|(
name|spaces
argument_list|,
literal|"reference_type "
argument_list|)
expr_stmt|;
name|gdb_print_host_address
argument_list|(
name|TYPE_REFERENCE_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printfi_filtered
argument_list|(
name|spaces
argument_list|,
literal|"type_chain "
argument_list|)
expr_stmt|;
name|gdb_print_host_address
argument_list|(
name|TYPE_CHAIN
argument_list|(
name|type
argument_list|)
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printfi_filtered
argument_list|(
name|spaces
argument_list|,
literal|"instance_flags 0x%x"
argument_list|,
name|TYPE_INSTANCE_FLAGS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CONST
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|puts_filtered
argument_list|(
literal|" TYPE_FLAG_CONST"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|puts_filtered
argument_list|(
literal|" TYPE_FLAG_VOLATILE"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_CODE_SPACE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|puts_filtered
argument_list|(
literal|" TYPE_FLAG_CODE_SPACE"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_DATA_SPACE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|puts_filtered
argument_list|(
literal|" TYPE_FLAG_DATA_SPACE"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_ADDRESS_CLASS_1
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|puts_filtered
argument_list|(
literal|" TYPE_FLAG_ADDRESS_CLASS_1"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_ADDRESS_CLASS_2
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|puts_filtered
argument_list|(
literal|" TYPE_FLAG_ADDRESS_CLASS_2"
argument_list|)
expr_stmt|;
block|}
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printfi_filtered
argument_list|(
name|spaces
argument_list|,
literal|"flags 0x%x"
argument_list|,
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|puts_filtered
argument_list|(
literal|" TYPE_FLAG_UNSIGNED"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_NOSIGN
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|puts_filtered
argument_list|(
literal|" TYPE_FLAG_NOSIGN"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_STUB
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|puts_filtered
argument_list|(
literal|" TYPE_FLAG_STUB"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_TARGET_STUB
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|puts_filtered
argument_list|(
literal|" TYPE_FLAG_TARGET_STUB"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_STATIC
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|puts_filtered
argument_list|(
literal|" TYPE_FLAG_STATIC"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_PROTOTYPED
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|puts_filtered
argument_list|(
literal|" TYPE_FLAG_PROTOTYPED"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_INCOMPLETE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|puts_filtered
argument_list|(
literal|" TYPE_FLAG_INCOMPLETE"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_VARARGS
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|puts_filtered
argument_list|(
literal|" TYPE_FLAG_VARARGS"
argument_list|)
expr_stmt|;
block|}
comment|/* This is used for things like AltiVec registers on ppc.  Gcc emits      an attribute for the array type, which tells whether or not we      have a vector, instead of a regular array.  */
if|if
condition|(
name|TYPE_VECTOR
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|puts_filtered
argument_list|(
literal|" TYPE_FLAG_VECTOR"
argument_list|)
expr_stmt|;
block|}
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printfi_filtered
argument_list|(
name|spaces
argument_list|,
literal|"nfields %d "
argument_list|,
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|gdb_print_host_address
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
condition|;
name|idx
operator|++
control|)
block|{
name|printfi_filtered
argument_list|(
name|spaces
operator|+
literal|2
argument_list|,
literal|"[%d] bitpos %d bitsize %d type "
argument_list|,
name|idx
argument_list|,
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|idx
argument_list|)
argument_list|,
name|TYPE_FIELD_BITSIZE
argument_list|(
name|type
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
name|gdb_print_host_address
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|idx
argument_list|)
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" name '%s' ("
argument_list|,
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|idx
argument_list|)
operator|!=
name|NULL
condition|?
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|idx
argument_list|)
else|:
literal|"<NULL>"
argument_list|)
expr_stmt|;
name|gdb_print_host_address
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|idx
argument_list|)
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|")\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|idx
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|recursive_dump_type
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|idx
argument_list|)
argument_list|,
name|spaces
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
name|printfi_filtered
argument_list|(
name|spaces
argument_list|,
literal|"vptr_basetype "
argument_list|)
expr_stmt|;
name|gdb_print_host_address
argument_list|(
name|TYPE_VPTR_BASETYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_VPTR_BASETYPE
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|recursive_dump_type
argument_list|(
name|TYPE_VPTR_BASETYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|spaces
operator|+
literal|2
argument_list|)
expr_stmt|;
block|}
name|printfi_filtered
argument_list|(
name|spaces
argument_list|,
literal|"vptr_fieldno %d\n"
argument_list|,
name|TYPE_VPTR_FIELDNO
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_STRUCT
case|:
name|printfi_filtered
argument_list|(
name|spaces
argument_list|,
literal|"cplus_stuff "
argument_list|)
expr_stmt|;
name|gdb_print_host_address
argument_list|(
name|TYPE_CPLUS_SPECIFIC
argument_list|(
name|type
argument_list|)
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|print_cplus_stuff
argument_list|(
name|type
argument_list|,
name|spaces
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_FLT
case|:
name|printfi_filtered
argument_list|(
name|spaces
argument_list|,
literal|"floatformat "
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FLOATFORMAT
argument_list|(
name|type
argument_list|)
operator|==
name|NULL
operator|||
name|TYPE_FLOATFORMAT
argument_list|(
name|type
argument_list|)
operator|->
name|name
operator|==
name|NULL
condition|)
name|puts_filtered
argument_list|(
literal|"(null)"
argument_list|)
expr_stmt|;
else|else
name|puts_filtered
argument_list|(
name|TYPE_FLOATFORMAT
argument_list|(
name|type
argument_list|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* We have to pick one of the union types to be able print and test          the value.  Pick cplus_struct_type, even though we know it isn't          any particular one. */
name|printfi_filtered
argument_list|(
name|spaces
argument_list|,
literal|"type_specific "
argument_list|)
expr_stmt|;
name|gdb_print_host_address
argument_list|(
name|TYPE_CPLUS_SPECIFIC
argument_list|(
name|type
argument_list|)
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CPLUS_SPECIFIC
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|printf_filtered
argument_list|(
literal|" (unknown data form)"
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|spaces
operator|==
literal|0
condition|)
name|obstack_free
argument_list|(
operator|&
name|dont_print_type_obstack
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|build_gdbtypes
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|build_gdbtypes
parameter_list|(
name|void
parameter_list|)
block|{
name|builtin_type_void
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_VOID
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"void"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_char
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
operator|(
name|TYPE_FLAG_NOSIGN
operator||
operator|(
name|TARGET_CHAR_SIGNED
condition|?
literal|0
else|:
name|TYPE_FLAG_UNSIGNED
operator|)
operator|)
argument_list|,
literal|"char"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_true_char
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_CHAR
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"true character"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_signed_char
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"signed char"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_unsigned_char
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned char"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_short
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_SHORT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"short"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_unsigned_short
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_SHORT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned short"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_int
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"int"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_unsigned_int
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned int"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_long
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"long"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_unsigned_long
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned long"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_long_long
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"long long"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_unsigned_long_long
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned long long"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_float
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_FLOAT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"float"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* vinschen@redhat.com 2002-02-08:    The below lines are disabled since they are doing the wrong    thing for non-multiarch targets.  They are setting the correct    type of floats for the target but while on multiarch targets    this is done everytime the architecture changes, it's done on    non-multiarch targets only on startup, leaving the wrong values    in even if the architecture changes (eg. from big-endian to    little-endian).  */
if|#
directive|if
literal|0
block|TYPE_FLOATFORMAT (builtin_type_float) = TARGET_FLOAT_FORMAT;
endif|#
directive|endif
name|builtin_type_double
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"double"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|TYPE_FLOATFORMAT (builtin_type_double) = TARGET_DOUBLE_FORMAT;
endif|#
directive|endif
name|builtin_type_long_double
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_LONG_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"long double"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|TYPE_FLOATFORMAT (builtin_type_long_double) = TARGET_LONG_DOUBLE_FORMAT;
endif|#
directive|endif
name|builtin_type_complex
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_COMPLEX
argument_list|,
literal|2
operator|*
name|TARGET_FLOAT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"complex"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|builtin_type_complex
argument_list|)
operator|=
name|builtin_type_float
expr_stmt|;
name|builtin_type_double_complex
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_COMPLEX
argument_list|,
literal|2
operator|*
name|TARGET_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"double complex"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|builtin_type_double_complex
argument_list|)
operator|=
name|builtin_type_double
expr_stmt|;
name|builtin_type_string
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_STRING
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"string"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_int0
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|0
operator|/
literal|8
argument_list|,
literal|0
argument_list|,
literal|"int0_t"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_int8
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|8
operator|/
literal|8
argument_list|,
literal|0
argument_list|,
literal|"int8_t"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_uint8
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|8
operator|/
literal|8
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"uint8_t"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_int16
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|16
operator|/
literal|8
argument_list|,
literal|0
argument_list|,
literal|"int16_t"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_uint16
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|16
operator|/
literal|8
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"uint16_t"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_int32
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|32
operator|/
literal|8
argument_list|,
literal|0
argument_list|,
literal|"int32_t"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_uint32
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|32
operator|/
literal|8
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"uint32_t"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_int64
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|64
operator|/
literal|8
argument_list|,
literal|0
argument_list|,
literal|"int64_t"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_uint64
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|64
operator|/
literal|8
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"uint64_t"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_int128
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|128
operator|/
literal|8
argument_list|,
literal|0
argument_list|,
literal|"int128_t"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_uint128
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|128
operator|/
literal|8
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"uint128_t"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_bool
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_BOOL
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"bool"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* Add user knob for controlling resolution of opaque types */
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"opaque-type-resolution"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|opaque_type_resolution
argument_list|,
literal|"Set resolution of opaque struct/class/union types (if set before loading symbols)."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|opaque_type_resolution
operator|=
literal|1
expr_stmt|;
comment|/* Build SIMD types.  */
name|builtin_type_v4sf
operator|=
name|init_simd_type
argument_list|(
literal|"__builtin_v4sf"
argument_list|,
name|builtin_type_float
argument_list|,
literal|"f"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|builtin_type_v4si
operator|=
name|init_simd_type
argument_list|(
literal|"__builtin_v4si"
argument_list|,
name|builtin_type_int32
argument_list|,
literal|"f"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|builtin_type_v16qi
operator|=
name|init_simd_type
argument_list|(
literal|"__builtin_v16qi"
argument_list|,
name|builtin_type_int8
argument_list|,
literal|"f"
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|builtin_type_v8qi
operator|=
name|init_simd_type
argument_list|(
literal|"__builtin_v8qi"
argument_list|,
name|builtin_type_int8
argument_list|,
literal|"f"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|builtin_type_v8hi
operator|=
name|init_simd_type
argument_list|(
literal|"__builtin_v8hi"
argument_list|,
name|builtin_type_int16
argument_list|,
literal|"f"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|builtin_type_v4hi
operator|=
name|init_simd_type
argument_list|(
literal|"__builtin_v4hi"
argument_list|,
name|builtin_type_int16
argument_list|,
literal|"f"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|builtin_type_v2si
operator|=
name|init_simd_type
argument_list|(
literal|"__builtin_v2si"
argument_list|,
name|builtin_type_int32
argument_list|,
literal|"f"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* 128 bit vectors.  */
name|builtin_type_v2_double
operator|=
name|init_vector_type
argument_list|(
name|builtin_type_double
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|builtin_type_v4_float
operator|=
name|init_vector_type
argument_list|(
name|builtin_type_float
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|builtin_type_v2_int64
operator|=
name|init_vector_type
argument_list|(
name|builtin_type_int64
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|builtin_type_v4_int32
operator|=
name|init_vector_type
argument_list|(
name|builtin_type_int32
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|builtin_type_v8_int16
operator|=
name|init_vector_type
argument_list|(
name|builtin_type_int16
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|builtin_type_v16_int8
operator|=
name|init_vector_type
argument_list|(
name|builtin_type_int8
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* 64 bit vectors.  */
name|builtin_type_v2_float
operator|=
name|init_vector_type
argument_list|(
name|builtin_type_float
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|builtin_type_v2_int32
operator|=
name|init_vector_type
argument_list|(
name|builtin_type_int32
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|builtin_type_v4_int16
operator|=
name|init_vector_type
argument_list|(
name|builtin_type_int16
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|builtin_type_v8_int8
operator|=
name|init_vector_type
argument_list|(
name|builtin_type_int8
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* Vector types.  */
name|builtin_type_vec64
operator|=
name|build_builtin_type_vec64
argument_list|()
expr_stmt|;
name|builtin_type_vec64i
operator|=
name|build_builtin_type_vec64i
argument_list|()
expr_stmt|;
name|builtin_type_vec128
operator|=
name|build_builtin_type_vec128
argument_list|()
expr_stmt|;
name|builtin_type_vec128i
operator|=
name|build_builtin_type_vec128i
argument_list|()
expr_stmt|;
comment|/* Pointer/Address types. */
comment|/* NOTE: on some targets, addresses and pointers are not necessarily      the same --- for example, on the D10V, pointers are 16 bits long,      but addresses are 32 bits long.  See doc/gdbint.texinfo,      ``Pointers Are Not Always Addresses''.       The upshot is:      - gdb's `struct type' always describes the target's        representation.      - gdb's `struct value' objects should always hold values in        target form.      - gdb's CORE_ADDR values are addresses in the unified virtual        address space that the assembler and linker work with.  Thus,        since target_read_memory takes a CORE_ADDR as an argument, it        can access any memory on the target, even if the processor has        separate code and data address spaces.       So, for example:      - If v is a value holding a D10V code pointer, its contents are        in target form: a big-endian address left-shifted two bits.      - If p is a D10V pointer type, TYPE_LENGTH (p) == 2, just as        sizeof (void *) == 2 on the target.       In this context, builtin_type_CORE_ADDR is a bit odd: it's a      target type for a value the target will never see.  It's only      used to hold the values of (typeless) linker symbols, which are      indeed in the unified virtual address space.  */
name|builtin_type_void_data_ptr
operator|=
name|make_pointer_type
argument_list|(
name|builtin_type_void
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_void_func_ptr
operator|=
name|lookup_pointer_type
argument_list|(
name|lookup_function_type
argument_list|(
name|builtin_type_void
argument_list|)
argument_list|)
expr_stmt|;
name|builtin_type_CORE_ADDR
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_ADDR_BIT
operator|/
literal|8
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"__CORE_ADDR"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_bfd_vma
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_BFD_VMA_BIT
operator|/
literal|8
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"__bfd_vma"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|extern
name|void
name|_initialize_gdbtypes
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|_initialize_gdbtypes
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|build_gdbtypes
argument_list|()
expr_stmt|;
comment|/* FIXME - For the moment, handle types by swapping them in and out.      Should be using the per-architecture data-pointer and a large      struct. */
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_void
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_char
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_short
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_int
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_long
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_long_long
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_signed_char
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_unsigned_char
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_unsigned_short
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_unsigned_int
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_unsigned_long
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_unsigned_long_long
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_float
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_double
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_long_double
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_complex
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_double_complex
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_string
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_int8
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_uint8
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_int16
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_uint16
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_int32
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_uint32
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_int64
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_uint64
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_int128
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_uint128
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_v4sf
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_v4si
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_v16qi
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_v8qi
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_v8hi
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_v4hi
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_v2si
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_v2_double
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_v4_float
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_v2_int64
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_v4_int32
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_v8_int16
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_v16_int8
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_v2_float
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_v2_int32
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_v8_int8
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_v4_int16
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_vec128
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_vec128i
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_void_data_ptr
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_void_func_ptr
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_CORE_ADDR
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_bfd_vma
argument_list|)
expr_stmt|;
name|deprecated_register_gdbarch_swap
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|build_gdbtypes
argument_list|)
expr_stmt|;
comment|/* Note: These types do not need to be swapped - they are target      neutral.  */
name|builtin_type_ieee_single_big
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|floatformat_ieee_single_big
operator|.
name|totalsize
operator|/
literal|8
argument_list|,
literal|0
argument_list|,
literal|"builtin_type_ieee_single_big"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TYPE_FLOATFORMAT
argument_list|(
name|builtin_type_ieee_single_big
argument_list|)
operator|=
operator|&
name|floatformat_ieee_single_big
expr_stmt|;
name|builtin_type_ieee_single_little
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|floatformat_ieee_single_little
operator|.
name|totalsize
operator|/
literal|8
argument_list|,
literal|0
argument_list|,
literal|"builtin_type_ieee_single_little"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TYPE_FLOATFORMAT
argument_list|(
name|builtin_type_ieee_single_little
argument_list|)
operator|=
operator|&
name|floatformat_ieee_single_little
expr_stmt|;
name|builtin_type_ieee_double_big
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|floatformat_ieee_double_big
operator|.
name|totalsize
operator|/
literal|8
argument_list|,
literal|0
argument_list|,
literal|"builtin_type_ieee_double_big"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TYPE_FLOATFORMAT
argument_list|(
name|builtin_type_ieee_double_big
argument_list|)
operator|=
operator|&
name|floatformat_ieee_double_big
expr_stmt|;
name|builtin_type_ieee_double_little
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|floatformat_ieee_double_little
operator|.
name|totalsize
operator|/
literal|8
argument_list|,
literal|0
argument_list|,
literal|"builtin_type_ieee_double_little"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TYPE_FLOATFORMAT
argument_list|(
name|builtin_type_ieee_double_little
argument_list|)
operator|=
operator|&
name|floatformat_ieee_double_little
expr_stmt|;
name|builtin_type_ieee_double_littlebyte_bigword
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|floatformat_ieee_double_littlebyte_bigword
operator|.
name|totalsize
operator|/
literal|8
argument_list|,
literal|0
argument_list|,
literal|"builtin_type_ieee_double_littlebyte_bigword"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TYPE_FLOATFORMAT
argument_list|(
name|builtin_type_ieee_double_littlebyte_bigword
argument_list|)
operator|=
operator|&
name|floatformat_ieee_double_littlebyte_bigword
expr_stmt|;
name|builtin_type_i387_ext
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|floatformat_i387_ext
operator|.
name|totalsize
operator|/
literal|8
argument_list|,
literal|0
argument_list|,
literal|"builtin_type_i387_ext"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TYPE_FLOATFORMAT
argument_list|(
name|builtin_type_i387_ext
argument_list|)
operator|=
operator|&
name|floatformat_i387_ext
expr_stmt|;
name|builtin_type_m68881_ext
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|floatformat_m68881_ext
operator|.
name|totalsize
operator|/
literal|8
argument_list|,
literal|0
argument_list|,
literal|"builtin_type_m68881_ext"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TYPE_FLOATFORMAT
argument_list|(
name|builtin_type_m68881_ext
argument_list|)
operator|=
operator|&
name|floatformat_m68881_ext
expr_stmt|;
name|builtin_type_i960_ext
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|floatformat_i960_ext
operator|.
name|totalsize
operator|/
literal|8
argument_list|,
literal|0
argument_list|,
literal|"builtin_type_i960_ext"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TYPE_FLOATFORMAT
argument_list|(
name|builtin_type_i960_ext
argument_list|)
operator|=
operator|&
name|floatformat_i960_ext
expr_stmt|;
name|builtin_type_m88110_ext
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|floatformat_m88110_ext
operator|.
name|totalsize
operator|/
literal|8
argument_list|,
literal|0
argument_list|,
literal|"builtin_type_m88110_ext"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TYPE_FLOATFORMAT
argument_list|(
name|builtin_type_m88110_ext
argument_list|)
operator|=
operator|&
name|floatformat_m88110_ext
expr_stmt|;
name|builtin_type_m88110_harris_ext
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|floatformat_m88110_harris_ext
operator|.
name|totalsize
operator|/
literal|8
argument_list|,
literal|0
argument_list|,
literal|"builtin_type_m88110_harris_ext"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TYPE_FLOATFORMAT
argument_list|(
name|builtin_type_m88110_harris_ext
argument_list|)
operator|=
operator|&
name|floatformat_m88110_harris_ext
expr_stmt|;
name|builtin_type_arm_ext_big
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|floatformat_arm_ext_big
operator|.
name|totalsize
operator|/
literal|8
argument_list|,
literal|0
argument_list|,
literal|"builtin_type_arm_ext_big"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TYPE_FLOATFORMAT
argument_list|(
name|builtin_type_arm_ext_big
argument_list|)
operator|=
operator|&
name|floatformat_arm_ext_big
expr_stmt|;
name|builtin_type_arm_ext_littlebyte_bigword
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|floatformat_arm_ext_littlebyte_bigword
operator|.
name|totalsize
operator|/
literal|8
argument_list|,
literal|0
argument_list|,
literal|"builtin_type_arm_ext_littlebyte_bigword"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TYPE_FLOATFORMAT
argument_list|(
name|builtin_type_arm_ext_littlebyte_bigword
argument_list|)
operator|=
operator|&
name|floatformat_arm_ext_littlebyte_bigword
expr_stmt|;
name|builtin_type_ia64_spill_big
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|floatformat_ia64_spill_big
operator|.
name|totalsize
operator|/
literal|8
argument_list|,
literal|0
argument_list|,
literal|"builtin_type_ia64_spill_big"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TYPE_FLOATFORMAT
argument_list|(
name|builtin_type_ia64_spill_big
argument_list|)
operator|=
operator|&
name|floatformat_ia64_spill_big
expr_stmt|;
name|builtin_type_ia64_spill_little
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|floatformat_ia64_spill_little
operator|.
name|totalsize
operator|/
literal|8
argument_list|,
literal|0
argument_list|,
literal|"builtin_type_ia64_spill_little"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TYPE_FLOATFORMAT
argument_list|(
name|builtin_type_ia64_spill_little
argument_list|)
operator|=
operator|&
name|floatformat_ia64_spill_little
expr_stmt|;
name|builtin_type_ia64_quad_big
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|floatformat_ia64_quad_big
operator|.
name|totalsize
operator|/
literal|8
argument_list|,
literal|0
argument_list|,
literal|"builtin_type_ia64_quad_big"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TYPE_FLOATFORMAT
argument_list|(
name|builtin_type_ia64_quad_big
argument_list|)
operator|=
operator|&
name|floatformat_ia64_quad_big
expr_stmt|;
name|builtin_type_ia64_quad_little
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|floatformat_ia64_quad_little
operator|.
name|totalsize
operator|/
literal|8
argument_list|,
literal|0
argument_list|,
literal|"builtin_type_ia64_quad_little"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TYPE_FLOATFORMAT
argument_list|(
name|builtin_type_ia64_quad_little
argument_list|)
operator|=
operator|&
name|floatformat_ia64_quad_little
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"overload"
argument_list|,
name|no_class
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|overload_debug
argument_list|,
literal|"Set debugging of C++ overloading.\n\ 			  When enabled, ranking of the functions\n\ 			  is displayed."
argument_list|,
operator|&
name|setdebuglist
argument_list|)
argument_list|,
operator|&
name|showdebuglist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

