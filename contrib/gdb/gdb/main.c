begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Top level stuff for GDB, the GNU debugger.     Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,    1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software    Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"top.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"event-loop.h"
end_include

begin_include
include|#
directive|include
file|"ui-out.h"
end_include

begin_include
include|#
directive|include
file|"interps.h"
end_include

begin_include
include|#
directive|include
file|"main.h"
end_include

begin_comment
comment|/* If nonzero, display time usage both at startup and for each command.  */
end_comment

begin_decl_stmt
name|int
name|display_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, display space usage both at startup and for each command.  */
end_comment

begin_decl_stmt
name|int
name|display_space
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether this is the async version or not.  The async version is    invoked on the command line with the -nw --async options.  In this    version, the usual command_loop is substituted by and event loop which    processes UI events asynchronously. */
end_comment

begin_decl_stmt
name|int
name|event_loop_p
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The selected interpreter.  This will be used as a set command    variable, so it should always be malloc'ed - since    do_setshow_command will free it. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|interpreter_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether xdb commands will be handled */
end_comment

begin_decl_stmt
name|int
name|xdb_commands
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether dbx commands will be handled */
end_comment

begin_decl_stmt
name|int
name|dbx_commands
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* System root path, used to find libraries etc.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|gdb_sysroot
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ui_file
modifier|*
name|gdb_stdout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ui_file
modifier|*
name|gdb_stderr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ui_file
modifier|*
name|gdb_stdlog
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ui_file
modifier|*
name|gdb_stdin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* target IO streams */
end_comment

begin_decl_stmt
name|struct
name|ui_file
modifier|*
name|gdb_stdtargin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ui_file
modifier|*
name|gdb_stdtarg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ui_file
modifier|*
name|gdb_stdtargerr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether to enable writing into executable and core files */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|write_files
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|print_gdb_help
parameter_list|(
name|struct
name|ui_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* These two are used to set the external editor commands when gdb is farming    out files to be edited by another program. */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|external_editor_command
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Call command_loop.  If it happens to return, pass that through as a    non-zero return status. */
end_comment

begin_function
specifier|static
name|int
name|captured_command_loop
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|current_interp_command_loop
argument_list|()
expr_stmt|;
comment|/* FIXME: cagney/1999-11-05: A correct command_loop() implementaton      would clean things up (restoring the cleanup chain) to the state      they were just prior to the call.  Technically, this means that      the do_cleanups() below is redundant.  Unfortunately, many FUNCs      are not that well behaved.  do_cleanups should either be replaced      with a do_cleanups call (to cover the problem) or an assertion      check to detect bad FUNCs code. */
name|do_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
comment|/* If the command_loop returned, normally (rather than threw an      error) we try to quit. If the quit is aborted, catch_errors()      which called this catch the signal and restart the command      loop. */
name|quit_command
argument_list|(
name|NULL
argument_list|,
name|instream
operator|==
name|stdin
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|captured_main
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|captured_main_args
modifier|*
name|context
init|=
name|data
decl_stmt|;
name|int
name|argc
init|=
name|context
operator|->
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
init|=
name|context
operator|->
name|argv
decl_stmt|;
name|int
name|count
decl_stmt|;
specifier|static
name|int
name|quiet
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|batch
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|set_args
init|=
literal|0
decl_stmt|;
comment|/* Pointers to various arguments from command line.  */
name|char
modifier|*
name|symarg
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|execarg
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|corearg
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|cdarg
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|ttyarg
init|=
name|NULL
decl_stmt|;
comment|/* These are static so that we can take their address in an initializer.  */
specifier|static
name|int
name|print_help
decl_stmt|;
specifier|static
name|int
name|print_version
decl_stmt|;
comment|/* Pointers to all arguments of --command option.  */
name|char
modifier|*
modifier|*
name|cmdarg
decl_stmt|;
comment|/* Allocated size of cmdarg.  */
name|int
name|cmdsize
decl_stmt|;
comment|/* Number of elements of cmdarg used.  */
name|int
name|ncmd
decl_stmt|;
comment|/* Indices of all arguments of --directory option.  */
name|char
modifier|*
modifier|*
name|dirarg
decl_stmt|;
comment|/* Allocated size.  */
name|int
name|dirsize
decl_stmt|;
comment|/* Number of elements used.  */
name|int
name|ndir
decl_stmt|;
name|struct
name|stat
name|homebuf
decl_stmt|,
name|cwdbuf
decl_stmt|;
name|char
modifier|*
name|homedir
decl_stmt|,
modifier|*
name|homeinit
decl_stmt|;
name|int
name|i
decl_stmt|;
name|long
name|time_at_startup
init|=
name|get_run_time
argument_list|()
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETLOCALE
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_LC_MESSAGES
argument_list|)
name|setlocale
argument_list|(
name|LC_MESSAGES
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SETLOCALE
argument_list|)
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bindtextdomain
argument_list|(
name|PACKAGE
argument_list|,
name|LOCALEDIR
argument_list|)
expr_stmt|;
name|textdomain
argument_list|(
name|PACKAGE
argument_list|)
expr_stmt|;
comment|/* This needs to happen before the first use of malloc.  */
name|init_malloc
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SBRK
name|lim_at_start
operator|=
operator|(
name|char
operator|*
operator|)
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|ALIGN_STACK_ON_STARTUP
argument_list|)
name|i
operator|=
operator|(
name|int
operator|)
operator|&
name|count
operator|&
literal|0x3
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|alloca
argument_list|(
literal|4
operator|-
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cmdsize
operator|=
literal|1
expr_stmt|;
name|cmdarg
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|cmdsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cmdarg
argument_list|)
argument_list|)
expr_stmt|;
name|ncmd
operator|=
literal|0
expr_stmt|;
name|dirsize
operator|=
literal|1
expr_stmt|;
name|dirarg
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|dirsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dirarg
argument_list|)
argument_list|)
expr_stmt|;
name|ndir
operator|=
literal|0
expr_stmt|;
name|quit_flag
operator|=
literal|0
expr_stmt|;
name|line
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|linesize
argument_list|)
expr_stmt|;
name|line
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Terminate saved (now empty) cmd line */
name|instream
operator|=
name|stdin
expr_stmt|;
name|getcwd
argument_list|(
name|gdb_dirbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|gdb_dirbuf
argument_list|)
argument_list|)
expr_stmt|;
name|current_directory
operator|=
name|gdb_dirbuf
expr_stmt|;
name|gdb_stdout
operator|=
name|stdio_fileopen
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|gdb_stderr
operator|=
name|stdio_fileopen
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|gdb_stdlog
operator|=
name|gdb_stderr
expr_stmt|;
comment|/* for moment */
name|gdb_stdtarg
operator|=
name|gdb_stderr
expr_stmt|;
comment|/* for moment */
name|gdb_stdin
operator|=
name|stdio_fileopen
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|gdb_stdtargerr
operator|=
name|gdb_stderr
expr_stmt|;
comment|/* for moment */
name|gdb_stdtargin
operator|=
name|gdb_stdin
expr_stmt|;
comment|/* for moment */
comment|/* initialize error() */
name|error_init
argument_list|()
expr_stmt|;
comment|/* Set the sysroot path.  */
ifdef|#
directive|ifdef
name|TARGET_SYSTEM_ROOT_RELOCATABLE
name|gdb_sysroot
operator|=
name|make_relative_prefix
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|BINDIR
argument_list|,
name|TARGET_SYSTEM_ROOT
argument_list|)
expr_stmt|;
if|if
condition|(
name|gdb_sysroot
condition|)
block|{
name|struct
name|stat
name|s
decl_stmt|;
name|int
name|res
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|gdb_sysroot
argument_list|,
operator|&
name|s
argument_list|)
operator|==
literal|0
condition|)
if|if
condition|(
name|S_ISDIR
argument_list|(
name|s
operator|.
name|st_mode
argument_list|)
condition|)
name|res
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|res
operator|==
literal|0
condition|)
block|{
name|xfree
argument_list|(
name|gdb_sysroot
argument_list|)
expr_stmt|;
name|gdb_sysroot
operator|=
name|TARGET_SYSTEM_ROOT
expr_stmt|;
block|}
block|}
else|else
name|gdb_sysroot
operator|=
name|TARGET_SYSTEM_ROOT
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|TARGET_SYSTEM_ROOT
argument_list|)
name|gdb_sysroot
operator|=
name|TARGET_SYSTEM_ROOT
expr_stmt|;
else|#
directive|else
name|gdb_sysroot
operator|=
literal|""
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* There will always be an interpreter.  Either the one passed into      this captured main, or one specified by the user at start up, or      the console.  Initialize the interpreter to the one requested by       the application.  */
name|interpreter_p
operator|=
name|xstrdup
argument_list|(
name|context
operator|->
name|interpreter_p
argument_list|)
expr_stmt|;
comment|/* Parse arguments and options.  */
block|{
name|int
name|c
decl_stmt|;
comment|/* When var field is 0, use flag field to record the equivalent        short option (or arbitrary numbers starting at 10 for those        with no equivalent).  */
enum|enum
block|{
name|OPT_SE
init|=
literal|10
block|,
name|OPT_CD
block|,
name|OPT_ANNOTATE
block|,
name|OPT_STATISTICS
block|,
name|OPT_TUI
block|,
name|OPT_NOWINDOWS
block|,
name|OPT_WINDOWS
block|}
enum|;
specifier|static
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"async"
block|,
name|no_argument
block|,
operator|&
name|event_loop_p
block|,
literal|1
block|}
block|,
block|{
literal|"noasync"
block|,
name|no_argument
block|,
operator|&
name|event_loop_p
block|,
literal|0
block|}
block|,
if|#
directive|if
name|defined
argument_list|(
name|TUI
argument_list|)
block|{
literal|"tui"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPT_TUI
block|}
block|,
endif|#
directive|endif
block|{
literal|"xdb"
block|,
name|no_argument
block|,
operator|&
name|xdb_commands
block|,
literal|1
block|}
block|,
block|{
literal|"dbx"
block|,
name|no_argument
block|,
operator|&
name|dbx_commands
block|,
literal|1
block|}
block|,
block|{
literal|"readnow"
block|,
name|no_argument
block|,
operator|&
name|readnow_symbol_files
block|,
literal|1
block|}
block|,
block|{
literal|"r"
block|,
name|no_argument
block|,
operator|&
name|readnow_symbol_files
block|,
literal|1
block|}
block|,
block|{
literal|"quiet"
block|,
name|no_argument
block|,
operator|&
name|quiet
block|,
literal|1
block|}
block|,
block|{
literal|"q"
block|,
name|no_argument
block|,
operator|&
name|quiet
block|,
literal|1
block|}
block|,
block|{
literal|"silent"
block|,
name|no_argument
block|,
operator|&
name|quiet
block|,
literal|1
block|}
block|,
block|{
literal|"nx"
block|,
name|no_argument
block|,
operator|&
name|inhibit_gdbinit
block|,
literal|1
block|}
block|,
block|{
literal|"n"
block|,
name|no_argument
block|,
operator|&
name|inhibit_gdbinit
block|,
literal|1
block|}
block|,
block|{
literal|"batch"
block|,
name|no_argument
block|,
operator|&
name|batch
block|,
literal|1
block|}
block|,
block|{
literal|"epoch"
block|,
name|no_argument
block|,
operator|&
name|epoch_interface
block|,
literal|1
block|}
block|,
comment|/* This is a synonym for "--annotate=1".  --annotate is now preferred,        but keep this here for a long time because people will be running        emacses which use --fullname.  */
block|{
literal|"fullname"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'f'
block|}
block|,
block|{
literal|"f"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'f'
block|}
block|,
block|{
literal|"annotate"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPT_ANNOTATE
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
operator|&
name|print_help
block|,
literal|1
block|}
block|,
block|{
literal|"se"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPT_SE
block|}
block|,
block|{
literal|"symbols"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'s'
block|}
block|,
block|{
literal|"s"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'s'
block|}
block|,
block|{
literal|"exec"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'e'
block|}
block|,
block|{
literal|"e"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'e'
block|}
block|,
block|{
literal|"core"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'c'
block|}
block|,
block|{
literal|"c"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'c'
block|}
block|,
block|{
literal|"pid"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'p'
block|}
block|,
block|{
literal|"p"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'p'
block|}
block|,
block|{
literal|"command"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'x'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
operator|&
name|print_version
block|,
literal|1
block|}
block|,
block|{
literal|"x"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'x'
block|}
block|,
ifdef|#
directive|ifdef
name|GDBTK
block|{
literal|"tclcommand"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'z'
block|}
block|,
block|{
literal|"enable-external-editor"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'y'
block|}
block|,
block|{
literal|"editor-command"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'w'
block|}
block|,
endif|#
directive|endif
block|{
literal|"ui"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'i'
block|}
block|,
block|{
literal|"interpreter"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'i'
block|}
block|,
block|{
literal|"i"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'i'
block|}
block|,
block|{
literal|"directory"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'d'
block|}
block|,
block|{
literal|"d"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'d'
block|}
block|,
block|{
literal|"cd"
block|,
name|required_argument
block|,
literal|0
block|,
name|OPT_CD
block|}
block|,
block|{
literal|"tty"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'t'
block|}
block|,
block|{
literal|"baud"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'b'
block|}
block|,
block|{
literal|"b"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'b'
block|}
block|,
block|{
literal|"nw"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPT_NOWINDOWS
block|}
block|,
block|{
literal|"nowindows"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPT_NOWINDOWS
block|}
block|,
block|{
literal|"w"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPT_WINDOWS
block|}
block|,
block|{
literal|"windows"
block|,
name|no_argument
block|,
name|NULL
block|,
name|OPT_WINDOWS
block|}
block|,
block|{
literal|"statistics"
block|,
name|no_argument
block|,
literal|0
block|,
name|OPT_STATISTICS
block|}
block|,
block|{
literal|"write"
block|,
name|no_argument
block|,
operator|&
name|write_files
block|,
literal|1
block|}
block|,
block|{
literal|"args"
block|,
name|no_argument
block|,
operator|&
name|set_args
block|,
literal|1
block|}
block|,
block|{
literal|0
block|,
name|no_argument
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|option_index
decl_stmt|;
name|c
operator|=
name|getopt_long_only
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|""
argument_list|,
name|long_options
argument_list|,
operator|&
name|option_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
operator|||
name|set_args
condition|)
break|break;
comment|/* Long option that takes an argument.  */
if|if
condition|(
name|c
operator|==
literal|0
operator|&&
name|long_options
index|[
name|option_index
index|]
operator|.
name|flag
operator|==
literal|0
condition|)
name|c
operator|=
name|long_options
index|[
name|option_index
index|]
operator|.
name|val
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|0
case|:
comment|/* Long option that just sets a flag.  */
break|break;
case|case
name|OPT_SE
case|:
name|symarg
operator|=
name|optarg
expr_stmt|;
name|execarg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
name|OPT_CD
case|:
name|cdarg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
name|OPT_ANNOTATE
case|:
comment|/* FIXME: what if the syntax is wrong (e.g. not digits)?  */
name|annotation_level
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_STATISTICS
case|:
comment|/* Enable the display of both time and space usage.  */
name|display_time
operator|=
literal|1
expr_stmt|;
name|display_space
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_TUI
case|:
comment|/* --tui is equivalent to -i=tui.  */
name|xfree
argument_list|(
name|interpreter_p
argument_list|)
expr_stmt|;
name|interpreter_p
operator|=
name|xstrdup
argument_list|(
literal|"tui"
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPT_WINDOWS
case|:
comment|/* FIXME: cagney/2003-03-01: Not sure if this option is                actually useful, and if it is, what it should do.  */
name|use_windows
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OPT_NOWINDOWS
case|:
comment|/* -nw is equivalent to -i=console.  */
name|xfree
argument_list|(
name|interpreter_p
argument_list|)
expr_stmt|;
name|interpreter_p
operator|=
name|xstrdup
argument_list|(
name|INTERP_CONSOLE
argument_list|)
expr_stmt|;
name|use_windows
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|annotation_level
operator|=
literal|1
expr_stmt|;
comment|/* We have probably been invoked from emacs.  Disable window interface.  */
name|use_windows
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|symarg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|execarg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|corearg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* "corearg" is shared by "--core" and "--pid" */
name|corearg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|cmdarg
index|[
name|ncmd
operator|++
index|]
operator|=
name|optarg
expr_stmt|;
if|if
condition|(
name|ncmd
operator|>=
name|cmdsize
condition|)
block|{
name|cmdsize
operator|*=
literal|2
expr_stmt|;
name|cmdarg
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cmdarg
argument_list|,
name|cmdsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cmdarg
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|GDBTK
case|case
literal|'z'
case|:
block|{
specifier|extern
name|int
name|gdbtk_test
argument_list|(
name|char
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|gdbtk_test
argument_list|(
name|optarg
argument_list|)
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
name|_
argument_list|(
literal|"%s: unable to load tclcommand file \"%s\""
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|'y'
case|:
comment|/* Backwards compatibility only.  */
break|break;
case|case
literal|'w'
case|:
block|{
name|external_editor_command
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* GDBTK */
case|case
literal|'i'
case|:
name|xfree
argument_list|(
name|interpreter_p
argument_list|)
expr_stmt|;
name|interpreter_p
operator|=
name|xstrdup
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|dirarg
index|[
name|ndir
operator|++
index|]
operator|=
name|optarg
expr_stmt|;
if|if
condition|(
name|ndir
operator|>=
name|dirsize
condition|)
block|{
name|dirsize
operator|*=
literal|2
expr_stmt|;
name|dirarg
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dirarg
argument_list|,
name|dirsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dirarg
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'t'
case|:
name|ttyarg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|i
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|&
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|p
operator|==
name|optarg
condition|)
comment|/* Don't use *_filtered or warning() (which relies on 		   current_target) until after initialize_all_files(). */
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
name|_
argument_list|(
literal|"warning: could not set baud rate to `%s'.\n"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
else|else
name|baud_rate
operator|=
name|i
expr_stmt|;
block|}
break|break;
case|case
literal|'l'
case|:
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|i
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|&
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|p
operator|==
name|optarg
condition|)
comment|/* Don't use *_filtered or warning() (which relies on 		   current_target) until after initialize_all_files(). */
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
name|_
argument_list|(
literal|"warning: could not set timeout limit to `%s'.\n"
argument_list|)
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
else|else
name|remote_timeout
operator|=
name|i
expr_stmt|;
block|}
break|break;
case|case
literal|'?'
case|:
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
name|_
argument_list|(
literal|"Use `%s --help' for a complete list of options.\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If --help or --version, disable window interface.  */
if|if
condition|(
name|print_help
operator|||
name|print_version
condition|)
block|{
name|use_windows
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|set_args
condition|)
block|{
comment|/* The remaining options are the command-line options for the 	   inferior.  The first one is the sym/exec file, and the rest 	   are arguments.  */
if|if
condition|(
name|optind
operator|>=
name|argc
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
name|_
argument_list|(
literal|"%s: `--args' specified but no program specified\n"
argument_list|)
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|symarg
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
name|execarg
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
operator|++
name|optind
expr_stmt|;
name|set_inferior_args_vector
argument_list|(
name|argc
operator|-
name|optind
argument_list|,
operator|&
name|argv
index|[
name|optind
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* OK, that's all the options.  The other arguments are filenames.  */
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|optind
operator|<
name|argc
condition|;
name|optind
operator|++
control|)
switch|switch
condition|(
operator|++
name|count
condition|)
block|{
case|case
literal|1
case|:
name|symarg
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
name|execarg
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* The documentation says this can be a "ProcID" as well.  	         We will try it as both a corefile and a pid.  */
name|corearg
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
name|_
argument_list|(
literal|"Excess command line arguments ignored. (%s%s)\n"
argument_list|)
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|,
operator|(
name|optind
operator|==
name|argc
operator|-
literal|1
operator|)
condition|?
literal|""
else|:
literal|" ..."
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|batch
condition|)
name|quiet
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Initialize all files.  Give the interpreter a chance to take      control of the console via the init_ui_hook()) */
name|gdb_init
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Do these (and anything which might call wrap_here or *_filtered)      after initialize_all_files() but before the interpreter has been      installed.  Otherwize the help/version messages will be eaten by      the interpreter's output handler.  */
if|if
condition|(
name|print_version
condition|)
block|{
name|print_gdb_version
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|print_help
condition|)
block|{
name|print_gdb_help
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"\n"
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME: cagney/2003-02-03: The big hack (part 1 of 2) that lets      GDB retain the old MI1 interpreter startup behavior.  Output the      copyright message before the interpreter is installed.  That way      it isn't encapsulated in MI output.  */
if|if
condition|(
operator|!
name|quiet
operator|&&
name|strcmp
argument_list|(
name|interpreter_p
argument_list|,
name|INTERP_MI1
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Print all the junk at the top, with trailing "..." if we are about          to read a symbol file (possibly slowly).  */
name|print_gdb_version
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|symarg
condition|)
name|printf_filtered
argument_list|(
literal|".."
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
comment|/* Force to screen during slow operations */
block|}
comment|/* Install the default UI.  All the interpreters should have had a      look at things by now.  Initialize the default interpreter. */
block|{
comment|/* Find it.  */
name|struct
name|interp
modifier|*
name|interp
init|=
name|interp_lookup
argument_list|(
name|interpreter_p
argument_list|)
decl_stmt|;
if|if
condition|(
name|interp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Interpreter `%s' unrecognized"
argument_list|,
name|interpreter_p
argument_list|)
expr_stmt|;
comment|/* Install it.  */
if|if
condition|(
operator|!
name|interp_set
argument_list|(
name|interp
argument_list|)
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Interpreter `%s' failed to initialize.\n"
argument_list|,
name|interpreter_p
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* FIXME: cagney/2003-02-03: The big hack (part 2 of 2) that lets      GDB retain the old MI1 interpreter startup behavior.  Output the      copyright message after the interpreter is installed when it is      any sane interpreter.  */
if|if
condition|(
operator|!
name|quiet
operator|&&
operator|!
name|current_interp_named_p
argument_list|(
name|INTERP_MI1
argument_list|)
condition|)
block|{
comment|/* Print all the junk at the top, with trailing "..." if we are about          to read a symbol file (possibly slowly).  */
name|print_gdb_version
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|symarg
condition|)
name|printf_filtered
argument_list|(
literal|".."
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
comment|/* Force to screen during slow operations */
block|}
name|error_pre_print
operator|=
literal|"\n\n"
expr_stmt|;
name|quit_pre_print
operator|=
name|error_pre_print
expr_stmt|;
comment|/* We may get more than one warning, don't double space all of them... */
name|warning_pre_print
operator|=
name|_
argument_list|(
literal|"\nwarning: "
argument_list|)
expr_stmt|;
comment|/* Read and execute $HOME/.gdbinit file, if it exists.  This is done      *before* all the command line arguments are processed; it sets      global parameters, which are independent of what file you are      debugging or what directory you are in.  */
name|homedir
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|homedir
condition|)
block|{
name|homeinit
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|homedir
argument_list|)
operator|+
name|strlen
argument_list|(
name|gdbinit
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|homeinit
argument_list|,
name|homedir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|homeinit
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|homeinit
argument_list|,
name|gdbinit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inhibit_gdbinit
condition|)
block|{
name|catch_command_errors
argument_list|(
name|source_command
argument_list|,
name|homeinit
argument_list|,
literal|0
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
block|}
comment|/* Do stats; no need to do them elsewhere since we'll only          need them if homedir is set.  Make sure that they are          zero in case one of them fails (this guarantees that they          won't match if either exists).  */
name|memset
argument_list|(
operator|&
name|homebuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|stat
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cwdbuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|stat
argument_list|)
argument_list|)
expr_stmt|;
name|stat
argument_list|(
name|homeinit
argument_list|,
operator|&
name|homebuf
argument_list|)
expr_stmt|;
name|stat
argument_list|(
name|gdbinit
argument_list|,
operator|&
name|cwdbuf
argument_list|)
expr_stmt|;
comment|/* We'll only need this if 				   homedir was set.  */
block|}
comment|/* Now perform all the actions indicated by the arguments.  */
if|if
condition|(
name|cdarg
operator|!=
name|NULL
condition|)
block|{
name|catch_command_errors
argument_list|(
name|cd_command
argument_list|,
name|cdarg
argument_list|,
literal|0
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndir
condition|;
name|i
operator|++
control|)
name|catch_command_errors
argument_list|(
name|directory_command
argument_list|,
name|dirarg
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|dirarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|execarg
operator|!=
name|NULL
operator|&&
name|symarg
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|execarg
argument_list|,
name|symarg
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* The exec file and the symbol-file are the same.  If we can't          open it, better only print one error message.          catch_command_errors returns non-zero on success! */
if|if
condition|(
name|catch_command_errors
argument_list|(
name|exec_file_attach
argument_list|,
name|execarg
argument_list|,
operator|!
name|batch
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
condition|)
name|catch_command_errors
argument_list|(
name|symbol_file_add_main
argument_list|,
name|symarg
argument_list|,
literal|0
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|execarg
operator|!=
name|NULL
condition|)
name|catch_command_errors
argument_list|(
name|exec_file_attach
argument_list|,
name|execarg
argument_list|,
operator|!
name|batch
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|symarg
operator|!=
name|NULL
condition|)
name|catch_command_errors
argument_list|(
name|symbol_file_add_main
argument_list|,
name|symarg
argument_list|,
literal|0
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
block|}
comment|/* After the symbol file has been read, print a newline to get us      beyond the copyright line...  But errors should still set off      the error message with a (single) blank line.  */
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|error_pre_print
operator|=
literal|"\n"
expr_stmt|;
name|quit_pre_print
operator|=
name|error_pre_print
expr_stmt|;
name|warning_pre_print
operator|=
name|_
argument_list|(
literal|"\nwarning: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|corearg
operator|!=
name|NULL
condition|)
block|{
comment|/* corearg may be either a corefile or a pid. 	 If its first character is a digit, try attach first 	 and then corefile.  Otherwise try corefile first. */
if|if
condition|(
name|isdigit
argument_list|(
name|corearg
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|catch_command_errors
argument_list|(
name|attach_command
argument_list|,
name|corearg
argument_list|,
operator|!
name|batch
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
operator|==
literal|0
condition|)
name|catch_command_errors
argument_list|(
name|core_file_command
argument_list|,
name|corearg
argument_list|,
operator|!
name|batch
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Can't be a pid, better be a corefile. */
name|catch_command_errors
argument_list|(
name|core_file_command
argument_list|,
name|corearg
argument_list|,
operator|!
name|batch
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ttyarg
operator|!=
name|NULL
condition|)
name|catch_command_errors
argument_list|(
name|tty_command
argument_list|,
name|ttyarg
argument_list|,
operator|!
name|batch
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
comment|/* Error messages should no longer be distinguished with extra output. */
name|error_pre_print
operator|=
name|NULL
expr_stmt|;
name|quit_pre_print
operator|=
name|NULL
expr_stmt|;
name|warning_pre_print
operator|=
name|_
argument_list|(
literal|"warning: "
argument_list|)
expr_stmt|;
comment|/* Read the .gdbinit file in the current directory, *if* it isn't      the same as the $HOME/.gdbinit file (it should exist, also).  */
if|if
condition|(
operator|!
name|homedir
operator|||
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|homebuf
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|cwdbuf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|stat
argument_list|)
argument_list|)
condition|)
if|if
condition|(
operator|!
name|inhibit_gdbinit
condition|)
block|{
name|catch_command_errors
argument_list|(
name|source_command
argument_list|,
name|gdbinit
argument_list|,
literal|0
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncmd
condition|;
name|i
operator|++
control|)
block|{
if|#
directive|if
literal|0
comment|/* NOTE: cagney/1999-11-03: SET_TOP_LEVEL() was a macro that          expanded into a call to setjmp().  */
block|if (!SET_TOP_LEVEL ())
comment|/* NB: This is #if 0'd out */
block|{
comment|/* NOTE: I am commenting this out, because it is not clear 	     where this feature is used. It is very old and 	     undocumented. ezannoni: 1999-05-04 */
if|#
directive|if
literal|0
block|if (cmdarg[i][0] == '-'&& cmdarg[i][1] == '\0') 	    read_command_file (stdin); 	  else
endif|#
directive|endif
block|source_command (cmdarg[i], !batch); 	  do_cleanups (ALL_CLEANUPS); 	}
endif|#
directive|endif
name|catch_command_errors
argument_list|(
name|source_command
argument_list|,
name|cmdarg
index|[
name|i
index|]
argument_list|,
operator|!
name|batch
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
block|}
name|xfree
argument_list|(
name|cmdarg
argument_list|)
expr_stmt|;
comment|/* Read in the old history after all the command files have been read. */
name|init_history
argument_list|()
expr_stmt|;
if|if
condition|(
name|batch
condition|)
block|{
comment|/* We have hit the end of the batch file.  */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Do any host- or target-specific hacks.  This is used for i960 targets      to force the user to set a nindy target and spec its parameters.  */
ifdef|#
directive|ifdef
name|BEFORE_MAIN_LOOP_HOOK
name|BEFORE_MAIN_LOOP_HOOK
expr_stmt|;
endif|#
directive|endif
comment|/* Show time and/or space usage.  */
if|if
condition|(
name|display_time
condition|)
block|{
name|long
name|init_time
init|=
name|get_run_time
argument_list|()
operator|-
name|time_at_startup
decl_stmt|;
name|printf_unfiltered
argument_list|(
name|_
argument_list|(
literal|"Startup time: %ld.%06ld\n"
argument_list|)
argument_list|,
name|init_time
operator|/
literal|1000000
argument_list|,
name|init_time
operator|%
literal|1000000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|display_space
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SBRK
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
name|char
modifier|*
name|lim
init|=
operator|(
name|char
operator|*
operator|)
name|sbrk
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|printf_unfiltered
argument_list|(
name|_
argument_list|(
literal|"Startup size: data size %ld\n"
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|lim
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|environ
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|#
directive|if
literal|0
comment|/* FIXME: cagney/1999-11-06: The original main loop was like: */
block|while (1)     {       if (!SET_TOP_LEVEL ()) 	{ 	  do_cleanups (ALL_CLEANUPS);
comment|/* Do complete cleanup */
comment|/* GUIs generally have their own command loop, mainloop, or whatever. 	     This is a good place to gain control because many error 	     conditions will end up here via longjmp(). */
block|if (command_loop_hook) 	    command_loop_hook (); 	  else 	    command_loop (); 	  quit_command ((char *) 0, instream == stdin); 	}     }
comment|/* NOTE: If the command_loop() returned normally, the loop would      attempt to exit by calling the function quit_command().  That      function would either call exit() or throw an error returning      control to SET_TOP_LEVEL. */
comment|/* NOTE: The function do_cleanups() was called once each time round      the loop.  The usefulness of the call isn't clear.  If an error      was thrown, everything would have already been cleaned up.  If      command_loop() returned normally and quit_command() was called,      either exit() or error() (again cleaning up) would be called. */
endif|#
directive|endif
comment|/* NOTE: cagney/1999-11-07: There is probably no reason for not      moving this loop and the code found in captured_command_loop()      into the command_loop() proper.  The main thing holding back that      change - SET_TOP_LEVEL() - has been eliminated. */
while|while
condition|(
literal|1
condition|)
block|{
name|catch_errors
argument_list|(
name|captured_command_loop
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
block|}
comment|/* No exit -- exit is through quit_command.  */
block|}
end_function

begin_function
name|int
name|gdb_main
parameter_list|(
name|struct
name|captured_main_args
modifier|*
name|args
parameter_list|)
block|{
name|use_windows
operator|=
name|args
operator|->
name|use_windows
expr_stmt|;
name|catch_errors
argument_list|(
name|captured_main
argument_list|,
name|args
argument_list|,
literal|""
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
comment|/* The only way to end up here is by an error (normal exit is      handled by quit_force()), hence always return an error status.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Don't use *_filtered for printing help.  We don't want to prompt    for continue no matter how small the screen or how much we're going    to print.  */
end_comment

begin_function
specifier|static
name|void
name|print_gdb_help
parameter_list|(
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|fputs_unfiltered
argument_list|(
name|_
argument_list|(
literal|"\ This is the GNU debugger.  Usage:\n\n\     gdb [options] [executable-file [core-file or process-id]]\n\     gdb [options] --args executable-file [inferior-arguments ...]\n\n\ Options:\n\n\ "
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
name|_
argument_list|(
literal|"\   --args             Arguments after executable-file are passed to inferior\n\ "
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
name|_
argument_list|(
literal|"\   --[no]async        Enable (disable) asynchronous version of CLI\n\ "
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
name|_
argument_list|(
literal|"\   -b BAUDRATE        Set serial port baud rate used for remote debugging.\n\   --batch            Exit after processing options.\n\   --cd=DIR           Change current directory to DIR.\n\   --command=FILE     Execute GDB commands from FILE.\n\   --core=COREFILE    Analyze the core dump COREFILE.\n\   --pid=PID          Attach to running process PID.\n\ "
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
name|_
argument_list|(
literal|"\   --dbx              DBX compatibility mode.\n\   --directory=DIR    Search for source files in DIR.\n\   --epoch            Output information used by epoch emacs-GDB interface.\n\   --exec=EXECFILE    Use EXECFILE as the executable.\n\   --fullname         Output information used by emacs-GDB interface.\n\   --help             Print this message.\n\ "
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
name|_
argument_list|(
literal|"\   --interpreter=INTERP\n\                      Select a specific interpreter / user interface\n\ "
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
name|_
argument_list|(
literal|"\   --mapped           Use mapped symbol files if supported on this system.\n\   --nw		     Do not use a window interface.\n\   --nx               Do not read "
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
name|gdbinit
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
name|_
argument_list|(
literal|" file.\n\   --quiet            Do not print version number on startup.\n\   --readnow          Fully read symbol files on first access.\n\ "
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
name|_
argument_list|(
literal|"\   --se=FILE          Use FILE as symbol file and executable file.\n\   --symbols=SYMFILE  Read symbols from SYMFILE.\n\   --tty=TTY          Use TTY for input/output by the program being debugged.\n\ "
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TUI
argument_list|)
name|fputs_unfiltered
argument_list|(
name|_
argument_list|(
literal|"\   --tui              Use a terminal user interface.\n\ "
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fputs_unfiltered
argument_list|(
name|_
argument_list|(
literal|"\   --version          Print version information and then exit.\n\   -w                 Use a window interface.\n\   --write            Set writing into executable and core files.\n\   --xdb              XDB compatibility mode.\n\ "
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
name|_
argument_list|(
literal|"\n\ For more information, type \"help\" from within GDB, or consult the\n\ GDB manual (available as on-line info or a printed manual).\n\ Report bugs to \"bug-gdb@gnu.org\".\ "
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

