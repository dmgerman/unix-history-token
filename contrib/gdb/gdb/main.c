begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Top level stuff for GDB, the GNU debugger.    Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995    Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"top.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"call-cmds.h"
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_comment
comment|/* Temporary variable for SET_TOP_LEVEL.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|top_level_val
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Do a setjmp on error_return and quit_return.  catch_errors is    generally a cleaner way to do this, but main() would look pretty    ugly if it had to use catch_errors each time.  */
end_comment

begin_define
define|#
directive|define
name|SET_TOP_LEVEL
parameter_list|()
define|\
value|(((top_level_val = SIGSETJMP (error_return)) \     ? (PTR) 0 : (PTR) memcpy (quit_return, error_return, sizeof (SIGJMP_BUF))) \    , top_level_val)
end_define

begin_comment
comment|/* If nonzero, display time usage both at startup and for each command.  */
end_comment

begin_decl_stmt
name|int
name|display_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, display space usage both at startup and for each command.  */
end_comment

begin_decl_stmt
name|int
name|display_space
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether this is the command line version or not */
end_comment

begin_decl_stmt
name|int
name|tui_version
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether xdb commands will be handled */
end_comment

begin_decl_stmt
name|int
name|xdb_commands
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether dbx commands will be handled */
end_comment

begin_decl_stmt
name|int
name|dbx_commands
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|GDB_FILE
modifier|*
name|gdb_stdout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|GDB_FILE
modifier|*
name|gdb_stderr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Whether to enable writing into executable and core files */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|write_files
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_gdb_help
name|PARAMS
argument_list|(
operator|(
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|gdb_init
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These two are used to set the external editor commands when gdb is farming    out files to be edited by another program. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|enable_external_editor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|external_editor_command
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__CYGWIN__
end_ifdef

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_comment
comment|/* for MAX_PATH */
end_comment

begin_include
include|#
directive|include
file|<sys/cygwin.h>
end_include

begin_comment
comment|/* for cygwin32_conv_to_posix_path */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|count
decl_stmt|;
specifier|static
name|int
name|quiet
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|batch
init|=
literal|0
decl_stmt|;
comment|/* Pointers to various arguments from command line.  */
name|char
modifier|*
name|symarg
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|execarg
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|corearg
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|cdarg
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|ttyarg
init|=
name|NULL
decl_stmt|;
comment|/* These are static so that we can take their address in an initializer.  */
specifier|static
name|int
name|print_help
decl_stmt|;
specifier|static
name|int
name|print_version
decl_stmt|;
comment|/* Pointers to all arguments of --command option.  */
name|char
modifier|*
modifier|*
name|cmdarg
decl_stmt|;
comment|/* Allocated size of cmdarg.  */
name|int
name|cmdsize
decl_stmt|;
comment|/* Number of elements of cmdarg used.  */
name|int
name|ncmd
decl_stmt|;
comment|/* Indices of all arguments of --directory option.  */
name|char
modifier|*
modifier|*
name|dirarg
decl_stmt|;
comment|/* Allocated size.  */
name|int
name|dirsize
decl_stmt|;
comment|/* Number of elements used.  */
name|int
name|ndir
decl_stmt|;
name|struct
name|stat
name|homebuf
decl_stmt|,
name|cwdbuf
decl_stmt|;
name|char
modifier|*
name|homedir
decl_stmt|,
modifier|*
name|homeinit
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|long
name|time_at_startup
init|=
name|get_run_time
argument_list|()
decl_stmt|;
name|int
name|gdb_file_size
decl_stmt|;
name|START_PROGRESS
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MPW
comment|/* Do all Mac-specific setup. */
name|mac_init
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* MPW */
comment|/* This needs to happen before the first use of malloc.  */
name|init_malloc
argument_list|(
operator|(
name|PTR
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ALIGN_STACK_ON_STARTUP
argument_list|)
name|i
operator|=
operator|(
name|int
operator|)
operator|&
name|count
operator|&
literal|0x3
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|alloca
argument_list|(
literal|4
operator|-
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If error() is called from initialization code, just exit */
if|if
condition|(
name|SET_TOP_LEVEL
argument_list|()
condition|)
block|{
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|cmdsize
operator|=
literal|1
expr_stmt|;
name|cmdarg
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|cmdsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cmdarg
argument_list|)
argument_list|)
expr_stmt|;
name|ncmd
operator|=
literal|0
expr_stmt|;
name|dirsize
operator|=
literal|1
expr_stmt|;
name|dirarg
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|dirsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dirarg
argument_list|)
argument_list|)
expr_stmt|;
name|ndir
operator|=
literal|0
expr_stmt|;
name|quit_flag
operator|=
literal|0
expr_stmt|;
name|line
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|linesize
argument_list|)
expr_stmt|;
name|line
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Terminate saved (now empty) cmd line */
name|instream
operator|=
name|stdin
expr_stmt|;
name|getcwd
argument_list|(
name|gdb_dirbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|gdb_dirbuf
argument_list|)
argument_list|)
expr_stmt|;
name|current_directory
operator|=
name|gdb_dirbuf
expr_stmt|;
name|gdb_file_size
operator|=
sizeof|sizeof
argument_list|(
name|GDB_FILE
argument_list|)
expr_stmt|;
name|gdb_stdout
operator|=
operator|(
name|GDB_FILE
operator|*
operator|)
name|xmalloc
argument_list|(
name|gdb_file_size
argument_list|)
expr_stmt|;
name|gdb_stdout
operator|->
name|ts_streamtype
operator|=
name|afile
expr_stmt|;
name|gdb_stdout
operator|->
name|ts_filestream
operator|=
name|stdout
expr_stmt|;
name|gdb_stdout
operator|->
name|ts_strbuf
operator|=
name|NULL
expr_stmt|;
name|gdb_stdout
operator|->
name|ts_buflen
operator|=
literal|0
expr_stmt|;
name|gdb_stderr
operator|=
operator|(
name|GDB_FILE
operator|*
operator|)
name|xmalloc
argument_list|(
name|gdb_file_size
argument_list|)
expr_stmt|;
name|gdb_stderr
operator|->
name|ts_streamtype
operator|=
name|afile
expr_stmt|;
name|gdb_stderr
operator|->
name|ts_filestream
operator|=
name|stderr
expr_stmt|;
name|gdb_stderr
operator|->
name|ts_strbuf
operator|=
name|NULL
expr_stmt|;
name|gdb_stderr
operator|->
name|ts_buflen
operator|=
literal|0
expr_stmt|;
comment|/* Parse arguments and options.  */
block|{
name|int
name|c
decl_stmt|;
comment|/* When var field is 0, use flag field to record the equivalent        short option (or arbitrary numbers starting at 10 for those        with no equivalent).  */
specifier|static
name|struct
name|option
name|long_options
index|[]
init|=
block|{
if|#
directive|if
name|defined
argument_list|(
name|TUI
argument_list|)
block|{
literal|"tui"
block|,
name|no_argument
block|,
operator|&
name|tui_version
block|,
literal|1
block|}
block|,
endif|#
directive|endif
block|{
literal|"xdb"
block|,
name|no_argument
block|,
operator|&
name|xdb_commands
block|,
literal|1
block|}
block|,
block|{
literal|"dbx"
block|,
name|no_argument
block|,
operator|&
name|dbx_commands
block|,
literal|1
block|}
block|,
block|{
literal|"readnow"
block|,
name|no_argument
block|,
operator|&
name|readnow_symbol_files
block|,
literal|1
block|}
block|,
block|{
literal|"r"
block|,
name|no_argument
block|,
operator|&
name|readnow_symbol_files
block|,
literal|1
block|}
block|,
block|{
literal|"mapped"
block|,
name|no_argument
block|,
operator|&
name|mapped_symbol_files
block|,
literal|1
block|}
block|,
block|{
literal|"m"
block|,
name|no_argument
block|,
operator|&
name|mapped_symbol_files
block|,
literal|1
block|}
block|,
block|{
literal|"quiet"
block|,
name|no_argument
block|,
operator|&
name|quiet
block|,
literal|1
block|}
block|,
block|{
literal|"q"
block|,
name|no_argument
block|,
operator|&
name|quiet
block|,
literal|1
block|}
block|,
block|{
literal|"silent"
block|,
name|no_argument
block|,
operator|&
name|quiet
block|,
literal|1
block|}
block|,
block|{
literal|"nx"
block|,
name|no_argument
block|,
operator|&
name|inhibit_gdbinit
block|,
literal|1
block|}
block|,
block|{
literal|"n"
block|,
name|no_argument
block|,
operator|&
name|inhibit_gdbinit
block|,
literal|1
block|}
block|,
block|{
literal|"batch"
block|,
name|no_argument
block|,
operator|&
name|batch
block|,
literal|1
block|}
block|,
block|{
literal|"epoch"
block|,
name|no_argument
block|,
operator|&
name|epoch_interface
block|,
literal|1
block|}
block|,
comment|/* This is a synonym for "--annotate=1".  --annotate is now preferred, 	   but keep this here for a long time because people will be running 	   emacses which use --fullname.  */
block|{
literal|"fullname"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'f'
block|}
block|,
block|{
literal|"f"
block|,
name|no_argument
block|,
literal|0
block|,
literal|'f'
block|}
block|,
block|{
literal|"annotate"
block|,
name|required_argument
block|,
literal|0
block|,
literal|12
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
operator|&
name|print_help
block|,
literal|1
block|}
block|,
block|{
literal|"se"
block|,
name|required_argument
block|,
literal|0
block|,
literal|10
block|}
block|,
block|{
literal|"symbols"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'s'
block|}
block|,
block|{
literal|"s"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'s'
block|}
block|,
block|{
literal|"exec"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'e'
block|}
block|,
block|{
literal|"e"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'e'
block|}
block|,
block|{
literal|"core"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'c'
block|}
block|,
block|{
literal|"c"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'c'
block|}
block|,
block|{
literal|"command"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'x'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
operator|&
name|print_version
block|,
literal|1
block|}
block|,
block|{
literal|"x"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'x'
block|}
block|,
block|{
literal|"directory"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'d'
block|}
block|,
block|{
literal|"cd"
block|,
name|required_argument
block|,
literal|0
block|,
literal|11
block|}
block|,
block|{
literal|"tty"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'t'
block|}
block|,
block|{
literal|"baud"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'b'
block|}
block|,
block|{
literal|"b"
block|,
name|required_argument
block|,
literal|0
block|,
literal|'b'
block|}
block|,
block|{
literal|"nw"
block|,
name|no_argument
block|,
operator|&
name|use_windows
block|,
literal|0
block|}
block|,
block|{
literal|"nowindows"
block|,
name|no_argument
block|,
operator|&
name|use_windows
block|,
literal|0
block|}
block|,
block|{
literal|"w"
block|,
name|no_argument
block|,
operator|&
name|use_windows
block|,
literal|1
block|}
block|,
block|{
literal|"windows"
block|,
name|no_argument
block|,
operator|&
name|use_windows
block|,
literal|1
block|}
block|,
block|{
literal|"statistics"
block|,
name|no_argument
block|,
literal|0
block|,
literal|13
block|}
block|,
block|{
literal|"write"
block|,
name|no_argument
block|,
operator|&
name|write_files
block|,
literal|1
block|}
block|,
comment|/* Allow machine descriptions to add more options... */
ifdef|#
directive|ifdef
name|ADDITIONAL_OPTIONS
name|ADDITIONAL_OPTIONS
endif|#
directive|endif
block|{
literal|0
block|,
name|no_argument
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|option_index
decl_stmt|;
name|c
operator|=
name|getopt_long_only
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|""
argument_list|,
name|long_options
argument_list|,
operator|&
name|option_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
comment|/* Long option that takes an argument.  */
if|if
condition|(
name|c
operator|==
literal|0
operator|&&
name|long_options
index|[
name|option_index
index|]
operator|.
name|flag
operator|==
literal|0
condition|)
name|c
operator|=
name|long_options
index|[
name|option_index
index|]
operator|.
name|val
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|0
case|:
comment|/* Long option that just sets a flag.  */
break|break;
case|case
literal|10
case|:
name|symarg
operator|=
name|optarg
expr_stmt|;
name|execarg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|11
case|:
name|cdarg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|12
case|:
comment|/* FIXME: what if the syntax is wrong (e.g. not digits)?  */
name|annotation_level
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|13
case|:
comment|/* Enable the display of both time and space usage.  */
name|display_time
operator|=
literal|1
expr_stmt|;
name|display_space
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|annotation_level
operator|=
literal|1
expr_stmt|;
comment|/* We have probably been invoked from emacs.  Disable window interface.  */
name|use_windows
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|symarg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|execarg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|corearg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|cmdarg
index|[
name|ncmd
operator|++
index|]
operator|=
name|optarg
expr_stmt|;
if|if
condition|(
name|ncmd
operator|>=
name|cmdsize
condition|)
block|{
name|cmdsize
operator|*=
literal|2
expr_stmt|;
name|cmdarg
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cmdarg
argument_list|,
name|cmdsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cmdarg
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'d'
case|:
name|dirarg
index|[
name|ndir
operator|++
index|]
operator|=
name|optarg
expr_stmt|;
if|if
condition|(
name|ndir
operator|>=
name|dirsize
condition|)
block|{
name|dirsize
operator|*=
literal|2
expr_stmt|;
name|dirarg
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dirarg
argument_list|,
name|dirsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dirarg
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'t'
case|:
name|ttyarg
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|i
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|&
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|p
operator|==
name|optarg
condition|)
comment|/* Don't use *_filtered or warning() (which relies on                    current_target) until after initialize_all_files(). */
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"warning: could not set baud rate to `%s'.\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
else|else
name|baud_rate
operator|=
name|i
expr_stmt|;
block|}
case|case
literal|'l'
case|:
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|i
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
operator|&
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|p
operator|==
name|optarg
condition|)
comment|/* Don't use *_filtered or warning() (which relies on                    current_target) until after initialize_all_files(). */
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"warning: could not set timeout limit to `%s'.\n"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
else|else
name|remote_timeout
operator|=
name|i
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|ADDITIONAL_OPTION_CASES
name|ADDITIONAL_OPTION_CASES
endif|#
directive|endif
case|case
literal|'?'
case|:
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Use `%s --help' for a complete list of options.\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If --help or --version, disable window interface.  */
if|if
condition|(
name|print_help
operator|||
name|print_version
condition|)
block|{
name|use_windows
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|TUI
comment|/* Disable the TUI as well.  */
name|tui_version
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|TUI
comment|/* An explicit --tui flag overrides the default UI, which is the        window system.  */
if|if
condition|(
name|tui_version
condition|)
name|use_windows
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* OK, that's all the options.  The other arguments are filenames.  */
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|optind
operator|<
name|argc
condition|;
name|optind
operator|++
control|)
switch|switch
condition|(
operator|++
name|count
condition|)
block|{
case|case
literal|1
case|:
name|symarg
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
name|execarg
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|corearg
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Excess command line arguments ignored. (%s%s)\n"
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|,
operator|(
name|optind
operator|==
name|argc
operator|-
literal|1
operator|)
condition|?
literal|""
else|:
literal|" ..."
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|batch
condition|)
name|quiet
operator|=
literal|1
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|TUI
argument_list|)
if|if
condition|(
name|tui_version
condition|)
name|init_ui_hook
operator|=
name|tuiInit
expr_stmt|;
endif|#
directive|endif
name|gdb_init
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Do these (and anything which might call wrap_here or *_filtered)      after initialize_all_files.  */
if|if
condition|(
name|print_version
condition|)
block|{
name|print_gdb_version
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|print_help
condition|)
block|{
name|print_gdb_help
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"\n"
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
comment|/* Print all the junk at the top, with trailing "..." if we are about 	 to read a symbol file (possibly slowly).  */
name|print_gdb_version
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|symarg
condition|)
name|printf_filtered
argument_list|(
literal|".."
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
comment|/* Force to screen during slow operations */
block|}
name|error_pre_print
operator|=
literal|"\n\n"
expr_stmt|;
name|quit_pre_print
operator|=
name|error_pre_print
expr_stmt|;
comment|/* We may get more than one warning, don't double space all of them... */
name|warning_pre_print
operator|=
literal|"\nwarning: "
expr_stmt|;
comment|/* Read and execute $HOME/.gdbinit file, if it exists.  This is done      *before* all the command line arguments are processed; it sets      global parameters, which are independent of what file you are      debugging or what directory you are in.  */
ifdef|#
directive|ifdef
name|__CYGWIN32__
block|{
name|char
modifier|*
name|tmp
init|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
decl_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|NULL
condition|)
block|{
name|homedir
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|MAX_PATH
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cygwin32_conv_to_posix_path
argument_list|(
name|tmp
argument_list|,
name|homedir
argument_list|)
expr_stmt|;
block|}
else|else
name|homedir
operator|=
name|NULL
expr_stmt|;
block|}
else|#
directive|else
name|homedir
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|homedir
condition|)
block|{
name|homeinit
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|homedir
argument_list|)
operator|+
name|strlen
argument_list|(
name|gdbinit
argument_list|)
operator|+
literal|10
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|homeinit
argument_list|,
name|homedir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|homeinit
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|homeinit
argument_list|,
name|gdbinit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inhibit_gdbinit
condition|)
block|{
if|if
condition|(
operator|!
name|SET_TOP_LEVEL
argument_list|()
condition|)
name|source_command
argument_list|(
name|homeinit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
comment|/* Do stats; no need to do them elsewhere since we'll only 	 need them if homedir is set.  Make sure that they are 	 zero in case one of them fails (this guarantees that they 	 won't match if either exists).  */
name|memset
argument_list|(
operator|&
name|homebuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|stat
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cwdbuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|stat
argument_list|)
argument_list|)
expr_stmt|;
name|stat
argument_list|(
name|homeinit
argument_list|,
operator|&
name|homebuf
argument_list|)
expr_stmt|;
name|stat
argument_list|(
name|gdbinit
argument_list|,
operator|&
name|cwdbuf
argument_list|)
expr_stmt|;
comment|/* We'll only need this if 				       homedir was set.  */
block|}
comment|/* Now perform all the actions indicated by the arguments.  */
if|if
condition|(
name|cdarg
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|SET_TOP_LEVEL
argument_list|()
condition|)
block|{
name|cd_command
argument_list|(
name|cdarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|do_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndir
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|SET_TOP_LEVEL
argument_list|()
condition|)
name|directory_command
argument_list|(
name|dirarg
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|dirarg
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
if|if
condition|(
name|execarg
operator|!=
name|NULL
operator|&&
name|symarg
operator|!=
name|NULL
operator|&&
name|STREQ
argument_list|(
name|execarg
argument_list|,
name|symarg
argument_list|)
condition|)
block|{
comment|/* The exec file and the symbol-file are the same.  If we can't open 	 it, better only print one error message.  */
if|if
condition|(
operator|!
name|SET_TOP_LEVEL
argument_list|()
condition|)
block|{
name|exec_file_command
argument_list|(
name|execarg
argument_list|,
operator|!
name|batch
argument_list|)
expr_stmt|;
name|symbol_file_command
argument_list|(
name|symarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|execarg
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|!
name|SET_TOP_LEVEL
argument_list|()
condition|)
name|exec_file_command
argument_list|(
name|execarg
argument_list|,
operator|!
name|batch
argument_list|)
expr_stmt|;
if|if
condition|(
name|symarg
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|!
name|SET_TOP_LEVEL
argument_list|()
condition|)
name|symbol_file_command
argument_list|(
name|symarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
comment|/* After the symbol file has been read, print a newline to get us      beyond the copyright line...  But errors should still set off      the error message with a (single) blank line.  */
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|error_pre_print
operator|=
literal|"\n"
expr_stmt|;
name|quit_pre_print
operator|=
name|error_pre_print
expr_stmt|;
name|warning_pre_print
operator|=
literal|"\nwarning: "
expr_stmt|;
if|if
condition|(
name|corearg
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|SET_TOP_LEVEL
argument_list|()
condition|)
name|core_file_command
argument_list|(
name|corearg
argument_list|,
operator|!
name|batch
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
name|corearg
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|!
name|SET_TOP_LEVEL
argument_list|()
condition|)
name|attach_command
argument_list|(
name|corearg
argument_list|,
operator|!
name|batch
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttyarg
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|!
name|SET_TOP_LEVEL
argument_list|()
condition|)
name|tty_command
argument_list|(
name|ttyarg
argument_list|,
operator|!
name|batch
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ADDITIONAL_OPTION_HANDLER
name|ADDITIONAL_OPTION_HANDLER
expr_stmt|;
endif|#
directive|endif
comment|/* Error messages should no longer be distinguished with extra output. */
name|error_pre_print
operator|=
name|NULL
expr_stmt|;
name|quit_pre_print
operator|=
name|NULL
expr_stmt|;
name|warning_pre_print
operator|=
literal|"warning: "
expr_stmt|;
comment|/* Read the .gdbinit file in the current directory, *if* it isn't      the same as the $HOME/.gdbinit file (it should exist, also).  */
if|if
condition|(
operator|!
name|homedir
operator|||
name|memcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|homebuf
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|cwdbuf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|stat
argument_list|)
argument_list|)
condition|)
if|if
condition|(
operator|!
name|inhibit_gdbinit
condition|)
block|{
if|if
condition|(
operator|!
name|SET_TOP_LEVEL
argument_list|()
condition|)
name|source_command
argument_list|(
name|gdbinit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncmd
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|SET_TOP_LEVEL
argument_list|()
condition|)
block|{
if|if
condition|(
name|cmdarg
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|cmdarg
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|read_command_file
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
else|else
name|source_command
argument_list|(
name|cmdarg
index|[
name|i
index|]
argument_list|,
operator|!
name|batch
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|cmdarg
argument_list|)
expr_stmt|;
comment|/* Read in the old history after all the command files have been read. */
name|init_history
argument_list|()
expr_stmt|;
if|if
condition|(
name|batch
condition|)
block|{
comment|/* We have hit the end of the batch file.  */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Do any host- or target-specific hacks.  This is used for i960 targets      to force the user to set a nindy target and spec its parameters.  */
ifdef|#
directive|ifdef
name|BEFORE_MAIN_LOOP_HOOK
name|BEFORE_MAIN_LOOP_HOOK
expr_stmt|;
endif|#
directive|endif
name|END_PROGRESS
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Show time and/or space usage.  */
if|if
condition|(
name|display_time
condition|)
block|{
name|long
name|init_time
init|=
name|get_run_time
argument_list|()
operator|-
name|time_at_startup
decl_stmt|;
name|printf_unfiltered
argument_list|(
literal|"Startup time: %ld.%06ld\n"
argument_list|,
name|init_time
operator|/
literal|1000000
argument_list|,
name|init_time
operator|%
literal|1000000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|display_space
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SBRK
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
name|char
modifier|*
name|lim
init|=
operator|(
name|char
operator|*
operator|)
name|sbrk
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|printf_unfiltered
argument_list|(
literal|"Startup size: data size %ld\n"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|lim
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|environ
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* The default command loop.       The WIN32 Gui calls this main to set up gdb's state, and       has its own command loop. */
if|#
directive|if
operator|!
name|defined
name|_WIN32
operator|||
name|defined
name|__GNUC__
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|SET_TOP_LEVEL
argument_list|()
condition|)
block|{
name|do_cleanups
argument_list|(
name|ALL_CLEANUPS
argument_list|)
expr_stmt|;
comment|/* Do complete cleanup */
comment|/* GUIs generally have their own command loop, mainloop, or whatever. 	     This is a good place to gain control because many error 	     conditions will end up here via longjmp(). */
if|if
condition|(
name|command_loop_hook
condition|)
name|command_loop_hook
argument_list|()
expr_stmt|;
else|else
name|command_loop
argument_list|()
expr_stmt|;
name|quit_command
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|instream
operator|==
name|stdin
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* No exit -- exit is through quit_command.  */
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Don't use *_filtered for printing help.  We don't want to prompt    for continue no matter how small the screen or how much we're going    to print.  */
end_comment

begin_function
specifier|static
name|void
name|print_gdb_help
parameter_list|(
name|stream
parameter_list|)
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fputs_unfiltered
argument_list|(
literal|"\ This is the GNU debugger.  Usage:\n\n\     gdb [options] [executable-file [core-file or process-id]]\n\n\ Options:\n\n\ "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"\   -b BAUDRATE        Set serial port baud rate used for remote debugging.\n\   --batch            Exit after processing options.\n\   --cd=DIR           Change current directory to DIR.\n\   --command=FILE     Execute GDB commands from FILE.\n\   --core=COREFILE    Analyze the core dump COREFILE.\n\ "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"\   --dbx              DBX compatibility mode.\n\   --directory=DIR    Search for source files in DIR.\n\   --epoch            Output information used by epoch emacs-GDB interface.\n\   --exec=EXECFILE    Use EXECFILE as the executable.\n\   --fullname         Output information used by emacs-GDB interface.\n\   --help             Print this message.\n\ "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"\   --mapped           Use mapped symbol files if supported on this system.\n\   --nw		     Do not use a window interface.\n\   --nx               Do not read .gdbinit file.\n\   --quiet            Do not print version number on startup.\n\   --readnow          Fully read symbol files on first access.\n\ "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"\   --se=FILE          Use FILE as symbol file and executable file.\n\   --symbols=SYMFILE  Read symbols from SYMFILE.\n\   --tty=TTY          Use TTY for input/output by the program being debugged.\n\ "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|TUI
argument_list|)
name|fputs_unfiltered
argument_list|(
literal|"\   --tui              Use a terminal user interface.\n\ "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fputs_unfiltered
argument_list|(
literal|"\   --version          Print version information and then exit.\n\   -w                 Use a window interface.\n\   --write            Set writing into executable and core files.\n\   --xdb              XDB compatibility mode.\n\ "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ADDITIONAL_OPTION_HELP
name|fputs_unfiltered
argument_list|(
name|ADDITIONAL_OPTION_HELP
argument_list|,
name|stream
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fputs_unfiltered
argument_list|(
literal|"\n\ For more information, type \"help\" from within GDB, or consult the\n\ GDB manual (available as on-line info or a printed manual).\n\ Report bugs to \"bug-gdb@prep.ai.mit.edu\".\ "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|init_proc
parameter_list|()
block|{ }
end_function

begin_function
name|void
name|proc_remove_foreign
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{ }
end_function

begin_comment
comment|/* All I/O sent to the *_filtered and *_unfiltered functions eventually ends up    here.  The fputs_unfiltered_hook is primarily used by GUIs to collect all    output and send it to the GUI, instead of the controlling terminal.  Only    output to gdb_stdout and gdb_stderr are sent to the hook.  Everything else    is sent on to fputs to allow file I/O to be handled appropriately.  */
end_comment

begin_function
name|void
name|fputs_unfiltered
parameter_list|(
name|linebuffer
parameter_list|,
name|stream
parameter_list|)
specifier|const
name|char
modifier|*
name|linebuffer
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|TUI
argument_list|)
specifier|extern
name|int
name|tui_owns_terminal
decl_stmt|;
endif|#
directive|endif
comment|/* If anything (GUI, TUI) wants to capture GDB output, this is    * the place... the way to do it is to set up     * fputs_unfiltered_hook.    * Our TUI ("gdb -tui") used to hook output, but in the    * new (XDB style) scheme, we do not do that anymore... - RT    */
if|if
condition|(
name|fputs_unfiltered_hook
operator|&&
operator|(
name|stream
operator|==
name|gdb_stdout
operator|||
name|stream
operator|==
name|gdb_stderr
operator|)
condition|)
name|fputs_unfiltered_hook
argument_list|(
name|linebuffer
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|TUI
argument_list|)
if|if
condition|(
name|tui_version
operator|&&
name|tui_owns_terminal
condition|)
block|{
comment|/* If we get here somehow while updating the TUI (from 	 * within a tuiDo(), then we need to temporarily  	 * set up the terminal for GDB output. This probably just 	 * happens on error output. 	 */
if|if
condition|(
name|stream
operator|->
name|ts_streamtype
operator|==
name|astring
condition|)
block|{
name|gdb_file_adjust_strbuf
argument_list|(
name|strlen
argument_list|(
name|linebuffer
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|stream
operator|->
name|ts_strbuf
argument_list|,
name|linebuffer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tuiTermUnsetup
argument_list|(
literal|0
argument_list|,
operator|(
name|tui_version
operator|)
condition|?
name|cmdWin
operator|->
name|detail
operator|.
name|commandInfo
operator|.
name|curch
else|:
literal|0
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|linebuffer
argument_list|,
name|stream
operator|->
name|ts_filestream
argument_list|)
expr_stmt|;
name|tuiTermSetup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|linebuffer
index|[
name|strlen
argument_list|(
name|linebuffer
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|tuiClearCommandCharCount
argument_list|()
expr_stmt|;
else|else
name|tuiIncrCommandCharCountBy
argument_list|(
name|strlen
argument_list|(
name|linebuffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* The normal case - just do a fputs() */
if|if
condition|(
name|stream
operator|->
name|ts_streamtype
operator|==
name|astring
condition|)
block|{
name|gdb_file_adjust_strbuf
argument_list|(
name|strlen
argument_list|(
name|linebuffer
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|stream
operator|->
name|ts_strbuf
argument_list|,
name|linebuffer
argument_list|)
expr_stmt|;
block|}
else|else
name|fputs
argument_list|(
name|linebuffer
argument_list|,
name|stream
operator|->
name|ts_filestream
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|stream
operator|->
name|ts_streamtype
operator|==
name|astring
condition|)
block|{
name|gdb_file_adjust_strbuf
argument_list|(
name|strlen
argument_list|(
name|linebuffer
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|stream
operator|->
name|ts_strbuf
argument_list|,
name|linebuffer
argument_list|)
expr_stmt|;
block|}
else|else
name|fputs
argument_list|(
name|linebuffer
argument_list|,
name|stream
operator|->
name|ts_filestream
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

end_unit

