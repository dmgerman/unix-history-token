begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Remote target communications for serial-line targets in custom GDB protocol     Copyright 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996,    1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* See the GDB User Guide for details of the GDB remote protocol. */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_comment
comment|/*#include "terminal.h" */
end_comment

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdb-stabs.h"
end_include

begin_include
include|#
directive|include
file|"gdbthread.h"
end_include

begin_include
include|#
directive|include
file|"remote.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"event-loop.h"
end_include

begin_include
include|#
directive|include
file|"event-top.h"
end_include

begin_include
include|#
directive|include
file|"inf-loop.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_comment
comment|/* for exec_bfd */
end_comment

begin_include
include|#
directive|include
file|"remote-fileio.h"
end_include

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_function_decl
specifier|static
name|void
name|cleanup_sigint_signal_handler
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|initialize_sigint_signal_handler
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getpkt_sane
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|long
name|sizeof_buf
parameter_list|,
name|int
name|forever
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_remote_sigint
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_remote_sigint_twice
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|async_remote_interrupt
parameter_list|(
name|gdb_client_data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|async_remote_interrupt_twice
parameter_list|(
name|gdb_client_data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_remote_gdbarch_data
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remote_files_info
parameter_list|(
name|struct
name|target_ops
modifier|*
name|ignore
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|remote_xfer_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|should_write
parameter_list|,
name|struct
name|mem_attrib
modifier|*
name|attrib
parameter_list|,
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remote_prepare_to_store
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remote_fetch_registers
parameter_list|(
name|int
name|regno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remote_resume
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|step
parameter_list|,
name|enum
name|target_signal
name|siggnal
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remote_async_resume
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|step
parameter_list|,
name|enum
name|target_signal
name|siggnal
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|remote_start_remote
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|void
modifier|*
name|dummy
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remote_open
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remote_async_open
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|extended_remote_open
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|extended_remote_async_open
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remote_open_1
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|target_ops
modifier|*
parameter_list|,
name|int
name|extended_p
parameter_list|,
name|int
name|async_p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remote_close
parameter_list|(
name|int
name|quitting
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remote_store_registers
parameter_list|(
name|int
name|regno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remote_mourn
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remote_async_mourn
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|extended_remote_restart
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|extended_remote_mourn
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|extended_remote_create_inferior
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|extended_remote_async_create_inferior
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remote_mourn_1
parameter_list|(
name|struct
name|target_ops
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remote_send
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|long
name|sizeof_buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|readchar
parameter_list|(
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ptid_t
name|remote_wait
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ptid_t
name|remote_async_wait
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remote_kill
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remote_async_kill
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tohex
parameter_list|(
name|int
name|nib
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remote_detach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remote_interrupt
parameter_list|(
name|int
name|signo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remote_interrupt_twice
parameter_list|(
name|int
name|signo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|interrupt_query
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_thread
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|remote_thread_alive
parameter_list|(
name|ptid_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|get_offsets
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|read_frame
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|long
name|sizeof_buf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|remote_insert_breakpoint
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|remote_remove_breakpoint
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hexnumlen
parameter_list|(
name|ULONGEST
name|num
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_remote_ops
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_extended_remote_ops
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remote_stop
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ishex
parameter_list|(
name|int
name|ch
parameter_list|,
name|int
modifier|*
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stubhex
parameter_list|(
name|int
name|ch
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hexnumstr
parameter_list|(
name|char
modifier|*
parameter_list|,
name|ULONGEST
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hexnumnstr
parameter_list|(
name|char
modifier|*
parameter_list|,
name|ULONGEST
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|CORE_ADDR
name|remote_address_masked
parameter_list|(
name|CORE_ADDR
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_packet
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|long
name|crc32
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compare_sections_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|packet_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|stub_unpack_int
parameter_list|(
name|char
modifier|*
name|buff
parameter_list|,
name|int
name|fieldlength
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ptid_t
name|remote_current_thread
parameter_list|(
name|ptid_t
name|oldptid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remote_find_new_threads
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|record_currthread
parameter_list|(
name|int
name|currthread
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fromhex
parameter_list|(
name|int
name|a
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hex2bin
parameter_list|(
specifier|const
name|char
modifier|*
name|hex
parameter_list|,
name|char
modifier|*
name|bin
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bin2hex
parameter_list|(
specifier|const
name|char
modifier|*
name|bin
parameter_list|,
name|char
modifier|*
name|hex
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|putpkt_binary
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|cnt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_binary_download
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_struct_decl
struct_decl|struct
name|packet_config
struct_decl|;
end_struct_decl

begin_function_decl
specifier|static
name|void
name|show_packet_config_cmd
parameter_list|(
name|struct
name|packet_config
modifier|*
name|config
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|update_packet_config
parameter_list|(
name|struct
name|packet_config
modifier|*
name|config
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|_initialize_remote
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Description of the remote protocol.  Strictly speaking, when the    target is open()ed, remote.c should create a per-target description    of the remote protocol using that target's architecture.    Unfortunately, the target stack doesn't include local state.  For    the moment keep the information in the target's architecture    object.  Sigh..  */
end_comment

begin_struct
struct|struct
name|packet_reg
block|{
name|long
name|offset
decl_stmt|;
comment|/* Offset into G packet.  */
name|long
name|regnum
decl_stmt|;
comment|/* GDB's internal register number.  */
name|LONGEST
name|pnum
decl_stmt|;
comment|/* Remote protocol register number.  */
name|int
name|in_g_packet
decl_stmt|;
comment|/* Always part of G packet.  */
comment|/* long size in bytes;  == DEPRECATED_REGISTER_RAW_SIZE (regnum); at present.  */
comment|/* char *name; == REGISTER_NAME (regnum); at present.  */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|remote_state
block|{
comment|/* Description of the remote protocol registers.  */
name|long
name|sizeof_g_packet
decl_stmt|;
comment|/* Description of the remote protocol registers indexed by REGNUM      (making an array of NUM_REGS + NUM_PSEUDO_REGS in size).  */
name|struct
name|packet_reg
modifier|*
name|regs
decl_stmt|;
comment|/* This is the size (in chars) of the first response to the ``g''      packet.  It is used as a heuristic when determining the maximum      size of memory-read and memory-write packets.  A target will      typically only reserve a buffer large enough to hold the ``g''      packet.  The size does not include packet overhead (headers and      trailers). */
name|long
name|actual_register_packet_size
decl_stmt|;
comment|/* This is the maximum size (in chars) of a non read/write packet.      It is also used as a cap on the size of read/write packets. */
name|long
name|remote_packet_size
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Handle for retreving the remote protocol data from gdbarch.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|gdbarch_data
modifier|*
name|remote_gdbarch_data_handle
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|remote_state
modifier|*
name|get_remote_state
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|gdbarch_data
argument_list|(
name|current_gdbarch
argument_list|,
name|remote_gdbarch_data_handle
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|init_remote_state
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|)
block|{
name|int
name|regnum
decl_stmt|;
name|struct
name|remote_state
modifier|*
name|rs
init|=
name|GDBARCH_OBSTACK_ZALLOC
argument_list|(
name|gdbarch
argument_list|,
expr|struct
name|remote_state
argument_list|)
decl_stmt|;
if|if
condition|(
name|DEPRECATED_REGISTER_BYTES
operator|!=
literal|0
condition|)
name|rs
operator|->
name|sizeof_g_packet
operator|=
name|DEPRECATED_REGISTER_BYTES
expr_stmt|;
else|else
name|rs
operator|->
name|sizeof_g_packet
operator|=
literal|0
expr_stmt|;
comment|/* Assume a 1:1 regnum<->pnum table.  */
name|rs
operator|->
name|regs
operator|=
name|GDBARCH_OBSTACK_CALLOC
argument_list|(
name|gdbarch
argument_list|,
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
argument_list|,
expr|struct
name|packet_reg
argument_list|)
expr_stmt|;
for|for
control|(
name|regnum
operator|=
literal|0
init|;
name|regnum
operator|<
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
condition|;
name|regnum
operator|++
control|)
block|{
name|struct
name|packet_reg
modifier|*
name|r
init|=
operator|&
name|rs
operator|->
name|regs
index|[
name|regnum
index|]
decl_stmt|;
name|r
operator|->
name|pnum
operator|=
name|regnum
expr_stmt|;
name|r
operator|->
name|regnum
operator|=
name|regnum
expr_stmt|;
name|r
operator|->
name|offset
operator|=
name|DEPRECATED_REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
name|r
operator|->
name|in_g_packet
operator|=
operator|(
name|regnum
operator|<
name|NUM_REGS
operator|)
expr_stmt|;
comment|/* ...name = REGISTER_NAME (regnum); */
comment|/* Compute packet size by accumulating the size of all registers. */
if|if
condition|(
name|DEPRECATED_REGISTER_BYTES
operator|==
literal|0
condition|)
name|rs
operator|->
name|sizeof_g_packet
operator|+=
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
block|}
comment|/* Default maximum number of characters in a packet body. Many      remote stubs have a hardwired buffer size of 400 bytes      (c.f. BUFMAX in m68k-stub.c and i386-stub.c).  BUFMAX-1 is used      as the maximum packet-size to ensure that the packet and an extra      NUL character can always fit in the buffer.  This stops GDB      trashing stubs that try to squeeze an extra NUL into what is      already a full buffer (As of 1999-12-04 that was most stubs. */
name|rs
operator|->
name|remote_packet_size
operator|=
literal|400
operator|-
literal|1
expr_stmt|;
comment|/* Should rs->sizeof_g_packet needs more space than the      default, adjust the size accordingly. Remember that each byte is      encoded as two characters. 32 is the overhead for the packet      header / footer. NOTE: cagney/1999-10-26: I suspect that 8      (``$NN:G...#NN'') is a better guess, the below has been padded a      little. */
if|if
condition|(
name|rs
operator|->
name|sizeof_g_packet
operator|>
operator|(
operator|(
name|rs
operator|->
name|remote_packet_size
operator|-
literal|32
operator|)
operator|/
literal|2
operator|)
condition|)
name|rs
operator|->
name|remote_packet_size
operator|=
operator|(
name|rs
operator|->
name|sizeof_g_packet
operator|*
literal|2
operator|+
literal|32
operator|)
expr_stmt|;
comment|/* This one is filled in when a ``g'' packet is received. */
name|rs
operator|->
name|actual_register_packet_size
operator|=
literal|0
expr_stmt|;
return|return
name|rs
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|packet_reg
modifier|*
name|packet_reg_from_regnum
parameter_list|(
name|struct
name|remote_state
modifier|*
name|rs
parameter_list|,
name|long
name|regnum
parameter_list|)
block|{
if|if
condition|(
name|regnum
operator|<
literal|0
operator|&&
name|regnum
operator|>=
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
condition|)
return|return
name|NULL
return|;
else|else
block|{
name|struct
name|packet_reg
modifier|*
name|r
init|=
operator|&
name|rs
operator|->
name|regs
index|[
name|regnum
index|]
decl_stmt|;
name|gdb_assert
argument_list|(
name|r
operator|->
name|regnum
operator|==
name|regnum
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|packet_reg
modifier|*
name|packet_reg_from_pnum
parameter_list|(
name|struct
name|remote_state
modifier|*
name|rs
parameter_list|,
name|LONGEST
name|pnum
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|packet_reg
modifier|*
name|r
init|=
operator|&
name|rs
operator|->
name|regs
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|r
operator|->
name|pnum
operator|==
name|pnum
condition|)
return|return
name|r
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* FIXME: graces/2002-08-08: These variables should eventually be    bound to an instance of the target object (as in gdbarch-tdep()),    when such a thing exists.  */
end_comment

begin_comment
comment|/* This is set to the data address of the access causing the target    to stop for a watchpoint.  */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|remote_watch_data_address
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is non-zero if taregt stopped for a watchpoint. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|remote_stopped_by_watchpoint_p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|target_ops
name|remote_ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|target_ops
name|extended_remote_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Temporary target ops. Just like the remote_ops and    extended_remote_ops, but with asynchronous support. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|target_ops
name|remote_async_ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|target_ops
name|extended_async_remote_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FIXME: cagney/1999-09-23: Even though getpkt was called with    ``forever'' still use the normal timeout mechanism.  This is    currently used by the ASYNC code to guarentee that target reads    during the initial connect always time-out.  Once getpkt has been    modified to return a timeout indication and, in turn    remote_wait()/wait_for_inferior() have gained a timeout parameter    this can go away. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|wait_forever_enabled_p
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This variable chooses whether to send a ^C or a break when the user    requests program interruption.  Although ^C is usually what remote    systems expect, and that is the default here, sometimes a break is    preferable instead.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|remote_break
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Descriptor for I/O to remote machine.  Initialize it to NULL so that    remote_open knows that we don't have a file open when the program    starts.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|serial
modifier|*
name|remote_desc
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This variable sets the number of bits in an address that are to be    sent in a memory ("M" or "m") packet.  Normally, after stripping    leading zeros, the entire address would be sent. This variable    restricts the address to REMOTE_ADDRESS_SIZE bits.  HISTORY: The    initial implementation of remote.c restricted the address sent in    memory packets to ``host::sizeof long'' bytes - (typically 32    bits).  Consequently, for 64 bit targets, the upper 32 bits of an    address was never sent.  Since fixing this bug may cause a break in    some remote targets this variable is principly provided to    facilitate backward compatibility. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|remote_address_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tempoary to track who currently owns the terminal.  See    target_async_terminal_* for more details.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|remote_async_terminal_ours_p
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* User configurable variables for the number of characters in a    memory read/write packet.  MIN ((rs->remote_packet_size),    rs->sizeof_g_packet) is the default.  Some targets need smaller    values (fifo overruns, et.al.)  and some users need larger values    (speed up transfers).  The variables ``preferred_*'' (the user    request), ``current_*'' (what was actually set) and ``forced_*''    (Positive - a soft limit, negative - a hard limit). */
end_comment

begin_struct
struct|struct
name|memory_packet_config
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|long
name|size
decl_stmt|;
name|int
name|fixed_p
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Compute the current size of a read/write packet.  Since this makes    use of ``actual_register_packet_size'' the computation is dynamic.  */
end_comment

begin_function
specifier|static
name|long
name|get_memory_packet_size
parameter_list|(
name|struct
name|memory_packet_config
modifier|*
name|config
parameter_list|)
block|{
name|struct
name|remote_state
modifier|*
name|rs
init|=
name|get_remote_state
argument_list|()
decl_stmt|;
comment|/* NOTE: The somewhat arbitrary 16k comes from the knowledge (folk      law?) that some hosts don't cope very well with large alloca()      calls.  Eventually the alloca() code will be replaced by calls to      xmalloc() and make_cleanups() allowing this restriction to either      be lifted or removed. */
ifndef|#
directive|ifndef
name|MAX_REMOTE_PACKET_SIZE
define|#
directive|define
name|MAX_REMOTE_PACKET_SIZE
value|16384
endif|#
directive|endif
comment|/* NOTE: 16 is just chosen at random. */
ifndef|#
directive|ifndef
name|MIN_REMOTE_PACKET_SIZE
define|#
directive|define
name|MIN_REMOTE_PACKET_SIZE
value|16
endif|#
directive|endif
name|long
name|what_they_get
decl_stmt|;
if|if
condition|(
name|config
operator|->
name|fixed_p
condition|)
block|{
if|if
condition|(
name|config
operator|->
name|size
operator|<=
literal|0
condition|)
name|what_they_get
operator|=
name|MAX_REMOTE_PACKET_SIZE
expr_stmt|;
else|else
name|what_they_get
operator|=
name|config
operator|->
name|size
expr_stmt|;
block|}
else|else
block|{
name|what_they_get
operator|=
operator|(
name|rs
operator|->
name|remote_packet_size
operator|)
expr_stmt|;
comment|/* Limit the packet to the size specified by the user. */
if|if
condition|(
name|config
operator|->
name|size
operator|>
literal|0
operator|&&
name|what_they_get
operator|>
name|config
operator|->
name|size
condition|)
name|what_they_get
operator|=
name|config
operator|->
name|size
expr_stmt|;
comment|/* Limit it to the size of the targets ``g'' response. */
if|if
condition|(
operator|(
name|rs
operator|->
name|actual_register_packet_size
operator|)
operator|>
literal|0
operator|&&
name|what_they_get
operator|>
operator|(
name|rs
operator|->
name|actual_register_packet_size
operator|)
condition|)
name|what_they_get
operator|=
operator|(
name|rs
operator|->
name|actual_register_packet_size
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|what_they_get
operator|>
name|MAX_REMOTE_PACKET_SIZE
condition|)
name|what_they_get
operator|=
name|MAX_REMOTE_PACKET_SIZE
expr_stmt|;
if|if
condition|(
name|what_they_get
operator|<
name|MIN_REMOTE_PACKET_SIZE
condition|)
name|what_they_get
operator|=
name|MIN_REMOTE_PACKET_SIZE
expr_stmt|;
return|return
name|what_they_get
return|;
block|}
end_function

begin_comment
comment|/* Update the size of a read/write packet. If they user wants    something really big then do a sanity check. */
end_comment

begin_function
specifier|static
name|void
name|set_memory_packet_size
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|struct
name|memory_packet_config
modifier|*
name|config
parameter_list|)
block|{
name|int
name|fixed_p
init|=
name|config
operator|->
name|fixed_p
decl_stmt|;
name|long
name|size
init|=
name|config
operator|->
name|size
decl_stmt|;
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Argument required (integer, `fixed' or `limited')."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|args
argument_list|,
literal|"hard"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|args
argument_list|,
literal|"fixed"
argument_list|)
operator|==
literal|0
condition|)
name|fixed_p
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|args
argument_list|,
literal|"soft"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|args
argument_list|,
literal|"limit"
argument_list|)
operator|==
literal|0
condition|)
name|fixed_p
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|size
operator|=
name|strtoul
argument_list|(
name|args
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|==
name|end
condition|)
name|error
argument_list|(
literal|"Invalid %s (bad syntax)."
argument_list|,
name|config
operator|->
name|name
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Instead of explicitly capping the size of a packet to          MAX_REMOTE_PACKET_SIZE or dissallowing it, the user is          instead allowed to set the size to something arbitrarily          large. */
block|if (size> MAX_REMOTE_PACKET_SIZE) 	error ("Invalid %s (too large).", config->name);
endif|#
directive|endif
block|}
comment|/* Extra checks? */
if|if
condition|(
name|fixed_p
operator|&&
operator|!
name|config
operator|->
name|fixed_p
condition|)
block|{
if|if
condition|(
operator|!
name|query
argument_list|(
literal|"The target may not be able to correctly handle a %s\n"
literal|"of %ld bytes. Change the packet size? "
argument_list|,
name|config
operator|->
name|name
argument_list|,
name|size
argument_list|)
condition|)
name|error
argument_list|(
literal|"Packet size not changed."
argument_list|)
expr_stmt|;
block|}
comment|/* Update the config. */
name|config
operator|->
name|fixed_p
operator|=
name|fixed_p
expr_stmt|;
name|config
operator|->
name|size
operator|=
name|size
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_memory_packet_size
parameter_list|(
name|struct
name|memory_packet_config
modifier|*
name|config
parameter_list|)
block|{
name|printf_filtered
argument_list|(
literal|"The %s is %ld. "
argument_list|,
name|config
operator|->
name|name
argument_list|,
name|config
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|->
name|fixed_p
condition|)
name|printf_filtered
argument_list|(
literal|"Packets are fixed at %ld bytes.\n"
argument_list|,
name|get_memory_packet_size
argument_list|(
name|config
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"Packets are limited to %ld bytes.\n"
argument_list|,
name|get_memory_packet_size
argument_list|(
name|config
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|memory_packet_config
name|memory_write_packet_config
init|=
block|{
literal|"memory-write-packet-size"
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|set_memory_write_packet_size
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|set_memory_packet_size
argument_list|(
name|args
argument_list|,
operator|&
name|memory_write_packet_config
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_memory_write_packet_size
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|show_memory_packet_size
argument_list|(
operator|&
name|memory_write_packet_config
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|long
name|get_memory_write_packet_size
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|get_memory_packet_size
argument_list|(
operator|&
name|memory_write_packet_config
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|memory_packet_config
name|memory_read_packet_config
init|=
block|{
literal|"memory-read-packet-size"
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|set_memory_read_packet_size
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|set_memory_packet_size
argument_list|(
name|args
argument_list|,
operator|&
name|memory_read_packet_config
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_memory_read_packet_size
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|show_memory_packet_size
argument_list|(
operator|&
name|memory_read_packet_config
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|long
name|get_memory_read_packet_size
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|remote_state
modifier|*
name|rs
init|=
name|get_remote_state
argument_list|()
decl_stmt|;
name|long
name|size
init|=
name|get_memory_packet_size
argument_list|(
operator|&
name|memory_read_packet_config
argument_list|)
decl_stmt|;
comment|/* FIXME: cagney/1999-11-07: Functions like getpkt() need to get an      extra buffer size argument before the memory read size can be      increased beyond (rs->remote_packet_size). */
if|if
condition|(
name|size
operator|>
operator|(
name|rs
operator|->
name|remote_packet_size
operator|)
condition|)
name|size
operator|=
operator|(
name|rs
operator|->
name|remote_packet_size
operator|)
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generic configuration support for packets the stub optionally    supports. Allows the user to specify the use of the packet as well    as allowing GDB to auto-detect support in the remote stub. */
end_comment

begin_enum
enum|enum
name|packet_support
block|{
name|PACKET_SUPPORT_UNKNOWN
init|=
literal|0
block|,
name|PACKET_ENABLE
block|,
name|PACKET_DISABLE
block|}
enum|;
end_enum

begin_struct
struct|struct
name|packet_config
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|title
decl_stmt|;
name|enum
name|auto_boolean
name|detect
decl_stmt|;
name|enum
name|packet_support
name|support
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Analyze a packet's return value and update the packet config    accordingly. */
end_comment

begin_enum
enum|enum
name|packet_result
block|{
name|PACKET_ERROR
block|,
name|PACKET_OK
block|,
name|PACKET_UNKNOWN
block|}
enum|;
end_enum

begin_function
specifier|static
name|void
name|update_packet_config
parameter_list|(
name|struct
name|packet_config
modifier|*
name|config
parameter_list|)
block|{
switch|switch
condition|(
name|config
operator|->
name|detect
condition|)
block|{
case|case
name|AUTO_BOOLEAN_TRUE
case|:
name|config
operator|->
name|support
operator|=
name|PACKET_ENABLE
expr_stmt|;
break|break;
case|case
name|AUTO_BOOLEAN_FALSE
case|:
name|config
operator|->
name|support
operator|=
name|PACKET_DISABLE
expr_stmt|;
break|break;
case|case
name|AUTO_BOOLEAN_AUTO
case|:
name|config
operator|->
name|support
operator|=
name|PACKET_SUPPORT_UNKNOWN
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|show_packet_config_cmd
parameter_list|(
name|struct
name|packet_config
modifier|*
name|config
parameter_list|)
block|{
name|char
modifier|*
name|support
init|=
literal|"internal-error"
decl_stmt|;
switch|switch
condition|(
name|config
operator|->
name|support
condition|)
block|{
case|case
name|PACKET_ENABLE
case|:
name|support
operator|=
literal|"enabled"
expr_stmt|;
break|break;
case|case
name|PACKET_DISABLE
case|:
name|support
operator|=
literal|"disabled"
expr_stmt|;
break|break;
case|case
name|PACKET_SUPPORT_UNKNOWN
case|:
name|support
operator|=
literal|"unknown"
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|config
operator|->
name|detect
condition|)
block|{
case|case
name|AUTO_BOOLEAN_AUTO
case|:
name|printf_filtered
argument_list|(
literal|"Support for remote protocol `%s' (%s) packet is auto-detected, currently %s.\n"
argument_list|,
name|config
operator|->
name|name
argument_list|,
name|config
operator|->
name|title
argument_list|,
name|support
argument_list|)
expr_stmt|;
break|break;
case|case
name|AUTO_BOOLEAN_TRUE
case|:
case|case
name|AUTO_BOOLEAN_FALSE
case|:
name|printf_filtered
argument_list|(
literal|"Support for remote protocol `%s' (%s) packet is currently %s.\n"
argument_list|,
name|config
operator|->
name|name
argument_list|,
name|config
operator|->
name|title
argument_list|,
name|support
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|add_packet_config_cmd
parameter_list|(
name|struct
name|packet_config
modifier|*
name|config
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|title
parameter_list|,
name|cmd_sfunc_ftype
modifier|*
name|set_func
parameter_list|,
name|cmd_sfunc_ftype
modifier|*
name|show_func
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|set_remote_list
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|show_remote_list
parameter_list|,
name|int
name|legacy
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|set_cmd
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|show_cmd
decl_stmt|;
name|char
modifier|*
name|set_doc
decl_stmt|;
name|char
modifier|*
name|show_doc
decl_stmt|;
name|char
modifier|*
name|cmd_name
decl_stmt|;
name|config
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|config
operator|->
name|title
operator|=
name|title
expr_stmt|;
name|config
operator|->
name|detect
operator|=
name|AUTO_BOOLEAN_AUTO
expr_stmt|;
name|config
operator|->
name|support
operator|=
name|PACKET_SUPPORT_UNKNOWN
expr_stmt|;
name|xasprintf
argument_list|(
operator|&
name|set_doc
argument_list|,
literal|"Set use of remote protocol `%s' (%s) packet"
argument_list|,
name|name
argument_list|,
name|title
argument_list|)
expr_stmt|;
name|xasprintf
argument_list|(
operator|&
name|show_doc
argument_list|,
literal|"Show current use of remote protocol `%s' (%s) packet"
argument_list|,
name|name
argument_list|,
name|title
argument_list|)
expr_stmt|;
comment|/* set/show TITLE-packet {auto,on,off} */
name|xasprintf
argument_list|(
operator|&
name|cmd_name
argument_list|,
literal|"%s-packet"
argument_list|,
name|title
argument_list|)
expr_stmt|;
name|add_setshow_auto_boolean_cmd
argument_list|(
name|cmd_name
argument_list|,
name|class_obscure
argument_list|,
operator|&
name|config
operator|->
name|detect
argument_list|,
name|set_doc
argument_list|,
name|show_doc
argument_list|,
name|set_func
argument_list|,
name|show_func
argument_list|,
name|set_remote_list
argument_list|,
name|show_remote_list
argument_list|)
expr_stmt|;
comment|/* set/show remote NAME-packet {auto,on,off} -- legacy */
if|if
condition|(
name|legacy
condition|)
block|{
name|char
modifier|*
name|legacy_name
decl_stmt|;
name|xasprintf
argument_list|(
operator|&
name|legacy_name
argument_list|,
literal|"%s-packet"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
name|legacy_name
argument_list|,
name|cmd_name
argument_list|,
name|class_obscure
argument_list|,
literal|0
argument_list|,
name|set_remote_list
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
name|legacy_name
argument_list|,
name|cmd_name
argument_list|,
name|class_obscure
argument_list|,
literal|0
argument_list|,
name|show_remote_list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|enum
name|packet_result
name|packet_ok
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|struct
name|packet_config
modifier|*
name|config
parameter_list|)
block|{
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
comment|/* The stub recognized the packet request.  Check that the 	 operation succeeded. */
switch|switch
condition|(
name|config
operator|->
name|support
condition|)
block|{
case|case
name|PACKET_SUPPORT_UNKNOWN
case|:
if|if
condition|(
name|remote_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"Packet %s (%s) is supported\n"
argument_list|,
name|config
operator|->
name|name
argument_list|,
name|config
operator|->
name|title
argument_list|)
expr_stmt|;
name|config
operator|->
name|support
operator|=
name|PACKET_ENABLE
expr_stmt|;
break|break;
case|case
name|PACKET_DISABLE
case|:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"packet_ok: attempt to use a disabled packet"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PACKET_ENABLE
case|:
break|break;
block|}
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'O'
operator|&&
name|buf
index|[
literal|1
index|]
operator|==
literal|'K'
operator|&&
name|buf
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
comment|/* "OK" - definitly OK. */
return|return
name|PACKET_OK
return|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'E'
operator|&&
name|isxdigit
argument_list|(
name|buf
index|[
literal|1
index|]
argument_list|)
operator|&&
name|isxdigit
argument_list|(
name|buf
index|[
literal|2
index|]
argument_list|)
operator|&&
name|buf
index|[
literal|3
index|]
operator|==
literal|'\0'
condition|)
comment|/* "Enn"  - definitly an error. */
return|return
name|PACKET_ERROR
return|;
comment|/* The packet may or may not be OK.  Just assume it is */
return|return
name|PACKET_OK
return|;
block|}
else|else
block|{
comment|/* The stub does not support the packet. */
switch|switch
condition|(
name|config
operator|->
name|support
condition|)
block|{
case|case
name|PACKET_ENABLE
case|:
if|if
condition|(
name|config
operator|->
name|detect
operator|==
name|AUTO_BOOLEAN_AUTO
condition|)
comment|/* If the stub previously indicated that the packet was 	       supported then there is a protocol error.. */
name|error
argument_list|(
literal|"Protocol error: %s (%s) conflicting enabled responses."
argument_list|,
name|config
operator|->
name|name
argument_list|,
name|config
operator|->
name|title
argument_list|)
expr_stmt|;
else|else
comment|/* The user set it wrong. */
name|error
argument_list|(
literal|"Enabled packet %s (%s) not recognized by stub"
argument_list|,
name|config
operator|->
name|name
argument_list|,
name|config
operator|->
name|title
argument_list|)
expr_stmt|;
break|break;
case|case
name|PACKET_SUPPORT_UNKNOWN
case|:
if|if
condition|(
name|remote_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"Packet %s (%s) is NOT supported\n"
argument_list|,
name|config
operator|->
name|name
argument_list|,
name|config
operator|->
name|title
argument_list|)
expr_stmt|;
name|config
operator|->
name|support
operator|=
name|PACKET_DISABLE
expr_stmt|;
break|break;
case|case
name|PACKET_DISABLE
case|:
break|break;
block|}
return|return
name|PACKET_UNKNOWN
return|;
block|}
block|}
end_function

begin_comment
comment|/* Should we try the 'vCont' (descriptive resume) request? */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|packet_config
name|remote_protocol_vcont
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|set_remote_protocol_vcont_packet_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|update_packet_config
argument_list|(
operator|&
name|remote_protocol_vcont
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_remote_protocol_vcont_packet_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|show_packet_config_cmd
argument_list|(
operator|&
name|remote_protocol_vcont
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Should we try the 'qSymbol' (target symbol lookup service) request? */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|packet_config
name|remote_protocol_qSymbol
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|set_remote_protocol_qSymbol_packet_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|update_packet_config
argument_list|(
operator|&
name|remote_protocol_qSymbol
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_remote_protocol_qSymbol_packet_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|show_packet_config_cmd
argument_list|(
operator|&
name|remote_protocol_qSymbol
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Should we try the 'e' (step over range) request? */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|packet_config
name|remote_protocol_e
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|set_remote_protocol_e_packet_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|update_packet_config
argument_list|(
operator|&
name|remote_protocol_e
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_remote_protocol_e_packet_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|show_packet_config_cmd
argument_list|(
operator|&
name|remote_protocol_e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Should we try the 'E' (step over range / w signal #) request? */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|packet_config
name|remote_protocol_E
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|set_remote_protocol_E_packet_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|update_packet_config
argument_list|(
operator|&
name|remote_protocol_E
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_remote_protocol_E_packet_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|show_packet_config_cmd
argument_list|(
operator|&
name|remote_protocol_E
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Should we try the 'P' (set register) request?  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|packet_config
name|remote_protocol_P
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|set_remote_protocol_P_packet_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|update_packet_config
argument_list|(
operator|&
name|remote_protocol_P
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_remote_protocol_P_packet_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|show_packet_config_cmd
argument_list|(
operator|&
name|remote_protocol_P
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Should we try one of the 'Z' requests?  */
end_comment

begin_enum
enum|enum
name|Z_packet_type
block|{
name|Z_PACKET_SOFTWARE_BP
block|,
name|Z_PACKET_HARDWARE_BP
block|,
name|Z_PACKET_WRITE_WP
block|,
name|Z_PACKET_READ_WP
block|,
name|Z_PACKET_ACCESS_WP
block|,
name|NR_Z_PACKET_TYPES
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|struct
name|packet_config
name|remote_protocol_Z
index|[
name|NR_Z_PACKET_TYPES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FIXME: Instead of having all these boiler plate functions, the    command callback should include a context argument. */
end_comment

begin_function
specifier|static
name|void
name|set_remote_protocol_Z_software_bp_packet_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|update_packet_config
argument_list|(
operator|&
name|remote_protocol_Z
index|[
name|Z_PACKET_SOFTWARE_BP
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_remote_protocol_Z_software_bp_packet_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|show_packet_config_cmd
argument_list|(
operator|&
name|remote_protocol_Z
index|[
name|Z_PACKET_SOFTWARE_BP
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_remote_protocol_Z_hardware_bp_packet_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|update_packet_config
argument_list|(
operator|&
name|remote_protocol_Z
index|[
name|Z_PACKET_HARDWARE_BP
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_remote_protocol_Z_hardware_bp_packet_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|show_packet_config_cmd
argument_list|(
operator|&
name|remote_protocol_Z
index|[
name|Z_PACKET_HARDWARE_BP
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_remote_protocol_Z_write_wp_packet_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|update_packet_config
argument_list|(
operator|&
name|remote_protocol_Z
index|[
name|Z_PACKET_WRITE_WP
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_remote_protocol_Z_write_wp_packet_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|show_packet_config_cmd
argument_list|(
operator|&
name|remote_protocol_Z
index|[
name|Z_PACKET_WRITE_WP
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_remote_protocol_Z_read_wp_packet_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|update_packet_config
argument_list|(
operator|&
name|remote_protocol_Z
index|[
name|Z_PACKET_READ_WP
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_remote_protocol_Z_read_wp_packet_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|show_packet_config_cmd
argument_list|(
operator|&
name|remote_protocol_Z
index|[
name|Z_PACKET_READ_WP
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_remote_protocol_Z_access_wp_packet_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|update_packet_config
argument_list|(
operator|&
name|remote_protocol_Z
index|[
name|Z_PACKET_ACCESS_WP
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_remote_protocol_Z_access_wp_packet_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|show_packet_config_cmd
argument_list|(
operator|&
name|remote_protocol_Z
index|[
name|Z_PACKET_ACCESS_WP
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* For compatibility with older distributions.  Provide a ``set remote    Z-packet ...'' command that updates all the Z packet types. */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|auto_boolean
name|remote_Z_packet_detect
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|set_remote_protocol_Z_packet_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NR_Z_PACKET_TYPES
condition|;
name|i
operator|++
control|)
block|{
name|remote_protocol_Z
index|[
name|i
index|]
operator|.
name|detect
operator|=
name|remote_Z_packet_detect
expr_stmt|;
name|update_packet_config
argument_list|(
operator|&
name|remote_protocol_Z
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|show_remote_protocol_Z_packet_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NR_Z_PACKET_TYPES
condition|;
name|i
operator|++
control|)
block|{
name|show_packet_config_cmd
argument_list|(
operator|&
name|remote_protocol_Z
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Should we try the 'X' (remote binary download) packet?     This variable (available to the user via "set remote X-packet")    dictates whether downloads are sent in binary (via the 'X' packet).    We assume that the stub can, and attempt to do it. This will be    cleared if the stub does not understand it. This switch is still    needed, though in cases when the packet is supported in the stub,    but the connection does not allow it (i.e., 7-bit serial connection    only). */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|packet_config
name|remote_protocol_binary_download
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Should we try the 'ThreadInfo' query packet?     This variable (NOT available to the user: auto-detect only!)    determines whether GDB will use the new, simpler "ThreadInfo"    query or the older, more complex syntax for thread queries.    This is an auto-detect variable (set to true at each connect,    and set to false when the target fails to recognize it).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|use_threadinfo_query
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|use_threadextra_query
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|set_remote_protocol_binary_download_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|update_packet_config
argument_list|(
operator|&
name|remote_protocol_binary_download
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_remote_protocol_binary_download_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|show_packet_config_cmd
argument_list|(
operator|&
name|remote_protocol_binary_download
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Should we try the 'qPart:auxv' (target auxiliary vector read) request? */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|packet_config
name|remote_protocol_qPart_auxv
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|set_remote_protocol_qPart_auxv_packet_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|update_packet_config
argument_list|(
operator|&
name|remote_protocol_qPart_auxv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_remote_protocol_qPart_auxv_packet_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|show_packet_config_cmd
argument_list|(
operator|&
name|remote_protocol_qPart_auxv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Should we try the 'qPart:dirty' (target dirty register read) request? */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|packet_config
name|remote_protocol_qPart_dirty
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|set_remote_protocol_qPart_dirty_packet_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|update_packet_config
argument_list|(
operator|&
name|remote_protocol_qPart_dirty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_remote_protocol_qPart_dirty_packet_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|show_packet_config_cmd
argument_list|(
operator|&
name|remote_protocol_qPart_dirty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Tokens for use by the asynchronous signal handlers for SIGINT */
end_comment

begin_decl_stmt
specifier|static
name|void
modifier|*
name|sigint_remote_twice_token
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|sigint_remote_token
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These are pointers to hook functions that may be set in order to    modify resume/wait behavior for a particular architecture.  */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|target_resume_hook
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|target_wait_loop_hook
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* These are the threads which we last sent to the remote system.    -1 for all or -2 for not sent yet.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|general_thread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|continue_thread
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Call this function as a result of    1) A halt indication (T packet) containing a thread id    2) A direct query of currthread    3) Successful execution of set thread  */
end_comment

begin_function
specifier|static
name|void
name|record_currthread
parameter_list|(
name|int
name|currthread
parameter_list|)
block|{
name|general_thread
operator|=
name|currthread
expr_stmt|;
comment|/* If this is a new thread, add it to GDB's thread list.      If we leave it up to WFI to do this, bad things will happen.  */
if|if
condition|(
operator|!
name|in_thread_list
argument_list|(
name|pid_to_ptid
argument_list|(
name|currthread
argument_list|)
argument_list|)
condition|)
block|{
name|add_thread
argument_list|(
name|pid_to_ptid
argument_list|(
name|currthread
argument_list|)
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"[New "
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
name|target_pid_to_str
argument_list|(
name|pid_to_ptid
argument_list|(
name|currthread
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"]\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|MAGIC_NULL_PID
value|42000
end_define

begin_function
specifier|static
name|void
name|set_thread
parameter_list|(
name|int
name|th
parameter_list|,
name|int
name|gen
parameter_list|)
block|{
name|struct
name|remote_state
modifier|*
name|rs
init|=
name|get_remote_state
argument_list|()
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|rs
operator|->
name|remote_packet_size
argument_list|)
decl_stmt|;
name|int
name|state
init|=
name|gen
condition|?
name|general_thread
else|:
name|continue_thread
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|th
condition|)
return|return;
name|buf
index|[
literal|0
index|]
operator|=
literal|'H'
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|gen
condition|?
literal|'g'
else|:
literal|'c'
expr_stmt|;
if|if
condition|(
name|th
operator|==
name|MAGIC_NULL_PID
condition|)
block|{
name|buf
index|[
literal|2
index|]
operator|=
literal|'0'
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|th
operator|<
literal|0
condition|)
name|sprintf
argument_list|(
operator|&
name|buf
index|[
literal|2
index|]
argument_list|,
literal|"-%x"
argument_list|,
operator|-
name|th
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
operator|&
name|buf
index|[
literal|2
index|]
argument_list|,
literal|"%x"
argument_list|,
name|th
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
operator|(
name|rs
operator|->
name|remote_packet_size
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|gen
condition|)
name|general_thread
operator|=
name|th
expr_stmt|;
else|else
name|continue_thread
operator|=
name|th
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  Return nonzero if the thread TH is still alive on the remote system.  */
end_comment

begin_function
specifier|static
name|int
name|remote_thread_alive
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
name|int
name|tid
init|=
name|PIDGET
argument_list|(
name|ptid
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
if|if
condition|(
name|tid
operator|<
literal|0
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"T-%08x"
argument_list|,
operator|-
name|tid
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"T%08x"
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'O'
operator|&&
name|buf
index|[
literal|1
index|]
operator|==
literal|'K'
operator|)
return|;
block|}
end_function

begin_comment
comment|/* About these extended threadlist and threadinfo packets.  They are    variable length packets but, the fields within them are often fixed    length.  They are redundent enough to send over UDP as is the    remote protocol in general.  There is a matching unit test module    in libstub.  */
end_comment

begin_define
define|#
directive|define
name|OPAQUETHREADBYTES
value|8
end_define

begin_comment
comment|/* a 64 bit opaque identifier */
end_comment

begin_typedef
typedef|typedef
name|unsigned
name|char
name|threadref
index|[
name|OPAQUETHREADBYTES
index|]
typedef|;
end_typedef

begin_comment
comment|/* WARNING: This threadref data structure comes from the remote O.S., libstub    protocol encoding, and remote.c. it is not particularly changable */
end_comment

begin_comment
comment|/* Right now, the internal structure is int. We want it to be bigger.    Plan to fix this.  */
end_comment

begin_typedef
typedef|typedef
name|int
name|gdb_threadref
typedef|;
end_typedef

begin_comment
comment|/* internal GDB thread reference */
end_comment

begin_comment
comment|/* gdb_ext_thread_info is an internal GDB data structure which is    equivalint to the reply of the remote threadinfo packet */
end_comment

begin_struct
struct|struct
name|gdb_ext_thread_info
block|{
name|threadref
name|threadid
decl_stmt|;
comment|/* External form of thread reference */
name|int
name|active
decl_stmt|;
comment|/* Has state interesting to GDB? , regs, stack */
name|char
name|display
index|[
literal|256
index|]
decl_stmt|;
comment|/* Brief state display, name, blocked/syspended */
name|char
name|shortname
index|[
literal|32
index|]
decl_stmt|;
comment|/* To be used to name threads */
name|char
name|more_display
index|[
literal|256
index|]
decl_stmt|;
comment|/* Long info, statistics, queue depth, whatever */
block|}
struct|;
end_struct

begin_comment
comment|/* The volume of remote transfers can be limited by submitting    a mask containing bits specifying the desired information.    Use a union of these values as the 'selection' parameter to    get_thread_info. FIXME: Make these TAG names more thread specific.  */
end_comment

begin_define
define|#
directive|define
name|TAG_THREADID
value|1
end_define

begin_define
define|#
directive|define
name|TAG_EXISTS
value|2
end_define

begin_define
define|#
directive|define
name|TAG_DISPLAY
value|4
end_define

begin_define
define|#
directive|define
name|TAG_THREADNAME
value|8
end_define

begin_define
define|#
directive|define
name|TAG_MOREDISPLAY
value|16
end_define

begin_define
define|#
directive|define
name|BUF_THREAD_ID_SIZE
value|(OPAQUETHREADBYTES*2)
end_define

begin_function_decl
name|char
modifier|*
name|unpack_varlen_hex
parameter_list|(
name|char
modifier|*
name|buff
parameter_list|,
name|ULONGEST
modifier|*
name|result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|unpack_nibble
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|val
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|pack_nibble
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|nibble
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|pack_hex_byte
parameter_list|(
name|char
modifier|*
name|pkt
parameter_list|,
name|int
comment|/*unsigned char */
name|byte
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|unpack_byte
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|pack_int
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|unpack_int
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|unpack_string
parameter_list|(
name|char
modifier|*
name|src
parameter_list|,
name|char
modifier|*
name|dest
parameter_list|,
name|int
name|length
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|pack_threadid
parameter_list|(
name|char
modifier|*
name|pkt
parameter_list|,
name|threadref
modifier|*
name|id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|unpack_threadid
parameter_list|(
name|char
modifier|*
name|inbuf
parameter_list|,
name|threadref
modifier|*
name|id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|int_to_threadref
parameter_list|(
name|threadref
modifier|*
name|id
parameter_list|,
name|int
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|threadref_to_int
parameter_list|(
name|threadref
modifier|*
name|ref
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|copy_threadref
parameter_list|(
name|threadref
modifier|*
name|dest
parameter_list|,
name|threadref
modifier|*
name|src
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|threadmatch
parameter_list|(
name|threadref
modifier|*
name|dest
parameter_list|,
name|threadref
modifier|*
name|src
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|pack_threadinfo_request
parameter_list|(
name|char
modifier|*
name|pkt
parameter_list|,
name|int
name|mode
parameter_list|,
name|threadref
modifier|*
name|id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|remote_unpack_thread_info_response
parameter_list|(
name|char
modifier|*
name|pkt
parameter_list|,
name|threadref
modifier|*
name|expectedref
parameter_list|,
name|struct
name|gdb_ext_thread_info
modifier|*
name|info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|remote_get_threadinfo
parameter_list|(
name|threadref
modifier|*
name|threadid
parameter_list|,
name|int
name|fieldset
parameter_list|,
comment|/*TAG mask */
name|struct
name|gdb_ext_thread_info
modifier|*
name|info
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|pack_threadlist_request
parameter_list|(
name|char
modifier|*
name|pkt
parameter_list|,
name|int
name|startflag
parameter_list|,
name|int
name|threadcount
parameter_list|,
name|threadref
modifier|*
name|nextthread
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parse_threadlist_response
parameter_list|(
name|char
modifier|*
name|pkt
parameter_list|,
name|int
name|result_limit
parameter_list|,
name|threadref
modifier|*
name|original_echo
parameter_list|,
name|threadref
modifier|*
name|resultlist
parameter_list|,
name|int
modifier|*
name|doneflag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|remote_get_threadlist
parameter_list|(
name|int
name|startflag
parameter_list|,
name|threadref
modifier|*
name|nextthread
parameter_list|,
name|int
name|result_limit
parameter_list|,
name|int
modifier|*
name|done
parameter_list|,
name|int
modifier|*
name|result_count
parameter_list|,
name|threadref
modifier|*
name|threadlist
parameter_list|)
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|rmt_thread_action
function_decl|)
parameter_list|(
name|threadref
modifier|*
name|ref
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
function_decl|;
end_typedef

begin_function_decl
specifier|static
name|int
name|remote_threadlist_iterator
parameter_list|(
name|rmt_thread_action
name|stepfunction
parameter_list|,
name|void
modifier|*
name|context
parameter_list|,
name|int
name|looplimit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|remote_newthread_step
parameter_list|(
name|threadref
modifier|*
name|ref
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* encode 64 bits in 16 chars of hex */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|hexchars
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|ishex
parameter_list|(
name|int
name|ch
parameter_list|,
name|int
modifier|*
name|val
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'f'
operator|)
condition|)
block|{
operator|*
name|val
operator|=
name|ch
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'A'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'F'
operator|)
condition|)
block|{
operator|*
name|val
operator|=
name|ch
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'9'
operator|)
condition|)
block|{
operator|*
name|val
operator|=
name|ch
operator|-
literal|'0'
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|stubhex
parameter_list|(
name|int
name|ch
parameter_list|)
block|{
if|if
condition|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'f'
condition|)
return|return
name|ch
operator|-
literal|'a'
operator|+
literal|10
return|;
if|if
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
return|return
name|ch
operator|-
literal|'0'
return|;
if|if
condition|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'F'
condition|)
return|return
name|ch
operator|-
literal|'A'
operator|+
literal|10
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|stub_unpack_int
parameter_list|(
name|char
modifier|*
name|buff
parameter_list|,
name|int
name|fieldlength
parameter_list|)
block|{
name|int
name|nibble
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|fieldlength
condition|)
block|{
name|nibble
operator|=
name|stubhex
argument_list|(
operator|*
name|buff
operator|++
argument_list|)
expr_stmt|;
name|retval
operator||=
name|nibble
expr_stmt|;
name|fieldlength
operator|--
expr_stmt|;
if|if
condition|(
name|fieldlength
condition|)
name|retval
operator|=
name|retval
operator|<<
literal|4
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|unpack_varlen_hex
parameter_list|(
name|char
modifier|*
name|buff
parameter_list|,
comment|/* packet to parse */
name|ULONGEST
modifier|*
name|result
parameter_list|)
block|{
name|int
name|nibble
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|ishex
argument_list|(
operator|*
name|buff
argument_list|,
operator|&
name|nibble
argument_list|)
condition|)
block|{
name|buff
operator|++
expr_stmt|;
name|retval
operator|=
name|retval
operator|<<
literal|4
expr_stmt|;
name|retval
operator||=
name|nibble
operator|&
literal|0x0f
expr_stmt|;
block|}
operator|*
name|result
operator|=
name|retval
expr_stmt|;
return|return
name|buff
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|unpack_nibble
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|val
parameter_list|)
block|{
name|ishex
argument_list|(
operator|*
name|buf
operator|++
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|pack_nibble
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|nibble
parameter_list|)
block|{
operator|*
name|buf
operator|++
operator|=
name|hexchars
index|[
operator|(
name|nibble
operator|&
literal|0x0f
operator|)
index|]
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|pack_hex_byte
parameter_list|(
name|char
modifier|*
name|pkt
parameter_list|,
name|int
name|byte
parameter_list|)
block|{
operator|*
name|pkt
operator|++
operator|=
name|hexchars
index|[
operator|(
name|byte
operator|>>
literal|4
operator|)
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|pkt
operator|++
operator|=
name|hexchars
index|[
operator|(
name|byte
operator|&
literal|0xf
operator|)
index|]
expr_stmt|;
return|return
name|pkt
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|unpack_byte
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|value
parameter_list|)
block|{
operator|*
name|value
operator|=
name|stub_unpack_int
argument_list|(
name|buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
name|buf
operator|+
literal|2
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|pack_int
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|buf
operator|=
name|pack_hex_byte
argument_list|(
name|buf
argument_list|,
operator|(
name|value
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|buf
operator|=
name|pack_hex_byte
argument_list|(
name|buf
argument_list|,
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|buf
operator|=
name|pack_hex_byte
argument_list|(
name|buf
argument_list|,
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0x0ff
argument_list|)
expr_stmt|;
name|buf
operator|=
name|pack_hex_byte
argument_list|(
name|buf
argument_list|,
operator|(
name|value
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|unpack_int
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|value
parameter_list|)
block|{
operator|*
name|value
operator|=
name|stub_unpack_int
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
return|return
name|buf
operator|+
literal|8
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* currently unused, uncomment when needed */
end_comment

begin_comment
unit|static char *pack_string (char *pkt, char *string);  static char * pack_string (char *pkt, char *string) {   char ch;   int len;    len = strlen (string);   if (len> 200)     len = 200;
comment|/* Bigger than most GDB packets, junk??? */
end_comment

begin_comment
unit|pkt = pack_hex_byte (pkt, len);   while (len--> 0)     {       ch = *string++;       if ((ch == '\0') || (ch == '#')) 	ch = '*';
comment|/* Protect encapsulation */
end_comment

begin_endif
unit|*pkt++ = ch;     }   return pkt; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 (unused) */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|unpack_string
parameter_list|(
name|char
modifier|*
name|src
parameter_list|,
name|char
modifier|*
name|dest
parameter_list|,
name|int
name|length
parameter_list|)
block|{
while|while
condition|(
name|length
operator|--
condition|)
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dest
operator|=
literal|'\0'
expr_stmt|;
return|return
name|src
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|pack_threadid
parameter_list|(
name|char
modifier|*
name|pkt
parameter_list|,
name|threadref
modifier|*
name|id
parameter_list|)
block|{
name|char
modifier|*
name|limit
decl_stmt|;
name|unsigned
name|char
modifier|*
name|altid
decl_stmt|;
name|altid
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|id
expr_stmt|;
name|limit
operator|=
name|pkt
operator|+
name|BUF_THREAD_ID_SIZE
expr_stmt|;
while|while
condition|(
name|pkt
operator|<
name|limit
condition|)
name|pkt
operator|=
name|pack_hex_byte
argument_list|(
name|pkt
argument_list|,
operator|*
name|altid
operator|++
argument_list|)
expr_stmt|;
return|return
name|pkt
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|unpack_threadid
parameter_list|(
name|char
modifier|*
name|inbuf
parameter_list|,
name|threadref
modifier|*
name|id
parameter_list|)
block|{
name|char
modifier|*
name|altref
decl_stmt|;
name|char
modifier|*
name|limit
init|=
name|inbuf
operator|+
name|BUF_THREAD_ID_SIZE
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|altref
operator|=
operator|(
name|char
operator|*
operator|)
name|id
expr_stmt|;
while|while
condition|(
name|inbuf
operator|<
name|limit
condition|)
block|{
name|x
operator|=
name|stubhex
argument_list|(
operator|*
name|inbuf
operator|++
argument_list|)
expr_stmt|;
name|y
operator|=
name|stubhex
argument_list|(
operator|*
name|inbuf
operator|++
argument_list|)
expr_stmt|;
operator|*
name|altref
operator|++
operator|=
operator|(
name|x
operator|<<
literal|4
operator|)
operator||
name|y
expr_stmt|;
block|}
return|return
name|inbuf
return|;
block|}
end_function

begin_comment
comment|/* Externally, threadrefs are 64 bits but internally, they are still    ints. This is due to a mismatch of specifications.  We would like    to use 64bit thread references internally.  This is an adapter    function.  */
end_comment

begin_function
name|void
name|int_to_threadref
parameter_list|(
name|threadref
modifier|*
name|id
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|scan
decl_stmt|;
name|scan
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|id
expr_stmt|;
block|{
name|int
name|i
init|=
literal|4
decl_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
operator|*
name|scan
operator|++
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|scan
operator|++
operator|=
operator|(
name|value
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
name|scan
operator|++
operator|=
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
name|scan
operator|++
operator|=
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
name|scan
operator|++
operator|=
operator|(
name|value
operator|&
literal|0xff
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|threadref_to_int
parameter_list|(
name|threadref
modifier|*
name|ref
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|value
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|scan
decl_stmt|;
name|scan
operator|=
operator|(
name|char
operator|*
operator|)
name|ref
expr_stmt|;
name|scan
operator|+=
literal|4
expr_stmt|;
name|i
operator|=
literal|4
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
name|value
operator|=
operator|(
name|value
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|*
name|scan
operator|++
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|copy_threadref
parameter_list|(
name|threadref
modifier|*
name|dest
parameter_list|,
name|threadref
modifier|*
name|src
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|char
modifier|*
name|csrc
decl_stmt|,
modifier|*
name|cdest
decl_stmt|;
name|csrc
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|src
expr_stmt|;
name|cdest
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|dest
expr_stmt|;
name|i
operator|=
literal|8
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
operator|*
name|cdest
operator|++
operator|=
operator|*
name|csrc
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|threadmatch
parameter_list|(
name|threadref
modifier|*
name|dest
parameter_list|,
name|threadref
modifier|*
name|src
parameter_list|)
block|{
comment|/* things are broken right now, so just assume we got a match */
if|#
directive|if
literal|0
block|unsigned char *srcp, *destp;   int i, result;   srcp = (char *) src;   destp = (char *) dest;    result = 1;   while (i--> 0)     result&= (*srcp++ == *destp++) ? 1 : 0;   return result;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*    threadid:1,        # always request threadid    context_exists:2,    display:4,    unique_name:8,    more_display:16  */
end_comment

begin_comment
comment|/* Encoding:  'Q':8,'P':8,mask:32,threadid:64 */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|pack_threadinfo_request
parameter_list|(
name|char
modifier|*
name|pkt
parameter_list|,
name|int
name|mode
parameter_list|,
name|threadref
modifier|*
name|id
parameter_list|)
block|{
operator|*
name|pkt
operator|++
operator|=
literal|'q'
expr_stmt|;
comment|/* Info Query */
operator|*
name|pkt
operator|++
operator|=
literal|'P'
expr_stmt|;
comment|/* process or thread info */
name|pkt
operator|=
name|pack_int
argument_list|(
name|pkt
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* mode */
name|pkt
operator|=
name|pack_threadid
argument_list|(
name|pkt
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* threadid */
operator|*
name|pkt
operator|=
literal|'\0'
expr_stmt|;
comment|/* terminate */
return|return
name|pkt
return|;
block|}
end_function

begin_comment
comment|/* These values tag the fields in a thread info response packet */
end_comment

begin_comment
comment|/* Tagging the fields allows us to request specific fields and to    add more fields as time goes by */
end_comment

begin_define
define|#
directive|define
name|TAG_THREADID
value|1
end_define

begin_comment
comment|/* Echo the thread identifier */
end_comment

begin_define
define|#
directive|define
name|TAG_EXISTS
value|2
end_define

begin_comment
comment|/* Is this process defined enough to 				   fetch registers and its stack */
end_comment

begin_define
define|#
directive|define
name|TAG_DISPLAY
value|4
end_define

begin_comment
comment|/* A short thing maybe to put on a window */
end_comment

begin_define
define|#
directive|define
name|TAG_THREADNAME
value|8
end_define

begin_comment
comment|/* string, maps 1-to-1 with a thread is */
end_comment

begin_define
define|#
directive|define
name|TAG_MOREDISPLAY
value|16
end_define

begin_comment
comment|/* Whatever the kernel wants to say about 				   the process */
end_comment

begin_function
specifier|static
name|int
name|remote_unpack_thread_info_response
parameter_list|(
name|char
modifier|*
name|pkt
parameter_list|,
name|threadref
modifier|*
name|expectedref
parameter_list|,
name|struct
name|gdb_ext_thread_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|remote_state
modifier|*
name|rs
init|=
name|get_remote_state
argument_list|()
decl_stmt|;
name|int
name|mask
decl_stmt|,
name|length
decl_stmt|;
name|unsigned
name|int
name|tag
decl_stmt|;
name|threadref
name|ref
decl_stmt|;
name|char
modifier|*
name|limit
init|=
name|pkt
operator|+
operator|(
name|rs
operator|->
name|remote_packet_size
operator|)
decl_stmt|;
comment|/* plausable parsing limit */
name|int
name|retval
init|=
literal|1
decl_stmt|;
comment|/* info->threadid = 0; FIXME: implement zero_threadref */
name|info
operator|->
name|active
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|display
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|info
operator|->
name|shortname
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|info
operator|->
name|more_display
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Assume the characters indicating the packet type have been stripped */
name|pkt
operator|=
name|unpack_int
argument_list|(
name|pkt
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
comment|/* arg mask */
name|pkt
operator|=
name|unpack_threadid
argument_list|(
name|pkt
argument_list|,
operator|&
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"Incomplete response to threadinfo request\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|threadmatch
argument_list|(
operator|&
name|ref
argument_list|,
name|expectedref
argument_list|)
condition|)
block|{
comment|/* This is an answer to a different request */
name|warning
argument_list|(
literal|"ERROR RMT Thread info mismatch\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|copy_threadref
argument_list|(
operator|&
name|info
operator|->
name|threadid
argument_list|,
operator|&
name|ref
argument_list|)
expr_stmt|;
comment|/* Loop on tagged fields , try to bail if somthing goes wrong */
while|while
condition|(
operator|(
name|pkt
operator|<
name|limit
operator|)
operator|&&
name|mask
operator|&&
operator|*
name|pkt
condition|)
comment|/* packets are terminated with nulls */
block|{
name|pkt
operator|=
name|unpack_int
argument_list|(
name|pkt
argument_list|,
operator|&
name|tag
argument_list|)
expr_stmt|;
comment|/* tag */
name|pkt
operator|=
name|unpack_byte
argument_list|(
name|pkt
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
comment|/* length */
if|if
condition|(
operator|!
operator|(
name|tag
operator|&
name|mask
operator|)
condition|)
comment|/* tags out of synch with mask */
block|{
name|warning
argument_list|(
literal|"ERROR RMT: threadinfo tag mismatch\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tag
operator|==
name|TAG_THREADID
condition|)
block|{
if|if
condition|(
name|length
operator|!=
literal|16
condition|)
block|{
name|warning
argument_list|(
literal|"ERROR RMT: length of threadid is not 16\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|pkt
operator|=
name|unpack_threadid
argument_list|(
name|pkt
argument_list|,
operator|&
name|ref
argument_list|)
expr_stmt|;
name|mask
operator|=
name|mask
operator|&
operator|~
name|TAG_THREADID
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|tag
operator|==
name|TAG_EXISTS
condition|)
block|{
name|info
operator|->
name|active
operator|=
name|stub_unpack_int
argument_list|(
name|pkt
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|pkt
operator|+=
name|length
expr_stmt|;
name|mask
operator|=
name|mask
operator|&
operator|~
operator|(
name|TAG_EXISTS
operator|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|8
condition|)
block|{
name|warning
argument_list|(
literal|"ERROR RMT: 'exists' length too long\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
break|break;
block|}
continue|continue;
block|}
if|if
condition|(
name|tag
operator|==
name|TAG_THREADNAME
condition|)
block|{
name|pkt
operator|=
name|unpack_string
argument_list|(
name|pkt
argument_list|,
operator|&
name|info
operator|->
name|shortname
index|[
literal|0
index|]
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|mask
operator|=
name|mask
operator|&
operator|~
name|TAG_THREADNAME
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|tag
operator|==
name|TAG_DISPLAY
condition|)
block|{
name|pkt
operator|=
name|unpack_string
argument_list|(
name|pkt
argument_list|,
operator|&
name|info
operator|->
name|display
index|[
literal|0
index|]
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|mask
operator|=
name|mask
operator|&
operator|~
name|TAG_DISPLAY
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|tag
operator|==
name|TAG_MOREDISPLAY
condition|)
block|{
name|pkt
operator|=
name|unpack_string
argument_list|(
name|pkt
argument_list|,
operator|&
name|info
operator|->
name|more_display
index|[
literal|0
index|]
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|mask
operator|=
name|mask
operator|&
operator|~
name|TAG_MOREDISPLAY
expr_stmt|;
continue|continue;
block|}
name|warning
argument_list|(
literal|"ERROR RMT: unknown thread info tag\n"
argument_list|)
expr_stmt|;
break|break;
comment|/* Not a tag we know about */
block|}
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|remote_get_threadinfo
parameter_list|(
name|threadref
modifier|*
name|threadid
parameter_list|,
name|int
name|fieldset
parameter_list|,
comment|/* TAG mask */
name|struct
name|gdb_ext_thread_info
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|remote_state
modifier|*
name|rs
init|=
name|get_remote_state
argument_list|()
decl_stmt|;
name|int
name|result
decl_stmt|;
name|char
modifier|*
name|threadinfo_pkt
init|=
name|alloca
argument_list|(
name|rs
operator|->
name|remote_packet_size
argument_list|)
decl_stmt|;
name|pack_threadinfo_request
argument_list|(
name|threadinfo_pkt
argument_list|,
name|fieldset
argument_list|,
name|threadid
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|threadinfo_pkt
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|threadinfo_pkt
argument_list|,
operator|(
name|rs
operator|->
name|remote_packet_size
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|result
operator|=
name|remote_unpack_thread_info_response
argument_list|(
name|threadinfo_pkt
operator|+
literal|2
argument_list|,
name|threadid
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*    Format: i'Q':8,i"L":8,initflag:8,batchsize:16,lastthreadid:32   */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|pack_threadlist_request
parameter_list|(
name|char
modifier|*
name|pkt
parameter_list|,
name|int
name|startflag
parameter_list|,
name|int
name|threadcount
parameter_list|,
name|threadref
modifier|*
name|nextthread
parameter_list|)
block|{
operator|*
name|pkt
operator|++
operator|=
literal|'q'
expr_stmt|;
comment|/* info query packet */
operator|*
name|pkt
operator|++
operator|=
literal|'L'
expr_stmt|;
comment|/* Process LIST or threadLIST request */
name|pkt
operator|=
name|pack_nibble
argument_list|(
name|pkt
argument_list|,
name|startflag
argument_list|)
expr_stmt|;
comment|/* initflag 1 bytes */
name|pkt
operator|=
name|pack_hex_byte
argument_list|(
name|pkt
argument_list|,
name|threadcount
argument_list|)
expr_stmt|;
comment|/* threadcount 2 bytes */
name|pkt
operator|=
name|pack_threadid
argument_list|(
name|pkt
argument_list|,
name|nextthread
argument_list|)
expr_stmt|;
comment|/* 64 bit thread identifier */
operator|*
name|pkt
operator|=
literal|'\0'
expr_stmt|;
return|return
name|pkt
return|;
block|}
end_function

begin_comment
comment|/* Encoding:   'q':8,'M':8,count:16,done:8,argthreadid:64,(threadid:64)* */
end_comment

begin_function
specifier|static
name|int
name|parse_threadlist_response
parameter_list|(
name|char
modifier|*
name|pkt
parameter_list|,
name|int
name|result_limit
parameter_list|,
name|threadref
modifier|*
name|original_echo
parameter_list|,
name|threadref
modifier|*
name|resultlist
parameter_list|,
name|int
modifier|*
name|doneflag
parameter_list|)
block|{
name|struct
name|remote_state
modifier|*
name|rs
init|=
name|get_remote_state
argument_list|()
decl_stmt|;
name|char
modifier|*
name|limit
decl_stmt|;
name|int
name|count
decl_stmt|,
name|resultcount
decl_stmt|,
name|done
decl_stmt|;
name|resultcount
operator|=
literal|0
expr_stmt|;
comment|/* Assume the 'q' and 'M chars have been stripped.  */
name|limit
operator|=
name|pkt
operator|+
operator|(
operator|(
name|rs
operator|->
name|remote_packet_size
operator|)
operator|-
name|BUF_THREAD_ID_SIZE
operator|)
expr_stmt|;
comment|/* done parse past here */
name|pkt
operator|=
name|unpack_byte
argument_list|(
name|pkt
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
comment|/* count field */
name|pkt
operator|=
name|unpack_nibble
argument_list|(
name|pkt
argument_list|,
operator|&
name|done
argument_list|)
expr_stmt|;
comment|/* The first threadid is the argument threadid.  */
name|pkt
operator|=
name|unpack_threadid
argument_list|(
name|pkt
argument_list|,
name|original_echo
argument_list|)
expr_stmt|;
comment|/* should match query packet */
while|while
condition|(
operator|(
name|count
operator|--
operator|>
literal|0
operator|)
operator|&&
operator|(
name|pkt
operator|<
name|limit
operator|)
condition|)
block|{
name|pkt
operator|=
name|unpack_threadid
argument_list|(
name|pkt
argument_list|,
name|resultlist
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|resultcount
operator|++
operator|>=
name|result_limit
condition|)
break|break;
block|}
if|if
condition|(
name|doneflag
condition|)
operator|*
name|doneflag
operator|=
name|done
expr_stmt|;
return|return
name|resultcount
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|remote_get_threadlist
parameter_list|(
name|int
name|startflag
parameter_list|,
name|threadref
modifier|*
name|nextthread
parameter_list|,
name|int
name|result_limit
parameter_list|,
name|int
modifier|*
name|done
parameter_list|,
name|int
modifier|*
name|result_count
parameter_list|,
name|threadref
modifier|*
name|threadlist
parameter_list|)
block|{
name|struct
name|remote_state
modifier|*
name|rs
init|=
name|get_remote_state
argument_list|()
decl_stmt|;
specifier|static
name|threadref
name|echo_nextthread
decl_stmt|;
name|char
modifier|*
name|threadlist_packet
init|=
name|alloca
argument_list|(
name|rs
operator|->
name|remote_packet_size
argument_list|)
decl_stmt|;
name|char
modifier|*
name|t_response
init|=
name|alloca
argument_list|(
name|rs
operator|->
name|remote_packet_size
argument_list|)
decl_stmt|;
name|int
name|result
init|=
literal|1
decl_stmt|;
comment|/* Trancate result limit to be smaller than the packet size */
if|if
condition|(
operator|(
operator|(
operator|(
name|result_limit
operator|+
literal|1
operator|)
operator|*
name|BUF_THREAD_ID_SIZE
operator|)
operator|+
literal|10
operator|)
operator|>=
operator|(
name|rs
operator|->
name|remote_packet_size
operator|)
condition|)
name|result_limit
operator|=
operator|(
operator|(
name|rs
operator|->
name|remote_packet_size
operator|)
operator|/
name|BUF_THREAD_ID_SIZE
operator|)
operator|-
literal|2
expr_stmt|;
name|pack_threadlist_request
argument_list|(
name|threadlist_packet
argument_list|,
name|startflag
argument_list|,
name|result_limit
argument_list|,
name|nextthread
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|threadlist_packet
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|t_response
argument_list|,
operator|(
name|rs
operator|->
name|remote_packet_size
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|result_count
operator|=
name|parse_threadlist_response
argument_list|(
name|t_response
operator|+
literal|2
argument_list|,
name|result_limit
argument_list|,
operator|&
name|echo_nextthread
argument_list|,
name|threadlist
argument_list|,
name|done
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|threadmatch
argument_list|(
operator|&
name|echo_nextthread
argument_list|,
name|nextthread
argument_list|)
condition|)
block|{
comment|/* FIXME: This is a good reason to drop the packet */
comment|/* Possably, there is a duplicate response */
comment|/* Possabilities :          retransmit immediatly - race conditions          retransmit after timeout - yes          exit          wait for packet, then exit        */
name|warning
argument_list|(
literal|"HMM: threadlist did not echo arg thread, dropping it\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* I choose simply exiting */
block|}
if|if
condition|(
operator|*
name|result_count
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|done
operator|!=
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"RMT ERROR : failed to get remote thread list\n"
argument_list|)
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|result
return|;
comment|/* break; */
block|}
if|if
condition|(
operator|*
name|result_count
operator|>
name|result_limit
condition|)
block|{
operator|*
name|result_count
operator|=
literal|0
expr_stmt|;
name|warning
argument_list|(
literal|"RMT ERROR: threadlist response longer than requested\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* This is the interface between remote and threads, remotes upper interface */
end_comment

begin_comment
comment|/* remote_find_new_threads retrieves the thread list and for each    thread in the list, looks up the thread in GDB's internal list,    ading the thread if it does not already exist.  This involves    getting partial thread lists from the remote target so, polling the    quit_flag is required.  */
end_comment

begin_comment
comment|/* About this many threadisds fit in a packet. */
end_comment

begin_define
define|#
directive|define
name|MAXTHREADLISTRESULTS
value|32
end_define

begin_function
specifier|static
name|int
name|remote_threadlist_iterator
parameter_list|(
name|rmt_thread_action
name|stepfunction
parameter_list|,
name|void
modifier|*
name|context
parameter_list|,
name|int
name|looplimit
parameter_list|)
block|{
name|int
name|done
decl_stmt|,
name|i
decl_stmt|,
name|result_count
decl_stmt|;
name|int
name|startflag
init|=
literal|1
decl_stmt|;
name|int
name|result
init|=
literal|1
decl_stmt|;
name|int
name|loopcount
init|=
literal|0
decl_stmt|;
specifier|static
name|threadref
name|nextthread
decl_stmt|;
specifier|static
name|threadref
name|resultthreadlist
index|[
name|MAXTHREADLISTRESULTS
index|]
decl_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
if|if
condition|(
name|loopcount
operator|++
operator|>
name|looplimit
condition|)
block|{
name|result
operator|=
literal|0
expr_stmt|;
name|warning
argument_list|(
literal|"Remote fetch threadlist -infinite loop-\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|remote_get_threadlist
argument_list|(
name|startflag
argument_list|,
operator|&
name|nextthread
argument_list|,
name|MAXTHREADLISTRESULTS
argument_list|,
operator|&
name|done
argument_list|,
operator|&
name|result_count
argument_list|,
name|resultthreadlist
argument_list|)
condition|)
block|{
name|result
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* clear for later iterations */
name|startflag
operator|=
literal|0
expr_stmt|;
comment|/* Setup to resume next batch of thread references, set nextthread.  */
if|if
condition|(
name|result_count
operator|>=
literal|1
condition|)
name|copy_threadref
argument_list|(
operator|&
name|nextthread
argument_list|,
operator|&
name|resultthreadlist
index|[
name|result_count
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|result_count
operator|--
condition|)
if|if
condition|(
operator|!
operator|(
name|result
operator|=
call|(
modifier|*
name|stepfunction
call|)
argument_list|(
operator|&
name|resultthreadlist
index|[
name|i
operator|++
index|]
argument_list|,
name|context
argument_list|)
operator|)
condition|)
break|break;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|remote_newthread_step
parameter_list|(
name|threadref
modifier|*
name|ref
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|ptid_t
name|ptid
decl_stmt|;
name|ptid
operator|=
name|pid_to_ptid
argument_list|(
name|threadref_to_int
argument_list|(
name|ref
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in_thread_list
argument_list|(
name|ptid
argument_list|)
condition|)
name|add_thread
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* continue iterator */
block|}
end_function

begin_define
define|#
directive|define
name|CRAZY_MAX_THREADS
value|1000
end_define

begin_function
specifier|static
name|ptid_t
name|remote_current_thread
parameter_list|(
name|ptid_t
name|oldpid
parameter_list|)
block|{
name|struct
name|remote_state
modifier|*
name|rs
init|=
name|get_remote_state
argument_list|()
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|rs
operator|->
name|remote_packet_size
argument_list|)
decl_stmt|;
name|putpkt
argument_list|(
literal|"qC"
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
operator|(
name|rs
operator|->
name|remote_packet_size
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'Q'
operator|&&
name|buf
index|[
literal|1
index|]
operator|==
literal|'C'
condition|)
return|return
name|pid_to_ptid
argument_list|(
name|strtol
argument_list|(
operator|&
name|buf
index|[
literal|2
index|]
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
argument_list|)
return|;
else|else
return|return
name|oldpid
return|;
block|}
end_function

begin_comment
comment|/* Find new threads for info threads command.  * Original version, using John Metzler's thread protocol.  */
end_comment

begin_function
specifier|static
name|void
name|remote_find_new_threads
parameter_list|(
name|void
parameter_list|)
block|{
name|remote_threadlist_iterator
argument_list|(
name|remote_newthread_step
argument_list|,
literal|0
argument_list|,
name|CRAZY_MAX_THREADS
argument_list|)
expr_stmt|;
if|if
condition|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
operator|==
name|MAGIC_NULL_PID
condition|)
comment|/* ack ack ack */
name|inferior_ptid
operator|=
name|remote_current_thread
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find all threads for info threads command.  * Uses new thread protocol contributed by Cisco.  * Falls back and attempts to use the older method (above)  * if the target doesn't respond to the new method.  */
end_comment

begin_function
specifier|static
name|void
name|remote_threads_info
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|remote_state
modifier|*
name|rs
init|=
name|get_remote_state
argument_list|()
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|rs
operator|->
name|remote_packet_size
argument_list|)
decl_stmt|;
name|char
modifier|*
name|bufp
decl_stmt|;
name|int
name|tid
decl_stmt|;
if|if
condition|(
name|remote_desc
operator|==
literal|0
condition|)
comment|/* paranoia */
name|error
argument_list|(
literal|"Command can only be used when connected to the remote target."
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_threadinfo_query
condition|)
block|{
name|putpkt
argument_list|(
literal|"qfThreadInfo"
argument_list|)
expr_stmt|;
name|bufp
operator|=
name|buf
expr_stmt|;
name|getpkt
argument_list|(
name|bufp
argument_list|,
operator|(
name|rs
operator|->
name|remote_packet_size
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufp
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
comment|/* q packet recognized */
block|{
while|while
condition|(
operator|*
name|bufp
operator|++
operator|==
literal|'m'
condition|)
comment|/* reply contains one or more TID */
block|{
do|do
block|{
name|tid
operator|=
name|strtol
argument_list|(
name|bufp
argument_list|,
operator|&
name|bufp
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|tid
operator|!=
literal|0
operator|&&
operator|!
name|in_thread_list
argument_list|(
name|pid_to_ptid
argument_list|(
name|tid
argument_list|)
argument_list|)
condition|)
name|add_thread
argument_list|(
name|pid_to_ptid
argument_list|(
name|tid
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|bufp
operator|++
operator|==
literal|','
condition|)
do|;
comment|/* comma-separated list */
name|putpkt
argument_list|(
literal|"qsThreadInfo"
argument_list|)
expr_stmt|;
name|bufp
operator|=
name|buf
expr_stmt|;
name|getpkt
argument_list|(
name|bufp
argument_list|,
operator|(
name|rs
operator|->
name|remote_packet_size
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return;
comment|/* done */
block|}
block|}
comment|/* Else fall back to old method based on jmetzler protocol. */
name|use_threadinfo_query
operator|=
literal|0
expr_stmt|;
name|remote_find_new_threads
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Collect a descriptive string about the given thread.  * The target may say anything it wants to about the thread  * (typically info about its blocked / runnable state, name, etc.).  * This string will appear in the info threads display.  *  * Optional: targets are not required to implement this function.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|remote_threads_extra_info
parameter_list|(
name|struct
name|thread_info
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|remote_state
modifier|*
name|rs
init|=
name|get_remote_state
argument_list|()
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|set
decl_stmt|;
name|threadref
name|id
decl_stmt|;
name|struct
name|gdb_ext_thread_info
name|threadinfo
decl_stmt|;
specifier|static
name|char
name|display_buf
index|[
literal|100
index|]
decl_stmt|;
comment|/* arbitrary... */
name|char
modifier|*
name|bufp
init|=
name|alloca
argument_list|(
name|rs
operator|->
name|remote_packet_size
argument_list|)
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
comment|/* position in display_buf */
if|if
condition|(
name|remote_desc
operator|==
literal|0
condition|)
comment|/* paranoia */
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"remote_threads_extra_info"
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_threadextra_query
condition|)
block|{
name|sprintf
argument_list|(
name|bufp
argument_list|,
literal|"qThreadExtraInfo,%x"
argument_list|,
name|PIDGET
argument_list|(
name|tp
operator|->
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|bufp
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|bufp
argument_list|,
operator|(
name|rs
operator|->
name|remote_packet_size
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufp
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|n
operator|=
name|min
argument_list|(
name|strlen
argument_list|(
name|bufp
argument_list|)
operator|/
literal|2
argument_list|,
sizeof|sizeof
argument_list|(
name|display_buf
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|hex2bin
argument_list|(
name|bufp
argument_list|,
name|display_buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|display_buf
index|[
name|result
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|display_buf
return|;
block|}
block|}
comment|/* If the above query fails, fall back to the old method.  */
name|use_threadextra_query
operator|=
literal|0
expr_stmt|;
name|set
operator|=
name|TAG_THREADID
operator||
name|TAG_EXISTS
operator||
name|TAG_THREADNAME
operator||
name|TAG_MOREDISPLAY
operator||
name|TAG_DISPLAY
expr_stmt|;
name|int_to_threadref
argument_list|(
operator|&
name|id
argument_list|,
name|PIDGET
argument_list|(
name|tp
operator|->
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_get_threadinfo
argument_list|(
operator|&
name|id
argument_list|,
name|set
argument_list|,
operator|&
name|threadinfo
argument_list|)
condition|)
if|if
condition|(
name|threadinfo
operator|.
name|active
condition|)
block|{
if|if
condition|(
operator|*
name|threadinfo
operator|.
name|shortname
condition|)
name|n
operator|+=
name|sprintf
argument_list|(
operator|&
name|display_buf
index|[
literal|0
index|]
argument_list|,
literal|" Name: %s,"
argument_list|,
name|threadinfo
operator|.
name|shortname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|threadinfo
operator|.
name|display
condition|)
name|n
operator|+=
name|sprintf
argument_list|(
operator|&
name|display_buf
index|[
name|n
index|]
argument_list|,
literal|" State: %s,"
argument_list|,
name|threadinfo
operator|.
name|display
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|threadinfo
operator|.
name|more_display
condition|)
name|n
operator|+=
name|sprintf
argument_list|(
operator|&
name|display_buf
index|[
name|n
index|]
argument_list|,
literal|" Priority: %s"
argument_list|,
name|threadinfo
operator|.
name|more_display
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
comment|/* for purely cosmetic reasons, clear up trailing commas */
if|if
condition|(
literal|','
operator|==
name|display_buf
index|[
name|n
operator|-
literal|1
index|]
condition|)
name|display_buf
index|[
name|n
operator|-
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
return|return
name|display_buf
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  Restart the remote side; this is an extended protocol operation.  */
end_comment

begin_function
specifier|static
name|void
name|extended_remote_restart
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|remote_state
modifier|*
name|rs
init|=
name|get_remote_state
argument_list|()
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|rs
operator|->
name|remote_packet_size
argument_list|)
decl_stmt|;
comment|/* Send the restart command; for reasons I don't understand the      remote side really expects a number after the "R".  */
name|buf
index|[
literal|0
index|]
operator|=
literal|'R'
expr_stmt|;
name|sprintf
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|,
literal|"%x"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* Now query for status so this looks just like we restarted      gdbserver from scratch.  */
name|putpkt
argument_list|(
literal|"?"
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
operator|(
name|rs
operator|->
name|remote_packet_size
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Clean up connection to a remote debugger.  */
end_comment

begin_function
specifier|static
name|void
name|remote_close
parameter_list|(
name|int
name|quitting
parameter_list|)
block|{
if|if
condition|(
name|remote_desc
condition|)
name|serial_close
argument_list|(
name|remote_desc
argument_list|)
expr_stmt|;
name|remote_desc
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Query the remote side for the text, data and bss offsets. */
end_comment

begin_function
specifier|static
name|void
name|get_offsets
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|remote_state
modifier|*
name|rs
init|=
name|get_remote_state
argument_list|()
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|rs
operator|->
name|remote_packet_size
argument_list|)
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|lose
decl_stmt|;
name|CORE_ADDR
name|text_addr
decl_stmt|,
name|data_addr
decl_stmt|,
name|bss_addr
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|offs
decl_stmt|;
name|putpkt
argument_list|(
literal|"qOffsets"
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
operator|(
name|rs
operator|->
name|remote_packet_size
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\000'
condition|)
return|return;
comment|/* Return silently.  Stub doesn't support 				   this command. */
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'E'
condition|)
block|{
name|warning
argument_list|(
literal|"Remote failure reply: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Pick up each field in turn.  This used to be done with scanf, but      scanf will make trouble if CORE_ADDR size doesn't match      conversion directives correctly.  The following code will work      with any size of CORE_ADDR.  */
name|text_addr
operator|=
name|data_addr
operator|=
name|bss_addr
operator|=
literal|0
expr_stmt|;
name|ptr
operator|=
name|buf
expr_stmt|;
name|lose
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|ptr
argument_list|,
literal|"Text="
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ptr
operator|+=
literal|5
expr_stmt|;
comment|/* Don't use strtol, could lose on big values.  */
while|while
condition|(
operator|*
name|ptr
operator|&&
operator|*
name|ptr
operator|!=
literal|';'
condition|)
name|text_addr
operator|=
operator|(
name|text_addr
operator|<<
literal|4
operator|)
operator|+
name|fromhex
argument_list|(
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
block|}
else|else
name|lose
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|lose
operator|&&
name|strncmp
argument_list|(
name|ptr
argument_list|,
literal|";Data="
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ptr
operator|+=
literal|6
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|&&
operator|*
name|ptr
operator|!=
literal|';'
condition|)
name|data_addr
operator|=
operator|(
name|data_addr
operator|<<
literal|4
operator|)
operator|+
name|fromhex
argument_list|(
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
block|}
else|else
name|lose
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|lose
operator|&&
name|strncmp
argument_list|(
name|ptr
argument_list|,
literal|";Bss="
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ptr
operator|+=
literal|5
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|&&
operator|*
name|ptr
operator|!=
literal|';'
condition|)
name|bss_addr
operator|=
operator|(
name|bss_addr
operator|<<
literal|4
operator|)
operator|+
name|fromhex
argument_list|(
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
block|}
else|else
name|lose
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|lose
condition|)
name|error
argument_list|(
literal|"Malformed response to offset query, %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|symfile_objfile
operator|==
name|NULL
condition|)
return|return;
name|offs
operator|=
operator|(
operator|(
expr|struct
name|section_offsets
operator|*
operator|)
name|alloca
argument_list|(
name|SIZEOF_N_SECTION_OFFSETS
argument_list|(
name|symfile_objfile
operator|->
name|num_sections
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|offs
argument_list|,
name|symfile_objfile
operator|->
name|section_offsets
argument_list|,
name|SIZEOF_N_SECTION_OFFSETS
argument_list|(
name|symfile_objfile
operator|->
name|num_sections
argument_list|)
argument_list|)
expr_stmt|;
name|offs
operator|->
name|offsets
index|[
name|SECT_OFF_TEXT
argument_list|(
name|symfile_objfile
argument_list|)
index|]
operator|=
name|text_addr
expr_stmt|;
comment|/* This is a temporary kludge to force data and bss to use the same offsets      because that's what nlmconv does now.  The real solution requires changes      to the stub and remote.c that I don't have time to do right now.  */
name|offs
operator|->
name|offsets
index|[
name|SECT_OFF_DATA
argument_list|(
name|symfile_objfile
argument_list|)
index|]
operator|=
name|data_addr
expr_stmt|;
name|offs
operator|->
name|offsets
index|[
name|SECT_OFF_BSS
argument_list|(
name|symfile_objfile
argument_list|)
index|]
operator|=
name|data_addr
expr_stmt|;
name|objfile_relocate
argument_list|(
name|symfile_objfile
argument_list|,
name|offs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stub for catch_errors.  */
end_comment

begin_function
specifier|static
name|int
name|remote_start_remote_dummy
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|start_remote
argument_list|()
expr_stmt|;
comment|/* Initialize gdb process mechanisms */
comment|/* NOTE: Return something>=0.  A -ve value is reserved for      catch_exceptions.  */
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|remote_start_remote
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|immediate_quit
operator|++
expr_stmt|;
comment|/* Allow user to interrupt it */
comment|/* Ack any packet which the remote side has already sent.  */
name|serial_write
argument_list|(
name|remote_desc
argument_list|,
literal|"+"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Let the stub know that we want it to return the thread.  */
name|set_thread
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inferior_ptid
operator|=
name|remote_current_thread
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
name|get_offsets
argument_list|()
expr_stmt|;
comment|/* Get text, data& bss offsets */
name|putpkt
argument_list|(
literal|"?"
argument_list|)
expr_stmt|;
comment|/* initiate a query from remote machine */
name|immediate_quit
operator|--
expr_stmt|;
comment|/* NOTE: See comment above in remote_start_remote_dummy().  This      function returns something>=0.  */
return|return
name|remote_start_remote_dummy
argument_list|(
name|uiout
argument_list|,
name|dummy
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Open a connection to a remote debugger.    NAME is the filename used for communication.  */
end_comment

begin_function
specifier|static
name|void
name|remote_open
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|remote_open_1
argument_list|(
name|name
argument_list|,
name|from_tty
argument_list|,
operator|&
name|remote_ops
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Just like remote_open, but with asynchronous support. */
end_comment

begin_function
specifier|static
name|void
name|remote_async_open
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|remote_open_1
argument_list|(
name|name
argument_list|,
name|from_tty
argument_list|,
operator|&
name|remote_async_ops
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Open a connection to a remote debugger using the extended    remote gdb protocol.  NAME is the filename used for communication.  */
end_comment

begin_function
specifier|static
name|void
name|extended_remote_open
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|remote_open_1
argument_list|(
name|name
argument_list|,
name|from_tty
argument_list|,
operator|&
name|extended_remote_ops
argument_list|,
literal|1
comment|/*extended_p */
argument_list|,
literal|0
comment|/* async_p */
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Just like extended_remote_open, but with asynchronous support. */
end_comment

begin_function
specifier|static
name|void
name|extended_remote_async_open
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|remote_open_1
argument_list|(
name|name
argument_list|,
name|from_tty
argument_list|,
operator|&
name|extended_async_remote_ops
argument_list|,
literal|1
comment|/*extended_p */
argument_list|,
literal|1
comment|/* async_p */
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generic code for opening a connection to a remote target.  */
end_comment

begin_function
specifier|static
name|void
name|init_all_packet_configs
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|update_packet_config
argument_list|(
operator|&
name|remote_protocol_e
argument_list|)
expr_stmt|;
name|update_packet_config
argument_list|(
operator|&
name|remote_protocol_E
argument_list|)
expr_stmt|;
name|update_packet_config
argument_list|(
operator|&
name|remote_protocol_P
argument_list|)
expr_stmt|;
name|update_packet_config
argument_list|(
operator|&
name|remote_protocol_qSymbol
argument_list|)
expr_stmt|;
name|update_packet_config
argument_list|(
operator|&
name|remote_protocol_vcont
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NR_Z_PACKET_TYPES
condition|;
name|i
operator|++
control|)
name|update_packet_config
argument_list|(
operator|&
name|remote_protocol_Z
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Force remote_write_bytes to check whether target supports binary      downloading. */
name|update_packet_config
argument_list|(
operator|&
name|remote_protocol_binary_download
argument_list|)
expr_stmt|;
name|update_packet_config
argument_list|(
operator|&
name|remote_protocol_qPart_auxv
argument_list|)
expr_stmt|;
name|update_packet_config
argument_list|(
operator|&
name|remote_protocol_qPart_dirty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Symbol look-up. */
end_comment

begin_function
specifier|static
name|void
name|remote_check_symbols
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|struct
name|remote_state
modifier|*
name|rs
init|=
name|get_remote_state
argument_list|()
decl_stmt|;
name|char
modifier|*
name|msg
decl_stmt|,
modifier|*
name|reply
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|sym
decl_stmt|;
name|int
name|end
decl_stmt|;
if|if
condition|(
name|remote_protocol_qSymbol
operator|.
name|support
operator|==
name|PACKET_DISABLE
condition|)
return|return;
name|msg
operator|=
name|alloca
argument_list|(
name|rs
operator|->
name|remote_packet_size
argument_list|)
expr_stmt|;
name|reply
operator|=
name|alloca
argument_list|(
name|rs
operator|->
name|remote_packet_size
argument_list|)
expr_stmt|;
comment|/* Invite target to request symbol lookups. */
name|putpkt
argument_list|(
literal|"qSymbol::"
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|reply
argument_list|,
operator|(
name|rs
operator|->
name|remote_packet_size
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|packet_ok
argument_list|(
name|reply
argument_list|,
operator|&
name|remote_protocol_qSymbol
argument_list|)
expr_stmt|;
while|while
condition|(
name|strncmp
argument_list|(
name|reply
argument_list|,
literal|"qSymbol:"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tmp
operator|=
operator|&
name|reply
index|[
literal|8
index|]
expr_stmt|;
name|end
operator|=
name|hex2bin
argument_list|(
name|tmp
argument_list|,
name|msg
argument_list|,
name|strlen
argument_list|(
name|tmp
argument_list|)
operator|/
literal|2
argument_list|)
expr_stmt|;
name|msg
index|[
name|end
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sym
operator|=
name|lookup_minimal_symbol
argument_list|(
name|msg
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"qSymbol::%s"
argument_list|,
operator|&
name|reply
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"qSymbol:%s:%s"
argument_list|,
name|paddr_nz
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|,
operator|&
name|reply
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|reply
argument_list|,
operator|(
name|rs
operator|->
name|remote_packet_size
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|serial
modifier|*
name|remote_serial_open
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|static
name|int
name|udp_warning
init|=
literal|0
decl_stmt|;
comment|/* FIXME: Parsing NAME here is a hack.  But we want to warn here instead      of in ser-tcp.c, because it is the remote protocol assuming that the      serial connection is reliable and not the serial connection promising      to be.  */
if|if
condition|(
operator|!
name|udp_warning
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"udp:"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"The remote protocol may be unreliable over UDP."
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"Some events may be lost, rendering further debugging "
literal|"impossible."
argument_list|)
expr_stmt|;
name|udp_warning
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|serial_open
argument_list|(
name|name
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|remote_open_1
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|target_ops
modifier|*
name|target
parameter_list|,
name|int
name|extended_p
parameter_list|,
name|int
name|async_p
parameter_list|)
block|{
name|int
name|ex
decl_stmt|;
name|struct
name|remote_state
modifier|*
name|rs
init|=
name|get_remote_state
argument_list|()
decl_stmt|;
if|if
condition|(
name|name
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"To open a remote debug connection, you need to specify what\n"
literal|"serial device is attached to the remote system\n"
literal|"(e.g. /dev/ttyS0, /dev/ttya, COM1, etc.)."
argument_list|)
expr_stmt|;
comment|/* See FIXME above */
if|if
condition|(
operator|!
name|async_p
condition|)
name|wait_forever_enabled_p
operator|=
literal|1
expr_stmt|;
name|target_preopen
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
name|unpush_target
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|remote_desc
operator|=
name|remote_serial_open
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|remote_desc
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|baud_rate
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|serial_setbaudrate
argument_list|(
name|remote_desc
argument_list|,
name|baud_rate
argument_list|)
condition|)
block|{
comment|/* The requested speed could not be set.  Error out to 	     top level after closing remote_desc.  Take care to 	     set remote_desc to NULL to avoid closing remote_desc 	     more than once.  */
name|serial_close
argument_list|(
name|remote_desc
argument_list|)
expr_stmt|;
name|remote_desc
operator|=
name|NULL
expr_stmt|;
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|serial_raw
argument_list|(
name|remote_desc
argument_list|)
expr_stmt|;
comment|/* If there is something sitting in the buffer we might take it as a      response to a command, which would be bad.  */
name|serial_flush_input
argument_list|(
name|remote_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|puts_filtered
argument_list|(
literal|"Remote debugging using "
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|push_target
argument_list|(
name|target
argument_list|)
expr_stmt|;
comment|/* Switch to using remote target now */
name|init_all_packet_configs
argument_list|()
expr_stmt|;
name|general_thread
operator|=
operator|-
literal|2
expr_stmt|;
name|continue_thread
operator|=
operator|-
literal|2
expr_stmt|;
comment|/* Probe for ability to use "ThreadInfo" query, as required.  */
name|use_threadinfo_query
operator|=
literal|1
expr_stmt|;
name|use_threadextra_query
operator|=
literal|1
expr_stmt|;
comment|/* Without this, some commands which require an active target (such      as kill) won't work.  This variable serves (at least) double duty      as both the pid of the target process (if it has such), and as a      flag indicating that a target is active.  These functions should      be split out into seperate variables, especially since GDB will      someday have a notion of debugging several processes.  */
name|inferior_ptid
operator|=
name|pid_to_ptid
argument_list|(
name|MAGIC_NULL_PID
argument_list|)
expr_stmt|;
if|if
condition|(
name|async_p
condition|)
block|{
comment|/* With this target we start out by owning the terminal. */
name|remote_async_terminal_ours_p
operator|=
literal|1
expr_stmt|;
comment|/* FIXME: cagney/1999-09-23: During the initial connection it is 	 assumed that the target is already ready and able to respond to 	 requests. Unfortunately remote_start_remote() eventually calls 	 wait_for_inferior() with no timeout.  wait_forever_enabled_p gets 	 around this. Eventually a mechanism that allows 	 wait_for_inferior() to expect/get timeouts will be 	 implemented. */
name|wait_forever_enabled_p
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SOLIB_CREATE_INFERIOR_HOOK
comment|/* First delete any symbols previously loaded from shared libraries. */
name|no_shared_libraries
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Start the remote connection.  If error() or QUIT, discard this      target (we'd otherwise be in an inconsistent state) and then      propogate the error on up the exception chain.  This ensures that      the caller doesn't stumble along blindly assuming that the      function succeeded.  The CLI doesn't have this problem but other      UI's, such as MI do.       FIXME: cagney/2002-05-19: Instead of re-throwing the exception,      this function should return an error indication letting the      caller restore the previous state.  Unfortunately the command      ``target remote'' is directly wired to this function making that      impossible.  On a positive note, the CLI side of this problem has      been fixed - the function set_cmd_context() makes it possible for      all the ``target ....'' commands to share a common callback      function.  See cli-dump.c.  */
name|ex
operator|=
name|catch_exceptions
argument_list|(
name|uiout
argument_list|,
name|remote_start_remote
argument_list|,
name|NULL
argument_list|,
literal|"Couldn't establish connection to remote"
literal|" target\n"
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ex
operator|<
literal|0
condition|)
block|{
name|pop_target
argument_list|()
expr_stmt|;
if|if
condition|(
name|async_p
condition|)
name|wait_forever_enabled_p
operator|=
literal|1
expr_stmt|;
name|throw_exception
argument_list|(
name|ex
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|async_p
condition|)
name|wait_forever_enabled_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|extended_p
condition|)
block|{
comment|/* Tell the remote that we are using the extended protocol.  */
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|rs
operator|->
name|remote_packet_size
argument_list|)
decl_stmt|;
name|putpkt
argument_list|(
literal|"!"
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
operator|(
name|rs
operator|->
name|remote_packet_size
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SOLIB_CREATE_INFERIOR_HOOK
comment|/* FIXME: need a master target_open vector from which all      remote_opens can be called, so that stuff like this can      go there.  Failing that, the following code must be copied      to the open function for any remote target that wants to      support svr4 shared libraries.  */
comment|/* Set up to detect and load shared libraries. */
if|if
condition|(
name|exec_bfd
condition|)
comment|/* No use without an exec file. */
block|{
name|SOLIB_CREATE_INFERIOR_HOOK
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
name|remote_check_symbols
argument_list|(
name|symfile_objfile
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* This takes a program previously attached to and detaches it.  After    this is done, GDB can be used to debug some other program.  We    better not have left any breakpoints in the target program or it'll    die when it hits one.  */
end_comment

begin_function
specifier|static
name|void
name|remote_detach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|remote_state
modifier|*
name|rs
init|=
name|get_remote_state
argument_list|()
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|rs
operator|->
name|remote_packet_size
argument_list|)
decl_stmt|;
if|if
condition|(
name|args
condition|)
name|error
argument_list|(
literal|"Argument given to \"detach\" when remotely debugging."
argument_list|)
expr_stmt|;
comment|/* Tell the remote target to detach.  */
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"D"
argument_list|)
expr_stmt|;
name|remote_send
argument_list|(
name|buf
argument_list|,
operator|(
name|rs
operator|->
name|remote_packet_size
operator|)
argument_list|)
expr_stmt|;
comment|/* Unregister the file descriptor from the event loop. */
if|if
condition|(
name|target_is_async_p
argument_list|()
condition|)
name|serial_async
argument_list|(
name|remote_desc
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|target_mourn_inferior
argument_list|()
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|puts_filtered
argument_list|(
literal|"Ending remote debugging.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Same as remote_detach, but don't send the "D" packet; just disconnect.  */
end_comment

begin_function
specifier|static
name|void
name|remote_disconnect
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|remote_state
modifier|*
name|rs
init|=
name|get_remote_state
argument_list|()
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|rs
operator|->
name|remote_packet_size
argument_list|)
decl_stmt|;
if|if
condition|(
name|args
condition|)
name|error
argument_list|(
literal|"Argument given to \"detach\" when remotely debugging."
argument_list|)
expr_stmt|;
comment|/* Unregister the file descriptor from the event loop. */
if|if
condition|(
name|target_is_async_p
argument_list|()
condition|)
name|serial_async
argument_list|(
name|remote_desc
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|target_mourn_inferior
argument_list|()
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|puts_filtered
argument_list|(
literal|"Ending remote debugging.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert hex digit A to a number.  */
end_comment

begin_function
specifier|static
name|int
name|fromhex
parameter_list|(
name|int
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|>=
literal|'0'
operator|&&
name|a
operator|<=
literal|'9'
condition|)
return|return
name|a
operator|-
literal|'0'
return|;
elseif|else
if|if
condition|(
name|a
operator|>=
literal|'a'
operator|&&
name|a
operator|<=
literal|'f'
condition|)
return|return
name|a
operator|-
literal|'a'
operator|+
literal|10
return|;
elseif|else
if|if
condition|(
name|a
operator|>=
literal|'A'
operator|&&
name|a
operator|<=
literal|'F'
condition|)
return|return
name|a
operator|-
literal|'A'
operator|+
literal|10
return|;
else|else
name|error
argument_list|(
literal|"Reply contains invalid hex digit %d"
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|hex2bin
parameter_list|(
specifier|const
name|char
modifier|*
name|hex
parameter_list|,
name|char
modifier|*
name|bin
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hex
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|hex
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
comment|/* Hex string is short, or of uneven length. 	     Return the count that has been converted so far. */
return|return
name|i
return|;
block|}
operator|*
name|bin
operator|++
operator|=
name|fromhex
argument_list|(
name|hex
index|[
literal|0
index|]
argument_list|)
operator|*
literal|16
operator|+
name|fromhex
argument_list|(
name|hex
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|hex
operator|+=
literal|2
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Convert number NIB to a hex digit.  */
end_comment

begin_function
specifier|static
name|int
name|tohex
parameter_list|(
name|int
name|nib
parameter_list|)
block|{
if|if
condition|(
name|nib
operator|<
literal|10
condition|)
return|return
literal|'0'
operator|+
name|nib
return|;
else|else
return|return
literal|'a'
operator|+
name|nib
operator|-
literal|10
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bin2hex
parameter_list|(
specifier|const
name|char
modifier|*
name|bin
parameter_list|,
name|char
modifier|*
name|hex
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* May use a length, or a nul-terminated string as input. */
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|count
operator|=
name|strlen
argument_list|(
name|bin
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|hex
operator|++
operator|=
name|tohex
argument_list|(
operator|(
operator|*
name|bin
operator|>>
literal|4
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
operator|*
name|hex
operator|++
operator|=
name|tohex
argument_list|(
operator|*
name|bin
operator|++
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
operator|*
name|hex
operator|=
literal|0
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Check for the availability of vCont.  This function should also check    the response.  */
end_comment

begin_function
specifier|static
name|void
name|remote_vcont_probe
parameter_list|(
name|struct
name|remote_state
modifier|*
name|rs
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"vCont?"
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
name|rs
operator|->
name|remote_packet_size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Make sure that the features we assume are supported.  */
if|if
condition|(
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"vCont"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|p
init|=
operator|&
name|buf
index|[
literal|5
index|]
decl_stmt|;
name|int
name|support_s
decl_stmt|,
name|support_S
decl_stmt|,
name|support_c
decl_stmt|,
name|support_C
decl_stmt|;
name|support_s
operator|=
literal|0
expr_stmt|;
name|support_S
operator|=
literal|0
expr_stmt|;
name|support_c
operator|=
literal|0
expr_stmt|;
name|support_C
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|p
operator|&&
operator|*
name|p
operator|==
literal|';'
condition|)
block|{
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'s'
operator|&&
operator|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|';'
operator|||
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|0
operator|)
condition|)
name|support_s
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'S'
operator|&&
operator|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|';'
operator|||
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|0
operator|)
condition|)
name|support_S
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'c'
operator|&&
operator|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|';'
operator|||
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|0
operator|)
condition|)
name|support_c
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'C'
operator|&&
operator|(
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|';'
operator|||
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|0
operator|)
condition|)
name|support_C
operator|=
literal|1
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
block|}
comment|/* If s, S, c, and C are not all supported, we can't use vCont.  Clearing          BUF will make packet_ok disable the packet.  */
if|if
condition|(
operator|!
name|support_s
operator|||
operator|!
name|support_S
operator|||
operator|!
name|support_c
operator|||
operator|!
name|support_C
condition|)
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|packet_ok
argument_list|(
name|buf
argument_list|,
operator|&
name|remote_protocol_vcont
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Resume the remote inferior by using a "vCont" packet.  The thread    to be resumed is PTID; STEP and SIGGNAL indicate whether the    resumed thread should be single-stepped and/or signalled.  If PTID's    PID is -1, then all threads are resumed; the thread to be stepped and/or    signalled is given in the global INFERIOR_PTID.  This function returns    non-zero iff it resumes the inferior.     This function issues a strict subset of all possible vCont commands at the    moment.  */
end_comment

begin_function
specifier|static
name|int
name|remote_vcont_resume
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|step
parameter_list|,
name|enum
name|target_signal
name|siggnal
parameter_list|)
block|{
name|struct
name|remote_state
modifier|*
name|rs
init|=
name|get_remote_state
argument_list|()
decl_stmt|;
name|int
name|pid
init|=
name|PIDGET
argument_list|(
name|ptid
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|,
modifier|*
name|outbuf
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_cleanup
decl_stmt|;
name|buf
operator|=
name|xmalloc
argument_list|(
name|rs
operator|->
name|remote_packet_size
argument_list|)
expr_stmt|;
name|old_cleanup
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_protocol_vcont
operator|.
name|support
operator|==
name|PACKET_SUPPORT_UNKNOWN
condition|)
name|remote_vcont_probe
argument_list|(
name|rs
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_protocol_vcont
operator|.
name|support
operator|==
name|PACKET_DISABLE
condition|)
block|{
name|do_cleanups
argument_list|(
name|old_cleanup
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* If we could generate a wider range of packets, we'd have to worry      about overflowing BUF.  Should there be a generic      "multi-part-packet" packet?  */
if|if
condition|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
operator|==
name|MAGIC_NULL_PID
condition|)
block|{
comment|/* MAGIC_NULL_PTID means that we don't have any active threads, so we 	 don't have any PID numbers the inferior will understand.  Make sure 	 to only send forms that do not specify a PID.  */
if|if
condition|(
name|step
operator|&&
name|siggnal
operator|!=
name|TARGET_SIGNAL_0
condition|)
name|outbuf
operator|=
name|xstrprintf
argument_list|(
literal|"vCont;S%02x"
argument_list|,
name|siggnal
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|step
condition|)
name|outbuf
operator|=
name|xstrprintf
argument_list|(
literal|"vCont;s"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|siggnal
operator|!=
name|TARGET_SIGNAL_0
condition|)
name|outbuf
operator|=
name|xstrprintf
argument_list|(
literal|"vCont;C%02x"
argument_list|,
name|siggnal
argument_list|)
expr_stmt|;
else|else
name|outbuf
operator|=
name|xstrprintf
argument_list|(
literal|"vCont;c"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Resume all threads, with preference for INFERIOR_PTID.  */
if|if
condition|(
name|step
operator|&&
name|siggnal
operator|!=
name|TARGET_SIGNAL_0
condition|)
name|outbuf
operator|=
name|xstrprintf
argument_list|(
literal|"vCont;S%02x:%x;c"
argument_list|,
name|siggnal
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|step
condition|)
name|outbuf
operator|=
name|xstrprintf
argument_list|(
literal|"vCont;s:%x;c"
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|siggnal
operator|!=
name|TARGET_SIGNAL_0
condition|)
name|outbuf
operator|=
name|xstrprintf
argument_list|(
literal|"vCont;C%02x:%x;c"
argument_list|,
name|siggnal
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|outbuf
operator|=
name|xstrprintf
argument_list|(
literal|"vCont;c"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Scheduler locking; resume only PTID.  */
if|if
condition|(
name|step
operator|&&
name|siggnal
operator|!=
name|TARGET_SIGNAL_0
condition|)
name|outbuf
operator|=
name|xstrprintf
argument_list|(
literal|"vCont;S%02x:%x"
argument_list|,
name|siggnal
argument_list|,
name|pid
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|step
condition|)
name|outbuf
operator|=
name|xstrprintf
argument_list|(
literal|"vCont;s:%x"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|siggnal
operator|!=
name|TARGET_SIGNAL_0
condition|)
name|outbuf
operator|=
name|xstrprintf
argument_list|(
literal|"vCont;C%02x:%x"
argument_list|,
name|siggnal
argument_list|,
name|pid
argument_list|)
expr_stmt|;
else|else
name|outbuf
operator|=
name|xstrprintf
argument_list|(
literal|"vCont;c:%x"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
block|}
name|gdb_assert
argument_list|(
name|outbuf
operator|&&
name|strlen
argument_list|(
name|outbuf
argument_list|)
operator|<
name|rs
operator|->
name|remote_packet_size
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|outbuf
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|outbuf
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_cleanup
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Tell the remote machine to resume.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|target_signal
name|last_sent_signal
init|=
name|TARGET_SIGNAL_0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|last_sent_step
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|remote_resume
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|step
parameter_list|,
name|enum
name|target_signal
name|siggnal
parameter_list|)
block|{
name|struct
name|remote_state
modifier|*
name|rs
init|=
name|get_remote_state
argument_list|()
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|rs
operator|->
name|remote_packet_size
argument_list|)
decl_stmt|;
name|int
name|pid
init|=
name|PIDGET
argument_list|(
name|ptid
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|last_sent_signal
operator|=
name|siggnal
expr_stmt|;
name|last_sent_step
operator|=
name|step
expr_stmt|;
comment|/* A hook for when we need to do something at the last moment before      resumption.  */
if|if
condition|(
name|target_resume_hook
condition|)
call|(
modifier|*
name|target_resume_hook
call|)
argument_list|()
expr_stmt|;
comment|/* The vCont packet doesn't need to specify threads via Hc.  */
if|if
condition|(
name|remote_vcont_resume
argument_list|(
name|ptid
argument_list|,
name|step
argument_list|,
name|siggnal
argument_list|)
condition|)
return|return;
comment|/* All other supported resume packets do use Hc, so call set_thread.  */
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
name|set_thread
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* run any thread */
else|else
name|set_thread
argument_list|(
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* run this thread */
comment|/* The s/S/c/C packets do not return status.  So if the target does      not support the S or C packets, the debug agent returns an empty      string which is detected in remote_wait().  This protocol defect      is fixed in the e/E packets. */
if|if
condition|(
name|step
operator|&&
name|step_range_end
condition|)
block|{
comment|/* If the target does not support the 'E' packet, we try the 'S' 	 packet.  Ideally we would fall back to the 'e' packet if that 	 too is not supported.  But that would require another copy of 	 the code to issue the 'e' packet (and fall back to 's' if not 	 supported) in remote_wait().  */
if|if
condition|(
name|siggnal
operator|!=
name|TARGET_SIGNAL_0
condition|)
block|{
if|if
condition|(
name|remote_protocol_E
operator|.
name|support
operator|!=
name|PACKET_DISABLE
condition|)
block|{
name|p
operator|=
name|buf
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'E'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|tohex
argument_list|(
operator|(
operator|(
name|int
operator|)
name|siggnal
operator|>>
literal|4
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|tohex
argument_list|(
operator|(
operator|(
name|int
operator|)
name|siggnal
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|','
expr_stmt|;
name|p
operator|+=
name|hexnumstr
argument_list|(
name|p
argument_list|,
operator|(
name|ULONGEST
operator|)
name|step_range_start
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|','
expr_stmt|;
name|p
operator|+=
name|hexnumstr
argument_list|(
name|p
argument_list|,
operator|(
name|ULONGEST
operator|)
name|step_range_end
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
operator|(
name|rs
operator|->
name|remote_packet_size
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|packet_ok
argument_list|(
name|buf
argument_list|,
operator|&
name|remote_protocol_E
argument_list|)
operator|==
name|PACKET_OK
condition|)
return|return;
block|}
block|}
else|else
block|{
if|if
condition|(
name|remote_protocol_e
operator|.
name|support
operator|!=
name|PACKET_DISABLE
condition|)
block|{
name|p
operator|=
name|buf
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'e'
expr_stmt|;
name|p
operator|+=
name|hexnumstr
argument_list|(
name|p
argument_list|,
operator|(
name|ULONGEST
operator|)
name|step_range_start
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|','
expr_stmt|;
name|p
operator|+=
name|hexnumstr
argument_list|(
name|p
argument_list|,
operator|(
name|ULONGEST
operator|)
name|step_range_end
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
operator|(
name|rs
operator|->
name|remote_packet_size
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|packet_ok
argument_list|(
name|buf
argument_list|,
operator|&
name|remote_protocol_e
argument_list|)
operator|==
name|PACKET_OK
condition|)
return|return;
block|}
block|}
block|}
if|if
condition|(
name|siggnal
operator|!=
name|TARGET_SIGNAL_0
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|step
condition|?
literal|'S'
else|:
literal|'C'
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|tohex
argument_list|(
operator|(
operator|(
name|int
operator|)
name|siggnal
operator|>>
literal|4
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|tohex
argument_list|(
operator|(
operator|(
name|int
operator|)
name|siggnal
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|buf
argument_list|,
name|step
condition|?
literal|"s"
else|:
literal|"c"
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Same as remote_resume, but with async support. */
end_comment

begin_function
specifier|static
name|void
name|remote_async_resume
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|step
parameter_list|,
name|enum
name|target_signal
name|siggnal
parameter_list|)
block|{
name|remote_resume
argument_list|(
name|ptid
argument_list|,
name|step
argument_list|,
name|siggnal
argument_list|)
expr_stmt|;
comment|/* We are about to start executing the inferior, let's register it      with the event loop. NOTE: this is the one place where all the      execution commands end up. We could alternatively do this in each      of the execution commands in infcmd.c.*/
comment|/* FIXME: ezannoni 1999-09-28: We may need to move this out of here      into infcmd.c in order to allow inferior function calls to work      NOT asynchronously. */
if|if
condition|(
name|event_loop_p
operator|&&
name|target_can_async_p
argument_list|()
condition|)
name|target_async
argument_list|(
name|inferior_event_handler
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Tell the world that the target is now executing. */
comment|/* FIXME: cagney/1999-09-23: Is it the targets responsibility to set      this?  Instead, should the client of target just assume (for      async targets) that the target is going to start executing?  Is      this information already found in the continuation block?  */
if|if
condition|(
name|target_is_async_p
argument_list|()
condition|)
name|target_executing
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Set up the signal handler for SIGINT, while the target is    executing, ovewriting the 'regular' SIGINT signal handler. */
end_comment

begin_function
specifier|static
name|void
name|initialize_sigint_signal_handler
parameter_list|(
name|void
parameter_list|)
block|{
name|sigint_remote_token
operator|=
name|create_async_signal_handler
argument_list|(
name|async_remote_interrupt
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|handle_remote_sigint
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Signal handler for SIGINT, while the target is executing. */
end_comment

begin_function
specifier|static
name|void
name|handle_remote_sigint
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|signal
argument_list|(
name|sig
argument_list|,
name|handle_remote_sigint_twice
argument_list|)
expr_stmt|;
name|sigint_remote_twice_token
operator|=
name|create_async_signal_handler
argument_list|(
name|async_remote_interrupt_twice
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mark_async_signal_handler_wrapper
argument_list|(
name|sigint_remote_token
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Signal handler for SIGINT, installed after SIGINT has already been    sent once.  It will take effect the second time that the user sends    a ^C. */
end_comment

begin_function
specifier|static
name|void
name|handle_remote_sigint_twice
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
name|signal
argument_list|(
name|sig
argument_list|,
name|handle_sigint
argument_list|)
expr_stmt|;
name|sigint_remote_twice_token
operator|=
name|create_async_signal_handler
argument_list|(
name|inferior_event_handler_wrapper
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mark_async_signal_handler_wrapper
argument_list|(
name|sigint_remote_twice_token
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform the real interruption of the target execution, in response    to a ^C. */
end_comment

begin_function
specifier|static
name|void
name|async_remote_interrupt
parameter_list|(
name|gdb_client_data
name|arg
parameter_list|)
block|{
if|if
condition|(
name|remote_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"remote_interrupt called\n"
argument_list|)
expr_stmt|;
name|target_stop
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform interrupt, if the first attempt did not succeed. Just give    up on the target alltogether. */
end_comment

begin_function
name|void
name|async_remote_interrupt_twice
parameter_list|(
name|gdb_client_data
name|arg
parameter_list|)
block|{
if|if
condition|(
name|remote_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"remote_interrupt_twice called\n"
argument_list|)
expr_stmt|;
comment|/* Do something only if the target was not killed by the previous      cntl-C. */
if|if
condition|(
name|target_executing
condition|)
block|{
name|interrupt_query
argument_list|()
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|handle_remote_sigint
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Reinstall the usual SIGINT handlers, after the target has    stopped. */
end_comment

begin_function
specifier|static
name|void
name|cleanup_sigint_signal_handler
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|handle_sigint
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigint_remote_twice_token
condition|)
name|delete_async_signal_handler
argument_list|(
operator|(
expr|struct
name|async_signal_handler
operator|*
operator|*
operator|)
operator|&
name|sigint_remote_twice_token
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigint_remote_token
condition|)
name|delete_async_signal_handler
argument_list|(
operator|(
expr|struct
name|async_signal_handler
operator|*
operator|*
operator|)
operator|&
name|sigint_remote_token
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Send ^C to target to halt it.  Target will respond, and send us a    packet.  */
end_comment

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|ofunc
function_decl|)
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The command line interface's stop routine. This function is installed    as a signal handler for SIGINT. The first time a user requests a    stop, we call remote_stop to send a break or ^C. If there is no    response from the target (it didn't stop when the user requested it),    we ask the user if he'd like to detach from the target. */
end_comment

begin_function
specifier|static
name|void
name|remote_interrupt
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
comment|/* If this doesn't work, try more severe steps. */
name|signal
argument_list|(
name|signo
argument_list|,
name|remote_interrupt_twice
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"remote_interrupt called\n"
argument_list|)
expr_stmt|;
name|target_stop
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The user typed ^C twice.  */
end_comment

begin_function
specifier|static
name|void
name|remote_interrupt_twice
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
name|signal
argument_list|(
name|signo
argument_list|,
name|ofunc
argument_list|)
expr_stmt|;
name|interrupt_query
argument_list|()
expr_stmt|;
name|signal
argument_list|(
name|signo
argument_list|,
name|remote_interrupt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is the generic stop called via the target vector. When a target    interrupt is requested, either by the command line or the GUI, we    will eventually end up here. */
end_comment

begin_function
specifier|static
name|void
name|remote_stop
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Send a break or a ^C, depending on user preference.  */
if|if
condition|(
name|remote_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"remote_stop called\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_break
condition|)
name|serial_send_break
argument_list|(
name|remote_desc
argument_list|)
expr_stmt|;
else|else
name|serial_write
argument_list|(
name|remote_desc
argument_list|,
literal|"\003"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Ask the user what to do when an interrupt is received.  */
end_comment

begin_function
specifier|static
name|void
name|interrupt_query
parameter_list|(
name|void
parameter_list|)
block|{
name|target_terminal_ours
argument_list|()
expr_stmt|;
if|if
condition|(
name|query
argument_list|(
literal|"Interrupted while waiting for the program.\n\ Give up (and stop debugging it)? "
argument_list|)
condition|)
block|{
name|target_mourn_inferior
argument_list|()
expr_stmt|;
name|throw_exception
argument_list|(
name|RETURN_QUIT
argument_list|)
expr_stmt|;
block|}
name|target_terminal_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Enable/disable target terminal ownership.  Most targets can use    terminal groups to control terminal ownership.  Remote targets are    different in that explicit transfer of ownership to/from GDB/target    is required. */
end_comment

begin_function
specifier|static
name|void
name|remote_async_terminal_inferior
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* FIXME: cagney/1999-09-27: Shouldn't need to test for      sync_execution here.  This function should only be called when      GDB is resuming the inferior in the forground.  A background      resume (``run&'') should leave GDB in control of the terminal and      consequently should not call this code. */
if|if
condition|(
operator|!
name|sync_execution
condition|)
return|return;
comment|/* FIXME: cagney/1999-09-27: Closely related to the above.  Make      calls target_terminal_*() idenpotent. The event-loop GDB talking      to an asynchronous target with a synchronous command calls this      function from both event-top.c and infrun.c/infcmd.c.  Once GDB      stops trying to transfer the terminal to the target when it      shouldn't this guard can go away.  */
if|if
condition|(
operator|!
name|remote_async_terminal_ours_p
condition|)
return|return;
name|delete_file_handler
argument_list|(
name|input_fd
argument_list|)
expr_stmt|;
name|remote_async_terminal_ours_p
operator|=
literal|0
expr_stmt|;
name|initialize_sigint_signal_handler
argument_list|()
expr_stmt|;
comment|/* NOTE: At this point we could also register our selves as the      recipient of all input.  Any characters typed could then be      passed on down to the target. */
block|}
end_function

begin_function
specifier|static
name|void
name|remote_async_terminal_ours
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* See FIXME in remote_async_terminal_inferior. */
if|if
condition|(
operator|!
name|sync_execution
condition|)
return|return;
comment|/* See FIXME in remote_async_terminal_inferior. */
if|if
condition|(
name|remote_async_terminal_ours_p
condition|)
return|return;
name|cleanup_sigint_signal_handler
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|add_file_handler
argument_list|(
name|input_fd
argument_list|,
name|stdin_event_handler
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|remote_async_terminal_ours_p
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If nonzero, ignore the next kill.  */
end_comment

begin_decl_stmt
name|int
name|kill_kludge
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|remote_console_output
parameter_list|(
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|msg
init|;
name|p
index|[
literal|0
index|]
operator|&&
name|p
index|[
literal|1
index|]
condition|;
name|p
operator|+=
literal|2
control|)
block|{
name|char
name|tb
index|[
literal|2
index|]
decl_stmt|;
name|char
name|c
init|=
name|fromhex
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
operator|*
literal|16
operator|+
name|fromhex
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|tb
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|tb
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|fputs_unfiltered
argument_list|(
name|tb
argument_list|,
name|gdb_stdtarg
argument_list|)
expr_stmt|;
block|}
name|gdb_flush
argument_list|(
name|gdb_stdtarg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wait until the remote machine stops, then return,    storing status in STATUS just as `wait' would.    Returns "pid", which in the case of a multi-threaded    remote OS, is the thread-id.  */
end_comment

begin_function
specifier|static
name|ptid_t
name|remote_wait
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
name|status
parameter_list|)
block|{
name|struct
name|remote_state
modifier|*
name|rs
init|=
name|get_remote_state
argument_list|()
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|rs
operator|->
name|remote_packet_size
argument_list|)
decl_stmt|;
name|ULONGEST
name|thread_num
init|=
operator|-
literal|1
decl_stmt|;
name|ULONGEST
name|addr
decl_stmt|;
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|integer
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|ofunc
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|remote_interrupt
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
operator|(
name|rs
operator|->
name|remote_packet_size
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|ofunc
argument_list|)
expr_stmt|;
comment|/* This is a hook for when we need to do something (perhaps the          collection of trace data) every time the target stops.  */
if|if
condition|(
name|target_wait_loop_hook
condition|)
call|(
modifier|*
name|target_wait_loop_hook
call|)
argument_list|()
expr_stmt|;
name|remote_stopped_by_watchpoint_p
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|buf
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'E'
case|:
comment|/* Error of some sort */
name|warning
argument_list|(
literal|"Remote failure reply: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'F'
case|:
comment|/* File-I/O request */
name|remote_fileio_request
argument_list|(
name|buf
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'T'
case|:
comment|/* Status with PC, SP, FP, ... */
block|{
name|int
name|i
decl_stmt|;
name|char
name|regs
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
comment|/* Expedited reply, containing Signal, {regno, reg} repeat */
comment|/*  format is:  'Tssn...:r...;n...:r...;n...:r...;#cc', where 	       ss = signal number 	       n... = register number 	       r... = register contents 	     */
name|p
operator|=
operator|&
name|buf
index|[
literal|3
index|]
expr_stmt|;
comment|/* after Txx */
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|unsigned
name|char
modifier|*
name|p1
decl_stmt|;
name|char
modifier|*
name|p_temp
decl_stmt|;
name|int
name|fieldsize
decl_stmt|;
name|LONGEST
name|pnum
init|=
literal|0
decl_stmt|;
comment|/* If the packet contains a register number save it in pnum 		   and set p1 to point to the character following it. 		   Otherwise p1 points to p.  */
comment|/* If this packet is an awatch packet, don't parse the 'a' 		   as a register number.  */
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"awatch"
argument_list|,
name|strlen
argument_list|(
literal|"awatch"
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Read the ``P'' register number.  */
name|pnum
operator|=
name|strtol
argument_list|(
name|p
argument_list|,
operator|&
name|p_temp
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|p1
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|p_temp
expr_stmt|;
block|}
else|else
name|p1
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|p1
operator|==
name|p
condition|)
comment|/* No register number present here */
block|{
name|p1
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|p
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|==
name|NULL
condition|)
name|warning
argument_list|(
literal|"Malformed packet(a) (missing colon): %s\n\ Packet: '%s'\n"
argument_list|,
name|p
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"thread"
argument_list|,
name|p1
operator|-
name|p
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p_temp
operator|=
name|unpack_varlen_hex
argument_list|(
operator|++
name|p1
argument_list|,
operator|&
name|thread_num
argument_list|)
expr_stmt|;
name|record_currthread
argument_list|(
name|thread_num
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|p_temp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"watch"
argument_list|,
name|p1
operator|-
name|p
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"rwatch"
argument_list|,
name|p1
operator|-
name|p
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"awatch"
argument_list|,
name|p1
operator|-
name|p
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|remote_stopped_by_watchpoint_p
operator|=
literal|1
expr_stmt|;
name|p
operator|=
name|unpack_varlen_hex
argument_list|(
operator|++
name|p1
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
name|remote_watch_data_address
operator|=
operator|(
name|CORE_ADDR
operator|)
name|addr
expr_stmt|;
block|}
else|else
block|{
comment|/* Silently skip unknown optional info.  */
name|p_temp
operator|=
name|strchr
argument_list|(
name|p1
operator|+
literal|1
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_temp
condition|)
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|p_temp
expr_stmt|;
block|}
block|}
else|else
block|{
name|struct
name|packet_reg
modifier|*
name|reg
init|=
name|packet_reg_from_pnum
argument_list|(
name|rs
argument_list|,
name|pnum
argument_list|)
decl_stmt|;
name|p
operator|=
name|p1
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|':'
condition|)
name|error
argument_list|(
literal|"Malformed packet(b) (missing colon): %s\nPacket: '%s'\n"
argument_list|,
name|p
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Remote sent bad register number %s: %s\nPacket: '%s'\n"
argument_list|,
name|phex_nz
argument_list|(
name|pnum
argument_list|,
literal|0
argument_list|)
argument_list|,
name|p
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fieldsize
operator|=
name|hex2bin
argument_list|(
name|p
argument_list|,
name|regs
argument_list|,
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|reg
operator|->
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
operator|*
name|fieldsize
expr_stmt|;
if|if
condition|(
name|fieldsize
operator|<
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|reg
operator|->
name|regnum
argument_list|)
condition|)
name|warning
argument_list|(
literal|"Remote reply is too short: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|reg
operator|->
name|regnum
argument_list|,
name|regs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|';'
condition|)
name|error
argument_list|(
literal|"Remote register badly formatted: %s\nhere: %s"
argument_list|,
name|buf
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* fall through */
case|case
literal|'S'
case|:
comment|/* Old style status, just signal only */
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
operator|(
expr|enum
name|target_signal
operator|)
operator|(
operator|(
operator|(
name|fromhex
argument_list|(
name|buf
index|[
literal|1
index|]
argument_list|)
operator|)
operator|<<
literal|4
operator|)
operator|+
operator|(
name|fromhex
argument_list|(
name|buf
index|[
literal|2
index|]
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|3
index|]
operator|==
literal|'p'
condition|)
block|{
name|thread_num
operator|=
name|strtol
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|buf
index|[
literal|4
index|]
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|record_currthread
argument_list|(
name|thread_num
argument_list|)
expr_stmt|;
block|}
goto|goto
name|got_status
goto|;
case|case
literal|'W'
case|:
comment|/* Target exited */
block|{
comment|/* The remote process exited.  */
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|integer
operator|=
operator|(
name|fromhex
argument_list|(
name|buf
index|[
literal|1
index|]
argument_list|)
operator|<<
literal|4
operator|)
operator|+
name|fromhex
argument_list|(
name|buf
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
goto|goto
name|got_status
goto|;
block|}
case|case
literal|'X'
case|:
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_SIGNALLED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
operator|(
expr|enum
name|target_signal
operator|)
operator|(
operator|(
operator|(
name|fromhex
argument_list|(
name|buf
index|[
literal|1
index|]
argument_list|)
operator|)
operator|<<
literal|4
operator|)
operator|+
operator|(
name|fromhex
argument_list|(
name|buf
index|[
literal|2
index|]
argument_list|)
operator|)
operator|)
expr_stmt|;
name|kill_kludge
operator|=
literal|1
expr_stmt|;
goto|goto
name|got_status
goto|;
case|case
literal|'O'
case|:
comment|/* Console output */
name|remote_console_output
argument_list|(
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'\0'
case|:
if|if
condition|(
name|last_sent_signal
operator|!=
name|TARGET_SIGNAL_0
condition|)
block|{
comment|/* Zero length reply means that we tried 'S' or 'C' and 	         the remote system doesn't support it.  */
name|target_terminal_ours_for_output
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Can't send signals to this remote system.  %s not sent.\n"
argument_list|,
name|target_signal_to_name
argument_list|(
name|last_sent_signal
argument_list|)
argument_list|)
expr_stmt|;
name|last_sent_signal
operator|=
name|TARGET_SIGNAL_0
expr_stmt|;
name|target_terminal_inferior
argument_list|()
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|last_sent_step
condition|?
literal|"s"
else|:
literal|"c"
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* else fallthrough */
default|default:
name|warning
argument_list|(
literal|"Invalid remote reply: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|got_status
label|:
if|if
condition|(
name|thread_num
operator|!=
operator|-
literal|1
condition|)
block|{
return|return
name|pid_to_ptid
argument_list|(
name|thread_num
argument_list|)
return|;
block|}
return|return
name|inferior_ptid
return|;
block|}
end_function

begin_comment
comment|/* Async version of remote_wait. */
end_comment

begin_function
specifier|static
name|ptid_t
name|remote_async_wait
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
name|status
parameter_list|)
block|{
name|struct
name|remote_state
modifier|*
name|rs
init|=
name|get_remote_state
argument_list|()
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|rs
operator|->
name|remote_packet_size
argument_list|)
decl_stmt|;
name|ULONGEST
name|thread_num
init|=
operator|-
literal|1
decl_stmt|;
name|ULONGEST
name|addr
decl_stmt|;
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|integer
operator|=
literal|0
expr_stmt|;
name|remote_stopped_by_watchpoint_p
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|target_is_async_p
argument_list|()
condition|)
name|ofunc
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|remote_interrupt
argument_list|)
expr_stmt|;
comment|/* FIXME: cagney/1999-09-27: If we're in async mode we should          _never_ wait for ever -> test on target_is_async_p().          However, before we do that we need to ensure that the caller          knows how to take the target into/out of async mode. */
name|getpkt
argument_list|(
name|buf
argument_list|,
operator|(
name|rs
operator|->
name|remote_packet_size
operator|)
argument_list|,
name|wait_forever_enabled_p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target_is_async_p
argument_list|()
condition|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|ofunc
argument_list|)
expr_stmt|;
comment|/* This is a hook for when we need to do something (perhaps the          collection of trace data) every time the target stops.  */
if|if
condition|(
name|target_wait_loop_hook
condition|)
call|(
modifier|*
name|target_wait_loop_hook
call|)
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|buf
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'E'
case|:
comment|/* Error of some sort */
name|warning
argument_list|(
literal|"Remote failure reply: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'F'
case|:
comment|/* File-I/O request */
name|remote_fileio_request
argument_list|(
name|buf
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'T'
case|:
comment|/* Status with PC, SP, FP, ... */
block|{
name|int
name|i
decl_stmt|;
name|char
name|regs
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
comment|/* Expedited reply, containing Signal, {regno, reg} repeat */
comment|/*  format is:  'Tssn...:r...;n...:r...;n...:r...;#cc', where 	       ss = signal number 	       n... = register number 	       r... = register contents 	     */
name|p
operator|=
operator|&
name|buf
index|[
literal|3
index|]
expr_stmt|;
comment|/* after Txx */
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|unsigned
name|char
modifier|*
name|p1
decl_stmt|;
name|char
modifier|*
name|p_temp
decl_stmt|;
name|int
name|fieldsize
decl_stmt|;
name|long
name|pnum
init|=
literal|0
decl_stmt|;
comment|/* If the packet contains a register number, save it in pnum 		   and set p1 to point to the character following it. 		   Otherwise p1 points to p.  */
comment|/* If this packet is an awatch packet, don't parse the 'a' 		   as a register number.  */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"awatch"
argument_list|,
name|strlen
argument_list|(
literal|"awatch"
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Read the register number.  */
name|pnum
operator|=
name|strtol
argument_list|(
name|p
argument_list|,
operator|&
name|p_temp
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|p1
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|p_temp
expr_stmt|;
block|}
else|else
name|p1
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|p1
operator|==
name|p
condition|)
comment|/* No register number present here */
block|{
name|p1
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|p
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Malformed packet(a) (missing colon): %s\nPacket: '%s'\n"
argument_list|,
name|p
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"thread"
argument_list|,
name|p1
operator|-
name|p
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p_temp
operator|=
name|unpack_varlen_hex
argument_list|(
operator|++
name|p1
argument_list|,
operator|&
name|thread_num
argument_list|)
expr_stmt|;
name|record_currthread
argument_list|(
name|thread_num
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|p_temp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"watch"
argument_list|,
name|p1
operator|-
name|p
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"rwatch"
argument_list|,
name|p1
operator|-
name|p
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"awatch"
argument_list|,
name|p1
operator|-
name|p
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|remote_stopped_by_watchpoint_p
operator|=
literal|1
expr_stmt|;
name|p
operator|=
name|unpack_varlen_hex
argument_list|(
operator|++
name|p1
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
name|remote_watch_data_address
operator|=
operator|(
name|CORE_ADDR
operator|)
name|addr
expr_stmt|;
block|}
else|else
block|{
comment|/* Silently skip unknown optional info.  */
name|p_temp
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|strchr
argument_list|(
name|p1
operator|+
literal|1
argument_list|,
literal|';'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_temp
condition|)
name|p
operator|=
name|p_temp
expr_stmt|;
block|}
block|}
else|else
block|{
name|struct
name|packet_reg
modifier|*
name|reg
init|=
name|packet_reg_from_pnum
argument_list|(
name|rs
argument_list|,
name|pnum
argument_list|)
decl_stmt|;
name|p
operator|=
name|p1
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|':'
condition|)
name|error
argument_list|(
literal|"Malformed packet(b) (missing colon): %s\nPacket: '%s'\n"
argument_list|,
name|p
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Remote sent bad register number %ld: %s\nPacket: '%s'\n"
argument_list|,
name|pnum
argument_list|,
name|p
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fieldsize
operator|=
name|hex2bin
argument_list|(
name|p
argument_list|,
name|regs
argument_list|,
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|reg
operator|->
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
operator|*
name|fieldsize
expr_stmt|;
if|if
condition|(
name|fieldsize
operator|<
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|reg
operator|->
name|regnum
argument_list|)
condition|)
name|warning
argument_list|(
literal|"Remote reply is too short: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|reg
operator|->
name|regnum
argument_list|,
name|regs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|';'
condition|)
name|error
argument_list|(
literal|"Remote register badly formatted: %s\nhere: %s"
argument_list|,
name|buf
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* fall through */
case|case
literal|'S'
case|:
comment|/* Old style status, just signal only */
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
operator|(
expr|enum
name|target_signal
operator|)
operator|(
operator|(
operator|(
name|fromhex
argument_list|(
name|buf
index|[
literal|1
index|]
argument_list|)
operator|)
operator|<<
literal|4
operator|)
operator|+
operator|(
name|fromhex
argument_list|(
name|buf
index|[
literal|2
index|]
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|3
index|]
operator|==
literal|'p'
condition|)
block|{
name|thread_num
operator|=
name|strtol
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
operator|&
name|buf
index|[
literal|4
index|]
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|record_currthread
argument_list|(
name|thread_num
argument_list|)
expr_stmt|;
block|}
goto|goto
name|got_status
goto|;
case|case
literal|'W'
case|:
comment|/* Target exited */
block|{
comment|/* The remote process exited.  */
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|integer
operator|=
operator|(
name|fromhex
argument_list|(
name|buf
index|[
literal|1
index|]
argument_list|)
operator|<<
literal|4
operator|)
operator|+
name|fromhex
argument_list|(
name|buf
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
goto|goto
name|got_status
goto|;
block|}
case|case
literal|'X'
case|:
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_SIGNALLED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
operator|(
expr|enum
name|target_signal
operator|)
operator|(
operator|(
operator|(
name|fromhex
argument_list|(
name|buf
index|[
literal|1
index|]
argument_list|)
operator|)
operator|<<
literal|4
operator|)
operator|+
operator|(
name|fromhex
argument_list|(
name|buf
index|[
literal|2
index|]
argument_list|)
operator|)
operator|)
expr_stmt|;
name|kill_kludge
operator|=
literal|1
expr_stmt|;
goto|goto
name|got_status
goto|;
case|case
literal|'O'
case|:
comment|/* Console output */
name|remote_console_output
argument_list|(
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Return immediately to the event loop. The event loop will              still be waiting on the inferior afterwards. */
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_IGNORE
expr_stmt|;
goto|goto
name|got_status
goto|;
case|case
literal|'\0'
case|:
if|if
condition|(
name|last_sent_signal
operator|!=
name|TARGET_SIGNAL_0
condition|)
block|{
comment|/* Zero length reply means that we tried 'S' or 'C' and 	         the remote system doesn't support it.  */
name|target_terminal_ours_for_output
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Can't send signals to this remote system.  %s not sent.\n"
argument_list|,
name|target_signal_to_name
argument_list|(
name|last_sent_signal
argument_list|)
argument_list|)
expr_stmt|;
name|last_sent_signal
operator|=
name|TARGET_SIGNAL_0
expr_stmt|;
name|target_terminal_inferior
argument_list|()
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|last_sent_step
condition|?
literal|"s"
else|:
literal|"c"
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* else fallthrough */
default|default:
name|warning
argument_list|(
literal|"Invalid remote reply: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|got_status
label|:
if|if
condition|(
name|thread_num
operator|!=
operator|-
literal|1
condition|)
block|{
return|return
name|pid_to_ptid
argument_list|(
name|thread_num
argument_list|)
return|;
block|}
return|return
name|inferior_ptid
return|;
block|}
end_function

begin_comment
comment|/* Number of bytes of registers this stub implements.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|register_bytes_found
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read the remote registers into the block REGS.  */
end_comment

begin_comment
comment|/* Currently we just read all the registers, so we don't use regnum.  */
end_comment

begin_function
specifier|static
name|void
name|remote_fetch_registers
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
name|struct
name|remote_state
modifier|*
name|rs
init|=
name|get_remote_state
argument_list|()
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|rs
operator|->
name|remote_packet_size
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|regs
init|=
name|alloca
argument_list|(
name|rs
operator|->
name|sizeof_g_packet
argument_list|)
decl_stmt|;
name|set_thread
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|>=
literal|0
condition|)
block|{
name|struct
name|packet_reg
modifier|*
name|reg
init|=
name|packet_reg_from_regnum
argument_list|(
name|rs
argument_list|,
name|regnum
argument_list|)
decl_stmt|;
name|gdb_assert
argument_list|(
name|reg
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reg
operator|->
name|in_g_packet
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Attempt to fetch a non G-packet register when this "
literal|"remote.c does not support the p-packet."
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"g"
argument_list|)
expr_stmt|;
name|remote_send
argument_list|(
name|buf
argument_list|,
operator|(
name|rs
operator|->
name|remote_packet_size
operator|)
argument_list|)
expr_stmt|;
comment|/* Save the size of the packet sent to us by the target.  Its used      as a heuristic when determining the max size of packets that the      target can safely receive. */
if|if
condition|(
operator|(
name|rs
operator|->
name|actual_register_packet_size
operator|)
operator|==
literal|0
condition|)
operator|(
name|rs
operator|->
name|actual_register_packet_size
operator|)
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* Unimplemented registers read as all bits zero.  */
name|memset
argument_list|(
name|regs
argument_list|,
literal|0
argument_list|,
name|rs
operator|->
name|sizeof_g_packet
argument_list|)
expr_stmt|;
comment|/* We can get out of synch in various cases.  If the first character      in the buffer is not a hex character, assume that has happened      and try to fetch another packet to read.  */
while|while
condition|(
operator|(
name|buf
index|[
literal|0
index|]
operator|<
literal|'0'
operator|||
name|buf
index|[
literal|0
index|]
operator|>
literal|'9'
operator|)
operator|&&
operator|(
name|buf
index|[
literal|0
index|]
operator|<
literal|'a'
operator|||
name|buf
index|[
literal|0
index|]
operator|>
literal|'f'
operator|)
operator|&&
name|buf
index|[
literal|0
index|]
operator|!=
literal|'x'
condition|)
comment|/* New: unavailable register value */
block|{
if|if
condition|(
name|remote_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"Bad register packet; fetching a new packet\n"
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
operator|(
name|rs
operator|->
name|remote_packet_size
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Reply describes registers byte by byte, each byte encoded as two      hex characters.  Suck them all up, then supply them to the      register cacheing/storage mechanism.  */
name|p
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rs
operator|->
name|sizeof_g_packet
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"Remote reply is of odd length: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* Don't change register_bytes_found in this case, and don't 	     print a second warning.  */
goto|goto
name|supply_them
goto|;
block|}
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'x'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'x'
condition|)
name|regs
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 'x' */
else|else
name|regs
index|[
name|i
index|]
operator|=
name|fromhex
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
operator|*
literal|16
operator|+
name|fromhex
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
name|register_bytes_found
condition|)
block|{
name|register_bytes_found
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|REGISTER_BYTES_OK_P
argument_list|()
operator|&&
operator|!
name|REGISTER_BYTES_OK
argument_list|(
name|i
argument_list|)
condition|)
name|warning
argument_list|(
literal|"Remote reply is too short: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|supply_them
label|:
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|packet_reg
modifier|*
name|r
init|=
operator|&
name|rs
operator|->
name|regs
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|r
operator|->
name|in_g_packet
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|offset
operator|*
literal|2
operator|>=
name|strlen
argument_list|(
name|buf
argument_list|)
condition|)
comment|/* A short packet that didn't include the register's                  value, this implies that the register is zero (and                  not that the register is unavailable).  Supply that                  zero value.  */
name|regcache_raw_supply
argument_list|(
name|current_regcache
argument_list|,
name|r
operator|->
name|regnum
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|buf
index|[
name|r
operator|->
name|offset
operator|*
literal|2
index|]
operator|==
literal|'x'
condition|)
block|{
name|gdb_assert
argument_list|(
name|r
operator|->
name|offset
operator|*
literal|2
operator|<
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The register isn't available, mark it as such (at                    the same time setting the value to zero).  */
name|regcache_raw_supply
argument_list|(
name|current_regcache
argument_list|,
name|r
operator|->
name|regnum
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|set_register_cached
argument_list|(
name|i
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|regcache_raw_supply
argument_list|(
name|current_regcache
argument_list|,
name|r
operator|->
name|regnum
argument_list|,
name|regs
operator|+
name|r
operator|->
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Prepare to store registers.  Since we may send them all (using a    'G' request), we have to read out the ones we don't want to change    first.  */
end_comment

begin_function
specifier|static
name|void
name|remote_prepare_to_store
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|remote_state
modifier|*
name|rs
init|=
name|get_remote_state
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
comment|/* Make sure the entire registers array is valid.  */
switch|switch
condition|(
name|remote_protocol_P
operator|.
name|support
condition|)
block|{
case|case
name|PACKET_DISABLE
case|:
case|case
name|PACKET_SUPPORT_UNKNOWN
case|:
comment|/* Make sure all the necessary registers are cached.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rs
operator|->
name|regs
index|[
name|i
index|]
operator|.
name|in_g_packet
condition|)
name|regcache_raw_read
argument_list|(
name|current_regcache
argument_list|,
name|rs
operator|->
name|regs
index|[
name|i
index|]
operator|.
name|regnum
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|PACKET_ENABLE
case|:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Helper: Attempt to store REGNUM using the P packet.  Return fail IFF    packet was not recognized. */
end_comment

begin_function
specifier|static
name|int
name|store_register_using_P
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
name|struct
name|remote_state
modifier|*
name|rs
init|=
name|get_remote_state
argument_list|()
decl_stmt|;
name|struct
name|packet_reg
modifier|*
name|reg
init|=
name|packet_reg_from_regnum
argument_list|(
name|rs
argument_list|,
name|regnum
argument_list|)
decl_stmt|;
comment|/* Try storing a single register.  */
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|rs
operator|->
name|remote_packet_size
argument_list|)
decl_stmt|;
name|char
name|regp
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"P%s="
argument_list|,
name|phex_nz
argument_list|(
name|reg
operator|->
name|pnum
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|regcache_collect
argument_list|(
name|reg
operator|->
name|regnum
argument_list|,
name|regp
argument_list|)
expr_stmt|;
name|bin2hex
argument_list|(
name|regp
argument_list|,
name|p
argument_list|,
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|reg
operator|->
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
name|remote_send
argument_list|(
name|buf
argument_list|,
name|rs
operator|->
name|remote_packet_size
argument_list|)
expr_stmt|;
return|return
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
return|;
block|}
end_function

begin_comment
comment|/* Store register REGNUM, or all registers if REGNUM == -1, from the contents    of the register cache buffer.  FIXME: ignores errors.  */
end_comment

begin_function
specifier|static
name|void
name|remote_store_registers
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
name|struct
name|remote_state
modifier|*
name|rs
init|=
name|get_remote_state
argument_list|()
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|regs
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|set_thread
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|regnum
operator|>=
literal|0
condition|)
block|{
switch|switch
condition|(
name|remote_protocol_P
operator|.
name|support
condition|)
block|{
case|case
name|PACKET_DISABLE
case|:
break|break;
case|case
name|PACKET_ENABLE
case|:
if|if
condition|(
name|store_register_using_P
argument_list|(
name|regnum
argument_list|)
condition|)
return|return;
else|else
name|error
argument_list|(
literal|"Protocol error: P packet not recognized by stub"
argument_list|)
expr_stmt|;
case|case
name|PACKET_SUPPORT_UNKNOWN
case|:
if|if
condition|(
name|store_register_using_P
argument_list|(
name|regnum
argument_list|)
condition|)
block|{
comment|/* The stub recognized the 'P' packet.  Remember this.  */
name|remote_protocol_P
operator|.
name|support
operator|=
name|PACKET_ENABLE
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* The stub does not support the 'P' packet.  Use 'G' 	         instead, and don't try using 'P' in the future (it 	         will just waste our time).  */
name|remote_protocol_P
operator|.
name|support
operator|=
name|PACKET_DISABLE
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Extract all the registers in the regcache copying them into a      local buffer.  */
block|{
name|int
name|i
decl_stmt|;
name|regs
operator|=
name|alloca
argument_list|(
name|rs
operator|->
name|sizeof_g_packet
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|regs
argument_list|,
name|rs
operator|->
name|sizeof_g_packet
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|packet_reg
modifier|*
name|r
init|=
operator|&
name|rs
operator|->
name|regs
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|r
operator|->
name|in_g_packet
condition|)
name|regcache_collect
argument_list|(
name|r
operator|->
name|regnum
argument_list|,
name|regs
operator|+
name|r
operator|->
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Command describes registers byte by byte,      each byte encoded as two hex characters.  */
name|buf
operator|=
name|alloca
argument_list|(
name|rs
operator|->
name|remote_packet_size
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'G'
expr_stmt|;
comment|/* remote_prepare_to_store insures that register_bytes_found gets set.  */
name|bin2hex
argument_list|(
name|regs
argument_list|,
name|p
argument_list|,
name|register_bytes_found
argument_list|)
expr_stmt|;
name|remote_send
argument_list|(
name|buf
argument_list|,
operator|(
name|rs
operator|->
name|remote_packet_size
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the number of hex digits in num.  */
end_comment

begin_function
specifier|static
name|int
name|hexnumlen
parameter_list|(
name|ULONGEST
name|num
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|num
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
name|num
operator|>>=
literal|4
expr_stmt|;
return|return
name|max
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set BUF to the minimum number of hex digits representing NUM.  */
end_comment

begin_function
specifier|static
name|int
name|hexnumstr
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|ULONGEST
name|num
parameter_list|)
block|{
name|int
name|len
init|=
name|hexnumlen
argument_list|(
name|num
argument_list|)
decl_stmt|;
return|return
name|hexnumnstr
argument_list|(
name|buf
argument_list|,
name|num
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set BUF to the hex digits representing NUM, padded to WIDTH characters.  */
end_comment

begin_function
specifier|static
name|int
name|hexnumnstr
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|ULONGEST
name|num
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|buf
index|[
name|width
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
name|width
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|buf
index|[
name|i
index|]
operator|=
literal|"0123456789abcdef"
index|[
operator|(
name|num
operator|&
literal|0xf
operator|)
index|]
expr_stmt|;
name|num
operator|>>=
literal|4
expr_stmt|;
block|}
return|return
name|width
return|;
block|}
end_function

begin_comment
comment|/* Mask all but the least significant REMOTE_ADDRESS_SIZE bits. */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|remote_address_masked
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|)
block|{
if|if
condition|(
name|remote_address_size
operator|>
literal|0
operator|&&
name|remote_address_size
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|ULONGEST
argument_list|)
operator|*
literal|8
operator|)
condition|)
block|{
comment|/* Only create a mask when that mask can safely be constructed          in a ULONGEST variable. */
name|ULONGEST
name|mask
init|=
literal|1
decl_stmt|;
name|mask
operator|=
operator|(
name|mask
operator|<<
name|remote_address_size
operator|)
operator|-
literal|1
expr_stmt|;
name|addr
operator|&=
name|mask
expr_stmt|;
block|}
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* Determine whether the remote target supports binary downloading.    This is accomplished by sending a no-op memory write of zero length    to the target at the specified address. It does not suffice to send    the whole packet, since many stubs strip the eighth bit and subsequently    compute a wrong checksum, which causes real havoc with remote_write_bytes.     NOTE: This can still lose if the serial line is not eight-bit    clean. In cases like this, the user should clear "remote    X-packet". */
end_comment

begin_function
specifier|static
name|void
name|check_binary_download
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|)
block|{
name|struct
name|remote_state
modifier|*
name|rs
init|=
name|get_remote_state
argument_list|()
decl_stmt|;
switch|switch
condition|(
name|remote_protocol_binary_download
operator|.
name|support
condition|)
block|{
case|case
name|PACKET_DISABLE
case|:
break|break;
case|case
name|PACKET_ENABLE
case|:
break|break;
case|case
name|PACKET_SUPPORT_UNKNOWN
case|:
block|{
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|rs
operator|->
name|remote_packet_size
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'X'
expr_stmt|;
name|p
operator|+=
name|hexnumstr
argument_list|(
name|p
argument_list|,
operator|(
name|ULONGEST
operator|)
name|addr
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|','
expr_stmt|;
name|p
operator|+=
name|hexnumstr
argument_list|(
name|p
argument_list|,
operator|(
name|ULONGEST
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|':'
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|putpkt_binary
argument_list|(
name|buf
argument_list|,
call|(
name|int
call|)
argument_list|(
name|p
operator|-
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
operator|(
name|rs
operator|->
name|remote_packet_size
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|remote_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"binary downloading NOT suppported by target\n"
argument_list|)
expr_stmt|;
name|remote_protocol_binary_download
operator|.
name|support
operator|=
name|PACKET_DISABLE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|remote_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"binary downloading suppported by target\n"
argument_list|)
expr_stmt|;
name|remote_protocol_binary_download
operator|.
name|support
operator|=
name|PACKET_ENABLE
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Write memory data directly to the remote machine.    This does not inform the data cache; the data cache uses this.    MEMADDR is the address in the remote memory space.    MYADDR is the address of the buffer in our space.    LEN is the number of bytes.     Returns number of bytes transferred, or 0 (setting errno) for    error.  Only transfer a single packet. */
end_comment

begin_function
name|int
name|remote_write_bytes
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|char
modifier|*
name|plen
decl_stmt|;
name|long
name|sizeof_buf
decl_stmt|;
name|int
name|plenlen
decl_stmt|;
name|int
name|todo
decl_stmt|;
name|int
name|nr_bytes
decl_stmt|;
name|int
name|payload_size
decl_stmt|;
name|unsigned
name|char
modifier|*
name|payload_start
decl_stmt|;
comment|/* Verify that the target can support a binary download.  */
name|check_binary_download
argument_list|(
name|memaddr
argument_list|)
expr_stmt|;
comment|/* Compute the size, and then allocate space for the largest      possible packet.  Include space for an extra trailing NUL.  */
name|sizeof_buf
operator|=
name|get_memory_write_packet_size
argument_list|()
operator|+
literal|1
expr_stmt|;
name|buf
operator|=
name|alloca
argument_list|(
name|sizeof_buf
argument_list|)
expr_stmt|;
comment|/* Compute the size of the actual payload by subtracting out the      packet header and footer overhead: "$M<memaddr>,<len>:...#nn".  */
name|payload_size
operator|=
operator|(
name|get_memory_write_packet_size
argument_list|()
operator|-
operator|(
name|strlen
argument_list|(
literal|"$M,:#NN"
argument_list|)
operator|+
name|hexnumlen
argument_list|(
name|memaddr
argument_list|)
operator|+
name|hexnumlen
argument_list|(
name|len
argument_list|)
operator|)
operator|)
expr_stmt|;
comment|/* Construct the packet header: "[MX]<memaddr>,<len>:".   */
comment|/* Append "[XM]".  Compute a best guess of the number of bytes      actually transfered. */
name|p
operator|=
name|buf
expr_stmt|;
switch|switch
condition|(
name|remote_protocol_binary_download
operator|.
name|support
condition|)
block|{
case|case
name|PACKET_ENABLE
case|:
operator|*
name|p
operator|++
operator|=
literal|'X'
expr_stmt|;
comment|/* Best guess at number of bytes that will fit. */
name|todo
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|payload_size
argument_list|)
expr_stmt|;
break|break;
case|case
name|PACKET_DISABLE
case|:
operator|*
name|p
operator|++
operator|=
literal|'M'
expr_stmt|;
comment|/* num bytes that will fit */
name|todo
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|payload_size
operator|/
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|PACKET_SUPPORT_UNKNOWN
case|:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"remote_write_bytes: bad internal state"
argument_list|)
expr_stmt|;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"bad switch"
argument_list|)
expr_stmt|;
block|}
comment|/* Append "<memaddr>".  */
name|memaddr
operator|=
name|remote_address_masked
argument_list|(
name|memaddr
argument_list|)
expr_stmt|;
name|p
operator|+=
name|hexnumstr
argument_list|(
name|p
argument_list|,
operator|(
name|ULONGEST
operator|)
name|memaddr
argument_list|)
expr_stmt|;
comment|/* Append ",".  */
operator|*
name|p
operator|++
operator|=
literal|','
expr_stmt|;
comment|/* Append<len>.  Retain the location/size of<len>.  It may need to      be adjusted once the packet body has been created.  */
name|plen
operator|=
name|p
expr_stmt|;
name|plenlen
operator|=
name|hexnumstr
argument_list|(
name|p
argument_list|,
operator|(
name|ULONGEST
operator|)
name|todo
argument_list|)
expr_stmt|;
name|p
operator|+=
name|plenlen
expr_stmt|;
comment|/* Append ":".  */
operator|*
name|p
operator|++
operator|=
literal|':'
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* Append the packet body.  */
name|payload_start
operator|=
name|p
expr_stmt|;
switch|switch
condition|(
name|remote_protocol_binary_download
operator|.
name|support
condition|)
block|{
case|case
name|PACKET_ENABLE
case|:
comment|/* Binary mode.  Send target system values byte by byte, in 	 increasing byte addresses.  Only escape certain critical 	 characters.  */
for|for
control|(
name|nr_bytes
operator|=
literal|0
init|;
operator|(
name|nr_bytes
operator|<
name|todo
operator|)
operator|&&
operator|(
name|p
operator|-
name|payload_start
operator|)
operator|<
name|payload_size
condition|;
name|nr_bytes
operator|++
control|)
block|{
switch|switch
condition|(
name|myaddr
index|[
name|nr_bytes
index|]
operator|&
literal|0xff
condition|)
block|{
case|case
literal|'$'
case|:
case|case
literal|'#'
case|:
case|case
literal|0x7d
case|:
comment|/* These must be escaped */
operator|*
name|p
operator|++
operator|=
literal|0x7d
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|myaddr
index|[
name|nr_bytes
index|]
operator|&
literal|0xff
operator|)
operator|^
literal|0x20
expr_stmt|;
break|break;
default|default:
operator|*
name|p
operator|++
operator|=
name|myaddr
index|[
name|nr_bytes
index|]
operator|&
literal|0xff
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|nr_bytes
operator|<
name|todo
condition|)
block|{
comment|/* Escape chars have filled up the buffer prematurely, 	     and we have actually sent fewer bytes than planned. 	     Fix-up the length field of the packet.  Use the same 	     number of characters as before.  */
name|plen
operator|+=
name|hexnumnstr
argument_list|(
name|plen
argument_list|,
operator|(
name|ULONGEST
operator|)
name|nr_bytes
argument_list|,
name|plenlen
argument_list|)
expr_stmt|;
operator|*
name|plen
operator|=
literal|':'
expr_stmt|;
comment|/* overwrite \0 from hexnumnstr() */
block|}
break|break;
case|case
name|PACKET_DISABLE
case|:
comment|/* Normal mode: Send target system values byte by byte, in 	 increasing byte addresses.  Each byte is encoded as a two hex 	 value.  */
name|nr_bytes
operator|=
name|bin2hex
argument_list|(
name|myaddr
argument_list|,
name|p
argument_list|,
name|todo
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
operator|*
name|nr_bytes
expr_stmt|;
break|break;
case|case
name|PACKET_SUPPORT_UNKNOWN
case|:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"remote_write_bytes: bad internal state"
argument_list|)
expr_stmt|;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"bad switch"
argument_list|)
expr_stmt|;
block|}
name|putpkt_binary
argument_list|(
name|buf
argument_list|,
call|(
name|int
call|)
argument_list|(
name|p
operator|-
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
name|sizeof_buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'E'
condition|)
block|{
comment|/* There is no correspondance between what the remote protocol 	 uses for errors and errno codes.  We would like a cleaner way 	 of representing errors (big enough to include errno codes, 	 bfd_error codes, and others).  But for now just return EIO.  */
name|errno
operator|=
name|EIO
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Return NR_BYTES, not TODO, in case escape chars caused us to send fewer      bytes than we'd planned.  */
return|return
name|nr_bytes
return|;
block|}
end_function

begin_comment
comment|/* Read memory data directly from the remote machine.    This does not use the data cache; the data cache uses this.    MEMADDR is the address in the remote memory space.    MYADDR is the address of the buffer in our space.    LEN is the number of bytes.     Returns number of bytes transferred, or 0 for error.  */
end_comment

begin_comment
comment|/* NOTE: cagney/1999-10-18: This function (and its siblings in other    remote targets) shouldn't attempt to read the entire buffer.    Instead it should read a single packet worth of data and then    return the byte size of that packet to the caller.  The caller (its    caller and its callers caller ;-) already contains code for    handling partial reads. */
end_comment

begin_function
name|int
name|remote_read_bytes
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|max_buf_size
decl_stmt|;
comment|/* Max size of packet output buffer */
name|long
name|sizeof_buf
decl_stmt|;
name|int
name|origlen
decl_stmt|;
comment|/* Create a buffer big enough for this packet. */
name|max_buf_size
operator|=
name|get_memory_read_packet_size
argument_list|()
expr_stmt|;
name|sizeof_buf
operator|=
name|max_buf_size
operator|+
literal|1
expr_stmt|;
comment|/* Space for trailing NUL */
name|buf
operator|=
name|alloca
argument_list|(
name|sizeof_buf
argument_list|)
expr_stmt|;
name|origlen
operator|=
name|len
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|todo
decl_stmt|;
name|int
name|i
decl_stmt|;
name|todo
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|max_buf_size
operator|/
literal|2
argument_list|)
expr_stmt|;
comment|/* num bytes that will fit */
comment|/* construct "m"<memaddr>","<len>" */
comment|/* sprintf (buf, "m%lx,%x", (unsigned long) memaddr, todo); */
name|memaddr
operator|=
name|remote_address_masked
argument_list|(
name|memaddr
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'m'
expr_stmt|;
name|p
operator|+=
name|hexnumstr
argument_list|(
name|p
argument_list|,
operator|(
name|ULONGEST
operator|)
name|memaddr
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|','
expr_stmt|;
name|p
operator|+=
name|hexnumstr
argument_list|(
name|p
argument_list|,
operator|(
name|ULONGEST
operator|)
name|todo
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
name|sizeof_buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'E'
operator|&&
name|isxdigit
argument_list|(
name|buf
index|[
literal|1
index|]
argument_list|)
operator|&&
name|isxdigit
argument_list|(
name|buf
index|[
literal|2
index|]
argument_list|)
operator|&&
name|buf
index|[
literal|3
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* There is no correspondance between what the remote protocol uses 	     for errors and errno codes.  We would like a cleaner way of 	     representing errors (big enough to include errno codes, bfd_error 	     codes, and others).  But for now just return EIO.  */
name|errno
operator|=
name|EIO
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Reply describes memory byte by byte,          each byte encoded as two hex characters.  */
name|p
operator|=
name|buf
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|hex2bin
argument_list|(
name|p
argument_list|,
name|myaddr
argument_list|,
name|todo
argument_list|)
operator|)
operator|<
name|todo
condition|)
block|{
comment|/* Reply is short.  This means that we were able to read 	     only part of what we wanted to. */
return|return
name|i
operator|+
operator|(
name|origlen
operator|-
name|len
operator|)
return|;
block|}
name|myaddr
operator|+=
name|todo
expr_stmt|;
name|memaddr
operator|+=
name|todo
expr_stmt|;
name|len
operator|-=
name|todo
expr_stmt|;
block|}
return|return
name|origlen
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read or write LEN bytes from inferior memory at MEMADDR,    transferring to or from debugger address BUFFER.  Write to inferior if    SHOULD_WRITE is nonzero.  Returns length of data written or read; 0    for error.  TARGET is unused.  */
end_comment

begin_function
specifier|static
name|int
name|remote_xfer_memory
parameter_list|(
name|CORE_ADDR
name|mem_addr
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|mem_len
parameter_list|,
name|int
name|should_write
parameter_list|,
name|struct
name|mem_attrib
modifier|*
name|attrib
parameter_list|,
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
block|{
name|CORE_ADDR
name|targ_addr
decl_stmt|;
name|int
name|targ_len
decl_stmt|;
name|int
name|res
decl_stmt|;
comment|/* Should this be the selected frame?  */
name|gdbarch_remote_translate_xfer_address
argument_list|(
name|current_gdbarch
argument_list|,
name|current_regcache
argument_list|,
name|mem_addr
argument_list|,
name|mem_len
argument_list|,
operator|&
name|targ_addr
argument_list|,
operator|&
name|targ_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|targ_len
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|should_write
condition|)
name|res
operator|=
name|remote_write_bytes
argument_list|(
name|targ_addr
argument_list|,
name|buffer
argument_list|,
name|targ_len
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|remote_read_bytes
argument_list|(
name|targ_addr
argument_list|,
name|buffer
argument_list|,
name|targ_len
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|remote_files_info
parameter_list|(
name|struct
name|target_ops
modifier|*
name|ignore
parameter_list|)
block|{
name|puts_filtered
argument_list|(
literal|"Debugging a target over a serial line.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Stuff for dealing with the packets which are part of this protocol.    See comment at top of file for details.  */
end_comment

begin_comment
comment|/* Read a single character from the remote end, masking it down to 7 bits. */
end_comment

begin_function
specifier|static
name|int
name|readchar
parameter_list|(
name|int
name|timeout
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
name|ch
operator|=
name|serial_readchar
argument_list|(
name|remote_desc
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|>=
literal|0
condition|)
return|return
operator|(
name|ch
operator|&
literal|0x7f
operator|)
return|;
switch|switch
condition|(
operator|(
expr|enum
name|serial_rc
operator|)
name|ch
condition|)
block|{
case|case
name|SERIAL_EOF
case|:
name|target_mourn_inferior
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"Remote connection closed"
argument_list|)
expr_stmt|;
comment|/* no return */
case|case
name|SERIAL_ERROR
case|:
name|perror_with_name
argument_list|(
literal|"Remote communication error"
argument_list|)
expr_stmt|;
comment|/* no return */
case|case
name|SERIAL_TIMEOUT
case|:
break|break;
block|}
return|return
name|ch
return|;
block|}
end_function

begin_comment
comment|/* Send the command in BUF to the remote machine, and read the reply    into BUF.  Report an error if we get an error reply.  */
end_comment

begin_function
specifier|static
name|void
name|remote_send
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|long
name|sizeof_buf
parameter_list|)
block|{
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
name|sizeof_buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'E'
condition|)
name|error
argument_list|(
literal|"Remote failure reply: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Display a null-terminated packet on stdout, for debugging, using C    string notation.  */
end_comment

begin_function
specifier|static
name|void
name|print_packet
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|puts_filtered
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
name|fputstr_filtered
argument_list|(
name|buf
argument_list|,
literal|'"'
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|putpkt
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|)
block|{
return|return
name|putpkt_binary
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Send a packet to the remote machine, with error checking.  The data    of the packet is in BUF.  The string in BUF can be at most  (rs->remote_packet_size) - 5    to account for the $, # and checksum, and for a possible /0 if we are    debugging (remote_debug) and want to print the sent packet as a string */
end_comment

begin_function
specifier|static
name|int
name|putpkt_binary
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|struct
name|remote_state
modifier|*
name|rs
init|=
name|get_remote_state
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|csum
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|buf2
init|=
name|alloca
argument_list|(
name|cnt
operator|+
literal|6
argument_list|)
decl_stmt|;
name|long
name|sizeof_junkbuf
init|=
operator|(
name|rs
operator|->
name|remote_packet_size
operator|)
decl_stmt|;
name|char
modifier|*
name|junkbuf
init|=
name|alloca
argument_list|(
name|sizeof_junkbuf
argument_list|)
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|int
name|tcount
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Copy the packet into buffer BUF2, encapsulating it      and giving it a checksum.  */
name|p
operator|=
name|buf2
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'$'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|csum
operator|+=
name|buf
index|[
name|i
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|buf
index|[
name|i
index|]
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
literal|'#'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|tohex
argument_list|(
operator|(
name|csum
operator|>>
literal|4
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|tohex
argument_list|(
name|csum
operator|&
literal|0xf
argument_list|)
expr_stmt|;
comment|/* Send it over and over until we get a positive ack.  */
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|started_error_output
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|remote_debug
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"Sending packet: "
argument_list|)
expr_stmt|;
name|fputstrn_unfiltered
argument_list|(
name|buf2
argument_list|,
name|p
operator|-
name|buf2
argument_list|,
literal|0
argument_list|,
name|gdb_stdlog
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdlog
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|serial_write
argument_list|(
name|remote_desc
argument_list|,
name|buf2
argument_list|,
name|p
operator|-
name|buf2
argument_list|)
condition|)
name|perror_with_name
argument_list|(
literal|"putpkt: write failed"
argument_list|)
expr_stmt|;
comment|/* read until either a timeout occurs (-2) or '+' is read */
while|while
condition|(
literal|1
condition|)
block|{
name|ch
operator|=
name|readchar
argument_list|(
name|remote_timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_debug
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'+'
case|:
case|case
literal|'-'
case|:
case|case
name|SERIAL_TIMEOUT
case|:
case|case
literal|'$'
case|:
if|if
condition|(
name|started_error_output
condition|)
block|{
name|putchar_unfiltered
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|started_error_output
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'+'
case|:
if|if
condition|(
name|remote_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"Ack\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|'-'
case|:
if|if
condition|(
name|remote_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"Nak\n"
argument_list|)
expr_stmt|;
case|case
name|SERIAL_TIMEOUT
case|:
name|tcount
operator|++
expr_stmt|;
if|if
condition|(
name|tcount
operator|>
literal|3
condition|)
return|return
literal|0
return|;
break|break;
comment|/* Retransmit buffer */
case|case
literal|'$'
case|:
block|{
if|if
condition|(
name|remote_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"Packet instead of Ack, ignoring it\n"
argument_list|)
expr_stmt|;
comment|/* It's probably an old response, and we're out of sync. 		   Just gobble up the packet and ignore it.  */
name|read_frame
argument_list|(
name|junkbuf
argument_list|,
name|sizeof_junkbuf
argument_list|)
expr_stmt|;
continue|continue;
comment|/* Now, go look for + */
block|}
default|default:
if|if
condition|(
name|remote_debug
condition|)
block|{
if|if
condition|(
operator|!
name|started_error_output
condition|)
block|{
name|started_error_output
operator|=
literal|1
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"putpkt: Junk: "
argument_list|)
expr_stmt|;
block|}
name|fputc_unfiltered
argument_list|(
name|ch
operator|&
literal|0177
argument_list|,
name|gdb_stdlog
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
break|break;
comment|/* Here to retransmit */
block|}
if|#
directive|if
literal|0
comment|/* This is wrong.  If doing a long backtrace, the user should be          able to get out next time we call QUIT, without anything as          violent as interrupt_query.  If we want to provide a way out of          here without getting to the next QUIT, it should be based on          hitting ^C twice as in remote_wait.  */
block|if (quit_flag) 	{ 	  quit_flag = 0; 	  interrupt_query (); 	}
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* Come here after finding the start of the frame.  Collect the rest    into BUF, verifying the checksum, length, and handling run-length    compression.  No more than sizeof_buf-1 characters are read so that    the buffer can be NUL terminated.     Returns -1 on error, number of characters in buffer (ignoring the    trailing NULL) on success. (could be extended to return one of the    SERIAL status indications). */
end_comment

begin_function
specifier|static
name|long
name|read_frame
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|long
name|sizeof_buf
parameter_list|)
block|{
name|unsigned
name|char
name|csum
decl_stmt|;
name|long
name|bc
decl_stmt|;
name|int
name|c
decl_stmt|;
name|csum
operator|=
literal|0
expr_stmt|;
name|bc
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* ASSERT (bc< sizeof_buf - 1) - space for trailing NUL */
name|c
operator|=
name|readchar
argument_list|(
name|remote_timeout
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|SERIAL_TIMEOUT
case|:
if|if
condition|(
name|remote_debug
condition|)
name|fputs_filtered
argument_list|(
literal|"Timeout in mid-packet, retrying\n"
argument_list|,
name|gdb_stdlog
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
case|case
literal|'$'
case|:
if|if
condition|(
name|remote_debug
condition|)
name|fputs_filtered
argument_list|(
literal|"Saw new packet start in middle of old one\n"
argument_list|,
name|gdb_stdlog
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|/* Start a new packet, count retries */
case|case
literal|'#'
case|:
block|{
name|unsigned
name|char
name|pktcsum
decl_stmt|;
name|int
name|check_0
init|=
literal|0
decl_stmt|;
name|int
name|check_1
init|=
literal|0
decl_stmt|;
name|buf
index|[
name|bc
index|]
operator|=
literal|'\0'
expr_stmt|;
name|check_0
operator|=
name|readchar
argument_list|(
name|remote_timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_0
operator|>=
literal|0
condition|)
name|check_1
operator|=
name|readchar
argument_list|(
name|remote_timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_0
operator|==
name|SERIAL_TIMEOUT
operator|||
name|check_1
operator|==
name|SERIAL_TIMEOUT
condition|)
block|{
if|if
condition|(
name|remote_debug
condition|)
name|fputs_filtered
argument_list|(
literal|"Timeout in checksum, retrying\n"
argument_list|,
name|gdb_stdlog
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|check_0
operator|<
literal|0
operator|||
name|check_1
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|remote_debug
condition|)
name|fputs_filtered
argument_list|(
literal|"Communication error in checksum\n"
argument_list|,
name|gdb_stdlog
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|pktcsum
operator|=
operator|(
name|fromhex
argument_list|(
name|check_0
argument_list|)
operator|<<
literal|4
operator|)
operator||
name|fromhex
argument_list|(
name|check_1
argument_list|)
expr_stmt|;
if|if
condition|(
name|csum
operator|==
name|pktcsum
condition|)
return|return
name|bc
return|;
if|if
condition|(
name|remote_debug
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"Bad checksum, sentsum=0x%x, csum=0x%x, buf="
argument_list|,
name|pktcsum
argument_list|,
name|csum
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|buf
argument_list|,
name|gdb_stdlog
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"\n"
argument_list|,
name|gdb_stdlog
argument_list|)
expr_stmt|;
block|}
comment|/* Number of characters in buffer ignoring trailing                NUL. */
return|return
operator|-
literal|1
return|;
block|}
case|case
literal|'*'
case|:
comment|/* Run length encoding */
block|{
name|int
name|repeat
decl_stmt|;
name|csum
operator|+=
name|c
expr_stmt|;
name|c
operator|=
name|readchar
argument_list|(
name|remote_timeout
argument_list|)
expr_stmt|;
name|csum
operator|+=
name|c
expr_stmt|;
name|repeat
operator|=
name|c
operator|-
literal|' '
operator|+
literal|3
expr_stmt|;
comment|/* Compute repeat count */
comment|/* The character before ``*'' is repeated. */
if|if
condition|(
name|repeat
operator|>
literal|0
operator|&&
name|repeat
operator|<=
literal|255
operator|&&
name|bc
operator|>
literal|0
operator|&&
name|bc
operator|+
name|repeat
operator|-
literal|1
operator|<
name|sizeof_buf
operator|-
literal|1
condition|)
block|{
name|memset
argument_list|(
operator|&
name|buf
index|[
name|bc
index|]
argument_list|,
name|buf
index|[
name|bc
operator|-
literal|1
index|]
argument_list|,
name|repeat
argument_list|)
expr_stmt|;
name|bc
operator|+=
name|repeat
expr_stmt|;
continue|continue;
block|}
name|buf
index|[
name|bc
index|]
operator|=
literal|'\0'
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Repeat count %d too large for buffer: "
argument_list|,
name|repeat
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
default|default:
if|if
condition|(
name|bc
operator|<
name|sizeof_buf
operator|-
literal|1
condition|)
block|{
name|buf
index|[
name|bc
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|csum
operator|+=
name|c
expr_stmt|;
continue|continue;
block|}
name|buf
index|[
name|bc
index|]
operator|=
literal|'\0'
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"Remote packet too long: "
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Read a packet from the remote machine, with error checking, and    store it in BUF.  If FOREVER, wait forever rather than timing out;    this is used (in synchronous mode) to wait for a target that is is    executing user code to stop.  */
end_comment

begin_comment
comment|/* FIXME: ezannoni 2000-02-01 this wrapper is necessary so that we    don't have to change all the calls to getpkt to deal with the    return value, because at the moment I don't know what the right    thing to do it for those. */
end_comment

begin_function
name|void
name|getpkt
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|long
name|sizeof_buf
parameter_list|,
name|int
name|forever
parameter_list|)
block|{
name|int
name|timed_out
decl_stmt|;
name|timed_out
operator|=
name|getpkt_sane
argument_list|(
name|buf
argument_list|,
name|sizeof_buf
argument_list|,
name|forever
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read a packet from the remote machine, with error checking, and    store it in BUF.  If FOREVER, wait forever rather than timing out;    this is used (in synchronous mode) to wait for a target that is is    executing user code to stop. If FOREVER == 0, this function is    allowed to time out gracefully and return an indication of this to    the caller. */
end_comment

begin_function
specifier|static
name|int
name|getpkt_sane
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|long
name|sizeof_buf
parameter_list|,
name|int
name|forever
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|tries
decl_stmt|;
name|int
name|timeout
decl_stmt|;
name|int
name|val
decl_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"timeout"
argument_list|)
expr_stmt|;
if|if
condition|(
name|forever
condition|)
block|{
name|timeout
operator|=
name|watchdog
operator|>
literal|0
condition|?
name|watchdog
else|:
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|timeout
operator|=
name|remote_timeout
expr_stmt|;
define|#
directive|define
name|MAX_TRIES
value|3
for|for
control|(
name|tries
operator|=
literal|1
init|;
name|tries
operator|<=
name|MAX_TRIES
condition|;
name|tries
operator|++
control|)
block|{
comment|/* This can loop forever if the remote side sends us characters          continuously, but if it pauses, we'll get a zero from readchar          because of timeout.  Then we'll count that as a retry.  */
comment|/* Note that we will only wait forever prior to the start of a packet.          After that, we expect characters to arrive at a brisk pace.  They          should show up within remote_timeout intervals.  */
do|do
block|{
name|c
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|SERIAL_TIMEOUT
condition|)
block|{
if|if
condition|(
name|forever
condition|)
comment|/* Watchdog went off?  Kill the target. */
block|{
name|QUIT
expr_stmt|;
name|target_mourn_inferior
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"Watchdog has expired.  Target detached.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|remote_debug
condition|)
name|fputs_filtered
argument_list|(
literal|"Timed out.\n"
argument_list|,
name|gdb_stdlog
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
do|while
condition|(
name|c
operator|!=
literal|'$'
condition|)
do|;
comment|/* We've found the start of a packet, now collect the data.  */
name|val
operator|=
name|read_frame
argument_list|(
name|buf
argument_list|,
name|sizeof_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|remote_debug
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"Packet received: "
argument_list|)
expr_stmt|;
name|fputstr_unfiltered
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|gdb_stdlog
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|serial_write
argument_list|(
name|remote_desc
argument_list|,
literal|"+"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Try the whole thing again.  */
name|retry
label|:
name|serial_write
argument_list|(
name|remote_desc
argument_list|,
literal|"-"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* We have tried hard enough, and just can't receive the packet.  Give up. */
name|printf_unfiltered
argument_list|(
literal|"Ignoring packet error, continuing...\n"
argument_list|)
expr_stmt|;
name|serial_write
argument_list|(
name|remote_desc
argument_list|,
literal|"+"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|remote_kill
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* For some mysterious reason, wait_for_inferior calls kill instead of      mourn after it gets TARGET_WAITKIND_SIGNALLED.  Work around it.  */
if|if
condition|(
name|kill_kludge
condition|)
block|{
name|kill_kludge
operator|=
literal|0
expr_stmt|;
name|target_mourn_inferior
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Use catch_errors so the user can quit from gdb even when we aren't on      speaking terms with the remote system.  */
name|catch_errors
argument_list|(
operator|(
name|catch_errors_ftype
operator|*
operator|)
name|putpkt
argument_list|,
literal|"k"
argument_list|,
literal|""
argument_list|,
name|RETURN_MASK_ERROR
argument_list|)
expr_stmt|;
comment|/* Don't wait for it to die.  I'm not really sure it matters whether      we do or not.  For the existing stubs, kill is a noop.  */
name|target_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Async version of remote_kill. */
end_comment

begin_function
specifier|static
name|void
name|remote_async_kill
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Unregister the file descriptor from the event loop. */
if|if
condition|(
name|target_is_async_p
argument_list|()
condition|)
name|serial_async
argument_list|(
name|remote_desc
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* For some mysterious reason, wait_for_inferior calls kill instead of      mourn after it gets TARGET_WAITKIND_SIGNALLED.  Work around it.  */
if|if
condition|(
name|kill_kludge
condition|)
block|{
name|kill_kludge
operator|=
literal|0
expr_stmt|;
name|target_mourn_inferior
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Use catch_errors so the user can quit from gdb even when we aren't on      speaking terms with the remote system.  */
name|catch_errors
argument_list|(
operator|(
name|catch_errors_ftype
operator|*
operator|)
name|putpkt
argument_list|,
literal|"k"
argument_list|,
literal|""
argument_list|,
name|RETURN_MASK_ERROR
argument_list|)
expr_stmt|;
comment|/* Don't wait for it to die.  I'm not really sure it matters whether      we do or not.  For the existing stubs, kill is a noop.  */
name|target_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|remote_mourn
parameter_list|(
name|void
parameter_list|)
block|{
name|remote_mourn_1
argument_list|(
operator|&
name|remote_ops
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|remote_async_mourn
parameter_list|(
name|void
parameter_list|)
block|{
name|remote_mourn_1
argument_list|(
operator|&
name|remote_async_ops
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|extended_remote_mourn
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* We do _not_ want to mourn the target like this; this will      remove the extended remote target  from the target stack,      and the next time the user says "run" it'll fail.       FIXME: What is the right thing to do here?  */
if|#
directive|if
literal|0
block|remote_mourn_1 (&extended_remote_ops);
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Worker function for remote_mourn.  */
end_comment

begin_function
specifier|static
name|void
name|remote_mourn_1
parameter_list|(
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
block|{
name|unpush_target
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|generic_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* In the extended protocol we want to be able to do things like    "run" and have them basically work as expected.  So we need    a special create_inferior function.     FIXME: One day add support for changing the exec file    we're debugging, arguments and an environment.  */
end_comment

begin_function
specifier|static
name|void
name|extended_remote_create_inferior
parameter_list|(
name|char
modifier|*
name|exec_file
parameter_list|,
name|char
modifier|*
name|args
parameter_list|,
name|char
modifier|*
modifier|*
name|env
parameter_list|)
block|{
comment|/* Rip out the breakpoints; we'll reinsert them after restarting      the remote server.  */
name|remove_breakpoints
argument_list|()
expr_stmt|;
comment|/* Now restart the remote server.  */
name|extended_remote_restart
argument_list|()
expr_stmt|;
comment|/* Now put the breakpoints back in.  This way we're safe if the      restart function works via a unix fork on the remote side.  */
name|insert_breakpoints
argument_list|()
expr_stmt|;
comment|/* Clean up from the last time we were running.  */
name|clear_proceed_status
argument_list|()
expr_stmt|;
comment|/* Let the remote process run.  */
name|proceed
argument_list|(
operator|-
literal|1
argument_list|,
name|TARGET_SIGNAL_0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Async version of extended_remote_create_inferior. */
end_comment

begin_function
specifier|static
name|void
name|extended_remote_async_create_inferior
parameter_list|(
name|char
modifier|*
name|exec_file
parameter_list|,
name|char
modifier|*
name|args
parameter_list|,
name|char
modifier|*
modifier|*
name|env
parameter_list|)
block|{
comment|/* Rip out the breakpoints; we'll reinsert them after restarting      the remote server.  */
name|remove_breakpoints
argument_list|()
expr_stmt|;
comment|/* If running asynchronously, register the target file descriptor      with the event loop. */
if|if
condition|(
name|event_loop_p
operator|&&
name|target_can_async_p
argument_list|()
condition|)
name|target_async
argument_list|(
name|inferior_event_handler
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now restart the remote server.  */
name|extended_remote_restart
argument_list|()
expr_stmt|;
comment|/* Now put the breakpoints back in.  This way we're safe if the      restart function works via a unix fork on the remote side.  */
name|insert_breakpoints
argument_list|()
expr_stmt|;
comment|/* Clean up from the last time we were running.  */
name|clear_proceed_status
argument_list|()
expr_stmt|;
comment|/* Let the remote process run.  */
name|proceed
argument_list|(
operator|-
literal|1
argument_list|,
name|TARGET_SIGNAL_0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* On some machines, e.g. 68k, we may use a different breakpoint    instruction than other targets; in those use    DEPRECATED_REMOTE_BREAKPOINT instead of just BREAKPOINT_FROM_PC.    Also, bi-endian targets may define    DEPRECATED_LITTLE_REMOTE_BREAKPOINT and    DEPRECATED_BIG_REMOTE_BREAKPOINT.  If none of these are defined, we    just call the standard routines that are in mem-break.c.  */
end_comment

begin_comment
comment|/* NOTE: cagney/2003-06-08: This is silly.  A remote and simulator    target should use an identical BREAKPOINT_FROM_PC.  As for native,    the ARCH-OS-tdep.c code can override the default.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEPRECATED_LITTLE_REMOTE_BREAKPOINT
argument_list|)
operator|&&
name|defined
argument_list|(
name|DEPRECATED_BIG_REMOTE_BREAKPOINT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|DEPRECATED_REMOTE_BREAKPOINT
argument_list|)
end_if

begin_define
define|#
directive|define
name|DEPRECATED_REMOTE_BREAKPOINT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEPRECATED_REMOTE_BREAKPOINT
end_ifdef

begin_comment
comment|/* If the target isn't bi-endian, just pretend it is.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DEPRECATED_LITTLE_REMOTE_BREAKPOINT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|DEPRECATED_BIG_REMOTE_BREAKPOINT
argument_list|)
end_if

begin_define
define|#
directive|define
name|DEPRECATED_LITTLE_REMOTE_BREAKPOINT
value|DEPRECATED_REMOTE_BREAKPOINT
end_define

begin_define
define|#
directive|define
name|DEPRECATED_BIG_REMOTE_BREAKPOINT
value|DEPRECATED_REMOTE_BREAKPOINT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|big_break_insn
index|[]
init|=
name|DEPRECATED_BIG_REMOTE_BREAKPOINT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|little_break_insn
index|[]
init|=
name|DEPRECATED_LITTLE_REMOTE_BREAKPOINT
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEPRECATED_REMOTE_BREAKPOINT */
end_comment

begin_comment
comment|/* Insert a breakpoint on targets that don't have any better    breakpoint support.  We read the contents of the target location    and stash it, then overwrite it with a breakpoint instruction.    ADDR is the target location in the target machine.  CONTENTS_CACHE    is a pointer to memory allocated for saving the target contents.    It is guaranteed by the caller to be long enough to save the number    of bytes returned by BREAKPOINT_FROM_PC.  */
end_comment

begin_function
specifier|static
name|int
name|remote_insert_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|contents_cache
parameter_list|)
block|{
name|struct
name|remote_state
modifier|*
name|rs
init|=
name|get_remote_state
argument_list|()
decl_stmt|;
ifdef|#
directive|ifdef
name|DEPRECATED_REMOTE_BREAKPOINT
name|int
name|val
decl_stmt|;
endif|#
directive|endif
name|int
name|bp_size
decl_stmt|;
comment|/* Try the "Z" s/w breakpoint packet if it is not already disabled.      If it succeeds, then set the support to PACKET_ENABLE.  If it      fails, and the user has explicitly requested the Z support then      report an error, otherwise, mark it disabled and go on. */
if|if
condition|(
name|remote_protocol_Z
index|[
name|Z_PACKET_SOFTWARE_BP
index|]
operator|.
name|support
operator|!=
name|PACKET_DISABLE
condition|)
block|{
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|rs
operator|->
name|remote_packet_size
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
name|addr
operator|=
name|remote_address_masked
argument_list|(
name|addr
argument_list|)
expr_stmt|;
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
literal|'Z'
expr_stmt|;
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
literal|'0'
expr_stmt|;
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
literal|','
expr_stmt|;
name|p
operator|+=
name|hexnumstr
argument_list|(
name|p
argument_list|,
operator|(
name|ULONGEST
operator|)
name|addr
argument_list|)
expr_stmt|;
name|BREAKPOINT_FROM_PC
argument_list|(
operator|&
name|addr
argument_list|,
operator|&
name|bp_size
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|",%d"
argument_list|,
name|bp_size
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
operator|(
name|rs
operator|->
name|remote_packet_size
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|packet_ok
argument_list|(
name|buf
argument_list|,
operator|&
name|remote_protocol_Z
index|[
name|Z_PACKET_SOFTWARE_BP
index|]
argument_list|)
condition|)
block|{
case|case
name|PACKET_ERROR
case|:
return|return
operator|-
literal|1
return|;
case|case
name|PACKET_OK
case|:
return|return
literal|0
return|;
case|case
name|PACKET_UNKNOWN
case|:
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|DEPRECATED_REMOTE_BREAKPOINT
name|val
operator|=
name|target_read_memory
argument_list|(
name|addr
argument_list|,
name|contents_cache
argument_list|,
sizeof|sizeof
name|big_break_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|)
name|val
operator|=
name|target_write_memory
argument_list|(
name|addr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|big_break_insn
argument_list|,
sizeof|sizeof
name|big_break_insn
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|target_write_memory
argument_list|(
name|addr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|little_break_insn
argument_list|,
sizeof|sizeof
name|little_break_insn
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
else|#
directive|else
return|return
name|memory_insert_breakpoint
argument_list|(
name|addr
argument_list|,
name|contents_cache
argument_list|)
return|;
endif|#
directive|endif
comment|/* DEPRECATED_REMOTE_BREAKPOINT */
block|}
end_function

begin_function
specifier|static
name|int
name|remote_remove_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|contents_cache
parameter_list|)
block|{
name|struct
name|remote_state
modifier|*
name|rs
init|=
name|get_remote_state
argument_list|()
decl_stmt|;
name|int
name|bp_size
decl_stmt|;
if|if
condition|(
name|remote_protocol_Z
index|[
name|Z_PACKET_SOFTWARE_BP
index|]
operator|.
name|support
operator|!=
name|PACKET_DISABLE
condition|)
block|{
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|rs
operator|->
name|remote_packet_size
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
literal|'z'
expr_stmt|;
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
literal|'0'
expr_stmt|;
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
literal|','
expr_stmt|;
name|addr
operator|=
name|remote_address_masked
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|p
operator|+=
name|hexnumstr
argument_list|(
name|p
argument_list|,
operator|(
name|ULONGEST
operator|)
name|addr
argument_list|)
expr_stmt|;
name|BREAKPOINT_FROM_PC
argument_list|(
operator|&
name|addr
argument_list|,
operator|&
name|bp_size
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|",%d"
argument_list|,
name|bp_size
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
operator|(
name|rs
operator|->
name|remote_packet_size
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'E'
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DEPRECATED_REMOTE_BREAKPOINT
return|return
name|target_write_memory
argument_list|(
name|addr
argument_list|,
name|contents_cache
argument_list|,
sizeof|sizeof
name|big_break_insn
argument_list|)
return|;
else|#
directive|else
return|return
name|memory_remove_breakpoint
argument_list|(
name|addr
argument_list|,
name|contents_cache
argument_list|)
return|;
endif|#
directive|endif
comment|/* DEPRECATED_REMOTE_BREAKPOINT */
block|}
end_function

begin_function
specifier|static
name|int
name|watchpoint_to_Z_packet
parameter_list|(
name|int
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|hw_write
case|:
return|return
literal|2
return|;
break|break;
case|case
name|hw_read
case|:
return|return
literal|3
return|;
break|break;
case|case
name|hw_access
case|:
return|return
literal|4
return|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"hw_bp_to_z: bad watchpoint type %d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|remote_insert_watchpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|remote_state
modifier|*
name|rs
init|=
name|get_remote_state
argument_list|()
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|rs
operator|->
name|remote_packet_size
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|enum
name|Z_packet_type
name|packet
init|=
name|watchpoint_to_Z_packet
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|remote_protocol_Z
index|[
name|packet
index|]
operator|.
name|support
operator|==
name|PACKET_DISABLE
condition|)
name|error
argument_list|(
literal|"Can't set hardware watchpoints without the '%s' (%s) packet\n"
argument_list|,
name|remote_protocol_Z
index|[
name|packet
index|]
operator|.
name|name
argument_list|,
name|remote_protocol_Z
index|[
name|packet
index|]
operator|.
name|title
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Z%x,"
argument_list|,
name|packet
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|addr
operator|=
name|remote_address_masked
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|p
operator|+=
name|hexnumstr
argument_list|(
name|p
argument_list|,
operator|(
name|ULONGEST
operator|)
name|addr
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|",%x"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
operator|(
name|rs
operator|->
name|remote_packet_size
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|packet_ok
argument_list|(
name|buf
argument_list|,
operator|&
name|remote_protocol_Z
index|[
name|packet
index|]
argument_list|)
condition|)
block|{
case|case
name|PACKET_ERROR
case|:
case|case
name|PACKET_UNKNOWN
case|:
return|return
operator|-
literal|1
return|;
case|case
name|PACKET_OK
case|:
return|return
literal|0
return|;
block|}
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"remote_insert_watchpoint: reached end of function"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|remote_remove_watchpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|remote_state
modifier|*
name|rs
init|=
name|get_remote_state
argument_list|()
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|rs
operator|->
name|remote_packet_size
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|enum
name|Z_packet_type
name|packet
init|=
name|watchpoint_to_Z_packet
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|remote_protocol_Z
index|[
name|packet
index|]
operator|.
name|support
operator|==
name|PACKET_DISABLE
condition|)
name|error
argument_list|(
literal|"Can't clear hardware watchpoints without the '%s' (%s) packet\n"
argument_list|,
name|remote_protocol_Z
index|[
name|packet
index|]
operator|.
name|name
argument_list|,
name|remote_protocol_Z
index|[
name|packet
index|]
operator|.
name|title
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"z%x,"
argument_list|,
name|packet
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|addr
operator|=
name|remote_address_masked
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|p
operator|+=
name|hexnumstr
argument_list|(
name|p
argument_list|,
operator|(
name|ULONGEST
operator|)
name|addr
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|",%x"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
operator|(
name|rs
operator|->
name|remote_packet_size
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|packet_ok
argument_list|(
name|buf
argument_list|,
operator|&
name|remote_protocol_Z
index|[
name|packet
index|]
argument_list|)
condition|)
block|{
case|case
name|PACKET_ERROR
case|:
case|case
name|PACKET_UNKNOWN
case|:
return|return
operator|-
literal|1
return|;
case|case
name|PACKET_OK
case|:
return|return
literal|0
return|;
block|}
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"remote_remove_watchpoint: reached end of function"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|remote_hw_watchpoint_limit
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|remote_hw_breakpoint_limit
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|remote_check_watch_resources
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|cnt
parameter_list|,
name|int
name|ot
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|bp_hardware_breakpoint
condition|)
block|{
if|if
condition|(
name|remote_hw_breakpoint_limit
operator|==
literal|0
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|remote_hw_breakpoint_limit
operator|<
literal|0
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|cnt
operator|<=
name|remote_hw_breakpoint_limit
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
name|remote_hw_watchpoint_limit
operator|==
literal|0
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|remote_hw_watchpoint_limit
operator|<
literal|0
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|ot
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
name|cnt
operator|<=
name|remote_hw_watchpoint_limit
condition|)
return|return
literal|1
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|remote_stopped_by_watchpoint
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|remote_stopped_by_watchpoint_p
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|remote_stopped_data_address
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|remote_stopped_by_watchpoint
argument_list|()
condition|)
return|return
name|remote_watch_data_address
return|;
return|return
operator|(
name|CORE_ADDR
operator|)
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|remote_insert_hw_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|shadow
parameter_list|)
block|{
name|int
name|len
init|=
literal|0
decl_stmt|;
name|struct
name|remote_state
modifier|*
name|rs
init|=
name|get_remote_state
argument_list|()
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|rs
operator|->
name|remote_packet_size
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
comment|/* The length field should be set to the size of a breakpoint      instruction.  */
name|BREAKPOINT_FROM_PC
argument_list|(
operator|&
name|addr
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_protocol_Z
index|[
name|Z_PACKET_HARDWARE_BP
index|]
operator|.
name|support
operator|==
name|PACKET_DISABLE
condition|)
name|error
argument_list|(
literal|"Can't set hardware breakpoint without the '%s' (%s) packet\n"
argument_list|,
name|remote_protocol_Z
index|[
name|Z_PACKET_HARDWARE_BP
index|]
operator|.
name|name
argument_list|,
name|remote_protocol_Z
index|[
name|Z_PACKET_HARDWARE_BP
index|]
operator|.
name|title
argument_list|)
expr_stmt|;
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
literal|'Z'
expr_stmt|;
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
literal|'1'
expr_stmt|;
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
literal|','
expr_stmt|;
name|addr
operator|=
name|remote_address_masked
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|p
operator|+=
name|hexnumstr
argument_list|(
name|p
argument_list|,
operator|(
name|ULONGEST
operator|)
name|addr
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|",%x"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
operator|(
name|rs
operator|->
name|remote_packet_size
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|packet_ok
argument_list|(
name|buf
argument_list|,
operator|&
name|remote_protocol_Z
index|[
name|Z_PACKET_HARDWARE_BP
index|]
argument_list|)
condition|)
block|{
case|case
name|PACKET_ERROR
case|:
case|case
name|PACKET_UNKNOWN
case|:
return|return
operator|-
literal|1
return|;
case|case
name|PACKET_OK
case|:
return|return
literal|0
return|;
block|}
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"remote_insert_hw_breakpoint: reached end of function"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|remote_remove_hw_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|shadow
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|struct
name|remote_state
modifier|*
name|rs
init|=
name|get_remote_state
argument_list|()
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|rs
operator|->
name|remote_packet_size
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
comment|/* The length field should be set to the size of a breakpoint      instruction.  */
name|BREAKPOINT_FROM_PC
argument_list|(
operator|&
name|addr
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_protocol_Z
index|[
name|Z_PACKET_HARDWARE_BP
index|]
operator|.
name|support
operator|==
name|PACKET_DISABLE
condition|)
name|error
argument_list|(
literal|"Can't clear hardware breakpoint without the '%s' (%s) packet\n"
argument_list|,
name|remote_protocol_Z
index|[
name|Z_PACKET_HARDWARE_BP
index|]
operator|.
name|name
argument_list|,
name|remote_protocol_Z
index|[
name|Z_PACKET_HARDWARE_BP
index|]
operator|.
name|title
argument_list|)
expr_stmt|;
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
literal|'z'
expr_stmt|;
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
literal|'1'
expr_stmt|;
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
literal|','
expr_stmt|;
name|addr
operator|=
name|remote_address_masked
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|p
operator|+=
name|hexnumstr
argument_list|(
name|p
argument_list|,
operator|(
name|ULONGEST
operator|)
name|addr
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|",%x"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
operator|(
name|rs
operator|->
name|remote_packet_size
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|packet_ok
argument_list|(
name|buf
argument_list|,
operator|&
name|remote_protocol_Z
index|[
name|Z_PACKET_HARDWARE_BP
index|]
argument_list|)
condition|)
block|{
case|case
name|PACKET_ERROR
case|:
case|case
name|PACKET_UNKNOWN
case|:
return|return
operator|-
literal|1
return|;
case|case
name|PACKET_OK
case|:
return|return
literal|0
return|;
block|}
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"remote_remove_hw_breakpoint: reached end of function"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Some targets are only capable of doing downloads, and afterwards    they switch to the remote serial protocol.  This function provides    a clean way to get from the download target to the remote target.    It's basically just a wrapper so that we don't have to expose any    of the internal workings of remote.c.     Prior to calling this routine, you should shutdown the current    target code, else you will get the "A program is being debugged    already..." message.  Usually a call to pop_target() suffices.  */
end_comment

begin_function
name|void
name|push_remote_target
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|printf_filtered
argument_list|(
literal|"Switching to remote protocol\n"
argument_list|)
expr_stmt|;
name|remote_open
argument_list|(
name|name
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Table used by the crc32 function to calcuate the checksum. */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|crc32_table
index|[
literal|256
index|]
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|unsigned
name|long
name|crc32
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|,
name|unsigned
name|int
name|crc
parameter_list|)
block|{
if|if
condition|(
operator|!
name|crc32_table
index|[
literal|1
index|]
condition|)
block|{
comment|/* Initialize the CRC table and the decoding table. */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|c
operator|=
name|i
operator|<<
literal|24
operator|,
name|j
operator|=
literal|8
init|;
name|j
operator|>
literal|0
condition|;
operator|--
name|j
control|)
name|c
operator|=
name|c
operator|&
literal|0x80000000
condition|?
operator|(
name|c
operator|<<
literal|1
operator|)
operator|^
literal|0x04c11db7
else|:
operator|(
name|c
operator|<<
literal|1
operator|)
expr_stmt|;
name|crc32_table
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
block|}
block|}
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|crc
operator|=
operator|(
name|crc
operator|<<
literal|8
operator|)
operator|^
name|crc32_table
index|[
operator|(
operator|(
name|crc
operator|>>
literal|24
operator|)
operator|^
operator|*
name|buf
operator|)
operator|&
literal|255
index|]
expr_stmt|;
name|buf
operator|++
expr_stmt|;
block|}
return|return
name|crc
return|;
block|}
end_function

begin_comment
comment|/* compare-sections command     With no arguments, compares each loadable section in the exec bfd    with the same memory range on the target, and reports mismatches.    Useful for verifying the image on the target against the exec file.    Depends on the target understanding the new "qCRC:" request.  */
end_comment

begin_comment
comment|/* FIXME: cagney/1999-10-26: This command should be broken down into a    target method (target verify memory) and generic version of the    actual command.  This will allow other high-level code (especially    generic_load()) to make use of this target functionality. */
end_comment

begin_function
specifier|static
name|void
name|compare_sections_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|remote_state
modifier|*
name|rs
init|=
name|get_remote_state
argument_list|()
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|unsigned
name|long
name|host_crc
decl_stmt|,
name|target_crc
decl_stmt|;
specifier|extern
name|bfd
modifier|*
name|exec_bfd
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
name|char
modifier|*
name|sectdata
decl_stmt|;
specifier|const
name|char
modifier|*
name|sectname
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|rs
operator|->
name|remote_packet_size
argument_list|)
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|bfd_vma
name|lma
decl_stmt|;
name|int
name|matched
init|=
literal|0
decl_stmt|;
name|int
name|mismatched
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|exec_bfd
condition|)
name|error
argument_list|(
literal|"command cannot be used without an exec file"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|current_target
operator|.
name|to_shortname
operator|||
name|strcmp
argument_list|(
name|current_target
operator|.
name|to_shortname
argument_list|,
literal|"remote"
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"command can only be used with remote target"
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|exec_bfd
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
condition|)
continue|continue;
comment|/* skip non-loadable section */
name|size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
continue|continue;
comment|/* skip zero-length section */
name|sectname
operator|=
name|bfd_get_section_name
argument_list|(
name|exec_bfd
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|&&
name|strcmp
argument_list|(
name|args
argument_list|,
name|sectname
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* not the section selected by user */
name|matched
operator|=
literal|1
expr_stmt|;
comment|/* do this section */
name|lma
operator|=
name|s
operator|->
name|lma
expr_stmt|;
comment|/* FIXME: assumes lma can fit into long */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"qCRC:%lx,%lx"
argument_list|,
operator|(
name|long
operator|)
name|lma
argument_list|,
operator|(
name|long
operator|)
name|size
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* be clever; compute the host_crc before waiting for target reply */
name|sectdata
operator|=
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|sectdata
argument_list|)
expr_stmt|;
name|bfd_get_section_contents
argument_list|(
name|exec_bfd
argument_list|,
name|s
argument_list|,
name|sectdata
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|host_crc
operator|=
name|crc32
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|sectdata
argument_list|,
name|size
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
operator|(
name|rs
operator|->
name|remote_packet_size
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'E'
condition|)
name|error
argument_list|(
literal|"target memory fault, section %s, range 0x%s -- 0x%s"
argument_list|,
name|sectname
argument_list|,
name|paddr
argument_list|(
name|lma
argument_list|)
argument_list|,
name|paddr
argument_list|(
name|lma
operator|+
name|size
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'C'
condition|)
name|error
argument_list|(
literal|"remote target does not support this operation"
argument_list|)
expr_stmt|;
for|for
control|(
name|target_crc
operator|=
literal|0
operator|,
name|tmp
operator|=
operator|&
name|buf
index|[
literal|1
index|]
init|;
operator|*
name|tmp
condition|;
name|tmp
operator|++
control|)
name|target_crc
operator|=
name|target_crc
operator|*
literal|16
operator|+
name|fromhex
argument_list|(
operator|*
name|tmp
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Section %s, range 0x%s -- 0x%s: "
argument_list|,
name|sectname
argument_list|,
name|paddr
argument_list|(
name|lma
argument_list|)
argument_list|,
name|paddr
argument_list|(
name|lma
operator|+
name|size
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|host_crc
operator|==
name|target_crc
condition|)
name|printf_filtered
argument_list|(
literal|"matched.\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|printf_filtered
argument_list|(
literal|"MIS-MATCHED!\n"
argument_list|)
expr_stmt|;
name|mismatched
operator|++
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mismatched
operator|>
literal|0
condition|)
name|warning
argument_list|(
literal|"One or more sections of the remote executable does not match\n\ the loaded file\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|&&
operator|!
name|matched
condition|)
name|printf_filtered
argument_list|(
literal|"No loaded section named '%s'.\n"
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|LONGEST
name|remote_xfer_partial
parameter_list|(
name|struct
name|target_ops
modifier|*
name|ops
parameter_list|,
name|enum
name|target_object
name|object
parameter_list|,
specifier|const
name|char
modifier|*
name|annex
parameter_list|,
name|void
modifier|*
name|readbuf
parameter_list|,
specifier|const
name|void
modifier|*
name|writebuf
parameter_list|,
name|ULONGEST
name|offset
parameter_list|,
name|LONGEST
name|len
parameter_list|)
block|{
name|struct
name|remote_state
modifier|*
name|rs
init|=
name|get_remote_state
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|buf2
init|=
name|alloca
argument_list|(
name|rs
operator|->
name|remote_packet_size
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p2
init|=
operator|&
name|buf2
index|[
literal|0
index|]
decl_stmt|;
name|char
name|query_type
decl_stmt|;
comment|/* Only handle reads.  */
if|if
condition|(
name|writebuf
operator|!=
name|NULL
operator|||
name|readbuf
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Map pre-existing objects onto letters.  DO NOT do this for new      objects!!!  Instead specify new query packets.  */
switch|switch
condition|(
name|object
condition|)
block|{
case|case
name|TARGET_OBJECT_KOD
case|:
name|query_type
operator|=
literal|'K'
expr_stmt|;
break|break;
case|case
name|TARGET_OBJECT_AVR
case|:
name|query_type
operator|=
literal|'R'
expr_stmt|;
break|break;
case|case
name|TARGET_OBJECT_AUXV
case|:
if|if
condition|(
name|remote_protocol_qPart_auxv
operator|.
name|support
operator|!=
name|PACKET_DISABLE
condition|)
block|{
name|unsigned
name|int
name|total
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|LONGEST
name|n
init|=
name|min
argument_list|(
operator|(
name|rs
operator|->
name|remote_packet_size
operator|-
literal|2
operator|)
operator|/
literal|2
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|snprintf
argument_list|(
name|buf2
argument_list|,
name|rs
operator|->
name|remote_packet_size
argument_list|,
literal|"qPart:auxv:read::%s,%s"
argument_list|,
name|phex_nz
argument_list|(
name|offset
argument_list|,
sizeof|sizeof
name|offset
argument_list|)
argument_list|,
name|phex_nz
argument_list|(
name|n
argument_list|,
sizeof|sizeof
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|putpkt
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
name|total
operator|>
literal|0
condition|?
name|total
else|:
name|i
return|;
name|buf2
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|getpkt
argument_list|(
name|buf2
argument_list|,
name|rs
operator|->
name|remote_packet_size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|packet_ok
argument_list|(
name|buf2
argument_list|,
operator|&
name|remote_protocol_qPart_auxv
argument_list|)
operator|!=
name|PACKET_OK
condition|)
return|return
name|total
operator|>
literal|0
condition|?
name|total
else|:
operator|-
literal|1
return|;
if|if
condition|(
name|buf2
index|[
literal|0
index|]
operator|==
literal|'O'
operator|&&
name|buf2
index|[
literal|1
index|]
operator|==
literal|'K'
operator|&&
name|buf2
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
break|break;
comment|/* Got EOF indicator.  */
comment|/* Got some data.  */
name|i
operator|=
name|hex2bin
argument_list|(
name|buf2
argument_list|,
name|readbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|readbuf
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|readbuf
operator|+
name|i
operator|)
expr_stmt|;
name|offset
operator|+=
name|i
expr_stmt|;
name|len
operator|-=
name|i
expr_stmt|;
name|total
operator|+=
name|i
expr_stmt|;
block|}
block|}
return|return
name|total
return|;
block|}
return|return
operator|-
literal|1
return|;
case|case
name|TARGET_OBJECT_DIRTY
case|:
if|if
condition|(
name|remote_protocol_qPart_dirty
operator|.
name|support
operator|!=
name|PACKET_DISABLE
condition|)
block|{
name|snprintf
argument_list|(
name|buf2
argument_list|,
name|rs
operator|->
name|remote_packet_size
argument_list|,
literal|"qPart:dirty:read::%lx"
argument_list|,
call|(
name|long
call|)
argument_list|(
name|offset
operator|>>
literal|3
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|putpkt
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
name|i
return|;
name|buf2
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|getpkt
argument_list|(
name|buf2
argument_list|,
name|rs
operator|->
name|remote_packet_size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|packet_ok
argument_list|(
name|buf2
argument_list|,
operator|&
name|remote_protocol_qPart_dirty
argument_list|)
operator|!=
name|PACKET_OK
condition|)
return|return
operator|-
literal|1
return|;
name|i
operator|=
name|hex2bin
argument_list|(
name|buf2
argument_list|,
name|readbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
return|return
operator|-
literal|1
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
comment|/* Note: a zero OFFSET and LEN can be used to query the minimum      buffer size.  */
if|if
condition|(
name|offset
operator|==
literal|0
operator|&&
name|len
operator|==
literal|0
condition|)
return|return
operator|(
name|rs
operator|->
name|remote_packet_size
operator|)
return|;
comment|/* Minimum outbuf size is (rs->remote_packet_size) - if bufsiz is      not large enough let the caller.  */
if|if
condition|(
name|len
operator|<
operator|(
name|rs
operator|->
name|remote_packet_size
operator|)
condition|)
return|return
operator|-
literal|1
return|;
name|len
operator|=
name|rs
operator|->
name|remote_packet_size
expr_stmt|;
comment|/* except for querying the minimum buffer size, target must be open */
if|if
condition|(
operator|!
name|remote_desc
condition|)
name|error
argument_list|(
literal|"remote query is only available after target open"
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|annex
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|readbuf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|p2
operator|++
operator|=
literal|'q'
expr_stmt|;
operator|*
name|p2
operator|++
operator|=
name|query_type
expr_stmt|;
comment|/* we used one buffer char for the remote protocol q command and another      for the query type.  As the remote protocol encapsulation uses 4 chars      plus one extra in case we are debugging (remote_debug),      we have PBUFZIZ - 7 left to pack the query string */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|annex
index|[
name|i
index|]
operator|&&
operator|(
name|i
operator|<
operator|(
operator|(
name|rs
operator|->
name|remote_packet_size
operator|)
operator|-
literal|8
operator|)
operator|)
condition|)
block|{
comment|/* Bad caller may have sent forbidden characters.  */
name|gdb_assert
argument_list|(
name|isprint
argument_list|(
name|annex
index|[
name|i
index|]
argument_list|)
operator|&&
name|annex
index|[
name|i
index|]
operator|!=
literal|'$'
operator|&&
name|annex
index|[
name|i
index|]
operator|!=
literal|'#'
argument_list|)
expr_stmt|;
operator|*
name|p2
operator|++
operator|=
name|annex
index|[
name|i
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
operator|*
name|p2
operator|=
literal|'\0'
expr_stmt|;
name|gdb_assert
argument_list|(
name|annex
index|[
name|i
index|]
operator|==
literal|'\0'
argument_list|)
expr_stmt|;
name|i
operator|=
name|putpkt
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
name|i
return|;
name|getpkt
argument_list|(
name|readbuf
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|strlen
argument_list|(
name|readbuf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|remote_rcmd
parameter_list|(
name|char
modifier|*
name|command
parameter_list|,
name|struct
name|ui_file
modifier|*
name|outbuf
parameter_list|)
block|{
name|struct
name|remote_state
modifier|*
name|rs
init|=
name|get_remote_state
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|rs
operator|->
name|remote_packet_size
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
if|if
condition|(
operator|!
name|remote_desc
condition|)
name|error
argument_list|(
literal|"remote rcmd is only available after target open"
argument_list|)
expr_stmt|;
comment|/* Send a NULL command across as an empty command */
if|if
condition|(
name|command
operator|==
name|NULL
condition|)
name|command
operator|=
literal|""
expr_stmt|;
comment|/* The query prefix */
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"qRcmd,"
argument_list|)
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
name|strlen
argument_list|(
name|command
argument_list|)
operator|*
literal|2
operator|+
literal|8
comment|/*misc*/
operator|)
operator|>
operator|(
name|rs
operator|->
name|remote_packet_size
operator|)
condition|)
name|error
argument_list|(
literal|"\"monitor\" command ``%s'' is too long\n"
argument_list|,
name|command
argument_list|)
expr_stmt|;
comment|/* Encode the actual command */
name|bin2hex
argument_list|(
name|command
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|putpkt
argument_list|(
name|buf
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Communication problem with target\n"
argument_list|)
expr_stmt|;
comment|/* get/display the response */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* XXX - see also tracepoint.c:remote_get_noisy_reply() */
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
operator|(
name|rs
operator|->
name|remote_packet_size
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|error
argument_list|(
literal|"Target does not support this command\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'O'
operator|&&
name|buf
index|[
literal|1
index|]
operator|!=
literal|'K'
condition|)
block|{
name|remote_console_output
argument_list|(
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 'O' message from stub */
continue|continue;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"OK"
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|strlen
argument_list|(
name|buf
argument_list|)
operator|==
literal|3
operator|&&
name|buf
index|[
literal|0
index|]
operator|==
literal|'E'
operator|&&
name|isdigit
argument_list|(
name|buf
index|[
literal|1
index|]
argument_list|)
operator|&&
name|isdigit
argument_list|(
name|buf
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Protocol error with Rcmd"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|buf
init|;
name|p
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|p
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|;
name|p
operator|+=
literal|2
control|)
block|{
name|char
name|c
init|=
operator|(
name|fromhex
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
operator|<<
literal|4
operator|)
operator|+
name|fromhex
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|fputc_unfiltered
argument_list|(
name|c
argument_list|,
name|outbuf
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|packet_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|remote_state
modifier|*
name|rs
init|=
name|get_remote_state
argument_list|()
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|rs
operator|->
name|remote_packet_size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|remote_desc
condition|)
name|error
argument_list|(
literal|"command can only be used with remote target"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
name|error
argument_list|(
literal|"remote-packet command requires packet text as argument"
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"sending: "
argument_list|)
expr_stmt|;
name|print_packet
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
operator|(
name|rs
operator|->
name|remote_packet_size
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"received: "
argument_list|)
expr_stmt|;
name|print_packet
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* --------- UNIT_TEST for THREAD oriented PACKETS ------------------------- */
end_comment

begin_define
unit|static void display_thread_info (struct gdb_ext_thread_info *info);  static void threadset_test_cmd (char *cmd, int tty);  static void threadalive_test (char *cmd, int tty);  static void threadlist_test_cmd (char *cmd, int tty);  int get_and_display_threadinfo (threadref * ref);  static void threadinfo_test_cmd (char *cmd, int tty);  static int thread_display_step (threadref * ref, void *context);  static void threadlist_update_test_cmd (char *cmd, int tty);  static void init_remote_threadtests (void);
define|#
directive|define
name|SAMPLE_THREAD
value|0x05060708
end_define

begin_comment
comment|/* Truncated 64 bit threadid */
end_comment

begin_comment
unit|static void threadset_test_cmd (char *cmd, int tty) {   int sample_thread = SAMPLE_THREAD;    printf_filtered ("Remote threadset test\n");   set_thread (sample_thread, 1); }   static void threadalive_test (char *cmd, int tty) {   int sample_thread = SAMPLE_THREAD;    if (remote_thread_alive (pid_to_ptid (sample_thread)))     printf_filtered ("PASS: Thread alive test\n");   else     printf_filtered ("FAIL: Thread alive test\n"); }  void output_threadid (char *title, threadref * ref);  void output_threadid (char *title, threadref *ref) {   char hexid[20];    pack_threadid (&hexid[0], ref);
comment|/* Convert threead id into hex */
end_comment

begin_comment
unit|hexid[16] = 0;   printf_filtered ("%s  %s\n", title, (&hexid[0])); }  static void threadlist_test_cmd (char *cmd, int tty) {   int startflag = 1;   threadref nextthread;   int done, result_count;   threadref threadlist[3];    printf_filtered ("Remote Threadlist test\n");   if (!remote_get_threadlist (startflag,&nextthread, 3,&done,&result_count,&threadlist[0]))     printf_filtered ("FAIL: threadlist test\n");   else     {       threadref *scan = threadlist;       threadref *limit = scan + result_count;        while (scan< limit) 	output_threadid (" thread ", scan++);     } }  void display_thread_info (struct gdb_ext_thread_info *info) {   output_threadid ("Threadid: ",&info->threadid);   printf_filtered ("Name: %s\n ", info->shortname);   printf_filtered ("State: %s\n", info->display);   printf_filtered ("other: %s\n\n", info->more_display); }  int get_and_display_threadinfo (threadref *ref) {   int result;   int set;   struct gdb_ext_thread_info threadinfo;    set = TAG_THREADID | TAG_EXISTS | TAG_THREADNAME     | TAG_MOREDISPLAY | TAG_DISPLAY;   if (0 != (result = remote_get_threadinfo (ref, set,&threadinfo)))     display_thread_info (&threadinfo);   return result; }  static void threadinfo_test_cmd (char *cmd, int tty) {   int athread = SAMPLE_THREAD;   threadref thread;   int set;    int_to_threadref (&thread, athread);   printf_filtered ("Remote Threadinfo test\n");   if (!get_and_display_threadinfo (&thread))     printf_filtered ("FAIL cannot get thread info\n"); }  static int thread_display_step (threadref *ref, void *context) {
comment|/* output_threadid(" threadstep ",ref); */
end_comment

begin_comment
comment|/* simple test */
end_comment

begin_endif
unit|return get_and_display_threadinfo (ref); }  static void threadlist_update_test_cmd (char *cmd, int tty) {   printf_filtered ("Remote Threadlist update test\n");   remote_threadlist_iterator (thread_display_step, 0, CRAZY_MAX_THREADS); }  static void init_remote_threadtests (void) {   add_com ("tlist", class_obscure, threadlist_test_cmd,      "Fetch and print the remote list of thread identifiers, one pkt only");   add_com ("tinfo", class_obscure, threadinfo_test_cmd, 	   "Fetch and display info about one thread");   add_com ("tset", class_obscure, threadset_test_cmd, 	   "Test setting to a different thread");   add_com ("tupd", class_obscure, threadlist_update_test_cmd, 	   "Iterate through updating all remote thread info");   add_com ("talive", class_obscure, threadalive_test, 	   " Remote thread alive test "); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/* Convert a thread ID to a string.  Returns the string in a static    buffer.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|remote_pid_to_str
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Thread %d"
argument_list|,
name|PIDGET
argument_list|(
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_remote_ops
parameter_list|(
name|void
parameter_list|)
block|{
name|remote_ops
operator|.
name|to_shortname
operator|=
literal|"remote"
expr_stmt|;
name|remote_ops
operator|.
name|to_longname
operator|=
literal|"Remote serial target in gdb-specific protocol"
expr_stmt|;
name|remote_ops
operator|.
name|to_doc
operator|=
literal|"Use a remote computer via a serial line, using a gdb-specific protocol.\n\ Specify the serial device it is connected to\n\ (e.g. /dev/ttyS0, /dev/ttya, COM1, etc.)."
expr_stmt|;
name|remote_ops
operator|.
name|to_open
operator|=
name|remote_open
expr_stmt|;
name|remote_ops
operator|.
name|to_close
operator|=
name|remote_close
expr_stmt|;
name|remote_ops
operator|.
name|to_detach
operator|=
name|remote_detach
expr_stmt|;
name|remote_ops
operator|.
name|to_disconnect
operator|=
name|remote_disconnect
expr_stmt|;
name|remote_ops
operator|.
name|to_resume
operator|=
name|remote_resume
expr_stmt|;
name|remote_ops
operator|.
name|to_wait
operator|=
name|remote_wait
expr_stmt|;
name|remote_ops
operator|.
name|to_fetch_registers
operator|=
name|remote_fetch_registers
expr_stmt|;
name|remote_ops
operator|.
name|to_store_registers
operator|=
name|remote_store_registers
expr_stmt|;
name|remote_ops
operator|.
name|to_prepare_to_store
operator|=
name|remote_prepare_to_store
expr_stmt|;
name|remote_ops
operator|.
name|to_xfer_memory
operator|=
name|remote_xfer_memory
expr_stmt|;
name|remote_ops
operator|.
name|to_files_info
operator|=
name|remote_files_info
expr_stmt|;
name|remote_ops
operator|.
name|to_insert_breakpoint
operator|=
name|remote_insert_breakpoint
expr_stmt|;
name|remote_ops
operator|.
name|to_remove_breakpoint
operator|=
name|remote_remove_breakpoint
expr_stmt|;
name|remote_ops
operator|.
name|to_stopped_by_watchpoint
operator|=
name|remote_stopped_by_watchpoint
expr_stmt|;
name|remote_ops
operator|.
name|to_stopped_data_address
operator|=
name|remote_stopped_data_address
expr_stmt|;
name|remote_ops
operator|.
name|to_can_use_hw_breakpoint
operator|=
name|remote_check_watch_resources
expr_stmt|;
name|remote_ops
operator|.
name|to_insert_hw_breakpoint
operator|=
name|remote_insert_hw_breakpoint
expr_stmt|;
name|remote_ops
operator|.
name|to_remove_hw_breakpoint
operator|=
name|remote_remove_hw_breakpoint
expr_stmt|;
name|remote_ops
operator|.
name|to_insert_watchpoint
operator|=
name|remote_insert_watchpoint
expr_stmt|;
name|remote_ops
operator|.
name|to_remove_watchpoint
operator|=
name|remote_remove_watchpoint
expr_stmt|;
name|remote_ops
operator|.
name|to_kill
operator|=
name|remote_kill
expr_stmt|;
name|remote_ops
operator|.
name|to_load
operator|=
name|generic_load
expr_stmt|;
name|remote_ops
operator|.
name|to_mourn_inferior
operator|=
name|remote_mourn
expr_stmt|;
name|remote_ops
operator|.
name|to_thread_alive
operator|=
name|remote_thread_alive
expr_stmt|;
name|remote_ops
operator|.
name|to_find_new_threads
operator|=
name|remote_threads_info
expr_stmt|;
name|remote_ops
operator|.
name|to_pid_to_str
operator|=
name|remote_pid_to_str
expr_stmt|;
name|remote_ops
operator|.
name|to_extra_thread_info
operator|=
name|remote_threads_extra_info
expr_stmt|;
name|remote_ops
operator|.
name|to_stop
operator|=
name|remote_stop
expr_stmt|;
name|remote_ops
operator|.
name|to_xfer_partial
operator|=
name|remote_xfer_partial
expr_stmt|;
name|remote_ops
operator|.
name|to_rcmd
operator|=
name|remote_rcmd
expr_stmt|;
name|remote_ops
operator|.
name|to_stratum
operator|=
name|process_stratum
expr_stmt|;
name|remote_ops
operator|.
name|to_has_all_memory
operator|=
literal|1
expr_stmt|;
name|remote_ops
operator|.
name|to_has_memory
operator|=
literal|1
expr_stmt|;
name|remote_ops
operator|.
name|to_has_stack
operator|=
literal|1
expr_stmt|;
name|remote_ops
operator|.
name|to_has_registers
operator|=
literal|1
expr_stmt|;
name|remote_ops
operator|.
name|to_has_execution
operator|=
literal|1
expr_stmt|;
name|remote_ops
operator|.
name|to_has_thread_control
operator|=
name|tc_schedlock
expr_stmt|;
comment|/* can lock scheduler */
name|remote_ops
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set up the extended remote vector by making a copy of the standard    remote vector and adding to it.  */
end_comment

begin_function
specifier|static
name|void
name|init_extended_remote_ops
parameter_list|(
name|void
parameter_list|)
block|{
name|extended_remote_ops
operator|=
name|remote_ops
expr_stmt|;
name|extended_remote_ops
operator|.
name|to_shortname
operator|=
literal|"extended-remote"
expr_stmt|;
name|extended_remote_ops
operator|.
name|to_longname
operator|=
literal|"Extended remote serial target in gdb-specific protocol"
expr_stmt|;
name|extended_remote_ops
operator|.
name|to_doc
operator|=
literal|"Use a remote computer via a serial line, using a gdb-specific protocol.\n\ Specify the serial device it is connected to (e.g. /dev/ttya)."
operator|,
name|extended_remote_ops
operator|.
name|to_open
operator|=
name|extended_remote_open
expr_stmt|;
name|extended_remote_ops
operator|.
name|to_create_inferior
operator|=
name|extended_remote_create_inferior
expr_stmt|;
name|extended_remote_ops
operator|.
name|to_mourn_inferior
operator|=
name|extended_remote_mourn
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|remote_can_async_p
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* We're async whenever the serial device is. */
return|return
operator|(
name|current_target
operator|.
name|to_async_mask_value
operator|)
operator|&&
name|serial_can_async_p
argument_list|(
name|remote_desc
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|remote_is_async_p
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* We're async whenever the serial device is. */
return|return
operator|(
name|current_target
operator|.
name|to_async_mask_value
operator|)
operator|&&
name|serial_is_async_p
argument_list|(
name|remote_desc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Pass the SERIAL event on and up to the client.  One day this code    will be able to delay notifying the client of an event until the    point where an entire packet has been received. */
end_comment

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|async_client_callback
function_decl|)
parameter_list|(
name|enum
name|inferior_event_type
name|event_type
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
modifier|*
name|async_client_context
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|serial_event_ftype
name|remote_async_serial_handler
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|remote_async_serial_handler
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
comment|/* Don't propogate error information up to the client.  Instead let      the client find out about the error by querying the target.  */
name|async_client_callback
argument_list|(
name|INF_REG_EVENT
argument_list|,
name|async_client_context
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|remote_async
parameter_list|(
name|void
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
name|enum
name|inferior_event_type
name|event_type
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
if|if
condition|(
name|current_target
operator|.
name|to_async_mask_value
operator|==
literal|0
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Calling remote_async when async is masked"
argument_list|)
expr_stmt|;
if|if
condition|(
name|callback
operator|!=
name|NULL
condition|)
block|{
name|serial_async
argument_list|(
name|remote_desc
argument_list|,
name|remote_async_serial_handler
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|async_client_callback
operator|=
name|callback
expr_stmt|;
name|async_client_context
operator|=
name|context
expr_stmt|;
block|}
else|else
name|serial_async
argument_list|(
name|remote_desc
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Target async and target extended-async.     This are temporary targets, until it is all tested.  Eventually    async support will be incorporated int the usual 'remote'    target. */
end_comment

begin_function
specifier|static
name|void
name|init_remote_async_ops
parameter_list|(
name|void
parameter_list|)
block|{
name|remote_async_ops
operator|.
name|to_shortname
operator|=
literal|"async"
expr_stmt|;
name|remote_async_ops
operator|.
name|to_longname
operator|=
literal|"Remote serial target in async version of the gdb-specific protocol"
expr_stmt|;
name|remote_async_ops
operator|.
name|to_doc
operator|=
literal|"Use a remote computer via a serial line, using a gdb-specific protocol.\n\ Specify the serial device it is connected to (e.g. /dev/ttya)."
expr_stmt|;
name|remote_async_ops
operator|.
name|to_open
operator|=
name|remote_async_open
expr_stmt|;
name|remote_async_ops
operator|.
name|to_close
operator|=
name|remote_close
expr_stmt|;
name|remote_async_ops
operator|.
name|to_detach
operator|=
name|remote_detach
expr_stmt|;
name|remote_async_ops
operator|.
name|to_disconnect
operator|=
name|remote_disconnect
expr_stmt|;
name|remote_async_ops
operator|.
name|to_resume
operator|=
name|remote_async_resume
expr_stmt|;
name|remote_async_ops
operator|.
name|to_wait
operator|=
name|remote_async_wait
expr_stmt|;
name|remote_async_ops
operator|.
name|to_fetch_registers
operator|=
name|remote_fetch_registers
expr_stmt|;
name|remote_async_ops
operator|.
name|to_store_registers
operator|=
name|remote_store_registers
expr_stmt|;
name|remote_async_ops
operator|.
name|to_prepare_to_store
operator|=
name|remote_prepare_to_store
expr_stmt|;
name|remote_async_ops
operator|.
name|to_xfer_memory
operator|=
name|remote_xfer_memory
expr_stmt|;
name|remote_async_ops
operator|.
name|to_files_info
operator|=
name|remote_files_info
expr_stmt|;
name|remote_async_ops
operator|.
name|to_insert_breakpoint
operator|=
name|remote_insert_breakpoint
expr_stmt|;
name|remote_async_ops
operator|.
name|to_remove_breakpoint
operator|=
name|remote_remove_breakpoint
expr_stmt|;
name|remote_async_ops
operator|.
name|to_can_use_hw_breakpoint
operator|=
name|remote_check_watch_resources
expr_stmt|;
name|remote_async_ops
operator|.
name|to_insert_hw_breakpoint
operator|=
name|remote_insert_hw_breakpoint
expr_stmt|;
name|remote_async_ops
operator|.
name|to_remove_hw_breakpoint
operator|=
name|remote_remove_hw_breakpoint
expr_stmt|;
name|remote_async_ops
operator|.
name|to_insert_watchpoint
operator|=
name|remote_insert_watchpoint
expr_stmt|;
name|remote_async_ops
operator|.
name|to_remove_watchpoint
operator|=
name|remote_remove_watchpoint
expr_stmt|;
name|remote_async_ops
operator|.
name|to_stopped_by_watchpoint
operator|=
name|remote_stopped_by_watchpoint
expr_stmt|;
name|remote_async_ops
operator|.
name|to_stopped_data_address
operator|=
name|remote_stopped_data_address
expr_stmt|;
name|remote_async_ops
operator|.
name|to_terminal_inferior
operator|=
name|remote_async_terminal_inferior
expr_stmt|;
name|remote_async_ops
operator|.
name|to_terminal_ours
operator|=
name|remote_async_terminal_ours
expr_stmt|;
name|remote_async_ops
operator|.
name|to_kill
operator|=
name|remote_async_kill
expr_stmt|;
name|remote_async_ops
operator|.
name|to_load
operator|=
name|generic_load
expr_stmt|;
name|remote_async_ops
operator|.
name|to_mourn_inferior
operator|=
name|remote_async_mourn
expr_stmt|;
name|remote_async_ops
operator|.
name|to_thread_alive
operator|=
name|remote_thread_alive
expr_stmt|;
name|remote_async_ops
operator|.
name|to_find_new_threads
operator|=
name|remote_threads_info
expr_stmt|;
name|remote_async_ops
operator|.
name|to_pid_to_str
operator|=
name|remote_pid_to_str
expr_stmt|;
name|remote_async_ops
operator|.
name|to_extra_thread_info
operator|=
name|remote_threads_extra_info
expr_stmt|;
name|remote_async_ops
operator|.
name|to_stop
operator|=
name|remote_stop
expr_stmt|;
name|remote_async_ops
operator|.
name|to_xfer_partial
operator|=
name|remote_xfer_partial
expr_stmt|;
name|remote_async_ops
operator|.
name|to_rcmd
operator|=
name|remote_rcmd
expr_stmt|;
name|remote_async_ops
operator|.
name|to_stratum
operator|=
name|process_stratum
expr_stmt|;
name|remote_async_ops
operator|.
name|to_has_all_memory
operator|=
literal|1
expr_stmt|;
name|remote_async_ops
operator|.
name|to_has_memory
operator|=
literal|1
expr_stmt|;
name|remote_async_ops
operator|.
name|to_has_stack
operator|=
literal|1
expr_stmt|;
name|remote_async_ops
operator|.
name|to_has_registers
operator|=
literal|1
expr_stmt|;
name|remote_async_ops
operator|.
name|to_has_execution
operator|=
literal|1
expr_stmt|;
name|remote_async_ops
operator|.
name|to_has_thread_control
operator|=
name|tc_schedlock
expr_stmt|;
comment|/* can lock scheduler */
name|remote_async_ops
operator|.
name|to_can_async_p
operator|=
name|remote_can_async_p
expr_stmt|;
name|remote_async_ops
operator|.
name|to_is_async_p
operator|=
name|remote_is_async_p
expr_stmt|;
name|remote_async_ops
operator|.
name|to_async
operator|=
name|remote_async
expr_stmt|;
name|remote_async_ops
operator|.
name|to_async_mask_value
operator|=
literal|1
expr_stmt|;
name|remote_async_ops
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set up the async extended remote vector by making a copy of the standard    remote vector and adding to it.  */
end_comment

begin_function
specifier|static
name|void
name|init_extended_async_remote_ops
parameter_list|(
name|void
parameter_list|)
block|{
name|extended_async_remote_ops
operator|=
name|remote_async_ops
expr_stmt|;
name|extended_async_remote_ops
operator|.
name|to_shortname
operator|=
literal|"extended-async"
expr_stmt|;
name|extended_async_remote_ops
operator|.
name|to_longname
operator|=
literal|"Extended remote serial target in async gdb-specific protocol"
expr_stmt|;
name|extended_async_remote_ops
operator|.
name|to_doc
operator|=
literal|"Use a remote computer via a serial line, using an async gdb-specific protocol.\n\ Specify the serial device it is connected to (e.g. /dev/ttya)."
operator|,
name|extended_async_remote_ops
operator|.
name|to_open
operator|=
name|extended_remote_async_open
expr_stmt|;
name|extended_async_remote_ops
operator|.
name|to_create_inferior
operator|=
name|extended_remote_async_create_inferior
expr_stmt|;
name|extended_async_remote_ops
operator|.
name|to_mourn_inferior
operator|=
name|extended_remote_mourn
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_remote_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|show_remote_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
comment|/* FIXME: cagney/2002-06-15: This function should iterate over      remote_show_cmdlist for a list of sub commands to show.  */
name|show_remote_protocol_Z_packet_cmd
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|show_remote_protocol_e_packet_cmd
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|show_remote_protocol_E_packet_cmd
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|show_remote_protocol_P_packet_cmd
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|show_remote_protocol_qSymbol_packet_cmd
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|show_remote_protocol_vcont_packet_cmd
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|show_remote_protocol_binary_download_cmd
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|show_remote_protocol_qPart_auxv_packet_cmd
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|show_remote_protocol_qPart_dirty_packet_cmd
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|build_remote_gdbarch_data
parameter_list|(
name|void
parameter_list|)
block|{
name|remote_address_size
operator|=
name|TARGET_ADDR_BIT
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Saved pointer to previous owner of the new_objfile event. */
end_comment

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|remote_new_objfile_chain
function_decl|)
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Function to be called whenever a new objfile (shlib) is detected. */
end_comment

begin_function
specifier|static
name|void
name|remote_new_objfile
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
if|if
condition|(
name|remote_desc
operator|!=
literal|0
condition|)
comment|/* Have a remote connection */
block|{
name|remote_check_symbols
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
comment|/* Call predecessor on chain, if any. */
if|if
condition|(
name|remote_new_objfile_chain
operator|!=
literal|0
operator|&&
name|remote_desc
operator|==
literal|0
condition|)
name|remote_new_objfile_chain
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_remote
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|struct
name|cmd_list_element
modifier|*
name|remote_set_cmdlist
decl_stmt|;
specifier|static
name|struct
name|cmd_list_element
modifier|*
name|remote_show_cmdlist
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|tmpcmd
decl_stmt|;
comment|/* architecture specific data */
name|remote_gdbarch_data_handle
operator|=
name|register_gdbarch_data
argument_list|(
name|init_remote_state
argument_list|)
expr_stmt|;
comment|/* Old tacky stuff.  NOTE: This comes after the remote protocol so      that the remote protocol has been initialized.  */
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|remote_address_size
argument_list|)
expr_stmt|;
name|deprecated_register_gdbarch_swap
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|build_remote_gdbarch_data
argument_list|)
expr_stmt|;
name|init_remote_ops
argument_list|()
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|remote_ops
argument_list|)
expr_stmt|;
name|init_extended_remote_ops
argument_list|()
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|extended_remote_ops
argument_list|)
expr_stmt|;
name|init_remote_async_ops
argument_list|()
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|remote_async_ops
argument_list|)
expr_stmt|;
name|init_extended_async_remote_ops
argument_list|()
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|extended_async_remote_ops
argument_list|)
expr_stmt|;
comment|/* Hook into new objfile notification.  */
name|remote_new_objfile_chain
operator|=
name|target_new_objfile_hook
expr_stmt|;
name|target_new_objfile_hook
operator|=
name|remote_new_objfile
expr_stmt|;
if|#
directive|if
literal|0
block|init_remote_threadtests ();
endif|#
directive|endif
comment|/* set/show remote ... */
name|add_prefix_cmd
argument_list|(
literal|"remote"
argument_list|,
name|class_maintenance
argument_list|,
name|set_remote_cmd
argument_list|,
literal|"\ Remote protocol specific variables\n\ Configure various remote-protocol specific variables such as\n\ the packets being used"
argument_list|,
operator|&
name|remote_set_cmdlist
argument_list|,
literal|"set remote "
argument_list|,
literal|0
comment|/*allow-unknown*/
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"remote"
argument_list|,
name|class_maintenance
argument_list|,
name|show_remote_cmd
argument_list|,
literal|"\ Remote protocol specific variables\n\ Configure various remote-protocol specific variables such as\n\ the packets being used"
argument_list|,
operator|&
name|remote_show_cmdlist
argument_list|,
literal|"show remote "
argument_list|,
literal|0
comment|/*allow-unknown*/
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"compare-sections"
argument_list|,
name|class_obscure
argument_list|,
name|compare_sections_command
argument_list|,
literal|"Compare section data on target to the exec file.\n\ Argument is a single section name (default: all loaded sections)."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"packet"
argument_list|,
name|class_maintenance
argument_list|,
name|packet_command
argument_list|,
literal|"Send an arbitrary packet to a remote target.\n\    maintenance packet TEXT\n\ If GDB is talking to an inferior via the GDB serial protocol, then\n\ this command sends the string TEXT to the inferior, and displays the\n\ response packet.  GDB supplies the initial `$' character, and the\n\ terminating `#' character and checksum."
argument_list|,
operator|&
name|maintenancelist
argument_list|)
expr_stmt|;
name|add_setshow_boolean_cmd
argument_list|(
literal|"remotebreak"
argument_list|,
name|no_class
argument_list|,
operator|&
name|remote_break
argument_list|,
literal|"Set whether to send break if interrupted.\n"
argument_list|,
literal|"Show whether to send break if interrupted.\n"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|setlist
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
comment|/* Install commands for configuring memory read/write packets. */
name|add_cmd
argument_list|(
literal|"remotewritesize"
argument_list|,
name|no_class
argument_list|,
name|set_memory_write_packet_size
argument_list|,
literal|"Set the maximum number of bytes per memory write packet (deprecated).\n"
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"remotewritesize"
argument_list|,
name|no_class
argument_list|,
name|show_memory_write_packet_size
argument_list|,
literal|"Show the maximum number of bytes per memory write packet (deprecated).\n"
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"memory-write-packet-size"
argument_list|,
name|no_class
argument_list|,
name|set_memory_write_packet_size
argument_list|,
literal|"Set the maximum number of bytes per memory-write packet.\n"
literal|"Specify the number of bytes in a packet or 0 (zero) for the\n"
literal|"default packet size.  The actual limit is further reduced\n"
literal|"dependent on the target.  Specify ``fixed'' to disable the\n"
literal|"further restriction and ``limit'' to enable that restriction\n"
argument_list|,
operator|&
name|remote_set_cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"memory-read-packet-size"
argument_list|,
name|no_class
argument_list|,
name|set_memory_read_packet_size
argument_list|,
literal|"Set the maximum number of bytes per memory-read packet.\n"
literal|"Specify the number of bytes in a packet or 0 (zero) for the\n"
literal|"default packet size.  The actual limit is further reduced\n"
literal|"dependent on the target.  Specify ``fixed'' to disable the\n"
literal|"further restriction and ``limit'' to enable that restriction\n"
argument_list|,
operator|&
name|remote_set_cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"memory-write-packet-size"
argument_list|,
name|no_class
argument_list|,
name|show_memory_write_packet_size
argument_list|,
literal|"Show the maximum number of bytes per memory-write packet.\n"
argument_list|,
operator|&
name|remote_show_cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"memory-read-packet-size"
argument_list|,
name|no_class
argument_list|,
name|show_memory_read_packet_size
argument_list|,
literal|"Show the maximum number of bytes per memory-read packet.\n"
argument_list|,
operator|&
name|remote_show_cmdlist
argument_list|)
expr_stmt|;
name|add_setshow_cmd
argument_list|(
literal|"hardware-watchpoint-limit"
argument_list|,
name|no_class
argument_list|,
name|var_zinteger
argument_list|,
operator|&
name|remote_hw_watchpoint_limit
argument_list|,
literal|"\ Set the maximum number of target hardware watchpoints.\n\ Specify a negative limit for unlimited."
argument_list|,
literal|"\ Show the maximum number of target hardware watchpoints.\n"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|remote_set_cmdlist
argument_list|,
operator|&
name|remote_show_cmdlist
argument_list|)
expr_stmt|;
name|add_setshow_cmd
argument_list|(
literal|"hardware-breakpoint-limit"
argument_list|,
name|no_class
argument_list|,
name|var_zinteger
argument_list|,
operator|&
name|remote_hw_breakpoint_limit
argument_list|,
literal|"\ Set the maximum number of target hardware breakpoints.\n\ Specify a negative limit for unlimited."
argument_list|,
literal|"\ Show the maximum number of target hardware breakpoints.\n"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|remote_set_cmdlist
argument_list|,
operator|&
name|remote_show_cmdlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"remoteaddresssize"
argument_list|,
name|class_obscure
argument_list|,
name|var_integer
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|remote_address_size
argument_list|,
literal|"Set the maximum size of the address (in bits) \ in a memory packet.\n"
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_packet_config_cmd
argument_list|(
operator|&
name|remote_protocol_binary_download
argument_list|,
literal|"X"
argument_list|,
literal|"binary-download"
argument_list|,
name|set_remote_protocol_binary_download_cmd
argument_list|,
name|show_remote_protocol_binary_download_cmd
argument_list|,
operator|&
name|remote_set_cmdlist
argument_list|,
operator|&
name|remote_show_cmdlist
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXXX - should ``set remotebinarydownload'' be retained for      compatibility. */
block|add_show_from_set     (add_set_cmd ("remotebinarydownload", no_class, 		  var_boolean, (char *)&remote_binary_download, 		  "Set binary downloads.\n",&setlist),&showlist);
endif|#
directive|endif
name|add_packet_config_cmd
argument_list|(
operator|&
name|remote_protocol_vcont
argument_list|,
literal|"vCont"
argument_list|,
literal|"verbose-resume"
argument_list|,
name|set_remote_protocol_vcont_packet_cmd
argument_list|,
name|show_remote_protocol_vcont_packet_cmd
argument_list|,
operator|&
name|remote_set_cmdlist
argument_list|,
operator|&
name|remote_show_cmdlist
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_packet_config_cmd
argument_list|(
operator|&
name|remote_protocol_qSymbol
argument_list|,
literal|"qSymbol"
argument_list|,
literal|"symbol-lookup"
argument_list|,
name|set_remote_protocol_qSymbol_packet_cmd
argument_list|,
name|show_remote_protocol_qSymbol_packet_cmd
argument_list|,
operator|&
name|remote_set_cmdlist
argument_list|,
operator|&
name|remote_show_cmdlist
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_packet_config_cmd
argument_list|(
operator|&
name|remote_protocol_e
argument_list|,
literal|"e"
argument_list|,
literal|"step-over-range"
argument_list|,
name|set_remote_protocol_e_packet_cmd
argument_list|,
name|show_remote_protocol_e_packet_cmd
argument_list|,
operator|&
name|remote_set_cmdlist
argument_list|,
operator|&
name|remote_show_cmdlist
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable by default.  The ``e'' packet has nasty interactions with      the threading code - it relies on global state.  */
name|remote_protocol_e
operator|.
name|detect
operator|=
name|AUTO_BOOLEAN_FALSE
expr_stmt|;
name|update_packet_config
argument_list|(
operator|&
name|remote_protocol_e
argument_list|)
expr_stmt|;
name|add_packet_config_cmd
argument_list|(
operator|&
name|remote_protocol_E
argument_list|,
literal|"E"
argument_list|,
literal|"step-over-range-w-signal"
argument_list|,
name|set_remote_protocol_E_packet_cmd
argument_list|,
name|show_remote_protocol_E_packet_cmd
argument_list|,
operator|&
name|remote_set_cmdlist
argument_list|,
operator|&
name|remote_show_cmdlist
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable by default.  The ``e'' packet has nasty interactions with      the threading code - it relies on global state.  */
name|remote_protocol_E
operator|.
name|detect
operator|=
name|AUTO_BOOLEAN_FALSE
expr_stmt|;
name|update_packet_config
argument_list|(
operator|&
name|remote_protocol_E
argument_list|)
expr_stmt|;
name|add_packet_config_cmd
argument_list|(
operator|&
name|remote_protocol_P
argument_list|,
literal|"P"
argument_list|,
literal|"set-register"
argument_list|,
name|set_remote_protocol_P_packet_cmd
argument_list|,
name|show_remote_protocol_P_packet_cmd
argument_list|,
operator|&
name|remote_set_cmdlist
argument_list|,
operator|&
name|remote_show_cmdlist
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_packet_config_cmd
argument_list|(
operator|&
name|remote_protocol_Z
index|[
name|Z_PACKET_SOFTWARE_BP
index|]
argument_list|,
literal|"Z0"
argument_list|,
literal|"software-breakpoint"
argument_list|,
name|set_remote_protocol_Z_software_bp_packet_cmd
argument_list|,
name|show_remote_protocol_Z_software_bp_packet_cmd
argument_list|,
operator|&
name|remote_set_cmdlist
argument_list|,
operator|&
name|remote_show_cmdlist
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_packet_config_cmd
argument_list|(
operator|&
name|remote_protocol_Z
index|[
name|Z_PACKET_HARDWARE_BP
index|]
argument_list|,
literal|"Z1"
argument_list|,
literal|"hardware-breakpoint"
argument_list|,
name|set_remote_protocol_Z_hardware_bp_packet_cmd
argument_list|,
name|show_remote_protocol_Z_hardware_bp_packet_cmd
argument_list|,
operator|&
name|remote_set_cmdlist
argument_list|,
operator|&
name|remote_show_cmdlist
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_packet_config_cmd
argument_list|(
operator|&
name|remote_protocol_Z
index|[
name|Z_PACKET_WRITE_WP
index|]
argument_list|,
literal|"Z2"
argument_list|,
literal|"write-watchpoint"
argument_list|,
name|set_remote_protocol_Z_write_wp_packet_cmd
argument_list|,
name|show_remote_protocol_Z_write_wp_packet_cmd
argument_list|,
operator|&
name|remote_set_cmdlist
argument_list|,
operator|&
name|remote_show_cmdlist
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_packet_config_cmd
argument_list|(
operator|&
name|remote_protocol_Z
index|[
name|Z_PACKET_READ_WP
index|]
argument_list|,
literal|"Z3"
argument_list|,
literal|"read-watchpoint"
argument_list|,
name|set_remote_protocol_Z_read_wp_packet_cmd
argument_list|,
name|show_remote_protocol_Z_read_wp_packet_cmd
argument_list|,
operator|&
name|remote_set_cmdlist
argument_list|,
operator|&
name|remote_show_cmdlist
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_packet_config_cmd
argument_list|(
operator|&
name|remote_protocol_Z
index|[
name|Z_PACKET_ACCESS_WP
index|]
argument_list|,
literal|"Z4"
argument_list|,
literal|"access-watchpoint"
argument_list|,
name|set_remote_protocol_Z_access_wp_packet_cmd
argument_list|,
name|show_remote_protocol_Z_access_wp_packet_cmd
argument_list|,
operator|&
name|remote_set_cmdlist
argument_list|,
operator|&
name|remote_show_cmdlist
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_packet_config_cmd
argument_list|(
operator|&
name|remote_protocol_qPart_auxv
argument_list|,
literal|"qPart_auxv"
argument_list|,
literal|"read-aux-vector"
argument_list|,
name|set_remote_protocol_qPart_auxv_packet_cmd
argument_list|,
name|show_remote_protocol_qPart_auxv_packet_cmd
argument_list|,
operator|&
name|remote_set_cmdlist
argument_list|,
operator|&
name|remote_show_cmdlist
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_packet_config_cmd
argument_list|(
operator|&
name|remote_protocol_qPart_dirty
argument_list|,
literal|"qPart_dirty"
argument_list|,
literal|"read-dirty-registers"
argument_list|,
name|set_remote_protocol_qPart_dirty_packet_cmd
argument_list|,
name|show_remote_protocol_qPart_dirty_packet_cmd
argument_list|,
operator|&
name|remote_set_cmdlist
argument_list|,
operator|&
name|remote_show_cmdlist
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Keep the old ``set remote Z-packet ...'' working. */
name|add_setshow_auto_boolean_cmd
argument_list|(
literal|"Z-packet"
argument_list|,
name|class_obscure
argument_list|,
operator|&
name|remote_Z_packet_detect
argument_list|,
literal|"\ Set use of remote protocol `Z' packets"
argument_list|,
literal|"Show use of remote protocol `Z' packets "
argument_list|,
name|set_remote_protocol_Z_packet_cmd
argument_list|,
name|show_remote_protocol_Z_packet_cmd
argument_list|,
operator|&
name|remote_set_cmdlist
argument_list|,
operator|&
name|remote_show_cmdlist
argument_list|)
expr_stmt|;
comment|/* Eventually initialize fileio.  See fileio.c */
name|initialize_remote_fileio
argument_list|(
name|remote_set_cmdlist
argument_list|,
name|remote_show_cmdlist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

