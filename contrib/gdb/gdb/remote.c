begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Remote target communications for serial-line targets in custom GDB protocol    Copyright 1988, 1991, 1992, 1993, 1994, 1995, 1996 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Remote communication protocol.     A debug packet whose contents are<data>    is encapsulated for transmission in the form:  	$<data> # CSUM1 CSUM2<data> must be ASCII alphanumeric and cannot include characters 	'$' or '#'.  If<data> starts with two characters followed by 	':', then the existing stubs interpret this as a sequence number.  	CSUM1 and CSUM2 are ascii hex representation of an 8-bit  	checksum of<data>, the most significant nibble is sent first. 	the hex digits 0-9,a-f are used.     Receiver responds with:  	+	- if CSUM is correct and ready for next packet 	-	- if CSUM is incorrect<data> is as follows:    Most values are encoded in ascii hex digits.  Signal numbers are according    to the numbering in target.h.  	Request		Packet  	set thread	Hct...		Set thread for subsequent operations. 					c = 'c' for thread used in step and  					continue; t... can be -1 for all 					threads. 					c = 'g' for thread used in other 					operations.  If zero, pick a thread, 					any thread. 	reply		OK		for success 			ENN		for an error.  	read registers  g 	reply		XX....X		Each byte of register data 					is described by two hex digits. 					Registers are in the internal order 					for GDB, and the bytes in a register 					are in the same order the machine uses. 			or ENN		for an error.  	write regs	GXX..XX		Each byte of register data 					is described by two hex digits. 	reply		OK		for success 			ENN		for an error          write reg	Pn...=r...	Write register n... with value r..., 					which contains two hex digits for each 					byte in the register (target byte 					order). 	reply		OK		for success 			ENN		for an error 	(not supported by all stubs).  	read mem	mAA..AA,LLLL	AA..AA is address, LLLL is length. 	reply		XX..XX		XX..XX is mem contents 					Can be fewer bytes than requested 					if able to read only part of the data. 			or ENN		NN is errno  	write mem	MAA..AA,LLLL:XX..XX 					AA..AA is address, 					LLLL is number of bytes, 					XX..XX is data 	reply		OK		for success 			ENN		for an error (this includes the case 					where only part of the data was 					written).  	continue	cAA..AA		AA..AA is address to resume 					If AA..AA is omitted, 					resume at same address.  	step		sAA..AA		AA..AA is address to resume 					If AA..AA is omitted, 					resume at same address.  	continue with	Csig;AA		Continue with signal sig (hex signal 	signal				number).  	step with	Ssig;AA		Like 'C' but step not continue. 	signal  	last signal     ?               Reply the current reason for stopping.                                         This is the same reply as is generated 					for step or cont : SAA where AA is the 					signal number.  	detach          D               Reply OK.  	There is no immediate reply to step or cont. 	The reply comes when the machine stops. 	It is		SAA		AA is the signal number.  	or...		TAAn...:r...;n...:r...;n...:r...; 					AA = signal number 					n... = register number (hex) 					  r... = register contents 					n... = `thread' 					  r... = thread process ID.  This is 						 a hex integer. 					n... = other string not starting  					    with valid hex digit. 					  gdb should ignore this n,r pair 					  and go on to the next.  This way 					  we can extend the protocol. 	or...		WAA		The process exited, and AA is 					the exit status.  This is only 					applicable for certains sorts of 					targets. 	or...		XAA		The process terminated with signal 					AA.         or...           OXX..XX	XX..XX  is hex encoding of ASCII data. This 					can happen at any time while the program is 					running and the debugger should 					continue to wait for 'W', 'T', etc.  	thread alive	TXX		Find out if the thread XX is alive. 	reply		OK		thread is still alive 			ENN		thread is dead 	 	remote restart	RXX		Restart the remote server  	extended ops 	!		Use the extended remote protocol. 					Sticky -- only needs to be set once.  	kill request	k  	toggle debug	d		toggle debug flag (see 386& 68k stubs) 	reset		r		reset -- see sparc stub. 	reserved<other>		On other requests, the stub should 					ignore the request and send an empty 					response ($#<checksum>).  This way 					we can extend the protocol and GDB 					can tell whether the stub it is 					talking to uses the old or the new. 	search		tAA:PP,MM	Search backwards starting at address 					AA for a match with pattern PP and 					mask MM.  PP and MM are 4 bytes. 					Not supported by all stubs.  	general query	qXXXX		Request info about XXXX. 	general set	QXXXX=yyyy	Set value of XXXX to yyyy. 	query sect offs	qOffsets	Get section offsets.  Reply is 					Text=xxx;Data=yyy;Bss=zzz  	Responses can be run-length encoded to save space.  A '*' means that 	the next character is an ASCII encoding giving a repeat count which 	stands for that many repititions of the character preceding the '*'. 	The encoding is n+29, yielding a printable character where n>=3  	(which is where rle starts to win).  Don't use an n> 126.  	So  	"0* " means the same as "0000".  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_comment
comment|/*#include "terminal.h"*/
end_comment

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdb-stabs.h"
end_include

begin_include
include|#
directive|include
file|"thread.h"
end_include

begin_include
include|#
directive|include
file|"dcache.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_decl_stmt
specifier|static
name|int
name|remote_write_bytes
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
name|memaddr
operator|,
name|char
operator|*
name|myaddr
operator|,
name|int
name|len
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remote_read_bytes
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
name|memaddr
operator|,
name|char
operator|*
name|myaddr
operator|,
name|int
name|len
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_files_info
name|PARAMS
argument_list|(
operator|(
expr|struct
name|target_ops
operator|*
name|ignore
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remote_xfer_memory
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
name|memaddr
operator|,
name|char
operator|*
name|myaddr
operator|,
name|int
name|len
operator|,
name|int
name|should_write
operator|,
expr|struct
name|target_ops
operator|*
name|target
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_prepare_to_store
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_fetch_registers
name|PARAMS
argument_list|(
operator|(
name|int
name|regno
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_resume
name|PARAMS
argument_list|(
operator|(
name|int
name|pid
operator|,
name|int
name|step
operator|,
expr|enum
name|target_signal
name|siggnal
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remote_start_remote
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|dummy
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_open
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|name
operator|,
name|int
name|from_tty
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|extended_remote_open
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|name
operator|,
name|int
name|from_tty
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_open_1
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|target_ops
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_close
name|PARAMS
argument_list|(
operator|(
name|int
name|quitting
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_store_registers
name|PARAMS
argument_list|(
operator|(
name|int
name|regno
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_mourn
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|extended_remote_restart
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|extended_remote_mourn
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|extended_remote_create_inferior
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_mourn_1
name|PARAMS
argument_list|(
operator|(
expr|struct
name|target_ops
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|getpkt
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|buf
operator|,
name|int
name|forever
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|putpkt
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|buf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_send
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|buf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|readchar
name|PARAMS
argument_list|(
operator|(
name|int
name|timeout
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remote_wait
name|PARAMS
argument_list|(
operator|(
name|int
name|pid
operator|,
expr|struct
name|target_waitstatus
operator|*
name|status
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_kill
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tohex
name|PARAMS
argument_list|(
operator|(
name|int
name|nib
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fromhex
name|PARAMS
argument_list|(
operator|(
name|int
name|a
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_detach
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|args
operator|,
name|int
name|from_tty
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_interrupt
name|PARAMS
argument_list|(
operator|(
name|int
name|signo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_interrupt_twice
name|PARAMS
argument_list|(
operator|(
name|int
name|signo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|interrupt_query
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|remote_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward decl */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|extended_remote_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward decl */
end_comment

begin_comment
comment|/* This was 5 seconds, which is a long time to sit and wait.    Unless this is going though some terminal server or multiplexer or    other form of hairy serial connection, I would think 2 seconds would    be plenty.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|remote_timeout
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This variable chooses whether to send a ^C or a break when the user    requests program interruption.  Although ^C is usually what remote    systems expect, and that is the default here, sometimes a break is    preferable instead.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|remote_break
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Descriptor for I/O to remote machine.  Initialize it to NULL so that    remote_open knows that we don't have a file open when the program    starts.  */
end_comment

begin_decl_stmt
name|serial_t
name|remote_desc
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Having this larger than 400 causes us to be incompatible with m68k-stub.c    and i386-stub.c.  Normally, no one would notice because it only matters    for writing large chunks of memory (e.g. in downloads).  Also, this needs    to be more than 400 if required to hold the registers (see below, where    we round it up based on REGISTER_BYTES).  */
end_comment

begin_define
define|#
directive|define
name|PBUFSIZ
value|400
end_define

begin_comment
comment|/* Maximum number of bytes to read/write at once.  The value here    is chosen to fill up a packet (the headers account for the 32).  */
end_comment

begin_define
define|#
directive|define
name|MAXBUFBYTES
value|((PBUFSIZ-32)/2)
end_define

begin_comment
comment|/* Round up PBUFSIZ to hold all the registers, at least.  */
end_comment

begin_comment
comment|/* The blank line after the #if seems to be required to work around a    bug in HP's PA compiler.  */
end_comment

begin_if
if|#
directive|if
name|REGISTER_BYTES
operator|>
name|MAXBUFBYTES
end_if

begin_undef
undef|#
directive|undef
name|PBUFSIZ
end_undef

begin_define
define|#
directive|define
name|PBUFSIZ
value|(REGISTER_BYTES * 2 + 32)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Should we try the 'P' request?  If this is set to one when the stub    doesn't support 'P', the only consequence is some unnecessary traffic.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stub_supports_P
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  * Support for quasi-interactive control of device through GDB port.  * While we're waiting for an event to occur, chat with the running device.  */
end_comment

begin_define
define|#
directive|define
name|REMOTE_CHAT
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|REMOTE_CHAT
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|quit_flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|tty_input
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|escape_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|echo_check
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remote_chat
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|read_stat
block|{
name|READ_MORE
block|,
name|FATAL_ERROR
block|,
name|ENTER_DEBUG
block|}
enum|;
end_enum

begin_function
specifier|static
name|enum
name|read_stat
name|readtarget
parameter_list|()
block|{
name|int
name|j
decl_stmt|;
name|int
name|data
decl_stmt|;
comment|/* Loop until the socket doesn't have any more data */
while|while
condition|(
operator|(
name|data
operator|=
name|readchar
argument_list|(
literal|0
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
comment|/* Check for the escape sequence */
if|if
condition|(
name|data
operator|==
literal|'|'
condition|)
block|{
comment|/* If this is the fourth escape, get out */
if|if
condition|(
operator|++
name|escape_count
operator|==
literal|4
condition|)
return|return
operator|(
name|ENTER_DEBUG
operator|)
return|;
continue|continue;
comment|/* Not the fourth, continue */
block|}
else|else
block|{
comment|/* 	     * Not an escape any more, Ensure any pending ones are flushed 	     */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|escape_count
condition|;
name|j
operator|++
control|)
name|putchar
argument_list|(
literal|'|'
argument_list|)
expr_stmt|;
name|escape_count
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|==
literal|'\r'
condition|)
comment|/* If this is a return character */
continue|continue;
comment|/* just supress it */
if|if
condition|(
name|echo_check
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* If we are checking for an echo */
comment|/* If this might be an echo */
if|if
condition|(
name|tty_input
index|[
name|echo_check
index|]
operator|==
name|data
condition|)
block|{
name|echo_check
operator|++
expr_stmt|;
comment|/* Note one more character match */
continue|continue;
comment|/* Go and loop */
block|}
else|else
block|{
if|if
condition|(
operator|(
name|data
operator|==
literal|'\n'
operator|)
operator|&&
operator|(
name|tty_input
index|[
name|echo_check
index|]
operator|==
literal|'\r'
operator|)
condition|)
block|{
comment|/* If this is the end of the line */
name|echo_check
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* No more echo supression */
continue|continue;
comment|/* Go and loop */
block|}
comment|/* Not an echo, print out the data */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|echo_check
condition|;
name|j
operator|++
control|)
name|putchar
argument_list|(
name|tty_input
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|echo_check
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* No more echo checking */
block|}
block|}
name|putchar
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|/* Output the character */
block|}
return|return
operator|(
name|READ_MORE
operator|)
return|;
comment|/* Indicate to read some more */
block|}
end_function

begin_function
specifier|static
name|enum
name|read_stat
name|readtty
parameter_list|()
block|{
name|enum
name|read_stat
name|status
decl_stmt|;
name|int
name|tty_bc
decl_stmt|;
comment|/* First, read a buffer full from the terminal */
if|if
condition|(
operator|(
name|tty_bc
operator|=
name|read
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|tty_input
argument_list|,
sizeof|sizeof
argument_list|(
name|tty_input
argument_list|)
operator|-
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror_with_name
argument_list|(
literal|"readtty: read failed"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FATAL_ERROR
operator|)
return|;
block|}
comment|/* Turn trailing newlines into returns */
if|if
condition|(
name|tty_input
index|[
name|tty_bc
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|tty_input
index|[
name|tty_bc
operator|-
literal|1
index|]
operator|=
literal|'\r'
expr_stmt|;
if|if
condition|(
operator|(
name|tty_input
index|[
literal|0
index|]
operator|==
literal|'~'
operator|)
operator|&&
operator|(
name|tty_bc
operator|==
literal|3
operator|)
condition|)
switch|switch
condition|(
name|tty_input
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'b'
case|:
comment|/* ~b\n = send break& gdb */
name|SERIAL_SEND_BREAK
argument_list|(
name|remote_desc
argument_list|)
expr_stmt|;
comment|/* fall through */
case|case
literal|'c'
case|:
comment|/* ~c\n = return to gdb */
return|return
operator|(
name|ENTER_DEBUG
operator|)
return|;
block|}
comment|/* Make this a zero terminated string and write it out */
name|tty_input
index|[
name|tty_bc
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|SERIAL_WRITE
argument_list|(
name|remote_desc
argument_list|,
name|tty_input
argument_list|,
name|tty_bc
argument_list|)
condition|)
block|{
name|perror_with_name
argument_list|(
literal|"readtty: write failed"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FATAL_ERROR
operator|)
return|;
block|}
return|return
operator|(
name|READ_MORE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|remote_talk
parameter_list|()
block|{
name|fd_set
name|input
decl_stmt|;
name|int
name|tablesize
decl_stmt|;
name|enum
name|read_stat
name|status
decl_stmt|;
name|int
name|panic_flag
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|escape_count
operator|=
literal|0
expr_stmt|;
name|echo_check
operator|=
operator|-
literal|1
expr_stmt|;
name|tablesize
operator|=
name|getdtablesize
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 	 * Check for anything from our socket - doesn't block. Note that this 	 * must be done *before* the select as there may be buffered I/O 	 * waiting to be processed. 	 */
if|if
condition|(
operator|(
name|status
operator|=
name|readtarget
argument_list|()
operator|)
operator|!=
name|READ_MORE
condition|)
return|return
operator|(
name|status
operator|)
return|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* Flush output before blocking */
comment|/* Now block on more socket input or TTY input */
name|FD_ZERO
argument_list|(
operator|&
name|input
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|input
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|remote_desc
operator|->
name|fd
argument_list|,
operator|&
name|input
argument_list|)
expr_stmt|;
name|status
operator|=
name|select
argument_list|(
name|tablesize
argument_list|,
operator|&
name|input
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|<
literal|0
operator|)
operator|&&
operator|(
name|errno
operator|!=
name|EINTR
operator|)
condition|)
block|{
name|perror_with_name
argument_list|(
literal|"remote_talk: select"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FATAL_ERROR
operator|)
return|;
block|}
comment|/* Handle Control-C typed */
if|if
condition|(
name|quit_flag
condition|)
block|{
if|if
condition|(
operator|(
operator|++
name|panic_flag
operator|)
operator|==
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"\nAre you repeating Control-C to terminate "
literal|"the session? (y/n) [n] "
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|buf
argument_list|,
literal|3
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'y'
condition|)
block|{
name|pop_target
argument_list|()
expr_stmt|;
comment|/* Clean up */
name|error
argument_list|(
literal|"Debugging terminated by user interrupt"
argument_list|)
expr_stmt|;
block|}
name|panic_flag
operator|=
literal|0
expr_stmt|;
block|}
name|quit_flag
operator|=
literal|0
expr_stmt|;
name|SERIAL_WRITE
argument_list|(
name|remote_desc
argument_list|,
literal|"\003"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Handle terminal input */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|input
argument_list|)
condition|)
block|{
name|panic_flag
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|readtty
argument_list|()
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|READ_MORE
condition|)
return|return
operator|(
name|status
operator|)
return|;
name|echo_check
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REMOTE_CHAT */
end_comment

begin_escape
end_escape

begin_comment
comment|/* These are the threads which we last sent to the remote system.  -1 for all    or -2 for not sent yet.  */
end_comment

begin_decl_stmt
name|int
name|general_thread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cont_thread
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|set_thread
parameter_list|(
name|th
parameter_list|,
name|gen
parameter_list|)
name|int
name|th
decl_stmt|;
name|int
name|gen
decl_stmt|;
block|{
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|int
name|state
init|=
name|gen
condition|?
name|general_thread
else|:
name|cont_thread
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|th
condition|)
return|return;
name|buf
index|[
literal|0
index|]
operator|=
literal|'H'
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|gen
condition|?
literal|'g'
else|:
literal|'c'
expr_stmt|;
if|if
condition|(
name|th
operator|==
literal|42000
condition|)
block|{
name|buf
index|[
literal|2
index|]
operator|=
literal|'0'
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|th
operator|<
literal|0
condition|)
name|sprintf
argument_list|(
operator|&
name|buf
index|[
literal|2
index|]
argument_list|,
literal|"-%x"
argument_list|,
operator|-
name|th
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
operator|&
name|buf
index|[
literal|2
index|]
argument_list|,
literal|"%x"
argument_list|,
name|th
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|gen
condition|)
name|general_thread
operator|=
name|th
expr_stmt|;
else|else
name|cont_thread
operator|=
name|th
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  Return nonzero if the thread TH is still alive on the remote system.  */
end_comment

begin_function
specifier|static
name|int
name|remote_thread_alive
parameter_list|(
name|th
parameter_list|)
name|int
name|th
decl_stmt|;
block|{
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'T'
expr_stmt|;
if|if
condition|(
name|th
operator|<
literal|0
condition|)
name|sprintf
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|,
literal|"-%x"
argument_list|,
operator|-
name|th
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|,
literal|"%x"
argument_list|,
name|th
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'O'
operator|&&
name|buf
index|[
literal|1
index|]
operator|==
literal|'K'
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  Restart the remote side; this is an extended protocol operation.  */
end_comment

begin_function
specifier|static
name|void
name|extended_remote_restart
parameter_list|()
block|{
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
comment|/* Send the restart command; for reasons I don't understand the      remote side really expects a number after the "R".  */
name|buf
index|[
literal|0
index|]
operator|=
literal|'R'
expr_stmt|;
name|sprintf
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|,
literal|"%x"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* Now query for status so this looks just like we restarted      gdbserver from scratch.  */
name|putpkt
argument_list|(
literal|"?"
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Clean up connection to a remote debugger.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|remote_close
parameter_list|(
name|quitting
parameter_list|)
name|int
name|quitting
decl_stmt|;
block|{
if|if
condition|(
name|remote_desc
condition|)
name|SERIAL_CLOSE
argument_list|(
name|remote_desc
argument_list|)
expr_stmt|;
name|remote_desc
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Query the remote side for the text, data and bss offsets. */
end_comment

begin_function
specifier|static
name|void
name|get_offsets
parameter_list|()
block|{
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|int
name|nvals
decl_stmt|;
name|CORE_ADDR
name|text_addr
decl_stmt|,
name|data_addr
decl_stmt|,
name|bss_addr
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|offs
decl_stmt|;
ifdef|#
directive|ifdef
name|REMOTE_CHAT
if|if
condition|(
name|remote_chat
condition|)
operator|(
name|void
operator|)
name|remote_talk
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* REMOTE_CHAT */
name|putpkt
argument_list|(
literal|"qOffsets"
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\000'
condition|)
return|return;
comment|/* Return silently.  Stub doesn't support this 				   command. */
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'E'
condition|)
block|{
name|warning
argument_list|(
literal|"Remote failure reply: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
name|nvals
operator|=
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"Text=%lx;Data=%lx;Bss=%lx"
argument_list|,
operator|&
name|text_addr
argument_list|,
operator|&
name|data_addr
argument_list|,
operator|&
name|bss_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvals
operator|!=
literal|3
condition|)
name|error
argument_list|(
literal|"Malformed response to offset query, %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|symfile_objfile
operator|==
name|NULL
condition|)
return|return;
name|offs
operator|=
operator|(
expr|struct
name|section_offsets
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_offsets
argument_list|)
operator|+
name|symfile_objfile
operator|->
name|num_sections
operator|*
sizeof|sizeof
argument_list|(
name|offs
operator|->
name|offsets
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|offs
argument_list|,
name|symfile_objfile
operator|->
name|section_offsets
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|section_offsets
argument_list|)
operator|+
name|symfile_objfile
operator|->
name|num_sections
operator|*
sizeof|sizeof
argument_list|(
name|offs
operator|->
name|offsets
argument_list|)
argument_list|)
expr_stmt|;
name|ANOFFSET
argument_list|(
name|offs
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
operator|=
name|text_addr
expr_stmt|;
comment|/* This is a temporary kludge to force data and bss to use the same offsets      because that's what nlmconv does now.  The real solution requires changes      to the stub and remote.c that I don't have time to do right now.  */
name|ANOFFSET
argument_list|(
name|offs
argument_list|,
name|SECT_OFF_DATA
argument_list|)
operator|=
name|data_addr
expr_stmt|;
name|ANOFFSET
argument_list|(
name|offs
argument_list|,
name|SECT_OFF_BSS
argument_list|)
operator|=
name|data_addr
expr_stmt|;
name|objfile_relocate
argument_list|(
name|symfile_objfile
argument_list|,
name|offs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stub for catch_errors.  */
end_comment

begin_function
specifier|static
name|int
name|remote_start_remote
parameter_list|(
name|dummy
parameter_list|)
name|char
modifier|*
name|dummy
decl_stmt|;
block|{
name|immediate_quit
operator|=
literal|1
expr_stmt|;
comment|/* Allow user to interrupt it */
comment|/* Ack any packet which the remote side has already sent.  */
name|SERIAL_WRITE
argument_list|(
name|remote_desc
argument_list|,
literal|"+"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Let the stub know that we want it to return the thread.  */
name|set_thread
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|get_offsets
argument_list|()
expr_stmt|;
comment|/* Get text, data& bss offsets */
name|putpkt
argument_list|(
literal|"?"
argument_list|)
expr_stmt|;
comment|/* initiate a query from remote machine */
name|immediate_quit
operator|=
literal|0
expr_stmt|;
name|start_remote
argument_list|()
expr_stmt|;
comment|/* Initialize gdb process mechanisms */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Open a connection to a remote debugger.    NAME is the filename used for communication.  */
end_comment

begin_function
specifier|static
name|void
name|remote_open
parameter_list|(
name|name
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|remote_open_1
argument_list|(
name|name
argument_list|,
name|from_tty
argument_list|,
operator|&
name|remote_ops
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Open a connection to a remote debugger using the extended    remote gdb protocol.  NAME is the filename used for communication.  */
end_comment

begin_function
specifier|static
name|void
name|extended_remote_open
parameter_list|(
name|name
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
comment|/* Do the basic remote open stuff.  */
name|remote_open_1
argument_list|(
name|name
argument_list|,
name|from_tty
argument_list|,
operator|&
name|extended_remote_ops
argument_list|)
expr_stmt|;
comment|/* Now tell the remote that we're using the extended protocol.  */
name|putpkt
argument_list|(
literal|"!"
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generic code for opening a connection to a remote target.  */
end_comment

begin_decl_stmt
specifier|static
name|DCACHE
modifier|*
name|remote_dcache
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|remote_open_1
parameter_list|(
name|name
parameter_list|,
name|from_tty
parameter_list|,
name|target
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
block|{
if|if
condition|(
name|name
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"To open a remote debug connection, you need to specify what serial\n\ device is attached to the remote system (e.g. /dev/ttya)."
argument_list|)
expr_stmt|;
name|target_preopen
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
name|unpush_target
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|remote_dcache
operator|=
name|dcache_init
argument_list|(
name|remote_read_bytes
argument_list|,
name|remote_write_bytes
argument_list|)
expr_stmt|;
name|remote_desc
operator|=
name|SERIAL_OPEN
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|remote_desc
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|baud_rate
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|SERIAL_SETBAUDRATE
argument_list|(
name|remote_desc
argument_list|,
name|baud_rate
argument_list|)
condition|)
block|{
name|SERIAL_CLOSE
argument_list|(
name|remote_desc
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|SERIAL_RAW
argument_list|(
name|remote_desc
argument_list|)
expr_stmt|;
comment|/* If there is something sitting in the buffer we might take it as a      response to a command, which would be bad.  */
name|SERIAL_FLUSH_INPUT
argument_list|(
name|remote_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|puts_filtered
argument_list|(
literal|"Remote debugging using "
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|push_target
argument_list|(
name|target
argument_list|)
expr_stmt|;
comment|/* Switch to using remote target now */
comment|/* Start out by trying the 'P' request to set registers.  We set this each      time that we open a new target so that if the user switches from one      stub to another, we can (if the target is closed and reopened) cope.  */
name|stub_supports_P
operator|=
literal|1
expr_stmt|;
name|general_thread
operator|=
operator|-
literal|2
expr_stmt|;
name|cont_thread
operator|=
operator|-
literal|2
expr_stmt|;
comment|/* Without this, some commands which require an active target (such as kill)      won't work.  This variable serves (at least) double duty as both the pid      of the target process (if it has such), and as a flag indicating that a      target is active.  These functions should be split out into seperate      variables, especially since GDB will someday have a notion of debugging      several processes.  */
name|inferior_pid
operator|=
literal|42000
expr_stmt|;
comment|/* Start the remote connection; if error (0), discard this target.      In particular, if the user quits, be sure to discard it      (we'd be in an inconsistent state otherwise).  */
if|if
condition|(
operator|!
name|catch_errors
argument_list|(
name|remote_start_remote
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|"Couldn't establish connection to remote target\n"
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
condition|)
name|pop_target
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This takes a program previously attached to and detaches it.  After    this is done, GDB can be used to debug some other program.  We    better not have left any breakpoints in the target program or it'll    die when it hits one.  */
end_comment

begin_function
specifier|static
name|void
name|remote_detach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|args
condition|)
name|error
argument_list|(
literal|"Argument given to \"detach\" when remotely debugging."
argument_list|)
expr_stmt|;
comment|/* Tell the remote target to detach.  */
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"D"
argument_list|)
expr_stmt|;
name|remote_send
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|pop_target
argument_list|()
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|puts_filtered
argument_list|(
literal|"Ending remote debugging.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert hex digit A to a number.  */
end_comment

begin_function
specifier|static
name|int
name|fromhex
parameter_list|(
name|a
parameter_list|)
name|int
name|a
decl_stmt|;
block|{
if|if
condition|(
name|a
operator|>=
literal|'0'
operator|&&
name|a
operator|<=
literal|'9'
condition|)
return|return
name|a
operator|-
literal|'0'
return|;
elseif|else
if|if
condition|(
name|a
operator|>=
literal|'a'
operator|&&
name|a
operator|<=
literal|'f'
condition|)
return|return
name|a
operator|-
literal|'a'
operator|+
literal|10
return|;
else|else
name|error
argument_list|(
literal|"Reply contains invalid hex digit %d"
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert number NIB to a hex digit.  */
end_comment

begin_function
specifier|static
name|int
name|tohex
parameter_list|(
name|nib
parameter_list|)
name|int
name|nib
decl_stmt|;
block|{
if|if
condition|(
name|nib
operator|<
literal|10
condition|)
return|return
literal|'0'
operator|+
name|nib
return|;
else|else
return|return
literal|'a'
operator|+
name|nib
operator|-
literal|10
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Tell the remote machine to resume.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|target_signal
name|last_sent_signal
init|=
name|TARGET_SIGNAL_0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|last_sent_step
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|remote_resume
parameter_list|(
name|pid
parameter_list|,
name|step
parameter_list|,
name|siggnal
parameter_list|)
name|int
name|pid
decl_stmt|,
name|step
decl_stmt|;
name|enum
name|target_signal
name|siggnal
decl_stmt|;
block|{
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
name|set_thread
argument_list|(
name|inferior_pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|set_thread
argument_list|(
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dcache_flush
argument_list|(
name|remote_dcache
argument_list|)
expr_stmt|;
name|last_sent_signal
operator|=
name|siggnal
expr_stmt|;
name|last_sent_step
operator|=
name|step
expr_stmt|;
if|if
condition|(
name|siggnal
operator|!=
name|TARGET_SIGNAL_0
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|step
condition|?
literal|'S'
else|:
literal|'C'
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|tohex
argument_list|(
operator|(
operator|(
name|int
operator|)
name|siggnal
operator|>>
literal|4
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|tohex
argument_list|(
operator|(
name|int
operator|)
name|siggnal
operator|&
literal|0xf
argument_list|)
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|buf
argument_list|,
name|step
condition|?
literal|"s"
else|:
literal|"c"
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Send ^C to target to halt it.  Target will respond, and send us a    packet.  */
end_comment

begin_function
specifier|static
name|void
name|remote_interrupt
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
comment|/* If this doesn't work, try more severe steps.  */
name|signal
argument_list|(
name|signo
argument_list|,
name|remote_interrupt_twice
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_debug
condition|)
name|printf_unfiltered
argument_list|(
literal|"remote_interrupt called\n"
argument_list|)
expr_stmt|;
comment|/* Send a break or a ^C, depending on user preference.  */
if|if
condition|(
name|remote_break
condition|)
name|SERIAL_SEND_BREAK
argument_list|(
name|remote_desc
argument_list|)
expr_stmt|;
else|else
name|SERIAL_WRITE
argument_list|(
name|remote_desc
argument_list|,
literal|"\003"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|ofunc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* The user typed ^C twice.  */
end_comment

begin_function
specifier|static
name|void
name|remote_interrupt_twice
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|signal
argument_list|(
name|signo
argument_list|,
name|ofunc
argument_list|)
expr_stmt|;
name|interrupt_query
argument_list|()
expr_stmt|;
name|signal
argument_list|(
name|signo
argument_list|,
name|remote_interrupt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Ask the user what to do when an interrupt is received.  */
end_comment

begin_function
specifier|static
name|void
name|interrupt_query
parameter_list|()
block|{
name|target_terminal_ours
argument_list|()
expr_stmt|;
if|if
condition|(
name|query
argument_list|(
literal|"Interrupted while waiting for the program.\n\ Give up (and stop debugging it)? "
argument_list|)
condition|)
block|{
name|target_mourn_inferior
argument_list|()
expr_stmt|;
name|return_to_top_level
argument_list|(
name|RETURN_QUIT
argument_list|)
expr_stmt|;
block|}
name|target_terminal_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If nonzero, ignore the next kill.  */
end_comment

begin_decl_stmt
name|int
name|kill_kludge
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Wait until the remote machine stops, then return,    storing status in STATUS just as `wait' would.    Returns "pid" (though it's not clear what, if anything, that    means in the case of this target).  */
end_comment

begin_function
specifier|static
name|int
name|remote_wait
parameter_list|(
name|pid
parameter_list|,
name|status
parameter_list|)
name|int
name|pid
decl_stmt|;
name|struct
name|target_waitstatus
modifier|*
name|status
decl_stmt|;
block|{
name|unsigned
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|int
name|thread_num
init|=
operator|-
literal|1
decl_stmt|;
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|integer
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|REMOTE_CHAT
if|if
condition|(
name|remote_chat
condition|)
operator|(
name|void
operator|)
name|remote_talk
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* REMOTE_CHAT */
name|ofunc
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|remote_interrupt
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|ofunc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|buf
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'E'
case|:
comment|/* Error of some sort */
name|warning
argument_list|(
literal|"Remote failure reply: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'T'
case|:
comment|/* Status with PC, SP, FP, ... */
block|{
name|int
name|i
decl_stmt|;
name|long
name|regno
decl_stmt|;
name|char
name|regs
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
comment|/* Expedited reply, containing Signal, {regno, reg} repeat */
comment|/*  format is:  'Tssn...:r...;n...:r...;n...:r...;#cc', where 		ss = signal number 		n... = register number 		r... = register contents 		*/
name|p
operator|=
operator|&
name|buf
index|[
literal|3
index|]
expr_stmt|;
comment|/* after Txx */
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|unsigned
name|char
modifier|*
name|p1
decl_stmt|;
name|char
modifier|*
name|p_temp
decl_stmt|;
name|regno
operator|=
name|strtol
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
argument_list|,
operator|&
name|p_temp
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* Read the register number */
name|p1
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|p_temp
expr_stmt|;
if|if
condition|(
name|p1
operator|==
name|p
condition|)
block|{
name|p1
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|strchr
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|==
name|NULL
condition|)
name|warning
argument_list|(
literal|"Malformed packet (missing colon): %s\n\ Packet: '%s'\n"
argument_list|,
name|p
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
argument_list|,
literal|"thread"
argument_list|,
name|p1
operator|-
name|p
argument_list|)
operator|==
literal|0
condition|)
block|{
name|thread_num
operator|=
name|strtol
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
operator|++
name|p1
argument_list|,
operator|&
name|p_temp
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|p_temp
expr_stmt|;
block|}
block|}
else|else
block|{
name|p
operator|=
name|p1
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|':'
condition|)
name|warning
argument_list|(
literal|"Malformed packet (missing colon): %s\n\ Packet: '%s'\n"
argument_list|,
name|p
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|NUM_REGS
condition|)
name|warning
argument_list|(
literal|"Remote sent bad register number %ld: %s\n\ Packet: '%s'\n"
argument_list|,
name|regno
argument_list|,
name|p
argument_list|,
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"Remote reply is too short: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|regs
index|[
name|i
index|]
operator|=
name|fromhex
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
operator|*
literal|16
operator|+
name|fromhex
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
name|supply_register
argument_list|(
name|regno
argument_list|,
name|regs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|';'
condition|)
name|warning
argument_list|(
literal|"Remote register badly formatted: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* fall through */
case|case
literal|'S'
case|:
comment|/* Old style status, just signal only */
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
operator|(
expr|enum
name|target_signal
operator|)
operator|(
operator|(
operator|(
name|fromhex
argument_list|(
name|buf
index|[
literal|1
index|]
argument_list|)
operator|)
operator|<<
literal|4
operator|)
operator|+
operator|(
name|fromhex
argument_list|(
name|buf
index|[
literal|2
index|]
argument_list|)
operator|)
operator|)
expr_stmt|;
goto|goto
name|got_status
goto|;
case|case
literal|'W'
case|:
comment|/* Target exited */
block|{
comment|/* The remote process exited.  */
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|integer
operator|=
operator|(
name|fromhex
argument_list|(
name|buf
index|[
literal|1
index|]
argument_list|)
operator|<<
literal|4
operator|)
operator|+
name|fromhex
argument_list|(
name|buf
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
goto|goto
name|got_status
goto|;
block|}
case|case
literal|'X'
case|:
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_SIGNALLED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
operator|(
expr|enum
name|target_signal
operator|)
operator|(
operator|(
operator|(
name|fromhex
argument_list|(
name|buf
index|[
literal|1
index|]
argument_list|)
operator|)
operator|<<
literal|4
operator|)
operator|+
operator|(
name|fromhex
argument_list|(
name|buf
index|[
literal|2
index|]
argument_list|)
operator|)
operator|)
expr_stmt|;
name|kill_kludge
operator|=
literal|1
expr_stmt|;
goto|goto
name|got_status
goto|;
case|case
literal|'O'
case|:
comment|/* Console output */
for|for
control|(
name|p
operator|=
name|buf
operator|+
literal|1
init|;
operator|*
name|p
condition|;
name|p
operator|+=
literal|2
control|)
block|{
name|char
name|tb
index|[
literal|2
index|]
decl_stmt|;
name|char
name|c
init|=
name|fromhex
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
operator|*
literal|16
operator|+
name|fromhex
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|tb
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|tb
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|target_output_hook
condition|)
name|target_output_hook
argument_list|(
name|tb
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
name|tb
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
literal|'\0'
case|:
if|if
condition|(
name|last_sent_signal
operator|!=
name|TARGET_SIGNAL_0
condition|)
block|{
comment|/* Zero length reply means that we tried 'S' or 'C' and 		 the remote system doesn't support it.  */
name|target_terminal_ours_for_output
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Can't send signals to this remote system.  %s not sent.\n"
argument_list|,
name|target_signal_to_name
argument_list|(
name|last_sent_signal
argument_list|)
argument_list|)
expr_stmt|;
name|last_sent_signal
operator|=
name|TARGET_SIGNAL_0
expr_stmt|;
name|target_terminal_inferior
argument_list|()
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|last_sent_step
condition|?
literal|"s"
else|:
literal|"c"
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* else fallthrough */
default|default:
name|warning
argument_list|(
literal|"Invalid remote reply: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|got_status
label|:
if|if
condition|(
name|thread_num
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* Initial thread value can only be acquired via wait, so deal with 	 this marker which is used before the first thread value is 	 acquired.  */
if|if
condition|(
name|inferior_pid
operator|==
literal|42000
condition|)
block|{
name|inferior_pid
operator|=
name|thread_num
expr_stmt|;
name|add_thread
argument_list|(
name|inferior_pid
argument_list|)
expr_stmt|;
block|}
return|return
name|thread_num
return|;
block|}
return|return
name|inferior_pid
return|;
block|}
end_function

begin_comment
comment|/* Number of bytes of registers this stub implements.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|register_bytes_found
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read the remote registers into the block REGS.  */
end_comment

begin_comment
comment|/* Currently we just read all the registers, so we don't use regno.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|remote_fetch_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|regs
index|[
name|REGISTER_BYTES
index|]
decl_stmt|;
name|set_thread
argument_list|(
name|inferior_pid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"g"
argument_list|)
expr_stmt|;
name|remote_send
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* Unimplemented registers read as all bits zero.  */
name|memset
argument_list|(
name|regs
argument_list|,
literal|0
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
comment|/* We can get out of synch in various cases.  If the first character      in the buffer is not a hex character, assume that has happened      and try to fetch another packet to read.  */
while|while
condition|(
operator|(
name|buf
index|[
literal|0
index|]
operator|<
literal|'0'
operator|||
name|buf
index|[
literal|0
index|]
operator|>
literal|'9'
operator|)
operator|&&
operator|(
name|buf
index|[
literal|0
index|]
operator|<
literal|'a'
operator|||
name|buf
index|[
literal|0
index|]
operator|>
literal|'f'
operator|)
condition|)
block|{
if|if
condition|(
name|remote_debug
condition|)
name|printf_unfiltered
argument_list|(
literal|"Bad register packet; fetching a new packet\n"
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Reply describes registers byte by byte, each byte encoded as two      hex characters.  Suck them all up, then supply them to the      register cacheing/storage mechanism.  */
name|p
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGISTER_BYTES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"Remote reply is of odd length: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* Don't change register_bytes_found in this case, and don't 	     print a second warning.  */
goto|goto
name|supply_them
goto|;
block|}
name|regs
index|[
name|i
index|]
operator|=
name|fromhex
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
operator|*
literal|16
operator|+
name|fromhex
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
name|register_bytes_found
condition|)
block|{
name|register_bytes_found
operator|=
name|i
expr_stmt|;
ifdef|#
directive|ifdef
name|REGISTER_BYTES_OK
if|if
condition|(
operator|!
name|REGISTER_BYTES_OK
argument_list|(
name|i
argument_list|)
condition|)
name|warning
argument_list|(
literal|"Remote reply is too short: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|supply_them
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
condition|;
name|i
operator|++
control|)
name|supply_register
argument_list|(
name|i
argument_list|,
operator|&
name|regs
index|[
name|REGISTER_BYTE
argument_list|(
name|i
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Prepare to store registers.  Since we may send them all (using a    'G' request), we have to read out the ones we don't want to change    first.  */
end_comment

begin_function
specifier|static
name|void
name|remote_prepare_to_store
parameter_list|()
block|{
comment|/* Make sure the entire registers array is valid.  */
name|read_register_bytes
argument_list|(
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store register REGNO, or all registers if REGNO == -1, from the contents    of REGISTERS.  FIXME: ignores errors.  */
end_comment

begin_function
specifier|static
name|void
name|remote_store_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|set_thread
argument_list|(
name|inferior_pid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|0
operator|&&
name|stub_supports_P
condition|)
block|{
comment|/* Try storing a single register.  */
name|char
modifier|*
name|regp
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"P%x="
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|regp
operator|=
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
operator|*
name|p
operator|++
operator|=
name|tohex
argument_list|(
operator|(
name|regp
index|[
name|i
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|tohex
argument_list|(
name|regp
index|[
name|i
index|]
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|remote_send
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
comment|/* The stub understands the 'P' request.  We are done.  */
return|return;
block|}
comment|/* The stub does not support the 'P' request.  Use 'G' instead, 	 and don't try using 'P' in the future (it will just waste our 	 time).  */
name|stub_supports_P
operator|=
literal|0
expr_stmt|;
block|}
name|buf
index|[
literal|0
index|]
operator|=
literal|'G'
expr_stmt|;
comment|/* Command describes registers byte by byte,      each byte encoded as two hex characters.  */
name|p
operator|=
name|buf
operator|+
literal|1
expr_stmt|;
comment|/* remote_prepare_to_store insures that register_bytes_found gets set.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|register_bytes_found
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|p
operator|++
operator|=
name|tohex
argument_list|(
operator|(
name|registers
index|[
name|i
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|tohex
argument_list|(
name|registers
index|[
name|i
index|]
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|remote_send
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*     Use of the data cache *used* to be disabled because it loses for looking at    and changing hardware I/O ports and the like.  Accepting `volatile'    would perhaps be one way to fix it.  Another idea would be to use the    executable file for the text segment (for all SEC_CODE sections?    For all SEC_READONLY sections?).  This has problems if you want to    actually see what the memory contains (e.g. self-modifying code,    clobbered memory, user downloaded the wrong thing).       Because it speeds so much up, it's now enabled, if you're playing    with registers you turn it of (set remotecache 0) */
end_comment

begin_comment
comment|/* Read a word from remote address ADDR and return it.    This goes through the data cache.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* unused? */
end_comment

begin_comment
unit|static int remote_fetch_word (addr)      CORE_ADDR addr; {   return dcache_fetch (remote_dcache, addr); }
comment|/* Write a word WORD into remote address ADDR.    This goes through the data cache.  */
end_comment

begin_endif
unit|static void remote_store_word (addr, word)      CORE_ADDR addr;      int word; {   dcache_poke (remote_dcache, addr, word); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 (unused?) */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Write memory data directly to the remote machine.    This does not inform the data cache; the data cache uses this.    MEMADDR is the address in the remote memory space.    MYADDR is the address of the buffer in our space.    LEN is the number of bytes.     Returns number of bytes transferred, or 0 for error.  */
end_comment

begin_function
specifier|static
name|int
name|remote_write_bytes
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|done
decl_stmt|;
comment|/* Chop the transfer down if necessary */
name|done
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|done
operator|<
name|len
condition|)
block|{
name|int
name|todo
init|=
name|len
operator|-
name|done
decl_stmt|;
name|int
name|cando
init|=
name|PBUFSIZ
operator|/
literal|2
operator|-
literal|32
decl_stmt|;
comment|/* number of bytes that will fit. */
if|if
condition|(
name|todo
operator|>
name|cando
condition|)
name|todo
operator|=
name|cando
expr_stmt|;
comment|/* FIXME-32x64: Need a version of print_address_numeric which puts the 	 result in a buffer like sprintf.  */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"M%lx,%x:"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|memaddr
operator|+
name|done
argument_list|,
name|todo
argument_list|)
expr_stmt|;
comment|/* We send target system values byte by byte, in increasing byte addresses, 	 each byte encoded as two hex characters.  */
name|p
operator|=
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|todo
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|p
operator|++
operator|=
name|tohex
argument_list|(
operator|(
name|myaddr
index|[
name|i
operator|+
name|done
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|tohex
argument_list|(
name|myaddr
index|[
name|i
operator|+
name|done
index|]
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'E'
condition|)
block|{
comment|/* There is no correspondance between what the remote protocol uses 	     for errors and errno codes.  We would like a cleaner way of 	     representing errors (big enough to include errno codes, bfd_error 	     codes, and others).  But for now just return EIO.  */
name|errno
operator|=
name|EIO
expr_stmt|;
return|return
literal|0
return|;
block|}
name|done
operator|+=
name|todo
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* Read memory data directly from the remote machine.    This does not use the data cache; the data cache uses this.    MEMADDR is the address in the remote memory space.    MYADDR is the address of the buffer in our space.    LEN is the number of bytes.     Returns number of bytes transferred, or 0 for error.  */
end_comment

begin_function
specifier|static
name|int
name|remote_read_bytes
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|done
decl_stmt|;
comment|/* Chop transfer down if neccessary */
if|#
directive|if
literal|0
comment|/* FIXME: This is wrong for larger packets */
block|if (len> PBUFSIZ / 2 - 1)     abort ();
endif|#
directive|endif
name|done
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|done
operator|<
name|len
condition|)
block|{
name|int
name|todo
init|=
name|len
operator|-
name|done
decl_stmt|;
name|int
name|cando
init|=
name|PBUFSIZ
operator|/
literal|2
operator|-
literal|32
decl_stmt|;
comment|/* number of bytes that will fit. */
if|if
condition|(
name|todo
operator|>
name|cando
condition|)
name|todo
operator|=
name|cando
expr_stmt|;
comment|/* FIXME-32x64: Need a version of print_address_numeric which puts the 	 result in a buffer like sprintf.  */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"m%lx,%x"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|memaddr
operator|+
name|done
argument_list|,
name|todo
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'E'
condition|)
block|{
comment|/* There is no correspondance between what the remote protocol uses 	     for errors and errno codes.  We would like a cleaner way of 	     representing errors (big enough to include errno codes, bfd_error 	     codes, and others).  But for now just return EIO.  */
name|errno
operator|=
name|EIO
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Reply describes memory byte by byte,      each byte encoded as two hex characters.  */
name|p
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|todo
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
comment|/* Reply is short.  This means that we were able to read only part 	       of what we wanted to.  */
return|return
name|i
operator|+
name|done
return|;
name|myaddr
index|[
name|i
operator|+
name|done
index|]
operator|=
name|fromhex
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
operator|*
literal|16
operator|+
name|fromhex
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
name|done
operator|+=
name|todo
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read or write LEN bytes from inferior memory at MEMADDR, transferring    to or from debugger address MYADDR.  Write to inferior if SHOULD_WRITE is    nonzero.  Returns length of data written or read; 0 for error.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|remote_xfer_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|should_write
parameter_list|,
name|target
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|should_write
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
comment|/* ignored */
block|{
return|return
name|dcache_xfer_memory
argument_list|(
name|remote_dcache
argument_list|,
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|,
name|should_write
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Enable after 4.12.  */
end_comment

begin_comment
unit|void remote_search (len, data, mask, startaddr, increment, lorange, hirange 	       addr_found, data_found)      int len;      char *data;      char *mask;      CORE_ADDR startaddr;      int increment;      CORE_ADDR lorange;      CORE_ADDR hirange;      CORE_ADDR *addr_found;      char *data_found; {   if (increment == -4&& len == 4)     {       long mask_long, data_long;       long data_found_long;       CORE_ADDR addr_we_found;       char buf[PBUFSIZ];       long returned_long[2];       char *p;        mask_long = extract_unsigned_integer (mask, len);       data_long = extract_unsigned_integer (data, len);       sprintf (buf, "t%x:%x,%x", startaddr, data_long, mask_long);       putpkt (buf);       getpkt (buf, 0);       if (buf[0] == '\0') 	{
comment|/* The stub doesn't support the 't' request.  We might want to 	     remember this fact, but on the other hand the stub could be 	     switched on us.  Maybe we should remember it only until 	     the next "target remote".  */
end_comment

begin_comment
unit|generic_search (len, data, mask, startaddr, increment, lorange, 			  hirange, addr_found, data_found); 	  return; 	}        if (buf[0] == 'E')
comment|/* There is no correspondance between what the remote protocol uses 	   for errors and errno codes.  We would like a cleaner way of 	   representing errors (big enough to include errno codes, bfd_error 	   codes, and others).  But for now just use EIO.  */
end_comment

begin_comment
unit|memory_error (EIO, startaddr);       p = buf;       addr_we_found = 0;       while (*p != '\0'&& *p != ',') 	addr_we_found = (addr_we_found<< 4) + fromhex (*p++);       if (*p == '\0') 	error ("Protocol error: short return for search");        data_found_long = 0;       while (*p != '\0'&& *p != ',') 	data_found_long = (data_found_long<< 4) + fromhex (*p++);
comment|/* Ignore anything after this comma, for future extensions.  */
end_comment

begin_endif
unit|if (addr_we_found< lorange || addr_we_found>= hirange) 	{ 	  *addr_found = 0; 	  return; 	}        *addr_found = addr_we_found;       *data_found = store_unsigned_integer (data_we_found, len);       return;     }   generic_search (len, data, mask, startaddr, increment, lorange, 		  hirange, addr_found, data_found); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_escape
end_escape

begin_function
specifier|static
name|void
name|remote_files_info
parameter_list|(
name|ignore
parameter_list|)
name|struct
name|target_ops
modifier|*
name|ignore
decl_stmt|;
block|{
name|puts_filtered
argument_list|(
literal|"Debugging a target over a serial line.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Stuff for dealing with the packets which are part of this protocol.    See comment at top of file for details.  */
end_comment

begin_comment
comment|/* Read a single character from the remote end, masking it down to 7 bits. */
end_comment

begin_function
specifier|static
name|int
name|readchar
parameter_list|(
name|timeout
parameter_list|)
name|int
name|timeout
decl_stmt|;
block|{
name|int
name|ch
decl_stmt|;
name|ch
operator|=
name|SERIAL_READCHAR
argument_list|(
name|remote_desc
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|SERIAL_EOF
case|:
name|error
argument_list|(
literal|"Remote connection closed"
argument_list|)
expr_stmt|;
case|case
name|SERIAL_ERROR
case|:
name|perror_with_name
argument_list|(
literal|"Remote communication error"
argument_list|)
expr_stmt|;
case|case
name|SERIAL_TIMEOUT
case|:
return|return
name|ch
return|;
default|default:
return|return
name|ch
operator|&
literal|0x7f
return|;
block|}
block|}
end_function

begin_comment
comment|/* Send the command in BUF to the remote machine,    and read the reply into BUF.    Report an error if we get an error reply.  */
end_comment

begin_function
specifier|static
name|void
name|remote_send
parameter_list|(
name|buf
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'E'
condition|)
name|error
argument_list|(
literal|"Remote failure reply: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Send a packet to the remote machine, with error checking.    The data of the packet is in BUF.  */
end_comment

begin_function
specifier|static
name|int
name|putpkt
parameter_list|(
name|buf
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|csum
init|=
literal|0
decl_stmt|;
name|char
name|buf2
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|int
name|cnt
init|=
name|strlen
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|int
name|tcount
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Copy the packet into buffer BUF2, encapsulating it      and giving it a checksum.  */
if|if
condition|(
name|cnt
operator|>
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|buf2
argument_list|)
operator|-
literal|5
condition|)
comment|/* Prosanity check */
name|abort
argument_list|()
expr_stmt|;
name|p
operator|=
name|buf2
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'$'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|csum
operator|+=
name|buf
index|[
name|i
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|buf
index|[
name|i
index|]
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
literal|'#'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|tohex
argument_list|(
operator|(
name|csum
operator|>>
literal|4
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|tohex
argument_list|(
name|csum
operator|&
literal|0xf
argument_list|)
expr_stmt|;
comment|/* Send it over and over until we get a positive ack.  */
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|started_error_output
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|remote_debug
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"Sending packet: %s..."
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SERIAL_WRITE
argument_list|(
name|remote_desc
argument_list|,
name|buf2
argument_list|,
name|p
operator|-
name|buf2
argument_list|)
condition|)
name|perror_with_name
argument_list|(
literal|"putpkt: write failed"
argument_list|)
expr_stmt|;
comment|/* read until either a timeout occurs (-2) or '+' is read */
while|while
condition|(
literal|1
condition|)
block|{
name|ch
operator|=
name|readchar
argument_list|(
name|remote_timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_debug
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'+'
case|:
case|case
name|SERIAL_TIMEOUT
case|:
case|case
literal|'$'
case|:
if|if
condition|(
name|started_error_output
condition|)
block|{
name|putchar_unfiltered
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|started_error_output
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'+'
case|:
if|if
condition|(
name|remote_debug
condition|)
name|printf_unfiltered
argument_list|(
literal|"Ack\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|SERIAL_TIMEOUT
case|:
name|tcount
operator|++
expr_stmt|;
if|if
condition|(
name|tcount
operator|>
literal|3
condition|)
return|return
literal|0
return|;
break|break;
comment|/* Retransmit buffer */
case|case
literal|'$'
case|:
block|{
name|char
name|junkbuf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
comment|/* It's probably an old response, and we're out of sync.  Just 		 gobble up the packet and ignore it.  */
name|getpkt
argument_list|(
name|junkbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
comment|/* Now, go look for + */
block|}
ifdef|#
directive|ifdef
name|REMOTE_CHAT
case|case
literal|'|'
case|:
block|{
if|if
condition|(
operator|!
name|started_error_output
condition|)
continue|continue;
comment|/* else fall through */
block|}
endif|#
directive|endif
comment|/* REMOTE_CHAT */
default|default:
if|if
condition|(
name|remote_debug
condition|)
block|{
if|if
condition|(
operator|!
name|started_error_output
condition|)
block|{
name|started_error_output
operator|=
literal|1
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"putpkt: Junk: "
argument_list|)
expr_stmt|;
block|}
name|putchar_unfiltered
argument_list|(
name|ch
operator|&
literal|0177
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
break|break;
comment|/* Here to retransmit */
block|}
if|#
directive|if
literal|0
comment|/* This is wrong.  If doing a long backtrace, the user should be 	 able to get out next time we call QUIT, without anything as violent 	 as interrupt_query.  If we want to provide a way out of here 	 without getting to the next QUIT, it should be based on hitting 	 ^C twice as in remote_wait.  */
block|if (quit_flag) 	{ 	  quit_flag = 0; 	  interrupt_query (); 	}
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* Come here after finding the start of the frame.  Collect the rest into BUF,    verifying the checksum, length, and handling run-length compression.    Returns 0 on any error, 1 on success.  */
end_comment

begin_function
specifier|static
name|int
name|read_frame
parameter_list|(
name|buf
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|unsigned
name|char
name|csum
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|;
name|int
name|c
decl_stmt|;
name|csum
operator|=
literal|0
expr_stmt|;
name|bp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|readchar
argument_list|(
name|remote_timeout
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|SERIAL_TIMEOUT
case|:
if|if
condition|(
name|remote_debug
condition|)
name|puts_filtered
argument_list|(
literal|"Timeout in mid-packet, retrying\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|'$'
case|:
if|if
condition|(
name|remote_debug
condition|)
name|puts_filtered
argument_list|(
literal|"Saw new packet start in middle of old one\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* Start a new packet, count retries */
case|case
literal|'#'
case|:
block|{
name|unsigned
name|char
name|pktcsum
decl_stmt|;
operator|*
name|bp
operator|=
literal|'\000'
expr_stmt|;
name|pktcsum
operator|=
name|fromhex
argument_list|(
name|readchar
argument_list|(
name|remote_timeout
argument_list|)
argument_list|)
operator|<<
literal|4
expr_stmt|;
name|pktcsum
operator||=
name|fromhex
argument_list|(
name|readchar
argument_list|(
name|remote_timeout
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|csum
operator|==
name|pktcsum
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|remote_debug
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Bad checksum, sentsum=0x%x, csum=0x%x, buf="
argument_list|,
name|pktcsum
argument_list|,
name|csum
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
case|case
literal|'*'
case|:
comment|/* Run length encoding */
name|csum
operator|+=
name|c
expr_stmt|;
name|c
operator|=
name|readchar
argument_list|(
name|remote_timeout
argument_list|)
expr_stmt|;
name|csum
operator|+=
name|c
expr_stmt|;
name|c
operator|=
name|c
operator|-
literal|' '
operator|+
literal|3
expr_stmt|;
comment|/* Compute repeat count */
if|if
condition|(
name|c
operator|>
literal|0
operator|&&
name|c
operator|<
literal|255
operator|&&
name|bp
operator|+
name|c
operator|-
literal|1
operator|<
name|buf
operator|+
name|PBUFSIZ
operator|-
literal|1
condition|)
block|{
name|memset
argument_list|(
name|bp
argument_list|,
operator|*
operator|(
name|bp
operator|-
literal|1
operator|)
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|c
expr_stmt|;
continue|continue;
block|}
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Repeat count %d too large for buffer: "
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
default|default:
if|if
condition|(
name|bp
operator|<
name|buf
operator|+
name|PBUFSIZ
operator|-
literal|1
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
name|csum
operator|+=
name|c
expr_stmt|;
continue|continue;
block|}
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"Remote packet too long: "
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Read a packet from the remote machine, with error checking,    and store it in BUF.  BUF is expected to be of size PBUFSIZ.    If FOREVER, wait forever rather than timing out; this is used    while the target is executing user code.  */
end_comment

begin_function
specifier|static
name|void
name|getpkt
parameter_list|(
name|buf
parameter_list|,
name|forever
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|forever
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|int
name|tries
decl_stmt|;
name|int
name|timeout
decl_stmt|;
name|int
name|val
decl_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"timeout"
argument_list|)
expr_stmt|;
if|if
condition|(
name|forever
condition|)
block|{
ifdef|#
directive|ifdef
name|MAINTENANCE_CMDS
name|timeout
operator|=
name|watchdog
operator|>
literal|0
condition|?
name|watchdog
else|:
operator|-
literal|1
expr_stmt|;
else|#
directive|else
name|timeout
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|timeout
operator|=
name|remote_timeout
expr_stmt|;
define|#
directive|define
name|MAX_TRIES
value|3
for|for
control|(
name|tries
operator|=
literal|1
init|;
name|tries
operator|<=
name|MAX_TRIES
condition|;
name|tries
operator|++
control|)
block|{
comment|/* This can loop forever if the remote side sends us characters 	 continuously, but if it pauses, we'll get a zero from readchar 	 because of timeout.  Then we'll count that as a retry.  */
comment|/* Note that we will only wait forever prior to the start of a packet. 	 After that, we expect characters to arrive at a brisk pace.  They 	 should show up within remote_timeout intervals.  */
do|do
block|{
name|c
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|SERIAL_TIMEOUT
condition|)
block|{
ifdef|#
directive|ifdef
name|MAINTENANCE_CMDS
if|if
condition|(
name|forever
condition|)
comment|/* Watchdog went off.  Kill the target. */
block|{
name|target_mourn_inferior
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"Watchdog has expired.  Target detached.\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|remote_debug
condition|)
name|puts_filtered
argument_list|(
literal|"Timed out.\n"
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
do|while
condition|(
name|c
operator|!=
literal|'$'
condition|)
do|;
comment|/* We've found the start of a packet, now collect the data.  */
name|val
operator|=
name|read_frame
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|remote_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Packet received: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|SERIAL_WRITE
argument_list|(
name|remote_desc
argument_list|,
literal|"+"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Try the whole thing again.  */
name|retry
label|:
name|SERIAL_WRITE
argument_list|(
name|remote_desc
argument_list|,
literal|"-"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* We have tried hard enough, and just can't receive the packet.  Give up. */
name|printf_unfiltered
argument_list|(
literal|"Ignoring packet error, continuing...\n"
argument_list|)
expr_stmt|;
name|SERIAL_WRITE
argument_list|(
name|remote_desc
argument_list|,
literal|"+"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|remote_kill
parameter_list|()
block|{
comment|/* For some mysterious reason, wait_for_inferior calls kill instead of      mourn after it gets TARGET_WAITKIND_SIGNALLED.  Work around it.  */
if|if
condition|(
name|kill_kludge
condition|)
block|{
name|kill_kludge
operator|=
literal|0
expr_stmt|;
name|target_mourn_inferior
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Use catch_errors so the user can quit from gdb even when we aren't on      speaking terms with the remote system.  */
name|catch_errors
argument_list|(
name|putpkt
argument_list|,
literal|"k"
argument_list|,
literal|""
argument_list|,
name|RETURN_MASK_ERROR
argument_list|)
expr_stmt|;
comment|/* Don't wait for it to die.  I'm not really sure it matters whether      we do or not.  For the existing stubs, kill is a noop.  */
name|target_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|remote_mourn
parameter_list|()
block|{
name|remote_mourn_1
argument_list|(
operator|&
name|remote_ops
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|extended_remote_mourn
parameter_list|()
block|{
comment|/* We do _not_ want to mourn the target like this; this will      remove the extended remote target  from the target stack,      and the next time the user says "run" it'll fail.        FIXME: What is the right thing to do here?  */
if|#
directive|if
literal|0
block|remote_mourn_1 (&extended_remote_ops);
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Worker function for remote_mourn.  */
end_comment

begin_function
specifier|static
name|void
name|remote_mourn_1
parameter_list|(
name|target
parameter_list|)
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
block|{
name|unpush_target
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|generic_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* In the extended protocol we want to be able to do things like    "run" and have them basically work as expected.  So we need    a special create_inferior function.      FIXME: One day add support for changing the exec file    we're debugging, arguments and an environment.  */
end_comment

begin_function
specifier|static
name|void
name|extended_remote_create_inferior
parameter_list|(
name|exec_file
parameter_list|,
name|args
parameter_list|,
name|env
parameter_list|)
name|char
modifier|*
name|exec_file
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
name|char
modifier|*
modifier|*
name|env
decl_stmt|;
block|{
comment|/* Rip out the breakpoints; we'll reinsert them after restarting      the remote server.  */
name|remove_breakpoints
argument_list|()
expr_stmt|;
comment|/* Now restart the remote server.  */
name|extended_remote_restart
argument_list|()
expr_stmt|;
comment|/* Now put the breakpoints back in.  This way we're safe if the      restart function works via a unix fork on the remote side.  */
name|insert_breakpoints
argument_list|()
expr_stmt|;
comment|/* Clean up from the last time we were running.  */
name|clear_proceed_status
argument_list|()
expr_stmt|;
comment|/* Let the remote process run.  */
name|proceed
argument_list|(
operator|-
literal|1
argument_list|,
name|TARGET_SIGNAL_0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|REMOTE_BREAKPOINT
end_ifdef

begin_comment
comment|/* On some machines, e.g. 68k, we may use a different breakpoint instruction    than other targets.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|break_insn
index|[]
init|=
name|REMOTE_BREAKPOINT
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* No REMOTE_BREAKPOINT.  */
end_comment

begin_comment
comment|/* Same old breakpoint instruction.  This code does nothing different    than mem-break.c.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|break_insn
index|[]
init|=
name|BREAKPOINT
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* No REMOTE_BREAKPOINT.  */
end_comment

begin_comment
comment|/* Insert a breakpoint on targets that don't have any better breakpoint    support.  We read the contents of the target location and stash it,    then overwrite it with a breakpoint instruction.  ADDR is the target    location in the target machine.  CONTENTS_CACHE is a pointer to     memory allocated for saving the target contents.  It is guaranteed    by the caller to be long enough to save sizeof BREAKPOINT bytes (this    is accomplished via BREAKPOINT_MAX).  */
end_comment

begin_function
specifier|static
name|int
name|remote_insert_breakpoint
parameter_list|(
name|addr
parameter_list|,
name|contents_cache
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|contents_cache
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
name|val
operator|=
name|target_read_memory
argument_list|(
name|addr
argument_list|,
name|contents_cache
argument_list|,
sizeof|sizeof
name|break_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|val
operator|=
name|target_write_memory
argument_list|(
name|addr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|break_insn
argument_list|,
sizeof|sizeof
name|break_insn
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|remote_remove_breakpoint
parameter_list|(
name|addr
parameter_list|,
name|contents_cache
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|contents_cache
decl_stmt|;
block|{
return|return
name|target_write_memory
argument_list|(
name|addr
argument_list|,
name|contents_cache
argument_list|,
sizeof|sizeof
name|break_insn
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Define the target subroutine names */
end_comment

begin_decl_stmt
name|struct
name|target_ops
name|remote_ops
init|=
block|{
literal|"remote"
block|,
comment|/* to_shortname */
literal|"Remote serial target in gdb-specific protocol"
block|,
comment|/* to_longname */
literal|"Use a remote computer via a serial line, using a gdb-specific protocol.\n\ Specify the serial device it is connected to (e.g. /dev/ttya)."
block|,
comment|/* to_doc */
name|remote_open
block|,
comment|/* to_open */
name|remote_close
block|,
comment|/* to_close */
name|NULL
block|,
comment|/* to_attach */
name|remote_detach
block|,
comment|/* to_detach */
name|remote_resume
block|,
comment|/* to_resume */
name|remote_wait
block|,
comment|/* to_wait */
name|remote_fetch_registers
block|,
comment|/* to_fetch_registers */
name|remote_store_registers
block|,
comment|/* to_store_registers */
name|remote_prepare_to_store
block|,
comment|/* to_prepare_to_store */
name|remote_xfer_memory
block|,
comment|/* to_xfer_memory */
name|remote_files_info
block|,
comment|/* to_files_info */
name|remote_insert_breakpoint
block|,
comment|/* to_insert_breakpoint */
name|remote_remove_breakpoint
block|,
comment|/* to_remove_breakpoint */
name|NULL
block|,
comment|/* to_terminal_init */
name|NULL
block|,
comment|/* to_terminal_inferior */
name|NULL
block|,
comment|/* to_terminal_ours_for_output */
name|NULL
block|,
comment|/* to_terminal_ours */
name|NULL
block|,
comment|/* to_terminal_info */
name|remote_kill
block|,
comment|/* to_kill */
name|generic_load
block|,
comment|/* to_load */
name|NULL
block|,
comment|/* to_lookup_symbol */
name|NULL
block|,
comment|/* to_create_inferior */
name|remote_mourn
block|,
comment|/* to_mourn_inferior */
literal|0
block|,
comment|/* to_can_run */
literal|0
block|,
comment|/* to_notice_signals */
name|remote_thread_alive
block|,
comment|/* to_thread_alive */
literal|0
block|,
comment|/* to_stop */
name|process_stratum
block|,
comment|/* to_stratum */
name|NULL
block|,
comment|/* to_next */
literal|1
block|,
comment|/* to_has_all_memory */
literal|1
block|,
comment|/* to_has_memory */
literal|1
block|,
comment|/* to_has_stack */
literal|1
block|,
comment|/* to_has_registers */
literal|1
block|,
comment|/* to_has_execution */
name|NULL
block|,
comment|/* sections */
name|NULL
block|,
comment|/* sections_end */
name|OPS_MAGIC
comment|/* to_magic */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|target_ops
name|extended_remote_ops
init|=
block|{
literal|"extended-remote"
block|,
comment|/* to_shortname */
literal|"Extended remote serial target in gdb-specific protocol"
block|,
comment|/* to_longname */
literal|"Use a remote computer via a serial line, using a gdb-specific protocol.\n\ Specify the serial device it is connected to (e.g. /dev/ttya)."
block|,
comment|/* to_doc */
name|extended_remote_open
block|,
comment|/* to_open */
name|remote_close
block|,
comment|/* to_close */
name|NULL
block|,
comment|/* to_attach */
name|remote_detach
block|,
comment|/* to_detach */
name|remote_resume
block|,
comment|/* to_resume */
name|remote_wait
block|,
comment|/* to_wait */
name|remote_fetch_registers
block|,
comment|/* to_fetch_registers */
name|remote_store_registers
block|,
comment|/* to_store_registers */
name|remote_prepare_to_store
block|,
comment|/* to_prepare_to_store */
name|remote_xfer_memory
block|,
comment|/* to_xfer_memory */
name|remote_files_info
block|,
comment|/* to_files_info */
name|remote_insert_breakpoint
block|,
comment|/* to_insert_breakpoint */
name|remote_remove_breakpoint
block|,
comment|/* to_remove_breakpoint */
name|NULL
block|,
comment|/* to_terminal_init */
name|NULL
block|,
comment|/* to_terminal_inferior */
name|NULL
block|,
comment|/* to_terminal_ours_for_output */
name|NULL
block|,
comment|/* to_terminal_ours */
name|NULL
block|,
comment|/* to_terminal_info */
name|remote_kill
block|,
comment|/* to_kill */
name|generic_load
block|,
comment|/* to_load */
name|NULL
block|,
comment|/* to_lookup_symbol */
name|extended_remote_create_inferior
block|,
comment|/* to_create_inferior */
name|extended_remote_mourn
block|,
comment|/* to_mourn_inferior */
literal|0
block|,
comment|/* to_can_run */
literal|0
block|,
comment|/* to_notice_signals */
name|remote_thread_alive
block|,
comment|/* to_thread_alive */
literal|0
block|,
comment|/* to_stop */
name|process_stratum
block|,
comment|/* to_stratum */
name|NULL
block|,
comment|/* to_next */
literal|1
block|,
comment|/* to_has_all_memory */
literal|1
block|,
comment|/* to_has_memory */
literal|1
block|,
comment|/* to_has_stack */
literal|1
block|,
comment|/* to_has_registers */
literal|1
block|,
comment|/* to_has_execution */
name|NULL
block|,
comment|/* sections */
name|NULL
block|,
comment|/* sections_end */
name|OPS_MAGIC
comment|/* to_magic */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_remote
parameter_list|()
block|{
name|add_target
argument_list|(
operator|&
name|remote_ops
argument_list|)
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|extended_remote_ops
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"remotetimeout"
argument_list|,
name|no_class
argument_list|,
name|var_integer
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|remote_timeout
argument_list|,
literal|"Set timeout value for remote read.\n"
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"remotebreak"
argument_list|,
name|no_class
argument_list|,
name|var_integer
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|remote_break
argument_list|,
literal|"Set whether to send break if interrupted.\n"
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REMOTE_CHAT
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"remotechat"
argument_list|,
name|no_class
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|remote_chat
argument_list|,
literal|"Set remote port interacts with target.\n"
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* REMOTE_CHAT */
block|}
end_function

end_unit

