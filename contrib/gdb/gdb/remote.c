begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Remote target communications for serial-line targets in custom GDB protocol    Copyright 1988, 91, 92, 93, 94, 95, 96, 97, 1998     Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Remote communication protocol.     A debug packet whose contents are<data>    is encapsulated for transmission in the form:  	$<data> # CSUM1 CSUM2<data> must be ASCII alphanumeric and cannot include characters 	'$' or '#'.  If<data> starts with two characters followed by 	':', then the existing stubs interpret this as a sequence number.  	CSUM1 and CSUM2 are ascii hex representation of an 8-bit  	checksum of<data>, the most significant nibble is sent first. 	the hex digits 0-9,a-f are used.     Receiver responds with:  	+	- if CSUM is correct and ready for next packet 	-	- if CSUM is incorrect<data> is as follows:    Most values are encoded in ascii hex digits.  Signal numbers are according    to the numbering in target.h.  	Request		Packet  	set thread	Hct...		Set thread for subsequent operations. 					c = 'c' for thread used in step and  					continue; t... can be -1 for all 					threads. 					c = 'g' for thread used in other 					operations.  If zero, pick a thread, 					any thread. 	reply		OK		for success 			ENN		for an error.  	read registers  g 	reply		XX....X		Each byte of register data 					is described by two hex digits. 					Registers are in the internal order 					for GDB, and the bytes in a register 					are in the same order the machine uses. 			or ENN		for an error.  	write regs	GXX..XX		Each byte of register data 					is described by two hex digits. 	reply		OK		for success 			ENN		for an error          write reg	Pn...=r...	Write register n... with value r..., 					which contains two hex digits for each 					byte in the register (target byte 					order). 	reply		OK		for success 			ENN		for an error 	(not supported by all stubs).  	read mem	mAA..AA,LLLL	AA..AA is address, LLLL is length. 	reply		XX..XX		XX..XX is mem contents 					Can be fewer bytes than requested 					if able to read only part of the data. 			or ENN		NN is errno  	write mem	MAA..AA,LLLL:XX..XX 					AA..AA is address, 					LLLL is number of bytes, 					XX..XX is data 	reply		OK		for success 			ENN		for an error (this includes the case 					where only part of the data was 					written).          write mem       XAA..AA,LLLL:XX..XX          (binary)                       AA..AA is address,                                         LLLL is number of bytes,                                         XX..XX is binary data         reply           OK              for success                         ENN             for an error  	continue	cAA..AA		AA..AA is address to resume 					If AA..AA is omitted, 					resume at same address.  	step		sAA..AA		AA..AA is address to resume 					If AA..AA is omitted, 					resume at same address.  	continue with	Csig;AA..AA	Continue with signal sig (hex signal 	signal				number).  If ;AA..AA is omitted,  					resume at same address.  	step with	Ssig;AA..AA	Like 'C' but step not continue. 	signal  	last signal     ?               Reply the current reason for stopping.                                         This is the same reply as is generated 					for step or cont : SAA where AA is the 					signal number.  	detach          D               Reply OK.  	There is no immediate reply to step or cont. 	The reply comes when the machine stops. 	It is		SAA		AA is the signal number.  	or...		TAAn...:r...;n...:r...;n...:r...; 					AA = signal number 					n... = register number (hex) 					  r... = register contents 					n... = `thread' 					  r... = thread process ID.  This is 						 a hex integer. 					n... = other string not starting  					    with valid hex digit. 					  gdb should ignore this n,r pair 					  and go on to the next.  This way 					  we can extend the protocol. 	or...		WAA		The process exited, and AA is 					the exit status.  This is only 					applicable for certains sorts of 					targets. 	or...		XAA		The process terminated with signal 					AA.         or...           OXX..XX	XX..XX  is hex encoding of ASCII data. This 					can happen at any time while the  					program is running and the debugger  					should continue to wait for  					'W', 'T', etc.  	thread alive	TXX		Find out if the thread XX is alive. 	reply		OK		thread is still alive 			ENN		thread is dead 	 	remote restart	RXX		Restart the remote server  	extended ops 	!		Use the extended remote protocol. 					Sticky -- only needs to be set once.  	kill request	k  	toggle debug	d		toggle debug flag (see 386& 68k stubs) 	reset		r		reset -- see sparc stub. 	reserved<other>		On other requests, the stub should 					ignore the request and send an empty 					response ($#<checksum>).  This way 					we can extend the protocol and GDB 					can tell whether the stub it is 					talking to uses the old or the new. 	search		tAA:PP,MM	Search backwards starting at address 					AA for a match with pattern PP and 					mask MM.  PP and MM are 4 bytes. 					Not supported by all stubs.  	general query	qXXXX		Request info about XXXX. 	general set	QXXXX=yyyy	Set value of XXXX to yyyy. 	query sect offs	qOffsets	Get section offsets.  Reply is 					Text=xxx;Data=yyy;Bss=zzz  	Responses can be run-length encoded to save space.  A '*' means that 	the next character is an ASCII encoding giving a repeat count which 	stands for that many repititions of the character preceding the '*'. 	The encoding is n+29, yielding a printable character where n>=3  	(which is where rle starts to win).  Don't use an n> 126.  	So  	"0* " means the same as "0000".  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_comment
comment|/*#include "terminal.h"*/
end_comment

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdb-stabs.h"
end_include

begin_include
include|#
directive|include
file|"gdbthread.h"
end_include

begin_include
include|#
directive|include
file|"dcache.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_decl_stmt
specifier|static
name|int
name|remote_write_bytes
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
name|memaddr
operator|,
name|char
operator|*
name|myaddr
operator|,
name|int
name|len
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remote_read_bytes
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
name|memaddr
operator|,
name|char
operator|*
name|myaddr
operator|,
name|int
name|len
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_files_info
name|PARAMS
argument_list|(
operator|(
expr|struct
name|target_ops
operator|*
name|ignore
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remote_xfer_memory
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
name|memaddr
operator|,
name|char
operator|*
name|myaddr
operator|,
name|int
name|len
operator|,
name|int
name|should_write
operator|,
expr|struct
name|target_ops
operator|*
name|target
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_prepare_to_store
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_fetch_registers
name|PARAMS
argument_list|(
operator|(
name|int
name|regno
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_resume
name|PARAMS
argument_list|(
operator|(
name|int
name|pid
operator|,
name|int
name|step
operator|,
expr|enum
name|target_signal
name|siggnal
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remote_start_remote
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_open
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|name
operator|,
name|int
name|from_tty
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|extended_remote_open
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|name
operator|,
name|int
name|from_tty
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_open_1
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|target_ops
operator|*
operator|,
name|int
name|extended_p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_close
name|PARAMS
argument_list|(
operator|(
name|int
name|quitting
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_store_registers
name|PARAMS
argument_list|(
operator|(
name|int
name|regno
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_mourn
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|extended_remote_restart
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|extended_remote_mourn
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|extended_remote_create_inferior
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_mourn_1
name|PARAMS
argument_list|(
operator|(
expr|struct
name|target_ops
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_send
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|buf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|readchar
name|PARAMS
argument_list|(
operator|(
name|int
name|timeout
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remote_wait
name|PARAMS
argument_list|(
operator|(
name|int
name|pid
operator|,
expr|struct
name|target_waitstatus
operator|*
name|status
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_kill
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tohex
name|PARAMS
argument_list|(
operator|(
name|int
name|nib
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_detach
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|args
operator|,
name|int
name|from_tty
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_interrupt
name|PARAMS
argument_list|(
operator|(
name|int
name|signo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|interrupt_query
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_thread
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remote_thread_alive
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|get_offsets
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|read_frame
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remote_insert_breakpoint
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remote_remove_breakpoint
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hexnumlen
name|PARAMS
argument_list|(
operator|(
name|ULONGEST
name|num
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_remote_ops
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_extended_remote_ops
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remote_stop
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ishex
name|PARAMS
argument_list|(
operator|(
name|int
name|ch
operator|,
name|int
operator|*
name|val
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stubhex
name|PARAMS
argument_list|(
operator|(
name|int
name|ch
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remote_query
name|PARAMS
argument_list|(
operator|(
name|int
comment|/*char*/
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hexnumstr
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|ULONGEST
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|remote_address_masked
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_packet
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|crc32
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|,
name|int
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|compare_sections_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|packet_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stub_unpack_int
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|buff
operator|,
name|int
name|fieldlength
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|unpack_varlen_hex
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|buff
operator|,
name|int
operator|*
name|result
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|unpack_nibble
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|buf
operator|,
name|int
operator|*
name|val
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pack_nibble
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|buf
operator|,
name|int
name|nibble
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pack_hex_byte
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|pkt
operator|,
name|int
comment|/*unsigned char*/
name|byte
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|unpack_byte
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|buf
operator|,
name|int
operator|*
name|value
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pack_int
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|buf
operator|,
name|int
name|value
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|unpack_int
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|buf
operator|,
name|int
operator|*
name|value
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|unpack_string
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|src
operator|,
name|char
operator|*
name|dest
operator|,
name|int
name|length
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pack_threadid
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|pkt
operator|,
name|threadref
operator|*
name|id
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|unpack_threadid
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|inbuf
operator|,
name|threadref
operator|*
name|id
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|int_to_threadref
name|PARAMS
argument_list|(
operator|(
name|threadref
operator|*
name|id
operator|,
name|int
name|value
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|threadref_to_int
name|PARAMS
argument_list|(
operator|(
name|threadref
operator|*
name|ref
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|copy_threadref
name|PARAMS
argument_list|(
operator|(
name|threadref
operator|*
name|dest
operator|,
name|threadref
operator|*
name|src
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|threadmatch
name|PARAMS
argument_list|(
operator|(
name|threadref
operator|*
name|dest
operator|,
name|threadref
operator|*
name|src
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pack_threadinfo_request
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|pkt
operator|,
name|int
name|mode
operator|,
name|threadref
operator|*
name|id
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remote_unpack_thread_info_response
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|pkt
operator|,
name|threadref
operator|*
name|expectedref
operator|,
expr|struct
name|gdb_ext_thread_info
operator|*
name|info
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remote_get_threadinfo
name|PARAMS
argument_list|(
operator|(
name|threadref
operator|*
name|threadid
operator|,
name|int
name|fieldset
operator|,
comment|/*TAG mask */
expr|struct
name|gdb_ext_thread_info
operator|*
name|info
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|adapt_remote_get_threadinfo
name|PARAMS
argument_list|(
operator|(
name|gdb_threadref
operator|*
name|ref
operator|,
name|int
name|selection
operator|,
expr|struct
name|gdb_ext_thread_info
operator|*
name|info
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pack_threadlist_request
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|pkt
operator|,
name|int
name|startflag
operator|,
name|int
name|threadcount
operator|,
name|threadref
operator|*
name|nextthread
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|parse_threadlist_response
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|pkt
operator|,
name|int
name|result_limit
operator|,
name|threadref
operator|*
name|original_echo
operator|,
name|threadref
operator|*
name|resultlist
operator|,
name|int
operator|*
name|doneflag
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remote_get_threadlist
name|PARAMS
argument_list|(
operator|(
name|int
name|startflag
operator|,
name|threadref
operator|*
name|nextthread
operator|,
name|int
name|result_limit
operator|,
name|int
operator|*
name|done
operator|,
name|int
operator|*
name|result_count
operator|,
name|threadref
operator|*
name|threadlist
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|int
function_decl|(
modifier|*
name|rmt_thread_action
function_decl|)
parameter_list|(
name|threadref
modifier|*
name|ref
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
function_decl|;
end_typedef

begin_decl_stmt
specifier|static
name|int
name|remote_threadlist_iterator
name|PARAMS
argument_list|(
operator|(
name|rmt_thread_action
name|stepfunction
operator|,
name|void
operator|*
name|context
operator|,
name|int
name|looplimit
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remote_newthread_step
name|PARAMS
argument_list|(
operator|(
name|threadref
operator|*
name|ref
operator|,
name|void
operator|*
name|context
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remote_current_thread
name|PARAMS
argument_list|(
operator|(
name|int
name|oldpid
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|remote_find_new_threads
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|record_currthread
name|PARAMS
argument_list|(
operator|(
name|int
name|currthread
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_remote_threads
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* exported functions */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|fromhex
name|PARAMS
argument_list|(
operator|(
name|int
name|a
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|getpkt
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|buf
operator|,
name|int
name|forever
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|putpkt
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|buf
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|putpkt_binary
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|buf
operator|,
name|int
name|cnt
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|remote_console_output
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|check_binary_download
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
name|addr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define the target subroutine names */
end_comment

begin_decl_stmt
name|void
name|open_remote_target
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|target_ops
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|_initialize_remote
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|target_ops
name|remote_ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|target_ops
name|extended_remote_ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|target_thread_vector
name|remote_thread_vec
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This was 5 seconds, which is a long time to sit and wait.    Unless this is going though some terminal server or multiplexer or    other form of hairy serial connection, I would think 2 seconds would    be plenty.  */
end_comment

begin_comment
comment|/* Changed to allow option to set timeout value.    was static int remote_timeout = 2; */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|remote_timeout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This variable chooses whether to send a ^C or a break when the user    requests program interruption.  Although ^C is usually what remote    systems expect, and that is the default here, sometimes a break is    preferable instead.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|remote_break
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Has the user attempted to interrupt the target? If so, then offer    the user the opportunity to bail out completely if he interrupts    again. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|interrupted_already
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Descriptor for I/O to remote machine.  Initialize it to NULL so that    remote_open knows that we don't have a file open when the program    starts.  */
end_comment

begin_decl_stmt
specifier|static
name|serial_t
name|remote_desc
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This variable (available to the user via "set remotebinarydownload")    dictates whether downloads are sent in binary (via the 'X' packet).    We assume that the stub can, and attempt to do it. This will be cleared if    the stub does not understand it. This switch is still needed, though    in cases when the packet is supported in the stub, but the connection    does not allow it (i.e., 7-bit serial connection only). */
end_comment

begin_decl_stmt
specifier|static
name|int
name|remote_binary_download
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Have we already checked whether binary downloads work? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|remote_binary_checked
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Having this larger than 400 causes us to be incompatible with m68k-stub.c    and i386-stub.c.  Normally, no one would notice because it only matters    for writing large chunks of memory (e.g. in downloads).  Also, this needs    to be more than 400 if required to hold the registers (see below, where    we round it up based on REGISTER_BYTES).  */
end_comment

begin_define
define|#
directive|define
name|PBUFSIZ
value|400
end_define

begin_comment
comment|/* Maximum number of bytes to read/write at once.  The value here    is chosen to fill up a packet (the headers account for the 32).  */
end_comment

begin_define
define|#
directive|define
name|MAXBUFBYTES
value|((PBUFSIZ-32)/2)
end_define

begin_comment
comment|/* Round up PBUFSIZ to hold all the registers, at least.  */
end_comment

begin_comment
comment|/* The blank line after the #if seems to be required to work around a    bug in HP's PA compiler.  */
end_comment

begin_if
if|#
directive|if
name|REGISTER_BYTES
operator|>
name|MAXBUFBYTES
end_if

begin_undef
undef|#
directive|undef
name|PBUFSIZ
end_undef

begin_define
define|#
directive|define
name|PBUFSIZ
value|(REGISTER_BYTES * 2 + 32)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This variable sets the number of bytes to be written to the target    in a single packet.  Normally PBUFSIZ is satisfactory, but some    targets need smaller values (perhaps because the receiving end    is slow).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|remote_write_size
init|=
name|PBUFSIZ
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This variable sets the number of bits in an address that are to be    sent in a memory ("M" or "m") packet.  Normally, after stripping    leading zeros, the entire address would be sent. This variable    restricts the address to REMOTE_ADDRESS_SIZE bits.  HISTORY: The    initial implementation of remote.c restricted the address sent in    memory packets to ``host::sizeof long'' bytes - (typically 32    bits).  Consequently, for 64 bit targets, the upper 32 bits of an    address was never sent.  Since fixing this bug may cause a break in    some remote targets this variable is principly provided to    facilitate backward compatibility. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|remote_address_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the size (in chars) of the first response to the `g' command.  This    is used to limit the size of the memory read and write commands to prevent    stub buffers from overflowing.  The size does not include headers and    trailers, it is only the payload size. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|remote_register_buf_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Should we try the 'P' request?  If this is set to one when the stub    doesn't support 'P', the only consequence is some unnecessary traffic.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stub_supports_P
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These are pointers to hook functions that may be set in order to    modify resume/wait behavior for a particular architecture.  */
end_comment

begin_macro
name|void
argument_list|(
argument|*target_resume_hook
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|void
argument_list|(
argument|*target_wait_loop_hook
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_escape
end_escape

begin_comment
comment|/*  * Support for quasi-interactive control of device through GDB port.  * While we're waiting for an event to occur, chat with the running device.  */
end_comment

begin_define
define|#
directive|define
name|REMOTE_CHAT
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|REMOTE_CHAT
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|quit_flag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|tty_input
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|escape_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|echo_check
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|remote_chat
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|read_stat
block|{
name|READ_MORE
block|,
name|FATAL_ERROR
block|,
name|ENTER_DEBUG
block|}
enum|;
end_enum

begin_function
specifier|static
name|enum
name|read_stat
name|readtarget
parameter_list|()
block|{
name|int
name|j
decl_stmt|;
name|int
name|data
decl_stmt|;
comment|/* Loop until the socket doesn't have any more data */
while|while
condition|(
operator|(
name|data
operator|=
name|readchar
argument_list|(
literal|0
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
comment|/* Check for the escape sequence */
if|if
condition|(
name|data
operator|==
literal|'|'
condition|)
block|{
comment|/* If this is the fourth escape, get out */
if|if
condition|(
operator|++
name|escape_count
operator|==
literal|4
condition|)
return|return
operator|(
name|ENTER_DEBUG
operator|)
return|;
continue|continue;
comment|/* Not the fourth, continue */
block|}
else|else
block|{
comment|/* 	     * Not an escape any more, Ensure any pending ones are flushed 	     */
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|escape_count
condition|;
name|j
operator|++
control|)
name|putchar
argument_list|(
literal|'|'
argument_list|)
expr_stmt|;
name|escape_count
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|==
literal|'\r'
condition|)
comment|/* If this is a return character */
continue|continue;
comment|/* just supress it */
if|if
condition|(
name|echo_check
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* If we are checking for an echo */
comment|/* If this might be an echo */
if|if
condition|(
name|tty_input
index|[
name|echo_check
index|]
operator|==
name|data
condition|)
block|{
name|echo_check
operator|++
expr_stmt|;
comment|/* Note one more character match */
continue|continue;
comment|/* Go and loop */
block|}
else|else
block|{
if|if
condition|(
operator|(
name|data
operator|==
literal|'\n'
operator|)
operator|&&
operator|(
name|tty_input
index|[
name|echo_check
index|]
operator|==
literal|'\r'
operator|)
condition|)
block|{
comment|/* If this is the end of the line */
name|echo_check
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* No more echo supression */
continue|continue;
comment|/* Go and loop */
block|}
comment|/* Not an echo, print out the data */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|echo_check
condition|;
name|j
operator|++
control|)
name|putchar
argument_list|(
name|tty_input
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|echo_check
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* No more echo checking */
block|}
block|}
name|putchar
argument_list|(
name|data
argument_list|)
expr_stmt|;
comment|/* Output the character */
block|}
return|return
operator|(
name|READ_MORE
operator|)
return|;
comment|/* Indicate to read some more */
block|}
end_function

begin_function
specifier|static
name|enum
name|read_stat
name|readtty
parameter_list|()
block|{
name|enum
name|read_stat
name|status
decl_stmt|;
name|int
name|tty_bc
decl_stmt|;
comment|/* First, read a buffer full from the terminal */
if|if
condition|(
operator|(
name|tty_bc
operator|=
name|read
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
name|tty_input
argument_list|,
sizeof|sizeof
argument_list|(
name|tty_input
argument_list|)
operator|-
literal|1
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror_with_name
argument_list|(
literal|"readtty: read failed"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FATAL_ERROR
operator|)
return|;
block|}
comment|/* Turn trailing newlines into returns */
if|if
condition|(
name|tty_input
index|[
name|tty_bc
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|tty_input
index|[
name|tty_bc
operator|-
literal|1
index|]
operator|=
literal|'\r'
expr_stmt|;
if|if
condition|(
operator|(
name|tty_input
index|[
literal|0
index|]
operator|==
literal|'~'
operator|)
operator|&&
operator|(
name|tty_bc
operator|==
literal|3
operator|)
condition|)
switch|switch
condition|(
name|tty_input
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'b'
case|:
comment|/* ~b\n = send break& gdb */
name|SERIAL_SEND_BREAK
argument_list|(
name|remote_desc
argument_list|)
expr_stmt|;
comment|/* fall through */
case|case
literal|'c'
case|:
comment|/* ~c\n = return to gdb */
return|return
operator|(
name|ENTER_DEBUG
operator|)
return|;
block|}
comment|/* Make this a zero terminated string and write it out */
name|tty_input
index|[
name|tty_bc
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|SERIAL_WRITE
argument_list|(
name|remote_desc
argument_list|,
name|tty_input
argument_list|,
name|tty_bc
argument_list|)
condition|)
block|{
name|perror_with_name
argument_list|(
literal|"readtty: write failed"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FATAL_ERROR
operator|)
return|;
block|}
return|return
operator|(
name|READ_MORE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|remote_talk
parameter_list|()
block|{
name|fd_set
name|input
decl_stmt|;
name|int
name|tablesize
decl_stmt|;
name|enum
name|read_stat
name|status
decl_stmt|;
name|int
name|panic_flag
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|escape_count
operator|=
literal|0
expr_stmt|;
name|echo_check
operator|=
operator|-
literal|1
expr_stmt|;
name|tablesize
operator|=
name|getdtablesize
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 	 * Check for anything from our socket - doesn't block. Note that this 	 * must be done *before* the select as there may be buffered I/O 	 * waiting to be processed. 	 */
if|if
condition|(
operator|(
name|status
operator|=
name|readtarget
argument_list|()
operator|)
operator|!=
name|READ_MORE
condition|)
return|return
operator|(
name|status
operator|)
return|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* Flush output before blocking */
comment|/* Now block on more socket input or TTY input */
name|FD_ZERO
argument_list|(
operator|&
name|input
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|input
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|remote_desc
operator|->
name|fd
argument_list|,
operator|&
name|input
argument_list|)
expr_stmt|;
name|status
operator|=
name|select
argument_list|(
name|tablesize
argument_list|,
operator|&
name|input
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|status
operator|<
literal|0
operator|)
operator|&&
operator|(
name|errno
operator|!=
name|EINTR
operator|)
condition|)
block|{
name|perror_with_name
argument_list|(
literal|"remote_talk: select"
argument_list|)
expr_stmt|;
return|return
operator|(
name|FATAL_ERROR
operator|)
return|;
block|}
comment|/* Handle Control-C typed */
if|if
condition|(
name|quit_flag
condition|)
block|{
if|if
condition|(
operator|(
operator|++
name|panic_flag
operator|)
operator|==
literal|3
condition|)
block|{
name|printf
argument_list|(
literal|"\nAre you repeating Control-C to terminate "
literal|"the session? (y/n) [n] "
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|buf
argument_list|,
literal|3
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'y'
condition|)
block|{
name|pop_target
argument_list|()
expr_stmt|;
comment|/* Clean up */
name|error
argument_list|(
literal|"Debugging terminated by user interrupt"
argument_list|)
expr_stmt|;
block|}
name|panic_flag
operator|=
literal|0
expr_stmt|;
block|}
name|quit_flag
operator|=
literal|0
expr_stmt|;
name|SERIAL_WRITE
argument_list|(
name|remote_desc
argument_list|,
literal|"\003"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Handle terminal input */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|input
argument_list|)
condition|)
block|{
name|panic_flag
operator|=
literal|0
expr_stmt|;
name|status
operator|=
name|readtty
argument_list|()
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|READ_MORE
condition|)
return|return
operator|(
name|status
operator|)
return|;
name|echo_check
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REMOTE_CHAT */
end_comment

begin_escape
end_escape

begin_comment
comment|/* These are the threads which we last sent to the remote system.    -1 for all or -2 for not sent yet.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|general_thread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cont_thread
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Call this function as a result of    1) A halt indication (T packet) containing a thread id    2) A direct query of currthread    3) Successful execution of set thread  */
end_comment

begin_function
specifier|static
name|void
name|record_currthread
parameter_list|(
name|currthread
parameter_list|)
name|int
name|currthread
decl_stmt|;
block|{
if|#
directive|if
literal|0
comment|/* target_wait must not modify inferior_pid! */
block|inferior_pid = currthread;
endif|#
directive|endif
name|general_thread
operator|=
name|currthread
expr_stmt|;
if|#
directive|if
literal|0
comment|/* setting cont_thread has a different meaning  	   from having the target report its thread id.  */
block|cont_thread = currthread;
endif|#
directive|endif
comment|/* If this is a new thread, add it to GDB's thread list.      If we leave it up to WFI to do this, bad things will happen.  */
if|if
condition|(
operator|!
name|in_thread_list
argument_list|(
name|currthread
argument_list|)
condition|)
name|add_thread
argument_list|(
name|currthread
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MAGIC_NULL_PID
value|42000
end_define

begin_function
specifier|static
name|void
name|set_thread
parameter_list|(
name|th
parameter_list|,
name|gen
parameter_list|)
name|int
name|th
decl_stmt|;
name|int
name|gen
decl_stmt|;
block|{
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|int
name|state
init|=
name|gen
condition|?
name|general_thread
else|:
name|cont_thread
decl_stmt|;
if|if
condition|(
name|state
operator|==
name|th
condition|)
return|return;
name|buf
index|[
literal|0
index|]
operator|=
literal|'H'
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|gen
condition|?
literal|'g'
else|:
literal|'c'
expr_stmt|;
if|if
condition|(
name|th
operator|==
name|MAGIC_NULL_PID
condition|)
block|{
name|buf
index|[
literal|2
index|]
operator|=
literal|'0'
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|th
operator|<
literal|0
condition|)
name|sprintf
argument_list|(
operator|&
name|buf
index|[
literal|2
index|]
argument_list|,
literal|"-%x"
argument_list|,
operator|-
name|th
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
operator|&
name|buf
index|[
literal|2
index|]
argument_list|,
literal|"%x"
argument_list|,
name|th
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|gen
condition|)
name|general_thread
operator|=
name|th
expr_stmt|;
else|else
name|cont_thread
operator|=
name|th
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  Return nonzero if the thread TH is still alive on the remote system.  */
end_comment

begin_function
specifier|static
name|int
name|remote_thread_alive
parameter_list|(
name|th
parameter_list|)
name|int
name|th
decl_stmt|;
block|{
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'T'
expr_stmt|;
if|if
condition|(
name|th
operator|<
literal|0
condition|)
name|sprintf
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|,
literal|"-%08x"
argument_list|,
operator|-
name|th
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|,
literal|"%08x"
argument_list|,
name|th
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'O'
operator|&&
name|buf
index|[
literal|1
index|]
operator|==
literal|'K'
operator|)
return|;
block|}
end_function

begin_comment
comment|/* About these extended threadlist and threadinfo packets.  They are    variable length packets but, the fields within them are often fixed    length.  They are redundent enough to send over UDP as is the    remote protocol in general.  There is a matching unit test module    in libstub.  */
end_comment

begin_define
define|#
directive|define
name|BUF_THREAD_ID_SIZE
value|(OPAQUETHREADBYTES*2)
end_define

begin_comment
comment|/* encode 64 bits in 16 chars of hex */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|hexchars
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|ishex
parameter_list|(
name|ch
parameter_list|,
name|val
parameter_list|)
name|int
name|ch
decl_stmt|;
name|int
modifier|*
name|val
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'a'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'f'
operator|)
condition|)
block|{
operator|*
name|val
operator|=
name|ch
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'A'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'F'
operator|)
condition|)
block|{
operator|*
name|val
operator|=
name|ch
operator|-
literal|'A'
operator|+
literal|10
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|ch
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|ch
operator|<=
literal|'9'
operator|)
condition|)
block|{
operator|*
name|val
operator|=
name|ch
operator|-
literal|'0'
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|stubhex
parameter_list|(
name|ch
parameter_list|)
name|int
name|ch
decl_stmt|;
block|{
if|if
condition|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'f'
condition|)
return|return
name|ch
operator|-
literal|'a'
operator|+
literal|10
return|;
if|if
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
return|return
name|ch
operator|-
literal|'0'
return|;
if|if
condition|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'F'
condition|)
return|return
name|ch
operator|-
literal|'A'
operator|+
literal|10
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|stub_unpack_int
parameter_list|(
name|buff
parameter_list|,
name|fieldlength
parameter_list|)
name|char
modifier|*
name|buff
decl_stmt|;
name|int
name|fieldlength
decl_stmt|;
block|{
name|int
name|nibble
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|fieldlength
condition|)
block|{
name|nibble
operator|=
name|stubhex
argument_list|(
operator|*
name|buff
operator|++
argument_list|)
expr_stmt|;
name|retval
operator||=
name|nibble
expr_stmt|;
name|fieldlength
operator|--
expr_stmt|;
if|if
condition|(
name|fieldlength
condition|)
name|retval
operator|=
name|retval
operator|<<
literal|4
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|unpack_varlen_hex
parameter_list|(
name|buff
parameter_list|,
name|result
parameter_list|)
name|char
modifier|*
name|buff
decl_stmt|;
comment|/* packet to parse */
name|int
modifier|*
name|result
decl_stmt|;
block|{
name|int
name|nibble
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|ishex
argument_list|(
operator|*
name|buff
argument_list|,
operator|&
name|nibble
argument_list|)
condition|)
block|{
name|buff
operator|++
expr_stmt|;
name|retval
operator|=
name|retval
operator|<<
literal|4
expr_stmt|;
name|retval
operator||=
name|nibble
operator|&
literal|0x0f
expr_stmt|;
block|}
operator|*
name|result
operator|=
name|retval
expr_stmt|;
return|return
name|buff
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|unpack_nibble
parameter_list|(
name|buf
parameter_list|,
name|val
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|int
modifier|*
name|val
decl_stmt|;
block|{
name|ishex
argument_list|(
operator|*
name|buf
operator|++
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|pack_nibble
parameter_list|(
name|buf
parameter_list|,
name|nibble
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|nibble
decl_stmt|;
block|{
operator|*
name|buf
operator|++
operator|=
name|hexchars
index|[
operator|(
name|nibble
operator|&
literal|0x0f
operator|)
index|]
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|pack_hex_byte
parameter_list|(
name|pkt
parameter_list|,
name|byte
parameter_list|)
name|char
modifier|*
name|pkt
decl_stmt|;
name|int
name|byte
decl_stmt|;
block|{
operator|*
name|pkt
operator|++
operator|=
name|hexchars
index|[
operator|(
name|byte
operator|>>
literal|4
operator|)
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|pkt
operator|++
operator|=
name|hexchars
index|[
operator|(
name|byte
operator|&
literal|0xf
operator|)
index|]
expr_stmt|;
return|return
name|pkt
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|unpack_byte
parameter_list|(
name|buf
parameter_list|,
name|value
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|int
modifier|*
name|value
decl_stmt|;
block|{
operator|*
name|value
operator|=
name|stub_unpack_int
argument_list|(
name|buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
name|buf
operator|+
literal|2
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|pack_int
parameter_list|(
name|buf
parameter_list|,
name|value
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|value
decl_stmt|;
block|{
name|buf
operator|=
name|pack_hex_byte
argument_list|(
name|buf
argument_list|,
operator|(
name|value
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|buf
operator|=
name|pack_hex_byte
argument_list|(
name|buf
argument_list|,
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|buf
operator|=
name|pack_hex_byte
argument_list|(
name|buf
argument_list|,
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0x0ff
argument_list|)
expr_stmt|;
name|buf
operator|=
name|pack_hex_byte
argument_list|(
name|buf
argument_list|,
operator|(
name|value
operator|&
literal|0xff
operator|)
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|unpack_int
parameter_list|(
name|buf
parameter_list|,
name|value
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|int
modifier|*
name|value
decl_stmt|;
block|{
operator|*
name|value
operator|=
name|stub_unpack_int
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
return|return
name|buf
operator|+
literal|8
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* currently unused, uncomment when needed */
end_comment

begin_comment
unit|static char *pack_string PARAMS ((char *pkt, char *string));  static char * pack_string (pkt, string)      char *pkt;      char *string; {   char ch;   int len;    len = strlen (string);   if (len> 200)     len = 200;
comment|/* Bigger than most GDB packets, junk??? */
end_comment

begin_comment
unit|pkt = pack_hex_byte (pkt, len);   while (len--> 0)     {       ch = *string++;       if ((ch == '\0') || (ch == '#')) 	ch = '*';
comment|/* Protect encapsulation */
end_comment

begin_endif
unit|*pkt++ = ch;     }   return pkt; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 (unused) */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|unpack_string
parameter_list|(
name|src
parameter_list|,
name|dest
parameter_list|,
name|length
parameter_list|)
name|char
modifier|*
name|src
decl_stmt|;
name|char
modifier|*
name|dest
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
while|while
condition|(
name|length
operator|--
condition|)
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
operator|*
name|dest
operator|=
literal|'\0'
expr_stmt|;
return|return
name|src
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|pack_threadid
parameter_list|(
name|pkt
parameter_list|,
name|id
parameter_list|)
name|char
modifier|*
name|pkt
decl_stmt|;
name|threadref
modifier|*
name|id
decl_stmt|;
block|{
name|char
modifier|*
name|limit
decl_stmt|;
name|unsigned
name|char
modifier|*
name|altid
decl_stmt|;
name|altid
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|id
expr_stmt|;
name|limit
operator|=
name|pkt
operator|+
name|BUF_THREAD_ID_SIZE
expr_stmt|;
while|while
condition|(
name|pkt
operator|<
name|limit
condition|)
name|pkt
operator|=
name|pack_hex_byte
argument_list|(
name|pkt
argument_list|,
operator|*
name|altid
operator|++
argument_list|)
expr_stmt|;
return|return
name|pkt
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|unpack_threadid
parameter_list|(
name|inbuf
parameter_list|,
name|id
parameter_list|)
name|char
modifier|*
name|inbuf
decl_stmt|;
name|threadref
modifier|*
name|id
decl_stmt|;
block|{
name|char
modifier|*
name|altref
decl_stmt|;
name|char
modifier|*
name|limit
init|=
name|inbuf
operator|+
name|BUF_THREAD_ID_SIZE
decl_stmt|;
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|altref
operator|=
operator|(
name|char
operator|*
operator|)
name|id
expr_stmt|;
while|while
condition|(
name|inbuf
operator|<
name|limit
condition|)
block|{
name|x
operator|=
name|stubhex
argument_list|(
operator|*
name|inbuf
operator|++
argument_list|)
expr_stmt|;
name|y
operator|=
name|stubhex
argument_list|(
operator|*
name|inbuf
operator|++
argument_list|)
expr_stmt|;
operator|*
name|altref
operator|++
operator|=
operator|(
name|x
operator|<<
literal|4
operator|)
operator||
name|y
expr_stmt|;
block|}
return|return
name|inbuf
return|;
block|}
end_function

begin_comment
comment|/* Externally, threadrefs are 64 bits but internally, they are still    ints. This is due to a mismatch of specifications.  We would like    to use 64bit thread references internally.  This is an adapter    function.  */
end_comment

begin_function
name|void
name|int_to_threadref
parameter_list|(
name|id
parameter_list|,
name|value
parameter_list|)
name|threadref
modifier|*
name|id
decl_stmt|;
name|int
name|value
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|scan
decl_stmt|;
name|scan
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|id
expr_stmt|;
block|{
name|int
name|i
init|=
literal|4
decl_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
operator|*
name|scan
operator|++
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|scan
operator|++
operator|=
operator|(
name|value
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
name|scan
operator|++
operator|=
operator|(
name|value
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
name|scan
operator|++
operator|=
operator|(
name|value
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
name|scan
operator|++
operator|=
operator|(
name|value
operator|&
literal|0xff
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|threadref_to_int
parameter_list|(
name|ref
parameter_list|)
name|threadref
modifier|*
name|ref
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|value
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
modifier|*
name|scan
decl_stmt|;
name|scan
operator|=
operator|(
name|char
operator|*
operator|)
name|ref
expr_stmt|;
name|scan
operator|+=
literal|4
expr_stmt|;
name|i
operator|=
literal|4
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
name|value
operator|=
operator|(
name|value
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|*
name|scan
operator|++
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|copy_threadref
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
name|threadref
modifier|*
name|dest
decl_stmt|;
name|threadref
modifier|*
name|src
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|char
modifier|*
name|csrc
decl_stmt|,
modifier|*
name|cdest
decl_stmt|;
name|csrc
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|src
expr_stmt|;
name|cdest
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|dest
expr_stmt|;
name|i
operator|=
literal|8
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
operator|*
name|cdest
operator|++
operator|=
operator|*
name|csrc
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|threadmatch
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
name|threadref
modifier|*
name|dest
decl_stmt|;
name|threadref
modifier|*
name|src
decl_stmt|;
block|{
comment|/* things are broken right now, so just assume we got a match */
if|#
directive|if
literal|0
block|unsigned char *srcp, *destp;   int i, result;   srcp = (char *) src;   destp = (char *) dest;    result = 1;   while (i--> 0)     result&= (*srcp++ == *destp++) ? 1 : 0;   return result;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*   threadid:1,        # always request threadid   context_exists:2,   display:4,   unique_name:8,   more_display:16 */
end_comment

begin_comment
comment|/* Encoding:  'Q':8,'P':8,mask:32,threadid:64 */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|pack_threadinfo_request
parameter_list|(
name|pkt
parameter_list|,
name|mode
parameter_list|,
name|id
parameter_list|)
name|char
modifier|*
name|pkt
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|threadref
modifier|*
name|id
decl_stmt|;
block|{
operator|*
name|pkt
operator|++
operator|=
literal|'q'
expr_stmt|;
comment|/* Info Query */
operator|*
name|pkt
operator|++
operator|=
literal|'P'
expr_stmt|;
comment|/* process or thread info */
name|pkt
operator|=
name|pack_int
argument_list|(
name|pkt
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* mode */
name|pkt
operator|=
name|pack_threadid
argument_list|(
name|pkt
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* threadid */
operator|*
name|pkt
operator|=
literal|'\0'
expr_stmt|;
comment|/* terminate */
return|return
name|pkt
return|;
block|}
end_function

begin_comment
comment|/* These values tag the fields in a thread info response packet */
end_comment

begin_comment
comment|/* Tagging the fields allows us to request specific fields and to    add more fields as time goes by */
end_comment

begin_define
define|#
directive|define
name|TAG_THREADID
value|1
end_define

begin_comment
comment|/* Echo the thread identifier */
end_comment

begin_define
define|#
directive|define
name|TAG_EXISTS
value|2
end_define

begin_comment
comment|/* Is this process defined enough to 			       fetch registers and its stack */
end_comment

begin_define
define|#
directive|define
name|TAG_DISPLAY
value|4
end_define

begin_comment
comment|/* A short thing maybe to put on a window */
end_comment

begin_define
define|#
directive|define
name|TAG_THREADNAME
value|8
end_define

begin_comment
comment|/* string, maps 1-to-1 with a thread is */
end_comment

begin_define
define|#
directive|define
name|TAG_MOREDISPLAY
value|16
end_define

begin_comment
comment|/* Whatever the kernel wants to say about  			       the process*/
end_comment

begin_function
specifier|static
name|int
name|remote_unpack_thread_info_response
parameter_list|(
name|pkt
parameter_list|,
name|expectedref
parameter_list|,
name|info
parameter_list|)
name|char
modifier|*
name|pkt
decl_stmt|;
name|threadref
modifier|*
name|expectedref
decl_stmt|;
name|struct
name|gdb_ext_thread_info
modifier|*
name|info
decl_stmt|;
block|{
name|int
name|mask
decl_stmt|,
name|length
decl_stmt|;
name|unsigned
name|int
name|tag
decl_stmt|;
name|threadref
name|ref
decl_stmt|;
name|char
modifier|*
name|limit
init|=
name|pkt
operator|+
name|PBUFSIZ
decl_stmt|;
comment|/* plausable parsing limit */
name|int
name|retval
init|=
literal|1
decl_stmt|;
comment|/* info->threadid = 0; FIXME: implement zero_threadref */
name|info
operator|->
name|active
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|display
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|info
operator|->
name|shortname
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|info
operator|->
name|more_display
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Assume the characters indicating the packet type have been stripped */
name|pkt
operator|=
name|unpack_int
argument_list|(
name|pkt
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
comment|/* arg mask */
name|pkt
operator|=
name|unpack_threadid
argument_list|(
name|pkt
argument_list|,
operator|&
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"Incomplete response to threadinfo request\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|threadmatch
argument_list|(
operator|&
name|ref
argument_list|,
name|expectedref
argument_list|)
condition|)
block|{
comment|/* This is an answer to a different request */
name|warning
argument_list|(
literal|"ERROR RMT Thread info mismatch\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|copy_threadref
argument_list|(
operator|&
name|info
operator|->
name|threadid
argument_list|,
operator|&
name|ref
argument_list|)
expr_stmt|;
comment|/* Loop on tagged fields , try to bail if somthing goes wrong */
while|while
condition|(
operator|(
name|pkt
operator|<
name|limit
operator|)
operator|&&
name|mask
operator|&&
operator|*
name|pkt
condition|)
comment|/* packets are terminated with nulls */
block|{
name|pkt
operator|=
name|unpack_int
argument_list|(
name|pkt
argument_list|,
operator|&
name|tag
argument_list|)
expr_stmt|;
comment|/* tag */
name|pkt
operator|=
name|unpack_byte
argument_list|(
name|pkt
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
comment|/* length */
if|if
condition|(
operator|!
operator|(
name|tag
operator|&
name|mask
operator|)
condition|)
comment|/* tags out of synch with mask */
block|{
name|warning
argument_list|(
literal|"ERROR RMT: threadinfo tag mismatch\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tag
operator|==
name|TAG_THREADID
condition|)
block|{
if|if
condition|(
name|length
operator|!=
literal|16
condition|)
block|{
name|warning
argument_list|(
literal|"ERROR RMT: length of threadid is not 16\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|pkt
operator|=
name|unpack_threadid
argument_list|(
name|pkt
argument_list|,
operator|&
name|ref
argument_list|)
expr_stmt|;
name|mask
operator|=
name|mask
operator|&
operator|~
name|TAG_THREADID
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|tag
operator|==
name|TAG_EXISTS
condition|)
block|{
name|info
operator|->
name|active
operator|=
name|stub_unpack_int
argument_list|(
name|pkt
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|pkt
operator|+=
name|length
expr_stmt|;
name|mask
operator|=
name|mask
operator|&
operator|~
operator|(
name|TAG_EXISTS
operator|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|8
condition|)
block|{
name|warning
argument_list|(
literal|"ERROR RMT: 'exists' length too long\n"
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
break|break;
block|}
continue|continue;
block|}
if|if
condition|(
name|tag
operator|==
name|TAG_THREADNAME
condition|)
block|{
name|pkt
operator|=
name|unpack_string
argument_list|(
name|pkt
argument_list|,
operator|&
name|info
operator|->
name|shortname
index|[
literal|0
index|]
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|mask
operator|=
name|mask
operator|&
operator|~
name|TAG_THREADNAME
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|tag
operator|==
name|TAG_DISPLAY
condition|)
block|{
name|pkt
operator|=
name|unpack_string
argument_list|(
name|pkt
argument_list|,
operator|&
name|info
operator|->
name|display
index|[
literal|0
index|]
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|mask
operator|=
name|mask
operator|&
operator|~
name|TAG_DISPLAY
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|tag
operator|==
name|TAG_MOREDISPLAY
condition|)
block|{
name|pkt
operator|=
name|unpack_string
argument_list|(
name|pkt
argument_list|,
operator|&
name|info
operator|->
name|more_display
index|[
literal|0
index|]
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|mask
operator|=
name|mask
operator|&
operator|~
name|TAG_MOREDISPLAY
expr_stmt|;
continue|continue;
block|}
name|warning
argument_list|(
literal|"ERROR RMT: unknown thread info tag\n"
argument_list|)
expr_stmt|;
break|break;
comment|/* Not a tag we know about */
block|}
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|remote_get_threadinfo
parameter_list|(
name|threadid
parameter_list|,
name|fieldset
parameter_list|,
name|info
parameter_list|)
name|threadref
modifier|*
name|threadid
decl_stmt|;
name|int
name|fieldset
decl_stmt|;
comment|/* TAG mask */
name|struct
name|gdb_ext_thread_info
modifier|*
name|info
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
name|char
name|threadinfo_pkt
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|pack_threadinfo_request
argument_list|(
name|threadinfo_pkt
argument_list|,
name|fieldset
argument_list|,
name|threadid
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|threadinfo_pkt
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|threadinfo_pkt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|result
operator|=
name|remote_unpack_thread_info_response
argument_list|(
name|threadinfo_pkt
operator|+
literal|2
argument_list|,
name|threadid
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Unfortunately, 61 bit thread-ids are bigger than the internal    representation of a threadid.  */
end_comment

begin_function
specifier|static
name|int
name|adapt_remote_get_threadinfo
parameter_list|(
name|ref
parameter_list|,
name|selection
parameter_list|,
name|info
parameter_list|)
name|gdb_threadref
modifier|*
name|ref
decl_stmt|;
name|int
name|selection
decl_stmt|;
name|struct
name|gdb_ext_thread_info
modifier|*
name|info
decl_stmt|;
block|{
name|threadref
name|lclref
decl_stmt|;
name|int_to_threadref
argument_list|(
operator|&
name|lclref
argument_list|,
operator|*
name|ref
argument_list|)
expr_stmt|;
return|return
name|remote_get_threadinfo
argument_list|(
operator|&
name|lclref
argument_list|,
name|selection
argument_list|,
name|info
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*    Format: i'Q':8,i"L":8,initflag:8,batchsize:16,lastthreadid:32   */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|pack_threadlist_request
parameter_list|(
name|pkt
parameter_list|,
name|startflag
parameter_list|,
name|threadcount
parameter_list|,
name|nextthread
parameter_list|)
name|char
modifier|*
name|pkt
decl_stmt|;
name|int
name|startflag
decl_stmt|;
name|int
name|threadcount
decl_stmt|;
name|threadref
modifier|*
name|nextthread
decl_stmt|;
block|{
operator|*
name|pkt
operator|++
operator|=
literal|'q'
expr_stmt|;
comment|/* info query packet */
operator|*
name|pkt
operator|++
operator|=
literal|'L'
expr_stmt|;
comment|/* Process LIST or threadLIST request */
name|pkt
operator|=
name|pack_nibble
argument_list|(
name|pkt
argument_list|,
name|startflag
argument_list|)
expr_stmt|;
comment|/* initflag 1 bytes */
name|pkt
operator|=
name|pack_hex_byte
argument_list|(
name|pkt
argument_list|,
name|threadcount
argument_list|)
expr_stmt|;
comment|/* threadcount 2 bytes */
name|pkt
operator|=
name|pack_threadid
argument_list|(
name|pkt
argument_list|,
name|nextthread
argument_list|)
expr_stmt|;
comment|/* 64 bit thread identifier */
operator|*
name|pkt
operator|=
literal|'\0'
expr_stmt|;
return|return
name|pkt
return|;
block|}
end_function

begin_comment
comment|/* Encoding:   'q':8,'M':8,count:16,done:8,argthreadid:64,(threadid:64)* */
end_comment

begin_function
specifier|static
name|int
name|parse_threadlist_response
parameter_list|(
name|pkt
parameter_list|,
name|result_limit
parameter_list|,
name|original_echo
parameter_list|,
name|resultlist
parameter_list|,
name|doneflag
parameter_list|)
name|char
modifier|*
name|pkt
decl_stmt|;
name|int
name|result_limit
decl_stmt|;
name|threadref
modifier|*
name|original_echo
decl_stmt|;
name|threadref
modifier|*
name|resultlist
decl_stmt|;
name|int
modifier|*
name|doneflag
decl_stmt|;
block|{
name|char
modifier|*
name|limit
decl_stmt|;
name|int
name|count
decl_stmt|,
name|resultcount
decl_stmt|,
name|done
decl_stmt|;
name|resultcount
operator|=
literal|0
expr_stmt|;
comment|/* Assume the 'q' and 'M chars have been stripped.  */
name|limit
operator|=
name|pkt
operator|+
operator|(
name|PBUFSIZ
operator|-
name|BUF_THREAD_ID_SIZE
operator|)
expr_stmt|;
comment|/* done parse past here */
name|pkt
operator|=
name|unpack_byte
argument_list|(
name|pkt
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
comment|/* count field */
name|pkt
operator|=
name|unpack_nibble
argument_list|(
name|pkt
argument_list|,
operator|&
name|done
argument_list|)
expr_stmt|;
comment|/* The first threadid is the argument threadid.  */
name|pkt
operator|=
name|unpack_threadid
argument_list|(
name|pkt
argument_list|,
name|original_echo
argument_list|)
expr_stmt|;
comment|/* should match query packet */
while|while
condition|(
operator|(
name|count
operator|--
operator|>
literal|0
operator|)
operator|&&
operator|(
name|pkt
operator|<
name|limit
operator|)
condition|)
block|{
name|pkt
operator|=
name|unpack_threadid
argument_list|(
name|pkt
argument_list|,
name|resultlist
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|resultcount
operator|++
operator|>=
name|result_limit
condition|)
break|break;
block|}
if|if
condition|(
name|doneflag
condition|)
operator|*
name|doneflag
operator|=
name|done
expr_stmt|;
return|return
name|resultcount
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|remote_get_threadlist
parameter_list|(
name|startflag
parameter_list|,
name|nextthread
parameter_list|,
name|result_limit
parameter_list|,
name|done
parameter_list|,
name|result_count
parameter_list|,
name|threadlist
parameter_list|)
name|int
name|startflag
decl_stmt|;
name|threadref
modifier|*
name|nextthread
decl_stmt|;
name|int
name|result_limit
decl_stmt|;
name|int
modifier|*
name|done
decl_stmt|;
name|int
modifier|*
name|result_count
decl_stmt|;
name|threadref
modifier|*
name|threadlist
decl_stmt|;
block|{
specifier|static
name|threadref
name|echo_nextthread
decl_stmt|;
name|char
name|threadlist_packet
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|char
name|t_response
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|int
name|result
init|=
literal|1
decl_stmt|;
comment|/* Trancate result limit to be smaller than the packet size */
if|if
condition|(
operator|(
operator|(
operator|(
name|result_limit
operator|+
literal|1
operator|)
operator|*
name|BUF_THREAD_ID_SIZE
operator|)
operator|+
literal|10
operator|)
operator|>=
name|PBUFSIZ
condition|)
name|result_limit
operator|=
operator|(
name|PBUFSIZ
operator|/
name|BUF_THREAD_ID_SIZE
operator|)
operator|-
literal|2
expr_stmt|;
name|pack_threadlist_request
argument_list|(
name|threadlist_packet
argument_list|,
name|startflag
argument_list|,
name|result_limit
argument_list|,
name|nextthread
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|threadlist_packet
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|t_response
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|*
name|result_count
operator|=
name|parse_threadlist_response
argument_list|(
name|t_response
operator|+
literal|2
argument_list|,
name|result_limit
argument_list|,
operator|&
name|echo_nextthread
argument_list|,
name|threadlist
argument_list|,
name|done
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|threadmatch
argument_list|(
operator|&
name|echo_nextthread
argument_list|,
name|nextthread
argument_list|)
condition|)
block|{
comment|/* FIXME: This is a good reason to drop the packet */
comment|/* Possably, there is a duplicate response */
comment|/* Possabilities :          retransmit immediatly - race conditions          retransmit after timeout - yes          exit          wait for packet, then exit        */
name|warning
argument_list|(
literal|"HMM: threadlist did not echo arg thread, dropping it\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* I choose simply exiting */
block|}
if|if
condition|(
operator|*
name|result_count
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|done
operator|!=
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"RMT ERROR : failed to get remote thread list\n"
argument_list|)
expr_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|result
return|;
comment|/* break; */
block|}
if|if
condition|(
operator|*
name|result_count
operator|>
name|result_limit
condition|)
block|{
operator|*
name|result_count
operator|=
literal|0
expr_stmt|;
name|warning
argument_list|(
literal|"RMT ERROR: threadlist response longer than requested\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* This is the interface between remote and threads, remotes upper interface */
end_comment

begin_comment
comment|/* remote_find_new_threads retrieves the thread list and for each    thread in the list, looks up the thread in GDB's internal list,    ading the thread if it does not already exist.  This involves    getting partial thread lists from the remote target so, polling the    quit_flag is required.  */
end_comment

begin_comment
comment|/* About this many threadisds fit in a packet. */
end_comment

begin_define
define|#
directive|define
name|MAXTHREADLISTRESULTS
value|32
end_define

begin_function
specifier|static
name|int
name|remote_threadlist_iterator
parameter_list|(
name|stepfunction
parameter_list|,
name|context
parameter_list|,
name|looplimit
parameter_list|)
name|rmt_thread_action
name|stepfunction
decl_stmt|;
name|void
modifier|*
name|context
decl_stmt|;
name|int
name|looplimit
decl_stmt|;
block|{
name|int
name|done
decl_stmt|,
name|i
decl_stmt|,
name|result_count
decl_stmt|;
name|int
name|startflag
init|=
literal|1
decl_stmt|;
name|int
name|result
init|=
literal|1
decl_stmt|;
name|int
name|loopcount
init|=
literal|0
decl_stmt|;
specifier|static
name|threadref
name|nextthread
decl_stmt|;
specifier|static
name|threadref
name|resultthreadlist
index|[
name|MAXTHREADLISTRESULTS
index|]
decl_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
if|if
condition|(
name|loopcount
operator|++
operator|>
name|looplimit
condition|)
block|{
name|result
operator|=
literal|0
expr_stmt|;
name|warning
argument_list|(
literal|"Remote fetch threadlist -infinite loop-\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|remote_get_threadlist
argument_list|(
name|startflag
argument_list|,
operator|&
name|nextthread
argument_list|,
name|MAXTHREADLISTRESULTS
argument_list|,
operator|&
name|done
argument_list|,
operator|&
name|result_count
argument_list|,
name|resultthreadlist
argument_list|)
condition|)
block|{
name|result
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* clear for later iterations */
name|startflag
operator|=
literal|0
expr_stmt|;
comment|/* Setup to resume next batch of thread references, set nextthread.  */
if|if
condition|(
name|result_count
operator|>=
literal|1
condition|)
name|copy_threadref
argument_list|(
operator|&
name|nextthread
argument_list|,
operator|&
name|resultthreadlist
index|[
name|result_count
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|result_count
operator|--
condition|)
if|if
condition|(
operator|!
operator|(
name|result
operator|=
call|(
modifier|*
name|stepfunction
call|)
argument_list|(
operator|&
name|resultthreadlist
index|[
name|i
operator|++
index|]
argument_list|,
name|context
argument_list|)
operator|)
condition|)
break|break;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|remote_newthread_step
parameter_list|(
name|ref
parameter_list|,
name|context
parameter_list|)
name|threadref
modifier|*
name|ref
decl_stmt|;
name|void
modifier|*
name|context
decl_stmt|;
block|{
name|int
name|pid
decl_stmt|;
name|pid
operator|=
name|threadref_to_int
argument_list|(
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in_thread_list
argument_list|(
name|pid
argument_list|)
condition|)
name|add_thread
argument_list|(
name|pid
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* continue iterator */
block|}
end_function

begin_define
define|#
directive|define
name|CRAZY_MAX_THREADS
value|1000
end_define

begin_function
specifier|static
name|int
name|remote_current_thread
parameter_list|(
name|oldpid
parameter_list|)
name|int
name|oldpid
decl_stmt|;
block|{
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|putpkt
argument_list|(
literal|"qC"
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'Q'
operator|&&
name|buf
index|[
literal|1
index|]
operator|==
literal|'C'
condition|)
return|return
name|strtol
argument_list|(
operator|&
name|buf
index|[
literal|2
index|]
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
return|;
else|else
return|return
name|oldpid
return|;
block|}
end_function

begin_function
name|int
name|remote_find_new_threads
parameter_list|()
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|remote_threadlist_iterator
argument_list|(
name|remote_newthread_step
argument_list|,
literal|0
argument_list|,
name|CRAZY_MAX_THREADS
argument_list|)
expr_stmt|;
if|if
condition|(
name|inferior_pid
operator|==
name|MAGIC_NULL_PID
condition|)
comment|/* ack ack ack */
name|inferior_pid
operator|=
name|remote_current_thread
argument_list|(
name|inferior_pid
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Initialize the thread vector which is used by threads.c */
end_comment

begin_comment
comment|/* The thread stub is a package, it has an initializer */
end_comment

begin_function
specifier|static
name|void
name|init_remote_threads
parameter_list|()
block|{
name|remote_thread_vec
operator|.
name|find_new_threads
operator|=
name|remote_find_new_threads
expr_stmt|;
name|remote_thread_vec
operator|.
name|get_thread_info
operator|=
name|adapt_remote_get_threadinfo
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  Restart the remote side; this is an extended protocol operation.  */
end_comment

begin_function
specifier|static
name|void
name|extended_remote_restart
parameter_list|()
block|{
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
comment|/* Send the restart command; for reasons I don't understand the      remote side really expects a number after the "R".  */
name|buf
index|[
literal|0
index|]
operator|=
literal|'R'
expr_stmt|;
name|sprintf
argument_list|(
operator|&
name|buf
index|[
literal|1
index|]
argument_list|,
literal|"%x"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* Now query for status so this looks just like we restarted      gdbserver from scratch.  */
name|putpkt
argument_list|(
literal|"?"
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Clean up connection to a remote debugger.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|remote_close
parameter_list|(
name|quitting
parameter_list|)
name|int
name|quitting
decl_stmt|;
block|{
if|if
condition|(
name|remote_desc
condition|)
name|SERIAL_CLOSE
argument_list|(
name|remote_desc
argument_list|)
expr_stmt|;
name|remote_desc
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Query the remote side for the text, data and bss offsets. */
end_comment

begin_function
specifier|static
name|void
name|get_offsets
parameter_list|()
block|{
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
name|int
name|lose
decl_stmt|;
name|CORE_ADDR
name|text_addr
decl_stmt|,
name|data_addr
decl_stmt|,
name|bss_addr
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|offs
decl_stmt|;
ifdef|#
directive|ifdef
name|REMOTE_CHAT
if|if
condition|(
name|remote_chat
condition|)
operator|(
name|void
operator|)
name|remote_talk
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* REMOTE_CHAT */
name|putpkt
argument_list|(
literal|"qOffsets"
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\000'
condition|)
return|return;
comment|/* Return silently.  Stub doesn't support 				   this command. */
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'E'
condition|)
block|{
name|warning
argument_list|(
literal|"Remote failure reply: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Pick up each field in turn.  This used to be done with scanf, but      scanf will make trouble if CORE_ADDR size doesn't match      conversion directives correctly.  The following code will work      with any size of CORE_ADDR.  */
name|text_addr
operator|=
name|data_addr
operator|=
name|bss_addr
operator|=
literal|0
expr_stmt|;
name|ptr
operator|=
name|buf
expr_stmt|;
name|lose
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|ptr
argument_list|,
literal|"Text="
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ptr
operator|+=
literal|5
expr_stmt|;
comment|/* Don't use strtol, could lose on big values.  */
while|while
condition|(
operator|*
name|ptr
operator|&&
operator|*
name|ptr
operator|!=
literal|';'
condition|)
name|text_addr
operator|=
operator|(
name|text_addr
operator|<<
literal|4
operator|)
operator|+
name|fromhex
argument_list|(
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
block|}
else|else
name|lose
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|lose
operator|&&
name|strncmp
argument_list|(
name|ptr
argument_list|,
literal|";Data="
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ptr
operator|+=
literal|6
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|&&
operator|*
name|ptr
operator|!=
literal|';'
condition|)
name|data_addr
operator|=
operator|(
name|data_addr
operator|<<
literal|4
operator|)
operator|+
name|fromhex
argument_list|(
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
block|}
else|else
name|lose
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|lose
operator|&&
name|strncmp
argument_list|(
name|ptr
argument_list|,
literal|";Bss="
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ptr
operator|+=
literal|5
expr_stmt|;
while|while
condition|(
operator|*
name|ptr
operator|&&
operator|*
name|ptr
operator|!=
literal|';'
condition|)
name|bss_addr
operator|=
operator|(
name|bss_addr
operator|<<
literal|4
operator|)
operator|+
name|fromhex
argument_list|(
operator|*
name|ptr
operator|++
argument_list|)
expr_stmt|;
block|}
else|else
name|lose
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|lose
condition|)
name|error
argument_list|(
literal|"Malformed response to offset query, %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|symfile_objfile
operator|==
name|NULL
condition|)
return|return;
name|offs
operator|=
operator|(
expr|struct
name|section_offsets
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_offsets
argument_list|)
operator|+
name|symfile_objfile
operator|->
name|num_sections
operator|*
sizeof|sizeof
argument_list|(
name|offs
operator|->
name|offsets
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|offs
argument_list|,
name|symfile_objfile
operator|->
name|section_offsets
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|section_offsets
argument_list|)
operator|+
name|symfile_objfile
operator|->
name|num_sections
operator|*
sizeof|sizeof
argument_list|(
name|offs
operator|->
name|offsets
argument_list|)
argument_list|)
expr_stmt|;
name|ANOFFSET
argument_list|(
name|offs
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
operator|=
name|text_addr
expr_stmt|;
comment|/* This is a temporary kludge to force data and bss to use the same offsets      because that's what nlmconv does now.  The real solution requires changes      to the stub and remote.c that I don't have time to do right now.  */
name|ANOFFSET
argument_list|(
name|offs
argument_list|,
name|SECT_OFF_DATA
argument_list|)
operator|=
name|data_addr
expr_stmt|;
name|ANOFFSET
argument_list|(
name|offs
argument_list|,
name|SECT_OFF_BSS
argument_list|)
operator|=
name|data_addr
expr_stmt|;
name|objfile_relocate
argument_list|(
name|symfile_objfile
argument_list|,
name|offs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stub for catch_errors.  */
end_comment

begin_function
specifier|static
name|int
name|remote_start_remote
parameter_list|(
name|dummy
parameter_list|)
name|PTR
name|dummy
decl_stmt|;
block|{
name|immediate_quit
operator|=
literal|1
expr_stmt|;
comment|/* Allow user to interrupt it */
comment|/* Ack any packet which the remote side has already sent.  */
name|SERIAL_WRITE
argument_list|(
name|remote_desc
argument_list|,
literal|"+"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Let the stub know that we want it to return the thread.  */
name|set_thread
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
name|remote_current_thread
argument_list|(
name|inferior_pid
argument_list|)
expr_stmt|;
name|get_offsets
argument_list|()
expr_stmt|;
comment|/* Get text, data& bss offsets */
name|putpkt
argument_list|(
literal|"?"
argument_list|)
expr_stmt|;
comment|/* initiate a query from remote machine */
name|immediate_quit
operator|=
literal|0
expr_stmt|;
name|start_remote
argument_list|()
expr_stmt|;
comment|/* Initialize gdb process mechanisms */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Open a connection to a remote debugger.    NAME is the filename used for communication.  */
end_comment

begin_function
specifier|static
name|void
name|remote_open
parameter_list|(
name|name
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|remote_open_1
argument_list|(
name|name
argument_list|,
name|from_tty
argument_list|,
operator|&
name|remote_ops
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Open a connection to a remote debugger using the extended    remote gdb protocol.  NAME is the filename used for communication.  */
end_comment

begin_function
specifier|static
name|void
name|extended_remote_open
parameter_list|(
name|name
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|remote_open_1
argument_list|(
name|name
argument_list|,
name|from_tty
argument_list|,
operator|&
name|extended_remote_ops
argument_list|,
literal|1
comment|/*extended_p*/
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generic code for opening a connection to a remote target.  */
end_comment

begin_decl_stmt
specifier|static
name|DCACHE
modifier|*
name|remote_dcache
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|remote_open_1
parameter_list|(
name|name
parameter_list|,
name|from_tty
parameter_list|,
name|target
parameter_list|,
name|extended_p
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
name|int
name|extended_p
decl_stmt|;
block|{
if|if
condition|(
name|name
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"To open a remote debug connection, you need to specify what\n\ serial device is attached to the remote system (e.g. /dev/ttya)."
argument_list|)
expr_stmt|;
name|target_preopen
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
name|unpush_target
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|remote_dcache
operator|=
name|dcache_init
argument_list|(
name|remote_read_bytes
argument_list|,
name|remote_write_bytes
argument_list|)
expr_stmt|;
name|remote_desc
operator|=
name|SERIAL_OPEN
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|remote_desc
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|baud_rate
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|SERIAL_SETBAUDRATE
argument_list|(
name|remote_desc
argument_list|,
name|baud_rate
argument_list|)
condition|)
block|{
name|SERIAL_CLOSE
argument_list|(
name|remote_desc
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|SERIAL_RAW
argument_list|(
name|remote_desc
argument_list|)
expr_stmt|;
comment|/* If there is something sitting in the buffer we might take it as a      response to a command, which would be bad.  */
name|SERIAL_FLUSH_INPUT
argument_list|(
name|remote_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|puts_filtered
argument_list|(
literal|"Remote debugging using "
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|push_target
argument_list|(
name|target
argument_list|)
expr_stmt|;
comment|/* Switch to using remote target now */
comment|/* The target vector does not have the thread functions in it yet,      so we use this function to call back into the thread module and      register the thread vector and its contained functions. */
name|bind_target_thread_vector
argument_list|(
operator|&
name|remote_thread_vec
argument_list|)
expr_stmt|;
comment|/* Start out by trying the 'P' request to set registers.  We set      this each time that we open a new target so that if the user      switches from one stub to another, we can (if the target is      closed and reopened) cope.  */
name|stub_supports_P
operator|=
literal|1
expr_stmt|;
name|general_thread
operator|=
operator|-
literal|2
expr_stmt|;
name|cont_thread
operator|=
operator|-
literal|2
expr_stmt|;
comment|/* Force remote_write_bytes to check whether target supports      binary downloading. */
name|remote_binary_checked
operator|=
literal|0
expr_stmt|;
comment|/* Without this, some commands which require an active target (such      as kill) won't work.  This variable serves (at least) double duty      as both the pid of the target process (if it has such), and as a      flag indicating that a target is active.  These functions should      be split out into seperate variables, especially since GDB will      someday have a notion of debugging several processes.  */
name|inferior_pid
operator|=
name|MAGIC_NULL_PID
expr_stmt|;
comment|/* Start the remote connection; if error (0), discard this target.      In particular, if the user quits, be sure to discard it      (we'd be in an inconsistent state otherwise).  */
if|if
condition|(
operator|!
name|catch_errors
argument_list|(
name|remote_start_remote
argument_list|,
name|NULL
argument_list|,
literal|"Couldn't establish connection to remote target\n"
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
condition|)
block|{
name|pop_target
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|extended_p
condition|)
block|{
comment|/* tell the remote that we're using the extended protocol.  */
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|putpkt
argument_list|(
literal|"!"
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This takes a program previously attached to and detaches it.  After    this is done, GDB can be used to debug some other program.  We    better not have left any breakpoints in the target program or it'll    die when it hits one.  */
end_comment

begin_function
specifier|static
name|void
name|remote_detach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|args
condition|)
name|error
argument_list|(
literal|"Argument given to \"detach\" when remotely debugging."
argument_list|)
expr_stmt|;
comment|/* Tell the remote target to detach.  */
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"D"
argument_list|)
expr_stmt|;
name|remote_send
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|pop_target
argument_list|()
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|puts_filtered
argument_list|(
literal|"Ending remote debugging.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert hex digit A to a number.  */
end_comment

begin_function
name|int
name|fromhex
parameter_list|(
name|a
parameter_list|)
name|int
name|a
decl_stmt|;
block|{
if|if
condition|(
name|a
operator|>=
literal|'0'
operator|&&
name|a
operator|<=
literal|'9'
condition|)
return|return
name|a
operator|-
literal|'0'
return|;
elseif|else
if|if
condition|(
name|a
operator|>=
literal|'a'
operator|&&
name|a
operator|<=
literal|'f'
condition|)
return|return
name|a
operator|-
literal|'a'
operator|+
literal|10
return|;
elseif|else
if|if
condition|(
name|a
operator|>=
literal|'A'
operator|&&
name|a
operator|<=
literal|'F'
condition|)
return|return
name|a
operator|-
literal|'A'
operator|+
literal|10
return|;
else|else
name|error
argument_list|(
literal|"Reply contains invalid hex digit %d"
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert number NIB to a hex digit.  */
end_comment

begin_function
specifier|static
name|int
name|tohex
parameter_list|(
name|nib
parameter_list|)
name|int
name|nib
decl_stmt|;
block|{
if|if
condition|(
name|nib
operator|<
literal|10
condition|)
return|return
literal|'0'
operator|+
name|nib
return|;
else|else
return|return
literal|'a'
operator|+
name|nib
operator|-
literal|10
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Tell the remote machine to resume.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|target_signal
name|last_sent_signal
init|=
name|TARGET_SIGNAL_0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|last_sent_step
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|remote_resume
parameter_list|(
name|pid
parameter_list|,
name|step
parameter_list|,
name|siggnal
parameter_list|)
name|int
name|pid
decl_stmt|,
name|step
decl_stmt|;
name|enum
name|target_signal
name|siggnal
decl_stmt|;
block|{
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
name|set_thread
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* run any thread */
else|else
name|set_thread
argument_list|(
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* run this thread */
name|dcache_flush
argument_list|(
name|remote_dcache
argument_list|)
expr_stmt|;
name|last_sent_signal
operator|=
name|siggnal
expr_stmt|;
name|last_sent_step
operator|=
name|step
expr_stmt|;
comment|/* A hook for when we need to do something at the last moment before      resumption.  */
if|if
condition|(
name|target_resume_hook
condition|)
call|(
modifier|*
name|target_resume_hook
call|)
argument_list|()
expr_stmt|;
if|if
condition|(
name|siggnal
operator|!=
name|TARGET_SIGNAL_0
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|step
condition|?
literal|'S'
else|:
literal|'C'
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|tohex
argument_list|(
operator|(
operator|(
name|int
operator|)
name|siggnal
operator|>>
literal|4
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|tohex
argument_list|(
operator|(
name|int
operator|)
name|siggnal
operator|&
literal|0xf
argument_list|)
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|buf
argument_list|,
name|step
condition|?
literal|"s"
else|:
literal|"c"
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Send ^C to target to halt it.  Target will respond, and send us a    packet.  */
end_comment

begin_expr_stmt
specifier|static
name|void
argument_list|(
argument|*ofunc
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|remote_interrupt
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|remote_stop
argument_list|()
expr_stmt|;
name|signal
argument_list|(
name|signo
argument_list|,
name|remote_interrupt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|remote_stop
parameter_list|()
block|{
if|if
condition|(
operator|!
name|interrupted_already
condition|)
block|{
comment|/* Send a break or a ^C, depending on user preference.  */
name|interrupted_already
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|remote_debug
condition|)
name|printf_unfiltered
argument_list|(
literal|"remote_stop called\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_break
condition|)
name|SERIAL_SEND_BREAK
argument_list|(
name|remote_desc
argument_list|)
expr_stmt|;
else|else
name|SERIAL_WRITE
argument_list|(
name|remote_desc
argument_list|,
literal|"\003"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|ofunc
argument_list|)
expr_stmt|;
name|interrupt_query
argument_list|()
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|remote_interrupt
argument_list|)
expr_stmt|;
name|interrupted_already
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Ask the user what to do when an interrupt is received.  */
end_comment

begin_function
specifier|static
name|void
name|interrupt_query
parameter_list|()
block|{
name|target_terminal_ours
argument_list|()
expr_stmt|;
if|if
condition|(
name|query
argument_list|(
literal|"Interrupted while waiting for the program.\n\ Give up (and stop debugging it)? "
argument_list|)
condition|)
block|{
name|target_mourn_inferior
argument_list|()
expr_stmt|;
name|return_to_top_level
argument_list|(
name|RETURN_QUIT
argument_list|)
expr_stmt|;
block|}
name|target_terminal_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If nonzero, ignore the next kill.  */
end_comment

begin_decl_stmt
name|int
name|kill_kludge
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|remote_console_output
parameter_list|(
name|msg
parameter_list|)
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|msg
init|;
operator|*
name|p
condition|;
name|p
operator|+=
literal|2
control|)
block|{
name|char
name|tb
index|[
literal|2
index|]
decl_stmt|;
name|char
name|c
init|=
name|fromhex
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
operator|*
literal|16
operator|+
name|fromhex
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|tb
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|tb
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|target_output_hook
condition|)
name|target_output_hook
argument_list|(
name|tb
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
name|tb
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Wait until the remote machine stops, then return, storing status in    STATUS just as `wait' would.  Returns "pid" (though it's not clear    what, if anything, that means in the case of this target).  */
end_comment

begin_function
specifier|static
name|int
name|remote_wait
parameter_list|(
name|pid
parameter_list|,
name|status
parameter_list|)
name|int
name|pid
decl_stmt|;
name|struct
name|target_waitstatus
modifier|*
name|status
decl_stmt|;
block|{
name|unsigned
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|int
name|thread_num
init|=
operator|-
literal|1
decl_stmt|;
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|integer
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|REMOTE_CHAT
if|if
condition|(
name|remote_chat
condition|)
operator|(
name|void
operator|)
name|remote_talk
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* REMOTE_CHAT */
name|interrupted_already
operator|=
literal|0
expr_stmt|;
name|ofunc
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|remote_interrupt
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|ofunc
argument_list|)
expr_stmt|;
comment|/* This is a hook for when we need to do something (perhaps the 	 collection of trace data) every time the target stops.  */
if|if
condition|(
name|target_wait_loop_hook
condition|)
call|(
modifier|*
name|target_wait_loop_hook
call|)
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|buf
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'E'
case|:
comment|/* Error of some sort */
name|warning
argument_list|(
literal|"Remote failure reply: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'T'
case|:
comment|/* Status with PC, SP, FP, ... */
block|{
name|int
name|i
decl_stmt|;
name|long
name|regno
decl_stmt|;
name|char
name|regs
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
comment|/* Expedited reply, containing Signal, {regno, reg} repeat */
comment|/*  format is:  'Tssn...:r...;n...:r...;n...:r...;#cc', where 		ss = signal number 		n... = register number 		r... = register contents 		*/
name|p
operator|=
operator|&
name|buf
index|[
literal|3
index|]
expr_stmt|;
comment|/* after Txx */
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|unsigned
name|char
modifier|*
name|p1
decl_stmt|;
name|char
modifier|*
name|p_temp
decl_stmt|;
comment|/* Read the register number */
name|regno
operator|=
name|strtol
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
argument_list|,
operator|&
name|p_temp
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|p1
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|p_temp
expr_stmt|;
if|if
condition|(
name|p1
operator|==
name|p
condition|)
comment|/* No register number present here */
block|{
name|p1
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|strchr
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|==
name|NULL
condition|)
name|warning
argument_list|(
literal|"Malformed packet(a) (missing colon): %s\n\ Packet: '%s'\n"
argument_list|,
name|p
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
argument_list|,
literal|"thread"
argument_list|,
name|p1
operator|-
name|p
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p_temp
operator|=
name|unpack_varlen_hex
argument_list|(
operator|++
name|p1
argument_list|,
operator|&
name|thread_num
argument_list|)
expr_stmt|;
name|record_currthread
argument_list|(
name|thread_num
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|p_temp
expr_stmt|;
block|}
block|}
else|else
block|{
name|p
operator|=
name|p1
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|':'
condition|)
name|warning
argument_list|(
literal|"Malformed packet(b) (missing colon): %s\n\ Packet: '%s'\n"
argument_list|,
name|p
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
name|NUM_REGS
condition|)
name|warning
argument_list|(
literal|"Remote sent bad register number %ld: %s\n\ Packet: '%s'\n"
argument_list|,
name|regno
argument_list|,
name|p
argument_list|,
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"Remote reply is too short: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|regs
index|[
name|i
index|]
operator|=
name|fromhex
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
operator|*
literal|16
operator|+
name|fromhex
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
name|supply_register
argument_list|(
name|regno
argument_list|,
name|regs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|';'
condition|)
block|{
name|warning
argument_list|(
literal|"Remote register badly formatted: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"            here: %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* fall through */
case|case
literal|'S'
case|:
comment|/* Old style status, just signal only */
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
operator|(
expr|enum
name|target_signal
operator|)
operator|(
operator|(
operator|(
name|fromhex
argument_list|(
name|buf
index|[
literal|1
index|]
argument_list|)
operator|)
operator|<<
literal|4
operator|)
operator|+
operator|(
name|fromhex
argument_list|(
name|buf
index|[
literal|2
index|]
argument_list|)
operator|)
operator|)
expr_stmt|;
goto|goto
name|got_status
goto|;
case|case
literal|'W'
case|:
comment|/* Target exited */
block|{
comment|/* The remote process exited.  */
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|integer
operator|=
operator|(
name|fromhex
argument_list|(
name|buf
index|[
literal|1
index|]
argument_list|)
operator|<<
literal|4
operator|)
operator|+
name|fromhex
argument_list|(
name|buf
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
goto|goto
name|got_status
goto|;
block|}
case|case
literal|'X'
case|:
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_SIGNALLED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
operator|(
expr|enum
name|target_signal
operator|)
operator|(
operator|(
operator|(
name|fromhex
argument_list|(
name|buf
index|[
literal|1
index|]
argument_list|)
operator|)
operator|<<
literal|4
operator|)
operator|+
operator|(
name|fromhex
argument_list|(
name|buf
index|[
literal|2
index|]
argument_list|)
operator|)
operator|)
expr_stmt|;
name|kill_kludge
operator|=
literal|1
expr_stmt|;
goto|goto
name|got_status
goto|;
case|case
literal|'O'
case|:
comment|/* Console output */
name|remote_console_output
argument_list|(
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'\0'
case|:
if|if
condition|(
name|last_sent_signal
operator|!=
name|TARGET_SIGNAL_0
condition|)
block|{
comment|/* Zero length reply means that we tried 'S' or 'C' and 		 the remote system doesn't support it.  */
name|target_terminal_ours_for_output
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Can't send signals to this remote system.  %s not sent.\n"
argument_list|,
name|target_signal_to_name
argument_list|(
name|last_sent_signal
argument_list|)
argument_list|)
expr_stmt|;
name|last_sent_signal
operator|=
name|TARGET_SIGNAL_0
expr_stmt|;
name|target_terminal_inferior
argument_list|()
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|last_sent_step
condition|?
literal|"s"
else|:
literal|"c"
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* else fallthrough */
default|default:
name|warning
argument_list|(
literal|"Invalid remote reply: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|got_status
label|:
if|if
condition|(
name|thread_num
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* Initial thread value can only be acquired via wait, so deal with 	 this marker which is used before the first thread value is 	 acquired.  */
if|if
condition|(
name|inferior_pid
operator|==
name|MAGIC_NULL_PID
condition|)
block|{
name|inferior_pid
operator|=
name|thread_num
expr_stmt|;
if|if
condition|(
operator|!
name|in_thread_list
argument_list|(
name|inferior_pid
argument_list|)
condition|)
name|add_thread
argument_list|(
name|inferior_pid
argument_list|)
expr_stmt|;
block|}
return|return
name|thread_num
return|;
block|}
return|return
name|inferior_pid
return|;
block|}
end_function

begin_comment
comment|/* Number of bytes of registers this stub implements.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|register_bytes_found
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read the remote registers into the block REGS.  */
end_comment

begin_comment
comment|/* Currently we just read all the registers, so we don't use regno.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|remote_fetch_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|regs
index|[
name|REGISTER_BYTES
index|]
decl_stmt|;
name|set_thread
argument_list|(
name|inferior_pid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"g"
argument_list|)
expr_stmt|;
name|remote_send
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_register_buf_size
operator|==
literal|0
condition|)
name|remote_register_buf_size
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* Unimplemented registers read as all bits zero.  */
name|memset
argument_list|(
name|regs
argument_list|,
literal|0
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
comment|/* We can get out of synch in various cases.  If the first character      in the buffer is not a hex character, assume that has happened      and try to fetch another packet to read.  */
while|while
condition|(
operator|(
name|buf
index|[
literal|0
index|]
operator|<
literal|'0'
operator|||
name|buf
index|[
literal|0
index|]
operator|>
literal|'9'
operator|)
operator|&&
operator|(
name|buf
index|[
literal|0
index|]
operator|<
literal|'a'
operator|||
name|buf
index|[
literal|0
index|]
operator|>
literal|'f'
operator|)
operator|&&
name|buf
index|[
literal|0
index|]
operator|!=
literal|'x'
condition|)
comment|/* New: unavailable register value */
block|{
if|if
condition|(
name|remote_debug
condition|)
name|printf_unfiltered
argument_list|(
literal|"Bad register packet; fetching a new packet\n"
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Reply describes registers byte by byte, each byte encoded as two      hex characters.  Suck them all up, then supply them to the      register cacheing/storage mechanism.  */
name|p
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGISTER_BYTES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"Remote reply is of odd length: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* Don't change register_bytes_found in this case, and don't 	     print a second warning.  */
goto|goto
name|supply_them
goto|;
block|}
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'x'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'x'
condition|)
name|regs
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 'x' */
else|else
name|regs
index|[
name|i
index|]
operator|=
name|fromhex
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
operator|*
literal|16
operator|+
name|fromhex
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
name|register_bytes_found
condition|)
block|{
name|register_bytes_found
operator|=
name|i
expr_stmt|;
ifdef|#
directive|ifdef
name|REGISTER_BYTES_OK
if|if
condition|(
operator|!
name|REGISTER_BYTES_OK
argument_list|(
name|i
argument_list|)
condition|)
name|warning
argument_list|(
literal|"Remote reply is too short: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|supply_them
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
condition|;
name|i
operator|++
control|)
block|{
name|supply_register
argument_list|(
name|i
argument_list|,
operator|&
name|regs
index|[
name|REGISTER_BYTE
argument_list|(
name|i
argument_list|)
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
name|REGISTER_BYTE
argument_list|(
name|i
argument_list|)
operator|*
literal|2
index|]
operator|==
literal|'x'
condition|)
name|register_valid
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* register value not available */
block|}
block|}
end_function

begin_comment
comment|/* Prepare to store registers.  Since we may send them all (using a    'G' request), we have to read out the ones we don't want to change    first.  */
end_comment

begin_function
specifier|static
name|void
name|remote_prepare_to_store
parameter_list|()
block|{
comment|/* Make sure the entire registers array is valid.  */
name|read_register_bytes
argument_list|(
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store register REGNO, or all registers if REGNO == -1, from the contents    of REGISTERS.  FIXME: ignores errors.  */
end_comment

begin_function
specifier|static
name|void
name|remote_store_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|set_thread
argument_list|(
name|inferior_pid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|0
operator|&&
name|stub_supports_P
condition|)
block|{
comment|/* Try storing a single register.  */
name|char
modifier|*
name|regp
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"P%x="
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|regp
operator|=
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
operator|*
name|p
operator|++
operator|=
name|tohex
argument_list|(
operator|(
name|regp
index|[
name|i
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|tohex
argument_list|(
name|regp
index|[
name|i
index|]
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|remote_send
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
comment|/* The stub understands the 'P' request.  We are done.  */
return|return;
block|}
comment|/* The stub does not support the 'P' request.  Use 'G' instead, 	 and don't try using 'P' in the future (it will just waste our 	 time).  */
name|stub_supports_P
operator|=
literal|0
expr_stmt|;
block|}
name|buf
index|[
literal|0
index|]
operator|=
literal|'G'
expr_stmt|;
comment|/* Command describes registers byte by byte,      each byte encoded as two hex characters.  */
name|p
operator|=
name|buf
operator|+
literal|1
expr_stmt|;
comment|/* remote_prepare_to_store insures that register_bytes_found gets set.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|register_bytes_found
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|p
operator|++
operator|=
name|tohex
argument_list|(
operator|(
name|registers
index|[
name|i
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|tohex
argument_list|(
name|registers
index|[
name|i
index|]
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|remote_send
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Use of the data cache *used* to be disabled because it loses for looking    at and changing hardware I/O ports and the like.  Accepting `volatile'    would perhaps be one way to fix it.  Another idea would be to use the    executable file for the text segment (for all SEC_CODE sections?    For all SEC_READONLY sections?).  This has problems if you want to    actually see what the memory contains (e.g. self-modifying code,    clobbered memory, user downloaded the wrong thing).       Because it speeds so much up, it's now enabled, if you're playing    with registers you turn it of (set remotecache 0).  */
end_comment

begin_comment
comment|/* Read a word from remote address ADDR and return it.    This goes through the data cache.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* unused? */
end_comment

begin_comment
unit|static int remote_fetch_word (addr)      CORE_ADDR addr; {   return dcache_fetch (remote_dcache, addr); }
comment|/* Write a word WORD into remote address ADDR.    This goes through the data cache.  */
end_comment

begin_endif
unit|static void remote_store_word (addr, word)      CORE_ADDR addr;      int word; {   dcache_poke (remote_dcache, addr, word); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 (unused?) */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Return the number of hex digits in num.  */
end_comment

begin_function
specifier|static
name|int
name|hexnumlen
parameter_list|(
name|num
parameter_list|)
name|ULONGEST
name|num
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|num
operator|!=
literal|0
condition|;
name|i
operator|++
control|)
name|num
operator|>>=
literal|4
expr_stmt|;
return|return
name|max
argument_list|(
name|i
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set BUF to the hex digits representing NUM.  */
end_comment

begin_function
specifier|static
name|int
name|hexnumstr
parameter_list|(
name|buf
parameter_list|,
name|num
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|ULONGEST
name|num
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|len
init|=
name|hexnumlen
argument_list|(
name|num
argument_list|)
decl_stmt|;
name|buf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
name|len
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|buf
index|[
name|i
index|]
operator|=
literal|"0123456789abcdef"
index|[
operator|(
name|num
operator|&
literal|0xf
operator|)
index|]
expr_stmt|;
name|num
operator|>>=
literal|4
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* Mask all but the least significant REMOTE_ADDRESS_SIZE bits. */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|remote_address_masked
parameter_list|(
name|addr
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
if|if
condition|(
name|remote_address_size
operator|>
literal|0
operator|&&
name|remote_address_size
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|ULONGEST
argument_list|)
operator|*
literal|8
operator|)
condition|)
block|{
comment|/* Only create a mask when that mask can safely be constructed          in a ULONGEST variable. */
name|ULONGEST
name|mask
init|=
literal|1
decl_stmt|;
name|mask
operator|=
operator|(
name|mask
operator|<<
name|remote_address_size
operator|)
operator|-
literal|1
expr_stmt|;
name|addr
operator|&=
name|mask
expr_stmt|;
block|}
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* Determine whether the remote target supports binary downloading.    This is accomplished by sending a no-op memory write of zero length    to the target at the specified address. It does not suffice to send    the whole packet, since many stubs strip the eighth bit and subsequently    compute a wrong checksum, which causes real havoc with remote_write_bytes. */
end_comment

begin_function
specifier|static
name|void
name|check_binary_download
parameter_list|(
name|addr
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
if|if
condition|(
name|remote_binary_download
operator|&&
operator|!
name|remote_binary_checked
condition|)
block|{
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|remote_binary_checked
operator|=
literal|1
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'X'
expr_stmt|;
name|p
operator|+=
name|hexnumstr
argument_list|(
name|p
argument_list|,
operator|(
name|ULONGEST
operator|)
name|addr
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|','
expr_stmt|;
name|p
operator|+=
name|hexnumstr
argument_list|(
name|p
argument_list|,
operator|(
name|ULONGEST
operator|)
literal|0
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|':'
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|putpkt_binary
argument_list|(
name|buf
argument_list|,
call|(
name|int
call|)
argument_list|(
name|p
operator|-
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|remote_binary_download
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|remote_debug
condition|)
block|{
if|if
condition|(
name|remote_binary_download
condition|)
name|printf_unfiltered
argument_list|(
literal|"binary downloading suppported by target\n"
argument_list|)
expr_stmt|;
else|else
name|printf_unfiltered
argument_list|(
literal|"binary downloading NOT suppported by target\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write memory data directly to the remote machine.    This does not inform the data cache; the data cache uses this.    MEMADDR is the address in the remote memory space.    MYADDR is the address of the buffer in our space.    LEN is the number of bytes.     Returns number of bytes transferred, or 0 for error.  */
end_comment

begin_function
specifier|static
name|int
name|remote_write_bytes
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|max_buf_size
decl_stmt|;
comment|/* Max size of packet output buffer */
name|int
name|origlen
decl_stmt|;
comment|/* Verify that the target can support a binary download */
name|check_binary_download
argument_list|(
name|memaddr
argument_list|)
expr_stmt|;
comment|/* Chop the transfer down if necessary */
name|max_buf_size
operator|=
name|min
argument_list|(
name|remote_write_size
argument_list|,
name|PBUFSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_register_buf_size
operator|!=
literal|0
condition|)
name|max_buf_size
operator|=
name|min
argument_list|(
name|max_buf_size
argument_list|,
name|remote_register_buf_size
argument_list|)
expr_stmt|;
comment|/* Subtract header overhead from max payload size - $M<memaddr>,<len>:#nn */
name|max_buf_size
operator|-=
literal|2
operator|+
name|hexnumlen
argument_list|(
name|memaddr
operator|+
name|len
operator|-
literal|1
argument_list|)
operator|+
literal|1
operator|+
name|hexnumlen
argument_list|(
name|len
argument_list|)
operator|+
literal|4
expr_stmt|;
name|origlen
operator|=
name|len
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|unsigned
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|plen
decl_stmt|;
name|int
name|todo
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* construct "M"<memaddr>","<len>":" */
comment|/* sprintf (buf, "M%lx,%x:", (unsigned long) memaddr, todo); */
name|memaddr
operator|=
name|remote_address_masked
argument_list|(
name|memaddr
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|remote_binary_download
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'X'
expr_stmt|;
name|todo
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|max_buf_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|p
operator|++
operator|=
literal|'M'
expr_stmt|;
name|todo
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|max_buf_size
operator|/
literal|2
argument_list|)
expr_stmt|;
comment|/* num bytes that will fit */
block|}
name|p
operator|+=
name|hexnumstr
argument_list|(
name|p
argument_list|,
operator|(
name|ULONGEST
operator|)
name|memaddr
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|','
expr_stmt|;
name|plen
operator|=
name|p
expr_stmt|;
comment|/* remember where len field goes */
name|p
operator|+=
name|hexnumstr
argument_list|(
name|p
argument_list|,
operator|(
name|ULONGEST
operator|)
name|todo
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|':'
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* We send target system values byte by byte, in increasing byte 	 addresses, each byte encoded as two hex characters (or one 	 binary character).  */
if|if
condition|(
name|remote_binary_download
condition|)
block|{
name|int
name|escaped
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|todo
operator|)
operator|&&
operator|(
name|i
operator|+
name|escaped
operator|)
operator|<
operator|(
name|max_buf_size
operator|-
literal|2
operator|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|myaddr
index|[
name|i
index|]
operator|&
literal|0xff
condition|)
block|{
case|case
literal|'$'
case|:
case|case
literal|'#'
case|:
case|case
literal|0x7d
case|:
comment|/* These must be escaped */
name|escaped
operator|++
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0x7d
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|myaddr
index|[
name|i
index|]
operator|&
literal|0xff
operator|)
operator|^
literal|0x20
expr_stmt|;
break|break;
default|default:
operator|*
name|p
operator|++
operator|=
name|myaddr
index|[
name|i
index|]
operator|&
literal|0xff
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|<
name|todo
condition|)
block|{
comment|/* Escape chars have filled up the buffer prematurely,  		 and we have actually sent fewer bytes than planned. 		 Fix-up the length field of the packet.  */
comment|/* FIXME: will fail if new len is a shorter string than  		 old len.  */
name|plen
operator|+=
name|hexnumstr
argument_list|(
name|plen
argument_list|,
operator|(
name|ULONGEST
operator|)
name|i
argument_list|)
expr_stmt|;
operator|*
name|plen
operator|++
operator|=
literal|':'
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|todo
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|p
operator|++
operator|=
name|tohex
argument_list|(
operator|(
name|myaddr
index|[
name|i
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|tohex
argument_list|(
name|myaddr
index|[
name|i
index|]
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
block|}
name|putpkt_binary
argument_list|(
name|buf
argument_list|,
call|(
name|int
call|)
argument_list|(
name|p
operator|-
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'E'
condition|)
block|{
comment|/* There is no correspondance between what the remote protocol uses 	     for errors and errno codes.  We would like a cleaner way of 	     representing errors (big enough to include errno codes, bfd_error 	     codes, and others).  But for now just return EIO.  */
name|errno
operator|=
name|EIO
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Increment by i, not by todo, in case escape chars  	 caused us to send fewer bytes than we'd planned.  */
name|myaddr
operator|+=
name|i
expr_stmt|;
name|memaddr
operator|+=
name|i
expr_stmt|;
name|len
operator|-=
name|i
expr_stmt|;
block|}
return|return
name|origlen
return|;
block|}
end_function

begin_comment
comment|/* Read memory data directly from the remote machine.    This does not use the data cache; the data cache uses this.    MEMADDR is the address in the remote memory space.    MYADDR is the address of the buffer in our space.    LEN is the number of bytes.     Returns number of bytes transferred, or 0 for error.  */
end_comment

begin_function
specifier|static
name|int
name|remote_read_bytes
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|max_buf_size
decl_stmt|;
comment|/* Max size of packet output buffer */
name|int
name|origlen
decl_stmt|;
comment|/* Chop the transfer down if necessary */
name|max_buf_size
operator|=
name|min
argument_list|(
name|remote_write_size
argument_list|,
name|PBUFSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_register_buf_size
operator|!=
literal|0
condition|)
name|max_buf_size
operator|=
name|min
argument_list|(
name|max_buf_size
argument_list|,
name|remote_register_buf_size
argument_list|)
expr_stmt|;
name|origlen
operator|=
name|len
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|todo
decl_stmt|;
name|int
name|i
decl_stmt|;
name|todo
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|max_buf_size
operator|/
literal|2
argument_list|)
expr_stmt|;
comment|/* num bytes that will fit */
comment|/* construct "m"<memaddr>","<len>" */
comment|/* sprintf (buf, "m%lx,%x", (unsigned long) memaddr, todo); */
name|memaddr
operator|=
name|remote_address_masked
argument_list|(
name|memaddr
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'m'
expr_stmt|;
name|p
operator|+=
name|hexnumstr
argument_list|(
name|p
argument_list|,
operator|(
name|ULONGEST
operator|)
name|memaddr
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|','
expr_stmt|;
name|p
operator|+=
name|hexnumstr
argument_list|(
name|p
argument_list|,
operator|(
name|ULONGEST
operator|)
name|todo
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'E'
condition|)
block|{
comment|/* There is no correspondance between what the remote protocol uses 	     for errors and errno codes.  We would like a cleaner way of 	     representing errors (big enough to include errno codes, bfd_error 	     codes, and others).  But for now just return EIO.  */
name|errno
operator|=
name|EIO
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Reply describes memory byte by byte,      each byte encoded as two hex characters.  */
name|p
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|todo
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|0
condition|)
comment|/* Reply is short.  This means that we were able to read 	       only part of what we wanted to.  */
return|return
name|i
operator|+
operator|(
name|origlen
operator|-
name|len
operator|)
return|;
name|myaddr
index|[
name|i
index|]
operator|=
name|fromhex
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
operator|*
literal|16
operator|+
name|fromhex
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
name|myaddr
operator|+=
name|todo
expr_stmt|;
name|memaddr
operator|+=
name|todo
expr_stmt|;
name|len
operator|-=
name|todo
expr_stmt|;
block|}
return|return
name|origlen
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read or write LEN bytes from inferior memory at MEMADDR,    transferring to or from debugger address MYADDR.  Write to inferior    if SHOULD_WRITE is nonzero.  Returns length of data written or    read; 0 for error.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|remote_xfer_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|should_write
parameter_list|,
name|target
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|should_write
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
comment|/* ignored */
block|{
ifdef|#
directive|ifdef
name|REMOTE_TRANSLATE_XFER_ADDRESS
name|CORE_ADDR
name|targaddr
decl_stmt|;
name|int
name|targlen
decl_stmt|;
name|REMOTE_TRANSLATE_XFER_ADDRESS
argument_list|(
name|memaddr
argument_list|,
name|len
argument_list|,
name|targaddr
argument_list|,
name|targlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|targlen
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|memaddr
operator|=
name|targaddr
expr_stmt|;
name|len
operator|=
name|targlen
expr_stmt|;
endif|#
directive|endif
return|return
name|dcache_xfer_memory
argument_list|(
name|remote_dcache
argument_list|,
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|,
name|should_write
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Enable after 4.12.  */
end_comment

begin_comment
unit|void remote_search (len, data, mask, startaddr, increment, lorange, hirange 	       addr_found, data_found)      int len;      char *data;      char *mask;      CORE_ADDR startaddr;      int increment;      CORE_ADDR lorange;      CORE_ADDR hirange;      CORE_ADDR *addr_found;      char *data_found; {   if (increment == -4&& len == 4)     {       long mask_long, data_long;       long data_found_long;       CORE_ADDR addr_we_found;       char buf[PBUFSIZ];       long returned_long[2];       char *p;        mask_long = extract_unsigned_integer (mask, len);       data_long = extract_unsigned_integer (data, len);       sprintf (buf, "t%x:%x,%x", startaddr, data_long, mask_long);       putpkt (buf);       getpkt (buf, 0);       if (buf[0] == '\0') 	{
comment|/* The stub doesn't support the 't' request.  We might want to 	     remember this fact, but on the other hand the stub could be 	     switched on us.  Maybe we should remember it only until 	     the next "target remote".  */
end_comment

begin_comment
unit|generic_search (len, data, mask, startaddr, increment, lorange, 			  hirange, addr_found, data_found); 	  return; 	}        if (buf[0] == 'E')
comment|/* There is no correspondance between what the remote protocol uses 	   for errors and errno codes.  We would like a cleaner way of 	   representing errors (big enough to include errno codes, bfd_error 	   codes, and others).  But for now just use EIO.  */
end_comment

begin_comment
unit|memory_error (EIO, startaddr);       p = buf;       addr_we_found = 0;       while (*p != '\0'&& *p != ',') 	addr_we_found = (addr_we_found<< 4) + fromhex (*p++);       if (*p == '\0') 	error ("Protocol error: short return for search");        data_found_long = 0;       while (*p != '\0'&& *p != ',') 	data_found_long = (data_found_long<< 4) + fromhex (*p++);
comment|/* Ignore anything after this comma, for future extensions.  */
end_comment

begin_endif
unit|if (addr_we_found< lorange || addr_we_found>= hirange) 	{ 	  *addr_found = 0; 	  return; 	}        *addr_found = addr_we_found;       *data_found = store_unsigned_integer (data_we_found, len);       return;     }   generic_search (len, data, mask, startaddr, increment, lorange, 		  hirange, addr_found, data_found); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_escape
end_escape

begin_function
specifier|static
name|void
name|remote_files_info
parameter_list|(
name|ignore
parameter_list|)
name|struct
name|target_ops
modifier|*
name|ignore
decl_stmt|;
block|{
name|puts_filtered
argument_list|(
literal|"Debugging a target over a serial line.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Stuff for dealing with the packets which are part of this protocol.    See comment at top of file for details.  */
end_comment

begin_comment
comment|/* Read a single character from the remote end, masking it down to 7 bits. */
end_comment

begin_function
specifier|static
name|int
name|readchar
parameter_list|(
name|timeout
parameter_list|)
name|int
name|timeout
decl_stmt|;
block|{
name|int
name|ch
decl_stmt|;
name|ch
operator|=
name|SERIAL_READCHAR
argument_list|(
name|remote_desc
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|SERIAL_EOF
case|:
name|error
argument_list|(
literal|"Remote connection closed"
argument_list|)
expr_stmt|;
case|case
name|SERIAL_ERROR
case|:
name|perror_with_name
argument_list|(
literal|"Remote communication error"
argument_list|)
expr_stmt|;
case|case
name|SERIAL_TIMEOUT
case|:
return|return
name|ch
return|;
default|default:
return|return
name|ch
operator|&
literal|0x7f
return|;
block|}
block|}
end_function

begin_comment
comment|/* Send the command in BUF to the remote machine, and read the reply    into BUF.  Report an error if we get an error reply.  */
end_comment

begin_function
specifier|static
name|void
name|remote_send
parameter_list|(
name|buf
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'E'
condition|)
name|error
argument_list|(
literal|"Remote failure reply: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Display a null-terminated packet on stdout, for debugging, using C    string notation.  */
end_comment

begin_function
specifier|static
name|void
name|print_packet
parameter_list|(
name|buf
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|puts_filtered
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|buf
condition|)
name|gdb_printchar
argument_list|(
operator|*
name|buf
operator|++
argument_list|,
name|gdb_stdout
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|putpkt
parameter_list|(
name|buf
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
block|{
return|return
name|putpkt_binary
argument_list|(
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Send a packet to the remote machine, with error checking.  The data    of the packet is in BUF.  The string in BUF can be at most  PBUFSIZ - 5    to account for the $, # and checksum, and for a possible /0 if we are    debugging (remote_debug) and want to print the sent packet as a string */
end_comment

begin_function
specifier|static
name|int
name|putpkt_binary
parameter_list|(
name|buf
parameter_list|,
name|cnt
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|cnt
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|csum
init|=
literal|0
decl_stmt|;
name|char
name|buf2
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|int
name|tcount
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Copy the packet into buffer BUF2, encapsulating it      and giving it a checksum.  */
if|if
condition|(
name|cnt
operator|>
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|buf2
argument_list|)
operator|-
literal|5
condition|)
comment|/* Prosanity check */
name|abort
argument_list|()
expr_stmt|;
name|p
operator|=
name|buf2
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'$'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|csum
operator|+=
name|buf
index|[
name|i
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|buf
index|[
name|i
index|]
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
literal|'#'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|tohex
argument_list|(
operator|(
name|csum
operator|>>
literal|4
operator|)
operator|&
literal|0xf
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|tohex
argument_list|(
name|csum
operator|&
literal|0xf
argument_list|)
expr_stmt|;
comment|/* Send it over and over until we get a positive ack.  */
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|started_error_output
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|remote_debug
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"Sending packet: %s..."
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SERIAL_WRITE
argument_list|(
name|remote_desc
argument_list|,
name|buf2
argument_list|,
name|p
operator|-
name|buf2
argument_list|)
condition|)
name|perror_with_name
argument_list|(
literal|"putpkt: write failed"
argument_list|)
expr_stmt|;
comment|/* read until either a timeout occurs (-2) or '+' is read */
while|while
condition|(
literal|1
condition|)
block|{
name|ch
operator|=
name|readchar
argument_list|(
name|remote_timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_debug
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'+'
case|:
case|case
name|SERIAL_TIMEOUT
case|:
case|case
literal|'$'
case|:
if|if
condition|(
name|started_error_output
condition|)
block|{
name|putchar_unfiltered
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|started_error_output
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'+'
case|:
if|if
condition|(
name|remote_debug
condition|)
name|printf_unfiltered
argument_list|(
literal|"Ack\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
case|case
name|SERIAL_TIMEOUT
case|:
name|tcount
operator|++
expr_stmt|;
if|if
condition|(
name|tcount
operator|>
literal|3
condition|)
return|return
literal|0
return|;
break|break;
comment|/* Retransmit buffer */
case|case
literal|'$'
case|:
block|{
name|char
name|junkbuf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
comment|/* It's probably an old response, and we're out of sync. 		 Just gobble up the packet and ignore it.  */
name|getpkt
argument_list|(
name|junkbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
comment|/* Now, go look for + */
block|}
ifdef|#
directive|ifdef
name|REMOTE_CHAT
case|case
literal|'|'
case|:
block|{
if|if
condition|(
operator|!
name|started_error_output
condition|)
continue|continue;
comment|/* else fall through */
block|}
endif|#
directive|endif
comment|/* REMOTE_CHAT */
default|default:
if|if
condition|(
name|remote_debug
condition|)
block|{
if|if
condition|(
operator|!
name|started_error_output
condition|)
block|{
name|started_error_output
operator|=
literal|1
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"putpkt: Junk: "
argument_list|)
expr_stmt|;
block|}
name|putchar_unfiltered
argument_list|(
name|ch
operator|&
literal|0177
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
break|break;
comment|/* Here to retransmit */
block|}
if|#
directive|if
literal|0
comment|/* This is wrong.  If doing a long backtrace, the user should be 	 able to get out next time we call QUIT, without anything as 	 violent as interrupt_query.  If we want to provide a way out of 	 here without getting to the next QUIT, it should be based on 	 hitting ^C twice as in remote_wait.  */
block|if (quit_flag) 	{ 	  quit_flag = 0; 	  interrupt_query (); 	}
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* Come here after finding the start of the frame.  Collect the rest    into BUF, verifying the checksum, length, and handling run-length    compression.  Returns 0 on any error, 1 on success.  */
end_comment

begin_function
specifier|static
name|int
name|read_frame
parameter_list|(
name|buf
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|unsigned
name|char
name|csum
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|;
name|int
name|c
decl_stmt|;
name|csum
operator|=
literal|0
expr_stmt|;
name|bp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|readchar
argument_list|(
name|remote_timeout
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|SERIAL_TIMEOUT
case|:
if|if
condition|(
name|remote_debug
condition|)
name|puts_filtered
argument_list|(
literal|"Timeout in mid-packet, retrying\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|'$'
case|:
if|if
condition|(
name|remote_debug
condition|)
name|puts_filtered
argument_list|(
literal|"Saw new packet start in middle of old one\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* Start a new packet, count retries */
case|case
literal|'#'
case|:
block|{
name|unsigned
name|char
name|pktcsum
decl_stmt|;
operator|*
name|bp
operator|=
literal|'\000'
expr_stmt|;
name|pktcsum
operator|=
name|fromhex
argument_list|(
name|readchar
argument_list|(
name|remote_timeout
argument_list|)
argument_list|)
operator|<<
literal|4
expr_stmt|;
name|pktcsum
operator||=
name|fromhex
argument_list|(
name|readchar
argument_list|(
name|remote_timeout
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|csum
operator|==
name|pktcsum
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|remote_debug
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Bad checksum, sentsum=0x%x, csum=0x%x, buf="
argument_list|,
name|pktcsum
argument_list|,
name|csum
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
case|case
literal|'*'
case|:
comment|/* Run length encoding */
name|csum
operator|+=
name|c
expr_stmt|;
name|c
operator|=
name|readchar
argument_list|(
name|remote_timeout
argument_list|)
expr_stmt|;
name|csum
operator|+=
name|c
expr_stmt|;
name|c
operator|=
name|c
operator|-
literal|' '
operator|+
literal|3
expr_stmt|;
comment|/* Compute repeat count */
if|if
condition|(
name|c
operator|>
literal|0
operator|&&
name|c
operator|<
literal|255
operator|&&
name|bp
operator|+
name|c
operator|-
literal|1
operator|<
name|buf
operator|+
name|PBUFSIZ
operator|-
literal|1
condition|)
block|{
name|memset
argument_list|(
name|bp
argument_list|,
operator|*
operator|(
name|bp
operator|-
literal|1
operator|)
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|c
expr_stmt|;
continue|continue;
block|}
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Repeat count %d too large for buffer: "
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
default|default:
if|if
condition|(
name|bp
operator|<
name|buf
operator|+
name|PBUFSIZ
operator|-
literal|1
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
name|csum
operator|+=
name|c
expr_stmt|;
continue|continue;
block|}
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"Remote packet too long: "
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Read a packet from the remote machine, with error checking, and    store it in BUF.  BUF is expected to be of size PBUFSIZ.  If    FOREVER, wait forever rather than timing out; this is used while    the target is executing user code.  */
end_comment

begin_function
name|void
name|getpkt
parameter_list|(
name|buf
parameter_list|,
name|forever
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|forever
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|int
name|tries
decl_stmt|;
name|int
name|timeout
decl_stmt|;
name|int
name|val
decl_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"timeout"
argument_list|)
expr_stmt|;
if|if
condition|(
name|forever
condition|)
block|{
ifdef|#
directive|ifdef
name|MAINTENANCE_CMDS
name|timeout
operator|=
name|watchdog
operator|>
literal|0
condition|?
name|watchdog
else|:
operator|-
literal|1
expr_stmt|;
else|#
directive|else
name|timeout
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|timeout
operator|=
name|remote_timeout
expr_stmt|;
define|#
directive|define
name|MAX_TRIES
value|3
for|for
control|(
name|tries
operator|=
literal|1
init|;
name|tries
operator|<=
name|MAX_TRIES
condition|;
name|tries
operator|++
control|)
block|{
comment|/* This can loop forever if the remote side sends us characters 	 continuously, but if it pauses, we'll get a zero from readchar 	 because of timeout.  Then we'll count that as a retry.  */
comment|/* Note that we will only wait forever prior to the start of a packet. 	 After that, we expect characters to arrive at a brisk pace.  They 	 should show up within remote_timeout intervals.  */
do|do
block|{
name|c
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|SERIAL_TIMEOUT
condition|)
block|{
ifdef|#
directive|ifdef
name|MAINTENANCE_CMDS
if|if
condition|(
name|forever
condition|)
comment|/* Watchdog went off.  Kill the target. */
block|{
name|target_mourn_inferior
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"Watchdog has expired.  Target detached.\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|remote_debug
condition|)
name|puts_filtered
argument_list|(
literal|"Timed out.\n"
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
do|while
condition|(
name|c
operator|!=
literal|'$'
condition|)
do|;
comment|/* We've found the start of a packet, now collect the data.  */
name|val
operator|=
name|read_frame
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|remote_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdout
argument_list|,
literal|"Packet received: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|SERIAL_WRITE
argument_list|(
name|remote_desc
argument_list|,
literal|"+"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Try the whole thing again.  */
name|retry
label|:
name|SERIAL_WRITE
argument_list|(
name|remote_desc
argument_list|,
literal|"-"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* We have tried hard enough, and just can't receive the packet.  Give up. */
name|printf_unfiltered
argument_list|(
literal|"Ignoring packet error, continuing...\n"
argument_list|)
expr_stmt|;
name|SERIAL_WRITE
argument_list|(
name|remote_desc
argument_list|,
literal|"+"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|remote_kill
parameter_list|()
block|{
comment|/* For some mysterious reason, wait_for_inferior calls kill instead of      mourn after it gets TARGET_WAITKIND_SIGNALLED.  Work around it.  */
if|if
condition|(
name|kill_kludge
condition|)
block|{
name|kill_kludge
operator|=
literal|0
expr_stmt|;
name|target_mourn_inferior
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Use catch_errors so the user can quit from gdb even when we aren't on      speaking terms with the remote system.  */
name|catch_errors
argument_list|(
operator|(
name|catch_errors_ftype
operator|*
operator|)
name|putpkt
argument_list|,
literal|"k"
argument_list|,
literal|""
argument_list|,
name|RETURN_MASK_ERROR
argument_list|)
expr_stmt|;
comment|/* Don't wait for it to die.  I'm not really sure it matters whether      we do or not.  For the existing stubs, kill is a noop.  */
name|target_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|remote_mourn
parameter_list|()
block|{
name|remote_mourn_1
argument_list|(
operator|&
name|remote_ops
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|extended_remote_mourn
parameter_list|()
block|{
comment|/* We do _not_ want to mourn the target like this; this will      remove the extended remote target  from the target stack,      and the next time the user says "run" it'll fail.        FIXME: What is the right thing to do here?  */
if|#
directive|if
literal|0
block|remote_mourn_1 (&extended_remote_ops);
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Worker function for remote_mourn.  */
end_comment

begin_function
specifier|static
name|void
name|remote_mourn_1
parameter_list|(
name|target
parameter_list|)
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
block|{
name|unpush_target
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|generic_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* In the extended protocol we want to be able to do things like    "run" and have them basically work as expected.  So we need    a special create_inferior function.      FIXME: One day add support for changing the exec file    we're debugging, arguments and an environment.  */
end_comment

begin_function
specifier|static
name|void
name|extended_remote_create_inferior
parameter_list|(
name|exec_file
parameter_list|,
name|args
parameter_list|,
name|env
parameter_list|)
name|char
modifier|*
name|exec_file
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
name|char
modifier|*
modifier|*
name|env
decl_stmt|;
block|{
comment|/* Rip out the breakpoints; we'll reinsert them after restarting      the remote server.  */
name|remove_breakpoints
argument_list|()
expr_stmt|;
comment|/* Now restart the remote server.  */
name|extended_remote_restart
argument_list|()
expr_stmt|;
comment|/* Now put the breakpoints back in.  This way we're safe if the      restart function works via a unix fork on the remote side.  */
name|insert_breakpoints
argument_list|()
expr_stmt|;
comment|/* Clean up from the last time we were running.  */
name|clear_proceed_status
argument_list|()
expr_stmt|;
comment|/* Let the remote process run.  */
name|proceed
argument_list|(
operator|-
literal|1
argument_list|,
name|TARGET_SIGNAL_0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* On some machines, e.g. 68k, we may use a different breakpoint instruction    than other targets; in those use REMOTE_BREAKPOINT instead of just    BREAKPOINT.  Also, bi-endian targets may define LITTLE_REMOTE_BREAKPOINT    and BIG_REMOTE_BREAKPOINT.  If none of these are defined, we just call    the standard routines that are in mem-break.c.  */
end_comment

begin_comment
comment|/* FIXME, these ought to be done in a more dynamic fashion.  For instance,    the choice of breakpoint instruction affects target program design and    vice versa, and by making it user-tweakable, the special code here    goes away and we need fewer special GDB configurations.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LITTLE_REMOTE_BREAKPOINT
argument_list|)
operator|&&
name|defined
argument_list|(
name|BIG_REMOTE_BREAKPOINT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|REMOTE_BREAKPOINT
argument_list|)
end_if

begin_define
define|#
directive|define
name|REMOTE_BREAKPOINT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|REMOTE_BREAKPOINT
end_ifdef

begin_comment
comment|/* If the target isn't bi-endian, just pretend it is.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LITTLE_REMOTE_BREAKPOINT
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|BIG_REMOTE_BREAKPOINT
argument_list|)
end_if

begin_define
define|#
directive|define
name|LITTLE_REMOTE_BREAKPOINT
value|REMOTE_BREAKPOINT
end_define

begin_define
define|#
directive|define
name|BIG_REMOTE_BREAKPOINT
value|REMOTE_BREAKPOINT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|big_break_insn
index|[]
init|=
name|BIG_REMOTE_BREAKPOINT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|little_break_insn
index|[]
init|=
name|LITTLE_REMOTE_BREAKPOINT
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* REMOTE_BREAKPOINT */
end_comment

begin_comment
comment|/* Insert a breakpoint on targets that don't have any better breakpoint    support.  We read the contents of the target location and stash it,    then overwrite it with a breakpoint instruction.  ADDR is the target    location in the target machine.  CONTENTS_CACHE is a pointer to     memory allocated for saving the target contents.  It is guaranteed    by the caller to be long enough to save sizeof BREAKPOINT bytes (this    is accomplished via BREAKPOINT_MAX).  */
end_comment

begin_function
specifier|static
name|int
name|remote_insert_breakpoint
parameter_list|(
name|addr
parameter_list|,
name|contents_cache
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|contents_cache
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|REMOTE_BREAKPOINT
name|int
name|val
decl_stmt|;
name|val
operator|=
name|target_read_memory
argument_list|(
name|addr
argument_list|,
name|contents_cache
argument_list|,
sizeof|sizeof
name|big_break_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BIG_ENDIAN
condition|)
name|val
operator|=
name|target_write_memory
argument_list|(
name|addr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|big_break_insn
argument_list|,
sizeof|sizeof
name|big_break_insn
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|target_write_memory
argument_list|(
name|addr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|little_break_insn
argument_list|,
sizeof|sizeof
name|little_break_insn
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
else|#
directive|else
return|return
name|memory_insert_breakpoint
argument_list|(
name|addr
argument_list|,
name|contents_cache
argument_list|)
return|;
endif|#
directive|endif
comment|/* REMOTE_BREAKPOINT */
block|}
end_function

begin_function
specifier|static
name|int
name|remote_remove_breakpoint
parameter_list|(
name|addr
parameter_list|,
name|contents_cache
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|contents_cache
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|REMOTE_BREAKPOINT
return|return
name|target_write_memory
argument_list|(
name|addr
argument_list|,
name|contents_cache
argument_list|,
sizeof|sizeof
name|big_break_insn
argument_list|)
return|;
else|#
directive|else
return|return
name|memory_remove_breakpoint
argument_list|(
name|addr
argument_list|,
name|contents_cache
argument_list|)
return|;
endif|#
directive|endif
comment|/* REMOTE_BREAKPOINT */
block|}
end_function

begin_comment
comment|/* Some targets are only capable of doing downloads, and afterwards    they switch to the remote serial protocol.  This function provides    a clean way to get from the download target to the remote target.    It's basically just a wrapper so that we don't have to expose any    of the internal workings of remote.c.     Prior to calling this routine, you should shutdown the current    target code, else you will get the "A program is being debugged    already..." message.  Usually a call to pop_target() suffices.  */
end_comment

begin_function
name|void
name|push_remote_target
parameter_list|(
name|name
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|printf_filtered
argument_list|(
literal|"Switching to remote protocol\n"
argument_list|)
expr_stmt|;
name|remote_open
argument_list|(
name|name
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Other targets want to use the entire remote serial module but with    certain remote_ops overridden. */
end_comment

begin_function
name|void
name|open_remote_target
parameter_list|(
name|name
parameter_list|,
name|from_tty
parameter_list|,
name|target
parameter_list|,
name|extended_p
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
name|int
name|extended_p
decl_stmt|;
block|{
name|printf_filtered
argument_list|(
literal|"Selecting the %sremote protocol\n"
argument_list|,
operator|(
name|extended_p
condition|?
literal|"extended-"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|remote_open_1
argument_list|(
name|name
argument_list|,
name|from_tty
argument_list|,
name|target
argument_list|,
name|extended_p
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Table used by the crc32 function to calcuate the checksum. */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|crc32_table
index|[
literal|256
index|]
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|unsigned
name|long
name|crc32
parameter_list|(
name|buf
parameter_list|,
name|len
parameter_list|,
name|crc
parameter_list|)
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
name|unsigned
name|int
name|crc
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|crc32_table
index|[
literal|1
index|]
condition|)
block|{
comment|/* Initialize the CRC table and the decoding table. */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|c
operator|=
name|i
operator|<<
literal|24
operator|,
name|j
operator|=
literal|8
init|;
name|j
operator|>
literal|0
condition|;
operator|--
name|j
control|)
name|c
operator|=
name|c
operator|&
literal|0x80000000
condition|?
operator|(
name|c
operator|<<
literal|1
operator|)
operator|^
literal|0x04c11db7
else|:
operator|(
name|c
operator|<<
literal|1
operator|)
expr_stmt|;
name|crc32_table
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
block|}
block|}
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|crc
operator|=
operator|(
name|crc
operator|<<
literal|8
operator|)
operator|^
name|crc32_table
index|[
operator|(
operator|(
name|crc
operator|>>
literal|24
operator|)
operator|^
operator|*
name|buf
operator|)
operator|&
literal|255
index|]
expr_stmt|;
name|buf
operator|++
expr_stmt|;
block|}
return|return
name|crc
return|;
block|}
end_function

begin_comment
comment|/* compare-sections command     With no arguments, compares each loadable section in the exec bfd    with the same memory range on the target, and reports mismatches.    Useful for verifying the image on the target against the exec file.    Depends on the target understanding the new "qCRC:" request.  */
end_comment

begin_function
specifier|static
name|void
name|compare_sections_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|asection
modifier|*
name|s
decl_stmt|;
name|unsigned
name|long
name|host_crc
decl_stmt|,
name|target_crc
decl_stmt|;
specifier|extern
name|bfd
modifier|*
name|exec_bfd
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|sectdata
decl_stmt|,
modifier|*
name|sectname
decl_stmt|,
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|bfd_vma
name|lma
decl_stmt|;
name|int
name|matched
init|=
literal|0
decl_stmt|;
name|int
name|mismatched
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|exec_bfd
condition|)
name|error
argument_list|(
literal|"command cannot be used without an exec file"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|current_target
operator|.
name|to_shortname
operator|||
name|strcmp
argument_list|(
name|current_target
operator|.
name|to_shortname
argument_list|,
literal|"remote"
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"command can only be used with remote target"
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|exec_bfd
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
condition|)
continue|continue;
comment|/* skip non-loadable section */
name|size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
continue|continue;
comment|/* skip zero-length section */
name|sectname
operator|=
operator|(
name|char
operator|*
operator|)
name|bfd_get_section_name
argument_list|(
name|exec_bfd
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|&&
name|strcmp
argument_list|(
name|args
argument_list|,
name|sectname
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* not the section selected by user */
name|matched
operator|=
literal|1
expr_stmt|;
comment|/* do this section */
name|lma
operator|=
name|s
operator|->
name|lma
expr_stmt|;
comment|/* FIXME: assumes lma can fit into long */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"qCRC:%lx,%lx"
argument_list|,
operator|(
name|long
operator|)
name|lma
argument_list|,
operator|(
name|long
operator|)
name|size
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* be clever; compute the host_crc before waiting for target reply */
name|sectdata
operator|=
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|sectdata
argument_list|)
expr_stmt|;
name|bfd_get_section_contents
argument_list|(
name|exec_bfd
argument_list|,
name|s
argument_list|,
name|sectdata
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|host_crc
operator|=
name|crc32
argument_list|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|sectdata
argument_list|,
name|size
argument_list|,
literal|0xffffffff
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'E'
condition|)
name|error
argument_list|(
literal|"target memory fault, section %s, range 0x%08x -- 0x%08x"
argument_list|,
name|sectname
argument_list|,
name|lma
argument_list|,
name|lma
operator|+
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'C'
condition|)
name|error
argument_list|(
literal|"remote target does not support this operation"
argument_list|)
expr_stmt|;
for|for
control|(
name|target_crc
operator|=
literal|0
operator|,
name|tmp
operator|=
operator|&
name|buf
index|[
literal|1
index|]
init|;
operator|*
name|tmp
condition|;
name|tmp
operator|++
control|)
name|target_crc
operator|=
name|target_crc
operator|*
literal|16
operator|+
name|fromhex
argument_list|(
operator|*
name|tmp
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Section %s, range 0x%08x -- 0x%08x: "
argument_list|,
name|sectname
argument_list|,
name|lma
argument_list|,
name|lma
operator|+
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|host_crc
operator|==
name|target_crc
condition|)
name|printf_filtered
argument_list|(
literal|"matched.\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|printf_filtered
argument_list|(
literal|"MIS-MATCHED!\n"
argument_list|)
expr_stmt|;
name|mismatched
operator|++
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mismatched
operator|>
literal|0
condition|)
name|warning
argument_list|(
literal|"One or more sections of the remote executable does not match\n\ the loaded file\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|&&
operator|!
name|matched
condition|)
name|printf_filtered
argument_list|(
literal|"No loaded section named '%s'.\n"
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|remote_query
parameter_list|(
name|query_type
parameter_list|,
name|buf
parameter_list|,
name|outbuf
parameter_list|,
name|bufsiz
parameter_list|)
name|int
name|query_type
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|outbuf
decl_stmt|;
name|int
modifier|*
name|bufsiz
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
name|buf2
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|p2
init|=
operator|&
name|buf2
index|[
literal|0
index|]
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
if|if
condition|(
operator|!
name|bufsiz
condition|)
name|error
argument_list|(
literal|"null pointer to remote bufer size specified"
argument_list|)
expr_stmt|;
comment|/* minimum outbuf size is PBUFSIZE - if bufsiz is not large enough let       the caller know and return what the minimum size is   */
comment|/* Note: a zero bufsiz can be used to query the minimum buffer size */
if|if
condition|(
operator|*
name|bufsiz
operator|<
name|PBUFSIZ
condition|)
block|{
operator|*
name|bufsiz
operator|=
name|PBUFSIZ
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* except for querying the minimum buffer size, target must be open */
if|if
condition|(
operator|!
name|remote_desc
condition|)
name|error
argument_list|(
literal|"remote query is only available after target open"
argument_list|)
expr_stmt|;
comment|/* we only take uppercase letters as query types, at least for now */
if|if
condition|(
operator|(
name|query_type
operator|<
literal|'A'
operator|)
operator|||
operator|(
name|query_type
operator|>
literal|'Z'
operator|)
condition|)
name|error
argument_list|(
literal|"invalid remote query type"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
name|error
argument_list|(
literal|"null remote query specified"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outbuf
condition|)
name|error
argument_list|(
literal|"remote query requires a buffer to receive data"
argument_list|)
expr_stmt|;
name|outbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|p2
operator|++
operator|=
literal|'q'
expr_stmt|;
operator|*
name|p2
operator|++
operator|=
name|query_type
expr_stmt|;
comment|/* we used one buffer char for the remote protocol q command and another      for the query type.  As the remote protocol encapsulation uses 4 chars      plus one extra in case we are debugging (remote_debug),      we have PBUFZIZ - 7 left to pack the query string */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|buf
index|[
name|i
index|]
operator|&&
operator|(
name|i
operator|<
operator|(
name|PBUFSIZ
operator|-
literal|8
operator|)
operator|)
condition|)
block|{
comment|/* bad caller may have sent forbidden characters */
if|if
condition|(
operator|(
operator|!
name|isprint
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
operator|)
operator|||
operator|(
name|buf
index|[
name|i
index|]
operator|==
literal|'$'
operator|)
operator|||
operator|(
name|buf
index|[
name|i
index|]
operator|==
literal|'#'
operator|)
condition|)
name|error
argument_list|(
literal|"illegal characters in query string"
argument_list|)
expr_stmt|;
operator|*
name|p2
operator|++
operator|=
name|buf
index|[
name|i
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
operator|*
name|p2
operator|=
name|buf
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|buf
index|[
name|i
index|]
condition|)
name|error
argument_list|(
literal|"query larger than available buffer"
argument_list|)
expr_stmt|;
name|i
operator|=
name|putpkt
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
name|i
return|;
name|getpkt
argument_list|(
name|outbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|packet_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|remote_desc
condition|)
name|error
argument_list|(
literal|"command can only be used with remote target"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
name|error
argument_list|(
literal|"remote-packet command requires packet text as argument"
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"sending: "
argument_list|)
expr_stmt|;
name|print_packet
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"received: "
argument_list|)
expr_stmt|;
name|print_packet
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* --------- UNIT_TEST for THREAD oriented PACKETS ------------------------- */
end_comment

begin_define
unit|static void display_thread_info PARAMS ((struct gdb_ext_thread_info *info));  static void threadset_test_cmd PARAMS ((char *cmd, int tty));  static void threadalive_test PARAMS ((char *cmd, int tty));  static void threadlist_test_cmd PARAMS ((char *cmd, int tty));  int get_and_display_threadinfo PARAMS ((threadref *ref));  static void threadinfo_test_cmd PARAMS ((char *cmd, int tty));  static int thread_display_step PARAMS ((threadref *ref, void *context));  static void threadlist_update_test_cmd PARAMS ((char *cmd, int tty));  static void init_remote_threadtests PARAMS ((void));
define|#
directive|define
name|SAMPLE_THREAD
value|0x05060708
end_define

begin_comment
comment|/* Truncated 64 bit threadid */
end_comment

begin_comment
unit|static void threadset_test_cmd (cmd, tty)      char *cmd;      int tty; {   int sample_thread = SAMPLE_THREAD;    printf_filtered ("Remote threadset test\n");   set_thread (sample_thread, 1); }   static void threadalive_test (cmd, tty)      char *cmd;      int tty; {   int sample_thread = SAMPLE_THREAD;    if (remote_thread_alive (sample_thread))     printf_filtered ("PASS: Thread alive test\n");   else     printf_filtered ("FAIL: Thread alive test\n"); }  void output_threadid PARAMS ((char *title, threadref * ref));  void output_threadid (title, ref)      char *title;      threadref *ref; {   char hexid[20];    pack_threadid (&hexid[0], ref);
comment|/* Convert threead id into hex */
end_comment

begin_comment
unit|hexid[16] = 0;   printf_filtered ("%s  %s\n", title, (&hexid[0])); }  static void threadlist_test_cmd (cmd, tty)      char *cmd;      int tty; {   int startflag = 1;   threadref nextthread;   int done, result_count;   threadref threadlist[3];    printf_filtered ("Remote Threadlist test\n");   if (!remote_get_threadlist (startflag,&nextthread, 3,&done,&result_count,&threadlist[0]))     printf_filtered ("FAIL: threadlist test\n");   else     {       threadref *scan = threadlist;       threadref *limit = scan + result_count;        while (scan< limit) 	output_threadid (" thread ", scan++);     } }  void display_thread_info (info)      struct gdb_ext_thread_info *info; {   output_threadid ("Threadid: ",&info->threadid);   printf_filtered ("Name: %s\n ", info->shortname);   printf_filtered ("State: %s\n", info->display);   printf_filtered ("other: %s\n\n", info->more_display); }  int get_and_display_threadinfo (ref)      threadref *ref; {   int result;   int set;   struct gdb_ext_thread_info threadinfo;    set = TAG_THREADID | TAG_EXISTS | TAG_THREADNAME     | TAG_MOREDISPLAY | TAG_DISPLAY;   if (0 != (result = remote_get_threadinfo (ref, set,&threadinfo)))     display_thread_info (&threadinfo);   return result; }  static void threadinfo_test_cmd (cmd, tty)      char *cmd;      int tty; {   int athread = SAMPLE_THREAD;   threadref thread;   int set;    int_to_threadref (&thread, athread);   printf_filtered ("Remote Threadinfo test\n");   if (!get_and_display_threadinfo (&thread))     printf_filtered ("FAIL cannot get thread info\n"); }  static int thread_display_step (ref, context)      threadref *ref;      void *context; {
comment|/* output_threadid(" threadstep ",ref); */
end_comment

begin_comment
comment|/* simple test */
end_comment

begin_endif
unit|return get_and_display_threadinfo (ref); }  static void threadlist_update_test_cmd (cmd, tty)      char *cmd;      int tty; {   printf_filtered ("Remote Threadlist update test\n");   remote_threadlist_iterator (thread_display_step, 0, CRAZY_MAX_THREADS); }  static void init_remote_threadtests (void) {   add_com ("tlist", class_obscure, threadlist_test_cmd,      "Fetch and print the remote list of thread identifiers, one pkt only");   add_com ("tinfo", class_obscure, threadinfo_test_cmd, 	   "Fetch and display info about one thread");   add_com ("tset", class_obscure, threadset_test_cmd, 	   "Test setting to a different thread");   add_com ("tupd", class_obscure, threadlist_update_test_cmd, 	   "Iterate through updating all remote thread info");   add_com ("talive", class_obscure, threadalive_test, 	   " Remote thread alive test "); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_function
specifier|static
name|void
name|init_remote_ops
parameter_list|()
block|{
name|remote_ops
operator|.
name|to_shortname
operator|=
literal|"remote"
expr_stmt|;
name|remote_ops
operator|.
name|to_longname
operator|=
literal|"Remote serial target in gdb-specific protocol"
expr_stmt|;
name|remote_ops
operator|.
name|to_doc
operator|=
literal|"Use a remote computer via a serial line, using a gdb-specific protocol.\n\ Specify the serial device it is connected to (e.g. /dev/ttya)."
expr_stmt|;
name|remote_ops
operator|.
name|to_open
operator|=
name|remote_open
expr_stmt|;
name|remote_ops
operator|.
name|to_close
operator|=
name|remote_close
expr_stmt|;
name|remote_ops
operator|.
name|to_detach
operator|=
name|remote_detach
expr_stmt|;
name|remote_ops
operator|.
name|to_resume
operator|=
name|remote_resume
expr_stmt|;
name|remote_ops
operator|.
name|to_wait
operator|=
name|remote_wait
expr_stmt|;
name|remote_ops
operator|.
name|to_fetch_registers
operator|=
name|remote_fetch_registers
expr_stmt|;
name|remote_ops
operator|.
name|to_store_registers
operator|=
name|remote_store_registers
expr_stmt|;
name|remote_ops
operator|.
name|to_prepare_to_store
operator|=
name|remote_prepare_to_store
expr_stmt|;
name|remote_ops
operator|.
name|to_xfer_memory
operator|=
name|remote_xfer_memory
expr_stmt|;
name|remote_ops
operator|.
name|to_files_info
operator|=
name|remote_files_info
expr_stmt|;
name|remote_ops
operator|.
name|to_insert_breakpoint
operator|=
name|remote_insert_breakpoint
expr_stmt|;
name|remote_ops
operator|.
name|to_remove_breakpoint
operator|=
name|remote_remove_breakpoint
expr_stmt|;
name|remote_ops
operator|.
name|to_kill
operator|=
name|remote_kill
expr_stmt|;
name|remote_ops
operator|.
name|to_load
operator|=
name|generic_load
expr_stmt|;
name|remote_ops
operator|.
name|to_mourn_inferior
operator|=
name|remote_mourn
expr_stmt|;
name|remote_ops
operator|.
name|to_thread_alive
operator|=
name|remote_thread_alive
expr_stmt|;
name|remote_ops
operator|.
name|to_stop
operator|=
name|remote_stop
expr_stmt|;
name|remote_ops
operator|.
name|to_query
operator|=
name|remote_query
expr_stmt|;
name|remote_ops
operator|.
name|to_stratum
operator|=
name|process_stratum
expr_stmt|;
name|remote_ops
operator|.
name|to_has_all_memory
operator|=
literal|1
expr_stmt|;
name|remote_ops
operator|.
name|to_has_memory
operator|=
literal|1
expr_stmt|;
name|remote_ops
operator|.
name|to_has_stack
operator|=
literal|1
expr_stmt|;
name|remote_ops
operator|.
name|to_has_registers
operator|=
literal|1
expr_stmt|;
name|remote_ops
operator|.
name|to_has_execution
operator|=
literal|1
expr_stmt|;
name|remote_ops
operator|.
name|to_has_thread_control
operator|=
name|tc_schedlock
expr_stmt|;
comment|/* can lock scheduler */
name|remote_ops
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set up the extended remote vector by making a copy of the standard    remote vector and adding to it.  */
end_comment

begin_function
specifier|static
name|void
name|init_extended_remote_ops
parameter_list|()
block|{
name|extended_remote_ops
operator|=
name|remote_ops
expr_stmt|;
name|extended_remote_ops
operator|.
name|to_shortname
operator|=
literal|"extended-remote"
expr_stmt|;
name|extended_remote_ops
operator|.
name|to_longname
operator|=
literal|"Extended remote serial target in gdb-specific protocol"
expr_stmt|;
name|extended_remote_ops
operator|.
name|to_doc
operator|=
literal|"Use a remote computer via a serial line, using a gdb-specific protocol.\n\ Specify the serial device it is connected to (e.g. /dev/ttya)."
operator|,
name|extended_remote_ops
operator|.
name|to_open
operator|=
name|extended_remote_open
expr_stmt|;
name|extended_remote_ops
operator|.
name|to_create_inferior
operator|=
name|extended_remote_create_inferior
expr_stmt|;
name|extended_remote_ops
operator|.
name|to_mourn_inferior
operator|=
name|extended_remote_mourn
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_remote
parameter_list|()
block|{
name|init_remote_ops
argument_list|()
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|remote_ops
argument_list|)
expr_stmt|;
name|init_extended_remote_ops
argument_list|()
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|extended_remote_ops
argument_list|)
expr_stmt|;
name|init_remote_threads
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
block|init_remote_threadtests ();
endif|#
directive|endif
name|add_cmd
argument_list|(
literal|"compare-sections"
argument_list|,
name|class_obscure
argument_list|,
name|compare_sections_command
argument_list|,
literal|"Compare section data on target to the exec file.\n\ Argument is a single section name (default: all loaded sections)."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"packet"
argument_list|,
name|class_maintenance
argument_list|,
name|packet_command
argument_list|,
literal|"Send an arbitrary packet to a remote target.\n\    maintenance packet TEXT\n\ If GDB is talking to an inferior via the GDB serial protocol, then\n\ this command sends the string TEXT to the inferior, and displays the\n\ response packet.  GDB supplies the initial `$' character, and the\n\ terminating `#' character and checksum."
argument_list|,
operator|&
name|maintenancelist
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REMOTE_CHAT
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"remotechat"
argument_list|,
name|no_class
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|remote_chat
argument_list|,
literal|"Set remote port interacts with target.\n"
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* REMOTE_CHAT */
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"remotetimeout"
argument_list|,
name|no_class
argument_list|,
name|var_integer
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|remote_timeout
argument_list|,
literal|"Set timeout value for remote read.\n"
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"remotebreak"
argument_list|,
name|no_class
argument_list|,
name|var_integer
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|remote_break
argument_list|,
literal|"Set whether to send break if interrupted.\n"
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"remotewritesize"
argument_list|,
name|no_class
argument_list|,
name|var_integer
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|remote_write_size
argument_list|,
literal|"Set the maximum number of bytes per memory write packet.\n"
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|remote_address_size
operator|=
name|TARGET_PTR_BIT
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"remoteaddresssize"
argument_list|,
name|class_obscure
argument_list|,
name|var_integer
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|remote_address_size
argument_list|,
literal|"Set the maximum size of the address (in bits) \ in a memory packet.\n"
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"remotebinarydownload"
argument_list|,
name|no_class
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|remote_binary_download
argument_list|,
literal|"Set binary downloads.\n"
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

