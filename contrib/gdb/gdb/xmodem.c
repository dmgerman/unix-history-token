begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* XMODEM support for GDB, the GNU debugger.    Copyright 1995 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"xmodem.h"
end_include

begin_comment
comment|/* These definitions are for xmodem protocol. */
end_comment

begin_define
define|#
directive|define
name|SOH
value|0x01
end_define

begin_define
define|#
directive|define
name|STX
value|0x02
end_define

begin_define
define|#
directive|define
name|ACK
value|0x06
end_define

begin_define
define|#
directive|define
name|NAK
value|0x15
end_define

begin_define
define|#
directive|define
name|EOT
value|0x04
end_define

begin_define
define|#
directive|define
name|CANCEL
value|0x18
end_define

begin_decl_stmt
specifier|static
name|int
name|blknum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XMODEM block number */
end_comment

begin_decl_stmt
specifier|static
name|int
name|crcflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Sez we are using CRC's instead of cksums */
end_comment

begin_function
specifier|static
name|int
name|readchar
parameter_list|(
name|desc
parameter_list|,
name|timeout
parameter_list|)
name|serial_t
name|desc
decl_stmt|;
name|int
name|timeout
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
name|SERIAL_READCHAR
argument_list|(
name|desc
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_debug
operator|>
literal|0
condition|)
name|fputc_unfiltered
argument_list|(
name|c
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|0
condition|)
return|return
name|c
return|;
if|if
condition|(
name|c
operator|==
name|SERIAL_TIMEOUT
condition|)
name|error
argument_list|(
literal|"Timeout reading from remote system."
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
literal|"xmodem.c:readchar()"
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|CRC16
value|0x1021
end_define

begin_comment
comment|/* Generator polynomial (X^16 + X^12 + X^5 + 1) */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|short
modifier|*
name|crctab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Call this to init the fast CRC-16 calculation table.  */
end_comment

begin_function
specifier|static
name|void
name|crcinit
parameter_list|()
block|{
specifier|static
name|int
name|crctab_inited
init|=
literal|0
decl_stmt|;
name|int
name|val
decl_stmt|;
if|if
condition|(
name|crctab_inited
operator|==
literal|1
condition|)
return|return;
name|crctab
operator|=
name|xmalloc
argument_list|(
literal|256
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|val
operator|=
literal|0
init|;
name|val
operator|<=
literal|255
condition|;
name|val
operator|++
control|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|crc
decl_stmt|;
name|crc
operator|=
name|val
operator|<<
literal|8
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
operator|++
name|i
control|)
block|{
name|crc
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|crc
operator|&
literal|0x10000
condition|)
name|crc
operator|^=
name|CRC16
expr_stmt|;
block|}
name|crctab
index|[
name|val
index|]
operator|=
name|crc
expr_stmt|;
block|}
name|crctab_inited
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Calculate a CRC-16 for the LEN byte message pointed at by P.  */
end_comment

begin_function
specifier|static
name|unsigned
name|short
name|docrc
parameter_list|(
name|p
parameter_list|,
name|len
parameter_list|)
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|unsigned
name|short
name|crc
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
name|crc
operator|=
operator|(
name|crc
operator|<<
literal|8
operator|)
operator|^
name|crctab
index|[
operator|(
name|crc
operator|>>
literal|8
operator|)
operator|^
operator|*
name|p
operator|++
index|]
expr_stmt|;
return|return
name|crc
return|;
block|}
end_function

begin_comment
comment|/* Start up the transmit process.  Reset state variables.  Wait for receiver to    send NAK or CRC request.  */
end_comment

begin_function
name|int
name|xmodem_init_xfer
parameter_list|(
name|desc
parameter_list|)
name|serial_t
name|desc
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|blknum
operator|=
literal|1
expr_stmt|;
name|crcflag
operator|=
literal|0
expr_stmt|;
name|crcinit
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|readchar
argument_list|(
name|desc
argument_list|,
literal|6
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'C'
case|:
name|crcflag
operator|=
literal|1
expr_stmt|;
case|case
name|NAK
case|:
return|return
literal|0
return|;
default|default:
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"xmodem_init_xfer: Got unexpected character %c (0%o)\n"
argument_list|,
name|c
argument_list|,
name|c
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|CANCEL
case|:
comment|/* target aborted load */
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Got a CANCEL from the target.\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|error
argument_list|(
literal|"xmodem_init_xfer:  Too many unexpected characters."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Take 128 bytes of data and make a packet out of it.  *  *	Each packet looks like this:  *	+-----+-------+-------+------+-----+  *	| SOH | Seq1. | Seq2. | data | SUM |  *	+-----+-------+-------+------+-----+  *	SOH  = 0x01  *	Seq1 = The sequence number.  *	Seq2 = The complement of the sequence number.  *	Data = A 128 bytes of data.  *	SUM  = Add the contents of the 128 bytes and use the low-order  *	       8 bits of the result.  *  * send_xmodem_packet fills in the XMODEM fields of PACKET and sends it to the  * remote system.  PACKET must be XMODEM_PACKETSIZE bytes long.  The data must  * start 3 bytes after the beginning of the packet to leave room for the  * XMODEM header.  LEN is the length of the data portion of the packet (and  * must be<= 128 bytes).  If it is< 128 bytes, ^Z padding will be added.  */
end_comment

begin_function
name|void
name|xmodem_send_packet
parameter_list|(
name|desc
parameter_list|,
name|packet
parameter_list|,
name|len
parameter_list|,
name|hashmark
parameter_list|)
name|serial_t
name|desc
decl_stmt|;
name|unsigned
name|char
modifier|*
name|packet
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|hashmark
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|retries
decl_stmt|;
name|int
name|pktlen
decl_stmt|;
name|int
name|datasize
decl_stmt|;
comment|/* build the packet header */
name|packet
index|[
literal|1
index|]
operator|=
name|blknum
expr_stmt|;
name|packet
index|[
literal|2
index|]
operator|=
operator|~
name|blknum
expr_stmt|;
name|blknum
operator|++
expr_stmt|;
if|if
condition|(
name|len
operator|<=
name|XMODEM_DATASIZE
condition|)
block|{
name|packet
index|[
literal|0
index|]
operator|=
name|SOH
expr_stmt|;
name|datasize
operator|=
name|XMODEM_DATASIZE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|len
operator|<=
name|XMODEM_1KDATASIZE
condition|)
block|{
name|packet
index|[
literal|0
index|]
operator|=
name|STX
expr_stmt|;
name|datasize
operator|=
name|XMODEM_1KDATASIZE
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Packet way too large */
comment|/* Add ^Z padding if packet< 128 (or 1024) bytes */
name|memset
argument_list|(
name|packet
operator|+
literal|3
operator|+
name|len
argument_list|,
literal|'\026'
argument_list|,
name|datasize
operator|-
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|crcflag
condition|)
block|{
name|int
name|crc
decl_stmt|;
name|crc
operator|=
name|docrc
argument_list|(
name|packet
operator|+
literal|3
argument_list|,
name|datasize
argument_list|)
expr_stmt|;
name|packet
index|[
literal|3
operator|+
name|datasize
index|]
operator|=
name|crc
operator|>>
literal|8
expr_stmt|;
name|packet
index|[
literal|3
operator|+
name|datasize
operator|+
literal|1
index|]
operator|=
name|crc
expr_stmt|;
name|pktlen
operator|=
name|datasize
operator|+
literal|5
expr_stmt|;
block|}
else|else
block|{
name|int
name|sum
decl_stmt|;
name|sum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|3
init|;
name|i
operator|<
name|datasize
operator|+
literal|3
condition|;
name|i
operator|++
control|)
name|sum
operator|+=
name|packet
index|[
name|i
index|]
expr_stmt|;
name|packet
index|[
literal|3
operator|+
name|datasize
index|]
operator|=
name|sum
expr_stmt|;
comment|/* add the checksum */
name|pktlen
operator|=
name|datasize
operator|+
literal|4
expr_stmt|;
block|}
for|for
control|(
name|retries
operator|=
literal|3
init|;
name|retries
operator|>=
literal|0
condition|;
name|retries
operator|--
control|)
block|{
name|int
name|c
decl_stmt|;
name|SERIAL_WRITE
argument_list|(
name|desc
argument_list|,
name|packet
argument_list|,
name|pktlen
argument_list|)
expr_stmt|;
name|c
operator|=
name|readchar
argument_list|(
name|desc
argument_list|,
literal|3
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|ACK
case|:
return|return;
case|case
name|NAK
case|:
if|if
condition|(
operator|!
name|hashmark
condition|)
continue|continue;
name|putchar_unfiltered
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|CANCEL
case|:
name|error
argument_list|(
literal|"xmodem_send_packet: Transfer aborted by receiver."
argument_list|)
expr_stmt|;
default|default:
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"xmodem_send_packet: Got unexpected character %c (0%o)\n"
argument_list|,
name|c
argument_list|,
name|c
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|SERIAL_WRITE
argument_list|(
name|desc
argument_list|,
literal|"\004"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Send an EOT */
name|error
argument_list|(
literal|"xmodem_send_packet:  Excessive retries."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Finish off the transfer.  Send out the EOT, and wait for an ACK.  */
end_comment

begin_function
name|void
name|xmodem_finish_xfer
parameter_list|(
name|desc
parameter_list|)
name|serial_t
name|desc
decl_stmt|;
block|{
name|int
name|retries
decl_stmt|;
for|for
control|(
name|retries
operator|=
literal|10
init|;
name|retries
operator|>=
literal|0
condition|;
name|retries
operator|--
control|)
block|{
name|int
name|c
decl_stmt|;
name|SERIAL_WRITE
argument_list|(
name|desc
argument_list|,
literal|"\004"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Send an EOT */
name|c
operator|=
name|readchar
argument_list|(
name|desc
argument_list|,
literal|3
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|ACK
case|:
return|return;
case|case
name|NAK
case|:
continue|continue;
case|case
name|CANCEL
case|:
name|error
argument_list|(
literal|"xmodem_finish_xfer: Transfer aborted by receiver."
argument_list|)
expr_stmt|;
default|default:
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"xmodem_send_packet: Got unexpected character %c (0%o)\n"
argument_list|,
name|c
argument_list|,
name|c
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|error
argument_list|(
literal|"xmodem_finish_xfer:  Excessive retries."
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

