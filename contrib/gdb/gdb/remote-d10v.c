begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Remote target communications for d10v connected via a serial line.    Copyright 1988, 1991, 1992, 1993, 1994, 1995, 1996, 1997 Free    Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_comment
comment|/*#include "terminal.h"*/
end_comment

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdb-stabs.h"
end_include

begin_include
include|#
directive|include
file|"gdbthread.h"
end_include

begin_include
include|#
directive|include
file|"dcache.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_decl_stmt
specifier|static
name|void
name|remote_d10v_open
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|name
operator|,
name|int
name|from_tty
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define the target subroutine names */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|target_ops
name|remote_d10v_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Open a connection to a remote debugger.    NAME is the filename used for communication.  */
end_comment

begin_function
specifier|static
name|void
name|remote_d10v_open
parameter_list|(
name|name
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|pop_target
argument_list|()
expr_stmt|;
name|push_remote_target
argument_list|(
name|name
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Translate a GDB virtual ADDR/LEN into a format the remote target    understands.  Returns number of bytes that can be transfered    starting at taddr, ZERO if no bytes can be transfered. */
end_comment

begin_function
name|int
name|remote_d10v_translate_xfer_address
parameter_list|(
name|memaddr
parameter_list|,
name|nr_bytes
parameter_list|,
name|taddr
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|int
name|nr_bytes
decl_stmt|;
name|CORE_ADDR
modifier|*
name|taddr
decl_stmt|;
block|{
name|CORE_ADDR
name|phys
decl_stmt|;
name|CORE_ADDR
name|seg
decl_stmt|;
name|CORE_ADDR
name|off
decl_stmt|;
name|char
modifier|*
name|from
init|=
literal|"unknown"
decl_stmt|;
name|char
modifier|*
name|to
init|=
literal|"unknown"
decl_stmt|;
name|unsigned
name|short
name|imap0
init|=
name|read_register
argument_list|(
name|IMAP0_REGNUM
argument_list|)
decl_stmt|;
name|unsigned
name|short
name|imap1
init|=
name|read_register
argument_list|(
name|IMAP1_REGNUM
argument_list|)
decl_stmt|;
name|unsigned
name|short
name|dmap
init|=
name|read_register
argument_list|(
name|DMAP_REGNUM
argument_list|)
decl_stmt|;
comment|/* GDB interprets addresses as:         0x00xxxxxx: Logical data address segment        (DMAP translated memory)        0x01xxxxxx: Logical instruction address segment (IMAP translated memory)        0x10xxxxxx: Physical data memory segment        (On-chip data memory)        0x11xxxxxx: Physical instruction memory segment (On-chip insn memory)        0x12xxxxxx: Phisical unified memory segment     (Unified memory)       The remote d10v board interprets addresses as:         0x00xxxxxx: Phisical unified memory segment     (Unified memory)        0x01xxxxxx: Physical instruction memory segment (On-chip insn memory)        0x02xxxxxx: Physical data memory segment        (On-chip data memory)       Translate according to current IMAP/dmap registers */
enum|enum
block|{
name|targ_unified
init|=
literal|0x00000000
block|,
name|targ_insn
init|=
literal|0x01000000
block|,
name|targ_data
init|=
literal|0x02000000
block|,   }
enum|;
name|seg
operator|=
operator|(
name|memaddr
operator|>>
literal|24
operator|)
expr_stmt|;
name|off
operator|=
operator|(
name|memaddr
operator|&
literal|0xffffffL
operator|)
expr_stmt|;
switch|switch
condition|(
name|seg
condition|)
block|{
case|case
literal|0x00
case|:
comment|/* in logical data address segment */
block|{
name|from
operator|=
literal|"logical-data"
expr_stmt|;
if|if
condition|(
name|off
operator|<=
literal|0x7fffL
condition|)
block|{
comment|/* On chip data */
name|phys
operator|=
name|targ_data
operator|+
name|off
expr_stmt|;
if|if
condition|(
name|off
operator|+
name|nr_bytes
operator|>
literal|0x7fffL
condition|)
comment|/* don't cross VM boundary */
name|nr_bytes
operator|=
literal|0x7fffL
operator|-
name|off
operator|+
literal|1
expr_stmt|;
name|to
operator|=
literal|"chip-data"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|off
operator|<=
literal|0xbfffL
condition|)
block|{
name|short
name|map
init|=
name|dmap
decl_stmt|;
if|if
condition|(
name|map
operator|&
literal|0x1000
condition|)
block|{
comment|/* Instruction memory */
name|phys
operator|=
name|targ_insn
operator||
operator|(
operator|(
name|map
operator|&
literal|0xf
operator|)
operator|<<
literal|14
operator|)
operator||
operator|(
name|off
operator|&
literal|0x3fff
operator|)
expr_stmt|;
name|to
operator|=
literal|"chip-insn"
expr_stmt|;
block|}
else|else
block|{
comment|/* Unified memory */
name|phys
operator|=
name|targ_unified
operator||
operator|(
operator|(
name|map
operator|&
literal|0x3ff
operator|)
operator|<<
literal|14
operator|)
operator||
operator|(
name|off
operator|&
literal|0x3fff
operator|)
expr_stmt|;
name|to
operator|=
literal|"unified"
expr_stmt|;
block|}
if|if
condition|(
name|off
operator|+
name|nr_bytes
operator|>
literal|0xbfffL
condition|)
comment|/* don't cross VM boundary */
name|nr_bytes
operator|=
operator|(
literal|0xbfffL
operator|-
name|off
operator|+
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Logical address out side of data segments, not supported */
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
block|}
case|case
literal|0x01
case|:
comment|/* in logical instruction address segment */
block|{
name|short
name|map
decl_stmt|;
name|from
operator|=
literal|"logical-insn"
expr_stmt|;
if|if
condition|(
name|off
operator|<=
literal|0x1ffffL
condition|)
block|{
name|map
operator|=
name|imap0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|off
operator|<=
literal|0x3ffffL
condition|)
block|{
name|map
operator|=
name|imap1
expr_stmt|;
block|}
else|else
block|{
comment|/* Logical address outside of IMAP[01] segment, not 		 supported */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|off
operator|&
literal|0x1ffff
operator|)
operator|+
name|nr_bytes
operator|>
literal|0x1ffffL
condition|)
block|{
comment|/* don't cross VM boundary */
name|nr_bytes
operator|=
literal|0x1ffffL
operator|-
operator|(
name|off
operator|&
literal|0x1ffffL
operator|)
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|map
operator|&
literal|0x1000
condition|)
comment|/* Instruction memory */
block|{
name|phys
operator|=
name|targ_insn
operator||
name|off
expr_stmt|;
name|to
operator|=
literal|"chip-insn"
expr_stmt|;
block|}
else|else
block|{
name|phys
operator|=
operator|(
operator|(
name|map
operator|&
literal|0x7fL
operator|)
operator|<<
literal|17
operator|)
operator|+
operator|(
name|off
operator|&
literal|0x1ffffL
operator|)
expr_stmt|;
if|if
condition|(
name|phys
operator|>
literal|0xffffffL
condition|)
comment|/* Address outside of unified address segment */
return|return
operator|(
literal|0
operator|)
return|;
name|phys
operator||=
name|targ_unified
expr_stmt|;
name|to
operator|=
literal|"unified"
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|0x10
case|:
comment|/* Physical data memory segment */
name|from
operator|=
literal|"phys-data"
expr_stmt|;
name|phys
operator|=
name|targ_data
operator||
name|off
expr_stmt|;
name|to
operator|=
literal|"chip-data"
expr_stmt|;
break|break;
case|case
literal|0x11
case|:
comment|/* Physical instruction memory */
name|from
operator|=
literal|"phys-insn"
expr_stmt|;
name|phys
operator|=
name|targ_insn
operator||
name|off
expr_stmt|;
name|to
operator|=
literal|"chip-insn"
expr_stmt|;
break|break;
case|case
literal|0x12
case|:
comment|/* Physical unified memory */
name|from
operator|=
literal|"phys-unified"
expr_stmt|;
name|phys
operator|=
name|targ_unified
operator||
name|off
expr_stmt|;
name|to
operator|=
literal|"unified"
expr_stmt|;
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|taddr
operator|=
name|phys
expr_stmt|;
return|return
name|nr_bytes
return|;
block|}
end_function

begin_function
name|void
name|_initialize_remote_d10v
parameter_list|()
block|{
name|remote_d10v_ops
operator|.
name|to_shortname
operator|=
literal|"d10v"
expr_stmt|;
name|remote_d10v_ops
operator|.
name|to_longname
operator|=
literal|"Remote d10v serial target in gdb-specific protocol"
expr_stmt|;
name|remote_d10v_ops
operator|.
name|to_doc
operator|=
literal|"Use a remote d10v via a serial line, using a gdb-specific protocol.\n\ Specify the serial device it is connected to (e.g. /dev/ttya)."
expr_stmt|;
name|remote_d10v_ops
operator|.
name|to_open
operator|=
name|remote_d10v_open
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|remote_d10v_ops
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

