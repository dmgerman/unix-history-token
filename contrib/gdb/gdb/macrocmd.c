begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* C preprocessor macro expansion commands for GDB.    Copyright 2002 Free Software Foundation, Inc.    Contributed by Red Hat, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"macrotab.h"
end_include

begin_include
include|#
directive|include
file|"macroexp.h"
end_include

begin_include
include|#
directive|include
file|"macroscope.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* The `macro' prefix command.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cmd_list_element
modifier|*
name|macrolist
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|macro_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\"macro\" must be followed by the name of a macro command.\n"
argument_list|)
expr_stmt|;
name|help_list
argument_list|(
name|macrolist
argument_list|,
literal|"macro "
argument_list|,
operator|-
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Macro expansion commands.  */
end_comment

begin_function
specifier|static
name|void
name|macro_expand_command
parameter_list|(
name|char
modifier|*
name|exp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|macro_scope
modifier|*
name|ms
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|expanded
init|=
name|NULL
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|cleanup_chain
init|=
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|ms
argument_list|)
decl_stmt|;
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|expanded
argument_list|)
expr_stmt|;
comment|/* You know, when the user doesn't specify any expression, it would be      really cool if this defaulted to the last expression evaluated.      Then it would be easy to ask, "Hey, what did I just evaluate?"  But      at the moment, the `print' commands don't save the last expression      evaluated, just its value.  */
if|if
condition|(
operator|!
name|exp
operator|||
operator|!
operator|*
name|exp
condition|)
name|error
argument_list|(
literal|"You must follow the `macro expand' command with the"
literal|" expression you\n"
literal|"want to expand."
argument_list|)
expr_stmt|;
name|ms
operator|=
name|default_macro_scope
argument_list|()
expr_stmt|;
if|if
condition|(
name|ms
condition|)
block|{
name|expanded
operator|=
name|macro_expand
argument_list|(
name|exp
argument_list|,
name|standard_macro_lookup
argument_list|,
name|ms
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"expands to: "
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|expanded
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"\n"
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
else|else
name|fputs_filtered
argument_list|(
literal|"GDB has no preprocessor macro information for "
literal|"that code.\n"
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|cleanup_chain
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|macro_expand_once_command
parameter_list|(
name|char
modifier|*
name|exp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|macro_scope
modifier|*
name|ms
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|expanded
init|=
name|NULL
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|cleanup_chain
init|=
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|ms
argument_list|)
decl_stmt|;
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|expanded
argument_list|)
expr_stmt|;
comment|/* You know, when the user doesn't specify any expression, it would be      really cool if this defaulted to the last expression evaluated.      And it should set the once-expanded text as the new `last      expression'.  That way, you could just hit return over and over and      see the expression expanded one level at a time.  */
if|if
condition|(
operator|!
name|exp
operator|||
operator|!
operator|*
name|exp
condition|)
name|error
argument_list|(
literal|"You must follow the `macro expand-once' command with"
literal|" the expression\n"
literal|"you want to expand."
argument_list|)
expr_stmt|;
name|ms
operator|=
name|default_macro_scope
argument_list|()
expr_stmt|;
if|if
condition|(
name|ms
condition|)
block|{
name|expanded
operator|=
name|macro_expand_once
argument_list|(
name|exp
argument_list|,
name|standard_macro_lookup
argument_list|,
name|ms
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"expands to: "
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|expanded
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"\n"
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
else|else
name|fputs_filtered
argument_list|(
literal|"GDB has no preprocessor macro information for "
literal|"that code.\n"
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|cleanup_chain
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|show_pp_source_pos
parameter_list|(
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|struct
name|macro_source_file
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s:%d\n"
argument_list|,
name|file
operator|->
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
while|while
condition|(
name|file
operator|->
name|included_by
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|gdb_stdout
argument_list|,
literal|"  included at %s:%d\n"
argument_list|,
name|file
operator|->
name|included_by
operator|->
name|filename
argument_list|,
name|file
operator|->
name|included_at_line
argument_list|)
expr_stmt|;
name|file
operator|=
name|file
operator|->
name|included_by
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|info_macro_command
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|macro_scope
modifier|*
name|ms
init|=
name|NULL
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|cleanup_chain
init|=
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|ms
argument_list|)
decl_stmt|;
name|struct
name|macro_definition
modifier|*
name|d
decl_stmt|;
if|if
condition|(
operator|!
name|name
operator|||
operator|!
operator|*
name|name
condition|)
name|error
argument_list|(
literal|"You must follow the `info macro' command with the name"
literal|" of the macro\n"
literal|"whose definition you want to see."
argument_list|)
expr_stmt|;
name|ms
operator|=
name|default_macro_scope
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ms
condition|)
name|error
argument_list|(
literal|"GDB has no preprocessor macro information for that code."
argument_list|)
expr_stmt|;
name|d
operator|=
name|macro_lookup_definition
argument_list|(
name|ms
operator|->
name|file
argument_list|,
name|ms
operator|->
name|line
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
condition|)
block|{
name|int
name|line
decl_stmt|;
name|struct
name|macro_source_file
modifier|*
name|file
init|=
name|macro_definition_location
argument_list|(
name|ms
operator|->
name|file
argument_list|,
name|ms
operator|->
name|line
argument_list|,
name|name
argument_list|,
operator|&
name|line
argument_list|)
decl_stmt|;
name|fprintf_filtered
argument_list|(
name|gdb_stdout
argument_list|,
literal|"Defined at "
argument_list|)
expr_stmt|;
name|show_pp_source_pos
argument_list|(
name|gdb_stdout
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|gdb_stdout
argument_list|,
literal|"#define %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|kind
operator|==
name|macro_function_like
condition|)
block|{
name|int
name|i
decl_stmt|;
name|fputs_filtered
argument_list|(
literal|"("
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|fputs_filtered
argument_list|(
name|d
operator|->
name|argv
index|[
name|i
index|]
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|d
operator|->
name|argc
condition|)
name|fputs_filtered
argument_list|(
literal|", "
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
literal|")"
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|gdb_stdout
argument_list|,
literal|" %s\n"
argument_list|,
name|d
operator|->
name|replacement
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|gdb_stdout
argument_list|,
literal|"The symbol `%s' has no definition as a C/C++"
literal|" preprocessor macro\n"
literal|"at "
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|show_pp_source_pos
argument_list|(
name|gdb_stdout
argument_list|,
name|ms
operator|->
name|file
argument_list|,
name|ms
operator|->
name|line
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|cleanup_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* User-defined macros.  */
end_comment

begin_comment
comment|/* A table of user-defined macros.  Unlike the macro tables used for    symtabs, this one uses xmalloc for all its allocation, not an    obstack, and it doesn't bcache anything; it just xmallocs things.  So    it's perfectly possible to remove things from this, or redefine    things.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|macro_table
modifier|*
name|user_macros
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|macro_define_command
parameter_list|(
name|char
modifier|*
name|exp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|error
argument_list|(
literal|"Command not implemented yet."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|macro_undef_command
parameter_list|(
name|char
modifier|*
name|exp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|error
argument_list|(
literal|"Command not implemented yet."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|macro_list_command
parameter_list|(
name|char
modifier|*
name|exp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|error
argument_list|(
literal|"Command not implemented yet."
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initializing the `macrocmd' module.  */
end_comment

begin_decl_stmt
specifier|extern
name|initialize_file_ftype
name|_initialize_macrocmd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -Wmissing-prototypes */
end_comment

begin_function
name|void
name|_initialize_macrocmd
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
comment|/* We introduce a new command prefix, `macro', under which we'll put      the various commands for working with preprocessor macros.  */
name|add_prefix_cmd
argument_list|(
literal|"macro"
argument_list|,
name|class_info
argument_list|,
name|macro_command
argument_list|,
literal|"Prefix for commands dealing with C preprocessor macros."
argument_list|,
operator|&
name|macrolist
argument_list|,
literal|"macro "
argument_list|,
literal|0
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"expand"
argument_list|,
name|no_class
argument_list|,
name|macro_expand_command
argument_list|,
literal|"Fully expand any C/C++ preprocessor macro invocations in EXPRESSION.\n"
literal|"Show the expanded expression."
argument_list|,
operator|&
name|macrolist
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
literal|"exp"
argument_list|,
literal|"expand"
argument_list|,
name|no_class
argument_list|,
literal|1
argument_list|,
operator|&
name|macrolist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"expand-once"
argument_list|,
name|no_class
argument_list|,
name|macro_expand_once_command
argument_list|,
literal|"Expand C/C++ preprocessor macro invocations appearing directly in"
literal|" EXPRESSION.\n"
literal|"Show the expanded expression.\n"
literal|"\n"
literal|"This command differs from `macro expand' in that it only expands macro\n"
literal|"invocations that appear directly in EXPRESSION; if expanding a macro\n"
literal|"introduces further macro invocations, those are left unexpanded.\n"
literal|"\n"
literal|"`macro expand-once' helps you see how a particular macro expands,\n"
literal|"whereas `macro expand' shows you how all the macros involved in an\n"
literal|"expression work together to yield a pre-processed expression."
argument_list|,
operator|&
name|macrolist
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
literal|"exp1"
argument_list|,
literal|"expand-once"
argument_list|,
name|no_class
argument_list|,
literal|1
argument_list|,
operator|&
name|macrolist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"macro"
argument_list|,
name|no_class
argument_list|,
name|info_macro_command
argument_list|,
literal|"Show the definition of MACRO, and its source location."
argument_list|,
operator|&
name|infolist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"define"
argument_list|,
name|no_class
argument_list|,
name|macro_define_command
argument_list|,
literal|"Define a new C/C++ preprocessor macro.\n"
literal|"The GDB command `macro define DEFINITION' is equivalent to placing a\n"
literal|"preprocessor directive of the form `#define DEFINITION' such that the\n"
literal|"definition is visible in all the inferior's source files.\n"
literal|"For example:\n"
literal|"  (gdb) macro define PI (3.1415926)\n"
literal|"  (gdb) macro define MIN(x,y) ((x)< (y) ? (x) : (y))"
argument_list|,
operator|&
name|macrolist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"undef"
argument_list|,
name|no_class
argument_list|,
name|macro_undef_command
argument_list|,
literal|"Remove the definition of the C/C++ preprocessor macro with the"
literal|" given name."
argument_list|,
operator|&
name|macrolist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"list"
argument_list|,
name|no_class
argument_list|,
name|macro_list_command
argument_list|,
literal|"List all the macros defined using the `macro define' command."
argument_list|,
operator|&
name|macrolist
argument_list|)
expr_stmt|;
name|user_macros
operator|=
name|new_macro_table
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

