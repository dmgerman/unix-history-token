begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Support for printing C++ values for GDB, the GNU debugger.    Copyright 1986, 1988, 1989, 1991, 1994, 1995, 1996    Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"annotate.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"c-lang.h"
end_include

begin_decl_stmt
name|int
name|vtblprint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls printing of vtbl's */
end_comment

begin_decl_stmt
name|int
name|objectprint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls looking up an object's derived type 				   using what we find in its vtables.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|static_field_print
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls printing of static fields. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|dont_print_vb_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|dont_print_statmem_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cp_print_static_field
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|,
name|value_ptr
operator|,
name|GDB_FILE
operator|*
operator|,
name|int
operator|,
name|int
operator|,
expr|enum
name|val_prettyprint
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cp_print_value
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|,
name|char
operator|*
operator|,
name|CORE_ADDR
operator|,
name|GDB_FILE
operator|*
operator|,
name|int
operator|,
name|int
operator|,
expr|enum
name|val_prettyprint
operator|,
expr|struct
name|type
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|cp_print_class_method
parameter_list|(
name|valaddr
parameter_list|,
name|type
parameter_list|,
name|stream
parameter_list|)
name|char
modifier|*
name|valaddr
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|domain
decl_stmt|;
name|struct
name|fn_field
modifier|*
name|f
init|=
name|NULL
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
name|int
name|len2
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|char
modifier|*
name|kind
init|=
literal|""
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|type
modifier|*
name|target_type
init|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|domain
operator|=
name|TYPE_DOMAIN_TYPE
argument_list|(
name|target_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|domain
operator|==
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<unknown>"
argument_list|)
expr_stmt|;
return|return;
block|}
name|addr
operator|=
name|unpack_pointer
argument_list|(
name|lookup_pointer_type
argument_list|(
name|builtin_type_void
argument_list|)
argument_list|,
name|valaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|METHOD_PTR_IS_VIRTUAL
argument_list|(
name|addr
argument_list|)
condition|)
block|{
name|offset
operator|=
name|METHOD_PTR_TO_VOFFSET
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|domain
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|f
operator|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|len2
operator|=
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len2
condition|;
name|j
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|TYPE_FN_FIELD_VOFFSET
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
operator|==
name|offset
condition|)
block|{
name|kind
operator|=
literal|"virtual "
expr_stmt|;
goto|goto
name|common
goto|;
block|}
block|}
block|}
block|}
else|else
block|{
name|sym
operator|=
name|find_pc_function
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"invalid pointer to member function"
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|domain
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|f
operator|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|len2
operator|=
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len2
condition|;
name|j
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|TYPE_FN_FIELD_STUB
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
name|check_stub_method
argument_list|(
name|domain
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
block|{
goto|goto
name|common
goto|;
block|}
block|}
block|}
block|}
name|common
label|:
if|if
condition|(
name|i
operator|<
name|len
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
name|c_type_print_varspec_prefix
argument_list|(
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
name|kind
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|is_cplus_marker
argument_list|(
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|cp_type_print_method_args
argument_list|(
name|TYPE_FN_FIELD_ARGS
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
operator|+
literal|1
argument_list|,
literal|"~"
argument_list|,
name|TYPE_FN_FIELDLIST_NAME
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cp_type_print_method_args
argument_list|(
name|TYPE_FN_FIELD_ARGS
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|,
literal|""
argument_list|,
name|TYPE_FN_FIELDLIST_NAME
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|") %d"
argument_list|,
operator|(
name|int
operator|)
name|addr
operator|>>
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This was what it was for gcc 2.4.5 and earlier.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|vtbl_ptr_name_old
index|[]
init|=
block|{
name|CPLUS_MARKER
block|,
literal|'v'
block|,
literal|'t'
block|,
literal|'b'
block|,
literal|'l'
block|,
literal|'_'
block|,
literal|'p'
block|,
literal|'t'
block|,
literal|'r'
block|,
literal|'_'
block|,
literal|'t'
block|,
literal|'y'
block|,
literal|'p'
block|,
literal|'e'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* It was changed to this after 2.4.5.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|vtbl_ptr_name
index|[]
init|=
block|{
literal|'_'
block|,
literal|'_'
block|,
literal|'v'
block|,
literal|'t'
block|,
literal|'b'
block|,
literal|'l'
block|,
literal|'_'
block|,
literal|'p'
block|,
literal|'t'
block|,
literal|'r'
block|,
literal|'_'
block|,
literal|'t'
block|,
literal|'y'
block|,
literal|'p'
block|,
literal|'e'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return truth value for assertion that TYPE is of the type    "pointer to virtual function".  */
end_comment

begin_function
name|int
name|cp_is_vtbl_ptr_type
parameter_list|(
name|type
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
name|char
modifier|*
name|typename
init|=
name|type_name_no_tag
argument_list|(
name|type
argument_list|)
decl_stmt|;
return|return
operator|(
name|typename
operator|!=
name|NULL
operator|&&
operator|(
name|STREQ
argument_list|(
name|typename
argument_list|,
name|vtbl_ptr_name
argument_list|)
operator|||
name|STREQ
argument_list|(
name|typename
argument_list|,
name|vtbl_ptr_name_old
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return truth value for the assertion that TYPE is of the type    "pointer to virtual function table".  */
end_comment

begin_function
name|int
name|cp_is_vtbl_member
parameter_list|(
name|type
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
block|{
name|type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
condition|)
block|{
name|type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
comment|/* if not using thunks */
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
comment|/* if using thunks */
block|{
comment|/* Virtual functions tables are full of pointers 		 to virtual functions. */
return|return
name|cp_is_vtbl_ptr_type
argument_list|(
name|type
argument_list|)
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Mutually recursive subroutines of cp_print_value and c_val_print to    print out a structure's fields: cp_print_value_fields and cp_print_value.       TYPE, VALADDR, ADDRESS, STREAM, RECURSE, and PRETTY have the    same meanings as in cp_print_value and c_val_print.     DONT_PRINT is an array of baseclass types that we    should not print, or zero if called from top level.  */
end_comment

begin_function
name|void
name|cp_print_value_fields
parameter_list|(
name|type
parameter_list|,
name|valaddr
parameter_list|,
name|address
parameter_list|,
name|stream
parameter_list|,
name|format
parameter_list|,
name|recurse
parameter_list|,
name|pretty
parameter_list|,
name|dont_print_vb
parameter_list|,
name|dont_print_statmem
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|valaddr
decl_stmt|;
name|CORE_ADDR
name|address
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|format
decl_stmt|;
name|int
name|recurse
decl_stmt|;
name|enum
name|val_prettyprint
name|pretty
decl_stmt|;
name|struct
name|type
modifier|*
modifier|*
name|dont_print_vb
decl_stmt|;
name|int
name|dont_print_statmem
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|n_baseclasses
decl_stmt|;
name|struct
name|obstack
name|tmp_obstack
decl_stmt|;
name|char
modifier|*
name|last_dont_print
init|=
name|obstack_next_free
argument_list|(
operator|&
name|dont_print_statmem_obstack
argument_list|)
decl_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|n_baseclasses
operator|=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Print out baseclasses such that we don't print      duplicates of virtual baseclasses.  */
if|if
condition|(
name|n_baseclasses
operator|>
literal|0
condition|)
name|cp_print_value
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
name|address
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|,
name|dont_print_vb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|len
operator|&&
name|n_baseclasses
operator|==
literal|1
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<No data fields>"
argument_list|)
expr_stmt|;
else|else
block|{
specifier|extern
name|int
name|inspect_it
decl_stmt|;
name|int
name|fields_seen
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dont_print_statmem
operator|==
literal|0
condition|)
block|{
comment|/* If we're at top level, carve out a completely fresh 	     chunk of the obstack and use that until this particular 	     invocation returns.  */
name|tmp_obstack
operator|=
name|dont_print_statmem_obstack
expr_stmt|;
name|obstack_finish
argument_list|(
operator|&
name|dont_print_statmem_obstack
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|n_baseclasses
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
comment|/* If requested, skip printing of static fields.  */
if|if
condition|(
operator|!
name|static_field_print
operator|&&
name|TYPE_FIELD_STATIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|fields_seen
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n_baseclasses
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|pretty
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"members of "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|type_name_no_tag
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|": "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
name|fields_seen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pretty
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wrap_here
argument_list|(
name|n_spaces
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inspect_it
condition|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
name|fputs_filtered
argument_list|(
literal|"\"( ptr \""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|"\"( nodef \""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FIELD_STATIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
name|fputs_filtered
argument_list|(
literal|"static "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_symbol_filtered
argument_list|(
name|stream
argument_list|,
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|language_cplus
argument_list|,
name|DMGL_PARAMS
operator||
name|DMGL_ANSI
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"\" \""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_symbol_filtered
argument_list|(
name|stream
argument_list|,
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|language_cplus
argument_list|,
name|DMGL_PARAMS
operator||
name|DMGL_ANSI
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"\") \""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|annotate_field_begin
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FIELD_STATIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
name|fputs_filtered
argument_list|(
literal|"static "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_symbol_filtered
argument_list|(
name|stream
argument_list|,
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|language_cplus
argument_list|,
name|DMGL_PARAMS
operator||
name|DMGL_ANSI
argument_list|)
expr_stmt|;
name|annotate_field_name_end
argument_list|()
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" = "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|annotate_field_value
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TYPE_FIELD_STATIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|&&
name|TYPE_FIELD_PACKED
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|value_ptr
name|v
decl_stmt|;
comment|/* Bitfields require special handling, especially due to byte 		 order problems.  */
if|if
condition|(
name|TYPE_FIELD_IGNORE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"<optimized out or zero length>"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|v
operator|=
name|value_from_longest
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|unpack_field_as_long
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|val_print
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|v
argument_list|)
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|TYPE_FIELD_IGNORE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"<optimized out or zero length>"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_FIELD_STATIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|value_ptr
name|v
decl_stmt|;
name|char
modifier|*
name|phys_name
init|=
name|TYPE_FIELD_STATIC_PHYSNAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
init|=
name|lookup_symbol
argument_list|(
name|phys_name
argument_list|,
literal|0
argument_list|,
name|VAR_NAMESPACE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
name|fputs_filtered
argument_list|(
literal|"<optimized out>"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
block|{
name|v
operator|=
name|value_at
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
operator|(
name|CORE_ADDR
operator|)
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|cp_print_static_field
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|v
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|val_print
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|valaddr
operator|+
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|/
literal|8
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
block|}
block|}
name|annotate_field_end
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dont_print_statmem
operator|==
literal|0
condition|)
block|{
comment|/* Free the space used to deal with the printing 	     of the members from top level.  */
name|obstack_free
argument_list|(
operator|&
name|dont_print_statmem_obstack
argument_list|,
name|last_dont_print
argument_list|)
expr_stmt|;
name|dont_print_statmem_obstack
operator|=
name|tmp_obstack
expr_stmt|;
block|}
if|if
condition|(
name|pretty
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Special val_print routine to avoid printing multiple copies of virtual    baseclasses.  */
end_comment

begin_function
specifier|static
name|void
name|cp_print_value
parameter_list|(
name|type
parameter_list|,
name|valaddr
parameter_list|,
name|address
parameter_list|,
name|stream
parameter_list|,
name|format
parameter_list|,
name|recurse
parameter_list|,
name|pretty
parameter_list|,
name|dont_print_vb
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|valaddr
decl_stmt|;
name|CORE_ADDR
name|address
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|format
decl_stmt|;
name|int
name|recurse
decl_stmt|;
name|enum
name|val_prettyprint
name|pretty
decl_stmt|;
name|struct
name|type
modifier|*
modifier|*
name|dont_print_vb
decl_stmt|;
block|{
name|struct
name|obstack
name|tmp_obstack
decl_stmt|;
name|struct
name|type
modifier|*
modifier|*
name|last_dont_print
init|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|obstack_next_free
argument_list|(
operator|&
name|dont_print_vb_obstack
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|dont_print_vb
operator|==
literal|0
condition|)
block|{
comment|/* If we're at top level, carve out a completely fresh 	 chunk of the obstack and use that until this particular 	 invocation returns.  */
name|tmp_obstack
operator|=
name|dont_print_vb_obstack
expr_stmt|;
comment|/* Bump up the high-water mark.  Now alpha is omega.  */
name|obstack_finish
argument_list|(
operator|&
name|dont_print_vb_obstack
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|int
name|boffset
decl_stmt|;
name|struct
name|type
modifier|*
name|baseclass
init|=
name|check_typedef
argument_list|(
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|basename
init|=
name|TYPE_NAME
argument_list|(
name|baseclass
argument_list|)
decl_stmt|;
if|if
condition|(
name|BASETYPE_VIA_VIRTUAL
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|struct
name|type
modifier|*
modifier|*
name|first_dont_print
init|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|dont_print_vb_obstack
argument_list|)
decl_stmt|;
name|int
name|j
init|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|obstack_next_free
argument_list|(
operator|&
name|dont_print_vb_obstack
argument_list|)
operator|-
name|first_dont_print
decl_stmt|;
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
if|if
condition|(
name|baseclass
operator|==
name|first_dont_print
index|[
name|j
index|]
condition|)
goto|goto
name|flush_it
goto|;
name|obstack_ptr_grow
argument_list|(
operator|&
name|dont_print_vb_obstack
argument_list|,
name|baseclass
argument_list|)
expr_stmt|;
block|}
name|boffset
operator|=
name|baseclass_offset
argument_list|(
name|type
argument_list|,
name|i
argument_list|,
name|valaddr
argument_list|,
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|pretty
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
literal|"<"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* Not sure what the best notation is in the case where there is no 	 baseclass name.  */
name|fputs_filtered
argument_list|(
name|basename
condition|?
name|basename
else|:
literal|""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"> = "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|boffset
operator|==
operator|-
literal|1
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<invalid address>"
argument_list|)
expr_stmt|;
else|else
name|cp_print_value_fields
argument_list|(
name|baseclass
argument_list|,
name|valaddr
operator|+
name|boffset
argument_list|,
name|address
operator|+
name|boffset
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|,
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|dont_print_vb_obstack
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|flush_it
label|:
empty_stmt|;
block|}
if|if
condition|(
name|dont_print_vb
operator|==
literal|0
condition|)
block|{
comment|/* Free the space used to deal with the printing 	 of this type from top level.  */
name|obstack_free
argument_list|(
operator|&
name|dont_print_vb_obstack
argument_list|,
name|last_dont_print
argument_list|)
expr_stmt|;
comment|/* Reset watermark so that we can continue protecting 	 ourselves from whatever we were protecting ourselves.  */
name|dont_print_vb_obstack
operator|=
name|tmp_obstack
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print value of a static member.    To avoid infinite recursion when printing a class that contains    a static instance of the class, we keep the addresses of all printed    static member classes in an obstack and refuse to print them more    than once.     VAL contains the value to print, TYPE, STREAM, RECURSE, and PRETTY    have the same meanings as in c_val_print.  */
end_comment

begin_function
specifier|static
name|void
name|cp_print_static_field
parameter_list|(
name|type
parameter_list|,
name|val
parameter_list|,
name|stream
parameter_list|,
name|format
parameter_list|,
name|recurse
parameter_list|,
name|pretty
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|value_ptr
name|val
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|format
decl_stmt|;
name|int
name|recurse
decl_stmt|;
name|enum
name|val_prettyprint
name|pretty
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
condition|)
block|{
name|CORE_ADDR
modifier|*
name|first_dont_print
decl_stmt|;
name|int
name|i
decl_stmt|;
name|first_dont_print
operator|=
operator|(
name|CORE_ADDR
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|dont_print_statmem_obstack
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
name|CORE_ADDR
operator|*
operator|)
name|obstack_next_free
argument_list|(
operator|&
name|dont_print_statmem_obstack
argument_list|)
operator|-
name|first_dont_print
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|==
name|first_dont_print
index|[
name|i
index|]
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"<same as static member of an already seen type>"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|obstack_grow
argument_list|(
operator|&
name|dont_print_statmem_obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|cp_print_value_fields
argument_list|(
name|type
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|val_print
argument_list|(
name|type
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cp_print_class_member
parameter_list|(
name|valaddr
parameter_list|,
name|domain
parameter_list|,
name|stream
parameter_list|,
name|prefix
parameter_list|)
name|char
modifier|*
name|valaddr
decl_stmt|;
name|struct
name|type
modifier|*
name|domain
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
block|{
comment|/* VAL is a byte offset into the structure type DOMAIN.      Find the name of the field for that offset and      print it.  */
name|int
name|extra
init|=
literal|0
decl_stmt|;
name|int
name|bits
init|=
literal|0
decl_stmt|;
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|len
init|=
name|TYPE_NFIELDS
argument_list|(
name|domain
argument_list|)
decl_stmt|;
comment|/* @@ Make VAL into bit offset */
name|LONGEST
name|val
init|=
name|unpack_long
argument_list|(
name|builtin_type_int
argument_list|,
name|valaddr
argument_list|)
operator|<<
literal|3
decl_stmt|;
for|for
control|(
name|i
operator|=
name|TYPE_N_BASECLASSES
argument_list|(
name|domain
argument_list|)
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|int
name|bitpos
init|=
name|TYPE_FIELD_BITPOS
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|QUIT
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|bitpos
condition|)
break|break;
if|if
condition|(
name|val
operator|<
name|bitpos
operator|&&
name|i
operator|!=
literal|0
condition|)
block|{
comment|/* Somehow pointing into a field.  */
name|i
operator|-=
literal|1
expr_stmt|;
name|extra
operator|=
operator|(
name|val
operator|-
name|TYPE_FIELD_BITPOS
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|extra
operator|&
literal|0x7
condition|)
name|bits
operator|=
literal|1
expr_stmt|;
else|else
name|extra
operator|>>=
literal|3
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|<
name|len
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|name
operator|=
name|type_name_no_tag
argument_list|(
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|fputs_filtered
argument_list|(
name|name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|c_type_print_base
argument_list|(
name|domain
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" + %d bytes"
argument_list|,
name|extra
argument_list|)
expr_stmt|;
if|if
condition|(
name|bits
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" (offset in bits)"
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|val
operator|>>
literal|3
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_cp_valprint
parameter_list|()
block|{
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"static-members"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|static_field_print
argument_list|,
literal|"Set printing of C++ static members."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
comment|/* Turn on printing of static fields.  */
name|static_field_print
operator|=
literal|1
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"vtbl"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|vtblprint
argument_list|,
literal|"Set printing of C++ virtual function tables."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"object"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|objectprint
argument_list|,
literal|"Set printing of object's derived type based on vtable info."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
comment|/* Give people the defaults which they are used to.  */
name|objectprint
operator|=
literal|0
expr_stmt|;
name|vtblprint
operator|=
literal|0
expr_stmt|;
name|obstack_begin
argument_list|(
operator|&
name|dont_print_vb_obstack
argument_list|,
literal|32
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_specify_allocation
argument_list|(
operator|&
name|dont_print_statmem_obstack
argument_list|,
literal|32
operator|*
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
argument_list|,
name|xmalloc
argument_list|,
name|free
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

