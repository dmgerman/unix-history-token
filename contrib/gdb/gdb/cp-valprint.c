begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Support for printing C++ values for GDB, the GNU debugger.    Copyright 1986, 1988, 1989, 1991, 1994, 1995, 1996    Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"annotate.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"c-lang.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_comment
comment|/* Indication of presence of HP-compiled object files */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|hp_som_som_object_present
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* defined in symtab.c */
end_comment

begin_decl_stmt
name|int
name|vtblprint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls printing of vtbl's */
end_comment

begin_decl_stmt
name|int
name|objectprint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls looking up an object's derived type 				   using what we find in its vtables.  */
end_comment

begin_decl_stmt
name|int
name|static_field_print
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls printing of static fields. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|dont_print_vb_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|dont_print_statmem_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cp_print_static_field
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|,
name|value_ptr
operator|,
name|GDB_FILE
operator|*
operator|,
name|int
operator|,
name|int
operator|,
expr|enum
name|val_prettyprint
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cp_print_value
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|,
expr|struct
name|type
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|CORE_ADDR
operator|,
name|GDB_FILE
operator|*
operator|,
name|int
operator|,
name|int
operator|,
expr|enum
name|val_prettyprint
operator|,
expr|struct
name|type
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cp_print_hpacc_virtual_table_entries
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|,
name|int
operator|*
operator|,
name|value_ptr
operator|,
name|GDB_FILE
operator|*
operator|,
name|int
operator|,
name|int
operator|,
expr|enum
name|val_prettyprint
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|cp_print_class_method
parameter_list|(
name|valaddr
parameter_list|,
name|type
parameter_list|,
name|stream
parameter_list|)
name|char
modifier|*
name|valaddr
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|domain
decl_stmt|;
name|struct
name|fn_field
modifier|*
name|f
init|=
name|NULL
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
name|int
name|len2
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|char
modifier|*
name|kind
init|=
literal|""
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|type
modifier|*
name|target_type
init|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|domain
operator|=
name|TYPE_DOMAIN_TYPE
argument_list|(
name|target_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|domain
operator|==
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<unknown>"
argument_list|)
expr_stmt|;
return|return;
block|}
name|addr
operator|=
name|unpack_pointer
argument_list|(
name|lookup_pointer_type
argument_list|(
name|builtin_type_void
argument_list|)
argument_list|,
name|valaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|METHOD_PTR_IS_VIRTUAL
argument_list|(
name|addr
argument_list|)
condition|)
block|{
name|offset
operator|=
name|METHOD_PTR_TO_VOFFSET
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|domain
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|f
operator|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|len2
operator|=
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len2
condition|;
name|j
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|TYPE_FN_FIELD_VOFFSET
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
operator|==
name|offset
condition|)
block|{
if|if
condition|(
name|TYPE_FN_FIELD_STUB
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
name|check_stub_method
argument_list|(
name|domain
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|kind
operator|=
literal|"virtual "
expr_stmt|;
goto|goto
name|common
goto|;
block|}
block|}
block|}
block|}
else|else
block|{
name|sym
operator|=
name|find_pc_function
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
literal|0
condition|)
block|{
comment|/* 1997-08-01 Currently unsupported with HP aCC */
if|if
condition|(
name|hp_som_som_object_present
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"??<not supported with HP aCC>"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
block|}
name|error
argument_list|(
literal|"invalid pointer to member function"
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|domain
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|f
operator|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|len2
operator|=
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len2
condition|;
name|j
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|TYPE_FN_FIELD_STUB
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
name|check_stub_method
argument_list|(
name|domain
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
block|{
goto|goto
name|common
goto|;
block|}
block|}
block|}
block|}
name|common
label|:
if|if
condition|(
name|i
operator|<
name|len
condition|)
block|{
name|char
modifier|*
name|demangled_name
decl_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|kind
argument_list|)
expr_stmt|;
name|demangled_name
operator|=
name|cplus_demangle
argument_list|(
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|,
name|DMGL_ANSI
operator||
name|DMGL_PARAMS
argument_list|)
expr_stmt|;
if|if
condition|(
name|demangled_name
operator|==
name|NULL
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<badly mangled name %s>"
argument_list|,
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|fputs_filtered
argument_list|(
name|demangled_name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|demangled_name
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|") %d"
argument_list|,
operator|(
name|int
operator|)
name|addr
operator|>>
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This was what it was for gcc 2.4.5 and earlier.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|vtbl_ptr_name_old
index|[]
init|=
block|{
name|CPLUS_MARKER
block|,
literal|'v'
block|,
literal|'t'
block|,
literal|'b'
block|,
literal|'l'
block|,
literal|'_'
block|,
literal|'p'
block|,
literal|'t'
block|,
literal|'r'
block|,
literal|'_'
block|,
literal|'t'
block|,
literal|'y'
block|,
literal|'p'
block|,
literal|'e'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* It was changed to this after 2.4.5.  */
end_comment

begin_decl_stmt
specifier|const
name|char
name|vtbl_ptr_name
index|[]
init|=
block|{
literal|'_'
block|,
literal|'_'
block|,
literal|'v'
block|,
literal|'t'
block|,
literal|'b'
block|,
literal|'l'
block|,
literal|'_'
block|,
literal|'p'
block|,
literal|'t'
block|,
literal|'r'
block|,
literal|'_'
block|,
literal|'t'
block|,
literal|'y'
block|,
literal|'p'
block|,
literal|'e'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* HP aCC uses different names */
end_comment

begin_decl_stmt
specifier|const
name|char
name|hpacc_vtbl_ptr_name
index|[]
init|=
block|{
literal|'_'
block|,
literal|'_'
block|,
literal|'v'
block|,
literal|'f'
block|,
literal|'p'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
name|hpacc_vtbl_ptr_type_name
index|[]
init|=
block|{
literal|'_'
block|,
literal|'_'
block|,
literal|'v'
block|,
literal|'f'
block|,
literal|'t'
block|,
literal|'y'
block|,
literal|'p'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return truth value for assertion that TYPE is of the type    "pointer to virtual function".  */
end_comment

begin_function
name|int
name|cp_is_vtbl_ptr_type
parameter_list|(
name|type
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
name|char
modifier|*
name|typename
init|=
name|type_name_no_tag
argument_list|(
name|type
argument_list|)
decl_stmt|;
return|return
operator|(
name|typename
operator|!=
name|NULL
operator|&&
operator|(
name|STREQ
argument_list|(
name|typename
argument_list|,
name|vtbl_ptr_name
argument_list|)
operator|||
name|STREQ
argument_list|(
name|typename
argument_list|,
name|vtbl_ptr_name_old
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return truth value for the assertion that TYPE is of the type    "pointer to virtual function table".  */
end_comment

begin_function
name|int
name|cp_is_vtbl_member
parameter_list|(
name|type
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
block|{
name|type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
condition|)
block|{
name|type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
comment|/* if not using thunks */
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
comment|/* if using thunks */
block|{
comment|/* Virtual functions tables are full of pointers 		 to virtual functions. */
return|return
name|cp_is_vtbl_ptr_type
argument_list|(
name|type
argument_list|)
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Mutually recursive subroutines of cp_print_value and c_val_print to    print out a structure's fields: cp_print_value_fields and cp_print_value.       TYPE, VALADDR, ADDRESS, STREAM, RECURSE, and PRETTY have the    same meanings as in cp_print_value and c_val_print.     2nd argument REAL_TYPE is used to carry over the type of the derived    class across the recursion to base classes.      DONT_PRINT is an array of baseclass types that we    should not print, or zero if called from top level.  */
end_comment

begin_function
name|void
name|cp_print_value_fields
parameter_list|(
name|type
parameter_list|,
name|real_type
parameter_list|,
name|valaddr
parameter_list|,
name|offset
parameter_list|,
name|address
parameter_list|,
name|stream
parameter_list|,
name|format
parameter_list|,
name|recurse
parameter_list|,
name|pretty
parameter_list|,
name|dont_print_vb
parameter_list|,
name|dont_print_statmem
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|type
modifier|*
name|real_type
decl_stmt|;
name|char
modifier|*
name|valaddr
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|CORE_ADDR
name|address
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|format
decl_stmt|;
name|int
name|recurse
decl_stmt|;
name|enum
name|val_prettyprint
name|pretty
decl_stmt|;
name|struct
name|type
modifier|*
modifier|*
name|dont_print_vb
decl_stmt|;
name|int
name|dont_print_statmem
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|n_baseclasses
decl_stmt|;
name|struct
name|obstack
name|tmp_obstack
decl_stmt|;
name|char
modifier|*
name|last_dont_print
init|=
name|obstack_next_free
argument_list|(
operator|&
name|dont_print_statmem_obstack
argument_list|)
decl_stmt|;
name|int
name|fields_seen
init|=
literal|0
decl_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|n_baseclasses
operator|=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* First, print out baseclasses such that we don't print      duplicates of virtual baseclasses.  */
if|if
condition|(
name|n_baseclasses
operator|>
literal|0
condition|)
name|cp_print_value
argument_list|(
name|type
argument_list|,
name|real_type
argument_list|,
name|valaddr
argument_list|,
name|offset
argument_list|,
name|address
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|,
name|dont_print_vb
argument_list|)
expr_stmt|;
comment|/* Second, print out data fields */
comment|/* If there are no data fields, or if the only field is the    * vtbl pointer, skip this part */
if|if
condition|(
operator|(
name|len
operator|==
name|n_baseclasses
operator|)
operator|||
operator|(
operator|(
name|len
operator|-
name|n_baseclasses
operator|==
literal|1
operator|)
operator|&&
name|TYPE_HAS_VTABLE
argument_list|(
name|type
argument_list|)
operator|&&
name|STREQN
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|n_baseclasses
argument_list|)
argument_list|,
name|hpacc_vtbl_ptr_name
argument_list|,
literal|5
argument_list|)
operator|)
operator|||
operator|!
name|len
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<No data fields>"
argument_list|)
expr_stmt|;
else|else
block|{
specifier|extern
name|int
name|inspect_it
decl_stmt|;
if|if
condition|(
name|dont_print_statmem
operator|==
literal|0
condition|)
block|{
comment|/* If we're at top level, carve out a completely fresh 	     chunk of the obstack and use that until this particular 	     invocation returns.  */
name|tmp_obstack
operator|=
name|dont_print_statmem_obstack
expr_stmt|;
name|obstack_finish
argument_list|(
operator|&
name|dont_print_statmem_obstack
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|n_baseclasses
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
comment|/* If requested, skip printing of static fields.  */
if|if
condition|(
operator|!
name|static_field_print
operator|&&
name|TYPE_FIELD_STATIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
continue|continue;
comment|/* If a vtable pointer appears, we'll print it out later */
if|if
condition|(
name|TYPE_HAS_VTABLE
argument_list|(
name|type
argument_list|)
operator|&&
name|STREQN
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|hpacc_vtbl_ptr_name
argument_list|,
literal|5
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|fields_seen
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n_baseclasses
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|pretty
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"members of "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|type_name_no_tag
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|": "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
name|fields_seen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pretty
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wrap_here
argument_list|(
name|n_spaces
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inspect_it
condition|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
name|fputs_filtered
argument_list|(
literal|"\"( ptr \""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|"\"( nodef \""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FIELD_STATIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
name|fputs_filtered
argument_list|(
literal|"static "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_symbol_filtered
argument_list|(
name|stream
argument_list|,
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|language_cplus
argument_list|,
name|DMGL_PARAMS
operator||
name|DMGL_ANSI
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"\" \""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_symbol_filtered
argument_list|(
name|stream
argument_list|,
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|language_cplus
argument_list|,
name|DMGL_PARAMS
operator||
name|DMGL_ANSI
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"\") \""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|annotate_field_begin
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FIELD_STATIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
name|fputs_filtered
argument_list|(
literal|"static "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_symbol_filtered
argument_list|(
name|stream
argument_list|,
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|language_cplus
argument_list|,
name|DMGL_PARAMS
operator||
name|DMGL_ANSI
argument_list|)
expr_stmt|;
name|annotate_field_name_end
argument_list|()
expr_stmt|;
comment|/* do not print leading '=' in case of anonymous unions */
if|if
condition|(
name|strcmp
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
literal|""
argument_list|)
condition|)
name|fputs_filtered
argument_list|(
literal|" = "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|annotate_field_value
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TYPE_FIELD_STATIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|&&
name|TYPE_FIELD_PACKED
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|value_ptr
name|v
decl_stmt|;
comment|/* Bitfields require special handling, especially due to byte 		 order problems.  */
if|if
condition|(
name|TYPE_FIELD_IGNORE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"<optimized out or zero length>"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|v
operator|=
name|value_from_longest
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|unpack_field_as_long
argument_list|(
name|type
argument_list|,
name|valaddr
operator|+
name|offset
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|val_print
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|v
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|TYPE_FIELD_IGNORE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"<optimized out or zero length>"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_FIELD_STATIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|value_ptr
name|v
init|=
name|value_static_field
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|==
name|NULL
condition|)
name|fputs_filtered
argument_list|(
literal|"<optimized out>"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|cp_print_static_field
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|v
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val_print
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|valaddr
argument_list|,
name|offset
operator|+
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|/
literal|8
argument_list|,
name|address
operator|+
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|/
literal|8
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
block|}
block|}
name|annotate_field_end
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dont_print_statmem
operator|==
literal|0
condition|)
block|{
comment|/* Free the space used to deal with the printing 	     of the members from top level.  */
name|obstack_free
argument_list|(
operator|&
name|dont_print_statmem_obstack
argument_list|,
name|last_dont_print
argument_list|)
expr_stmt|;
name|dont_print_statmem_obstack
operator|=
name|tmp_obstack
expr_stmt|;
block|}
if|if
condition|(
name|pretty
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* if there are data fields */
comment|/* Now print out the virtual table pointer if there is one */
if|if
condition|(
name|TYPE_HAS_VTABLE
argument_list|(
name|type
argument_list|)
operator|&&
name|STREQN
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|n_baseclasses
argument_list|)
argument_list|,
name|hpacc_vtbl_ptr_name
argument_list|,
literal|5
argument_list|)
condition|)
block|{
name|value_ptr
name|v
decl_stmt|;
comment|/* First get the virtual table pointer and print it out*/
if|#
directive|if
literal|0
block|fputs_filtered ("__vfp = ", stream);
endif|#
directive|endif
name|fputs_filtered
argument_list|(
literal|", Virtual table at "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* pai: FIXME 32x64 problem? */
comment|/* Not sure what the best notation is in the case where there is no          baseclass name.  */
name|v
operator|=
name|value_from_longest
argument_list|(
name|lookup_pointer_type
argument_list|(
name|builtin_type_unsigned_long
argument_list|)
argument_list|,
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|(
name|valaddr
operator|+
name|offset
operator|)
argument_list|)
expr_stmt|;
name|val_print
argument_list|(
name|VALUE_TYPE
argument_list|(
name|v
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|v
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
name|fields_seen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|vtblprint
condition|)
block|{
comment|/* Print out function pointers in vtable. */
comment|/* FIXME: then-clause is for non-RRBC layout of virtual            * table.  The RRBC case in the else-clause is yet to be            * implemented.  The if (1) below should be changed to a            * test for whether the executable we have was compiled            * with a version of HP aCC that doesn't have RRBC            * support. */
if|if
condition|(
literal|1
condition|)
block|{
comment|/* no RRBC support; function pointers embedded directly in vtable */
name|int
name|vfuncs
init|=
name|count_virtual_fns
argument_list|(
name|real_type
argument_list|)
decl_stmt|;
name|fputs_filtered
argument_list|(
literal|" {"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* FIXME : doesn't work at present */
if|#
directive|if
literal|0
block|fprintf_filtered (stream, "%d entr%s: ", vfuncs, vfuncs == 1 ? "y" : "ies");
else|#
directive|else
name|fputs_filtered
argument_list|(
literal|"not implemented"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* recursive function that prints all virtual function entries */
if|#
directive|if
literal|0
block|cp_print_hpacc_virtual_table_entries (real_type,&vfuncs, v, stream, format, recurse, pretty);
endif|#
directive|endif
name|fputs_filtered
argument_list|(
literal|"}"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
comment|/* non-RRBC case */
else|else
block|{
comment|/* FIXME -- seem comments above */
comment|/* RRBC support present; function pointers are found                * by indirection through the class segment entries. */
block|}
comment|/* RRBC case */
block|}
comment|/* if vtblprint */
if|if
condition|(
name|pretty
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* if vtable exists */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Special val_print routine to avoid printing multiple copies of virtual    baseclasses.  */
end_comment

begin_function
specifier|static
name|void
name|cp_print_value
parameter_list|(
name|type
parameter_list|,
name|real_type
parameter_list|,
name|valaddr
parameter_list|,
name|offset
parameter_list|,
name|address
parameter_list|,
name|stream
parameter_list|,
name|format
parameter_list|,
name|recurse
parameter_list|,
name|pretty
parameter_list|,
name|dont_print_vb
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|type
modifier|*
name|real_type
decl_stmt|;
name|char
modifier|*
name|valaddr
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|CORE_ADDR
name|address
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|format
decl_stmt|;
name|int
name|recurse
decl_stmt|;
name|enum
name|val_prettyprint
name|pretty
decl_stmt|;
name|struct
name|type
modifier|*
modifier|*
name|dont_print_vb
decl_stmt|;
block|{
name|struct
name|obstack
name|tmp_obstack
decl_stmt|;
name|struct
name|type
modifier|*
modifier|*
name|last_dont_print
init|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|obstack_next_free
argument_list|(
operator|&
name|dont_print_vb_obstack
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|dont_print_vb
operator|==
literal|0
condition|)
block|{
comment|/* If we're at top level, carve out a completely fresh 	 chunk of the obstack and use that until this particular 	 invocation returns.  */
name|tmp_obstack
operator|=
name|dont_print_vb_obstack
expr_stmt|;
comment|/* Bump up the high-water mark.  Now alpha is omega.  */
name|obstack_finish
argument_list|(
operator|&
name|dont_print_vb_obstack
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|int
name|boffset
decl_stmt|;
name|int
name|skip
decl_stmt|;
name|struct
name|type
modifier|*
name|baseclass
init|=
name|check_typedef
argument_list|(
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|basename
init|=
name|TYPE_NAME
argument_list|(
name|baseclass
argument_list|)
decl_stmt|;
name|char
modifier|*
name|base_valaddr
decl_stmt|;
if|if
condition|(
name|BASETYPE_VIA_VIRTUAL
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|struct
name|type
modifier|*
modifier|*
name|first_dont_print
init|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|dont_print_vb_obstack
argument_list|)
decl_stmt|;
name|int
name|j
init|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|obstack_next_free
argument_list|(
operator|&
name|dont_print_vb_obstack
argument_list|)
operator|-
name|first_dont_print
decl_stmt|;
while|while
condition|(
operator|--
name|j
operator|>=
literal|0
condition|)
if|if
condition|(
name|baseclass
operator|==
name|first_dont_print
index|[
name|j
index|]
condition|)
goto|goto
name|flush_it
goto|;
name|obstack_ptr_grow
argument_list|(
operator|&
name|dont_print_vb_obstack
argument_list|,
name|baseclass
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_HAS_VTABLE
argument_list|(
name|type
argument_list|)
operator|&&
name|BASETYPE_VIA_VIRTUAL
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
comment|/* Assume HP/Taligent runtime convention */
name|find_rt_vbase_offset
argument_list|(
name|type
argument_list|,
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|valaddr
argument_list|,
name|offset
argument_list|,
operator|&
name|boffset
argument_list|,
operator|&
name|skip
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip
operator|>=
literal|0
condition|)
name|error
argument_list|(
literal|"Virtual base class offset not found from vtable while printing"
argument_list|)
expr_stmt|;
name|base_valaddr
operator|=
name|valaddr
expr_stmt|;
block|}
else|else
block|{
name|boffset
operator|=
name|baseclass_offset
argument_list|(
name|type
argument_list|,
name|i
argument_list|,
name|valaddr
operator|+
name|offset
argument_list|,
name|address
operator|+
name|offset
argument_list|)
expr_stmt|;
name|skip
operator|=
operator|(
operator|(
name|boffset
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|boffset
operator|+
name|offset
operator|)
operator|<
literal|0
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|BASETYPE_VIA_VIRTUAL
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
comment|/* The virtual base class pointer might have been clobbered by the 	         user program. Make sure that it still points to a valid memory 	         location.  */
if|if
condition|(
name|boffset
operator|!=
operator|-
literal|1
operator|&&
operator|(
operator|(
name|boffset
operator|+
name|offset
operator|)
operator|<
literal|0
operator|||
operator|(
name|boffset
operator|+
name|offset
operator|)
operator|>=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|)
condition|)
block|{
name|base_valaddr
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|TYPE_LENGTH
argument_list|(
name|baseclass
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|address
operator|+
name|boffset
argument_list|,
name|base_valaddr
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|baseclass
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|skip
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|base_valaddr
operator|=
name|valaddr
expr_stmt|;
block|}
else|else
name|base_valaddr
operator|=
name|valaddr
expr_stmt|;
block|}
comment|/* now do the printing */
if|if
condition|(
name|pretty
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
literal|"<"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* Not sure what the best notation is in the case where there is no 	 baseclass name.  */
name|fputs_filtered
argument_list|(
name|basename
condition|?
name|basename
else|:
literal|""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"> = "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip
operator|>=
literal|1
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<invalid address>"
argument_list|)
expr_stmt|;
else|else
name|cp_print_value_fields
argument_list|(
name|baseclass
argument_list|,
name|real_type
argument_list|,
name|base_valaddr
argument_list|,
name|offset
operator|+
name|boffset
argument_list|,
name|address
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|,
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|dont_print_vb_obstack
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|flush_it
label|:
empty_stmt|;
block|}
if|if
condition|(
name|dont_print_vb
operator|==
literal|0
condition|)
block|{
comment|/* Free the space used to deal with the printing 	 of this type from top level.  */
name|obstack_free
argument_list|(
operator|&
name|dont_print_vb_obstack
argument_list|,
name|last_dont_print
argument_list|)
expr_stmt|;
comment|/* Reset watermark so that we can continue protecting 	 ourselves from whatever we were protecting ourselves.  */
name|dont_print_vb_obstack
operator|=
name|tmp_obstack
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print value of a static member.    To avoid infinite recursion when printing a class that contains    a static instance of the class, we keep the addresses of all printed    static member classes in an obstack and refuse to print them more    than once.     VAL contains the value to print, TYPE, STREAM, RECURSE, and PRETTY    have the same meanings as in c_val_print.  */
end_comment

begin_function
specifier|static
name|void
name|cp_print_static_field
parameter_list|(
name|type
parameter_list|,
name|val
parameter_list|,
name|stream
parameter_list|,
name|format
parameter_list|,
name|recurse
parameter_list|,
name|pretty
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|value_ptr
name|val
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|format
decl_stmt|;
name|int
name|recurse
decl_stmt|;
name|enum
name|val_prettyprint
name|pretty
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
condition|)
block|{
name|CORE_ADDR
modifier|*
name|first_dont_print
decl_stmt|;
name|int
name|i
decl_stmt|;
name|first_dont_print
operator|=
operator|(
name|CORE_ADDR
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|dont_print_statmem_obstack
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
name|CORE_ADDR
operator|*
operator|)
name|obstack_next_free
argument_list|(
operator|&
name|dont_print_statmem_obstack
argument_list|)
operator|-
name|first_dont_print
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|==
name|first_dont_print
index|[
name|i
index|]
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"<same as static member of an already seen type>"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|obstack_grow
argument_list|(
operator|&
name|dont_print_statmem_obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|cp_print_value_fields
argument_list|(
name|type
argument_list|,
name|type
argument_list|,
name|VALUE_CONTENTS_ALL
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_EMBEDDED_OFFSET
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|val_print
argument_list|(
name|type
argument_list|,
name|VALUE_CONTENTS_ALL
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_EMBEDDED_OFFSET
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cp_print_class_member
parameter_list|(
name|valaddr
parameter_list|,
name|domain
parameter_list|,
name|stream
parameter_list|,
name|prefix
parameter_list|)
name|char
modifier|*
name|valaddr
decl_stmt|;
name|struct
name|type
modifier|*
name|domain
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
block|{
comment|/* VAL is a byte offset into the structure type DOMAIN.      Find the name of the field for that offset and      print it.  */
name|int
name|extra
init|=
literal|0
decl_stmt|;
name|int
name|bits
init|=
literal|0
decl_stmt|;
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|len
init|=
name|TYPE_NFIELDS
argument_list|(
name|domain
argument_list|)
decl_stmt|;
comment|/* @@ Make VAL into bit offset */
comment|/* Note: HP aCC generates offsets that are the real byte offsets added      to a constant bias 0x20000000 (1<< 29).  This constant bias gets      shifted out in the code below -- joyous happenstance! */
comment|/* Note: HP cfront uses a constant bias of 1; if we support this      compiler ever, we will have to adjust the computation below */
name|LONGEST
name|val
init|=
name|unpack_long
argument_list|(
name|builtin_type_int
argument_list|,
name|valaddr
argument_list|)
operator|<<
literal|3
decl_stmt|;
for|for
control|(
name|i
operator|=
name|TYPE_N_BASECLASSES
argument_list|(
name|domain
argument_list|)
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|int
name|bitpos
init|=
name|TYPE_FIELD_BITPOS
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|QUIT
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|bitpos
condition|)
break|break;
if|if
condition|(
name|val
operator|<
name|bitpos
operator|&&
name|i
operator|!=
literal|0
condition|)
block|{
comment|/* Somehow pointing into a field.  */
name|i
operator|-=
literal|1
expr_stmt|;
name|extra
operator|=
operator|(
name|val
operator|-
name|TYPE_FIELD_BITPOS
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|extra
operator|&
literal|0x7
condition|)
name|bits
operator|=
literal|1
expr_stmt|;
else|else
name|extra
operator|>>=
literal|3
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|<
name|len
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|name
operator|=
name|type_name_no_tag
argument_list|(
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|fputs_filtered
argument_list|(
name|name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|c_type_print_base
argument_list|(
name|domain
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" + %d bytes"
argument_list|,
name|extra
argument_list|)
expr_stmt|;
if|if
condition|(
name|bits
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" (offset in bits)"
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|val
operator|>>
literal|3
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function prints out virtual table entries for a class; it  * recurses on the base classes to find all virtual functions  * available in a class.  *  * pai/1997-05-21 Note: As the name suggests, it's currently  * implemented for HP aCC runtime only. g++ objects are handled  * differently and I have made no attempt to fold that logic in  * here. The runtime layout is different for the two cases.  Also,  * this currently has only the code for non-RRBC layouts generated by  * the HP aCC compiler; RRBC code is stubbed out and will have to be  * added later. */
end_comment

begin_function
specifier|static
name|void
name|cp_print_hpacc_virtual_table_entries
parameter_list|(
name|type
parameter_list|,
name|vfuncs
parameter_list|,
name|v
parameter_list|,
name|stream
parameter_list|,
name|format
parameter_list|,
name|recurse
parameter_list|,
name|pretty
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
modifier|*
name|vfuncs
decl_stmt|;
name|value_ptr
name|v
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|format
decl_stmt|;
name|int
name|recurse
decl_stmt|;
name|enum
name|val_prettyprint
name|pretty
decl_stmt|;
block|{
name|int
name|fn
decl_stmt|,
name|oi
decl_stmt|;
comment|/* pai: FIXME this function doesn't work. It should handle a given    * virtual function only once (latest redefinition in class hierarchy)    */
comment|/* Recursion on other classes that can share the same vtable */
name|struct
name|type
modifier|*
name|pbc
init|=
name|primary_base_class
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|pbc
condition|)
name|cp_print_hpacc_virtual_table_entries
argument_list|(
name|pbc
argument_list|,
name|vfuncs
argument_list|,
name|v
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
comment|/* Now deal with vfuncs declared in this class */
for|for
control|(
name|fn
operator|=
literal|0
init|;
name|fn
operator|<
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
condition|;
name|fn
operator|++
control|)
for|for
control|(
name|oi
operator|=
literal|0
init|;
name|oi
operator|<
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|type
argument_list|,
name|fn
argument_list|)
condition|;
name|oi
operator|++
control|)
if|if
condition|(
name|TYPE_FN_FIELD_VIRTUAL_P
argument_list|(
name|TYPE_FN_FIELDLIST1
argument_list|(
name|type
argument_list|,
name|fn
argument_list|)
argument_list|,
name|oi
argument_list|)
condition|)
block|{
name|char
modifier|*
name|vf_name
decl_stmt|;
comment|/* virtual function offset */
name|int
name|vx
init|=
name|TYPE_FN_FIELD_VOFFSET
argument_list|(
name|TYPE_FN_FIELDLIST1
argument_list|(
name|type
argument_list|,
name|fn
argument_list|)
argument_list|,
name|oi
argument_list|)
operator|-
literal|1
decl_stmt|;
comment|/* Get the address of the vfunction entry */
name|value_ptr
name|vf
init|=
name|value_copy
argument_list|(
name|v
argument_list|)
decl_stmt|;
if|if
condition|(
name|VALUE_LAZY
argument_list|(
name|vf
argument_list|)
condition|)
operator|(
name|void
operator|)
name|value_fetch_lazy
argument_list|(
name|vf
argument_list|)
expr_stmt|;
name|vf
operator|->
name|aligner
operator|.
name|contents
index|[
literal|0
index|]
operator|+=
literal|4
operator|*
operator|(
name|HP_ACC_VFUNC_START
operator|+
name|vx
operator|)
expr_stmt|;
comment|/* adjust by offset */
name|vf
operator|=
name|value_ind
argument_list|(
name|vf
argument_list|)
expr_stmt|;
comment|/* get the entry */
name|VALUE_TYPE
argument_list|(
name|vf
argument_list|)
operator|=
name|VALUE_TYPE
argument_list|(
name|v
argument_list|)
expr_stmt|;
comment|/* make it a pointer */
comment|/* print out the entry */
name|val_print
argument_list|(
name|VALUE_TYPE
argument_list|(
name|vf
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|vf
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
name|vf_name
operator|=
name|cplus_demangle
argument_list|(
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|TYPE_FN_FIELDLIST1
argument_list|(
name|type
argument_list|,
name|fn
argument_list|)
argument_list|,
name|oi
argument_list|)
argument_list|,
name|DMGL_ARM
argument_list|)
expr_stmt|;
comment|/* pai: (temp) FIXME Maybe this should be DMGL_ANSI */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" %s"
argument_list|,
name|vf_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
operator|(
operator|*
name|vfuncs
operator|)
operator|>
literal|0
condition|)
name|fputs_filtered
argument_list|(
literal|", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|_initialize_cp_valprint
parameter_list|()
block|{
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"static-members"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|static_field_print
argument_list|,
literal|"Set printing of C++ static members."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
comment|/* Turn on printing of static fields.  */
name|static_field_print
operator|=
literal|1
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"vtbl"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|vtblprint
argument_list|,
literal|"Set printing of C++ virtual function tables."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"object"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|objectprint
argument_list|,
literal|"Set printing of object's derived type based on vtable info."
argument_list|,
operator|&
name|setprintlist
argument_list|)
argument_list|,
operator|&
name|showprintlist
argument_list|)
expr_stmt|;
comment|/* Give people the defaults which they are used to.  */
name|objectprint
operator|=
literal|0
expr_stmt|;
name|vtblprint
operator|=
literal|0
expr_stmt|;
name|obstack_begin
argument_list|(
operator|&
name|dont_print_vb_obstack
argument_list|,
literal|32
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|obstack_specify_allocation
argument_list|(
operator|&
name|dont_print_statmem_obstack
argument_list|,
literal|32
operator|*
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
argument_list|,
name|xmalloc
argument_list|,
name|free
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

