begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Abstraction of GNU v3 abi.    Contributed by Jim Blandy<jimb@redhat.com>     Copyright 2001, 2002, 2003 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or    modify it under the terms of the GNU General Public License as    published by the Free Software Foundation; either version 2 of the    License, or (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"cp-abi.h"
end_include

begin_include
include|#
directive|include
file|"cp-support.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_decl_stmt
specifier|static
name|struct
name|cp_abi_ops
name|gnu_v3_abi_ops
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|gnuv3_is_vtable_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_ZTV"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gnuv3_is_operator_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"operator"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* To help us find the components of a vtable, we build ourselves a    GDB type object representing the vtable structure.  Following the    V3 ABI, it goes something like this:     struct gdb_gnu_v3_abi_vtable {       / * An array of virtual call and virtual base offsets.  The real          length of this array depends on the class hierarchy; we use          negative subscripts to access the elements.  Yucky, but          better than the alternatives.  * /      ptrdiff_t vcall_and_vbase_offsets[0];       / * The offset from a virtual pointer referring to this table          to the top of the complete object.  * /      ptrdiff_t offset_to_top;       / * The type_info pointer for this class.  This is really a          std::type_info *, but GDB doesn't really look at the          type_info object itself, so we don't bother to get the type          exactly right.  * /      void *type_info;       / * Virtual table pointers in objects point here.  * /       / * Virtual function pointers.  Like the vcall/vbase array, the          real length of this table depends on the class hierarchy.  * /      void (*virtual_functions[0]) ();     };     The catch, of course, is that the exact layout of this table    depends on the ABI --- word size, endianness, alignment, etc.  So    the GDB type object is actually a per-architecture kind of thing.     vtable_type_gdbarch_data is a gdbarch per-architecture data pointer    which refers to the struct type * for this structure, laid out    appropriately for the architecture.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|gdbarch_data
modifier|*
name|vtable_type_gdbarch_data
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Human-readable names for the numbers of the fields above.  */
end_comment

begin_enum
enum|enum
block|{
name|vtable_field_vcall_and_vbase_offsets
block|,
name|vtable_field_offset_to_top
block|,
name|vtable_field_type_info
block|,
name|vtable_field_virtual_functions
block|}
enum|;
end_enum

begin_comment
comment|/* Return a GDB type representing `struct gdb_gnu_v3_abi_vtable',    described above, laid out appropriately for ARCH.     We use this function as the gdbarch per-architecture data    initialization function.  We assume that the gdbarch framework    calls the per-architecture data initialization functions after it    sets current_gdbarch to the new architecture.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|build_gdb_vtable_type
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|arch
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|t
decl_stmt|;
name|struct
name|field
modifier|*
name|field_list
decl_stmt|,
modifier|*
name|field
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|struct
name|type
modifier|*
name|void_ptr_type
init|=
name|lookup_pointer_type
argument_list|(
name|builtin_type_void
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|ptr_to_void_fn_type
init|=
name|lookup_pointer_type
argument_list|(
name|lookup_function_type
argument_list|(
name|builtin_type_void
argument_list|)
argument_list|)
decl_stmt|;
comment|/* ARCH can't give us the true ptrdiff_t type, so we guess.  */
name|struct
name|type
modifier|*
name|ptrdiff_type
init|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_PTR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"ptrdiff_t"
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* We assume no padding is necessary, since GDB doesn't know      anything about alignment at the moment.  If this assumption bites      us, we should add a gdbarch method which, given a type, returns      the alignment that type requires, and then use that here.  */
comment|/* Build the field list.  */
name|field_list
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|field
index|[
literal|4
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|field_list
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
index|[
literal|4
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|field
operator|=
operator|&
name|field_list
index|[
literal|0
index|]
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* ptrdiff_t vcall_and_vbase_offsets[0]; */
name|FIELD_NAME
argument_list|(
operator|*
name|field
argument_list|)
operator|=
literal|"vcall_and_vbase_offsets"
expr_stmt|;
name|FIELD_TYPE
argument_list|(
operator|*
name|field
argument_list|)
operator|=
name|create_array_type
argument_list|(
literal|0
argument_list|,
name|ptrdiff_type
argument_list|,
name|create_range_type
argument_list|(
literal|0
argument_list|,
name|builtin_type_int
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|FIELD_BITPOS
argument_list|(
operator|*
name|field
argument_list|)
operator|=
name|offset
operator|*
name|TARGET_CHAR_BIT
expr_stmt|;
name|offset
operator|+=
name|TYPE_LENGTH
argument_list|(
name|FIELD_TYPE
argument_list|(
operator|*
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|field
operator|++
expr_stmt|;
comment|/* ptrdiff_t offset_to_top; */
name|FIELD_NAME
argument_list|(
operator|*
name|field
argument_list|)
operator|=
literal|"offset_to_top"
expr_stmt|;
name|FIELD_TYPE
argument_list|(
operator|*
name|field
argument_list|)
operator|=
name|ptrdiff_type
expr_stmt|;
name|FIELD_BITPOS
argument_list|(
operator|*
name|field
argument_list|)
operator|=
name|offset
operator|*
name|TARGET_CHAR_BIT
expr_stmt|;
name|offset
operator|+=
name|TYPE_LENGTH
argument_list|(
name|FIELD_TYPE
argument_list|(
operator|*
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|field
operator|++
expr_stmt|;
comment|/* void *type_info; */
name|FIELD_NAME
argument_list|(
operator|*
name|field
argument_list|)
operator|=
literal|"type_info"
expr_stmt|;
name|FIELD_TYPE
argument_list|(
operator|*
name|field
argument_list|)
operator|=
name|void_ptr_type
expr_stmt|;
name|FIELD_BITPOS
argument_list|(
operator|*
name|field
argument_list|)
operator|=
name|offset
operator|*
name|TARGET_CHAR_BIT
expr_stmt|;
name|offset
operator|+=
name|TYPE_LENGTH
argument_list|(
name|FIELD_TYPE
argument_list|(
operator|*
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|field
operator|++
expr_stmt|;
comment|/* void (*virtual_functions[0]) (); */
name|FIELD_NAME
argument_list|(
operator|*
name|field
argument_list|)
operator|=
literal|"virtual_functions"
expr_stmt|;
name|FIELD_TYPE
argument_list|(
operator|*
name|field
argument_list|)
operator|=
name|create_array_type
argument_list|(
literal|0
argument_list|,
name|ptr_to_void_fn_type
argument_list|,
name|create_range_type
argument_list|(
literal|0
argument_list|,
name|builtin_type_int
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|FIELD_BITPOS
argument_list|(
operator|*
name|field
argument_list|)
operator|=
name|offset
operator|*
name|TARGET_CHAR_BIT
expr_stmt|;
name|offset
operator|+=
name|TYPE_LENGTH
argument_list|(
name|FIELD_TYPE
argument_list|(
operator|*
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|field
operator|++
expr_stmt|;
comment|/* We assumed in the allocation above that there were four fields.  */
name|gdb_assert
argument_list|(
name|field
operator|==
operator|(
name|field_list
operator|+
literal|4
operator|)
argument_list|)
expr_stmt|;
name|t
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_STRUCT
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|field
operator|-
name|field_list
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|t
argument_list|)
operator|=
name|field_list
expr_stmt|;
name|TYPE_TAG_NAME
argument_list|(
name|t
argument_list|)
operator|=
literal|"gdb_gnu_v3_abi_vtable"
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Return the offset from the start of the imaginary `struct    gdb_gnu_v3_abi_vtable' object to the vtable's "address point"    (i.e., where objects' virtual table pointers point).  */
end_comment

begin_function
specifier|static
name|int
name|vtable_address_point_offset
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|vtable_type
init|=
name|gdbarch_data
argument_list|(
name|current_gdbarch
argument_list|,
name|vtable_type_gdbarch_data
argument_list|)
decl_stmt|;
return|return
operator|(
name|TYPE_FIELD_BITPOS
argument_list|(
name|vtable_type
argument_list|,
name|vtable_field_virtual_functions
argument_list|)
operator|/
name|TARGET_CHAR_BIT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|type
modifier|*
name|gnuv3_rtti_type
parameter_list|(
name|struct
name|value
modifier|*
name|value
parameter_list|,
name|int
modifier|*
name|full_p
parameter_list|,
name|int
modifier|*
name|top_p
parameter_list|,
name|int
modifier|*
name|using_enc_p
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|vtable_type
init|=
name|gdbarch_data
argument_list|(
name|current_gdbarch
argument_list|,
name|vtable_type_gdbarch_data
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|value_type
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|vtable_address
decl_stmt|;
name|struct
name|value
modifier|*
name|vtable
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|vtable_symbol
decl_stmt|;
specifier|const
name|char
modifier|*
name|vtable_symbol_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|class_name
decl_stmt|;
name|struct
name|type
modifier|*
name|run_time_type
decl_stmt|;
name|struct
name|type
modifier|*
name|base_type
decl_stmt|;
name|LONGEST
name|offset_to_top
decl_stmt|;
comment|/* We only have RTTI for class objects.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|value_type
argument_list|)
operator|!=
name|TYPE_CODE_CLASS
condition|)
return|return
name|NULL
return|;
comment|/* If we can't find the virtual table pointer for value_type, we      can't find the RTTI.  */
name|fill_in_vptr_fieldno
argument_list|(
name|value_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_VPTR_FIELDNO
argument_list|(
name|value_type
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|using_enc_p
condition|)
operator|*
name|using_enc_p
operator|=
literal|0
expr_stmt|;
comment|/* Fetch VALUE's virtual table pointer, and tweak it to point at      an instance of our imaginary gdb_gnu_v3_abi_vtable structure.  */
name|base_type
operator|=
name|check_typedef
argument_list|(
name|TYPE_VPTR_BASETYPE
argument_list|(
name|value_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|value_type
operator|!=
name|base_type
condition|)
block|{
name|value
operator|=
name|value_cast
argument_list|(
name|base_type
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|using_enc_p
condition|)
operator|*
name|using_enc_p
operator|=
literal|1
expr_stmt|;
block|}
name|vtable_address
operator|=
name|value_as_address
argument_list|(
name|value_field
argument_list|(
name|value
argument_list|,
name|TYPE_VPTR_FIELDNO
argument_list|(
name|value_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|vtable
operator|=
name|value_at_lazy
argument_list|(
name|vtable_type
argument_list|,
name|vtable_address
operator|-
name|vtable_address_point_offset
argument_list|()
argument_list|,
name|VALUE_BFD_SECTION
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find the linker symbol for this vtable.  */
name|vtable_symbol
operator|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|VALUE_ADDRESS
argument_list|(
name|vtable
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|vtable
argument_list|)
operator|+
name|VALUE_EMBEDDED_OFFSET
argument_list|(
name|vtable
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vtable_symbol
condition|)
return|return
name|NULL
return|;
comment|/* The symbol's demangled name should be something like "vtable for      CLASS", where CLASS is the name of the run-time type of VALUE.      If we didn't like this approach, we could instead look in the      type_info object itself to get the class name.  But this way      should work just as well, and doesn't read target memory.  */
name|vtable_symbol_name
operator|=
name|SYMBOL_DEMANGLED_NAME
argument_list|(
name|vtable_symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|vtable_symbol_name
operator|==
name|NULL
operator|||
name|strncmp
argument_list|(
name|vtable_symbol_name
argument_list|,
literal|"vtable for "
argument_list|,
literal|11
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"can't find linker symbol for virtual table for `%s' value"
argument_list|,
name|TYPE_NAME
argument_list|(
name|value_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vtable_symbol_name
condition|)
name|warning
argument_list|(
literal|"  found `%s' instead"
argument_list|,
name|vtable_symbol_name
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|class_name
operator|=
name|vtable_symbol_name
operator|+
literal|11
expr_stmt|;
comment|/* Try to look up the class name as a type name.  */
comment|/* FIXME: chastain/2003-11-26: block=NULL is bogus.  See pr gdb/1465. */
name|run_time_type
operator|=
name|cp_lookup_rtti_type
argument_list|(
name|class_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|run_time_type
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Get the offset from VALUE to the top of the complete object.      NOTE: this is the reverse of the meaning of *TOP_P.  */
name|offset_to_top
operator|=
name|value_as_long
argument_list|(
name|value_field
argument_list|(
name|vtable
argument_list|,
name|vtable_field_offset_to_top
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|full_p
condition|)
operator|*
name|full_p
operator|=
operator|(
operator|-
name|offset_to_top
operator|==
name|VALUE_EMBEDDED_OFFSET
argument_list|(
name|value
argument_list|)
operator|&&
operator|(
name|TYPE_LENGTH
argument_list|(
name|VALUE_ENCLOSING_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
operator|>=
name|TYPE_LENGTH
argument_list|(
name|run_time_type
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|top_p
condition|)
operator|*
name|top_p
operator|=
operator|-
name|offset_to_top
expr_stmt|;
return|return
name|run_time_type
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|value
modifier|*
name|gnuv3_virtual_fn_field
parameter_list|(
name|struct
name|value
modifier|*
modifier|*
name|value_p
parameter_list|,
name|struct
name|fn_field
modifier|*
name|f
parameter_list|,
name|int
name|j
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|vtable_type
init|=
name|gdbarch_data
argument_list|(
name|current_gdbarch
argument_list|,
name|vtable_type_gdbarch_data
argument_list|)
decl_stmt|;
name|struct
name|value
modifier|*
name|value
init|=
operator|*
name|value_p
decl_stmt|;
name|struct
name|type
modifier|*
name|value_type
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|value
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|vfn_base
decl_stmt|;
name|CORE_ADDR
name|vtable_address
decl_stmt|;
name|struct
name|value
modifier|*
name|vtable
decl_stmt|;
name|struct
name|value
modifier|*
name|vfn
decl_stmt|;
comment|/* Some simple sanity checks.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|value_type
argument_list|)
operator|!=
name|TYPE_CODE_CLASS
condition|)
name|error
argument_list|(
literal|"Only classes can have virtual functions."
argument_list|)
expr_stmt|;
comment|/* Find the base class that defines this virtual function.  */
name|vfn_base
operator|=
name|TYPE_FN_FIELD_FCONTEXT
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vfn_base
condition|)
comment|/* In programs compiled with G++ version 1, the debug info doesn't        say which base class defined the virtual function.  We'll guess        it's the same base class that has our vtable; this is wrong for        multiple inheritance, but it's better than nothing.  */
name|vfn_base
operator|=
name|TYPE_VPTR_BASETYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* This type may have been defined before its virtual function table      was.  If so, fill in the virtual function table entry for the      type now.  */
if|if
condition|(
name|TYPE_VPTR_FIELDNO
argument_list|(
name|vfn_base
argument_list|)
operator|<
literal|0
condition|)
name|fill_in_vptr_fieldno
argument_list|(
name|vfn_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_VPTR_FIELDNO
argument_list|(
name|vfn_base
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"Could not find virtual table pointer for class \"%s\"."
argument_list|,
name|TYPE_TAG_NAME
argument_list|(
name|vfn_base
argument_list|)
condition|?
name|TYPE_TAG_NAME
argument_list|(
name|vfn_base
argument_list|)
else|:
literal|"<unknown>"
argument_list|)
expr_stmt|;
comment|/* Now that we know which base class is defining our virtual      function, cast our value to that baseclass.  This takes care of      any necessary `this' adjustments.  */
if|if
condition|(
name|vfn_base
operator|!=
name|value_type
condition|)
name|value
operator|=
name|value_cast
argument_list|(
name|vfn_base
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Now value is an object of the appropriate base type.  Fetch its      virtual table.  */
comment|/* It might be possible to do this cast at the same time as the above.      Does multiple inheritance affect this?      Can this even trigger, or is TYPE_VPTR_BASETYPE idempotent?   */
if|if
condition|(
name|TYPE_VPTR_BASETYPE
argument_list|(
name|vfn_base
argument_list|)
operator|!=
name|vfn_base
condition|)
name|value
operator|=
name|value_cast
argument_list|(
name|TYPE_VPTR_BASETYPE
argument_list|(
name|vfn_base
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|vtable_address
operator|=
name|value_as_address
argument_list|(
name|value_field
argument_list|(
name|value
argument_list|,
name|TYPE_VPTR_FIELDNO
argument_list|(
name|vfn_base
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|vtable
operator|=
name|value_at_lazy
argument_list|(
name|vtable_type
argument_list|,
name|vtable_address
operator|-
name|vtable_address_point_offset
argument_list|()
argument_list|,
name|VALUE_BFD_SECTION
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fetch the appropriate function pointer from the vtable.  */
name|vfn
operator|=
name|value_subscript
argument_list|(
name|value_field
argument_list|(
name|vtable
argument_list|,
name|vtable_field_virtual_functions
argument_list|)
argument_list|,
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
name|TYPE_FN_FIELD_VOFFSET
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cast the function pointer to the appropriate type.  */
name|vfn
operator|=
name|value_cast
argument_list|(
name|lookup_pointer_type
argument_list|(
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|)
argument_list|,
name|vfn
argument_list|)
expr_stmt|;
comment|/* Is (type)value always numerically the same as (vfn_base)value?      If so we can spare this cast and use one of the ones above.  */
operator|*
name|value_p
operator|=
name|value_addr
argument_list|(
name|value_cast
argument_list|(
name|type
argument_list|,
operator|*
name|value_p
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|vfn
return|;
block|}
end_function

begin_comment
comment|/* Compute the offset of the baseclass which is    the INDEXth baseclass of class TYPE,    for value at VALADDR (in host) at ADDRESS (in target).    The result is the offset of the baseclass value relative    to (the address of)(ARG) + OFFSET.     -1 is returned on error. */
end_comment

begin_function
specifier|static
name|int
name|gnuv3_baseclass_offset
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|index
parameter_list|,
name|char
modifier|*
name|valaddr
parameter_list|,
name|CORE_ADDR
name|address
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|vtable_type
init|=
name|gdbarch_data
argument_list|(
name|current_gdbarch
argument_list|,
name|vtable_type_gdbarch_data
argument_list|)
decl_stmt|;
name|struct
name|value
modifier|*
name|vtable
decl_stmt|;
name|struct
name|type
modifier|*
name|vbasetype
decl_stmt|;
name|struct
name|value
modifier|*
name|offset_val
decl_stmt|,
modifier|*
name|vbase_array
decl_stmt|;
name|CORE_ADDR
name|vtable_address
decl_stmt|;
name|long
name|int
name|cur_base_offset
decl_stmt|,
name|base_offset
decl_stmt|;
comment|/* If it isn't a virtual base, this is easy.  The offset is in the      type definition.  */
if|if
condition|(
operator|!
name|BASETYPE_VIA_VIRTUAL
argument_list|(
name|type
argument_list|,
name|index
argument_list|)
condition|)
return|return
name|TYPE_BASECLASS_BITPOS
argument_list|(
name|type
argument_list|,
name|index
argument_list|)
operator|/
literal|8
return|;
comment|/* To access a virtual base, we need to use the vbase offset stored in      our vtable.  Recent GCC versions provide this information.  If it isn't      available, we could get what we needed from RTTI, or from drawing the      complete inheritance graph based on the debug info.  Neither is      worthwhile.  */
name|cur_base_offset
operator|=
name|TYPE_BASECLASS_BITPOS
argument_list|(
name|type
argument_list|,
name|index
argument_list|)
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|cur_base_offset
operator|>=
operator|-
name|vtable_address_point_offset
argument_list|()
condition|)
name|error
argument_list|(
literal|"Expected a negative vbase offset (old compiler?)"
argument_list|)
expr_stmt|;
name|cur_base_offset
operator|=
name|cur_base_offset
operator|+
name|vtable_address_point_offset
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
operator|-
name|cur_base_offset
operator|)
operator|%
name|TYPE_LENGTH
argument_list|(
name|builtin_type_void_data_ptr
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"Misaligned vbase offset."
argument_list|)
expr_stmt|;
name|cur_base_offset
operator|=
name|cur_base_offset
operator|/
operator|(
operator|(
name|int
operator|)
name|TYPE_LENGTH
argument_list|(
name|builtin_type_void_data_ptr
argument_list|)
operator|)
expr_stmt|;
comment|/* We're now looking for the cur_base_offset'th entry (negative index)      in the vcall_and_vbase_offsets array.  We used to cast the object to      its TYPE_VPTR_BASETYPE, and reference the vtable as TYPE_VPTR_FIELDNO;      however, that cast can not be done without calling baseclass_offset again      if the TYPE_VPTR_BASETYPE is a virtual base class, as described in the      v3 C++ ABI Section 2.4.I.2.b.  Fortunately the ABI guarantees that the      vtable pointer will be located at the beginning of the object, so we can      bypass the casting.  Verify that the TYPE_VPTR_FIELDNO is in fact at the      start of whichever baseclass it resides in, as a sanity measure - iff      we have debugging information for that baseclass.  */
name|vbasetype
operator|=
name|TYPE_VPTR_BASETYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_VPTR_FIELDNO
argument_list|(
name|vbasetype
argument_list|)
operator|<
literal|0
condition|)
name|fill_in_vptr_fieldno
argument_list|(
name|vbasetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_VPTR_FIELDNO
argument_list|(
name|vbasetype
argument_list|)
operator|>=
literal|0
operator|&&
name|TYPE_FIELD_BITPOS
argument_list|(
name|vbasetype
argument_list|,
name|TYPE_VPTR_FIELDNO
argument_list|(
name|vbasetype
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"Illegal vptr offset in class %s"
argument_list|,
name|TYPE_NAME
argument_list|(
name|vbasetype
argument_list|)
condition|?
name|TYPE_NAME
argument_list|(
name|vbasetype
argument_list|)
else|:
literal|"<unknown>"
argument_list|)
expr_stmt|;
name|vtable_address
operator|=
name|value_as_address
argument_list|(
name|value_at_lazy
argument_list|(
name|builtin_type_void_data_ptr
argument_list|,
name|address
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|vtable
operator|=
name|value_at_lazy
argument_list|(
name|vtable_type
argument_list|,
name|vtable_address
operator|-
name|vtable_address_point_offset
argument_list|()
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|offset_val
operator|=
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
name|cur_base_offset
argument_list|)
expr_stmt|;
name|vbase_array
operator|=
name|value_field
argument_list|(
name|vtable
argument_list|,
name|vtable_field_vcall_and_vbase_offsets
argument_list|)
expr_stmt|;
name|base_offset
operator|=
name|value_as_long
argument_list|(
name|value_subscript
argument_list|(
name|vbase_array
argument_list|,
name|offset_val
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|base_offset
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_gnuv3_ops
parameter_list|(
name|void
parameter_list|)
block|{
name|vtable_type_gdbarch_data
operator|=
name|register_gdbarch_data
argument_list|(
name|build_gdb_vtable_type
argument_list|)
expr_stmt|;
name|gnu_v3_abi_ops
operator|.
name|shortname
operator|=
literal|"gnu-v3"
expr_stmt|;
name|gnu_v3_abi_ops
operator|.
name|longname
operator|=
literal|"GNU G++ Version 3 ABI"
expr_stmt|;
name|gnu_v3_abi_ops
operator|.
name|doc
operator|=
literal|"G++ Version 3 ABI"
expr_stmt|;
name|gnu_v3_abi_ops
operator|.
name|is_destructor_name
operator|=
name|is_gnu_v3_mangled_dtor
expr_stmt|;
name|gnu_v3_abi_ops
operator|.
name|is_constructor_name
operator|=
name|is_gnu_v3_mangled_ctor
expr_stmt|;
name|gnu_v3_abi_ops
operator|.
name|is_vtable_name
operator|=
name|gnuv3_is_vtable_name
expr_stmt|;
name|gnu_v3_abi_ops
operator|.
name|is_operator_name
operator|=
name|gnuv3_is_operator_name
expr_stmt|;
name|gnu_v3_abi_ops
operator|.
name|rtti_type
operator|=
name|gnuv3_rtti_type
expr_stmt|;
name|gnu_v3_abi_ops
operator|.
name|virtual_fn_field
operator|=
name|gnuv3_virtual_fn_field
expr_stmt|;
name|gnu_v3_abi_ops
operator|.
name|baseclass_offset
operator|=
name|gnuv3_baseclass_offset
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|initialize_file_ftype
name|_initialize_gnu_v3_abi
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -Wmissing-prototypes */
end_comment

begin_function
name|void
name|_initialize_gnu_v3_abi
parameter_list|(
name|void
parameter_list|)
block|{
name|init_gnuv3_ops
argument_list|()
expr_stmt|;
name|register_cp_abi
argument_list|(
operator|&
name|gnu_v3_abi_ops
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

