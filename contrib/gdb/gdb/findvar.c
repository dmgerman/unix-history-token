begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Find a variable's value in memory, for GDB, the GNU debugger.     Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,    1995, 1996, 1997, 1998, 1999, 2000, 2001, 2003, 2004 Free Software    Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"floatformat.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_comment
comment|/* for overlay functions */
end_comment

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"user-regs.h"
end_include

begin_include
include|#
directive|include
file|"block.h"
end_include

begin_comment
comment|/* Basic byte-swapping routines.  GDB has needed these for a long time...    All extract a target-format integer at ADDR which is LEN bytes long.  */
end_comment

begin_if
if|#
directive|if
name|TARGET_CHAR_BIT
operator|!=
literal|8
operator|||
name|HOST_CHAR_BIT
operator|!=
literal|8
end_if

begin_comment
comment|/* 8 bit characters are a pretty safe assumption these days, so we      assume it throughout all these swapping routines.  If we had to deal with      9 bit characters, we would need to make len be in bits and would have      to re-write these routines...  */
end_comment

begin_function
name|you
name|lose
endif|#
directive|endif
name|LONGEST
name|extract_signed_integer
parameter_list|(
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|LONGEST
name|retval
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|startaddr
init|=
name|addr
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|endaddr
init|=
name|startaddr
operator|+
name|len
decl_stmt|;
if|if
condition|(
name|len
operator|>
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
condition|)
name|error
argument_list|(
literal|"\ That operation is not available on integers of more than %d bytes."
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Start at the most significant end of the integer, and work towards      the least significant.  */
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|)
block|{
name|p
operator|=
name|startaddr
expr_stmt|;
comment|/* Do the sign extension once at the start.  */
name|retval
operator|=
operator|(
operator|(
name|LONGEST
operator|)
operator|*
name|p
operator|^
literal|0x80
operator|)
operator|-
literal|0x80
expr_stmt|;
for|for
control|(
operator|++
name|p
init|;
name|p
operator|<
name|endaddr
condition|;
operator|++
name|p
control|)
name|retval
operator|=
operator|(
name|retval
operator|<<
literal|8
operator|)
operator||
operator|*
name|p
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|endaddr
operator|-
literal|1
expr_stmt|;
comment|/* Do the sign extension once at the start.  */
name|retval
operator|=
operator|(
operator|(
name|LONGEST
operator|)
operator|*
name|p
operator|^
literal|0x80
operator|)
operator|-
literal|0x80
expr_stmt|;
for|for
control|(
operator|--
name|p
init|;
name|p
operator|>=
name|startaddr
condition|;
operator|--
name|p
control|)
name|retval
operator|=
operator|(
name|retval
operator|<<
literal|8
operator|)
operator||
operator|*
name|p
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_function
name|ULONGEST
name|extract_unsigned_integer
parameter_list|(
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|ULONGEST
name|retval
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|startaddr
init|=
name|addr
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|endaddr
init|=
name|startaddr
operator|+
name|len
decl_stmt|;
if|if
condition|(
name|len
operator|>
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|ULONGEST
argument_list|)
condition|)
name|error
argument_list|(
literal|"\ That operation is not available on integers of more than %d bytes."
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|ULONGEST
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Start at the most significant end of the integer, and work towards      the least significant.  */
name|retval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|)
block|{
for|for
control|(
name|p
operator|=
name|startaddr
init|;
name|p
operator|<
name|endaddr
condition|;
operator|++
name|p
control|)
name|retval
operator|=
operator|(
name|retval
operator|<<
literal|8
operator|)
operator||
operator|*
name|p
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|p
operator|=
name|endaddr
operator|-
literal|1
init|;
name|p
operator|>=
name|startaddr
condition|;
operator|--
name|p
control|)
name|retval
operator|=
operator|(
name|retval
operator|<<
literal|8
operator|)
operator||
operator|*
name|p
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Sometimes a long long unsigned integer can be extracted as a    LONGEST value.  This is done so that we can print these values    better.  If this integer can be converted to a LONGEST, this    function returns 1 and sets *PVAL.  Otherwise it returns 0.  */
end_comment

begin_function
name|int
name|extract_long_unsigned_integer
parameter_list|(
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|int
name|orig_len
parameter_list|,
name|LONGEST
modifier|*
name|pval
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|first_addr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
name|orig_len
expr_stmt|;
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|)
block|{
for|for
control|(
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|addr
init|;
name|len
operator|>
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
operator|&&
name|p
operator|<
operator|(
name|char
operator|*
operator|)
name|addr
operator|+
name|orig_len
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
name|len
operator|--
expr_stmt|;
else|else
break|break;
block|}
name|first_addr
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
name|first_addr
operator|=
operator|(
name|char
operator|*
operator|)
name|addr
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|addr
operator|+
name|orig_len
operator|-
literal|1
init|;
name|len
operator|>
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
operator|&&
name|p
operator|>=
operator|(
name|char
operator|*
operator|)
name|addr
condition|;
name|p
operator|--
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
name|len
operator|--
expr_stmt|;
else|else
break|break;
block|}
block|}
if|if
condition|(
name|len
operator|<=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
condition|)
block|{
operator|*
name|pval
operator|=
operator|(
name|LONGEST
operator|)
name|extract_unsigned_integer
argument_list|(
name|first_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Treat the bytes at BUF as a pointer of type TYPE, and return the    address it represents.  */
end_comment

begin_function
name|CORE_ADDR
name|extract_typed_address
parameter_list|(
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_PTR
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_REF
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"extract_typed_address: "
literal|"type is not a pointer or reference"
argument_list|)
expr_stmt|;
return|return
name|POINTER_TO_ADDRESS
argument_list|(
name|type
argument_list|,
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|store_signed_integer
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|int
name|len
parameter_list|,
name|LONGEST
name|val
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|char
modifier|*
name|startaddr
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|addr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|endaddr
init|=
name|startaddr
operator|+
name|len
decl_stmt|;
comment|/* Start at the least significant end of the integer, and work towards      the most significant.  */
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|)
block|{
for|for
control|(
name|p
operator|=
name|endaddr
operator|-
literal|1
init|;
name|p
operator|>=
name|startaddr
condition|;
operator|--
name|p
control|)
block|{
operator|*
name|p
operator|=
name|val
operator|&
literal|0xff
expr_stmt|;
name|val
operator|>>=
literal|8
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|p
operator|=
name|startaddr
init|;
name|p
operator|<
name|endaddr
condition|;
operator|++
name|p
control|)
block|{
operator|*
name|p
operator|=
name|val
operator|&
literal|0xff
expr_stmt|;
name|val
operator|>>=
literal|8
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|store_unsigned_integer
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|int
name|len
parameter_list|,
name|ULONGEST
name|val
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|unsigned
name|char
modifier|*
name|startaddr
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|addr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|endaddr
init|=
name|startaddr
operator|+
name|len
decl_stmt|;
comment|/* Start at the least significant end of the integer, and work towards      the most significant.  */
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|)
block|{
for|for
control|(
name|p
operator|=
name|endaddr
operator|-
literal|1
init|;
name|p
operator|>=
name|startaddr
condition|;
operator|--
name|p
control|)
block|{
operator|*
name|p
operator|=
name|val
operator|&
literal|0xff
expr_stmt|;
name|val
operator|>>=
literal|8
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|p
operator|=
name|startaddr
init|;
name|p
operator|<
name|endaddr
condition|;
operator|++
name|p
control|)
block|{
operator|*
name|p
operator|=
name|val
operator|&
literal|0xff
expr_stmt|;
name|val
operator|>>=
literal|8
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Store the address ADDR as a pointer of type TYPE at BUF, in target    form.  */
end_comment

begin_function
name|void
name|store_typed_address
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_PTR
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_REF
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"store_typed_address: "
literal|"type is not a pointer or reference"
argument_list|)
expr_stmt|;
name|ADDRESS_TO_POINTER
argument_list|(
name|type
argument_list|,
name|buf
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a `value' with the contents of (virtual or cooked) register    REGNUM as found in the specified FRAME.  The register's type is    determined by register_type().     NOTE: returns NULL if register value is not available.  Caller will    check return value or die!  */
end_comment

begin_function
name|struct
name|value
modifier|*
name|value_of_register
parameter_list|(
name|int
name|regnum
parameter_list|,
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|optim
decl_stmt|;
name|struct
name|value
modifier|*
name|reg_val
decl_stmt|;
name|int
name|realnum
decl_stmt|;
name|char
name|raw_buffer
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|enum
name|lval_type
name|lval
decl_stmt|;
comment|/* User registers lie completely outside of the range of normal      registers.  Catch them early so that the target never sees them.  */
if|if
condition|(
name|regnum
operator|>=
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
condition|)
return|return
name|value_of_user_reg
argument_list|(
name|regnum
argument_list|,
name|frame
argument_list|)
return|;
name|frame_register
argument_list|(
name|frame
argument_list|,
name|regnum
argument_list|,
operator|&
name|optim
argument_list|,
operator|&
name|lval
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|realnum
argument_list|,
name|raw_buffer
argument_list|)
expr_stmt|;
comment|/* FIXME: cagney/2002-05-15: This test is just bogus.       It indicates that the target failed to supply a value for a      register because it was "not available" at this time.  Problem      is, the target still has the register and so get saved_register()      may be returning a value saved on the stack.  */
if|if
condition|(
name|register_cached
argument_list|(
name|regnum
argument_list|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
comment|/* register value not available */
name|reg_val
operator|=
name|allocate_value
argument_list|(
name|register_type
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Convert raw data to virtual format if necessary.  */
if|if
condition|(
name|DEPRECATED_REGISTER_CONVERTIBLE_P
argument_list|()
operator|&&
name|DEPRECATED_REGISTER_CONVERTIBLE
argument_list|(
name|regnum
argument_list|)
condition|)
block|{
name|DEPRECATED_REGISTER_CONVERT_TO_VIRTUAL
argument_list|(
name|regnum
argument_list|,
name|register_type
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
argument_list|,
name|raw_buffer
argument_list|,
name|VALUE_CONTENTS_RAW
argument_list|(
name|reg_val
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
operator|==
name|DEPRECATED_REGISTER_VIRTUAL_SIZE
argument_list|(
name|regnum
argument_list|)
condition|)
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|reg_val
argument_list|)
argument_list|,
name|raw_buffer
argument_list|,
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Register \"%s\" (%d) has conflicting raw (%d) and virtual (%d) size"
argument_list|,
name|REGISTER_NAME
argument_list|(
name|regnum
argument_list|)
argument_list|,
name|regnum
argument_list|,
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|,
name|DEPRECATED_REGISTER_VIRTUAL_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|reg_val
argument_list|)
operator|=
name|lval
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|reg_val
argument_list|)
operator|=
name|addr
expr_stmt|;
name|VALUE_REGNO
argument_list|(
name|reg_val
argument_list|)
operator|=
name|regnum
expr_stmt|;
name|VALUE_OPTIMIZED_OUT
argument_list|(
name|reg_val
argument_list|)
operator|=
name|optim
expr_stmt|;
return|return
name|reg_val
return|;
block|}
end_function

begin_comment
comment|/* Given a pointer of type TYPE in target form in BUF, return the    address it represents.  */
end_comment

begin_function
name|CORE_ADDR
name|unsigned_pointer_to_address
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|)
block|{
return|return
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|signed_pointer_to_address
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|)
block|{
return|return
name|extract_signed_integer
argument_list|(
name|buf
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given an address, store it as a pointer of type TYPE in target    format in BUF.  */
end_comment

begin_function
name|void
name|unsigned_address_to_pointer
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|)
block|{
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|address_to_signed_pointer
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|)
block|{
name|store_signed_integer
argument_list|(
name|buf
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Will calling read_var_value or locate_var_value on SYM end    up caring what frame it is being evaluated relative to?  SYM must    be non-NULL.  */
end_comment

begin_function
name|int
name|symbol_read_needs_frame
parameter_list|(
name|struct
name|symbol
modifier|*
name|sym
parameter_list|)
block|{
switch|switch
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
condition|)
block|{
comment|/* All cases listed explicitly so that gcc -Wall will detect it if          we failed to consider one.  */
case|case
name|LOC_COMPUTED
case|:
case|case
name|LOC_COMPUTED_ARG
case|:
comment|/* FIXME: cagney/2004-01-26: It should be possible to 	 unconditionally call the SYMBOL_OPS method when available. 	 Unfortunately DWARF 2 stores the frame-base (instead of the 	 function) location in a function's symbol.  Oops!  For the 	 moment enable this when/where applicable.  */
return|return
name|SYMBOL_OPS
argument_list|(
name|sym
argument_list|)
operator|->
name|read_needs_frame
argument_list|(
name|sym
argument_list|)
return|;
case|case
name|LOC_REGISTER
case|:
case|case
name|LOC_ARG
case|:
case|case
name|LOC_REF_ARG
case|:
case|case
name|LOC_REGPARM
case|:
case|case
name|LOC_REGPARM_ADDR
case|:
case|case
name|LOC_LOCAL
case|:
case|case
name|LOC_LOCAL_ARG
case|:
case|case
name|LOC_BASEREG
case|:
case|case
name|LOC_BASEREG_ARG
case|:
case|case
name|LOC_HP_THREAD_LOCAL_STATIC
case|:
return|return
literal|1
return|;
case|case
name|LOC_UNDEF
case|:
case|case
name|LOC_CONST
case|:
case|case
name|LOC_STATIC
case|:
case|case
name|LOC_INDIRECT
case|:
case|case
name|LOC_TYPEDEF
case|:
case|case
name|LOC_LABEL
case|:
comment|/* Getting the address of a label can be done independently of the block,          even if some *uses* of that address wouldn't work so well without          the right frame.  */
case|case
name|LOC_BLOCK
case|:
case|case
name|LOC_CONST_BYTES
case|:
case|case
name|LOC_UNRESOLVED
case|:
case|case
name|LOC_OPTIMIZED_OUT
case|:
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Given a struct symbol for a variable,    and a stack frame id, read the value of the variable    and return a (pointer to a) struct value containing the value.     If the variable cannot be found, return a zero pointer.    If FRAME is NULL, use the deprecated_selected_frame.  */
end_comment

begin_function
name|struct
name|value
modifier|*
name|read_var_value
parameter_list|(
name|struct
name|symbol
modifier|*
name|var
parameter_list|,
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|v
decl_stmt|;
name|struct
name|type
modifier|*
name|type
init|=
name|SYMBOL_TYPE
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|v
operator|=
name|allocate_value
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|lval_memory
expr_stmt|;
comment|/* The most likely possibility.  */
name|VALUE_BFD_SECTION
argument_list|(
name|v
argument_list|)
operator|=
name|SYMBOL_BFD_SECTION
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* FIXME drow/2003-09-06: this call to the selected frame should be      pushed upwards to the callers.  */
if|if
condition|(
name|frame
operator|==
name|NULL
condition|)
name|frame
operator|=
name|deprecated_safe_get_selected_frame
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|SYMBOL_CLASS
argument_list|(
name|var
argument_list|)
condition|)
block|{
case|case
name|LOC_CONST
case|:
comment|/* Put the constant back in target format.  */
name|store_signed_integer
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|v
argument_list|)
argument_list|,
name|len
argument_list|,
operator|(
name|LONGEST
operator|)
name|SYMBOL_VALUE
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|not_lval
expr_stmt|;
return|return
name|v
return|;
case|case
name|LOC_LABEL
case|:
comment|/* Put the constant back in target format.  */
if|if
condition|(
name|overlay_debugging
condition|)
block|{
name|CORE_ADDR
name|addr
init|=
name|symbol_overlayed_address
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|var
argument_list|)
argument_list|,
name|SYMBOL_BFD_SECTION
argument_list|(
name|var
argument_list|)
argument_list|)
decl_stmt|;
name|store_typed_address
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|v
argument_list|)
argument_list|,
name|type
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
name|store_typed_address
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|v
argument_list|)
argument_list|,
name|type
argument_list|,
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|not_lval
expr_stmt|;
return|return
name|v
return|;
case|case
name|LOC_CONST_BYTES
case|:
block|{
name|char
modifier|*
name|bytes_addr
decl_stmt|;
name|bytes_addr
operator|=
name|SYMBOL_VALUE_BYTES
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|v
argument_list|)
argument_list|,
name|bytes_addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|not_lval
expr_stmt|;
return|return
name|v
return|;
block|}
case|case
name|LOC_STATIC
case|:
if|if
condition|(
name|overlay_debugging
condition|)
name|addr
operator|=
name|symbol_overlayed_address
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|var
argument_list|)
argument_list|,
name|SYMBOL_BFD_SECTION
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|var
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_INDIRECT
case|:
block|{
comment|/* The import slot does not have a real address in it from the 	   dynamic loader (dld.sl on HP-UX), if the target hasn't 	   begun execution yet, so check for that. */
name|CORE_ADDR
name|locaddr
decl_stmt|;
name|struct
name|value
modifier|*
name|loc
decl_stmt|;
if|if
condition|(
operator|!
name|target_has_execution
condition|)
name|error
argument_list|(
literal|"\ Attempt to access variable defined in different shared object or load module when\n\ addresses have not been bound by the dynamic loader. Try again when executable is running."
argument_list|)
expr_stmt|;
name|locaddr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|loc
operator|=
name|value_at
argument_list|(
name|lookup_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|locaddr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|addr
operator|=
name|value_as_address
argument_list|(
name|loc
argument_list|)
expr_stmt|;
block|}
case|case
name|LOC_ARG
case|:
if|if
condition|(
name|frame
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|addr
operator|=
name|get_frame_args_address
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|addr
condition|)
return|return
literal|0
return|;
name|addr
operator|+=
name|SYMBOL_VALUE
argument_list|(
name|var
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_REF_ARG
case|:
block|{
name|struct
name|value
modifier|*
name|ref
decl_stmt|;
name|CORE_ADDR
name|argref
decl_stmt|;
if|if
condition|(
name|frame
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|argref
operator|=
name|get_frame_args_address
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|argref
condition|)
return|return
literal|0
return|;
name|argref
operator|+=
name|SYMBOL_VALUE
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|ref
operator|=
name|value_at
argument_list|(
name|lookup_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|argref
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|addr
operator|=
name|value_as_address
argument_list|(
name|ref
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|LOC_LOCAL
case|:
case|case
name|LOC_LOCAL_ARG
case|:
if|if
condition|(
name|frame
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|addr
operator|=
name|get_frame_locals_address
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|SYMBOL_VALUE
argument_list|(
name|var
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_BASEREG
case|:
case|case
name|LOC_BASEREG_ARG
case|:
case|case
name|LOC_HP_THREAD_LOCAL_STATIC
case|:
block|{
name|struct
name|value
modifier|*
name|regval
decl_stmt|;
name|regval
operator|=
name|value_from_register
argument_list|(
name|lookup_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|SYMBOL_BASEREG
argument_list|(
name|var
argument_list|)
argument_list|,
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|regval
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Value of base register not available."
argument_list|)
expr_stmt|;
name|addr
operator|=
name|value_as_address
argument_list|(
name|regval
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|SYMBOL_VALUE
argument_list|(
name|var
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|LOC_TYPEDEF
case|:
name|error
argument_list|(
literal|"Cannot look up value of a typedef"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_BLOCK
case|:
if|if
condition|(
name|overlay_debugging
condition|)
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|=
name|symbol_overlayed_address
argument_list|(
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|var
argument_list|)
argument_list|)
argument_list|,
name|SYMBOL_BFD_SECTION
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|=
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|v
return|;
case|case
name|LOC_REGISTER
case|:
case|case
name|LOC_REGPARM
case|:
case|case
name|LOC_REGPARM_ADDR
case|:
block|{
name|struct
name|block
modifier|*
name|b
decl_stmt|;
name|int
name|regno
init|=
name|SYMBOL_VALUE
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|struct
name|value
modifier|*
name|regval
decl_stmt|;
if|if
condition|(
name|frame
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|b
operator|=
name|get_frame_block
argument_list|(
name|frame
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|var
argument_list|)
operator|==
name|LOC_REGPARM_ADDR
condition|)
block|{
name|regval
operator|=
name|value_from_register
argument_list|(
name|lookup_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|regno
argument_list|,
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|regval
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Value of register variable not available."
argument_list|)
expr_stmt|;
name|addr
operator|=
name|value_as_address
argument_list|(
name|regval
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|lval_memory
expr_stmt|;
block|}
else|else
block|{
name|regval
operator|=
name|value_from_register
argument_list|(
name|type
argument_list|,
name|regno
argument_list|,
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|regval
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Value of register variable not available."
argument_list|)
expr_stmt|;
return|return
name|regval
return|;
block|}
block|}
break|break;
case|case
name|LOC_COMPUTED
case|:
case|case
name|LOC_COMPUTED_ARG
case|:
comment|/* FIXME: cagney/2004-01-26: It should be possible to 	 unconditionally call the SYMBOL_OPS method when available. 	 Unfortunately DWARF 2 stores the frame-base (instead of the 	 function) location in a function's symbol.  Oops!  For the 	 moment enable this when/where applicable.  */
if|if
condition|(
name|frame
operator|==
literal|0
operator|&&
name|SYMBOL_OPS
argument_list|(
name|var
argument_list|)
operator|->
name|read_needs_frame
argument_list|(
name|var
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|SYMBOL_OPS
argument_list|(
name|var
argument_list|)
operator|->
name|read_variable
argument_list|(
name|var
argument_list|,
name|frame
argument_list|)
return|;
case|case
name|LOC_UNRESOLVED
case|:
block|{
name|struct
name|minimal_symbol
modifier|*
name|msym
decl_stmt|;
name|msym
operator|=
name|lookup_minimal_symbol
argument_list|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|var
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|msym
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|overlay_debugging
condition|)
name|addr
operator|=
name|symbol_overlayed_address
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msym
argument_list|)
argument_list|,
name|SYMBOL_BFD_SECTION
argument_list|(
name|msym
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|addr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msym
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LOC_OPTIMIZED_OUT
case|:
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|not_lval
expr_stmt|;
name|VALUE_OPTIMIZED_OUT
argument_list|(
name|v
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|v
return|;
default|default:
name|error
argument_list|(
literal|"Cannot look up value of a botched symbol."
argument_list|)
expr_stmt|;
break|break;
block|}
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|=
name|addr
expr_stmt|;
name|VALUE_LAZY
argument_list|(
name|v
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/* Return a value of type TYPE, stored in register REGNUM, in frame    FRAME.     NOTE: returns NULL if register value is not available.    Caller will check return value or die!  */
end_comment

begin_function
name|struct
name|value
modifier|*
name|value_from_register
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|regnum
parameter_list|,
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
name|struct
name|gdbarch
modifier|*
name|gdbarch
init|=
name|get_frame_arch
argument_list|(
name|frame
argument_list|)
decl_stmt|;
name|struct
name|value
modifier|*
name|v
init|=
name|allocate_value
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* It doesn't matter much what we return for this: since the          length is zero, it could be anything.  But if allowed to see          a zero-length type, the register-finding loop below will set          neither mem_stor nor reg_stor, and then report an internal          error.             Zero-length types can legitimately arise from declarations          like 'struct {}' (a GCC extension, not valid ISO C).  GDB may          also create them when it finds bogus debugging information;          for example, in GCC 2.95.4 and binutils 2.11.93.0.2, the          STABS BINCL->EXCL compression process can create bad type          numbers.  GDB reads these as TYPE_CODE_UNDEF types, with zero          length.  (That bug is actually the only known way to get a          zero-length value allocated to a register --- which is what          it takes to make it here.)           We'll just attribute the value to the original register.  */
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|lval_register
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|=
name|regnum
expr_stmt|;
name|VALUE_REGNO
argument_list|(
name|v
argument_list|)
operator|=
name|regnum
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONVERT_REGISTER_P
argument_list|(
name|regnum
argument_list|,
name|type
argument_list|)
condition|)
block|{
comment|/* The ISA/ABI need to something weird when obtaining the          specified value from this register.  It might need to          re-order non-adjacent, starting with REGNUM (see MIPS and          i386).  It might need to convert the [float] register into          the corresponding [integer] type (see Alpha).  The assumption          is that REGISTER_TO_VALUE populates the entire value          including the location.  */
name|REGISTER_TO_VALUE
argument_list|(
name|frame
argument_list|,
name|regnum
argument_list|,
name|type
argument_list|,
name|VALUE_CONTENTS_RAW
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|lval_reg_frame_relative
expr_stmt|;
name|VALUE_FRAME_ID
argument_list|(
name|v
argument_list|)
operator|=
name|get_frame_id
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|VALUE_FRAME_REGNUM
argument_list|(
name|v
argument_list|)
operator|=
name|regnum
expr_stmt|;
block|}
else|else
block|{
name|int
name|local_regnum
decl_stmt|;
name|int
name|mem_stor
init|=
literal|0
decl_stmt|,
name|reg_stor
init|=
literal|0
decl_stmt|;
name|int
name|mem_tracking
init|=
literal|1
decl_stmt|;
name|CORE_ADDR
name|last_addr
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|first_addr
init|=
literal|0
decl_stmt|;
name|int
name|first_realnum
init|=
name|regnum
decl_stmt|;
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|value_bytes_copied
decl_stmt|;
name|int
name|optimized
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|value_bytes
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
name|MAX_REGISTER_SIZE
argument_list|)
decl_stmt|;
comment|/* Copy all of the data out, whereever it may be.  */
for|for
control|(
name|local_regnum
operator|=
name|regnum
operator|,
name|value_bytes_copied
operator|=
literal|0
init|;
name|value_bytes_copied
operator|<
name|len
condition|;
operator|(
name|value_bytes_copied
operator|+=
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|local_regnum
argument_list|)
operator|,
operator|++
name|local_regnum
operator|)
control|)
block|{
name|int
name|realnum
decl_stmt|;
name|int
name|optim
decl_stmt|;
name|enum
name|lval_type
name|lval
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|frame_register
argument_list|(
name|frame
argument_list|,
name|local_regnum
argument_list|,
operator|&
name|optim
argument_list|,
operator|&
name|lval
argument_list|,
operator|&
name|addr
argument_list|,
operator|&
name|realnum
argument_list|,
name|value_bytes
operator|+
name|value_bytes_copied
argument_list|)
expr_stmt|;
name|optimized
operator|+=
name|optim
expr_stmt|;
if|if
condition|(
name|register_cached
argument_list|(
name|local_regnum
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
comment|/* register value not available */
if|if
condition|(
name|regnum
operator|==
name|local_regnum
condition|)
block|{
name|first_addr
operator|=
name|addr
expr_stmt|;
name|first_realnum
operator|=
name|realnum
expr_stmt|;
block|}
if|if
condition|(
name|lval
operator|==
name|lval_register
condition|)
name|reg_stor
operator|++
expr_stmt|;
else|else
block|{
name|mem_stor
operator|++
expr_stmt|;
name|mem_tracking
operator|=
operator|(
name|mem_tracking
operator|&&
operator|(
name|regnum
operator|==
name|local_regnum
operator|||
name|addr
operator|==
name|last_addr
operator|)
operator|)
expr_stmt|;
block|}
name|last_addr
operator|=
name|addr
expr_stmt|;
block|}
comment|/* FIXME: cagney/2003-06-04: Shouldn't this always use          lval_reg_frame_relative?  If it doesn't and the register's          location changes (say after a resume) then this value is          going to have wrong information.  */
if|if
condition|(
operator|(
name|reg_stor
operator|&&
name|mem_stor
operator|)
operator|||
operator|(
name|mem_stor
operator|&&
operator|!
name|mem_tracking
operator|)
condition|)
comment|/* Mixed storage; all of the hassle we just went through was 	   for some good purpose.  */
block|{
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|lval_reg_frame_relative
expr_stmt|;
name|VALUE_FRAME_ID
argument_list|(
name|v
argument_list|)
operator|=
name|get_frame_id
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|VALUE_FRAME_REGNUM
argument_list|(
name|v
argument_list|)
operator|=
name|regnum
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mem_stor
condition|)
block|{
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|lval_memory
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|=
name|first_addr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reg_stor
condition|)
block|{
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|lval_register
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|=
name|first_addr
expr_stmt|;
name|VALUE_REGNO
argument_list|(
name|v
argument_list|)
operator|=
name|first_realnum
expr_stmt|;
block|}
else|else
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"value_from_register: Value not stored anywhere!"
argument_list|)
expr_stmt|;
name|VALUE_OPTIMIZED_OUT
argument_list|(
name|v
argument_list|)
operator|=
name|optimized
expr_stmt|;
comment|/* Any structure stored in more than one register will always be          an integral number of registers.  Otherwise, you need to do          some fiddling with the last register copied here for little          endian machines.  */
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
operator|&&
name|len
operator|<
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
condition|)
comment|/* Big-endian, and we want less than full size.  */
name|VALUE_OFFSET
argument_list|(
name|v
argument_list|)
operator|=
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
operator|-
name|len
expr_stmt|;
else|else
name|VALUE_OFFSET
argument_list|(
name|v
argument_list|)
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|v
argument_list|)
argument_list|,
name|value_bytes
operator|+
name|VALUE_OFFSET
argument_list|(
name|v
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|v
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a struct symbol for a variable or function,    and a stack frame id,     return a (pointer to a) struct value containing the properly typed    address.  */
end_comment

begin_function
name|struct
name|value
modifier|*
name|locate_var_value
parameter_list|(
name|struct
name|symbol
modifier|*
name|var
parameter_list|,
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
name|CORE_ADDR
name|addr
init|=
literal|0
decl_stmt|;
name|struct
name|type
modifier|*
name|type
init|=
name|SYMBOL_TYPE
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|struct
name|value
modifier|*
name|lazy_value
decl_stmt|;
comment|/* Evaluate it first; if the result is a memory address, we're fine.      Lazy evaluation pays off here. */
name|lazy_value
operator|=
name|read_var_value
argument_list|(
name|var
argument_list|,
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|lazy_value
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Address of \"%s\" is unknown."
argument_list|,
name|SYMBOL_PRINT_NAME
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_LAZY
argument_list|(
name|lazy_value
argument_list|)
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FUNC
condition|)
block|{
name|struct
name|value
modifier|*
name|val
decl_stmt|;
name|addr
operator|=
name|VALUE_ADDRESS
argument_list|(
name|lazy_value
argument_list|)
expr_stmt|;
name|val
operator|=
name|value_from_pointer
argument_list|(
name|lookup_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|VALUE_BFD_SECTION
argument_list|(
name|val
argument_list|)
operator|=
name|VALUE_BFD_SECTION
argument_list|(
name|lazy_value
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
comment|/* Not a memory address; check what the problem was.  */
switch|switch
condition|(
name|VALUE_LVAL
argument_list|(
name|lazy_value
argument_list|)
condition|)
block|{
case|case
name|lval_register
case|:
name|gdb_assert
argument_list|(
name|REGISTER_NAME
argument_list|(
name|VALUE_REGNO
argument_list|(
name|lazy_value
argument_list|)
argument_list|)
operator|!=
name|NULL
operator|&&
operator|*
name|REGISTER_NAME
argument_list|(
name|VALUE_REGNO
argument_list|(
name|lazy_value
argument_list|)
argument_list|)
operator|!=
literal|'\0'
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Address requested for identifier "
literal|"\"%s\" which is in register $%s"
argument_list|,
name|SYMBOL_PRINT_NAME
argument_list|(
name|var
argument_list|)
argument_list|,
name|REGISTER_NAME
argument_list|(
name|VALUE_REGNO
argument_list|(
name|lazy_value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|lval_reg_frame_relative
case|:
name|gdb_assert
argument_list|(
name|REGISTER_NAME
argument_list|(
name|VALUE_FRAME_REGNUM
argument_list|(
name|lazy_value
argument_list|)
argument_list|)
operator|!=
name|NULL
operator|&&
operator|*
name|REGISTER_NAME
argument_list|(
name|VALUE_FRAME_REGNUM
argument_list|(
name|lazy_value
argument_list|)
argument_list|)
operator|!=
literal|'\0'
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Address requested for identifier "
literal|"\"%s\" which is in frame register $%s"
argument_list|,
name|SYMBOL_PRINT_NAME
argument_list|(
name|var
argument_list|)
argument_list|,
name|REGISTER_NAME
argument_list|(
name|VALUE_FRAME_REGNUM
argument_list|(
name|lazy_value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Can't take address of \"%s\" which isn't an lvalue."
argument_list|,
name|SYMBOL_PRINT_NAME
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
comment|/* For lint -- never reached */
block|}
end_function

end_unit

