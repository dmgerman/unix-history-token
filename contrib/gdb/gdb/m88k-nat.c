begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Native-dependent Motorola 88xxx support for GDB, the GNU Debugger.    Copyright 1988, 1990, 1991, 1992 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|USER
end_ifndef

begin_comment
comment|/* added to support BCS ptrace_user */
end_comment

begin_define
define|#
directive|define
name|USER
value|ptrace_user
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"setjmp.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DELTA88
end_ifdef

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_comment
comment|/* define offsets to the pc instruction offsets in ptrace_user struct */
end_comment

begin_define
define|#
directive|define
name|SXIP_OFFSET
value|((char *)&u.pt_sigframe.sig_sxip - (char *)&u)
end_define

begin_define
define|#
directive|define
name|SNIP_OFFSET
value|((char *)&u.pt_sigframe.sig_snip - (char *)&u)
end_define

begin_define
define|#
directive|define
name|SFIP_OFFSET
value|((char *)&u.pt_sigframe.sig_sfip - (char *)&u)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* define offsets to the pc instruction offsets in ptrace_user struct */
end_comment

begin_define
define|#
directive|define
name|SXIP_OFFSET
value|((char *)&u.pt_sigframe.dg_sigframe.sc_sxip - (char *)&u)
end_define

begin_define
define|#
directive|define
name|SNIP_OFFSET
value|((char *)&u.pt_sigframe.dg_sigframe.sc_snip - (char *)&u)
end_define

begin_define
define|#
directive|define
name|SFIP_OFFSET
value|((char *)&u.pt_sigframe.dg_sigframe.sc_sfip - (char *)&u)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|int
name|have_symbol_file_p
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|jmp_buf
name|stack_jmp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|registers
index|[
name|REGISTER_BYTES
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|fetch_inferior_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
comment|/* Original value discarded */
block|{
specifier|register
name|unsigned
name|int
name|regaddr
decl_stmt|;
name|char
name|buf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|USER
name|u
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
name|offset
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|u
operator|.
name|pt_r0
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|u
expr_stmt|;
name|regaddr
operator|=
name|offset
expr_stmt|;
comment|/* byte offset to r0;*/
comment|/*  offset = ptrace (3, inferior_pid, (PTRACE_ARG3_TYPE) offset, 0) - KERNEL_U_ADDR; */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
block|{
comment|/*regaddr = register_addr (regno, offset);*/
comment|/* 88k enhancement  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
control|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|buf
index|[
name|i
index|]
operator|=
name|ptrace
argument_list|(
literal|3
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|regaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|regaddr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
name|supply_register
argument_list|(
name|regno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/* now load up registers 36 - 38; special pc registers */
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|buf
index|[
literal|0
index|]
operator|=
name|ptrace
argument_list|(
literal|3
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|SXIP_OFFSET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|SXIP_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|buf
index|[
literal|0
index|]
operator|=
name|ptrace
argument_list|(
literal|3
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|SNIP_OFFSET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|SNIP_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|buf
index|[
literal|0
index|]
operator|=
name|ptrace
argument_list|(
literal|3
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|SFIP_OFFSET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|SFIP_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store our register values back into the inferior.    If REGNO is -1, do this for all registers.    Otherwise, REGNO specifies which register (so we can save time).  */
end_comment

begin_function
name|void
name|store_inferior_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|regaddr
decl_stmt|;
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|struct
name|USER
name|u
decl_stmt|;
name|unsigned
name|int
name|offset
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|u
operator|.
name|pt_r0
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|u
decl_stmt|;
name|regaddr
operator|=
name|offset
expr_stmt|;
comment|/* Don't try to deal with EXIP_REGNUM or ENIP_REGNUM, because I think either      svr3 doesn't run on an 88110, or the kernel isolates the different (not      completely sure this is true, but seems to be.  */
if|if
condition|(
name|regno
operator|>=
literal|0
condition|)
block|{
comment|/*      regaddr = register_addr (regno, offset); */
if|if
condition|(
name|regno
operator|<
name|PC_REGNUM
condition|)
block|{
name|regaddr
operator|=
name|offset
operator|+
name|regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
literal|6
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|regaddr
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"writing register number %d"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|regno
operator|==
name|SXIP_REGNUM
condition|)
name|ptrace
argument_list|(
literal|6
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|SXIP_OFFSET
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|SNIP_REGNUM
condition|)
name|ptrace
argument_list|(
literal|6
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|SNIP_OFFSET
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|SFIP_REGNUM
condition|)
name|ptrace
argument_list|(
literal|6
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|SFIP_OFFSET
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf_unfiltered
argument_list|(
literal|"Bad register number for store_inferior routine\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|PC_REGNUM
condition|;
name|regno
operator|++
control|)
block|{
comment|/*      regaddr = register_addr (regno, offset); */
name|errno
operator|=
literal|0
expr_stmt|;
name|regaddr
operator|=
name|offset
operator|+
name|regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
literal|6
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|regaddr
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"writing register number %d"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
name|ptrace
argument_list|(
literal|6
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|SXIP_OFFSET
argument_list|,
name|read_register
argument_list|(
name|SXIP_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
literal|6
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|SNIP_OFFSET
argument_list|,
name|read_register
argument_list|(
name|SNIP_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
literal|6
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|SFIP_OFFSET
argument_list|,
name|read_register
argument_list|(
name|SFIP_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* blockend is the address of the end of the user structure */
end_comment

begin_macro
name|m88k_register_u_addr
argument_list|(
argument|blockend
argument_list|,
argument|regnum
argument_list|)
end_macro

begin_block
block|{
name|struct
name|USER
name|u
decl_stmt|;
name|int
name|ustart
init|=
name|blockend
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|USER
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|regnum
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|3
case|:
case|case
literal|4
case|:
case|case
literal|5
case|:
case|case
literal|6
case|:
case|case
literal|7
case|:
case|case
literal|8
case|:
case|case
literal|9
case|:
case|case
literal|10
case|:
case|case
literal|11
case|:
case|case
literal|12
case|:
case|case
literal|13
case|:
case|case
literal|14
case|:
case|case
literal|15
case|:
case|case
literal|16
case|:
case|case
literal|17
case|:
case|case
literal|18
case|:
case|case
literal|19
case|:
case|case
literal|20
case|:
case|case
literal|21
case|:
case|case
literal|22
case|:
case|case
literal|23
case|:
case|case
literal|24
case|:
case|case
literal|25
case|:
case|case
literal|26
case|:
case|case
literal|27
case|:
case|case
literal|28
case|:
case|case
literal|29
case|:
case|case
literal|30
case|:
case|case
literal|31
case|:
return|return
operator|(
name|ustart
operator|+
operator|(
operator|(
name|int
operator|)
operator|&
name|u
operator|.
name|pt_r0
operator|-
operator|(
name|int
operator|)
operator|&
name|u
operator|)
operator|+
name|REGISTER_SIZE
operator|*
name|regnum
operator|)
return|;
case|case
name|PSR_REGNUM
case|:
return|return
operator|(
name|ustart
operator|+
operator|(
operator|(
name|int
operator|)
operator|&
name|u
operator|.
name|pt_psr
operator|-
operator|(
name|int
operator|)
operator|&
name|u
operator|)
operator|)
return|;
case|case
name|FPSR_REGNUM
case|:
return|return
operator|(
name|ustart
operator|+
operator|(
operator|(
name|int
operator|)
operator|&
name|u
operator|.
name|pt_fpsr
operator|-
operator|(
name|int
operator|)
operator|&
name|u
operator|)
operator|)
return|;
case|case
name|FPCR_REGNUM
case|:
return|return
operator|(
name|ustart
operator|+
operator|(
operator|(
name|int
operator|)
operator|&
name|u
operator|.
name|pt_fpcr
operator|-
operator|(
name|int
operator|)
operator|&
name|u
operator|)
operator|)
return|;
case|case
name|SXIP_REGNUM
case|:
return|return
operator|(
name|ustart
operator|+
name|SXIP_OFFSET
operator|)
return|;
case|case
name|SNIP_REGNUM
case|:
return|return
operator|(
name|ustart
operator|+
name|SNIP_OFFSET
operator|)
return|;
case|case
name|SFIP_REGNUM
case|:
return|return
operator|(
name|ustart
operator|+
name|SFIP_OFFSET
operator|)
return|;
default|default:
if|if
condition|(
name|regnum
operator|<
name|NUM_REGS
condition|)
comment|/* The register is one of those which is not defined... 	       give it zero */
return|return
operator|(
name|ustart
operator|+
operator|(
operator|(
name|int
operator|)
operator|&
name|u
operator|.
name|pt_r0
operator|-
operator|(
name|int
operator|)
operator|&
name|u
operator|)
operator|)
return|;
else|else
return|return
operator|(
name|blockend
operator|+
name|REGISTER_SIZE
operator|*
name|regnum
operator|)
return|;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|USE_PROC_FS
end_ifdef

begin_include
include|#
directive|include
file|<sys/procfs.h>
end_include

begin_comment
comment|/*  Given a pointer to a general register set in /proc format (gregset_t *),     unpack the register contents and supply them as gdb's idea of the current     register values. */
end_comment

begin_function
name|void
name|supply_gregset
parameter_list|(
name|gregsetp
parameter_list|)
name|gregset_t
modifier|*
name|gregsetp
decl_stmt|;
block|{
specifier|register
name|int
name|regi
decl_stmt|;
specifier|register
name|greg_t
modifier|*
name|regp
init|=
operator|(
name|greg_t
operator|*
operator|)
name|gregsetp
decl_stmt|;
for|for
control|(
name|regi
operator|=
literal|0
init|;
name|regi
operator|<=
name|SP_REGNUM
condition|;
name|regi
operator|++
control|)
name|supply_register
argument_list|(
name|regi
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|regi
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|SXIP_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_XIP
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|SNIP_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_NIP
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|SFIP_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_FIP
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|PSR_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_PSR
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|FPSR_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_FPSR
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|FPCR_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_FPCR
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fill_gregset
parameter_list|(
name|gregsetp
parameter_list|,
name|regno
parameter_list|)
name|gregset_t
modifier|*
name|gregsetp
decl_stmt|;
name|int
name|regno
decl_stmt|;
block|{
name|int
name|regi
decl_stmt|;
specifier|register
name|greg_t
modifier|*
name|regp
init|=
operator|(
name|greg_t
operator|*
operator|)
name|gregsetp
decl_stmt|;
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
for|for
control|(
name|regi
operator|=
literal|0
init|;
name|regi
operator|<=
name|R_R31
condition|;
name|regi
operator|++
control|)
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|regi
operator|)
condition|)
operator|*
operator|(
name|regp
operator|+
name|regi
operator|)
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regi
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|SXIP_REGNUM
operator|)
condition|)
operator|*
operator|(
name|regp
operator|+
name|R_XIP
operator|)
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|SXIP_REGNUM
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|SNIP_REGNUM
operator|)
condition|)
operator|*
operator|(
name|regp
operator|+
name|R_NIP
operator|)
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|SNIP_REGNUM
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|SFIP_REGNUM
operator|)
condition|)
operator|*
operator|(
name|regp
operator|+
name|R_FIP
operator|)
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|SFIP_REGNUM
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|PSR_REGNUM
operator|)
condition|)
operator|*
operator|(
name|regp
operator|+
name|R_PSR
operator|)
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|PSR_REGNUM
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|FPSR_REGNUM
operator|)
condition|)
operator|*
operator|(
name|regp
operator|+
name|R_FPSR
operator|)
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FPSR_REGNUM
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|FPCR_REGNUM
operator|)
condition|)
operator|*
operator|(
name|regp
operator|+
name|R_FPCR
operator|)
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FPCR_REGNUM
argument_list|)
index|]
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_PROC_FS */
end_comment

end_unit

