begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Native-dependent Motorola 88xxx support for GDB, the GNU Debugger.    Copyright 1988, 1990, 1991, 1992, 1993, 1995, 1999, 2000, 2001    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|USER
end_ifndef

begin_comment
comment|/* added to support BCS ptrace_user */
end_comment

begin_define
define|#
directive|define
name|USER
value|ptrace_user
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"setjmp.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DELTA88
end_ifdef

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_comment
comment|/* define offsets to the pc instruction offsets in ptrace_user struct */
end_comment

begin_define
define|#
directive|define
name|SXIP_OFFSET
value|((char *)&u.pt_sigframe.sig_sxip - (char *)&u)
end_define

begin_define
define|#
directive|define
name|SNIP_OFFSET
value|((char *)&u.pt_sigframe.sig_snip - (char *)&u)
end_define

begin_define
define|#
directive|define
name|SFIP_OFFSET
value|((char *)&u.pt_sigframe.sig_sfip - (char *)&u)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* define offsets to the pc instruction offsets in ptrace_user struct */
end_comment

begin_define
define|#
directive|define
name|SXIP_OFFSET
value|((char *)&u.pt_sigframe.dg_sigframe.sc_sxip - (char *)&u)
end_define

begin_define
define|#
directive|define
name|SNIP_OFFSET
value|((char *)&u.pt_sigframe.dg_sigframe.sc_snip - (char *)&u)
end_define

begin_define
define|#
directive|define
name|SFIP_OFFSET
value|((char *)&u.pt_sigframe.dg_sigframe.sc_sfip - (char *)&u)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|int
name|have_symbol_file_p
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|jmp_buf
name|stack_jmp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|fetch_inferior_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
specifier|register
name|unsigned
name|int
name|regaddr
decl_stmt|;
name|char
name|buf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|USER
name|u
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
name|offset
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|u
operator|.
name|pt_r0
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|u
expr_stmt|;
name|regaddr
operator|=
name|offset
expr_stmt|;
comment|/* byte offset to r0; */
comment|/*  offset = ptrace (3, PIDGET (inferior_ptid), (PTRACE_ARG3_TYPE) offset, 0) - KERNEL_U_ADDR; */
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
block|{
comment|/*regaddr = register_addr (regno, offset); */
comment|/* 88k enhancement  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
control|)
block|{
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|buf
index|[
name|i
index|]
operator|=
name|ptrace
argument_list|(
literal|3
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|regaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|regaddr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
name|supply_register
argument_list|(
name|regno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
comment|/* now load up registers 36 - 38; special pc registers */
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|buf
index|[
literal|0
index|]
operator|=
name|ptrace
argument_list|(
literal|3
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|SXIP_OFFSET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|SXIP_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|buf
index|[
literal|0
index|]
operator|=
name|ptrace
argument_list|(
literal|3
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|SNIP_OFFSET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|SNIP_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|buf
index|[
literal|0
index|]
operator|=
name|ptrace
argument_list|(
literal|3
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|SFIP_OFFSET
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|SFIP_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store our register values back into the inferior.    If REGNO is -1, do this for all registers.    Otherwise, REGNO specifies which register (so we can save time).  */
end_comment

begin_function
name|void
name|store_inferior_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
specifier|register
name|unsigned
name|int
name|regaddr
decl_stmt|;
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|struct
name|USER
name|u
decl_stmt|;
name|unsigned
name|int
name|offset
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|u
operator|.
name|pt_r0
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|u
decl_stmt|;
name|regaddr
operator|=
name|offset
expr_stmt|;
comment|/* Don't try to deal with EXIP_REGNUM or ENIP_REGNUM, because I think either      svr3 doesn't run on an 88110, or the kernel isolates the different (not      completely sure this is true, but seems to be.  */
if|if
condition|(
name|regno
operator|>=
literal|0
condition|)
block|{
comment|/*      regaddr = register_addr (regno, offset); */
if|if
condition|(
name|regno
operator|<
name|PC_REGNUM
condition|)
block|{
name|regaddr
operator|=
name|offset
operator|+
name|regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
literal|6
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|regaddr
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"writing register number %d"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|regno
operator|==
name|SXIP_REGNUM
condition|)
name|ptrace
argument_list|(
literal|6
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|SXIP_OFFSET
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|SNIP_REGNUM
condition|)
name|ptrace
argument_list|(
literal|6
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|SNIP_OFFSET
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|SFIP_REGNUM
condition|)
name|ptrace
argument_list|(
literal|6
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|SFIP_OFFSET
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf_unfiltered
argument_list|(
literal|"Bad register number for store_inferior routine\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|PC_REGNUM
condition|;
name|regno
operator|++
control|)
block|{
comment|/*      regaddr = register_addr (regno, offset); */
name|errno
operator|=
literal|0
expr_stmt|;
name|regaddr
operator|=
name|offset
operator|+
name|regno
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
literal|6
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|regaddr
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"writing register number %d"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
name|ptrace
argument_list|(
literal|6
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|SXIP_OFFSET
argument_list|,
name|read_register
argument_list|(
name|SXIP_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
literal|6
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|SNIP_OFFSET
argument_list|,
name|read_register
argument_list|(
name|SNIP_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
literal|6
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|SFIP_OFFSET
argument_list|,
name|read_register
argument_list|(
name|SFIP_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* blockend is the address of the end of the user structure */
end_comment

begin_macro
name|m88k_register_u_addr
argument_list|(
argument|int blockend
argument_list|,
argument|int regnum
argument_list|)
end_macro

begin_block
block|{
name|struct
name|USER
name|u
decl_stmt|;
name|int
name|ustart
init|=
name|blockend
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|USER
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|regnum
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|3
case|:
case|case
literal|4
case|:
case|case
literal|5
case|:
case|case
literal|6
case|:
case|case
literal|7
case|:
case|case
literal|8
case|:
case|case
literal|9
case|:
case|case
literal|10
case|:
case|case
literal|11
case|:
case|case
literal|12
case|:
case|case
literal|13
case|:
case|case
literal|14
case|:
case|case
literal|15
case|:
case|case
literal|16
case|:
case|case
literal|17
case|:
case|case
literal|18
case|:
case|case
literal|19
case|:
case|case
literal|20
case|:
case|case
literal|21
case|:
case|case
literal|22
case|:
case|case
literal|23
case|:
case|case
literal|24
case|:
case|case
literal|25
case|:
case|case
literal|26
case|:
case|case
literal|27
case|:
case|case
literal|28
case|:
case|case
literal|29
case|:
case|case
literal|30
case|:
case|case
literal|31
case|:
return|return
operator|(
name|ustart
operator|+
operator|(
operator|(
name|int
operator|)
operator|&
name|u
operator|.
name|pt_r0
operator|-
operator|(
name|int
operator|)
operator|&
name|u
operator|)
operator|+
name|REGISTER_SIZE
operator|*
name|regnum
operator|)
return|;
case|case
name|PSR_REGNUM
case|:
return|return
operator|(
name|ustart
operator|+
operator|(
operator|(
name|int
operator|)
operator|&
name|u
operator|.
name|pt_psr
operator|-
operator|(
name|int
operator|)
operator|&
name|u
operator|)
operator|)
return|;
case|case
name|FPSR_REGNUM
case|:
return|return
operator|(
name|ustart
operator|+
operator|(
operator|(
name|int
operator|)
operator|&
name|u
operator|.
name|pt_fpsr
operator|-
operator|(
name|int
operator|)
operator|&
name|u
operator|)
operator|)
return|;
case|case
name|FPCR_REGNUM
case|:
return|return
operator|(
name|ustart
operator|+
operator|(
operator|(
name|int
operator|)
operator|&
name|u
operator|.
name|pt_fpcr
operator|-
operator|(
name|int
operator|)
operator|&
name|u
operator|)
operator|)
return|;
case|case
name|SXIP_REGNUM
case|:
return|return
operator|(
name|ustart
operator|+
name|SXIP_OFFSET
operator|)
return|;
case|case
name|SNIP_REGNUM
case|:
return|return
operator|(
name|ustart
operator|+
name|SNIP_OFFSET
operator|)
return|;
case|case
name|SFIP_REGNUM
case|:
return|return
operator|(
name|ustart
operator|+
name|SFIP_OFFSET
operator|)
return|;
default|default:
if|if
condition|(
name|regnum
operator|<
name|NUM_REGS
condition|)
comment|/* The register is one of those which is not defined... 	   give it zero */
return|return
operator|(
name|ustart
operator|+
operator|(
operator|(
name|int
operator|)
operator|&
name|u
operator|.
name|pt_r0
operator|-
operator|(
name|int
operator|)
operator|&
name|u
operator|)
operator|)
return|;
else|else
return|return
operator|(
name|blockend
operator|+
name|REGISTER_SIZE
operator|*
name|regnum
operator|)
return|;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|USE_PROC_FS
end_ifdef

begin_include
include|#
directive|include
file|<sys/procfs.h>
end_include

begin_comment
comment|/* Prototypes for supply_gregset etc. */
end_comment

begin_include
include|#
directive|include
file|"gregset.h"
end_include

begin_comment
comment|/*  Given a pointer to a general register set in /proc format (gregset_t *),    unpack the register contents and supply them as gdb's idea of the current    register values. */
end_comment

begin_function
name|void
name|supply_gregset
parameter_list|(
name|gregset_t
modifier|*
name|gregsetp
parameter_list|)
block|{
specifier|register
name|int
name|regi
decl_stmt|;
specifier|register
name|greg_t
modifier|*
name|regp
init|=
operator|(
name|greg_t
operator|*
operator|)
name|gregsetp
decl_stmt|;
for|for
control|(
name|regi
operator|=
literal|0
init|;
name|regi
operator|<=
name|SP_REGNUM
condition|;
name|regi
operator|++
control|)
name|supply_register
argument_list|(
name|regi
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|regi
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|SXIP_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_XIP
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|SNIP_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_NIP
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|SFIP_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_FIP
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|PSR_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_PSR
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|FPSR_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_FPSR
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|FPCR_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|R_FPCR
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fill_gregset
parameter_list|(
name|gregset_t
modifier|*
name|gregsetp
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|int
name|regi
decl_stmt|;
specifier|register
name|greg_t
modifier|*
name|regp
init|=
operator|(
name|greg_t
operator|*
operator|)
name|gregsetp
decl_stmt|;
for|for
control|(
name|regi
operator|=
literal|0
init|;
name|regi
operator|<=
name|R_R31
condition|;
name|regi
operator|++
control|)
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|regi
operator|)
condition|)
operator|*
operator|(
name|regp
operator|+
name|regi
operator|)
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regi
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|SXIP_REGNUM
operator|)
condition|)
operator|*
operator|(
name|regp
operator|+
name|R_XIP
operator|)
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|SXIP_REGNUM
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|SNIP_REGNUM
operator|)
condition|)
operator|*
operator|(
name|regp
operator|+
name|R_NIP
operator|)
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|SNIP_REGNUM
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|SFIP_REGNUM
operator|)
condition|)
operator|*
operator|(
name|regp
operator|+
name|R_FIP
operator|)
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|SFIP_REGNUM
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|PSR_REGNUM
operator|)
condition|)
operator|*
operator|(
name|regp
operator|+
name|R_PSR
operator|)
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|PSR_REGNUM
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|FPSR_REGNUM
operator|)
condition|)
operator|*
operator|(
name|regp
operator|+
name|R_FPSR
operator|)
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FPSR_REGNUM
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|FPCR_REGNUM
operator|)
condition|)
operator|*
operator|(
name|regp
operator|+
name|R_FPCR
operator|)
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FPCR_REGNUM
argument_list|)
index|]
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_PROC_FS */
end_comment

end_unit

