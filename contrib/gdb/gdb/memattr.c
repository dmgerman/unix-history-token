begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Memory attributes support, for GDB.    Copyright 2001 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"memattr.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_decl_stmt
specifier|const
name|struct
name|mem_attrib
name|default_mem_attrib
init|=
block|{
name|MEM_RW
block|,
comment|/* mode */
name|MEM_WIDTH_UNSPECIFIED
block|,
literal|0
block|,
comment|/* hwbreak */
literal|0
block|,
comment|/* cache */
literal|0
comment|/* verify */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mem_region
modifier|*
name|mem_region_chain
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mem_number
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|mem_region
modifier|*
name|create_mem_region
parameter_list|(
name|CORE_ADDR
name|lo
parameter_list|,
name|CORE_ADDR
name|hi
parameter_list|,
specifier|const
name|struct
name|mem_attrib
modifier|*
name|attrib
parameter_list|)
block|{
name|struct
name|mem_region
modifier|*
name|n
decl_stmt|,
modifier|*
name|new
decl_stmt|;
comment|/* lo == hi is a useless empty region */
if|if
condition|(
name|lo
operator|>=
name|hi
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"invalid memory region: low>= high\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|n
operator|=
name|mem_region_chain
expr_stmt|;
while|while
condition|(
name|n
condition|)
block|{
comment|/* overlapping node */
if|if
condition|(
operator|(
name|lo
operator|>=
name|n
operator|->
name|lo
operator|&&
name|lo
operator|<
name|n
operator|->
name|hi
operator|)
operator|||
operator|(
name|hi
operator|>
name|n
operator|->
name|lo
operator|&&
name|hi
operator|<=
name|n
operator|->
name|hi
operator|)
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"overlapping memory region\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|n
operator|=
name|n
operator|->
name|next
expr_stmt|;
block|}
name|new
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mem_region
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|lo
operator|=
name|lo
expr_stmt|;
name|new
operator|->
name|hi
operator|=
name|hi
expr_stmt|;
name|new
operator|->
name|number
operator|=
operator|++
name|mem_number
expr_stmt|;
name|new
operator|->
name|enabled_p
operator|=
literal|1
expr_stmt|;
name|new
operator|->
name|attrib
operator|=
operator|*
name|attrib
expr_stmt|;
comment|/* link in new node */
name|new
operator|->
name|next
operator|=
name|mem_region_chain
expr_stmt|;
name|mem_region_chain
operator|=
name|new
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|delete_mem_region
parameter_list|(
name|struct
name|mem_region
modifier|*
name|m
parameter_list|)
block|{
name|xfree
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Look up the memory region cooresponding to ADDR.  */
end_comment

begin_function
name|struct
name|mem_region
modifier|*
name|lookup_mem_region
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|)
block|{
specifier|static
name|struct
name|mem_region
name|region
decl_stmt|;
name|struct
name|mem_region
modifier|*
name|m
decl_stmt|;
name|CORE_ADDR
name|lo
decl_stmt|;
name|CORE_ADDR
name|hi
decl_stmt|;
comment|/* First we initialize LO and HI so that they describe the entire      memory space.  As we process the memory region chain, they are      redefined to describe the minimal region containing ADDR.  LO      and HI are used in the case where no memory region is defined      that contains ADDR.  If a memory region is disabled, it is      treated as if it does not exist.  */
name|lo
operator|=
operator|(
name|CORE_ADDR
operator|)
literal|0
expr_stmt|;
name|hi
operator|=
operator|(
name|CORE_ADDR
operator|)
operator|~
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|mem_region_chain
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
block|{
if|if
condition|(
name|m
operator|->
name|enabled_p
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|addr
operator|>=
name|m
operator|->
name|lo
operator|&&
name|addr
operator|<
name|m
operator|->
name|hi
condition|)
return|return
name|m
return|;
if|if
condition|(
name|addr
operator|>=
name|m
operator|->
name|hi
operator|&&
name|lo
operator|<
name|m
operator|->
name|hi
condition|)
name|lo
operator|=
name|m
operator|->
name|hi
expr_stmt|;
if|if
condition|(
name|addr
operator|<=
name|m
operator|->
name|lo
operator|&&
name|hi
operator|>
name|m
operator|->
name|lo
condition|)
name|hi
operator|=
name|m
operator|->
name|lo
expr_stmt|;
block|}
block|}
comment|/* Because no region was found, we must cons up one based on what      was learned above.  */
name|region
operator|.
name|lo
operator|=
name|lo
expr_stmt|;
name|region
operator|.
name|hi
operator|=
name|hi
expr_stmt|;
name|region
operator|.
name|attrib
operator|=
name|default_mem_attrib
expr_stmt|;
return|return
operator|&
name|region
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|mem_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|CORE_ADDR
name|lo
decl_stmt|,
name|hi
decl_stmt|;
name|char
modifier|*
name|tok
decl_stmt|;
name|struct
name|mem_attrib
name|attrib
decl_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
name|error_no_arg
argument_list|(
literal|"No mem"
argument_list|)
expr_stmt|;
name|tok
operator|=
name|strtok
argument_list|(
name|args
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tok
condition|)
name|error
argument_list|(
literal|"no lo address"
argument_list|)
expr_stmt|;
name|lo
operator|=
name|parse_and_eval_address
argument_list|(
name|tok
argument_list|)
expr_stmt|;
name|tok
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tok
condition|)
name|error
argument_list|(
literal|"no hi address"
argument_list|)
expr_stmt|;
name|hi
operator|=
name|parse_and_eval_address
argument_list|(
name|tok
argument_list|)
expr_stmt|;
name|attrib
operator|=
name|default_mem_attrib
expr_stmt|;
while|while
condition|(
operator|(
name|tok
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|" \t"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|tok
argument_list|,
literal|"rw"
argument_list|)
operator|==
literal|0
condition|)
name|attrib
operator|.
name|mode
operator|=
name|MEM_RW
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|tok
argument_list|,
literal|"ro"
argument_list|)
operator|==
literal|0
condition|)
name|attrib
operator|.
name|mode
operator|=
name|MEM_RO
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|tok
argument_list|,
literal|"wo"
argument_list|)
operator|==
literal|0
condition|)
name|attrib
operator|.
name|mode
operator|=
name|MEM_WO
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|tok
argument_list|,
literal|"8"
argument_list|)
operator|==
literal|0
condition|)
name|attrib
operator|.
name|width
operator|=
name|MEM_WIDTH_8
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|tok
argument_list|,
literal|"16"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|lo
operator|%
literal|2
operator|!=
literal|0
operator|)
operator|||
operator|(
name|hi
operator|%
literal|2
operator|!=
literal|0
operator|)
condition|)
name|error
argument_list|(
literal|"region bounds not 16 bit aligned"
argument_list|)
expr_stmt|;
name|attrib
operator|.
name|width
operator|=
name|MEM_WIDTH_16
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|tok
argument_list|,
literal|"32"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|lo
operator|%
literal|4
operator|!=
literal|0
operator|)
operator|||
operator|(
name|hi
operator|%
literal|4
operator|!=
literal|0
operator|)
condition|)
name|error
argument_list|(
literal|"region bounds not 32 bit aligned"
argument_list|)
expr_stmt|;
name|attrib
operator|.
name|width
operator|=
name|MEM_WIDTH_32
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|tok
argument_list|,
literal|"64"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|lo
operator|%
literal|8
operator|!=
literal|0
operator|)
operator|||
operator|(
name|hi
operator|%
literal|8
operator|!=
literal|0
operator|)
condition|)
name|error
argument_list|(
literal|"region bounds not 64 bit aligned"
argument_list|)
expr_stmt|;
name|attrib
operator|.
name|width
operator|=
name|MEM_WIDTH_64
expr_stmt|;
block|}
if|#
directive|if
literal|0
if|else if (strcmp (tok, "hwbreak") == 0) 	attrib.hwbreak = 1;       else if (strcmp (tok, "swbreak") == 0) 	attrib.hwbreak = 0;
endif|#
directive|endif
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|tok
argument_list|,
literal|"cache"
argument_list|)
operator|==
literal|0
condition|)
name|attrib
operator|.
name|cache
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|tok
argument_list|,
literal|"nocache"
argument_list|)
operator|==
literal|0
condition|)
name|attrib
operator|.
name|cache
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
if|else if (strcmp (tok, "verify") == 0) 	attrib.verify = 1;       else if (strcmp (tok, "noverify") == 0) 	attrib.verify = 0;
endif|#
directive|endif
else|else
name|error
argument_list|(
literal|"unknown attribute: %s"
argument_list|,
name|tok
argument_list|)
expr_stmt|;
block|}
name|create_mem_region
argument_list|(
name|lo
argument_list|,
name|hi
argument_list|,
operator|&
name|attrib
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|mem_info_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|mem_region
modifier|*
name|m
decl_stmt|;
name|struct
name|mem_attrib
modifier|*
name|attrib
decl_stmt|;
if|if
condition|(
operator|!
name|mem_region_chain
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"There are no memory regions defined.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf_filtered
argument_list|(
literal|"Num "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Enb "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Low Addr   "
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ADDR_BIT
operator|>
literal|32
condition|)
name|printf_filtered
argument_list|(
literal|"        "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"High Addr  "
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ADDR_BIT
operator|>
literal|32
condition|)
name|printf_filtered
argument_list|(
literal|"        "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Attrs "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
name|mem_region_chain
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
name|printf_filtered
argument_list|(
literal|"%-3d %-3c\t"
argument_list|,
name|m
operator|->
name|number
argument_list|,
name|m
operator|->
name|enabled_p
condition|?
literal|'y'
else|:
literal|'n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ADDR_BIT
operator|<=
literal|32
condition|)
name|tmp
operator|=
name|longest_local_hex_string_custom
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|m
operator|->
name|lo
argument_list|,
literal|"08l"
argument_list|)
expr_stmt|;
else|else
name|tmp
operator|=
name|longest_local_hex_string_custom
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|m
operator|->
name|lo
argument_list|,
literal|"016l"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s "
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_ADDR_BIT
operator|<=
literal|32
condition|)
name|tmp
operator|=
name|longest_local_hex_string_custom
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|m
operator|->
name|hi
argument_list|,
literal|"08l"
argument_list|)
expr_stmt|;
else|else
name|tmp
operator|=
name|longest_local_hex_string_custom
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|m
operator|->
name|hi
argument_list|,
literal|"016l"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s "
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
comment|/* Print a token for each attribute.         * FIXME: Should we output a comma after each token?  It may        * make it easier for users to read, but we'd lose the ability        * to cut-and-paste the list of attributes when defining a new        * region.  Perhaps that is not important.        *        * FIXME: If more attributes are added to GDB, the output may        * become cluttered and difficult for users to read.  At that        * time, we may want to consider printing tokens only if they        * are different from the default attribute.  */
name|attrib
operator|=
operator|&
name|m
operator|->
name|attrib
expr_stmt|;
switch|switch
condition|(
name|attrib
operator|->
name|mode
condition|)
block|{
case|case
name|MEM_RW
case|:
name|printf_filtered
argument_list|(
literal|"rw "
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM_RO
case|:
name|printf_filtered
argument_list|(
literal|"ro "
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM_WO
case|:
name|printf_filtered
argument_list|(
literal|"wo "
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|attrib
operator|->
name|width
condition|)
block|{
case|case
name|MEM_WIDTH_8
case|:
name|printf_filtered
argument_list|(
literal|"8 "
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM_WIDTH_16
case|:
name|printf_filtered
argument_list|(
literal|"16 "
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM_WIDTH_32
case|:
name|printf_filtered
argument_list|(
literal|"32 "
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM_WIDTH_64
case|:
name|printf_filtered
argument_list|(
literal|"64 "
argument_list|)
expr_stmt|;
break|break;
case|case
name|MEM_WIDTH_UNSPECIFIED
case|:
break|break;
block|}
if|#
directive|if
literal|0
block|if (attrib->hwbreak) 	printf_filtered ("hwbreak");       else 	printf_filtered ("swbreak");
endif|#
directive|endif
if|if
condition|(
name|attrib
operator|->
name|cache
condition|)
name|printf_filtered
argument_list|(
literal|"cache "
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"nocache "
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (attrib->verify) 	printf_filtered ("verify ");       else 	printf_filtered ("noverify ");
endif|#
directive|endif
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Enable the memory region number NUM. */
end_comment

begin_function
specifier|static
name|void
name|mem_enable
parameter_list|(
name|int
name|num
parameter_list|)
block|{
name|struct
name|mem_region
modifier|*
name|m
decl_stmt|;
for|for
control|(
name|m
operator|=
name|mem_region_chain
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
name|m
operator|->
name|number
operator|==
name|num
condition|)
block|{
name|m
operator|->
name|enabled_p
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|printf_unfiltered
argument_list|(
literal|"No memory region number %d.\n"
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mem_enable_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|args
decl_stmt|;
name|char
modifier|*
name|p1
decl_stmt|;
name|int
name|num
decl_stmt|;
name|struct
name|mem_region
modifier|*
name|m
decl_stmt|;
name|dcache_invalidate
argument_list|(
name|target_dcache
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|m
operator|=
name|mem_region_chain
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
name|m
operator|->
name|enabled_p
operator|=
literal|1
expr_stmt|;
block|}
else|else
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|p1
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p1
operator|>=
literal|'0'
operator|&&
operator|*
name|p1
operator|<=
literal|'9'
condition|)
name|p1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p1
operator|&&
operator|*
name|p1
operator|!=
literal|' '
operator|&&
operator|*
name|p1
operator|!=
literal|'\t'
condition|)
name|error
argument_list|(
literal|"Arguments must be memory region numbers."
argument_list|)
expr_stmt|;
name|num
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mem_enable
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|p
operator|=
name|p1
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Disable the memory region number NUM. */
end_comment

begin_function
specifier|static
name|void
name|mem_disable
parameter_list|(
name|int
name|num
parameter_list|)
block|{
name|struct
name|mem_region
modifier|*
name|m
decl_stmt|;
for|for
control|(
name|m
operator|=
name|mem_region_chain
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
if|if
condition|(
name|m
operator|->
name|number
operator|==
name|num
condition|)
block|{
name|m
operator|->
name|enabled_p
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|printf_unfiltered
argument_list|(
literal|"No memory region number %d.\n"
argument_list|,
name|num
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mem_disable_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|args
decl_stmt|;
name|char
modifier|*
name|p1
decl_stmt|;
name|int
name|num
decl_stmt|;
name|struct
name|mem_region
modifier|*
name|m
decl_stmt|;
name|dcache_invalidate
argument_list|(
name|target_dcache
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|m
operator|=
name|mem_region_chain
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
name|m
operator|->
name|enabled_p
operator|=
literal|0
expr_stmt|;
block|}
else|else
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|p1
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p1
operator|>=
literal|'0'
operator|&&
operator|*
name|p1
operator|<=
literal|'9'
condition|)
name|p1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p1
operator|&&
operator|*
name|p1
operator|!=
literal|' '
operator|&&
operator|*
name|p1
operator|!=
literal|'\t'
condition|)
name|error
argument_list|(
literal|"Arguments must be memory region numbers."
argument_list|)
expr_stmt|;
name|num
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mem_disable
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|p
operator|=
name|p1
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Clear memory region list */
end_comment

begin_function
specifier|static
name|void
name|mem_clear
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|mem_region
modifier|*
name|m
decl_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|mem_region_chain
operator|)
operator|!=
literal|0
condition|)
block|{
name|mem_region_chain
operator|=
name|m
operator|->
name|next
expr_stmt|;
name|delete_mem_region
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Delete the memory region number NUM. */
end_comment

begin_function
specifier|static
name|void
name|mem_delete
parameter_list|(
name|int
name|num
parameter_list|)
block|{
name|struct
name|mem_region
modifier|*
name|m1
decl_stmt|,
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|!
name|mem_region_chain
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"No memory region number %d.\n"
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mem_region_chain
operator|->
name|number
operator|==
name|num
condition|)
block|{
name|m1
operator|=
name|mem_region_chain
expr_stmt|;
name|mem_region_chain
operator|=
name|m1
operator|->
name|next
expr_stmt|;
name|delete_mem_region
argument_list|(
name|m1
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|m
operator|=
name|mem_region_chain
init|;
name|m
operator|->
name|next
condition|;
name|m
operator|=
name|m
operator|->
name|next
control|)
block|{
if|if
condition|(
name|m
operator|->
name|next
operator|->
name|number
operator|==
name|num
condition|)
block|{
name|m1
operator|=
name|m
operator|->
name|next
expr_stmt|;
name|m
operator|->
name|next
operator|=
name|m1
operator|->
name|next
expr_stmt|;
name|delete_mem_region
argument_list|(
name|m1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mem_delete_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|args
decl_stmt|;
name|char
modifier|*
name|p1
decl_stmt|;
name|int
name|num
decl_stmt|;
name|dcache_invalidate
argument_list|(
name|target_dcache
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|query
argument_list|(
literal|"Delete all memory regions? "
argument_list|)
condition|)
name|mem_clear
argument_list|()
expr_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|p1
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p1
operator|>=
literal|'0'
operator|&&
operator|*
name|p1
operator|<=
literal|'9'
condition|)
name|p1
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p1
operator|&&
operator|*
name|p1
operator|!=
literal|' '
operator|&&
operator|*
name|p1
operator|!=
literal|'\t'
condition|)
name|error
argument_list|(
literal|"Arguments must be memory region numbers."
argument_list|)
expr_stmt|;
name|num
operator|=
name|atoi
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|mem_delete
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|p
operator|=
name|p1
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
block|}
name|dont_repeat
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|_initialize_mem
parameter_list|()
block|{
name|add_com
argument_list|(
literal|"mem"
argument_list|,
name|class_vars
argument_list|,
name|mem_command
argument_list|,
literal|"Define attributes for memory region.\n\ Usage: mem<lo addr><hi addr> [<mode><width><cache>], \n\ where<mode>  may be rw (read/write), ro (read-only) or wo (write-only), \n\<width> may be 8, 16, 32, or 64, and \n\<cache> may be cache or nocache"
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"mem"
argument_list|,
name|class_vars
argument_list|,
name|mem_enable_command
argument_list|,
literal|"Enable memory region.\n\ Arguments are the code numbers of the memory regions to enable.\n\ Usage: enable mem<code number>\n\ Do \"info mem\" to see current list of code numbers."
argument_list|,
operator|&
name|enablelist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"mem"
argument_list|,
name|class_vars
argument_list|,
name|mem_disable_command
argument_list|,
literal|"Disable memory region.\n\ Arguments are the code numbers of the memory regions to disable.\n\ Usage: disable mem<code number>\n\ Do \"info mem\" to see current list of code numbers."
argument_list|,
operator|&
name|disablelist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"mem"
argument_list|,
name|class_vars
argument_list|,
name|mem_delete_command
argument_list|,
literal|"Delete memory region.\n\ Arguments are the code numbers of the memory regions to delete.\n\ Usage: delete mem<code number>\n\ Do \"info mem\" to see current list of code numbers."
argument_list|,
operator|&
name|deletelist
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"mem"
argument_list|,
name|mem_info_command
argument_list|,
literal|"Memory region attributes"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

