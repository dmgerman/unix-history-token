begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Disassemble support for GDB.     Copyright 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"ui-out.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"disasm.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_comment
comment|/* Disassemble functions.    FIXME: We should get rid of all the duplicate code in gdb that does    the same thing: disassemble_command() and the gdbtk variation. */
end_comment

begin_comment
comment|/* This Structure is used to store line number information.    We need a different sort of line table from the normal one cuz we can't    depend upon implicit line-end pc's for lines to do the    reordering in this function.  */
end_comment

begin_struct
struct|struct
name|dis_line_entry
block|{
name|int
name|line
decl_stmt|;
name|CORE_ADDR
name|start_pc
decl_stmt|;
name|CORE_ADDR
name|end_pc
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Like target_read_memory, but slightly different parameters.  */
end_comment

begin_function
specifier|static
name|int
name|dis_asm_read_memory
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|bfd_byte
modifier|*
name|myaddr
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
return|return
name|target_read_memory
argument_list|(
name|memaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|myaddr
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like memory_error with slightly different parameters.  */
end_comment

begin_function
specifier|static
name|void
name|dis_asm_memory_error
parameter_list|(
name|int
name|status
parameter_list|,
name|bfd_vma
name|memaddr
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
name|memory_error
argument_list|(
name|status
argument_list|,
name|memaddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like print_address with slightly different parameters.  */
end_comment

begin_function
specifier|static
name|void
name|dis_asm_print_address
parameter_list|(
name|bfd_vma
name|addr
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
name|print_address
argument_list|(
name|addr
argument_list|,
name|info
operator|->
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|compare_lines
parameter_list|(
specifier|const
name|void
modifier|*
name|mle1p
parameter_list|,
specifier|const
name|void
modifier|*
name|mle2p
parameter_list|)
block|{
name|struct
name|dis_line_entry
modifier|*
name|mle1
decl_stmt|,
modifier|*
name|mle2
decl_stmt|;
name|int
name|val
decl_stmt|;
name|mle1
operator|=
operator|(
expr|struct
name|dis_line_entry
operator|*
operator|)
name|mle1p
expr_stmt|;
name|mle2
operator|=
operator|(
expr|struct
name|dis_line_entry
operator|*
operator|)
name|mle2p
expr_stmt|;
name|val
operator|=
name|mle1
operator|->
name|line
operator|-
name|mle2
operator|->
name|line
expr_stmt|;
if|if
condition|(
name|val
operator|!=
literal|0
condition|)
return|return
name|val
return|;
return|return
name|mle1
operator|->
name|start_pc
operator|-
name|mle2
operator|->
name|start_pc
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dump_insns
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|di
parameter_list|,
name|CORE_ADDR
name|low
parameter_list|,
name|CORE_ADDR
name|high
parameter_list|,
name|int
name|how_many
parameter_list|,
name|struct
name|ui_stream
modifier|*
name|stb
parameter_list|)
block|{
name|int
name|num_displayed
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
comment|/* parts of the symbolic representation of the address */
name|int
name|unmapped
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|line
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|ui_out_chain
decl_stmt|;
for|for
control|(
name|pc
operator|=
name|low
init|;
name|pc
operator|<
name|high
condition|;
control|)
block|{
name|char
modifier|*
name|filename
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|QUIT
expr_stmt|;
if|if
condition|(
name|how_many
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|num_displayed
operator|>=
name|how_many
condition|)
break|break;
else|else
name|num_displayed
operator|++
expr_stmt|;
block|}
name|ui_out_chain
operator|=
name|make_cleanup_ui_out_tuple_begin_end
argument_list|(
name|uiout
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ui_out_field_core_addr
argument_list|(
name|uiout
argument_list|,
literal|"address"
argument_list|,
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|build_address_symbolic
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|offset
argument_list|,
operator|&
name|filename
argument_list|,
operator|&
name|line
argument_list|,
operator|&
name|unmapped
argument_list|)
condition|)
block|{
comment|/* We don't care now about line, filename and 	     unmapped. But we might in the future. */
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"func-name"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"+"
argument_list|)
expr_stmt|;
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
literal|"offset"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|">:\t"
argument_list|)
expr_stmt|;
block|}
else|else
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|":\t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
operator|!=
name|NULL
condition|)
name|xfree
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
name|xfree
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|ui_file_rewind
argument_list|(
name|stb
operator|->
name|stream
argument_list|)
expr_stmt|;
name|pc
operator|+=
name|TARGET_PRINT_INSN
argument_list|(
name|pc
argument_list|,
name|di
argument_list|)
expr_stmt|;
name|ui_out_field_stream
argument_list|(
name|uiout
argument_list|,
literal|"inst"
argument_list|,
name|stb
argument_list|)
expr_stmt|;
name|ui_file_rewind
argument_list|(
name|stb
operator|->
name|stream
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|ui_out_chain
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|num_displayed
return|;
block|}
end_function

begin_comment
comment|/* The idea here is to present a source-O-centric view of a    function to the user.  This means that things are presented    in source order, with (possibly) out of order assembly    immediately following.  */
end_comment

begin_function
specifier|static
name|void
name|do_mixed_source_and_assembly
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|di
parameter_list|,
name|int
name|nlines
parameter_list|,
name|struct
name|linetable_entry
modifier|*
name|le
parameter_list|,
name|CORE_ADDR
name|low
parameter_list|,
name|CORE_ADDR
name|high
parameter_list|,
name|struct
name|symtab
modifier|*
name|symtab
parameter_list|,
name|int
name|how_many
parameter_list|,
name|struct
name|ui_stream
modifier|*
name|stb
parameter_list|)
block|{
name|int
name|newlines
init|=
literal|0
decl_stmt|;
name|struct
name|dis_line_entry
modifier|*
name|mle
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|out_of_order
init|=
literal|0
decl_stmt|;
name|int
name|next_line
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
name|int
name|num_displayed
init|=
literal|0
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|ui_out_chain
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|ui_out_tuple_chain
init|=
name|make_cleanup
argument_list|(
name|null_cleanup
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|ui_out_list_chain
init|=
name|make_cleanup
argument_list|(
name|null_cleanup
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|mle
operator|=
operator|(
expr|struct
name|dis_line_entry
operator|*
operator|)
name|alloca
argument_list|(
name|nlines
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dis_line_entry
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy linetable entries for this function into our data      structure, creating end_pc's and setting out_of_order as      appropriate.  */
comment|/* First, skip all the preceding functions.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nlines
operator|-
literal|1
operator|&&
name|le
index|[
name|i
index|]
operator|.
name|pc
operator|<
name|low
condition|;
name|i
operator|++
control|)
empty_stmt|;
comment|/* Now, copy all entries before the end of this function.  */
for|for
control|(
init|;
name|i
operator|<
name|nlines
operator|-
literal|1
operator|&&
name|le
index|[
name|i
index|]
operator|.
name|pc
operator|<
name|high
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|le
index|[
name|i
index|]
operator|.
name|line
operator|==
name|le
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|line
operator|&&
name|le
index|[
name|i
index|]
operator|.
name|pc
operator|==
name|le
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|pc
condition|)
continue|continue;
comment|/* Ignore duplicates */
comment|/* Skip any end-of-function markers.  */
if|if
condition|(
name|le
index|[
name|i
index|]
operator|.
name|line
operator|==
literal|0
condition|)
continue|continue;
name|mle
index|[
name|newlines
index|]
operator|.
name|line
operator|=
name|le
index|[
name|i
index|]
operator|.
name|line
expr_stmt|;
if|if
condition|(
name|le
index|[
name|i
index|]
operator|.
name|line
operator|>
name|le
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|line
condition|)
name|out_of_order
operator|=
literal|1
expr_stmt|;
name|mle
index|[
name|newlines
index|]
operator|.
name|start_pc
operator|=
name|le
index|[
name|i
index|]
operator|.
name|pc
expr_stmt|;
name|mle
index|[
name|newlines
index|]
operator|.
name|end_pc
operator|=
name|le
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|pc
expr_stmt|;
name|newlines
operator|++
expr_stmt|;
block|}
comment|/* If we're on the last line, and it's part of the function,      then we need to get the end pc in a special way.  */
if|if
condition|(
name|i
operator|==
name|nlines
operator|-
literal|1
operator|&&
name|le
index|[
name|i
index|]
operator|.
name|pc
operator|<
name|high
condition|)
block|{
name|mle
index|[
name|newlines
index|]
operator|.
name|line
operator|=
name|le
index|[
name|i
index|]
operator|.
name|line
expr_stmt|;
name|mle
index|[
name|newlines
index|]
operator|.
name|start_pc
operator|=
name|le
index|[
name|i
index|]
operator|.
name|pc
expr_stmt|;
name|sal
operator|=
name|find_pc_line
argument_list|(
name|le
index|[
name|i
index|]
operator|.
name|pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mle
index|[
name|newlines
index|]
operator|.
name|end_pc
operator|=
name|sal
operator|.
name|end
expr_stmt|;
name|newlines
operator|++
expr_stmt|;
block|}
comment|/* Now, sort mle by line #s (and, then by addresses within      lines). */
if|if
condition|(
name|out_of_order
condition|)
name|qsort
argument_list|(
name|mle
argument_list|,
name|newlines
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dis_line_entry
argument_list|)
argument_list|,
name|compare_lines
argument_list|)
expr_stmt|;
comment|/* Now, for each line entry, emit the specified lines (unless      they have been emitted before), followed by the assembly code      for that line.  */
name|ui_out_chain
operator|=
name|make_cleanup_ui_out_list_begin_end
argument_list|(
name|uiout
argument_list|,
literal|"asm_insns"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|newlines
condition|;
name|i
operator|++
control|)
block|{
comment|/* Print out everything from next_line to the current line.  */
if|if
condition|(
name|mle
index|[
name|i
index|]
operator|.
name|line
operator|>=
name|next_line
condition|)
block|{
if|if
condition|(
name|next_line
operator|!=
literal|0
condition|)
block|{
comment|/* Just one line to print. */
if|if
condition|(
name|next_line
operator|==
name|mle
index|[
name|i
index|]
operator|.
name|line
condition|)
block|{
name|ui_out_tuple_chain
operator|=
name|make_cleanup_ui_out_tuple_begin_end
argument_list|(
name|uiout
argument_list|,
literal|"src_and_asm_line"
argument_list|)
expr_stmt|;
name|print_source_lines
argument_list|(
name|symtab
argument_list|,
name|next_line
argument_list|,
name|mle
index|[
name|i
index|]
operator|.
name|line
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Several source lines w/o asm instructions associated. */
for|for
control|(
init|;
name|next_line
operator|<
name|mle
index|[
name|i
index|]
operator|.
name|line
condition|;
name|next_line
operator|++
control|)
block|{
name|struct
name|cleanup
modifier|*
name|ui_out_list_chain_line
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|ui_out_tuple_chain_line
decl_stmt|;
name|ui_out_tuple_chain_line
operator|=
name|make_cleanup_ui_out_tuple_begin_end
argument_list|(
name|uiout
argument_list|,
literal|"src_and_asm_line"
argument_list|)
expr_stmt|;
name|print_source_lines
argument_list|(
name|symtab
argument_list|,
name|next_line
argument_list|,
name|next_line
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ui_out_list_chain_line
operator|=
name|make_cleanup_ui_out_list_begin_end
argument_list|(
name|uiout
argument_list|,
literal|"line_asm_insn"
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|ui_out_list_chain_line
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|ui_out_tuple_chain_line
argument_list|)
expr_stmt|;
block|}
comment|/* Print the last line and leave list open for 		     asm instructions to be added. */
name|ui_out_tuple_chain
operator|=
name|make_cleanup_ui_out_tuple_begin_end
argument_list|(
name|uiout
argument_list|,
literal|"src_and_asm_line"
argument_list|)
expr_stmt|;
name|print_source_lines
argument_list|(
name|symtab
argument_list|,
name|next_line
argument_list|,
name|mle
index|[
name|i
index|]
operator|.
name|line
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ui_out_tuple_chain
operator|=
name|make_cleanup_ui_out_tuple_begin_end
argument_list|(
name|uiout
argument_list|,
literal|"src_and_asm_line"
argument_list|)
expr_stmt|;
name|print_source_lines
argument_list|(
name|symtab
argument_list|,
name|mle
index|[
name|i
index|]
operator|.
name|line
argument_list|,
name|mle
index|[
name|i
index|]
operator|.
name|line
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|next_line
operator|=
name|mle
index|[
name|i
index|]
operator|.
name|line
operator|+
literal|1
expr_stmt|;
name|ui_out_list_chain
operator|=
name|make_cleanup_ui_out_list_begin_end
argument_list|(
name|uiout
argument_list|,
literal|"line_asm_insn"
argument_list|)
expr_stmt|;
block|}
name|num_displayed
operator|+=
name|dump_insns
argument_list|(
name|uiout
argument_list|,
name|di
argument_list|,
name|mle
index|[
name|i
index|]
operator|.
name|start_pc
argument_list|,
name|mle
index|[
name|i
index|]
operator|.
name|end_pc
argument_list|,
name|how_many
argument_list|,
name|stb
argument_list|)
expr_stmt|;
comment|/* When we've reached the end of the mle array, or we've seen the last          assembly range for this source line, close out the list/tuple.  */
if|if
condition|(
name|i
operator|==
operator|(
name|newlines
operator|-
literal|1
operator|)
operator|||
name|mle
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|line
operator|>
name|mle
index|[
name|i
index|]
operator|.
name|line
condition|)
block|{
name|do_cleanups
argument_list|(
name|ui_out_list_chain
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|ui_out_tuple_chain
argument_list|)
expr_stmt|;
name|ui_out_tuple_chain
operator|=
name|make_cleanup
argument_list|(
name|null_cleanup
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ui_out_list_chain
operator|=
name|make_cleanup
argument_list|(
name|null_cleanup
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|how_many
operator|>=
literal|0
operator|&&
name|num_displayed
operator|>=
name|how_many
condition|)
break|break;
block|}
name|do_cleanups
argument_list|(
name|ui_out_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_assembly_only
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|struct
name|disassemble_info
modifier|*
name|di
parameter_list|,
name|CORE_ADDR
name|low
parameter_list|,
name|CORE_ADDR
name|high
parameter_list|,
name|int
name|how_many
parameter_list|,
name|struct
name|ui_stream
modifier|*
name|stb
parameter_list|)
block|{
name|int
name|num_displayed
init|=
literal|0
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|ui_out_chain
decl_stmt|;
name|ui_out_chain
operator|=
name|make_cleanup_ui_out_list_begin_end
argument_list|(
name|uiout
argument_list|,
literal|"asm_insns"
argument_list|)
expr_stmt|;
name|num_displayed
operator|=
name|dump_insns
argument_list|(
name|uiout
argument_list|,
name|di
argument_list|,
name|low
argument_list|,
name|high
argument_list|,
name|how_many
argument_list|,
name|stb
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|ui_out_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the disassemble info struct ready for the specified    stream.  */
end_comment

begin_function
specifier|static
name|int
name|fprintf_disasm
parameter_list|(
name|void
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|vfprintf_filtered
argument_list|(
name|stream
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
comment|/* Something non -ve.  */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|disassemble_info
name|gdb_disassemble_info
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|ui_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|disassemble_info
name|di
decl_stmt|;
name|init_disassemble_info
argument_list|(
operator|&
name|di
argument_list|,
name|file
argument_list|,
name|fprintf_disasm
argument_list|)
expr_stmt|;
name|di
operator|.
name|flavour
operator|=
name|bfd_target_unknown_flavour
expr_stmt|;
name|di
operator|.
name|memory_error_func
operator|=
name|dis_asm_memory_error
expr_stmt|;
name|di
operator|.
name|print_address_func
operator|=
name|dis_asm_print_address
expr_stmt|;
comment|/* NOTE: cagney/2003-04-28: The original code, from the old Insight      disassembler had a local optomization here.  By default it would      access the executable file, instead of the target memory (there      was a growing list of exceptions though).  Unfortunately, the      heuristic was flawed.  Commands like "disassemble&variable"      didn't work as they relied on the access going to the target.      Further, it has been supperseeded by trust-read-only-sections      (although that should be superseeded by target_trust..._p()).  */
name|di
operator|.
name|read_memory_func
operator|=
name|dis_asm_read_memory
expr_stmt|;
name|di
operator|.
name|arch
operator|=
name|gdbarch_bfd_arch_info
argument_list|(
name|gdbarch
argument_list|)
operator|->
name|arch
expr_stmt|;
name|di
operator|.
name|mach
operator|=
name|gdbarch_bfd_arch_info
argument_list|(
name|gdbarch
argument_list|)
operator|->
name|mach
expr_stmt|;
name|di
operator|.
name|endian
operator|=
name|gdbarch_byte_order
argument_list|(
name|gdbarch
argument_list|)
expr_stmt|;
return|return
name|di
return|;
block|}
end_function

begin_function
name|void
name|gdb_disassembly
parameter_list|(
name|struct
name|ui_out
modifier|*
name|uiout
parameter_list|,
name|char
modifier|*
name|file_string
parameter_list|,
name|int
name|line_num
parameter_list|,
name|int
name|mixed_source_and_assembly
parameter_list|,
name|int
name|how_many
parameter_list|,
name|CORE_ADDR
name|low
parameter_list|,
name|CORE_ADDR
name|high
parameter_list|)
block|{
name|struct
name|ui_stream
modifier|*
name|stb
init|=
name|ui_out_stream_new
argument_list|(
name|uiout
argument_list|)
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|cleanups
init|=
name|make_cleanup_ui_out_stream_delete
argument_list|(
name|stb
argument_list|)
decl_stmt|;
name|struct
name|disassemble_info
name|di
init|=
name|gdb_disassemble_info
argument_list|(
name|current_gdbarch
argument_list|,
name|stb
operator|->
name|stream
argument_list|)
decl_stmt|;
comment|/* To collect the instruction outputted from opcodes. */
name|struct
name|symtab
modifier|*
name|symtab
init|=
name|NULL
decl_stmt|;
name|struct
name|linetable_entry
modifier|*
name|le
init|=
name|NULL
decl_stmt|;
name|int
name|nlines
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Assume symtab is valid for whole PC range */
name|symtab
operator|=
name|find_pc_symtab
argument_list|(
name|low
argument_list|)
expr_stmt|;
if|if
condition|(
name|symtab
operator|!=
name|NULL
operator|&&
name|symtab
operator|->
name|linetable
operator|!=
name|NULL
condition|)
block|{
comment|/* Convert the linetable to a bunch of my_line_entry's.  */
name|le
operator|=
name|symtab
operator|->
name|linetable
operator|->
name|item
expr_stmt|;
name|nlines
operator|=
name|symtab
operator|->
name|linetable
operator|->
name|nitems
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mixed_source_and_assembly
operator|||
name|nlines
operator|<=
literal|0
operator|||
name|symtab
operator|==
name|NULL
operator|||
name|symtab
operator|->
name|linetable
operator|==
name|NULL
condition|)
name|do_assembly_only
argument_list|(
name|uiout
argument_list|,
operator|&
name|di
argument_list|,
name|low
argument_list|,
name|high
argument_list|,
name|how_many
argument_list|,
name|stb
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mixed_source_and_assembly
condition|)
name|do_mixed_source_and_assembly
argument_list|(
name|uiout
argument_list|,
operator|&
name|di
argument_list|,
name|nlines
argument_list|,
name|le
argument_list|,
name|low
argument_list|,
name|high
argument_list|,
name|symtab
argument_list|,
name|how_many
argument_list|,
name|stb
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|cleanups
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the instruction at address MEMADDR in debugged memory,    on STREAM.  Returns length of the instruction, in bytes.  */
end_comment

begin_function
name|int
name|gdb_print_insn
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|struct
name|disassemble_info
name|di
init|=
name|gdb_disassemble_info
argument_list|(
name|current_gdbarch
argument_list|,
name|stream
argument_list|)
decl_stmt|;
return|return
name|TARGET_PRINT_INSN
argument_list|(
name|memaddr
argument_list|,
operator|&
name|di
argument_list|)
return|;
block|}
end_function

end_unit

