begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Native-dependent code for GNU/Linux x86-64.     Copyright 2001, 2002 Free Software Foundation, Inc.     Contributed by Jiri Smid, SuSE Labs.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"x86-64-tdep.h"
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/debugreg.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_include
include|#
directive|include
file|<sys/procfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/reg.h>
end_include

begin_comment
comment|/* Mapping between the general-purpose registers in `struct user'    format and GDB's register array layout.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|x86_64_regmap
index|[]
init|=
block|{
name|RAX
block|,
name|RBX
block|,
name|RCX
block|,
name|RDX
block|,
name|RSI
block|,
name|RDI
block|,
name|RBP
block|,
name|RSP
block|,
name|R8
block|,
name|R9
block|,
name|R10
block|,
name|R11
block|,
name|R12
block|,
name|R13
block|,
name|R14
block|,
name|R15
block|,
name|RIP
block|,
name|EFLAGS
block|,
name|DS
block|,
name|ES
block|,
name|FS
block|,
name|GS
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|unsigned
name|long
name|x86_64_linux_dr_get
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
name|int
name|tid
decl_stmt|;
name|unsigned
name|long
name|value
decl_stmt|;
comment|/* FIXME: kettenis/2001-01-29: It's not clear what we should do with      multi-threaded processes here.  For now, pretend there is just      one thread.  */
name|tid
operator|=
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
comment|/* FIXME: kettenis/2001-03-27: Calling perror_with_name if the      ptrace call fails breaks debugging remote targets.  The correct      way to fix this is to add the hardware breakpoint and watchpoint      stuff to the target vectore.  For now, just return zero if the      ptrace call fails.  */
name|errno
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|ptrace
argument_list|(
name|PT_READ_U
argument_list|,
name|tid
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|user
argument_list|,
name|u_debugreg
index|[
name|regnum
index|]
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
if|#
directive|if
literal|0
then|perror_with_name ("Couldn't read debug register");
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
return|return
name|value
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|x86_64_linux_dr_set
parameter_list|(
name|int
name|regnum
parameter_list|,
name|unsigned
name|long
name|value
parameter_list|)
block|{
name|int
name|tid
decl_stmt|;
comment|/* FIXME: kettenis/2001-01-29: It's not clear what we should do with      multi-threaded processes here.  For now, pretend there is just      one thread.  */
name|tid
operator|=
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|PT_WRITE_U
argument_list|,
name|tid
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|user
argument_list|,
name|u_debugreg
index|[
name|regnum
index|]
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"Couldn't write debug register"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|x86_64_linux_dr_set_control
parameter_list|(
name|unsigned
name|long
name|control
parameter_list|)
block|{
name|x86_64_linux_dr_set
argument_list|(
name|DR_CONTROL
argument_list|,
name|control
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|x86_64_linux_dr_set_addr
parameter_list|(
name|int
name|regnum
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<=
name|DR_LASTADDR
operator|-
name|DR_FIRSTADDR
argument_list|)
expr_stmt|;
name|x86_64_linux_dr_set
argument_list|(
name|DR_FIRSTADDR
operator|+
name|regnum
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|x86_64_linux_dr_reset_addr
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<=
name|DR_LASTADDR
operator|-
name|DR_FIRSTADDR
argument_list|)
expr_stmt|;
name|x86_64_linux_dr_set
argument_list|(
name|DR_FIRSTADDR
operator|+
name|regnum
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|long
name|x86_64_linux_dr_get_status
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|x86_64_linux_dr_get
argument_list|(
name|DR_STATUS
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The register sets used in GNU/Linux ELF core-dumps are identical to    the register sets used by `ptrace'.  */
end_comment

begin_define
define|#
directive|define
name|GETREGS_SUPPLIES
parameter_list|(
name|regno
parameter_list|)
define|\
value|(0<= (regno)&& (regno)< x86_64_num_gregs)
end_define

begin_define
define|#
directive|define
name|GETFPREGS_SUPPLIES
parameter_list|(
name|regno
parameter_list|)
define|\
value|(FP0_REGNUM<= (regno)&& (regno)<= MXCSR_REGNUM)
end_define

begin_escape
end_escape

begin_comment
comment|/* Transfering the general-purpose registers between GDB, inferiors    and core files.  */
end_comment

begin_comment
comment|/* Fill GDB's register array with the general-purpose register values    in *GREGSETP.  */
end_comment

begin_function
name|void
name|supply_gregset
parameter_list|(
name|elf_gregset_t
modifier|*
name|gregsetp
parameter_list|)
block|{
name|elf_greg_t
modifier|*
name|regp
init|=
operator|(
name|elf_greg_t
operator|*
operator|)
name|gregsetp
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|x86_64_num_gregs
condition|;
name|i
operator|++
control|)
name|supply_register
argument_list|(
name|i
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|x86_64_regmap
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fill register REGNO (if it is a general-purpose register) in    *GREGSETPS with the value in GDB's register array.  If REGNO is -1,    do this for all registers.  */
end_comment

begin_function
name|void
name|fill_gregset
parameter_list|(
name|elf_gregset_t
modifier|*
name|gregsetp
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|elf_greg_t
modifier|*
name|regp
init|=
operator|(
name|elf_greg_t
operator|*
operator|)
name|gregsetp
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|x86_64_num_gregs
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|||
name|regno
operator|==
name|i
operator|)
condition|)
name|read_register_gen
argument_list|(
name|i
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|x86_64_regmap
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fetch all general-purpose registers from process/thread TID and    store their values in GDB's register array.  */
end_comment

begin_function
specifier|static
name|void
name|fetch_regs
parameter_list|(
name|int
name|tid
parameter_list|)
block|{
name|elf_gregset_t
name|regs
decl_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PTRACE_GETREGS
argument_list|,
name|tid
argument_list|,
literal|0
argument_list|,
operator|(
name|long
operator|)
operator|&
name|regs
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"Couldn't get registers"
argument_list|)
expr_stmt|;
name|supply_gregset
argument_list|(
operator|&
name|regs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store all valid general-purpose registers in GDB's register array    into the process/thread specified by TID.  */
end_comment

begin_function
specifier|static
name|void
name|store_regs
parameter_list|(
name|int
name|tid
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|elf_gregset_t
name|regs
decl_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PTRACE_GETREGS
argument_list|,
name|tid
argument_list|,
literal|0
argument_list|,
operator|(
name|long
operator|)
operator|&
name|regs
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"Couldn't get registers"
argument_list|)
expr_stmt|;
name|fill_gregset
argument_list|(
operator|&
name|regs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PTRACE_SETREGS
argument_list|,
name|tid
argument_list|,
literal|0
argument_list|,
operator|(
name|long
operator|)
operator|&
name|regs
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"Couldn't write registers"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Transfering floating-point registers between GDB, inferiors and cores.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|x86_64_fxsave_offset
parameter_list|(
name|elf_fpregset_t
modifier|*
name|fxsave
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|reg_name
decl_stmt|;
name|int
name|reg_index
decl_stmt|;
name|gdb_assert
argument_list|(
name|x86_64_num_gregs
operator|-
literal|1
operator|<
name|regnum
operator|&&
name|regnum
operator|<
name|x86_64_num_regs
argument_list|)
expr_stmt|;
name|reg_name
operator|=
name|x86_64_register_name
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_name
index|[
literal|0
index|]
operator|==
literal|'s'
operator|&&
name|reg_name
index|[
literal|1
index|]
operator|==
literal|'t'
condition|)
block|{
name|reg_index
operator|=
name|reg_name
index|[
literal|2
index|]
operator|-
literal|'0'
expr_stmt|;
return|return
operator|&
name|fxsave
operator|->
name|st_space
index|[
name|reg_index
operator|*
literal|2
index|]
return|;
block|}
if|if
condition|(
name|reg_name
index|[
literal|0
index|]
operator|==
literal|'x'
operator|&&
name|reg_name
index|[
literal|1
index|]
operator|==
literal|'m'
operator|&&
name|reg_name
index|[
literal|2
index|]
operator|==
literal|'m'
condition|)
block|{
name|reg_index
operator|=
name|reg_name
index|[
literal|3
index|]
operator|-
literal|'0'
expr_stmt|;
return|return
operator|&
name|fxsave
operator|->
name|xmm_space
index|[
name|reg_index
operator|*
literal|4
index|]
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|reg_name
argument_list|,
literal|"mxcsr"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|&
name|fxsave
operator|->
name|mxcsr
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Fill GDB's register array with the floating-point and SSE register    values in *FXSAVE.  This function masks off any of the reserved    bits in *FXSAVE.  */
end_comment

begin_function
name|void
name|supply_fpregset
parameter_list|(
name|elf_fpregset_t
modifier|*
name|fxsave
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|reg_st0
decl_stmt|,
name|reg_mxcsr
decl_stmt|;
name|reg_st0
operator|=
name|x86_64_register_number
argument_list|(
literal|"st0"
argument_list|)
expr_stmt|;
name|reg_mxcsr
operator|=
name|x86_64_register_number
argument_list|(
literal|"mxcsr"
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|reg_st0
operator|>
literal|0
operator|&&
name|reg_mxcsr
operator|>
name|reg_st0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|reg_st0
init|;
name|i
operator|<=
name|reg_mxcsr
condition|;
name|i
operator|++
control|)
name|supply_register
argument_list|(
name|i
argument_list|,
name|x86_64_fxsave_offset
argument_list|(
name|fxsave
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fill register REGNUM (if it is a floating-point or SSE register) in    *FXSAVE with the value in GDB's register array.  If REGNUM is -1, do    this for all registers.  This function doesn't touch any of the    reserved bits in *FXSAVE.  */
end_comment

begin_function
name|void
name|fill_fpregset
parameter_list|(
name|elf_fpregset_t
modifier|*
name|fxsave
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|last_regnum
init|=
name|MXCSR_REGNUM
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|num_xmm_regs
operator|==
literal|0
condition|)
name|last_regnum
operator|=
name|FOP_REGNUM
expr_stmt|;
for|for
control|(
name|i
operator|=
name|FP0_REGNUM
init|;
name|i
operator|<=
name|last_regnum
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|regnum
operator|==
operator|-
literal|1
operator|||
name|regnum
operator|==
name|i
condition|)
block|{
name|ptr
operator|=
name|x86_64_fxsave_offset
argument_list|(
name|fxsave
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
name|regcache_collect
argument_list|(
name|i
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Fetch all floating-point registers from process/thread TID and store    thier values in GDB's register array.  */
end_comment

begin_function
specifier|static
name|void
name|fetch_fpregs
parameter_list|(
name|int
name|tid
parameter_list|)
block|{
name|elf_fpregset_t
name|fpregs
decl_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PTRACE_GETFPREGS
argument_list|,
name|tid
argument_list|,
literal|0
argument_list|,
operator|(
name|long
operator|)
operator|&
name|fpregs
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"Couldn't get floating point status"
argument_list|)
expr_stmt|;
name|supply_fpregset
argument_list|(
operator|&
name|fpregs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store all valid floating-point registers in GDB's register array    into the process/thread specified by TID.  */
end_comment

begin_function
specifier|static
name|void
name|store_fpregs
parameter_list|(
name|int
name|tid
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|elf_fpregset_t
name|fpregs
decl_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PTRACE_GETFPREGS
argument_list|,
name|tid
argument_list|,
literal|0
argument_list|,
operator|(
name|long
operator|)
operator|&
name|fpregs
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"Couldn't get floating point status"
argument_list|)
expr_stmt|;
name|fill_fpregset
argument_list|(
operator|&
name|fpregs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PTRACE_SETFPREGS
argument_list|,
name|tid
argument_list|,
literal|0
argument_list|,
operator|(
name|long
operator|)
operator|&
name|fpregs
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"Couldn't write floating point status"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Transferring arbitrary registers between GDB and inferior.  */
end_comment

begin_comment
comment|/* Fetch register REGNO from the child process.  If REGNO is -1, do    this for all registers (including the floating point and SSE    registers).  */
end_comment

begin_function
name|void
name|fetch_inferior_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|int
name|tid
decl_stmt|;
comment|/* GNU/Linux LWP ID's are process ID's.  */
if|if
condition|(
operator|(
name|tid
operator|=
name|TIDGET
argument_list|(
name|inferior_ptid
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|tid
operator|=
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
comment|/* Not a threaded program.  */
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
name|fetch_regs
argument_list|(
name|tid
argument_list|)
expr_stmt|;
name|fetch_fpregs
argument_list|(
name|tid
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GETREGS_SUPPLIES
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|fetch_regs
argument_list|(
name|tid
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GETFPREGS_SUPPLIES
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|fetch_fpregs
argument_list|(
name|tid
argument_list|)
expr_stmt|;
return|return;
block|}
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Got request for bad register number %d."
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store register REGNO back into the child process.  If REGNO is -1,    do this for all registers (including the floating point and SSE    registers).  */
end_comment

begin_function
name|void
name|store_inferior_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|int
name|tid
decl_stmt|;
comment|/* GNU/Linux LWP ID's are process ID's.  */
if|if
condition|(
operator|(
name|tid
operator|=
name|TIDGET
argument_list|(
name|inferior_ptid
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|tid
operator|=
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
comment|/* Not a threaded program.  */
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
name|store_regs
argument_list|(
name|tid
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|store_fpregs
argument_list|(
name|tid
argument_list|,
name|regno
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GETREGS_SUPPLIES
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|store_regs
argument_list|(
name|tid
argument_list|,
name|regno
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GETFPREGS_SUPPLIES
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|store_fpregs
argument_list|(
name|tid
argument_list|,
name|regno
argument_list|)
expr_stmt|;
return|return;
block|}
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Got request to store bad register number %d."
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
name|linux_syscall
index|[]
init|=
block|{
literal|0x0f
block|,
literal|0x05
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LINUX_SYSCALL_LEN
value|(sizeof linux_syscall)
end_define

begin_comment
comment|/* The system call number is stored in the %rax register.  */
end_comment

begin_define
define|#
directive|define
name|LINUX_SYSCALL_REGNUM
value|0
end_define

begin_comment
comment|/* %rax */
end_comment

begin_comment
comment|/* We are specifically interested in the sigreturn and rt_sigreturn    system calls.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SYS_sigreturn
end_ifndef

begin_define
define|#
directive|define
name|SYS_sigreturn
value|__NR_sigreturn
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SYS_rt_sigreturn
end_ifndef

begin_define
define|#
directive|define
name|SYS_rt_sigreturn
value|__NR_rt_sigreturn
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Offset to saved processor flags, from<asm/sigcontext.h>.  */
end_comment

begin_define
define|#
directive|define
name|LINUX_SIGCONTEXT_EFLAGS_OFFSET
value|(152)
end_define

begin_comment
comment|/* Offset to saved processor registers from<asm/ucontext.h> */
end_comment

begin_define
define|#
directive|define
name|LINUX_UCONTEXT_SIGCONTEXT_OFFSET
value|(36)
end_define

begin_comment
comment|/* Interpreting register set info found in core files.  */
end_comment

begin_comment
comment|/* Provide registers to GDB from a core file.     CORE_REG_SECT points to an array of bytes, which are the contents    of a `note' from a core file which BFD thinks might contain    register contents.  CORE_REG_SIZE is its size.     WHICH says which register set corelow suspects this is:      0 --- the general-purpose register set, in elf_gregset_t format      2 --- the floating-point register set, in elf_fpregset_t format     REG_ADDR isn't used on GNU/Linux.  */
end_comment

begin_function
specifier|static
name|void
name|fetch_core_registers
parameter_list|(
name|char
modifier|*
name|core_reg_sect
parameter_list|,
name|unsigned
name|core_reg_size
parameter_list|,
name|int
name|which
parameter_list|,
name|CORE_ADDR
name|reg_addr
parameter_list|)
block|{
name|elf_gregset_t
name|gregset
decl_stmt|;
name|elf_fpregset_t
name|fpregset
decl_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|core_reg_size
operator|!=
sizeof|sizeof
argument_list|(
name|gregset
argument_list|)
condition|)
name|warning
argument_list|(
literal|"Wrong size gregset in core file."
argument_list|)
expr_stmt|;
else|else
block|{
name|memcpy
argument_list|(
operator|&
name|gregset
argument_list|,
name|core_reg_sect
argument_list|,
sizeof|sizeof
argument_list|(
name|gregset
argument_list|)
argument_list|)
expr_stmt|;
name|supply_gregset
argument_list|(
operator|&
name|gregset
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|core_reg_size
operator|!=
sizeof|sizeof
argument_list|(
name|fpregset
argument_list|)
condition|)
name|warning
argument_list|(
literal|"Wrong size fpregset in core file."
argument_list|)
expr_stmt|;
else|else
block|{
name|memcpy
argument_list|(
operator|&
name|fpregset
argument_list|,
name|core_reg_sect
argument_list|,
sizeof|sizeof
argument_list|(
name|fpregset
argument_list|)
argument_list|)
expr_stmt|;
name|supply_fpregset
argument_list|(
operator|&
name|fpregset
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* We've covered all the kinds of registers we know about here,          so this must be something we wouldn't know what to do with          anyway.  Just ignore it.  */
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Register that we are able to handle GNU/Linux ELF core file formats.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|core_fns
name|linux_elf_core_fns
init|=
block|{
name|bfd_target_elf_flavour
block|,
comment|/* core_flavour */
name|default_check_format
block|,
comment|/* check_format */
name|default_core_sniffer
block|,
comment|/* core_sniffer */
name|fetch_core_registers
block|,
comment|/* core_read_registers */
name|NULL
comment|/* next */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|offsetof
argument_list|)
end_if

begin_define
define|#
directive|define
name|offsetof
parameter_list|(
name|TYPE
parameter_list|,
name|MEMBER
parameter_list|)
value|((unsigned long)&((TYPE *)0)->MEMBER)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return the address of register REGNUM.  BLOCKEND is the value of    u.u_ar0, which should point to the registers.  */
end_comment

begin_function
name|CORE_ADDR
name|x86_64_register_u_addr
parameter_list|(
name|CORE_ADDR
name|blockend
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
name|struct
name|user
name|u
decl_stmt|;
name|CORE_ADDR
name|fpstate
decl_stmt|;
name|CORE_ADDR
name|ubase
decl_stmt|;
name|ubase
operator|=
name|blockend
expr_stmt|;
if|if
condition|(
name|IS_FP_REGNUM
argument_list|(
name|regnum
argument_list|)
condition|)
block|{
name|fpstate
operator|=
name|ubase
operator|+
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|u
operator|.
name|i387
operator|.
name|st_space
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|u
operator|)
expr_stmt|;
return|return
operator|(
name|fpstate
operator|+
literal|16
operator|*
operator|(
name|regnum
operator|-
name|FP0_REGNUM
operator|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|IS_SSE_REGNUM
argument_list|(
name|regnum
argument_list|)
condition|)
block|{
name|fpstate
operator|=
name|ubase
operator|+
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|u
operator|.
name|i387
operator|.
name|xmm_space
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|u
operator|)
expr_stmt|;
return|return
operator|(
name|fpstate
operator|+
literal|16
operator|*
operator|(
name|regnum
operator|-
name|XMM0_REGNUM
operator|)
operator|)
return|;
block|}
else|else
return|return
operator|(
name|ubase
operator|+
literal|8
operator|*
name|x86_64_regmap
index|[
name|regnum
index|]
operator|)
return|;
block|}
end_function

begin_function
name|void
name|_initialize_x86_64_linux_nat
parameter_list|(
name|void
parameter_list|)
block|{
name|add_core_fns
argument_list|(
operator|&
name|linux_elf_core_fns
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|kernel_u_size
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|user
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

