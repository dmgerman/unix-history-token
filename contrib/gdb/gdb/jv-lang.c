begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Java language support routines for GDB, the GNU debugger.    Copyright 1997, 1998, 1999 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"parser-defs.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"c-lang.h"
end_include

begin_include
include|#
directive|include
file|"jv-lang.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_decl_stmt
name|struct
name|type
modifier|*
name|java_int_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|java_byte_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|java_short_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|java_long_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|java_boolean_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|java_char_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|java_float_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|java_double_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|java_void_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|java_demangled_signature_length
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|java_demangled_signature_copy
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|java_emit_char
name|PARAMS
argument_list|(
operator|(
name|int
name|c
operator|,
name|GDB_FILE
operator|*
name|stream
operator|,
name|int
name|quoter
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This objfile contains symtabs that have been dynamically created    to record dynamically loaded Java classes and dynamically    compiled java methods. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|objfile
modifier|*
name|dynamics_objfile
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|java_link_class_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|,
name|value_ptr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|objfile
modifier|*
name|get_dynamics_objfile
parameter_list|()
block|{
if|if
condition|(
name|dynamics_objfile
operator|==
name|NULL
condition|)
block|{
name|dynamics_objfile
operator|=
name|allocate_objfile
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|dynamics_objfile
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|1
end_if

begin_comment
comment|/* symtab contains classes read from the inferior. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|symtab
modifier|*
name|class_symtab
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum number of class in class_symtab before relocation is needed. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|class_symtab_space
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|symtab
modifier|*
name|get_java_class_symtab
parameter_list|()
block|{
if|if
condition|(
name|class_symtab
operator|==
name|NULL
condition|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|get_dynamics_objfile
argument_list|()
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
name|struct
name|block
modifier|*
name|bl
decl_stmt|;
name|class_symtab
operator|=
name|allocate_symtab
argument_list|(
literal|"<java-classes>"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|class_symtab
operator|->
name|language
operator|=
name|language_java
expr_stmt|;
name|bv
operator|=
operator|(
expr|struct
name|blockvector
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|blockvector
argument_list|)
argument_list|)
expr_stmt|;
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bv
argument_list|)
operator|=
literal|1
expr_stmt|;
name|BLOCKVECTOR
argument_list|(
name|class_symtab
argument_list|)
operator|=
name|bv
expr_stmt|;
comment|/* Allocate dummy STATIC_BLOCK. */
name|bl
operator|=
operator|(
expr|struct
name|block
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|block
argument_list|)
argument_list|)
expr_stmt|;
name|BLOCK_NSYMS
argument_list|(
name|bl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|BLOCK_START
argument_list|(
name|bl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|BLOCK_END
argument_list|(
name|bl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|BLOCK_FUNCTION
argument_list|(
name|bl
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|BLOCK_SUPERBLOCK
argument_list|(
name|bl
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|BLOCK_GCC_COMPILED
argument_list|(
name|bl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
operator|=
name|bl
expr_stmt|;
comment|/* Allocate GLOBAL_BLOCK.  This has to be relocatable. */
name|class_symtab_space
operator|=
literal|128
expr_stmt|;
name|bl
operator|=
operator|(
expr|struct
name|block
operator|*
operator|)
name|mmalloc
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|block
argument_list|)
operator|+
operator|(
operator|(
name|class_symtab_space
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
operator|*
name|bl
operator|=
operator|*
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
expr_stmt|;
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
operator|=
name|bl
expr_stmt|;
name|class_symtab
operator|->
name|free_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|bl
expr_stmt|;
block|}
return|return
name|class_symtab
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_class_symtab_symbol
parameter_list|(
name|sym
parameter_list|)
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
block|{
name|struct
name|symtab
modifier|*
name|symtab
init|=
name|get_java_class_symtab
argument_list|()
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|bv
init|=
name|BLOCKVECTOR
argument_list|(
name|symtab
argument_list|)
decl_stmt|;
name|struct
name|block
modifier|*
name|bl
init|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
decl_stmt|;
if|if
condition|(
name|BLOCK_NSYMS
argument_list|(
name|bl
argument_list|)
operator|>=
name|class_symtab_space
condition|)
block|{
comment|/* Need to re-allocate. */
name|class_symtab_space
operator|*=
literal|2
expr_stmt|;
name|bl
operator|=
operator|(
expr|struct
name|block
operator|*
operator|)
name|mrealloc
argument_list|(
name|symtab
operator|->
name|objfile
operator|->
name|md
argument_list|,
name|bl
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|block
argument_list|)
operator|+
operator|(
operator|(
name|class_symtab_space
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|class_symtab
operator|->
name|free_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|bl
expr_stmt|;
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
operator|=
name|bl
expr_stmt|;
block|}
name|BLOCK_SYM
argument_list|(
name|bl
argument_list|,
name|BLOCK_NSYMS
argument_list|(
name|bl
argument_list|)
argument_list|)
operator|=
name|sym
expr_stmt|;
name|BLOCK_NSYMS
argument_list|(
name|bl
argument_list|)
operator|=
name|BLOCK_NSYMS
argument_list|(
name|bl
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|symbol
modifier|*
name|add_class_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
name|type
operator|,
name|CORE_ADDR
name|addr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|symbol
modifier|*
name|add_class_symbol
parameter_list|(
name|type
parameter_list|,
name|addr
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|dynamics_objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_LANGUAGE
argument_list|(
name|sym
argument_list|)
operator|=
name|language_java
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_TYPEDEF
expr_stmt|;
comment|/*  SYMBOL_VALUE (sym) = valu;*/
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|type
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|STRUCT_NAMESPACE
expr_stmt|;
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|=
name|addr
expr_stmt|;
return|return
name|sym
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|struct
name|type
modifier|*
name|java_lookup_class
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|name
argument_list|,
name|expression_context_block
argument_list|,
name|STRUCT_NAMESPACE
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
return|return
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
return|;
if|#
directive|if
literal|0
block|CORE_ADDR addr;   if (called from parser)     {       call lookup_class (or similar) in inferior;       if not found: 	return NULL;       addr = found in inferior;     }   else     addr = 0;   struct type *type;   type = alloc_type (objfile);   TYPE_CODE (type) = TYPE_CODE_STRUCT;   INIT_CPLUS_SPECIFIC (type);   TYPE_TAG_NAME (type) = obsavestring (name, strlen(name),&objfile->type_obstack);   TYPE_FLAGS (type) |= TYPE_FLAG_STUB;   TYPE ? = addr;   return type;
else|#
directive|else
comment|/* FIXME - should search inferior's symbol table. */
return|return
name|NULL
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Return a nul-terminated string (allocated on OBSTACK) for    a name given by NAME (which has type Utf8Const*). */
end_comment

begin_function
name|char
modifier|*
name|get_java_utf8_name
parameter_list|(
name|obstack
parameter_list|,
name|name
parameter_list|)
name|struct
name|obstack
modifier|*
name|obstack
decl_stmt|;
name|value_ptr
name|name
decl_stmt|;
block|{
name|char
modifier|*
name|chrs
decl_stmt|;
name|value_ptr
name|temp
init|=
name|name
decl_stmt|;
name|int
name|name_length
decl_stmt|;
name|CORE_ADDR
name|data_addr
decl_stmt|;
name|temp
operator|=
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
literal|"length"
argument_list|,
name|NULL
argument_list|,
literal|"structure"
argument_list|)
expr_stmt|;
name|name_length
operator|=
operator|(
name|int
operator|)
name|value_as_long
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|data_addr
operator|=
name|VALUE_ADDRESS
argument_list|(
name|temp
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|temp
argument_list|)
operator|+
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|chrs
operator|=
name|obstack_alloc
argument_list|(
name|obstack
argument_list|,
name|name_length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|chrs
index|[
name|name_length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|read_memory_section
argument_list|(
name|data_addr
argument_list|,
name|chrs
argument_list|,
name|name_length
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|chrs
return|;
block|}
end_function

begin_function
name|value_ptr
name|java_class_from_object
parameter_list|(
name|obj_val
parameter_list|)
name|value_ptr
name|obj_val
decl_stmt|;
block|{
comment|/* This is all rather inefficient, since the offsets of vtable and      class are fixed.  FIXME */
name|value_ptr
name|vtable_val
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|obj_val
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|&&
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|obj_val
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|obj_val
operator|=
name|value_at
argument_list|(
name|get_java_object_type
argument_list|()
argument_list|,
name|value_as_pointer
argument_list|(
name|obj_val
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|vtable_val
operator|=
name|value_struct_elt
argument_list|(
operator|&
name|obj_val
argument_list|,
name|NULL
argument_list|,
literal|"vtable"
argument_list|,
name|NULL
argument_list|,
literal|"structure"
argument_list|)
expr_stmt|;
return|return
name|value_struct_elt
argument_list|(
operator|&
name|vtable_val
argument_list|,
name|NULL
argument_list|,
literal|"class"
argument_list|,
name|NULL
argument_list|,
literal|"structure"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Check if CLASS_IS_PRIMITIVE(value of clas): */
end_comment

begin_function
name|int
name|java_class_is_primitive
parameter_list|(
name|clas
parameter_list|)
name|value_ptr
name|clas
decl_stmt|;
block|{
name|value_ptr
name|vtable
init|=
name|value_struct_elt
argument_list|(
operator|&
name|clas
argument_list|,
name|NULL
argument_list|,
literal|"vtable"
argument_list|,
name|NULL
argument_list|,
literal|"struct"
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|i
init|=
name|value_as_pointer
argument_list|(
name|vtable
argument_list|)
decl_stmt|;
return|return
call|(
name|int
call|)
argument_list|(
name|i
operator|&
literal|0x7fffffff
argument_list|)
operator|==
operator|(
name|int
operator|)
literal|0x7fffffff
return|;
block|}
end_function

begin_comment
comment|/* Read a GCJ Class object, and generated a gdb (TYPE_CODE_STRUCT) type. */
end_comment

begin_function
name|struct
name|type
modifier|*
name|type_from_class
parameter_list|(
name|clas
parameter_list|)
name|value_ptr
name|clas
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|value_ptr
name|temp
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|value_ptr
name|utf8_name
decl_stmt|;
name|char
modifier|*
name|nptr
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|struct
name|block
modifier|*
name|bl
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|is_array
init|=
literal|0
decl_stmt|;
name|type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|clas
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
block|{
if|if
condition|(
name|value_logical_not
argument_list|(
name|clas
argument_list|)
condition|)
return|return
name|NULL
return|;
name|clas
operator|=
name|value_ind
argument_list|(
name|clas
argument_list|)
expr_stmt|;
block|}
name|addr
operator|=
name|VALUE_ADDRESS
argument_list|(
name|clas
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|clas
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|get_java_class_symtab ();   bl = BLOCKVECTOR_BLOCK (BLOCKVECTOR (class_symtab), GLOBAL_BLOCK);   for (i = BLOCK_NSYMS (bl);  --i>= 0; )     {       struct symbol *sym = BLOCK_SYM (bl, i);       if (SYMBOL_VALUE_ADDRESS (sym) == addr) 	return SYMBOL_TYPE (sym);     }
endif|#
directive|endif
name|objfile
operator|=
name|get_dynamics_objfile
argument_list|()
expr_stmt|;
if|if
condition|(
name|java_class_is_primitive
argument_list|(
name|clas
argument_list|)
condition|)
block|{
name|value_ptr
name|sig
decl_stmt|;
name|temp
operator|=
name|clas
expr_stmt|;
name|sig
operator|=
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
literal|"method_count"
argument_list|,
name|NULL
argument_list|,
literal|"structure"
argument_list|)
expr_stmt|;
return|return
name|java_primitive_type
argument_list|(
name|value_as_long
argument_list|(
name|sig
argument_list|)
argument_list|)
return|;
block|}
comment|/* Get Class name. */
comment|/* if clasloader non-null, prepend loader address. FIXME */
name|temp
operator|=
name|clas
expr_stmt|;
name|utf8_name
operator|=
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
literal|"name"
argument_list|,
name|NULL
argument_list|,
literal|"structure"
argument_list|)
expr_stmt|;
name|name
operator|=
name|get_java_utf8_name
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
name|utf8_name
argument_list|)
expr_stmt|;
for|for
control|(
name|nptr
operator|=
name|name
init|;
operator|*
name|nptr
operator|!=
literal|0
condition|;
name|nptr
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|nptr
operator|==
literal|'/'
condition|)
operator|*
name|nptr
operator|=
literal|'.'
expr_stmt|;
block|}
name|type
operator|=
name|java_lookup_class
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|NULL
condition|)
return|return
name|type
return|;
name|type
operator|=
name|alloc_type
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_STRUCT
expr_stmt|;
name|INIT_CPLUS_SPECIFIC
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'['
condition|)
block|{
name|char
modifier|*
name|signature
init|=
name|name
decl_stmt|;
name|int
name|namelen
init|=
name|java_demangled_signature_length
argument_list|(
name|signature
argument_list|)
decl_stmt|;
if|if
condition|(
name|namelen
operator|>
name|strlen
argument_list|(
name|name
argument_list|)
condition|)
name|name
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
name|namelen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|java_demangled_signature_copy
argument_list|(
name|name
argument_list|,
name|signature
argument_list|)
expr_stmt|;
name|name
index|[
name|namelen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|is_array
operator|=
literal|1
expr_stmt|;
name|temp
operator|=
name|clas
expr_stmt|;
comment|/* Set array element type. */
name|temp
operator|=
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
literal|"methods"
argument_list|,
name|NULL
argument_list|,
literal|"structure"
argument_list|)
expr_stmt|;
name|VALUE_TYPE
argument_list|(
name|temp
argument_list|)
operator|=
name|lookup_pointer_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|clas
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|type_from_class
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|ALLOCATE_CPLUS_STRUCT_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|name
expr_stmt|;
name|add_class_symtab_symbol
argument_list|(
name|add_class_symbol
argument_list|(
name|type
argument_list|,
name|addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|java_link_class_type
argument_list|(
name|type
argument_list|,
name|clas
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fill in class TYPE with data from the CLAS value. */
end_comment

begin_function
name|struct
name|type
modifier|*
name|java_link_class_type
parameter_list|(
name|type
parameter_list|,
name|clas
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|value_ptr
name|clas
decl_stmt|;
block|{
name|value_ptr
name|temp
decl_stmt|;
name|char
modifier|*
name|unqualified_name
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|ninterfaces
decl_stmt|,
name|nfields
decl_stmt|,
name|nmethods
decl_stmt|;
name|int
name|type_is_object
init|=
literal|0
decl_stmt|;
name|struct
name|fn_field
modifier|*
name|fn_fields
decl_stmt|;
name|struct
name|fn_fieldlist
modifier|*
name|fn_fieldlists
decl_stmt|;
name|value_ptr
name|fields
decl_stmt|,
name|field
decl_stmt|,
name|method
decl_stmt|,
name|methods
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|get_dynamics_objfile
argument_list|()
decl_stmt|;
name|struct
name|type
modifier|*
name|tsuper
decl_stmt|;
name|unqualified_name
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|unqualified_name
operator|==
name|NULL
condition|)
name|unqualified_name
operator|=
name|name
expr_stmt|;
name|temp
operator|=
name|clas
expr_stmt|;
name|temp
operator|=
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
literal|"superclass"
argument_list|,
name|NULL
argument_list|,
literal|"structure"
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"java.lang.Object"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tsuper
operator|=
name|get_java_object_type
argument_list|()
expr_stmt|;
if|if
condition|(
name|tsuper
operator|&&
name|TYPE_CODE
argument_list|(
name|tsuper
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
name|tsuper
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|tsuper
argument_list|)
expr_stmt|;
name|type_is_object
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|tsuper
operator|=
name|type_from_class
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
name|ninterfaces
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|temp
operator|=
name|clas
expr_stmt|;
name|ninterfaces
operator|=
name|value_as_long
argument_list|(
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
literal|"interface_len"
argument_list|,
name|NULL
argument_list|,
literal|"structure"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|tsuper
operator|==
name|NULL
condition|?
literal|0
else|:
literal|1
operator|)
operator|+
name|ninterfaces
expr_stmt|;
name|temp
operator|=
name|clas
expr_stmt|;
name|nfields
operator|=
name|value_as_long
argument_list|(
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
literal|"field_count"
argument_list|,
name|NULL
argument_list|,
literal|"structure"
argument_list|)
argument_list|)
expr_stmt|;
name|nfields
operator|+=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|nfields
operator|++
expr_stmt|;
comment|/* Add one for dummy "class" field. */
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|nfields
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|nfields
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|nfields
argument_list|)
expr_stmt|;
name|TYPE_FIELD_PRIVATE_BITS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|B_TYPE
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
name|B_BYTES
argument_list|(
name|nfields
argument_list|)
argument_list|)
expr_stmt|;
name|B_CLRALL
argument_list|(
name|TYPE_FIELD_PRIVATE_BITS
argument_list|(
name|type
argument_list|)
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
name|TYPE_FIELD_PROTECTED_BITS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|B_TYPE
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
name|B_BYTES
argument_list|(
name|nfields
argument_list|)
argument_list|)
expr_stmt|;
name|B_CLRALL
argument_list|(
name|TYPE_FIELD_PROTECTED_BITS
argument_list|(
name|type
argument_list|)
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
name|TYPE_FIELD_IGNORE_BITS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|B_TYPE
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
name|B_BYTES
argument_list|(
name|nfields
argument_list|)
argument_list|)
expr_stmt|;
name|B_CLRALL
argument_list|(
name|TYPE_FIELD_IGNORE_BITS
argument_list|(
name|type
argument_list|)
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
name|TYPE_FIELD_VIRTUAL_BITS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|B_TYPE
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
name|B_BYTES
argument_list|(
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|B_CLRALL
argument_list|(
name|TYPE_FIELD_VIRTUAL_BITS
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsuper
operator|!=
name|NULL
condition|)
block|{
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
operator|=
name|tsuper
expr_stmt|;
if|if
condition|(
name|type_is_object
condition|)
name|SET_TYPE_FIELD_PRIVATE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|2
operator|&&
name|name
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|']'
operator|&&
name|tsuper
operator|!=
name|NULL
condition|)
block|{
comment|/* FIXME */
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_LENGTH
argument_list|(
name|tsuper
argument_list|)
operator|+
literal|4
expr_stmt|;
comment|/* size with "length" */
block|}
else|else
block|{
name|temp
operator|=
name|clas
expr_stmt|;
name|temp
operator|=
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
literal|"size_in_bytes"
argument_list|,
name|NULL
argument_list|,
literal|"structure"
argument_list|)
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|value_as_long
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
name|fields
operator|=
name|NULL
expr_stmt|;
name|nfields
operator|--
expr_stmt|;
comment|/* First set up dummy "class" field. */
name|SET_FIELD_PHYSADDR
argument_list|(
name|TYPE_FIELD
argument_list|(
name|type
argument_list|,
name|nfields
argument_list|)
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|clas
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|clas
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|nfields
argument_list|)
operator|=
literal|"class"
expr_stmt|;
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|nfields
argument_list|)
operator|=
name|VALUE_TYPE
argument_list|(
name|clas
argument_list|)
expr_stmt|;
name|SET_TYPE_FIELD_PRIVATE
argument_list|(
name|type
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
init|;
name|i
operator|<
name|nfields
condition|;
name|i
operator|++
control|)
block|{
name|int
name|accflags
decl_stmt|;
name|int
name|boffset
decl_stmt|;
if|if
condition|(
name|fields
operator|==
name|NULL
condition|)
block|{
name|temp
operator|=
name|clas
expr_stmt|;
name|fields
operator|=
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
literal|"fields"
argument_list|,
name|NULL
argument_list|,
literal|"structure"
argument_list|)
expr_stmt|;
name|field
operator|=
name|value_ind
argument_list|(
name|fields
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Re-use field value for next field. */
name|VALUE_ADDRESS
argument_list|(
name|field
argument_list|)
operator|+=
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_LAZY
argument_list|(
name|field
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
name|temp
operator|=
name|field
expr_stmt|;
name|temp
operator|=
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
literal|"name"
argument_list|,
name|NULL
argument_list|,
literal|"structure"
argument_list|)
expr_stmt|;
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|=
name|get_java_utf8_name
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|temp
operator|=
name|field
expr_stmt|;
name|accflags
operator|=
name|value_as_long
argument_list|(
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
literal|"accflags"
argument_list|,
name|NULL
argument_list|,
literal|"structure"
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|=
name|field
expr_stmt|;
name|temp
operator|=
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
literal|"info"
argument_list|,
name|NULL
argument_list|,
literal|"structure"
argument_list|)
expr_stmt|;
name|boffset
operator|=
name|value_as_long
argument_list|(
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
literal|"boffset"
argument_list|,
name|NULL
argument_list|,
literal|"structure"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|accflags
operator|&
literal|0x0001
condition|)
comment|/* public access */
block|{
comment|/* ??? */
block|}
if|if
condition|(
name|accflags
operator|&
literal|0x0002
condition|)
comment|/* private access */
block|{
name|SET_TYPE_FIELD_PRIVATE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|accflags
operator|&
literal|0x0004
condition|)
comment|/* protected access */
block|{
name|SET_TYPE_FIELD_PROTECTED
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|accflags
operator|&
literal|0x0008
condition|)
comment|/* ACC_STATIC */
name|SET_FIELD_PHYSADDR
argument_list|(
name|TYPE_FIELD
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|boffset
argument_list|)
expr_stmt|;
else|else
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|=
literal|8
operator|*
name|boffset
expr_stmt|;
if|if
condition|(
name|accflags
operator|&
literal|0x8000
condition|)
comment|/* FIELD_UNRESOLVED_FLAG */
block|{
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|=
name|get_java_object_type
argument_list|()
expr_stmt|;
comment|/* FIXME */
block|}
else|else
block|{
name|struct
name|type
modifier|*
name|ftype
decl_stmt|;
name|temp
operator|=
name|field
expr_stmt|;
name|temp
operator|=
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
literal|"type"
argument_list|,
name|NULL
argument_list|,
literal|"structure"
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|type_from_class
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|ftype
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
condition|)
name|ftype
operator|=
name|lookup_pointer_type
argument_list|(
name|ftype
argument_list|)
expr_stmt|;
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|=
name|ftype
expr_stmt|;
block|}
block|}
name|temp
operator|=
name|clas
expr_stmt|;
name|nmethods
operator|=
name|value_as_long
argument_list|(
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
literal|"method_count"
argument_list|,
name|NULL
argument_list|,
literal|"structure"
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_NFN_FIELDS_TOTAL
argument_list|(
name|type
argument_list|)
operator|=
name|nmethods
expr_stmt|;
name|j
operator|=
name|nmethods
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fn_field
argument_list|)
expr_stmt|;
name|fn_fields
operator|=
operator|(
expr|struct
name|fn_field
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|dynamics_objfile
operator|->
name|symbol_obstack
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|fn_fields
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|fn_fieldlists
operator|=
operator|(
expr|struct
name|fn_fieldlist
operator|*
operator|)
name|alloca
argument_list|(
name|nmethods
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fn_fieldlist
argument_list|)
argument_list|)
expr_stmt|;
name|methods
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmethods
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|mname
decl_stmt|;
name|int
name|k
decl_stmt|;
if|if
condition|(
name|methods
operator|==
name|NULL
condition|)
block|{
name|temp
operator|=
name|clas
expr_stmt|;
name|methods
operator|=
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
literal|"methods"
argument_list|,
name|NULL
argument_list|,
literal|"structure"
argument_list|)
expr_stmt|;
name|method
operator|=
name|value_ind
argument_list|(
name|methods
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Re-use method value for next method. */
name|VALUE_ADDRESS
argument_list|(
name|method
argument_list|)
operator|+=
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|method
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_LAZY
argument_list|(
name|method
argument_list|)
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Get method name. */
name|temp
operator|=
name|method
expr_stmt|;
name|temp
operator|=
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
literal|"name"
argument_list|,
name|NULL
argument_list|,
literal|"structure"
argument_list|)
expr_stmt|;
name|mname
operator|=
name|get_java_utf8_name
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|mname
argument_list|,
literal|"<init>"
argument_list|)
operator|==
literal|0
condition|)
name|mname
operator|=
name|unqualified_name
expr_stmt|;
comment|/* Check for an existing method with the same name.        * This makes building the fn_fieldslists an O(nmethods**2)        * operation.  That could be using hashing, but I doubt it        * is worth it.  Note that we do maintain the order of methods        * in the inferior's Method table (as long as that is grouped        * by method name), which I think is desirable.  --PB */
for|for
control|(
name|k
operator|=
literal|0
operator|,
name|j
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|--
name|j
operator|<
literal|0
condition|)
block|{
comment|/* No match - new method name. */
name|j
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
operator|++
expr_stmt|;
name|fn_fieldlists
index|[
name|j
index|]
operator|.
name|name
operator|=
name|mname
expr_stmt|;
name|fn_fieldlists
index|[
name|j
index|]
operator|.
name|length
operator|=
literal|1
expr_stmt|;
name|fn_fieldlists
index|[
name|j
index|]
operator|.
name|fn_fields
operator|=
operator|&
name|fn_fields
index|[
name|i
index|]
expr_stmt|;
name|k
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|mname
argument_list|,
name|fn_fieldlists
index|[
name|j
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Found an existing method with the same name. */
name|int
name|l
decl_stmt|;
if|if
condition|(
name|mname
operator|!=
name|unqualified_name
condition|)
name|obstack_free
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
name|mname
argument_list|)
expr_stmt|;
name|mname
operator|=
name|fn_fieldlists
index|[
name|j
index|]
operator|.
name|name
expr_stmt|;
name|fn_fieldlists
index|[
name|j
index|]
operator|.
name|length
operator|++
expr_stmt|;
name|k
operator|=
name|i
operator|-
name|k
expr_stmt|;
comment|/* Index of new slot. */
comment|/* Shift intervening fn_fields (between k and i) down. */
for|for
control|(
name|l
operator|=
name|i
init|;
name|l
operator|>
name|k
condition|;
name|l
operator|--
control|)
name|fn_fields
index|[
name|l
index|]
operator|=
name|fn_fields
index|[
name|l
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|l
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
init|;
operator|--
name|l
operator|>
name|j
condition|;
control|)
name|fn_fieldlists
index|[
name|l
index|]
operator|.
name|fn_fields
operator|++
expr_stmt|;
break|break;
block|}
name|k
operator|+=
name|fn_fieldlists
index|[
name|j
index|]
operator|.
name|length
expr_stmt|;
block|}
name|fn_fields
index|[
name|k
index|]
operator|.
name|physname
operator|=
literal|""
expr_stmt|;
name|fn_fields
index|[
name|k
index|]
operator|.
name|is_stub
operator|=
literal|1
expr_stmt|;
name|fn_fields
index|[
name|k
index|]
operator|.
name|type
operator|=
name|make_function_type
argument_list|(
name|java_void_type
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* FIXME*/
name|TYPE_CODE
argument_list|(
name|fn_fields
index|[
name|k
index|]
operator|.
name|type
argument_list|)
operator|=
name|TYPE_CODE_METHOD
expr_stmt|;
block|}
name|j
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fn_fieldlist
argument_list|)
expr_stmt|;
name|TYPE_FN_FIELDLISTS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|fn_fieldlist
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|dynamics_objfile
operator|->
name|symbol_obstack
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|TYPE_FN_FIELDLISTS
argument_list|(
name|type
argument_list|)
argument_list|,
name|fn_fieldlists
argument_list|,
name|j
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|java_object_type
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|type
modifier|*
name|get_java_object_type
parameter_list|()
block|{
if|if
condition|(
name|java_object_type
operator|==
name|NULL
condition|)
block|{
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|lookup_symbol
argument_list|(
literal|"java.lang.Object"
argument_list|,
name|NULL
argument_list|,
name|STRUCT_NAMESPACE
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"cannot find java.lang.Object"
argument_list|)
expr_stmt|;
name|java_object_type
operator|=
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
block|}
return|return
name|java_object_type
return|;
block|}
end_function

begin_function
name|int
name|get_java_object_header_size
parameter_list|()
block|{
name|struct
name|type
modifier|*
name|objtype
init|=
name|get_java_object_type
argument_list|()
decl_stmt|;
if|if
condition|(
name|objtype
operator|==
name|NULL
condition|)
return|return
operator|(
literal|2
operator|*
name|TARGET_PTR_BIT
operator|/
name|TARGET_CHAR_BIT
operator|)
return|;
else|else
return|return
name|TYPE_LENGTH
argument_list|(
name|objtype
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|is_object_type
parameter_list|(
name|type
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
block|{
name|struct
name|type
modifier|*
name|ttype
init|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|ttype
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|TYPE_N_BASECLASSES
argument_list|(
name|ttype
argument_list|)
operator|>
literal|0
condition|)
name|ttype
operator|=
name|TYPE_BASECLASS
argument_list|(
name|ttype
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|name
operator|=
name|TYPE_TAG_NAME
argument_list|(
name|ttype
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"java.lang.Object"
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|name
operator|=
name|TYPE_NFIELDS
argument_list|(
name|ttype
argument_list|)
operator|>
literal|0
condition|?
name|TYPE_FIELD_NAME
argument_list|(
name|ttype
argument_list|,
literal|0
argument_list|)
else|:
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"vtable"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|java_object_type
operator|==
name|NULL
condition|)
name|java_object_type
operator|=
name|type
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|struct
name|type
modifier|*
name|java_primitive_type
parameter_list|(
name|signature
parameter_list|)
name|int
name|signature
decl_stmt|;
block|{
switch|switch
condition|(
name|signature
condition|)
block|{
case|case
literal|'B'
case|:
return|return
name|java_byte_type
return|;
case|case
literal|'S'
case|:
return|return
name|java_short_type
return|;
case|case
literal|'I'
case|:
return|return
name|java_int_type
return|;
case|case
literal|'J'
case|:
return|return
name|java_long_type
return|;
case|case
literal|'Z'
case|:
return|return
name|java_boolean_type
return|;
case|case
literal|'C'
case|:
return|return
name|java_char_type
return|;
case|case
literal|'F'
case|:
return|return
name|java_float_type
return|;
case|case
literal|'D'
case|:
return|return
name|java_double_type
return|;
case|case
literal|'V'
case|:
return|return
name|java_void_type
return|;
block|}
name|error
argument_list|(
literal|"unknown signature '%c' for primitive type"
argument_list|,
operator|(
name|char
operator|)
name|signature
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If name[0 .. namelen-1] is the name of a primitive Java type,    return that type.  Otherwise, return NULL. */
end_comment

begin_function
name|struct
name|type
modifier|*
name|java_primitive_type_from_name
parameter_list|(
name|name
parameter_list|,
name|namelen
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|namelen
decl_stmt|;
block|{
switch|switch
condition|(
name|name
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'b'
case|:
if|if
condition|(
name|namelen
operator|==
literal|4
operator|&&
name|memcmp
argument_list|(
name|name
argument_list|,
literal|"byte"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
name|java_byte_type
return|;
if|if
condition|(
name|namelen
operator|==
literal|7
operator|&&
name|memcmp
argument_list|(
name|name
argument_list|,
literal|"boolean"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
return|return
name|java_boolean_type
return|;
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
name|namelen
operator|==
literal|4
operator|&&
name|memcmp
argument_list|(
name|name
argument_list|,
literal|"char"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
name|java_char_type
return|;
case|case
literal|'d'
case|:
if|if
condition|(
name|namelen
operator|==
literal|6
operator|&&
name|memcmp
argument_list|(
name|name
argument_list|,
literal|"double"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
return|return
name|java_double_type
return|;
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
name|namelen
operator|==
literal|5
operator|&&
name|memcmp
argument_list|(
name|name
argument_list|,
literal|"float"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
return|return
name|java_float_type
return|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|namelen
operator|==
literal|3
operator|&&
name|memcmp
argument_list|(
name|name
argument_list|,
literal|"int"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
return|return
name|java_int_type
return|;
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|namelen
operator|==
literal|4
operator|&&
name|memcmp
argument_list|(
name|name
argument_list|,
literal|"long"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
name|java_long_type
return|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|namelen
operator|==
literal|5
operator|&&
name|memcmp
argument_list|(
name|name
argument_list|,
literal|"short"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
return|return
name|java_short_type
return|;
break|break;
case|case
literal|'v'
case|:
if|if
condition|(
name|namelen
operator|==
literal|4
operator|&&
name|memcmp
argument_list|(
name|name
argument_list|,
literal|"void"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
return|return
name|java_void_type
return|;
break|break;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return the length (in bytes) of demangled name of the Java type    signature string SIGNATURE. */
end_comment

begin_function
specifier|static
name|int
name|java_demangled_signature_length
parameter_list|(
name|signature
parameter_list|)
name|char
modifier|*
name|signature
decl_stmt|;
block|{
name|int
name|array
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
operator|*
name|signature
operator|==
literal|'['
condition|;
name|signature
operator|++
control|)
name|array
operator|+=
literal|2
expr_stmt|;
comment|/* Two chars for "[]". */
switch|switch
condition|(
name|signature
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'L'
case|:
comment|/* Subtract 2 for 'L' and ';'. */
return|return
name|strlen
argument_list|(
name|signature
argument_list|)
operator|-
literal|2
operator|+
name|array
return|;
default|default:
return|return
name|strlen
argument_list|(
name|TYPE_NAME
argument_list|(
name|java_primitive_type
argument_list|(
name|signature
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
operator|+
name|array
return|;
block|}
block|}
end_function

begin_comment
comment|/* Demangle the Java type signature SIGNATURE, leaving the result in RESULT. */
end_comment

begin_function
specifier|static
name|void
name|java_demangled_signature_copy
parameter_list|(
name|result
parameter_list|,
name|signature
parameter_list|)
name|char
modifier|*
name|result
decl_stmt|;
name|char
modifier|*
name|signature
decl_stmt|;
block|{
name|int
name|array
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|i
decl_stmt|;
while|while
condition|(
operator|*
name|signature
operator|==
literal|'['
condition|)
block|{
name|array
operator|++
expr_stmt|;
name|signature
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
name|signature
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'L'
case|:
comment|/* Subtract 2 for 'L' and ';', but add 1 for final nul. */
name|signature
operator|++
expr_stmt|;
name|ptr
operator|=
name|result
expr_stmt|;
for|for
control|(
init|;
operator|*
name|signature
operator|!=
literal|';'
operator|&&
operator|*
name|signature
operator|!=
literal|'\0'
condition|;
name|signature
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|signature
operator|==
literal|'/'
condition|)
operator|*
name|ptr
operator|++
operator|=
literal|'.'
expr_stmt|;
else|else
operator|*
name|ptr
operator|++
operator|=
operator|*
name|signature
expr_stmt|;
block|}
break|break;
default|default:
name|ptr
operator|=
name|TYPE_NAME
argument_list|(
name|java_primitive_type
argument_list|(
name|signature
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|result
operator|+
name|i
expr_stmt|;
break|break;
block|}
while|while
condition|(
operator|--
name|array
operator|>=
literal|0
condition|)
block|{
operator|*
name|ptr
operator|++
operator|=
literal|'['
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|']'
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the demangled name of the Java type signature string SIGNATURE,    as a freshly allocated copy. */
end_comment

begin_function
name|char
modifier|*
name|java_demangle_type_signature
parameter_list|(
name|signature
parameter_list|)
name|char
modifier|*
name|signature
decl_stmt|;
block|{
name|int
name|length
init|=
name|java_demangled_signature_length
argument_list|(
name|signature
argument_list|)
decl_stmt|;
name|char
modifier|*
name|result
init|=
name|xmalloc
argument_list|(
name|length
operator|+
literal|1
argument_list|)
decl_stmt|;
name|java_demangled_signature_copy
argument_list|(
name|result
argument_list|,
name|signature
argument_list|)
expr_stmt|;
name|result
index|[
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|struct
name|type
modifier|*
name|java_lookup_type
parameter_list|(
name|signature
parameter_list|)
name|char
modifier|*
name|signature
decl_stmt|;
block|{
switch|switch
condition|(
name|signature
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'L'
case|:
case|case
literal|'['
case|:
name|error
argument_list|(
literal|"java_lookup_type not fully implemented"
argument_list|)
expr_stmt|;
default|default:
return|return
name|java_primitive_type
argument_list|(
name|signature
index|[
literal|0
index|]
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return the type of TYPE followed by DIMS pairs of [ ].    If DIMS == 0, TYPE is returned. */
end_comment

begin_function
name|struct
name|type
modifier|*
name|java_array_type
parameter_list|(
name|type
parameter_list|,
name|dims
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|dims
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|range_type
decl_stmt|;
while|while
condition|(
name|dims
operator|--
operator|>
literal|0
condition|)
block|{
name|range_type
operator|=
name|create_range_type
argument_list|(
name|NULL
argument_list|,
name|builtin_type_int
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FIXME  This is bogus!  Java arrays are not gdb arrays! */
name|type
operator|=
name|create_array_type
argument_list|(
name|NULL
argument_list|,
name|type
argument_list|,
name|range_type
argument_list|)
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Create a Java string in the inferior from a (Utf8) literal. */
end_comment

begin_function
name|value_ptr
name|java_value_string
parameter_list|(
name|ptr
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|error
argument_list|(
literal|"not implemented - java_value_string"
argument_list|)
expr_stmt|;
comment|/* FIXME */
block|}
end_function

begin_comment
comment|/* Print the character C on STREAM as part of the contents of a literal    string whose delimiter is QUOTER.  Note that that format for printing    characters and strings is language specific. */
end_comment

begin_function
specifier|static
name|void
name|java_emit_char
parameter_list|(
name|c
parameter_list|,
name|stream
parameter_list|,
name|quoter
parameter_list|)
name|int
name|c
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|quoter
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
case|case
literal|'\''
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\\%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|fputs_filtered
argument_list|(
literal|"\\b"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|fputs_filtered
argument_list|(
literal|"\\t"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|fputs_filtered
argument_list|(
literal|"\\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
name|fputs_filtered
argument_list|(
literal|"\\f"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|fputs_filtered
argument_list|(
literal|"\\r"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
name|fputc_filtered
argument_list|(
name|c
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\\u%.4x"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|value_ptr
name|evaluate_subexp_java
parameter_list|(
name|expect_type
parameter_list|,
name|exp
parameter_list|,
name|pos
parameter_list|,
name|noside
parameter_list|)
name|struct
name|type
modifier|*
name|expect_type
decl_stmt|;
specifier|register
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
specifier|register
name|int
modifier|*
name|pos
decl_stmt|;
name|enum
name|noside
name|noside
decl_stmt|;
block|{
name|int
name|pc
init|=
operator|*
name|pos
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|enum
name|exp_opcode
name|op
init|=
name|exp
operator|->
name|elts
index|[
operator|*
name|pos
index|]
operator|.
name|opcode
decl_stmt|;
name|value_ptr
name|arg1
decl_stmt|,
name|arg2
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|UNOP_IND
case|:
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|standard
goto|;
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
name|arg1
operator|=
name|evaluate_subexp_java
argument_list|(
name|NULL_TYPE
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|EVAL_NORMAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_object_type
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
condition|)
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|type
operator|=
name|type_from_class
argument_list|(
name|java_class_from_object
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|value_cast
argument_list|(
name|lookup_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|arg1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
return|return
name|value_ind
argument_list|(
name|arg1
argument_list|)
return|;
case|case
name|BINOP_SUBSCRIPT
case|:
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
name|arg1
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|evaluate_subexp_with_coercion
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
comment|/* If the user attempts to subscript something that is not an 	 array or pointer type (like a plain int variable for example), 	 then report this as an error. */
name|COERCE_REF
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
name|type
operator|=
name|check_typedef
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
name|name
operator|=
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|i
operator|=
name|name
operator|==
name|NULL
condition|?
literal|0
else|:
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|&&
name|i
operator|>
literal|2
operator|&&
name|name
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|']'
condition|)
block|{
name|CORE_ADDR
name|address
decl_stmt|;
name|long
name|length
decl_stmt|,
name|index
decl_stmt|;
name|struct
name|type
modifier|*
name|el_type
decl_stmt|;
name|char
name|buf4
index|[
literal|4
index|]
decl_stmt|;
name|value_ptr
name|clas
init|=
name|java_class_from_object
argument_list|(
name|arg1
argument_list|)
decl_stmt|;
name|value_ptr
name|temp
init|=
name|clas
decl_stmt|;
comment|/* Get CLASS_ELEMENT_TYPE of the array type. */
name|temp
operator|=
name|value_struct_elt
argument_list|(
operator|&
name|temp
argument_list|,
name|NULL
argument_list|,
literal|"methods"
argument_list|,
name|NULL
argument_list|,
literal|"structure"
argument_list|)
expr_stmt|;
name|VALUE_TYPE
argument_list|(
name|temp
argument_list|)
operator|=
name|VALUE_TYPE
argument_list|(
name|clas
argument_list|)
expr_stmt|;
name|el_type
operator|=
name|type_from_class
argument_list|(
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|el_type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
condition|)
name|el_type
operator|=
name|lookup_pointer_type
argument_list|(
name|el_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
return|return
name|value_zero
argument_list|(
name|el_type
argument_list|,
name|VALUE_LVAL
argument_list|(
name|arg1
argument_list|)
argument_list|)
return|;
name|address
operator|=
name|value_as_pointer
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
name|address
operator|+=
name|JAVA_OBJECT_SIZE
expr_stmt|;
name|read_memory
argument_list|(
name|address
argument_list|,
name|buf4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|length
operator|=
operator|(
name|long
operator|)
name|extract_signed_integer
argument_list|(
name|buf4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|index
operator|=
operator|(
name|long
operator|)
name|value_as_long
argument_list|(
name|arg2
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|>=
name|length
operator|||
name|index
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"array index (%ld) out of bounds (length: %ld)"
argument_list|,
name|index
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|address
operator|=
operator|(
name|address
operator|+
literal|4
operator|)
operator|+
name|index
operator|*
name|TYPE_LENGTH
argument_list|(
name|el_type
argument_list|)
expr_stmt|;
return|return
name|value_at
argument_list|(
name|el_type
argument_list|,
name|address
argument_list|,
name|NULL
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
condition|)
block|{
if|if
condition|(
name|noside
operator|==
name|EVAL_AVOID_SIDE_EFFECTS
condition|)
return|return
name|value_zero
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|VALUE_LVAL
argument_list|(
name|arg1
argument_list|)
argument_list|)
return|;
else|else
return|return
name|value_subscript
argument_list|(
name|arg1
argument_list|,
name|arg2
argument_list|)
return|;
block|}
if|if
condition|(
name|name
condition|)
name|error
argument_list|(
literal|"cannot subscript something of type `%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"cannot subscript requested type"
argument_list|)
expr_stmt|;
case|case
name|OP_STRING
case|:
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
name|i
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|noside
operator|==
name|EVAL_SKIP
condition|)
goto|goto
name|nosideret
goto|;
return|return
name|java_value_string
argument_list|(
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
argument_list|,
name|i
argument_list|)
return|;
case|case
name|STRUCTOP_STRUCT
case|:
name|arg1
operator|=
name|evaluate_subexp_standard
argument_list|(
name|expect_type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
expr_stmt|;
comment|/* Convert object field (such as TYPE.class) to reference. */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
condition|)
name|arg1
operator|=
name|value_addr
argument_list|(
name|arg1
argument_list|)
expr_stmt|;
return|return
name|arg1
return|;
default|default:
break|break;
block|}
name|standard
label|:
return|return
name|evaluate_subexp_standard
argument_list|(
name|expect_type
argument_list|,
name|exp
argument_list|,
name|pos
argument_list|,
name|noside
argument_list|)
return|;
name|nosideret
label|:
return|return
name|value_from_longest
argument_list|(
name|builtin_type_long
argument_list|,
operator|(
name|LONGEST
operator|)
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|type
modifier|*
name|java_create_fundamental_type
parameter_list|(
name|objfile
parameter_list|,
name|typeid
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|int
name|typeid
decl_stmt|;
block|{
switch|switch
condition|(
name|typeid
condition|)
block|{
case|case
name|FT_VOID
case|:
return|return
name|java_void_type
return|;
case|case
name|FT_BOOLEAN
case|:
return|return
name|java_boolean_type
return|;
case|case
name|FT_CHAR
case|:
return|return
name|java_char_type
return|;
case|case
name|FT_FLOAT
case|:
return|return
name|java_float_type
return|;
case|case
name|FT_DBL_PREC_FLOAT
case|:
return|return
name|java_double_type
return|;
case|case
name|FT_BYTE
case|:
case|case
name|FT_SIGNED_CHAR
case|:
return|return
name|java_byte_type
return|;
case|case
name|FT_SHORT
case|:
case|case
name|FT_SIGNED_SHORT
case|:
return|return
name|java_short_type
return|;
case|case
name|FT_INTEGER
case|:
case|case
name|FT_SIGNED_INTEGER
case|:
return|return
name|java_int_type
return|;
case|case
name|FT_LONG
case|:
case|case
name|FT_SIGNED_LONG
case|:
return|return
name|java_long_type
return|;
block|}
return|return
name|c_create_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|typeid
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Table mapping opcodes into strings for printing operators    and precedences of the operators.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|op_print
name|java_op_print_tab
index|[]
init|=
block|{
block|{
literal|","
block|,
name|BINOP_COMMA
block|,
name|PREC_COMMA
block|,
literal|0
block|}
block|,
block|{
literal|"="
block|,
name|BINOP_ASSIGN
block|,
name|PREC_ASSIGN
block|,
literal|1
block|}
block|,
block|{
literal|"||"
block|,
name|BINOP_LOGICAL_OR
block|,
name|PREC_LOGICAL_OR
block|,
literal|0
block|}
block|,
block|{
literal|"&&"
block|,
name|BINOP_LOGICAL_AND
block|,
name|PREC_LOGICAL_AND
block|,
literal|0
block|}
block|,
block|{
literal|"|"
block|,
name|BINOP_BITWISE_IOR
block|,
name|PREC_BITWISE_IOR
block|,
literal|0
block|}
block|,
block|{
literal|"^"
block|,
name|BINOP_BITWISE_XOR
block|,
name|PREC_BITWISE_XOR
block|,
literal|0
block|}
block|,
block|{
literal|"&"
block|,
name|BINOP_BITWISE_AND
block|,
name|PREC_BITWISE_AND
block|,
literal|0
block|}
block|,
block|{
literal|"=="
block|,
name|BINOP_EQUAL
block|,
name|PREC_EQUAL
block|,
literal|0
block|}
block|,
block|{
literal|"!="
block|,
name|BINOP_NOTEQUAL
block|,
name|PREC_EQUAL
block|,
literal|0
block|}
block|,
block|{
literal|"<="
block|,
name|BINOP_LEQ
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|">="
block|,
name|BINOP_GEQ
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|">"
block|,
name|BINOP_GTR
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|"<"
block|,
name|BINOP_LESS
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|">>"
block|,
name|BINOP_RSH
block|,
name|PREC_SHIFT
block|,
literal|0
block|}
block|,
block|{
literal|"<<"
block|,
name|BINOP_LSH
block|,
name|PREC_SHIFT
block|,
literal|0
block|}
block|,
if|#
directive|if
literal|0
block|{">>>", BINOP_???, PREC_SHIFT, 0},
endif|#
directive|endif
block|{
literal|"+"
block|,
name|BINOP_ADD
block|,
name|PREC_ADD
block|,
literal|0
block|}
block|,
block|{
literal|"-"
block|,
name|BINOP_SUB
block|,
name|PREC_ADD
block|,
literal|0
block|}
block|,
block|{
literal|"*"
block|,
name|BINOP_MUL
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"/"
block|,
name|BINOP_DIV
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"%"
block|,
name|BINOP_REM
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"-"
block|,
name|UNOP_NEG
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"!"
block|,
name|UNOP_LOGICAL_NOT
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"~"
block|,
name|UNOP_COMPLEMENT
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"*"
block|,
name|UNOP_IND
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
if|#
directive|if
literal|0
block|{"instanceof", ???, ???, 0},
endif|#
directive|endif
block|{
literal|"++"
block|,
name|UNOP_PREINCREMENT
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"--"
block|,
name|UNOP_PREDECREMENT
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|language_defn
name|java_language_defn
init|=
block|{
literal|"java"
block|,
comment|/* Language name */
name|language_java
block|,
name|c_builtin_types
block|,
name|range_check_off
block|,
name|type_check_off
block|,
name|java_parse
block|,
name|java_error
block|,
name|evaluate_subexp_java
block|,
name|c_printchar
block|,
comment|/* Print a character constant */
name|c_printstr
block|,
comment|/* Function to print string constant */
name|java_emit_char
block|,
comment|/* Function to print a single character */
name|java_create_fundamental_type
block|,
comment|/* Create fundamental type in this language */
name|java_print_type
block|,
comment|/* Print a type using appropriate syntax */
name|java_val_print
block|,
comment|/* Print a value using appropriate syntax */
name|java_value_print
block|,
comment|/* Print a top-level value */
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
comment|/* Binary format info */
block|{
literal|"0%lo"
block|,
literal|"0"
block|,
literal|"o"
block|,
literal|""
block|}
block|,
comment|/* Octal format info */
block|{
literal|"%ld"
block|,
literal|""
block|,
literal|"d"
block|,
literal|""
block|}
block|,
comment|/* Decimal format info */
block|{
literal|"0x%lx"
block|,
literal|"0x"
block|,
literal|"x"
block|,
literal|""
block|}
block|,
comment|/* Hex format info */
name|java_op_print_tab
block|,
comment|/* expression operators for printing */
literal|0
block|,
comment|/* not c-style arrays */
literal|0
block|,
comment|/* String lower bound */
operator|&
name|builtin_type_char
block|,
comment|/* Type of string elements */
name|LANG_MAGIC
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_java_language
parameter_list|()
block|{
name|java_int_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|"int"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|java_short_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|"short"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|java_long_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
literal|"long"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|java_byte_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"byte"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|java_boolean_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_BOOL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"boolean"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|java_char_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_CHAR
argument_list|,
literal|2
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"char"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|java_float_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
literal|"float"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|java_double_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
literal|"double"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|java_void_type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_VOID
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"void"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|add_language
argument_list|(
operator|&
name|java_language_defn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Cleanup code that should be run on every "run".    We should use make_run_cleanup to have this be called.    But will that mess up values in value histry?  FIXME */
end_comment

begin_function
name|void
name|java_rerun_cleanup
parameter_list|()
block|{
if|if
condition|(
name|class_symtab
operator|!=
name|NULL
condition|)
block|{
name|free_symtab
argument_list|(
name|class_symtab
argument_list|)
expr_stmt|;
comment|/* ??? */
name|class_symtab
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|dynamics_objfile
operator|!=
name|NULL
condition|)
block|{
name|free_objfile
argument_list|(
name|dynamics_objfile
argument_list|)
expr_stmt|;
name|dynamics_objfile
operator|=
name|NULL
expr_stmt|;
block|}
name|java_object_type
operator|=
name|NULL
expr_stmt|;
block|}
end_function

end_unit

