begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target-dependent code for GNU/Linux running on i386's, for GDB.     Copyright 2000, 2001, 2002 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_comment
comment|/* For i386_linux_skip_solib_resolver.  */
end_comment

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"solib-svr4.h"
end_include

begin_comment
comment|/* For struct link_map_offsets.  */
end_comment

begin_comment
comment|/* Return the name of register REG.  */
end_comment

begin_function
name|char
modifier|*
name|i386_linux_register_name
parameter_list|(
name|int
name|reg
parameter_list|)
block|{
comment|/* Deal with the extra "orig_eax" pseudo register.  */
if|if
condition|(
name|reg
operator|==
name|I386_LINUX_ORIG_EAX_REGNUM
condition|)
return|return
literal|"orig_eax"
return|;
return|return
name|i386_register_name
argument_list|(
name|reg
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|i386_linux_register_byte
parameter_list|(
name|int
name|reg
parameter_list|)
block|{
comment|/* Deal with the extra "orig_eax" pseudo register.  */
if|if
condition|(
name|reg
operator|==
name|I386_LINUX_ORIG_EAX_REGNUM
condition|)
return|return
operator|(
name|i386_register_byte
argument_list|(
name|I386_LINUX_ORIG_EAX_REGNUM
operator|-
literal|1
argument_list|)
operator|+
name|i386_register_raw_size
argument_list|(
name|I386_LINUX_ORIG_EAX_REGNUM
operator|-
literal|1
argument_list|)
operator|)
return|;
return|return
name|i386_register_byte
argument_list|(
name|reg
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|i386_linux_register_raw_size
parameter_list|(
name|int
name|reg
parameter_list|)
block|{
comment|/* Deal with the extra "orig_eax" pseudo register.  */
if|if
condition|(
name|reg
operator|==
name|I386_LINUX_ORIG_EAX_REGNUM
condition|)
return|return
literal|4
return|;
return|return
name|i386_register_raw_size
argument_list|(
name|reg
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Recognizing signal handler frames.  */
end_comment

begin_comment
comment|/* GNU/Linux has two flavors of signals.  Normal signal handlers, and    "realtime" (RT) signals.  The RT signals can provide additional    information to the signal handler if the SA_SIGINFO flag is set    when establishing a signal handler using `sigaction'.  It is not    unlikely that future versions of GNU/Linux will support SA_SIGINFO    for normal signals too.  */
end_comment

begin_comment
comment|/* When the i386 Linux kernel calls a signal handler and the    SA_RESTORER flag isn't set, the return address points to a bit of    code on the stack.  This function returns whether the PC appears to    be within this bit of code.     The instruction sequence for normal signals is        pop    %eax        mov    $0x77,%eax        int    $0x80    or 0x58 0xb8 0x77 0x00 0x00 0x00 0xcd 0x80.     Checking for the code sequence should be somewhat reliable, because    the effect is to call the system call sigreturn.  This is unlikely    to occur anywhere other than a signal trampoline.     It kind of sucks that we have to read memory from the process in    order to identify a signal trampoline, but there doesn't seem to be    any other way.  The IN_SIGTRAMP macro in tm-linux.h arranges to    only call us if no function name could be identified, which should    be the case since the code is on the stack.     Detection of signal trampolines for handlers that set the    SA_RESTORER flag is in general not possible.  Unfortunately this is    what the GNU C Library has been doing for quite some time now.    However, as of version 2.1.2, the GNU C Library uses signal    trampolines (named __restore and __restore_rt) that are identical    to the ones used by the kernel.  Therefore, these trampolines are    supported too.  */
end_comment

begin_define
define|#
directive|define
name|LINUX_SIGTRAMP_INSN0
value|(0x58)
end_define

begin_comment
comment|/* pop %eax */
end_comment

begin_define
define|#
directive|define
name|LINUX_SIGTRAMP_OFFSET0
value|(0)
end_define

begin_define
define|#
directive|define
name|LINUX_SIGTRAMP_INSN1
value|(0xb8)
end_define

begin_comment
comment|/* mov $NNNN,%eax */
end_comment

begin_define
define|#
directive|define
name|LINUX_SIGTRAMP_OFFSET1
value|(1)
end_define

begin_define
define|#
directive|define
name|LINUX_SIGTRAMP_INSN2
value|(0xcd)
end_define

begin_comment
comment|/* int */
end_comment

begin_define
define|#
directive|define
name|LINUX_SIGTRAMP_OFFSET2
value|(6)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
name|linux_sigtramp_code
index|[]
init|=
block|{
name|LINUX_SIGTRAMP_INSN0
block|,
comment|/* pop %eax */
name|LINUX_SIGTRAMP_INSN1
block|,
literal|0x77
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* mov $0x77,%eax */
name|LINUX_SIGTRAMP_INSN2
block|,
literal|0x80
comment|/* int $0x80 */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LINUX_SIGTRAMP_LEN
value|(sizeof linux_sigtramp_code)
end_define

begin_comment
comment|/* If PC is in a sigtramp routine, return the address of the start of    the routine.  Otherwise, return 0.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|i386_linux_sigtramp_start
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|unsigned
name|char
name|buf
index|[
name|LINUX_SIGTRAMP_LEN
index|]
decl_stmt|;
comment|/* We only recognize a signal trampoline if PC is at the start of      one of the three instructions.  We optimize for finding the PC at      the start, as will be the case when the trampoline is not the      first frame on the stack.  We assume that in the case where the      PC is not at the start of the instruction sequence, there will be      a few trailing readable bytes on the stack.  */
if|if
condition|(
name|read_memory_nobpt
argument_list|(
name|pc
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|LINUX_SIGTRAMP_LEN
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
name|LINUX_SIGTRAMP_INSN0
condition|)
block|{
name|int
name|adjust
decl_stmt|;
switch|switch
condition|(
name|buf
index|[
literal|0
index|]
condition|)
block|{
case|case
name|LINUX_SIGTRAMP_INSN1
case|:
name|adjust
operator|=
name|LINUX_SIGTRAMP_OFFSET1
expr_stmt|;
break|break;
case|case
name|LINUX_SIGTRAMP_INSN2
case|:
name|adjust
operator|=
name|LINUX_SIGTRAMP_OFFSET2
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
name|pc
operator|-=
name|adjust
expr_stmt|;
if|if
condition|(
name|read_memory_nobpt
argument_list|(
name|pc
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|LINUX_SIGTRAMP_LEN
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|memcmp
argument_list|(
name|buf
argument_list|,
name|linux_sigtramp_code
argument_list|,
name|LINUX_SIGTRAMP_LEN
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|pc
return|;
block|}
end_function

begin_comment
comment|/* This function does the same for RT signals.  Here the instruction    sequence is        mov    $0xad,%eax        int    $0x80    or 0xb8 0xad 0x00 0x00 0x00 0xcd 0x80.     The effect is to call the system call rt_sigreturn.  */
end_comment

begin_define
define|#
directive|define
name|LINUX_RT_SIGTRAMP_INSN0
value|(0xb8)
end_define

begin_comment
comment|/* mov $NNNN,%eax */
end_comment

begin_define
define|#
directive|define
name|LINUX_RT_SIGTRAMP_OFFSET0
value|(0)
end_define

begin_define
define|#
directive|define
name|LINUX_RT_SIGTRAMP_INSN1
value|(0xcd)
end_define

begin_comment
comment|/* int */
end_comment

begin_define
define|#
directive|define
name|LINUX_RT_SIGTRAMP_OFFSET1
value|(5)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
name|linux_rt_sigtramp_code
index|[]
init|=
block|{
name|LINUX_RT_SIGTRAMP_INSN0
block|,
literal|0xad
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
comment|/* mov $0xad,%eax */
name|LINUX_RT_SIGTRAMP_INSN1
block|,
literal|0x80
comment|/* int $0x80 */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LINUX_RT_SIGTRAMP_LEN
value|(sizeof linux_rt_sigtramp_code)
end_define

begin_comment
comment|/* If PC is in a RT sigtramp routine, return the address of the start    of the routine.  Otherwise, return 0.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|i386_linux_rt_sigtramp_start
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|unsigned
name|char
name|buf
index|[
name|LINUX_RT_SIGTRAMP_LEN
index|]
decl_stmt|;
comment|/* We only recognize a signal trampoline if PC is at the start of      one of the two instructions.  We optimize for finding the PC at      the start, as will be the case when the trampoline is not the      first frame on the stack.  We assume that in the case where the      PC is not at the start of the instruction sequence, there will be      a few trailing readable bytes on the stack.  */
if|if
condition|(
name|read_memory_nobpt
argument_list|(
name|pc
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|LINUX_RT_SIGTRAMP_LEN
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
name|LINUX_RT_SIGTRAMP_INSN0
condition|)
block|{
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
name|LINUX_RT_SIGTRAMP_INSN1
condition|)
return|return
literal|0
return|;
name|pc
operator|-=
name|LINUX_RT_SIGTRAMP_OFFSET1
expr_stmt|;
if|if
condition|(
name|read_memory_nobpt
argument_list|(
name|pc
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|LINUX_RT_SIGTRAMP_LEN
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|memcmp
argument_list|(
name|buf
argument_list|,
name|linux_rt_sigtramp_code
argument_list|,
name|LINUX_RT_SIGTRAMP_LEN
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|pc
return|;
block|}
end_function

begin_comment
comment|/* Return whether PC is in a GNU/Linux sigtramp routine.  */
end_comment

begin_function
name|int
name|i386_linux_in_sigtramp
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|name
condition|)
return|return
name|STREQ
argument_list|(
literal|"__restore"
argument_list|,
name|name
argument_list|)
operator|||
name|STREQ
argument_list|(
literal|"__restore_rt"
argument_list|,
name|name
argument_list|)
return|;
return|return
operator|(
name|i386_linux_sigtramp_start
argument_list|(
name|pc
argument_list|)
operator|!=
literal|0
operator|||
name|i386_linux_rt_sigtramp_start
argument_list|(
name|pc
argument_list|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Assuming FRAME is for a GNU/Linux sigtramp routine, return the    address of the associated sigcontext structure.  */
end_comment

begin_function
name|CORE_ADDR
name|i386_linux_sigcontext_addr
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
name|CORE_ADDR
name|pc
decl_stmt|;
name|pc
operator|=
name|i386_linux_sigtramp_start
argument_list|(
name|frame
operator|->
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|pc
condition|)
block|{
name|CORE_ADDR
name|sp
decl_stmt|;
if|if
condition|(
name|frame
operator|->
name|next
condition|)
comment|/* If this isn't the top frame, the next frame must be for the 	   signal handler itself.  The sigcontext structure lives on 	   the stack, right after the signum argument.  */
return|return
name|frame
operator|->
name|next
operator|->
name|frame
operator|+
literal|12
return|;
comment|/* This is the top frame.  We'll have to find the address of the 	 sigcontext structure by looking at the stack pointer.  Keep 	 in mind that the first instruction of the sigtramp code is 	 "pop %eax".  If the PC is at this instruction, adjust the 	 returned value accordingly.  */
name|sp
operator|=
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|pc
operator|==
name|frame
operator|->
name|pc
condition|)
return|return
name|sp
operator|+
literal|4
return|;
return|return
name|sp
return|;
block|}
name|pc
operator|=
name|i386_linux_rt_sigtramp_start
argument_list|(
name|frame
operator|->
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|pc
condition|)
block|{
if|if
condition|(
name|frame
operator|->
name|next
condition|)
comment|/* If this isn't the top frame, the next frame must be for the 	   signal handler itself.  The sigcontext structure is part of 	   the user context.  A pointer to the user context is passed 	   as the third argument to the signal handler.  */
return|return
name|read_memory_integer
argument_list|(
name|frame
operator|->
name|next
operator|->
name|frame
operator|+
literal|16
argument_list|,
literal|4
argument_list|)
operator|+
literal|20
return|;
comment|/* This is the top frame.  Again, use the stack pointer to find 	 the address of the sigcontext structure.  */
return|return
name|read_memory_integer
argument_list|(
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
operator|+
literal|8
argument_list|,
literal|4
argument_list|)
operator|+
literal|20
return|;
block|}
name|error
argument_list|(
literal|"Couldn't recognize signal trampoline."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Offset to saved PC in sigcontext, from<asm/sigcontext.h>.  */
end_comment

begin_define
define|#
directive|define
name|LINUX_SIGCONTEXT_PC_OFFSET
value|(56)
end_define

begin_comment
comment|/* Assuming FRAME is for a GNU/Linux sigtramp routine, return the    saved program counter.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|i386_linux_sigtramp_saved_pc
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
name|addr
operator|=
name|i386_linux_sigcontext_addr
argument_list|(
name|frame
argument_list|)
expr_stmt|;
return|return
name|read_memory_integer
argument_list|(
name|addr
operator|+
name|LINUX_SIGCONTEXT_PC_OFFSET
argument_list|,
literal|4
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Offset to saved SP in sigcontext, from<asm/sigcontext.h>.  */
end_comment

begin_define
define|#
directive|define
name|LINUX_SIGCONTEXT_SP_OFFSET
value|(28)
end_define

begin_comment
comment|/* Assuming FRAME is for a GNU/Linux sigtramp routine, return the    saved stack pointer.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|i386_linux_sigtramp_saved_sp
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
name|addr
operator|=
name|i386_linux_sigcontext_addr
argument_list|(
name|frame
argument_list|)
expr_stmt|;
return|return
name|read_memory_integer
argument_list|(
name|addr
operator|+
name|LINUX_SIGCONTEXT_SP_OFFSET
argument_list|,
literal|4
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Signal trampolines don't have a meaningful frame.  As in    "i386/tm-i386.h", the frame pointer value we use is actually the    frame pointer of the calling frame -- that is, the frame which was    in progress when the signal trampoline was entered.  GDB mostly    treats this frame pointer value as a magic cookie.  We detect the    case of a signal trampoline by looking at the SIGNAL_HANDLER_CALLER    field, which is set based on IN_SIGTRAMP.     When a signal trampoline is invoked from a frameless function, we    essentially have two frameless functions in a row.  In this case,    we use the same magic cookie for three frames in a row.  We detect    this case by seeing whether the next frame has    SIGNAL_HANDLER_CALLER set, and, if it does, checking whether the    current frame is actually frameless.  In this case, we need to get    the PC by looking at the SP register value stored in the signal    context.     This should work in most cases except in horrible situations where    a signal occurs just as we enter a function but before the frame    has been set up.  */
end_comment

begin_define
define|#
directive|define
name|FRAMELESS_SIGNAL
parameter_list|(
name|frame
parameter_list|)
define|\
value|((frame)->next != NULL					\&& (frame)->next->signal_handler_caller			\&& frameless_look_for_prologue (frame))
end_define

begin_function
name|CORE_ADDR
name|i386_linux_frame_chain
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
if|if
condition|(
name|frame
operator|->
name|signal_handler_caller
operator|||
name|FRAMELESS_SIGNAL
argument_list|(
name|frame
argument_list|)
condition|)
return|return
name|frame
operator|->
name|frame
return|;
if|if
condition|(
operator|!
name|inside_entry_file
argument_list|(
name|frame
operator|->
name|pc
argument_list|)
condition|)
return|return
name|read_memory_unsigned_integer
argument_list|(
name|frame
operator|->
name|frame
argument_list|,
literal|4
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the saved program counter for FRAME.  */
end_comment

begin_function
name|CORE_ADDR
name|i386_linux_frame_saved_pc
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
if|if
condition|(
name|frame
operator|->
name|signal_handler_caller
condition|)
return|return
name|i386_linux_sigtramp_saved_pc
argument_list|(
name|frame
argument_list|)
return|;
if|if
condition|(
name|FRAMELESS_SIGNAL
argument_list|(
name|frame
argument_list|)
condition|)
block|{
name|CORE_ADDR
name|sp
init|=
name|i386_linux_sigtramp_saved_sp
argument_list|(
name|frame
operator|->
name|next
argument_list|)
decl_stmt|;
return|return
name|read_memory_unsigned_integer
argument_list|(
name|sp
argument_list|,
literal|4
argument_list|)
return|;
block|}
return|return
name|read_memory_unsigned_integer
argument_list|(
name|frame
operator|->
name|frame
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Immediately after a function call, return the saved pc.  */
end_comment

begin_function
name|CORE_ADDR
name|i386_linux_saved_pc_after_call
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
if|if
condition|(
name|frame
operator|->
name|signal_handler_caller
condition|)
return|return
name|i386_linux_sigtramp_saved_pc
argument_list|(
name|frame
argument_list|)
return|;
return|return
name|read_memory_unsigned_integer
argument_list|(
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
argument_list|,
literal|4
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set the program counter for process PTID to PC.  */
end_comment

begin_function
name|void
name|i386_linux_write_pc
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|ptid_t
name|ptid
parameter_list|)
block|{
name|write_register_pid
argument_list|(
name|PC_REGNUM
argument_list|,
name|pc
argument_list|,
name|ptid
argument_list|)
expr_stmt|;
comment|/* We must be careful with modifying the program counter.  If we      just interrupted a system call, the kernel might try to restart      it when we resume the inferior.  On restarting the system call,      the kernel will try backing up the program counter even though it      no longer points at the system call.  This typically results in a      SIGSEGV or SIGILL.  We can prevent this by writing `-1' in the      "orig_eax" pseudo-register.       Note that "orig_eax" is saved when setting up a dummy call frame.      This means that it is properly restored when that frame is      popped, and that the interrupted system call will be restarted      when we resume the inferior on return from a function call from      within GDB.  In all other cases the system call will not be      restarted.  */
name|write_register_pid
argument_list|(
name|I386_LINUX_ORIG_EAX_REGNUM
argument_list|,
operator|-
literal|1
argument_list|,
name|ptid
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Calling functions in shared libraries.  */
end_comment

begin_comment
comment|/* Find the minimal symbol named NAME, and return both the minsym    struct and its objfile.  This probably ought to be in minsym.c, but    everything there is trying to deal with things like C++ and    SOFUN_ADDRESS_MAYBE_TURQUOISE, ...  Since this is so simple, it may    be considered too special-purpose for general consumption.  */
end_comment

begin_function
specifier|static
name|struct
name|minimal_symbol
modifier|*
name|find_minsym_and_objfile
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|objfile
modifier|*
modifier|*
name|objfile_p
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|ALL_OBJFILES
argument_list|(
argument|objfile
argument_list|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|msym
decl_stmt|;
name|ALL_OBJFILE_MSYMBOLS
argument_list|(
argument|objfile
argument_list|,
argument|msym
argument_list|)
block|{
if|if
condition|(
name|SYMBOL_NAME
argument_list|(
name|msym
argument_list|)
operator|&&
name|STREQ
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|msym
argument_list|)
argument_list|,
name|name
argument_list|)
condition|)
block|{
operator|*
name|objfile_p
operator|=
name|objfile
expr_stmt|;
return|return
name|msym
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|skip_hurd_resolver
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
comment|/* The HURD dynamic linker is part of the GNU C library, so many      GNU/Linux distributions use it.  (All ELF versions, as far as I      know.)  An unresolved PLT entry points to "_dl_runtime_resolve",      which calls "fixup" to patch the PLT, and then passes control to      the function.       We look for the symbol `_dl_runtime_resolve', and find `fixup' in      the same objfile.  If we are at the entry point of `fixup', then      we set a breakpoint at the return address (at the top of the      stack), and continue.         It's kind of gross to do all these checks every time we're      called, since they don't change once the executable has gotten      started.  But this is only a temporary hack --- upcoming versions      of GNU/Linux will provide a portable, efficient interface for      debugging programs that use shared libraries.  */
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|resolver
init|=
name|find_minsym_and_objfile
argument_list|(
literal|"_dl_runtime_resolve"
argument_list|,
operator|&
name|objfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|resolver
condition|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|fixup
init|=
name|lookup_minimal_symbol
argument_list|(
literal|"fixup"
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|fixup
operator|&&
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|fixup
argument_list|)
operator|==
name|pc
condition|)
return|return
operator|(
name|SAVED_PC_AFTER_CALL
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* See the comments for SKIP_SOLIB_RESOLVER at the top of infrun.c.    This function:    1) decides whether a PLT has sent us into the linker to resolve       a function reference, and     2) if so, tells us where to set a temporary breakpoint that will       trigger when the dynamic linker is done.  */
end_comment

begin_function
name|CORE_ADDR
name|i386_linux_skip_solib_resolver
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|CORE_ADDR
name|result
decl_stmt|;
comment|/* Plug in functions for other kinds of resolvers here.  */
name|result
operator|=
name|skip_hurd_resolver
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Fetch (and possibly build) an appropriate link_map_offsets    structure for native GNU/Linux x86 targets using the struct offsets    defined in link.h (but without actual reference to that file).     This makes it possible to access GNU/Linux x86 shared libraries    from a GDB that was not built on an GNU/Linux x86 host (for cross    debugging).  */
end_comment

begin_function
name|struct
name|link_map_offsets
modifier|*
name|i386_linux_svr4_fetch_link_map_offsets
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|struct
name|link_map_offsets
name|lmo
decl_stmt|;
specifier|static
name|struct
name|link_map_offsets
modifier|*
name|lmp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|lmp
operator|==
name|NULL
condition|)
block|{
name|lmp
operator|=
operator|&
name|lmo
expr_stmt|;
name|lmo
operator|.
name|r_debug_size
operator|=
literal|8
expr_stmt|;
comment|/* The actual size is 20 bytes, but 				   this is all we need.  */
name|lmo
operator|.
name|r_map_offset
operator|=
literal|4
expr_stmt|;
name|lmo
operator|.
name|r_map_size
operator|=
literal|4
expr_stmt|;
name|lmo
operator|.
name|link_map_size
operator|=
literal|20
expr_stmt|;
comment|/* The actual size is 552 bytes, but 				   this is all we need.  */
name|lmo
operator|.
name|l_addr_offset
operator|=
literal|0
expr_stmt|;
name|lmo
operator|.
name|l_addr_size
operator|=
literal|4
expr_stmt|;
name|lmo
operator|.
name|l_name_offset
operator|=
literal|4
expr_stmt|;
name|lmo
operator|.
name|l_name_size
operator|=
literal|4
expr_stmt|;
name|lmo
operator|.
name|l_next_offset
operator|=
literal|12
expr_stmt|;
name|lmo
operator|.
name|l_next_size
operator|=
literal|4
expr_stmt|;
name|lmo
operator|.
name|l_prev_offset
operator|=
literal|16
expr_stmt|;
name|lmo
operator|.
name|l_prev_size
operator|=
literal|4
expr_stmt|;
block|}
return|return
name|lmp
return|;
block|}
end_function

end_unit

