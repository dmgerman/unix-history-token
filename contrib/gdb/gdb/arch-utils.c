begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Dynamic architecture support for GDB, the GNU debugger.    Copyright 1998, 1999, 2000, 2001 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_if
if|#
directive|if
name|GDB_MULTI_ARCH
end_if

begin_include
include|#
directive|include
file|"arch-utils.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_comment
comment|/* enum CALL_DUMMY_LOCATION et.al. */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Just include everything in sight so that the every old definition    of macro is visible. */
end_comment

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"gdb_wait.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"annotate.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"version.h"
end_include

begin_include
include|#
directive|include
file|"floatformat.h"
end_include

begin_comment
comment|/* Use the program counter to determine the contents and size    of a breakpoint instruction.  If no target-dependent macro    BREAKPOINT_FROM_PC has been defined to implement this function,    assume that the breakpoint doesn't depend on the PC, and    use the values of the BIG_BREAKPOINT and LITTLE_BREAKPOINT macros.    Return a pointer to a string of bytes that encode a breakpoint    instruction, stores the length of the string to *lenptr,    and optionally adjust the pc to point to the correct memory location    for inserting the breakpoint.  */
end_comment

begin_function
name|unsigned
name|char
modifier|*
name|legacy_breakpoint_from_pc
parameter_list|(
name|CORE_ADDR
modifier|*
name|pcptr
parameter_list|,
name|int
modifier|*
name|lenptr
parameter_list|)
block|{
comment|/* {BIG_,LITTLE_}BREAKPOINT is the sequence of bytes we insert for a      breakpoint.  On some machines, breakpoints are handled by the      target environment and we don't have to worry about them here.  */
ifdef|#
directive|ifdef
name|BIG_BREAKPOINT
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|)
block|{
specifier|static
name|unsigned
name|char
name|big_break_insn
index|[]
init|=
name|BIG_BREAKPOINT
decl_stmt|;
operator|*
name|lenptr
operator|=
sizeof|sizeof
argument_list|(
name|big_break_insn
argument_list|)
expr_stmt|;
return|return
name|big_break_insn
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LITTLE_BREAKPOINT
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|!=
name|BFD_ENDIAN_BIG
condition|)
block|{
specifier|static
name|unsigned
name|char
name|little_break_insn
index|[]
init|=
name|LITTLE_BREAKPOINT
decl_stmt|;
operator|*
name|lenptr
operator|=
sizeof|sizeof
argument_list|(
name|little_break_insn
argument_list|)
expr_stmt|;
return|return
name|little_break_insn
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BREAKPOINT
block|{
specifier|static
name|unsigned
name|char
name|break_insn
index|[]
init|=
name|BREAKPOINT
decl_stmt|;
operator|*
name|lenptr
operator|=
sizeof|sizeof
argument_list|(
name|break_insn
argument_list|)
expr_stmt|;
return|return
name|break_insn
return|;
block|}
endif|#
directive|endif
operator|*
name|lenptr
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|generic_frameless_function_invocation_not
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|generic_return_value_on_stack_not
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|generic_skip_trampoline_code
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|generic_in_solib_call_trampoline
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|generic_in_function_epilogue_p
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|CORE_ADDR
name|pc
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|legacy_register_name
parameter_list|(
name|int
name|i
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|REGISTER_NAMES
specifier|static
name|char
modifier|*
name|names
index|[]
init|=
name|REGISTER_NAMES
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>=
operator|(
sizeof|sizeof
argument_list|(
name|names
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|names
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
else|else
return|return
name|names
index|[
name|i
index|]
return|;
else|#
directive|else
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"legacy_register_name: called."
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CALL_DUMMY
argument_list|)
end_if

begin_decl_stmt
name|LONGEST
name|legacy_call_dummy_words
index|[]
init|=
name|CALL_DUMMY
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|LONGEST
name|legacy_call_dummy_words
index|[
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|legacy_sizeof_call_dummy_words
init|=
sizeof|sizeof
argument_list|(
name|legacy_call_dummy_words
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|generic_remote_translate_xfer_address
parameter_list|(
name|CORE_ADDR
name|gdb_addr
parameter_list|,
name|int
name|gdb_len
parameter_list|,
name|CORE_ADDR
modifier|*
name|rem_addr
parameter_list|,
name|int
modifier|*
name|rem_len
parameter_list|)
block|{
operator|*
name|rem_addr
operator|=
name|gdb_addr
expr_stmt|;
operator|*
name|rem_len
operator|=
name|gdb_len
expr_stmt|;
block|}
end_function

begin_function
name|int
name|generic_prologue_frameless_p
parameter_list|(
name|CORE_ADDR
name|ip
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SKIP_PROLOGUE_FRAMELESS_P
return|return
name|ip
operator|==
name|SKIP_PROLOGUE_FRAMELESS_P
argument_list|(
name|ip
argument_list|)
return|;
else|#
directive|else
return|return
name|ip
operator|==
name|SKIP_PROLOGUE
argument_list|(
name|ip
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* New/multi-arched targets should use the correct gdbarch field    instead of using this global pointer. */
end_comment

begin_function
name|int
name|legacy_print_insn
parameter_list|(
name|bfd_vma
name|vma
parameter_list|,
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
return|return
call|(
modifier|*
name|tm_print_insn
call|)
argument_list|(
name|vma
argument_list|,
name|info
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Helper functions for INNER_THAN */
end_comment

begin_function
name|int
name|core_addr_lessthan
parameter_list|(
name|CORE_ADDR
name|lhs
parameter_list|,
name|CORE_ADDR
name|rhs
parameter_list|)
block|{
return|return
operator|(
name|lhs
operator|<
name|rhs
operator|)
return|;
block|}
end_function

begin_function
name|int
name|core_addr_greaterthan
parameter_list|(
name|CORE_ADDR
name|lhs
parameter_list|,
name|CORE_ADDR
name|rhs
parameter_list|)
block|{
return|return
operator|(
name|lhs
operator|>
name|rhs
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Helper functions for TARGET_{FLOAT,DOUBLE}_FORMAT */
end_comment

begin_function
specifier|const
name|struct
name|floatformat
modifier|*
name|default_float_format
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|)
block|{
if|#
directive|if
name|GDB_MULTI_ARCH
name|int
name|byte_order
init|=
name|gdbarch_byte_order
argument_list|(
name|gdbarch
argument_list|)
decl_stmt|;
else|#
directive|else
name|int
name|byte_order
init|=
name|TARGET_BYTE_ORDER
decl_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|byte_order
condition|)
block|{
case|case
name|BFD_ENDIAN_BIG
case|:
return|return
operator|&
name|floatformat_ieee_single_big
return|;
case|case
name|BFD_ENDIAN_LITTLE
case|:
return|return
operator|&
name|floatformat_ieee_single_little
return|;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"default_float_format: bad byte order"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|const
name|struct
name|floatformat
modifier|*
name|default_double_format
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|)
block|{
if|#
directive|if
name|GDB_MULTI_ARCH
name|int
name|byte_order
init|=
name|gdbarch_byte_order
argument_list|(
name|gdbarch
argument_list|)
decl_stmt|;
else|#
directive|else
name|int
name|byte_order
init|=
name|TARGET_BYTE_ORDER
decl_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|byte_order
condition|)
block|{
case|case
name|BFD_ENDIAN_BIG
case|:
return|return
operator|&
name|floatformat_ieee_double_big
return|;
case|case
name|BFD_ENDIAN_LITTLE
case|:
return|return
operator|&
name|floatformat_ieee_double_little
return|;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"default_double_format: bad byte order"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|default_print_float_info
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|FLOAT_INFO
if|#
directive|if
name|GDB_MULTI_ARCH
operator|>
name|GDB_MULTI_ARCH_PARTIAL
error|#
directive|error
literal|"FLOAT_INFO defined in multi-arch"
endif|#
directive|endif
name|FLOAT_INFO
expr_stmt|;
else|#
directive|else
name|printf_filtered
argument_list|(
literal|"No floating point info available for this processor.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Misc helper functions for targets. */
end_comment

begin_function
name|int
name|frame_num_args_unknown
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|generic_register_convertible_not
parameter_list|(
name|int
name|num
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Under some ABI's that specify the `struct convention' for returning    structures by value, by the time we've returned from the function,    the return value is sitting there in the caller's buffer, but GDB    has no way to find the address of that buffer.     On such architectures, use this function as your    extract_struct_value_address method.  When asked to a struct    returned by value in this fashion, GDB will print a nice error    message, instead of garbage.  */
end_comment

begin_function
name|CORE_ADDR
name|generic_cannot_extract_struct_value_address
parameter_list|(
name|char
modifier|*
name|dummy
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|default_register_sim_regno
parameter_list|(
name|int
name|num
parameter_list|)
block|{
return|return
name|num
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|core_addr_identity
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|)
block|{
return|return
name|addr
return|;
block|}
end_function

begin_function
name|int
name|no_op_reg_to_regnum
parameter_list|(
name|int
name|reg
parameter_list|)
block|{
return|return
name|reg
return|;
block|}
end_function

begin_comment
comment|/* For use by frame_args_address and frame_locals_address.  */
end_comment

begin_function
name|CORE_ADDR
name|default_frame_address
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
return|return
name|fi
operator|->
name|frame
return|;
block|}
end_function

begin_comment
comment|/* Default prepare_to_procced().  */
end_comment

begin_function
name|int
name|default_prepare_to_proceed
parameter_list|(
name|int
name|select_it
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Generic prepare_to_proceed().  This one should be suitable for most    targets that support threads. */
end_comment

begin_function
name|int
name|generic_prepare_to_proceed
parameter_list|(
name|int
name|select_it
parameter_list|)
block|{
name|ptid_t
name|wait_ptid
decl_stmt|;
name|struct
name|target_waitstatus
name|wait_status
decl_stmt|;
comment|/* Get the last target status returned by target_wait().  */
name|get_last_target_status
argument_list|(
operator|&
name|wait_ptid
argument_list|,
operator|&
name|wait_status
argument_list|)
expr_stmt|;
comment|/* Make sure we were stopped either at a breakpoint, or because      of a Ctrl-C.  */
if|if
condition|(
name|wait_status
operator|.
name|kind
operator|!=
name|TARGET_WAITKIND_STOPPED
operator|||
operator|(
name|wait_status
operator|.
name|value
operator|.
name|sig
operator|!=
name|TARGET_SIGNAL_TRAP
operator|&&
name|wait_status
operator|.
name|value
operator|.
name|sig
operator|!=
name|TARGET_SIGNAL_INT
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|ptid_equal
argument_list|(
name|wait_ptid
argument_list|,
name|minus_one_ptid
argument_list|)
operator|&&
operator|!
name|ptid_equal
argument_list|(
name|inferior_ptid
argument_list|,
name|wait_ptid
argument_list|)
condition|)
block|{
comment|/* Switched over from WAIT_PID.  */
name|CORE_ADDR
name|wait_pc
init|=
name|read_pc_pid
argument_list|(
name|wait_ptid
argument_list|)
decl_stmt|;
if|if
condition|(
name|wait_pc
operator|!=
name|read_pc
argument_list|()
condition|)
block|{
if|if
condition|(
name|select_it
condition|)
block|{
comment|/* Switch back to WAIT_PID thread.  */
name|inferior_ptid
operator|=
name|wait_ptid
expr_stmt|;
comment|/* FIXME: This stuff came from switch_to_thread() in 		 thread.c (which should probably be a public function).  */
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|registers_changed
argument_list|()
expr_stmt|;
name|stop_pc
operator|=
name|wait_pc
expr_stmt|;
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* We return 1 to indicate that there is a breakpoint here,              so we need to step over it before continuing to avoid              hitting it straight away. */
if|if
condition|(
name|breakpoint_here_p
argument_list|(
name|wait_pc
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|init_frame_pc_noop
parameter_list|(
name|int
name|fromleaf
parameter_list|,
name|struct
name|frame_info
modifier|*
name|prev
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
name|void
name|init_frame_pc_default
parameter_list|(
name|int
name|fromleaf
parameter_list|,
name|struct
name|frame_info
modifier|*
name|prev
parameter_list|)
block|{
if|if
condition|(
name|fromleaf
condition|)
name|prev
operator|->
name|pc
operator|=
name|SAVED_PC_AFTER_CALL
argument_list|(
name|prev
operator|->
name|next
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|prev
operator|->
name|next
operator|!=
name|NULL
condition|)
name|prev
operator|->
name|pc
operator|=
name|FRAME_SAVED_PC
argument_list|(
name|prev
operator|->
name|next
argument_list|)
expr_stmt|;
else|else
name|prev
operator|->
name|pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|default_elf_make_msymbol_special
parameter_list|(
name|asymbol
modifier|*
name|sym
parameter_list|,
name|struct
name|minimal_symbol
modifier|*
name|msym
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
name|void
name|default_coff_make_msymbol_special
parameter_list|(
name|int
name|val
parameter_list|,
name|struct
name|minimal_symbol
modifier|*
name|msym
parameter_list|)
block|{
return|return;
block|}
end_function

begin_function
name|int
name|cannot_register_not
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Legacy version of target_virtual_frame_pointer().  Assumes that    there is an FP_REGNUM and that it is the same, cooked or raw.  */
end_comment

begin_function
name|void
name|legacy_virtual_frame_pointer
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|int
modifier|*
name|frame_regnum
parameter_list|,
name|LONGEST
modifier|*
name|frame_offset
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|FP_REGNUM
operator|>=
literal|0
argument_list|)
expr_stmt|;
operator|*
name|frame_regnum
operator|=
name|FP_REGNUM
expr_stmt|;
operator|*
name|frame_offset
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Assume the world is flat.  Every register is large enough to fit a    target integer.  */
end_comment

begin_function
name|int
name|generic_register_raw_size
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
argument_list|)
expr_stmt|;
return|return
name|TARGET_INT_BIT
operator|/
name|HOST_CHAR_BIT
return|;
block|}
end_function

begin_comment
comment|/* Assume the virtual size corresponds to the virtual type.  */
end_comment

begin_function
name|int
name|generic_register_virtual_size
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
return|return
name|TYPE_LENGTH
argument_list|(
name|REGISTER_VIRTUAL_TYPE
argument_list|(
name|regnum
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions to manipulate the endianness of the target.  */
end_comment

begin_comment
comment|/* ``target_byte_order'' is only used when non- multi-arch.    Multi-arch targets obtain the current byte order using the    TARGET_BYTE_ORDER gdbarch method.     The choice of initial value is entirely arbitrary.  During startup,    the function initialize_current_architecture() updates this value    based on default byte-order information extracted from BFD.  */
end_comment

begin_decl_stmt
name|int
name|target_byte_order
init|=
name|BFD_ENDIAN_BIG
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|target_byte_order_auto
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|endian_big
index|[]
init|=
literal|"big"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|endian_little
index|[]
init|=
literal|"little"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|endian_auto
index|[]
init|=
literal|"auto"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|endian_enum
index|[]
init|=
block|{
name|endian_big
block|,
name|endian_little
block|,
name|endian_auto
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|set_endian_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Called by ``show endian''.  */
end_comment

begin_function
specifier|static
name|void
name|show_endian
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|TARGET_BYTE_ORDER_AUTO
condition|)
name|printf_unfiltered
argument_list|(
literal|"The target endianness is set automatically (currently %s endian)\n"
argument_list|,
operator|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|?
literal|"big"
else|:
literal|"little"
operator|)
argument_list|)
expr_stmt|;
else|else
name|printf_unfiltered
argument_list|(
literal|"The target is assumed to be %s endian\n"
argument_list|,
operator|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|?
literal|"big"
else|:
literal|"little"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_endian
parameter_list|(
name|char
modifier|*
name|ignore_args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
name|set_endian_string
operator|==
name|endian_auto
condition|)
block|{
name|target_byte_order_auto
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|set_endian_string
operator|==
name|endian_little
condition|)
block|{
name|target_byte_order_auto
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GDB_MULTI_ARCH
condition|)
block|{
name|struct
name|gdbarch_info
name|info
decl_stmt|;
name|gdbarch_info_init
argument_list|(
operator|&
name|info
argument_list|)
expr_stmt|;
name|info
operator|.
name|byte_order
operator|=
name|BFD_ENDIAN_LITTLE
expr_stmt|;
if|if
condition|(
operator|!
name|gdbarch_update_p
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"Little endian target not supported by GDB\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|target_byte_order
operator|=
name|BFD_ENDIAN_LITTLE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|set_endian_string
operator|==
name|endian_big
condition|)
block|{
name|target_byte_order_auto
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|GDB_MULTI_ARCH
condition|)
block|{
name|struct
name|gdbarch_info
name|info
decl_stmt|;
name|gdbarch_info_init
argument_list|(
operator|&
name|info
argument_list|)
expr_stmt|;
name|info
operator|.
name|byte_order
operator|=
name|BFD_ENDIAN_BIG
expr_stmt|;
if|if
condition|(
operator|!
name|gdbarch_update_p
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"Big endian target not supported by GDB\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|target_byte_order
operator|=
name|BFD_ENDIAN_BIG
expr_stmt|;
block|}
block|}
else|else
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"set_endian: bad value"
argument_list|)
expr_stmt|;
name|show_endian
argument_list|(
name|NULL
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the endianness from a BFD.  */
end_comment

begin_function
specifier|static
name|void
name|set_endian_from_file
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|int
name|want
decl_stmt|;
if|if
condition|(
name|GDB_MULTI_ARCH
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"set_endian_from_file: not for multi-arch"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_big_endian
argument_list|(
name|abfd
argument_list|)
condition|)
name|want
operator|=
name|BFD_ENDIAN_BIG
expr_stmt|;
else|else
name|want
operator|=
name|BFD_ENDIAN_LITTLE
expr_stmt|;
if|if
condition|(
name|TARGET_BYTE_ORDER_AUTO
condition|)
name|target_byte_order
operator|=
name|want
expr_stmt|;
elseif|else
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|!=
name|want
condition|)
name|warning
argument_list|(
literal|"%s endian file does not match %s endian target."
argument_list|,
name|want
operator|==
name|BFD_ENDIAN_BIG
condition|?
literal|"big"
else|:
literal|"little"
argument_list|,
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|?
literal|"big"
else|:
literal|"little"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Functions to manipulate the architecture of the target */
end_comment

begin_enum
enum|enum
name|set_arch
block|{
name|set_arch_auto
block|,
name|set_arch_manual
block|}
enum|;
end_enum

begin_decl_stmt
name|int
name|target_architecture_auto
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|set_architecture_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Old way of changing the current architecture. */
end_comment

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|bfd_arch_info
name|bfd_default_arch_struct
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|bfd_arch_info
modifier|*
name|target_architecture
init|=
operator|&
name|bfd_default_arch_struct
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|target_architecture_hook
function_decl|)
parameter_list|(
specifier|const
name|struct
name|bfd_arch_info
modifier|*
name|ap
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|arch_ok
parameter_list|(
specifier|const
name|struct
name|bfd_arch_info
modifier|*
name|arch
parameter_list|)
block|{
if|if
condition|(
name|GDB_MULTI_ARCH
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"arch_ok: not multi-arched"
argument_list|)
expr_stmt|;
comment|/* Should be performing the more basic check that the binary is      compatible with GDB. */
comment|/* Check with the target that the architecture is valid. */
return|return
operator|(
name|target_architecture_hook
operator|==
name|NULL
operator|||
name|target_architecture_hook
argument_list|(
name|arch
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_arch
parameter_list|(
specifier|const
name|struct
name|bfd_arch_info
modifier|*
name|arch
parameter_list|,
name|enum
name|set_arch
name|type
parameter_list|)
block|{
if|if
condition|(
name|GDB_MULTI_ARCH
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"set_arch: not multi-arched"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|set_arch_auto
case|:
if|if
condition|(
operator|!
name|arch_ok
argument_list|(
name|arch
argument_list|)
condition|)
name|warning
argument_list|(
literal|"Target may not support %s architecture"
argument_list|,
name|arch
operator|->
name|printable_name
argument_list|)
expr_stmt|;
name|target_architecture
operator|=
name|arch
expr_stmt|;
break|break;
case|case
name|set_arch_manual
case|:
if|if
condition|(
operator|!
name|arch_ok
argument_list|(
name|arch
argument_list|)
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"Target does not support `%s' architecture.\n"
argument_list|,
name|arch
operator|->
name|printable_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|target_architecture_auto
operator|=
literal|0
expr_stmt|;
name|target_architecture
operator|=
name|arch
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|gdbarch_debug
condition|)
name|gdbarch_dump
argument_list|(
name|current_gdbarch
argument_list|,
name|gdb_stdlog
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the architecture from arch/machine (deprecated) */
end_comment

begin_function
name|void
name|set_architecture_from_arch_mach
parameter_list|(
name|enum
name|bfd_architecture
name|arch
parameter_list|,
name|unsigned
name|long
name|mach
parameter_list|)
block|{
specifier|const
name|struct
name|bfd_arch_info
modifier|*
name|wanted
init|=
name|bfd_lookup_arch
argument_list|(
name|arch
argument_list|,
name|mach
argument_list|)
decl_stmt|;
if|if
condition|(
name|GDB_MULTI_ARCH
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"set_architecture_from_arch_mach: not multi-arched"
argument_list|)
expr_stmt|;
if|if
condition|(
name|wanted
operator|!=
name|NULL
condition|)
name|set_arch
argument_list|(
name|wanted
argument_list|,
name|set_arch_manual
argument_list|)
expr_stmt|;
else|else
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"gdbarch: hardwired architecture/machine not recognized"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the architecture from a BFD (deprecated) */
end_comment

begin_function
specifier|static
name|void
name|set_architecture_from_file
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
specifier|const
name|struct
name|bfd_arch_info
modifier|*
name|wanted
init|=
name|bfd_get_arch_info
argument_list|(
name|abfd
argument_list|)
decl_stmt|;
if|if
condition|(
name|GDB_MULTI_ARCH
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"set_architecture_from_file: not multi-arched"
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_architecture_auto
condition|)
block|{
name|set_arch
argument_list|(
name|wanted
argument_list|,
name|set_arch_auto
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wanted
operator|!=
name|target_architecture
condition|)
block|{
name|warning
argument_list|(
literal|"%s architecture file may be incompatible with %s target."
argument_list|,
name|wanted
operator|->
name|printable_name
argument_list|,
name|target_architecture
operator|->
name|printable_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Called if the user enters ``show architecture'' without an    argument. */
end_comment

begin_function
specifier|static
name|void
name|show_architecture
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|arch
decl_stmt|;
name|arch
operator|=
name|TARGET_ARCHITECTURE
operator|->
name|printable_name
expr_stmt|;
if|if
condition|(
name|target_architecture_auto
condition|)
name|printf_filtered
argument_list|(
literal|"The target architecture is set automatically (currently %s)\n"
argument_list|,
name|arch
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"The target architecture is assumed to be %s\n"
argument_list|,
name|arch
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called if the user enters ``set architecture'' with or without an    argument. */
end_comment

begin_function
specifier|static
name|void
name|set_architecture
parameter_list|(
name|char
modifier|*
name|ignore_args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|set_architecture_string
argument_list|,
literal|"auto"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|target_architecture_auto
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GDB_MULTI_ARCH
condition|)
block|{
name|struct
name|gdbarch_info
name|info
decl_stmt|;
name|gdbarch_info_init
argument_list|(
operator|&
name|info
argument_list|)
expr_stmt|;
name|info
operator|.
name|bfd_arch_info
operator|=
name|bfd_scan_arch
argument_list|(
name|set_architecture_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|bfd_arch_info
operator|==
name|NULL
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"set_architecture: bfd_scan_arch failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|gdbarch_update_p
argument_list|(
name|info
argument_list|)
condition|)
name|target_architecture_auto
operator|=
literal|0
expr_stmt|;
else|else
name|printf_unfiltered
argument_list|(
literal|"Architecture `%s' not recognized.\n"
argument_list|,
name|set_architecture_string
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|struct
name|bfd_arch_info
modifier|*
name|arch
init|=
name|bfd_scan_arch
argument_list|(
name|set_architecture_string
argument_list|)
decl_stmt|;
if|if
condition|(
name|arch
operator|==
name|NULL
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"set_architecture: bfd_scan_arch failed"
argument_list|)
expr_stmt|;
name|set_arch
argument_list|(
name|arch
argument_list|,
name|set_arch_manual
argument_list|)
expr_stmt|;
block|}
name|show_architecture
argument_list|(
name|NULL
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the dynamic target-system-dependent parameters (architecture,    byte-order) using information found in the BFD */
end_comment

begin_function
name|void
name|set_gdbarch_from_file
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|if
condition|(
name|GDB_MULTI_ARCH
condition|)
block|{
name|struct
name|gdbarch_info
name|info
decl_stmt|;
name|gdbarch_info_init
argument_list|(
operator|&
name|info
argument_list|)
expr_stmt|;
name|info
operator|.
name|abfd
operator|=
name|abfd
expr_stmt|;
if|if
condition|(
operator|!
name|gdbarch_update_p
argument_list|(
name|info
argument_list|)
condition|)
name|error
argument_list|(
literal|"Architecture of file not recognized.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|set_architecture_from_file
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|set_endian_from_file
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize the current architecture.  Update the ``set    architecture'' command so that it specifies a list of valid    architectures.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEFAULT_BFD_ARCH
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|bfd_arch_info_type
name|DEFAULT_BFD_ARCH
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_arch_info_type
modifier|*
name|default_bfd_arch
init|=
operator|&
name|DEFAULT_BFD_ARCH
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
specifier|const
name|bfd_arch_info_type
modifier|*
name|default_bfd_arch
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEFAULT_BFD_VEC
end_ifdef

begin_decl_stmt
specifier|extern
specifier|const
name|bfd_target
name|DEFAULT_BFD_VEC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|bfd_target
modifier|*
name|default_bfd_vec
init|=
operator|&
name|DEFAULT_BFD_VEC
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
specifier|const
name|bfd_target
modifier|*
name|default_bfd_vec
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|initialize_current_architecture
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|arches
init|=
name|gdbarch_printable_names
argument_list|()
decl_stmt|;
comment|/* determine a default architecture and byte order. */
name|struct
name|gdbarch_info
name|info
decl_stmt|;
name|gdbarch_info_init
argument_list|(
operator|&
name|info
argument_list|)
expr_stmt|;
comment|/* Find a default architecture. */
if|if
condition|(
name|info
operator|.
name|bfd_arch_info
operator|==
name|NULL
operator|&&
name|default_bfd_arch
operator|!=
name|NULL
condition|)
name|info
operator|.
name|bfd_arch_info
operator|=
name|default_bfd_arch
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|bfd_arch_info
operator|==
name|NULL
condition|)
block|{
comment|/* Choose the architecture by taking the first one 	 alphabetically. */
specifier|const
name|char
modifier|*
name|chosen
init|=
name|arches
index|[
literal|0
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|arch
decl_stmt|;
for|for
control|(
name|arch
operator|=
name|arches
init|;
operator|*
name|arch
operator|!=
name|NULL
condition|;
name|arch
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|arch
argument_list|,
name|chosen
argument_list|)
operator|<
literal|0
condition|)
name|chosen
operator|=
operator|*
name|arch
expr_stmt|;
block|}
if|if
condition|(
name|chosen
operator|==
name|NULL
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"initialize_current_architecture: No arch"
argument_list|)
expr_stmt|;
name|info
operator|.
name|bfd_arch_info
operator|=
name|bfd_scan_arch
argument_list|(
name|chosen
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|.
name|bfd_arch_info
operator|==
name|NULL
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"initialize_current_architecture: Arch not found"
argument_list|)
expr_stmt|;
block|}
comment|/* Take several guesses at a byte order.  */
if|if
condition|(
name|info
operator|.
name|byte_order
operator|==
name|BFD_ENDIAN_UNKNOWN
operator|&&
name|default_bfd_vec
operator|!=
name|NULL
condition|)
block|{
comment|/* Extract BFD's default vector's byte order. */
switch|switch
condition|(
name|default_bfd_vec
operator|->
name|byteorder
condition|)
block|{
case|case
name|BFD_ENDIAN_BIG
case|:
name|info
operator|.
name|byte_order
operator|=
name|BFD_ENDIAN_BIG
expr_stmt|;
break|break;
case|case
name|BFD_ENDIAN_LITTLE
case|:
name|info
operator|.
name|byte_order
operator|=
name|BFD_ENDIAN_LITTLE
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|info
operator|.
name|byte_order
operator|==
name|BFD_ENDIAN_UNKNOWN
condition|)
block|{
comment|/* look for ``*el-*'' in the target name. */
specifier|const
name|char
modifier|*
name|chp
decl_stmt|;
name|chp
operator|=
name|strchr
argument_list|(
name|target_name
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|chp
operator|!=
name|NULL
operator|&&
name|chp
operator|-
literal|2
operator|>=
name|target_name
operator|&&
name|strncmp
argument_list|(
name|chp
operator|-
literal|2
argument_list|,
literal|"el"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|info
operator|.
name|byte_order
operator|=
name|BFD_ENDIAN_LITTLE
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|.
name|byte_order
operator|==
name|BFD_ENDIAN_UNKNOWN
condition|)
block|{
comment|/* Wire it to big-endian!!! */
name|info
operator|.
name|byte_order
operator|=
name|BFD_ENDIAN_BIG
expr_stmt|;
block|}
if|if
condition|(
name|GDB_MULTI_ARCH
condition|)
block|{
if|if
condition|(
operator|!
name|gdbarch_update_p
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"initialize_current_architecture: Selection of initial architecture failed"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* If the multi-arch logic comes up with a byte-order (from BFD)          use it for the non-multi-arch case.  */
if|if
condition|(
name|info
operator|.
name|byte_order
operator|!=
name|BFD_ENDIAN_UNKNOWN
condition|)
name|target_byte_order
operator|=
name|info
operator|.
name|byte_order
expr_stmt|;
name|initialize_non_multiarch
argument_list|()
expr_stmt|;
block|}
comment|/* Create the ``set architecture'' command appending ``auto'' to the      list of architectures. */
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
comment|/* Append ``auto''. */
name|int
name|nr
decl_stmt|;
for|for
control|(
name|nr
operator|=
literal|0
init|;
name|arches
index|[
name|nr
index|]
operator|!=
name|NULL
condition|;
name|nr
operator|++
control|)
empty_stmt|;
name|arches
operator|=
name|xrealloc
argument_list|(
name|arches
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|nr
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|arches
index|[
name|nr
operator|+
literal|0
index|]
operator|=
literal|"auto"
expr_stmt|;
name|arches
index|[
name|nr
operator|+
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* FIXME: add_set_enum_cmd() uses an array of ``char *'' instead        of ``const char *''.  We just happen to know that the casts are        safe. */
name|c
operator|=
name|add_set_enum_cmd
argument_list|(
literal|"architecture"
argument_list|,
name|class_support
argument_list|,
name|arches
argument_list|,
operator|&
name|set_architecture_string
argument_list|,
literal|"Set architecture of target."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|set_cmd_sfunc
argument_list|(
name|c
argument_list|,
name|set_architecture
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
literal|"processor"
argument_list|,
literal|"architecture"
argument_list|,
name|class_support
argument_list|,
literal|1
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
comment|/* Don't use set_from_show - need to print both auto/manual and        current setting. */
name|add_cmd
argument_list|(
literal|"architecture"
argument_list|,
name|class_support
argument_list|,
name|show_architecture
argument_list|,
literal|"Show the current target architecture"
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize a gdbarch info to values that will be automatically    overridden.  Note: Originally, this ``struct info'' was initialized    using memset(0).  Unfortunatly, that ran into problems, namely    BFD_ENDIAN_BIG is zero.  An explicit initialization function that    can explicitly set each field to a well defined value is used.  */
end_comment

begin_function
name|void
name|gdbarch_info_init
parameter_list|(
name|struct
name|gdbarch_info
modifier|*
name|info
parameter_list|)
block|{
name|memset
argument_list|(
name|info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|gdbarch_info
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|byte_order
operator|=
name|BFD_ENDIAN_UNKNOWN
expr_stmt|;
block|}
end_function

begin_comment
comment|/* */
end_comment

begin_decl_stmt
specifier|extern
name|initialize_file_ftype
name|_initialize_gdbarch_utils
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_gdbarch_utils
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|c
operator|=
name|add_set_enum_cmd
argument_list|(
literal|"endian"
argument_list|,
name|class_support
argument_list|,
name|endian_enum
argument_list|,
operator|&
name|set_endian_string
argument_list|,
literal|"Set endianness of target."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|set_cmd_sfunc
argument_list|(
name|c
argument_list|,
name|set_endian
argument_list|)
expr_stmt|;
comment|/* Don't use set_from_show - need to print both auto/manual and      current setting. */
name|add_cmd
argument_list|(
literal|"endian"
argument_list|,
name|class_support
argument_list|,
name|show_endian
argument_list|,
literal|"Show the current byte-order"
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

