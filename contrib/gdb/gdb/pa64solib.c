begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle HP ELF shared libraries for GDB, the GNU Debugger.     Copyright 1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation,    Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.     HP in their infinite stupidity choose not to use standard ELF dynamic    linker interfaces.  They also choose not to make their ELF dymamic    linker interfaces compatible with the SOM dynamic linker.  The    net result is we can not use either of the existing somsolib.c or    solib.c.  What a crock.     Even more disgusting.  This file depends on functions provided only    in certain PA64 libraries.  Thus this file is supposed to only be    used native.  When will HP ever learn that they need to provide the    same functionality in all their libraries!  */
end_comment

begin_include
include|#
directive|include
file|<dlfcn.h>
end_include

begin_include
include|#
directive|include
file|<elf.h>
end_include

begin_include
include|#
directive|include
file|<elf_hp.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"libhppa.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"gdb-stabs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"exec.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|O_BINARY
end_ifndef

begin_define
define|#
directive|define
name|O_BINARY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|CORE_ADDR
name|bfd_lookup_symbol
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* This lives in hppa-tdep.c. */
end_comment

begin_function_decl
specifier|extern
name|struct
name|unwind_table_entry
modifier|*
name|find_unwind_entry
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* These ought to be defined in some public interface, but aren't.  They    identify dynamic linker events.  */
end_comment

begin_define
define|#
directive|define
name|DLD_CB_LOAD
value|1
end_define

begin_define
define|#
directive|define
name|DLD_CB_UNLOAD
value|0
end_define

begin_comment
comment|/* A structure to keep track of all the known shared objects.  */
end_comment

begin_struct
struct|struct
name|so_list
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|so_list
modifier|*
name|next
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|CORE_ADDR
name|pa64_solib_desc_addr
decl_stmt|;
name|struct
name|load_module_desc
name|pa64_solib_desc
decl_stmt|;
name|struct
name|section_table
modifier|*
name|sections
decl_stmt|;
name|struct
name|section_table
modifier|*
name|sections_end
decl_stmt|;
name|int
name|loaded
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|so_list
modifier|*
name|so_list_head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the cumulative size in bytes of the symbol tables of all    shared objects on the so_list_head list.  (When we say size, here    we mean of the information before it is brought into memory and    potentially expanded by GDB.)  When adding a new shlib, this value    is compared against a threshold size, held by auto_solib_limit (in    megabytes).  If adding symbols for the new shlib would cause the    total size to exceed the threshold, then the new shlib's symbols    are not loaded. */
end_comment

begin_decl_stmt
specifier|static
name|LONGEST
name|pa64_solib_total_st_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When the threshold is reached for any shlib, we refuse to add    symbols for subsequent shlibs, even if those shlibs' symbols would    be small enough to fit under the threshold.  Although this may    result in one, early large shlib preventing the loading of later,    smaller shlibs' symbols, it allows us to issue one informational    message.  The alternative, to issue a message for each shlib whose    symbols aren't loaded, could be a big annoyance where the threshold    is exceeded due to a very large number of shlibs. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pa64_solib_st_size_threshold_exceeded
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When adding fields, be sure to clear them in _initialize_pa64_solib. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|CORE_ADDR
name|dld_flags_addr
decl_stmt|;
name|LONGEST
name|dld_flags
decl_stmt|;
name|struct
name|bfd_section
modifier|*
name|dyninfo_sect
decl_stmt|;
name|int
name|have_read_dld_descriptor
decl_stmt|;
name|int
name|is_valid
decl_stmt|;
name|CORE_ADDR
name|load_map
decl_stmt|;
name|CORE_ADDR
name|load_map_addr
decl_stmt|;
name|struct
name|load_module_desc
name|dld_desc
decl_stmt|;
block|}
name|dld_cache_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|dld_cache_t
name|dld_cache
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|pa64_sharedlibrary_info_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pa64_solib_sharedlibrary_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|pa64_target_read_memory
parameter_list|(
name|void
modifier|*
parameter_list|,
name|CORE_ADDR
parameter_list|,
name|size_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_dld_descriptor
parameter_list|(
name|struct
name|target_ops
modifier|*
parameter_list|,
name|int
name|readsyms
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_dynamic_info
parameter_list|(
name|asection
modifier|*
parameter_list|,
name|dld_cache_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_to_solist
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|load_module_desc
modifier|*
parameter_list|,
name|CORE_ADDR
parameter_list|,
name|struct
name|target_ops
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* When examining the shared library for debugging information we have to    look for HP debug symbols, stabs and dwarf2 debug symbols.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|pa64_debug_section_names
index|[]
init|=
block|{
literal|".debug_header"
block|,
literal|".debug_gntt"
block|,
literal|".debug_lntt"
block|,
literal|".debug_slt"
block|,
literal|".debug_vt"
block|,
literal|".stabs"
block|,
literal|".stabstr"
block|,
literal|".debug_info"
block|,
literal|".debug_abbrev"
block|,
literal|".debug_aranges"
block|,
literal|".debug_macinfo"
block|,
literal|".debug_line"
block|,
literal|".debug_loc"
block|,
literal|".debug_pubnames"
block|,
literal|".debug_str"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return a ballbark figure for the amount of memory GDB will need to    allocate to read in the debug symbols from FILENAME.  */
end_comment

begin_function
specifier|static
name|LONGEST
name|pa64_solib_sizeof_symbol_table
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|desc
decl_stmt|;
name|char
modifier|*
name|absolute_name
decl_stmt|;
name|LONGEST
name|st_size
init|=
operator|(
name|LONGEST
operator|)
literal|0
decl_stmt|;
name|asection
modifier|*
name|sect
decl_stmt|;
comment|/* We believe that filename was handed to us by the dynamic linker, and      is therefore always an absolute path.  */
name|desc
operator|=
name|openp
argument_list|(
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
argument_list|,
literal|1
argument_list|,
name|filename
argument_list|,
name|O_RDONLY
operator||
name|O_BINARY
argument_list|,
literal|0
argument_list|,
operator|&
name|absolute_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
block|{
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
name|filename
operator|=
name|absolute_name
expr_stmt|;
name|abfd
operator|=
name|bfd_fdopenr
argument_list|(
name|filename
argument_list|,
name|gnutarget
argument_list|,
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abfd
condition|)
block|{
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"\"%s\": can't open to read symbols: %s."
argument_list|,
name|filename
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
name|bfd_close
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"\"%s\": can't read symbols: %s."
argument_list|,
name|filename
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Sum the sizes of the various sections that compose debug info. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pa64_debug_section_names
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|asection
modifier|*
name|sect
decl_stmt|;
name|sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|pa64_debug_section_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sect
condition|)
name|st_size
operator|+=
operator|(
name|LONGEST
operator|)
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
expr_stmt|;
block|}
name|bfd_close
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|/* Unfortunately, just summing the sizes of various debug info      sections isn't a very accurate measurement of how much heap      space the debugger will need to hold them.  It also doesn't      account for space needed by linker (aka "minimal") symbols.       Anecdotal evidence suggests that just summing the sizes of      debug-info-related sections understates the heap space needed      to represent it internally by about an order of magnitude.       Since it's not exactly brain surgery we're doing here, rather      than attempt to more accurately measure the size of a shlib's      symbol table in GDB's heap, we'll just apply a 10x fudge-      factor to the debug info sections' size-sum.  No, this doesn't      account for minimal symbols in non-debuggable shlibs.  But it      all roughly washes out in the end.  */
return|return
name|st_size
operator|*
operator|(
name|LONGEST
operator|)
literal|10
return|;
block|}
end_function

begin_comment
comment|/* Add a shared library to the objfile list and load its symbols into    GDB's symbol table.  */
end_comment

begin_function
specifier|static
name|void
name|pa64_solib_add_solib_objfile
parameter_list|(
name|struct
name|so_list
modifier|*
name|so
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|CORE_ADDR
name|text_addr
parameter_list|)
block|{
name|bfd
modifier|*
name|tmp_bfd
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|obj_private_data_t
modifier|*
name|obj_private
decl_stmt|;
name|struct
name|section_addr_info
modifier|*
name|section_addrs
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|my_cleanups
decl_stmt|;
comment|/* We need the BFD so that we can look at its sections.  We open up the      file temporarily, then close it when we are done.  */
name|tmp_bfd
operator|=
name|bfd_openr
argument_list|(
name|name
argument_list|,
name|gnutarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_bfd
operator|==
name|NULL
condition|)
block|{
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|tmp_bfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
name|bfd_close
argument_list|(
name|tmp_bfd
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"\"%s\" is not an object file: %s"
argument_list|,
name|name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Undo some braindamage from symfile.c.       First, symfile.c will subtract the VMA of the first .text section      in the shared library that it finds.  Undo that.  */
name|sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|tmp_bfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
name|text_addr
operator|+=
name|bfd_section_vma
argument_list|(
name|tmp_bfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
comment|/* Now find the true lowest section in the shared library.  */
name|sec
operator|=
name|NULL
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|tmp_bfd
argument_list|,
name|find_lowest_section
argument_list|,
operator|&
name|sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|sec
condition|)
block|{
comment|/* Subtract out the VMA of the lowest section.  */
name|text_addr
operator|-=
name|bfd_section_vma
argument_list|(
name|tmp_bfd
argument_list|,
name|sec
argument_list|)
expr_stmt|;
comment|/* ??? Add back in the filepos of that lowest section. */
name|text_addr
operator|+=
name|sec
operator|->
name|filepos
expr_stmt|;
block|}
name|section_addrs
operator|=
name|alloc_section_addr_info
argument_list|(
name|bfd_count_sections
argument_list|(
name|tmp_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|my_cleanups
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|section_addrs
argument_list|)
expr_stmt|;
comment|/* We are done with the temporary bfd.  Get rid of it and make sure      nobody else can us it.  */
name|bfd_close
argument_list|(
name|tmp_bfd
argument_list|)
expr_stmt|;
name|tmp_bfd
operator|=
name|NULL
expr_stmt|;
comment|/* Now let the generic code load up symbols for this library.  */
name|section_addrs
operator|->
name|other
index|[
literal|0
index|]
operator|.
name|addr
operator|=
name|text_addr
expr_stmt|;
name|section_addrs
operator|->
name|other
index|[
literal|0
index|]
operator|.
name|name
operator|=
literal|".text"
expr_stmt|;
name|so
operator|->
name|objfile
operator|=
name|symbol_file_add
argument_list|(
name|name
argument_list|,
name|from_tty
argument_list|,
name|section_addrs
argument_list|,
literal|0
argument_list|,
name|OBJF_SHARED
argument_list|)
expr_stmt|;
name|so
operator|->
name|abfd
operator|=
name|so
operator|->
name|objfile
operator|->
name|obfd
expr_stmt|;
comment|/* Mark this as a shared library and save private data.  */
name|so
operator|->
name|objfile
operator|->
name|flags
operator||=
name|OBJF_SHARED
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|objfile
operator|->
name|obj_private
operator|==
name|NULL
condition|)
block|{
name|obj_private
operator|=
operator|(
name|obj_private_data_t
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|so
operator|->
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
name|obj_private_data_t
argument_list|)
argument_list|)
expr_stmt|;
name|obj_private
operator|->
name|unwind_info
operator|=
name|NULL
expr_stmt|;
name|obj_private
operator|->
name|so_info
operator|=
name|NULL
expr_stmt|;
name|so
operator|->
name|objfile
operator|->
name|obj_private
operator|=
name|obj_private
expr_stmt|;
block|}
name|obj_private
operator|=
operator|(
name|obj_private_data_t
operator|*
operator|)
name|so
operator|->
name|objfile
operator|->
name|obj_private
expr_stmt|;
name|obj_private
operator|->
name|so_info
operator|=
name|so
expr_stmt|;
name|obj_private
operator|->
name|dp
operator|=
name|so
operator|->
name|pa64_solib_desc
operator|.
name|linkage_ptr
expr_stmt|;
name|do_cleanups
argument_list|(
name|my_cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Load debugging information for a shared library.  TARGET may be    NULL if we are not attaching to a process or reading a core file.  */
end_comment

begin_function
specifier|static
name|void
name|pa64_solib_load_symbols
parameter_list|(
name|struct
name|so_list
modifier|*
name|so
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|CORE_ADDR
name|text_addr
parameter_list|,
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
block|{
name|struct
name|section_table
modifier|*
name|p
decl_stmt|;
name|asection
modifier|*
name|sec
decl_stmt|;
name|int
name|status
decl_stmt|;
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|CORE_ADDR
name|presumed_data_start
decl_stmt|;
if|if
condition|(
name|text_addr
operator|==
literal|0
condition|)
name|text_addr
operator|=
name|so
operator|->
name|pa64_solib_desc
operator|.
name|text_base
expr_stmt|;
name|pa64_solib_add_solib_objfile
argument_list|(
name|so
argument_list|,
name|name
argument_list|,
name|from_tty
argument_list|,
name|text_addr
argument_list|)
expr_stmt|;
comment|/* Now we need to build a section table for this library since      we might be debugging a core file from a dynamically linked      executable in which the libraries were not privately mapped.  */
if|if
condition|(
name|build_section_table
argument_list|(
name|so
operator|->
name|abfd
argument_list|,
operator|&
name|so
operator|->
name|sections
argument_list|,
operator|&
name|so
operator|->
name|sections_end
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Unable to build section table for shared library\n."
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|so
operator|->
name|objfile
operator|->
name|section_offsets
operator|)
operator|->
name|offsets
index|[
name|SECT_OFF_TEXT
argument_list|(
name|so
operator|->
name|objfile
argument_list|)
index|]
operator|=
name|so
operator|->
name|pa64_solib_desc
operator|.
name|text_base
expr_stmt|;
operator|(
name|so
operator|->
name|objfile
operator|->
name|section_offsets
operator|)
operator|->
name|offsets
index|[
name|SECT_OFF_DATA
argument_list|(
name|so
operator|->
name|objfile
argument_list|)
index|]
operator|=
name|so
operator|->
name|pa64_solib_desc
operator|.
name|data_base
expr_stmt|;
comment|/* Relocate all the sections based on where they got loaded.  */
for|for
control|(
name|p
operator|=
name|so
operator|->
name|sections
init|;
name|p
operator|<
name|so
operator|->
name|sections_end
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|the_bfd_section
operator|->
name|flags
operator|&
name|SEC_CODE
condition|)
block|{
name|p
operator|->
name|addr
operator|+=
name|ANOFFSET
argument_list|(
name|so
operator|->
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|so
operator|->
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|endaddr
operator|+=
name|ANOFFSET
argument_list|(
name|so
operator|->
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|so
operator|->
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|the_bfd_section
operator|->
name|flags
operator|&
name|SEC_DATA
condition|)
block|{
name|p
operator|->
name|addr
operator|+=
name|ANOFFSET
argument_list|(
name|so
operator|->
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_DATA
argument_list|(
name|so
operator|->
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|endaddr
operator|+=
name|ANOFFSET
argument_list|(
name|so
operator|->
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_DATA
argument_list|(
name|so
operator|->
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now see if we need to map in the text and data for this shared      library (for example debugging a core file which does not use      private shared libraries.).        Carefully peek at the first text address in the library.  If the      read succeeds, then the libraries were privately mapped and were      included in the core dump file.       If the peek failed, then the libraries were not privately mapped      and are not in the core file, we'll have to read them in ourselves.  */
name|status
operator|=
name|target_read_memory
argument_list|(
name|text_addr
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|int
name|new
decl_stmt|,
name|old
decl_stmt|;
name|new
operator|=
name|so
operator|->
name|sections_end
operator|-
name|so
operator|->
name|sections
expr_stmt|;
name|old
operator|=
name|target_resize_to_sections
argument_list|(
name|target
argument_list|,
name|new
argument_list|)
expr_stmt|;
comment|/* Copy over the old data before it gets clobbered.  */
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|target
operator|->
name|to_sections
operator|+
name|old
operator|)
argument_list|,
name|so
operator|->
name|sections
argument_list|,
operator|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_table
argument_list|)
operator|)
operator|*
name|new
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add symbols from shared libraries into the symtab list, unless the    size threshold specified by auto_solib_limit (in megabytes) would    be exceeded.  */
end_comment

begin_function
name|void
name|pa64_solib_add
parameter_list|(
name|char
modifier|*
name|arg_string
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|target_ops
modifier|*
name|target
parameter_list|,
name|int
name|readsyms
parameter_list|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|asection
modifier|*
name|shlib_info
decl_stmt|;
name|int
name|status
decl_stmt|;
name|unsigned
name|int
name|dld_flags
decl_stmt|;
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|,
modifier|*
name|re_err
decl_stmt|;
name|int
name|threshold_warning_given
init|=
literal|0
decl_stmt|;
name|int
name|dll_index
decl_stmt|;
name|struct
name|load_module_desc
name|dll_desc
decl_stmt|;
name|char
modifier|*
name|dll_path
decl_stmt|;
comment|/* First validate our arguments.  */
if|if
condition|(
operator|(
name|re_err
operator|=
name|re_comp
argument_list|(
name|arg_string
condition|?
name|arg_string
else|:
literal|"."
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"Invalid regexp: %s"
argument_list|,
name|re_err
argument_list|)
expr_stmt|;
block|}
comment|/* If we're debugging a core file, or have attached to a running      process, then pa64_solib_create_inferior_hook will not have been      called.       We need to first determine if we're dealing with a dynamically      linked executable.  If not, then return without an error or warning.       We also need to examine __dld_flags to determine if the shared library      list is valid and to determine if the libraries have been privately      mapped.  */
if|if
condition|(
name|symfile_objfile
operator|==
name|NULL
condition|)
return|return;
comment|/* First see if the objfile was dynamically linked.  */
name|shlib_info
operator|=
name|bfd_get_section_by_name
argument_list|(
name|symfile_objfile
operator|->
name|obfd
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|shlib_info
condition|)
return|return;
comment|/* It's got a .dynamic section, make sure it's not empty.  */
if|if
condition|(
name|bfd_section_size
argument_list|(
name|symfile_objfile
operator|->
name|obfd
argument_list|,
name|shlib_info
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* Read in the load map pointer if we have not done so already.  */
if|if
condition|(
operator|!
name|dld_cache
operator|.
name|have_read_dld_descriptor
condition|)
if|if
condition|(
operator|!
name|read_dld_descriptor
argument_list|(
name|target
argument_list|,
name|readsyms
argument_list|)
condition|)
return|return;
comment|/* If the libraries were not mapped private, warn the user.  */
if|if
condition|(
operator|(
name|dld_cache
operator|.
name|dld_flags
operator|&
name|DT_HP_DEBUG_PRIVATE
operator|)
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"The shared libraries were not privately mapped; setting a\nbreakpoint in a shared library will not work until you rerun the program.\n"
argument_list|)
expr_stmt|;
comment|/* For each shaerd library, add it to the shared library list.  */
for|for
control|(
name|dll_index
operator|=
literal|1
init|;
condition|;
name|dll_index
operator|++
control|)
block|{
comment|/* Read in the load module descriptor.  */
if|if
condition|(
name|dlgetmodinfo
argument_list|(
name|dll_index
argument_list|,
operator|&
name|dll_desc
argument_list|,
sizeof|sizeof
argument_list|(
name|dll_desc
argument_list|)
argument_list|,
name|pa64_target_read_memory
argument_list|,
literal|0
argument_list|,
name|dld_cache
operator|.
name|load_map
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* Get the name of the shared library.  */
name|dll_path
operator|=
operator|(
name|char
operator|*
operator|)
name|dlgetname
argument_list|(
operator|&
name|dll_desc
argument_list|,
sizeof|sizeof
argument_list|(
name|dll_desc
argument_list|)
argument_list|,
name|pa64_target_read_memory
argument_list|,
literal|0
argument_list|,
name|dld_cache
operator|.
name|load_map
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dll_path
condition|)
name|error
argument_list|(
literal|"pa64_solib_add, unable to read shared library path."
argument_list|)
expr_stmt|;
name|add_to_solist
argument_list|(
name|from_tty
argument_list|,
name|dll_path
argument_list|,
name|readsyms
argument_list|,
operator|&
name|dll_desc
argument_list|,
literal|0
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This hook gets called just before the first instruction in the    inferior process is executed.     This is our opportunity to set magic flags in the inferior so    that GDB can be notified when a shared library is mapped in and    to tell the dynamic linker that a private copy of the library is    needed (so GDB can set breakpoints in the library).     We need to set two flag bits in this routine.       DT_HP_DEBUG_PRIVATE to indicate that shared libraries should be      mapped private.       DT_HP_DEBUG_CALLBACK to indicate that we want the dynamic linker to      call the breakpoint routine for significant events.  */
end_comment

begin_function
name|void
name|pa64_solib_create_inferior_hook
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|unsigned
name|int
name|dld_flags
decl_stmt|,
name|status
decl_stmt|;
name|asection
modifier|*
name|shlib_info
decl_stmt|,
modifier|*
name|interp_sect
decl_stmt|;
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|CORE_ADDR
name|anaddr
decl_stmt|;
comment|/* First, remove all the solib event breakpoints.  Their addresses      may have changed since the last time we ran the program.  */
name|remove_solib_event_breakpoints
argument_list|()
expr_stmt|;
if|if
condition|(
name|symfile_objfile
operator|==
name|NULL
condition|)
return|return;
comment|/* First see if the objfile was dynamically linked.  */
name|shlib_info
operator|=
name|bfd_get_section_by_name
argument_list|(
name|symfile_objfile
operator|->
name|obfd
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|shlib_info
condition|)
return|return;
comment|/* It's got a .dynamic section, make sure it's not empty.  */
if|if
condition|(
name|bfd_section_size
argument_list|(
name|symfile_objfile
operator|->
name|obfd
argument_list|,
name|shlib_info
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* Read in the .dynamic section.  */
if|if
condition|(
operator|!
name|read_dynamic_info
argument_list|(
name|shlib_info
argument_list|,
operator|&
name|dld_cache
argument_list|)
condition|)
name|error
argument_list|(
literal|"Unable to read the .dynamic section."
argument_list|)
expr_stmt|;
comment|/* Turn on the flags we care about.  */
name|dld_cache
operator|.
name|dld_flags
operator||=
name|DT_HP_DEBUG_PRIVATE
expr_stmt|;
name|dld_cache
operator|.
name|dld_flags
operator||=
name|DT_HP_DEBUG_CALLBACK
expr_stmt|;
name|status
operator|=
name|target_write_memory
argument_list|(
name|dld_cache
operator|.
name|dld_flags_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dld_cache
operator|.
name|dld_flags
argument_list|,
sizeof|sizeof
argument_list|(
name|dld_cache
operator|.
name|dld_flags
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"Unable to modify dynamic linker flags."
argument_list|)
expr_stmt|;
comment|/* Now we have to create a shared library breakpoint in the dynamic      linker.  This can be somewhat tricky since the symbol is inside      the dynamic linker (for which we do not have symbols or a base      load address!   Luckily I wrote this code for solib.c years ago.  */
name|interp_sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|exec_bfd
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|interp_sect
condition|)
block|{
name|unsigned
name|int
name|interp_sect_size
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|CORE_ADDR
name|load_addr
decl_stmt|;
name|bfd
modifier|*
name|tmp_bfd
decl_stmt|;
name|CORE_ADDR
name|sym_addr
init|=
literal|0
decl_stmt|;
comment|/* Read the contents of the .interp section into a local buffer; 	 the contents specify the dynamic linker this program uses.  */
name|interp_sect_size
operator|=
name|bfd_section_size
argument_list|(
name|exec_bfd
argument_list|,
name|interp_sect
argument_list|)
expr_stmt|;
name|buf
operator|=
name|alloca
argument_list|(
name|interp_sect_size
argument_list|)
expr_stmt|;
name|bfd_get_section_contents
argument_list|(
name|exec_bfd
argument_list|,
name|interp_sect
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|interp_sect_size
argument_list|)
expr_stmt|;
comment|/* Now we need to figure out where the dynamic linker was 	 loaded so that we can load its symbols and place a breakpoint 	 in the dynamic linker itself.  	 This address is stored on the stack.  However, I've been unable 	 to find any magic formula to find it for Solaris (appears to 	 be trivial on GNU/Linux).  Therefore, we have to try an alternate 	 mechanism to find the dynamic linker's base address.  */
name|tmp_bfd
operator|=
name|bfd_openr
argument_list|(
name|buf
argument_list|,
name|gnutarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_bfd
operator|==
name|NULL
condition|)
goto|goto
name|get_out
goto|;
comment|/* Make sure the dynamic linker's really a useful object.  */
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|tmp_bfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to grok dynamic linker %s as an object file"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|bfd_close
argument_list|(
name|tmp_bfd
argument_list|)
expr_stmt|;
goto|goto
name|get_out
goto|;
block|}
comment|/* We find the dynamic linker's base address by examining the 	 current pc (which point at the entry point for the dynamic 	 linker) and subtracting the offset of the entry point.   	 Also note the breakpoint is the second instruction in the 	 routine.  */
name|load_addr
operator|=
name|read_pc
argument_list|()
operator|-
name|tmp_bfd
operator|->
name|start_address
expr_stmt|;
name|sym_addr
operator|=
name|bfd_lookup_symbol
argument_list|(
name|tmp_bfd
argument_list|,
literal|"__dld_break"
argument_list|)
expr_stmt|;
name|sym_addr
operator|=
name|load_addr
operator|+
name|sym_addr
operator|+
literal|4
expr_stmt|;
comment|/* Create the shared library breakpoint.  */
block|{
name|struct
name|breakpoint
modifier|*
name|b
init|=
name|create_solib_event_breakpoint
argument_list|(
name|sym_addr
argument_list|)
decl_stmt|;
comment|/* The breakpoint is actually hard-coded into the dynamic linker, 	   so we don't need to actually insert a breakpoint instruction 	   there.  In fact, the dynamic linker's code is immutable, even to 	   ttrace, so we shouldn't even try to do that.  For cases like 	   this, we have "permanent" breakpoints.  */
name|make_breakpoint_permanent
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
comment|/* We're done with the temporary bfd.  */
name|bfd_close
argument_list|(
name|tmp_bfd
argument_list|)
expr_stmt|;
block|}
name|get_out
label|:
comment|/* Wipe out all knowledge of old shared libraries since their      mapping can change from one exec to another!  */
while|while
condition|(
name|so_list_head
condition|)
block|{
name|struct
name|so_list
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
name|so_list_head
expr_stmt|;
name|xfree
argument_list|(
name|so_list_head
argument_list|)
expr_stmt|;
name|so_list_head
operator|=
name|temp
operator|->
name|next
expr_stmt|;
block|}
name|clear_symtab_users
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This operation removes the "hook" between GDB and the dynamic linker,    which causes the dld to notify GDB of shared library events.     After this operation completes, the dld will no longer notify GDB of    shared library events.  To resume notifications, GDB must call    pa64_solib_create_inferior_hook.     This operation does not remove any knowledge of shared libraries which    GDB may already have been notified of.  */
end_comment

begin_function
name|void
name|pa64_solib_remove_inferior_hook
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
comment|/* Turn off the DT_HP_DEBUG_CALLBACK bit in the dynamic linker flags.  */
name|dld_cache
operator|.
name|dld_flags
operator|&=
operator|~
name|DT_HP_DEBUG_CALLBACK
expr_stmt|;
name|target_write_memory
argument_list|(
name|dld_cache
operator|.
name|dld_flags_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dld_cache
operator|.
name|dld_flags
argument_list|,
sizeof|sizeof
argument_list|(
name|dld_cache
operator|.
name|dld_flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function creates a breakpoint on the dynamic linker hook, which    is called when e.g., a shl_load or shl_unload call is made.  This    breakpoint will only trigger when a shl_load call is made.     If filename is NULL, then loads of any dll will be caught.  Else,    only loads of the file whose pathname is the string contained by    filename will be caught.     Undefined behaviour is guaranteed if this function is called before    pa64_solib_create_inferior_hook.  */
end_comment

begin_function
name|void
name|pa64_solib_create_catch_load_hook
parameter_list|(
name|int
name|pid
parameter_list|,
name|int
name|tempflag
parameter_list|,
name|char
modifier|*
name|filename
parameter_list|,
name|char
modifier|*
name|cond_string
parameter_list|)
block|{
name|create_solib_load_event_breakpoint
argument_list|(
literal|""
argument_list|,
name|tempflag
argument_list|,
name|filename
argument_list|,
name|cond_string
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function creates a breakpoint on the dynamic linker hook, which    is called when e.g., a shl_load or shl_unload call is made.  This    breakpoint will only trigger when a shl_unload call is made.     If filename is NULL, then unloads of any dll will be caught.  Else,    only unloads of the file whose pathname is the string contained by    filename will be caught.     Undefined behaviour is guaranteed if this function is called before    pa64_solib_create_inferior_hook.  */
end_comment

begin_function
name|void
name|pa64_solib_create_catch_unload_hook
parameter_list|(
name|int
name|pid
parameter_list|,
name|int
name|tempflag
parameter_list|,
name|char
modifier|*
name|filename
parameter_list|,
name|char
modifier|*
name|cond_string
parameter_list|)
block|{
name|create_solib_unload_event_breakpoint
argument_list|(
literal|""
argument_list|,
name|tempflag
argument_list|,
name|filename
argument_list|,
name|cond_string
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return nonzero if the dynamic linker has reproted that a library    has been loaded.  */
end_comment

begin_function
name|int
name|pa64_solib_have_load_event
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
name|CORE_ADDR
name|event_kind
decl_stmt|;
name|event_kind
operator|=
name|read_register
argument_list|(
name|ARG0_REGNUM
argument_list|)
expr_stmt|;
return|return
operator|(
name|event_kind
operator|==
name|DLD_CB_LOAD
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if the dynamic linker has reproted that a library    has been unloaded.  */
end_comment

begin_function
name|int
name|pa64_solib_have_unload_event
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
name|CORE_ADDR
name|event_kind
decl_stmt|;
name|event_kind
operator|=
name|read_register
argument_list|(
name|ARG0_REGNUM
argument_list|)
expr_stmt|;
return|return
operator|(
name|event_kind
operator|==
name|DLD_CB_UNLOAD
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to a string indicating the pathname of the most    recently loaded library.     The caller is reposible for copying the string before the inferior is    restarted.  */
end_comment

begin_function
name|char
modifier|*
name|pa64_solib_loaded_library_pathname
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
specifier|static
name|char
name|dll_path
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|CORE_ADDR
name|dll_path_addr
init|=
name|read_register
argument_list|(
name|ARG3_REGNUM
argument_list|)
decl_stmt|;
name|read_memory_string
argument_list|(
name|dll_path_addr
argument_list|,
name|dll_path
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
return|return
name|dll_path
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to a string indicating the pathname of the most    recently unloaded library.     The caller is reposible for copying the string before the inferior is    restarted.  */
end_comment

begin_function
name|char
modifier|*
name|pa64_solib_unloaded_library_pathname
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
specifier|static
name|char
name|dll_path
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|CORE_ADDR
name|dll_path_addr
init|=
name|read_register
argument_list|(
name|ARG3_REGNUM
argument_list|)
decl_stmt|;
name|read_memory_string
argument_list|(
name|dll_path_addr
argument_list|,
name|dll_path
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
return|return
name|dll_path
return|;
block|}
end_function

begin_comment
comment|/* Return nonzero if PC is an address inside the dynamic linker.  */
end_comment

begin_function
name|int
name|pa64_solib_in_dynamic_linker
parameter_list|(
name|int
name|pid
parameter_list|,
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|asection
modifier|*
name|shlib_info
decl_stmt|;
if|if
condition|(
name|symfile_objfile
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|dld_cache
operator|.
name|have_read_dld_descriptor
condition|)
if|if
condition|(
operator|!
name|read_dld_descriptor
argument_list|(
operator|&
name|current_target
argument_list|,
name|auto_solib_add
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|pc
operator|>=
name|dld_cache
operator|.
name|dld_desc
operator|.
name|text_base
operator|&&
name|pc
operator|<
name|dld_cache
operator|.
name|dld_desc
operator|.
name|text_base
operator|+
name|dld_cache
operator|.
name|dld_desc
operator|.
name|text_size
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the GOT value for the shared library in which ADDR belongs.  If    ADDR isn't in any known shared library, return zero.  */
end_comment

begin_function
name|CORE_ADDR
name|pa64_solib_get_got_by_pc
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|)
block|{
name|struct
name|so_list
modifier|*
name|so_list
init|=
name|so_list_head
decl_stmt|;
name|CORE_ADDR
name|got_value
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|so_list
condition|)
block|{
if|if
condition|(
name|so_list
operator|->
name|pa64_solib_desc
operator|.
name|text_base
operator|<=
name|addr
operator|&&
operator|(
operator|(
name|so_list
operator|->
name|pa64_solib_desc
operator|.
name|text_base
operator|+
name|so_list
operator|->
name|pa64_solib_desc
operator|.
name|text_size
operator|)
operator|>
name|addr
operator|)
condition|)
block|{
name|got_value
operator|=
name|so_list
operator|->
name|pa64_solib_desc
operator|.
name|linkage_ptr
expr_stmt|;
break|break;
block|}
name|so_list
operator|=
name|so_list
operator|->
name|next
expr_stmt|;
block|}
return|return
name|got_value
return|;
block|}
end_function

begin_comment
comment|/* Return the address of the handle of the shared library in which ADDR    belongs.  If ADDR isn't in any known shared library, return zero.      This function is used in hppa_fix_call_dummy in hppa-tdep.c.  */
end_comment

begin_function
name|CORE_ADDR
name|pa64_solib_get_solib_by_pc
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|)
block|{
name|struct
name|so_list
modifier|*
name|so_list
init|=
name|so_list_head
decl_stmt|;
name|CORE_ADDR
name|retval
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|so_list
condition|)
block|{
if|if
condition|(
name|so_list
operator|->
name|pa64_solib_desc
operator|.
name|text_base
operator|<=
name|addr
operator|&&
operator|(
operator|(
name|so_list
operator|->
name|pa64_solib_desc
operator|.
name|text_base
operator|+
name|so_list
operator|->
name|pa64_solib_desc
operator|.
name|text_size
operator|)
operator|>
name|addr
operator|)
condition|)
block|{
name|retval
operator|=
name|so_list
operator|->
name|pa64_solib_desc_addr
expr_stmt|;
break|break;
block|}
name|so_list
operator|=
name|so_list
operator|->
name|next
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Dump information about all the currently loaded shared libraries.  */
end_comment

begin_function
specifier|static
name|void
name|pa64_sharedlibrary_info_command
parameter_list|(
name|char
modifier|*
name|ignore
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|so_list
modifier|*
name|so_list
init|=
name|so_list_head
decl_stmt|;
if|if
condition|(
name|exec_bfd
operator|==
name|NULL
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"No executable file.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|so_list
operator|==
name|NULL
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"No shared libraries loaded at this time.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf_unfiltered
argument_list|(
literal|"Shared Object Libraries\n"
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"   %-19s%-19s%-19s%-19s\n"
argument_list|,
literal|"  text start"
argument_list|,
literal|"   text end"
argument_list|,
literal|"  data start"
argument_list|,
literal|"   data end"
argument_list|)
expr_stmt|;
while|while
condition|(
name|so_list
condition|)
block|{
name|unsigned
name|int
name|flags
decl_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%s"
argument_list|,
name|so_list
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|so_list
operator|->
name|objfile
operator|==
name|NULL
condition|)
name|printf_unfiltered
argument_list|(
literal|"  (symbols not loaded)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|so_list
operator|->
name|loaded
operator|==
literal|0
condition|)
name|printf_unfiltered
argument_list|(
literal|"  (shared library unloaded)"
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"  %-18s"
argument_list|,
name|local_hex_string_custom
argument_list|(
name|so_list
operator|->
name|pa64_solib_desc
operator|.
name|linkage_ptr
argument_list|,
literal|"016l"
argument_list|)
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%-18s"
argument_list|,
name|local_hex_string_custom
argument_list|(
name|so_list
operator|->
name|pa64_solib_desc
operator|.
name|text_base
argument_list|,
literal|"016l"
argument_list|)
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|" %-18s"
argument_list|,
name|local_hex_string_custom
argument_list|(
operator|(
name|so_list
operator|->
name|pa64_solib_desc
operator|.
name|text_base
operator|+
name|so_list
operator|->
name|pa64_solib_desc
operator|.
name|text_size
operator|)
argument_list|,
literal|"016l"
argument_list|)
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|" %-18s"
argument_list|,
name|local_hex_string_custom
argument_list|(
name|so_list
operator|->
name|pa64_solib_desc
operator|.
name|data_base
argument_list|,
literal|"016l"
argument_list|)
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|" %-18s\n"
argument_list|,
name|local_hex_string_custom
argument_list|(
operator|(
name|so_list
operator|->
name|pa64_solib_desc
operator|.
name|data_base
operator|+
name|so_list
operator|->
name|pa64_solib_desc
operator|.
name|data_size
operator|)
argument_list|,
literal|"016l"
argument_list|)
argument_list|)
expr_stmt|;
name|so_list
operator|=
name|so_list
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Load up one or more shared libraries as directed by the user.  */
end_comment

begin_function
specifier|static
name|void
name|pa64_solib_sharedlibrary_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|dont_repeat
argument_list|()
expr_stmt|;
name|pa64_solib_add
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|,
operator|(
expr|struct
name|target_ops
operator|*
operator|)
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the name of the shared library containing ADDR or NULL if ADDR    is not contained in any known shared library.  */
end_comment

begin_function
name|char
modifier|*
name|pa64_solib_address
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|)
block|{
name|struct
name|so_list
modifier|*
name|so
init|=
name|so_list_head
decl_stmt|;
while|while
condition|(
name|so
condition|)
block|{
comment|/* Is this address within this shlib's text range?  If so, 	 return the shlib's name.  */
if|if
condition|(
name|addr
operator|>=
name|so
operator|->
name|pa64_solib_desc
operator|.
name|text_base
operator|&&
name|addr
operator|<
operator|(
name|so
operator|->
name|pa64_solib_desc
operator|.
name|text_base
operator||
name|so
operator|->
name|pa64_solib_desc
operator|.
name|text_size
operator|)
condition|)
return|return
name|so
operator|->
name|name
return|;
comment|/* Nope, keep looking... */
name|so
operator|=
name|so
operator|->
name|next
expr_stmt|;
block|}
comment|/* No, we couldn't prove that the address is within a shlib. */
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* We are killing the inferior and restarting the program.  */
end_comment

begin_function
name|void
name|pa64_solib_restart
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|so_list
modifier|*
name|sl
init|=
name|so_list_head
decl_stmt|;
comment|/* Before the shlib info vanishes, use it to disable any breakpoints      that may still be active in those shlibs.  */
name|disable_breakpoints_in_shlibs
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Discard all the shlib descriptors.  */
while|while
condition|(
name|sl
condition|)
block|{
name|struct
name|so_list
modifier|*
name|next_sl
init|=
name|sl
operator|->
name|next
decl_stmt|;
name|xfree
argument_list|(
name|sl
argument_list|)
expr_stmt|;
name|sl
operator|=
name|next_sl
expr_stmt|;
block|}
name|so_list_head
operator|=
name|NULL
expr_stmt|;
name|pa64_solib_total_st_size
operator|=
operator|(
name|LONGEST
operator|)
literal|0
expr_stmt|;
name|pa64_solib_st_size_threshold_exceeded
operator|=
literal|0
expr_stmt|;
name|dld_cache
operator|.
name|is_valid
operator|=
literal|0
expr_stmt|;
name|dld_cache
operator|.
name|have_read_dld_descriptor
operator|=
literal|0
expr_stmt|;
name|dld_cache
operator|.
name|dld_flags_addr
operator|=
literal|0
expr_stmt|;
name|dld_cache
operator|.
name|load_map
operator|=
literal|0
expr_stmt|;
name|dld_cache
operator|.
name|load_map_addr
operator|=
literal|0
expr_stmt|;
name|dld_cache
operator|.
name|dld_desc
operator|.
name|data_base
operator|=
literal|0
expr_stmt|;
name|dld_cache
operator|.
name|dld_flags
operator|=
literal|0
expr_stmt|;
name|dld_cache
operator|.
name|dyninfo_sect
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_pa64_solib
parameter_list|(
name|void
parameter_list|)
block|{
name|add_com
argument_list|(
literal|"sharedlibrary"
argument_list|,
name|class_files
argument_list|,
name|pa64_solib_sharedlibrary_command
argument_list|,
literal|"Load shared object library symbols for files matching REGEXP."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"sharedlibrary"
argument_list|,
name|pa64_sharedlibrary_info_command
argument_list|,
literal|"Status of loaded shared object libraries."
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"auto-solib-add"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|auto_solib_add
argument_list|,
literal|"Set autoloading of shared library symbols.\n\ If \"on\", symbols from all shared object libraries will be loaded\n\ automatically when the inferior begins execution, when the dynamic linker\n\ informs gdb that a new library has been loaded, or when attaching to the\n\ inferior.  Otherwise, symbols must be loaded manually, using `sharedlibrary'."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"auto-solib-limit"
argument_list|,
name|class_support
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|auto_solib_limit
argument_list|,
literal|"Set threshold (in Mb) for autoloading shared library symbols.\n\ When shared library autoloading is enabled, new libraries will be loaded\n\ only until the total size of shared library symbols exceeds this\n\ threshold in megabytes.  Is ignored when using `sharedlibrary'."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
comment|/* ??rehrauer: On HP-UX, the kernel parameter MAXDSIZ limits how      much data space a process can use.  We ought to be reading      MAXDSIZ and setting auto_solib_limit to some large fraction of      that value.  If not that, we maybe ought to be setting it smaller      than the default for MAXDSIZ (that being 64Mb, I believe).      However, [1] this threshold is only crudely approximated rather      than actually measured, and [2] 50 Mbytes is too small for      debugging gdb itself.  Thus, the arbitrary 100 figure.  */
name|auto_solib_limit
operator|=
literal|100
expr_stmt|;
comment|/* Megabytes */
name|pa64_solib_restart
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get some HPUX-specific data from a shared lib.  */
end_comment

begin_function
name|CORE_ADDR
name|so_lib_thread_start_addr
parameter_list|(
name|struct
name|so_list
modifier|*
name|so
parameter_list|)
block|{
return|return
name|so
operator|->
name|pa64_solib_desc
operator|.
name|tls_start_addr
return|;
block|}
end_function

begin_comment
comment|/* Read the dynamic linker's internal shared library descriptor.     This must happen after dld starts running, so we can't do it in    read_dynamic_info.  Record the fact that we have loaded the    descriptor.  If the library is archive bound, then return zero, else    return nonzero.  */
end_comment

begin_function
specifier|static
name|int
name|read_dld_descriptor
parameter_list|(
name|struct
name|target_ops
modifier|*
name|target
parameter_list|,
name|int
name|readsyms
parameter_list|)
block|{
name|char
modifier|*
name|dll_path
decl_stmt|;
name|asection
modifier|*
name|dyninfo_sect
decl_stmt|;
comment|/* If necessary call read_dynamic_info to extract the contents of the      .dynamic section from the shared library.  */
if|if
condition|(
operator|!
name|dld_cache
operator|.
name|is_valid
condition|)
block|{
if|if
condition|(
name|symfile_objfile
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"No object file symbols."
argument_list|)
expr_stmt|;
name|dyninfo_sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|symfile_objfile
operator|->
name|obfd
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dyninfo_sect
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|read_dynamic_info
argument_list|(
name|dyninfo_sect
argument_list|,
operator|&
name|dld_cache
argument_list|)
condition|)
name|error
argument_list|(
literal|"Unable to read in .dynamic section information."
argument_list|)
expr_stmt|;
block|}
comment|/* Read the load map pointer.  */
if|if
condition|(
name|target_read_memory
argument_list|(
name|dld_cache
operator|.
name|load_map_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dld_cache
operator|.
name|load_map
argument_list|,
sizeof|sizeof
argument_list|(
name|dld_cache
operator|.
name|load_map
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Error while reading in load map pointer."
argument_list|)
expr_stmt|;
block|}
comment|/* Read in the dld load module descriptor */
if|if
condition|(
name|dlgetmodinfo
argument_list|(
operator|-
literal|1
argument_list|,
operator|&
name|dld_cache
operator|.
name|dld_desc
argument_list|,
sizeof|sizeof
argument_list|(
name|dld_cache
operator|.
name|dld_desc
argument_list|)
argument_list|,
name|pa64_target_read_memory
argument_list|,
literal|0
argument_list|,
name|dld_cache
operator|.
name|load_map
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Error trying to get information about dynamic linker."
argument_list|)
expr_stmt|;
block|}
comment|/* Indicate that we have loaded the dld descriptor.  */
name|dld_cache
operator|.
name|have_read_dld_descriptor
operator|=
literal|1
expr_stmt|;
comment|/* Add dld.sl to the list of known shared libraries so that we can      do unwind, etc.        ?!? This may not be correct.  Consider of dld.sl contains symbols      which are also referenced/defined by the user program or some user      shared library.  We need to make absolutely sure that we do not      pollute the namespace from GDB's point of view.  */
name|dll_path
operator|=
name|dlgetname
argument_list|(
operator|&
name|dld_cache
operator|.
name|dld_desc
argument_list|,
sizeof|sizeof
argument_list|(
name|dld_cache
operator|.
name|dld_desc
argument_list|)
argument_list|,
name|pa64_target_read_memory
argument_list|,
literal|0
argument_list|,
name|dld_cache
operator|.
name|load_map
argument_list|)
expr_stmt|;
name|add_to_solist
argument_list|(
literal|0
argument_list|,
name|dll_path
argument_list|,
name|readsyms
argument_list|,
operator|&
name|dld_cache
operator|.
name|dld_desc
argument_list|,
literal|0
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Read the .dynamic section and extract the information of interest,    which is stored in dld_cache.  The routine elf_locate_base in solib.c     was used as a model for this.  */
end_comment

begin_function
specifier|static
name|int
name|read_dynamic_info
parameter_list|(
name|asection
modifier|*
name|dyninfo_sect
parameter_list|,
name|dld_cache_t
modifier|*
name|dld_cache_p
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|bufend
decl_stmt|;
name|CORE_ADDR
name|dyninfo_addr
decl_stmt|;
name|int
name|dyninfo_sect_size
decl_stmt|;
name|CORE_ADDR
name|entry_addr
decl_stmt|;
comment|/* Read in .dynamic section, silently ignore errors.  */
name|dyninfo_addr
operator|=
name|bfd_section_vma
argument_list|(
name|symfile_objfile
operator|->
name|obfd
argument_list|,
name|dyninfo_sect
argument_list|)
expr_stmt|;
name|dyninfo_sect_size
operator|=
name|bfd_section_size
argument_list|(
name|exec_bfd
argument_list|,
name|dyninfo_sect
argument_list|)
expr_stmt|;
name|buf
operator|=
name|alloca
argument_list|(
name|dyninfo_sect_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|dyninfo_addr
argument_list|,
name|buf
argument_list|,
name|dyninfo_sect_size
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Scan the .dynamic section and record the items of interest.       In particular, DT_HP_DLD_FLAGS */
for|for
control|(
name|bufend
operator|=
name|buf
operator|+
name|dyninfo_sect_size
operator|,
name|entry_addr
operator|=
name|dyninfo_addr
init|;
name|buf
operator|<
name|bufend
condition|;
name|buf
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_Dyn
argument_list|)
operator|,
name|entry_addr
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_Dyn
argument_list|)
control|)
block|{
name|Elf64_Dyn
modifier|*
name|x_dynp
init|=
operator|(
name|Elf64_Dyn
operator|*
operator|)
name|buf
decl_stmt|;
name|Elf64_Sxword
name|dyn_tag
decl_stmt|;
name|CORE_ADDR
name|dyn_ptr
decl_stmt|;
name|char
modifier|*
name|pbuf
decl_stmt|;
name|pbuf
operator|=
name|alloca
argument_list|(
name|TARGET_PTR_BIT
operator|/
name|HOST_CHAR_BIT
argument_list|)
expr_stmt|;
name|dyn_tag
operator|=
name|bfd_h_get_64
argument_list|(
name|symfile_objfile
operator|->
name|obfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
operator|&
name|x_dynp
operator|->
name|d_tag
argument_list|)
expr_stmt|;
comment|/* We can't use a switch here because dyn_tag is 64 bits and HP's 	 lame comiler does not handle 64bit items in switch statements.  */
if|if
condition|(
name|dyn_tag
operator|==
name|DT_NULL
condition|)
break|break;
elseif|else
if|if
condition|(
name|dyn_tag
operator|==
name|DT_HP_DLD_FLAGS
condition|)
block|{
comment|/* Set dld_flags_addr and dld_flags in *dld_cache_p */
name|dld_cache_p
operator|->
name|dld_flags_addr
operator|=
name|entry_addr
operator|+
name|offsetof
argument_list|(
name|Elf64_Dyn
argument_list|,
name|d_un
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|dld_cache_p
operator|->
name|dld_flags_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dld_cache_p
operator|->
name|dld_flags
argument_list|,
sizeof|sizeof
argument_list|(
name|dld_cache_p
operator|->
name|dld_flags
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Error while reading in .dynamic section of the program."
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dyn_tag
operator|==
name|DT_HP_LOAD_MAP
condition|)
block|{
comment|/* Dld will place the address of the load map at load_map_addr 	     after it starts running.  */
if|if
condition|(
name|target_read_memory
argument_list|(
name|entry_addr
operator|+
name|offsetof
argument_list|(
name|Elf64_Dyn
argument_list|,
name|d_un
operator|.
name|d_ptr
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dld_cache_p
operator|->
name|load_map_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|dld_cache_p
operator|->
name|load_map_addr
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Error while reading in .dynamic section of the program."
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* tag is not of interest */
block|}
block|}
comment|/* Record other information and set is_valid to 1. */
name|dld_cache_p
operator|->
name|dyninfo_sect
operator|=
name|dyninfo_sect
expr_stmt|;
comment|/* Verify that we read in required info.  These fields are re-set to zero      in pa64_solib_restart.  */
if|if
condition|(
name|dld_cache_p
operator|->
name|dld_flags_addr
operator|!=
literal|0
operator|&&
name|dld_cache_p
operator|->
name|load_map_addr
operator|!=
literal|0
condition|)
name|dld_cache_p
operator|->
name|is_valid
operator|=
literal|1
expr_stmt|;
else|else
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Wrapper for target_read_memory to make dlgetmodinfo happy.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|pa64_target_read_memory
parameter_list|(
name|void
modifier|*
name|buffer
parameter_list|,
name|CORE_ADDR
name|ptr
parameter_list|,
name|size_t
name|bufsiz
parameter_list|,
name|int
name|ident
parameter_list|)
block|{
if|if
condition|(
name|target_read_memory
argument_list|(
name|ptr
argument_list|,
name|buffer
argument_list|,
name|bufsiz
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|buffer
return|;
block|}
end_function

begin_comment
comment|/* Called from handle_dynlink_load_event and pa64_solib_add to add    a shared library to so_list_head list and possibly to read in the    debug information for the library.       If load_module_desc_p is NULL, then the load module descriptor must    be read from the inferior process at the address load_module_desc_addr.  */
end_comment

begin_function
specifier|static
name|void
name|add_to_solist
parameter_list|(
name|int
name|from_tty
parameter_list|,
name|char
modifier|*
name|dll_path
parameter_list|,
name|int
name|readsyms
parameter_list|,
name|struct
name|load_module_desc
modifier|*
name|load_module_desc_p
parameter_list|,
name|CORE_ADDR
name|load_module_desc_addr
parameter_list|,
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
block|{
name|struct
name|so_list
modifier|*
name|new_so
decl_stmt|,
modifier|*
name|so_list_tail
decl_stmt|;
name|int
name|pa64_solib_st_size_threshhold_exceeded
decl_stmt|;
name|LONGEST
name|st_size
decl_stmt|;
if|if
condition|(
name|symfile_objfile
operator|==
name|NULL
condition|)
return|return;
name|so_list_tail
operator|=
name|so_list_head
expr_stmt|;
comment|/* Find the end of the list of shared objects.  */
while|while
condition|(
name|so_list_tail
operator|&&
name|so_list_tail
operator|->
name|next
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|so_list_tail
operator|->
name|name
argument_list|,
name|dll_path
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|so_list_tail
operator|=
name|so_list_tail
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|so_list_tail
operator|&&
name|strcmp
argument_list|(
name|so_list_tail
operator|->
name|name
argument_list|,
name|dll_path
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* Add the shared library to the so_list_head list */
name|new_so
operator|=
operator|(
expr|struct
name|so_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|so_list
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|new_so
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|so_list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|so_list_head
operator|==
name|NULL
condition|)
block|{
name|so_list_head
operator|=
name|new_so
expr_stmt|;
name|so_list_tail
operator|=
name|new_so
expr_stmt|;
block|}
else|else
block|{
name|so_list_tail
operator|->
name|next
operator|=
name|new_so
expr_stmt|;
name|so_list_tail
operator|=
name|new_so
expr_stmt|;
block|}
comment|/* Initialize the new_so */
if|if
condition|(
name|load_module_desc_p
condition|)
block|{
name|new_so
operator|->
name|pa64_solib_desc
operator|=
operator|*
name|load_module_desc_p
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|target_read_memory
argument_list|(
name|load_module_desc_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|new_so
operator|->
name|pa64_solib_desc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|load_module_desc
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Error while reading in dynamic library %s"
argument_list|,
name|dll_path
argument_list|)
expr_stmt|;
block|}
block|}
name|new_so
operator|->
name|pa64_solib_desc_addr
operator|=
name|load_module_desc_addr
expr_stmt|;
name|new_so
operator|->
name|loaded
operator|=
literal|1
expr_stmt|;
name|new_so
operator|->
name|name
operator|=
name|obsavestring
argument_list|(
name|dll_path
argument_list|,
name|strlen
argument_list|(
name|dll_path
argument_list|)
argument_list|,
operator|&
name|symfile_objfile
operator|->
name|objfile_obstack
argument_list|)
expr_stmt|;
comment|/* If we are not going to load the library, tell the user if we      haven't already and return.  */
name|st_size
operator|=
name|pa64_solib_sizeof_symbol_table
argument_list|(
name|dll_path
argument_list|)
expr_stmt|;
name|pa64_solib_st_size_threshhold_exceeded
operator|=
operator|!
name|from_tty
operator|&&
name|readsyms
operator|&&
operator|(
operator|(
name|st_size
operator|+
name|pa64_solib_total_st_size
operator|)
operator|>
operator|(
name|auto_solib_limit
operator|*
call|(
name|LONGEST
call|)
argument_list|(
literal|1024
operator|*
literal|1024
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|pa64_solib_st_size_threshhold_exceeded
condition|)
block|{
name|pa64_solib_add_solib_objfile
argument_list|(
name|new_so
argument_list|,
name|dll_path
argument_list|,
name|from_tty
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Now read in debug info. */
name|pa64_solib_total_st_size
operator|+=
name|st_size
expr_stmt|;
comment|/* This fills in new_so->objfile, among others. */
name|pa64_solib_load_symbols
argument_list|(
name|new_so
argument_list|,
name|dll_path
argument_list|,
name|from_tty
argument_list|,
literal|0
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*    LOCAL FUNCTION     bfd_lookup_symbol -- lookup the value for a specific symbol     SYNOPSIS     CORE_ADDR bfd_lookup_symbol (bfd *abfd, char *symname)     DESCRIPTION     An expensive way to lookup the value of a single symbol for    bfd's that are only temporary anyway.  This is used by the    shared library support to find the address of the debugger    interface structures in the shared library.     Note that 0 is specifically allowed as an error return (no    such symbol).  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|bfd_lookup_symbol
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|symname
parameter_list|)
block|{
name|unsigned
name|int
name|storage_needed
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbol_table
decl_stmt|;
name|unsigned
name|int
name|number_of_symbols
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
decl_stmt|;
name|CORE_ADDR
name|symaddr
init|=
literal|0
decl_stmt|;
name|storage_needed
operator|=
name|bfd_get_symtab_upper_bound
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|storage_needed
operator|>
literal|0
condition|)
block|{
name|symbol_table
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|storage_needed
argument_list|)
expr_stmt|;
name|back_to
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|symbol_table
argument_list|)
expr_stmt|;
name|number_of_symbols
operator|=
name|bfd_canonicalize_symtab
argument_list|(
name|abfd
argument_list|,
name|symbol_table
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_of_symbols
condition|;
name|i
operator|++
control|)
block|{
name|sym
operator|=
operator|*
name|symbol_table
operator|++
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|sym
operator|->
name|name
argument_list|,
name|symname
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Bfd symbols are section relative. */
name|symaddr
operator|=
name|sym
operator|->
name|value
operator|+
name|sym
operator|->
name|section
operator|->
name|vma
expr_stmt|;
break|break;
block|}
block|}
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|symaddr
operator|)
return|;
block|}
end_function

end_unit

