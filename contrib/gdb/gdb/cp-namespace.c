begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Helper routines for C++ support in GDB.    Copyright 2003, 2004 Free Software Foundation, Inc.     Contributed by David Carlton and by Kealia, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"cp-support.h"
end_include

begin_include
include|#
directive|include
file|"gdb_obstack.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"block.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"dictionary.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_comment
comment|/* When set, the file that we're processing is known to have debugging    info for C++ namespaces.  */
end_comment

begin_comment
comment|/* NOTE: carlton/2004-01-13: No currently released version of GCC (the    latest of which is 3.3.x at the time of this writing) produces this    debug info.  GCC 3.4 should, however.  */
end_comment

begin_decl_stmt
name|unsigned
name|char
name|processing_has_namespace_info
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This contains our best guess as to the name of the current    enclosing namespace(s)/class(es), if any.  For example, if we're    within the method foo() in the following code:      namespace N {       class C { 	void foo () { 	}       };     }     then processing_current_prefix should be set to "N::C".  If    processing_has_namespace_info is false, then this variable might    not be reliable.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|processing_current_prefix
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of using directives that are active in the current file.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|using_direct
modifier|*
name|using_list
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|struct
name|using_direct
modifier|*
name|cp_add_using
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|inner_len
parameter_list|,
name|unsigned
name|int
name|outer_len
parameter_list|,
name|struct
name|using_direct
modifier|*
name|next
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|using_direct
modifier|*
name|cp_copy_usings
parameter_list|(
name|struct
name|using_direct
modifier|*
name|using
parameter_list|,
name|struct
name|obstack
modifier|*
name|obstack
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|symbol
modifier|*
name|lookup_namespace_scope
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|linkage_name
parameter_list|,
specifier|const
name|struct
name|block
modifier|*
name|block
parameter_list|,
specifier|const
name|domain_enum
name|domain
parameter_list|,
name|struct
name|symtab
modifier|*
modifier|*
name|symtab
parameter_list|,
specifier|const
name|char
modifier|*
name|scope
parameter_list|,
name|int
name|scope_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|symbol
modifier|*
name|lookup_symbol_file
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|linkage_name
parameter_list|,
specifier|const
name|struct
name|block
modifier|*
name|block
parameter_list|,
specifier|const
name|domain_enum
name|domain
parameter_list|,
name|struct
name|symtab
modifier|*
modifier|*
name|symtab
parameter_list|,
name|int
name|anonymous_namespace
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|cp_lookup_transparent_type_loop
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|scope
parameter_list|,
name|int
name|scope_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|initialize_namespace_symtab
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|block
modifier|*
name|get_possible_namespace_block
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_namespace_block
parameter_list|(
name|struct
name|symtab
modifier|*
name|symtab
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_possible_namespace_symbols_loop
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|len
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_one_possible_namespace_symbol
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|len
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|symbol
modifier|*
name|lookup_possible_namespace_symbol
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|symtab
modifier|*
modifier|*
name|symtab
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|maintenance_cplus_namespace
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Set up support for dealing with C++ namespace info in the current    symtab.  */
end_comment

begin_function
name|void
name|cp_initialize_namespace
parameter_list|()
block|{
name|processing_has_namespace_info
operator|=
literal|0
expr_stmt|;
name|using_list
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add all the using directives we've gathered to the current symtab.    STATIC_BLOCK should be the symtab's static block; OBSTACK is used    for allocation.  */
end_comment

begin_function
name|void
name|cp_finalize_namespace
parameter_list|(
name|struct
name|block
modifier|*
name|static_block
parameter_list|,
name|struct
name|obstack
modifier|*
name|obstack
parameter_list|)
block|{
if|if
condition|(
name|using_list
operator|!=
name|NULL
condition|)
block|{
name|block_set_using
argument_list|(
name|static_block
argument_list|,
name|cp_copy_usings
argument_list|(
name|using_list
argument_list|,
name|obstack
argument_list|)
argument_list|,
name|obstack
argument_list|)
expr_stmt|;
name|using_list
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Check to see if SYMBOL refers to an object contained within an    anonymous namespace; if so, add an appropriate using directive.  */
end_comment

begin_comment
comment|/* Optimize away strlen ("(anonymous namespace)").  */
end_comment

begin_define
define|#
directive|define
name|ANONYMOUS_NAMESPACE_LEN
value|21
end_define

begin_function
name|void
name|cp_scan_for_anonymous_namespaces
parameter_list|(
specifier|const
name|struct
name|symbol
modifier|*
name|symbol
parameter_list|)
block|{
if|if
condition|(
operator|!
name|processing_has_namespace_info
operator|&&
name|SYMBOL_CPLUS_DEMANGLED_NAME
argument_list|(
name|symbol
argument_list|)
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|SYMBOL_CPLUS_DEMANGLED_NAME
argument_list|(
name|symbol
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|previous_component
decl_stmt|;
name|unsigned
name|int
name|next_component
decl_stmt|;
specifier|const
name|char
modifier|*
name|len
decl_stmt|;
comment|/* Start with a quick-and-dirty check for mention of "(anonymous 	 namespace)".  */
if|if
condition|(
operator|!
name|cp_is_anonymous
argument_list|(
name|name
argument_list|)
condition|)
return|return;
name|previous_component
operator|=
literal|0
expr_stmt|;
name|next_component
operator|=
name|cp_find_first_component
argument_list|(
name|name
operator|+
name|previous_component
argument_list|)
expr_stmt|;
while|while
condition|(
name|name
index|[
name|next_component
index|]
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
operator|(
name|next_component
operator|-
name|previous_component
operator|)
operator|==
name|ANONYMOUS_NAMESPACE_LEN
operator|&&
name|strncmp
argument_list|(
name|name
operator|+
name|previous_component
argument_list|,
literal|"(anonymous namespace)"
argument_list|,
name|ANONYMOUS_NAMESPACE_LEN
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* We've found a component of the name that's an 		 anonymous namespace.  So add symbols in it to the 		 namespace given by the previous component if there is 		 one, or to the global namespace if there isn't.  */
name|cp_add_using_directive
argument_list|(
name|name
argument_list|,
name|previous_component
operator|==
literal|0
condition|?
literal|0
else|:
name|previous_component
operator|-
literal|2
argument_list|,
name|next_component
argument_list|)
expr_stmt|;
block|}
comment|/* The "+ 2" is for the "::".  */
name|previous_component
operator|=
name|next_component
operator|+
literal|2
expr_stmt|;
name|next_component
operator|=
operator|(
name|previous_component
operator|+
name|cp_find_first_component
argument_list|(
name|name
operator|+
name|previous_component
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Add a using directive to using_list.  NAME is the start of a string    that should contain the namespaces we want to add as initial    substrings, OUTER_LENGTH is the end of the outer namespace, and    INNER_LENGTH is the end of the inner namespace.  If the using    directive in question has already been added, don't add it    twice.  */
end_comment

begin_function
name|void
name|cp_add_using_directive
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|outer_length
parameter_list|,
name|unsigned
name|int
name|inner_length
parameter_list|)
block|{
name|struct
name|using_direct
modifier|*
name|current
decl_stmt|;
name|struct
name|using_direct
modifier|*
name|new
decl_stmt|;
comment|/* Has it already been added?  */
for|for
control|(
name|current
operator|=
name|using_list
init|;
name|current
operator|!=
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|current
operator|->
name|inner
argument_list|,
name|name
argument_list|,
name|inner_length
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|strlen
argument_list|(
name|current
operator|->
name|inner
argument_list|)
operator|==
name|inner_length
operator|)
operator|&&
operator|(
name|strlen
argument_list|(
name|current
operator|->
name|outer
argument_list|)
operator|==
name|outer_length
operator|)
condition|)
return|return;
block|}
name|using_list
operator|=
name|cp_add_using
argument_list|(
name|name
argument_list|,
name|inner_length
argument_list|,
name|outer_length
argument_list|,
name|using_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record the namespace that the function defined by SYMBOL was    defined in, if necessary.  BLOCK is the associated block; use    OBSTACK for allocation.  */
end_comment

begin_function
name|void
name|cp_set_block_scope
parameter_list|(
specifier|const
name|struct
name|symbol
modifier|*
name|symbol
parameter_list|,
name|struct
name|block
modifier|*
name|block
parameter_list|,
name|struct
name|obstack
modifier|*
name|obstack
parameter_list|)
block|{
comment|/* Make sure that the name was originally mangled: if not, there      certainly isn't any namespace information to worry about!  */
if|if
condition|(
name|SYMBOL_CPLUS_DEMANGLED_NAME
argument_list|(
name|symbol
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|processing_has_namespace_info
condition|)
block|{
name|block_set_scope
argument_list|(
name|block
argument_list|,
name|obsavestring
argument_list|(
name|processing_current_prefix
argument_list|,
name|strlen
argument_list|(
name|processing_current_prefix
argument_list|)
argument_list|,
name|obstack
argument_list|)
argument_list|,
name|obstack
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Try to figure out the appropriate namespace from the 	     demangled name.  */
comment|/* FIXME: carlton/2003-04-15: If the function in question is 	     a method of a class, the name will actually include the 	     name of the class as well.  This should be harmless, but 	     is a little unfortunate.  */
specifier|const
name|char
modifier|*
name|name
init|=
name|SYMBOL_CPLUS_DEMANGLED_NAME
argument_list|(
name|symbol
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|prefix_len
init|=
name|cp_entire_prefix_len
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|block_set_scope
argument_list|(
name|block
argument_list|,
name|obsavestring
argument_list|(
name|name
argument_list|,
name|prefix_len
argument_list|,
name|obstack
argument_list|)
argument_list|,
name|obstack
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Test whether or not NAMESPACE looks like it mentions an anonymous    namespace; return nonzero if so.  */
end_comment

begin_function
name|int
name|cp_is_anonymous
parameter_list|(
specifier|const
name|char
modifier|*
name|namespace
parameter_list|)
block|{
return|return
operator|(
name|strstr
argument_list|(
name|namespace
argument_list|,
literal|"(anonymous namespace)"
argument_list|)
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Create a new struct using direct whose inner namespace is the    initial substring of NAME of leng INNER_LEN and whose outer    namespace is the initial substring of NAME of length OUTER_LENGTH.    Set its next member in the linked list to NEXT; allocate all memory    using xmalloc.  It copies the strings, so NAME can be a temporary    string.  */
end_comment

begin_function
specifier|static
name|struct
name|using_direct
modifier|*
name|cp_add_using
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|unsigned
name|int
name|inner_len
parameter_list|,
name|unsigned
name|int
name|outer_len
parameter_list|,
name|struct
name|using_direct
modifier|*
name|next
parameter_list|)
block|{
name|struct
name|using_direct
modifier|*
name|retval
decl_stmt|;
name|gdb_assert
argument_list|(
name|outer_len
operator|<
name|inner_len
argument_list|)
expr_stmt|;
name|retval
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|using_direct
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|->
name|inner
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|inner_len
argument_list|)
expr_stmt|;
name|retval
operator|->
name|outer
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|outer_len
argument_list|)
expr_stmt|;
name|retval
operator|->
name|next
operator|=
name|next
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Make a copy of the using directives in the list pointed to by    USING, using OBSTACK to allocate memory.  Free all memory pointed    to by USING via xfree.  */
end_comment

begin_function
specifier|static
name|struct
name|using_direct
modifier|*
name|cp_copy_usings
parameter_list|(
name|struct
name|using_direct
modifier|*
name|using
parameter_list|,
name|struct
name|obstack
modifier|*
name|obstack
parameter_list|)
block|{
if|if
condition|(
name|using
operator|==
name|NULL
condition|)
block|{
return|return
name|NULL
return|;
block|}
else|else
block|{
name|struct
name|using_direct
modifier|*
name|retval
init|=
name|obstack_alloc
argument_list|(
name|obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|using_direct
argument_list|)
argument_list|)
decl_stmt|;
name|retval
operator|->
name|inner
operator|=
name|obsavestring
argument_list|(
name|using
operator|->
name|inner
argument_list|,
name|strlen
argument_list|(
name|using
operator|->
name|inner
argument_list|)
argument_list|,
name|obstack
argument_list|)
expr_stmt|;
name|retval
operator|->
name|outer
operator|=
name|obsavestring
argument_list|(
name|using
operator|->
name|outer
argument_list|,
name|strlen
argument_list|(
name|using
operator|->
name|outer
argument_list|)
argument_list|,
name|obstack
argument_list|)
expr_stmt|;
name|retval
operator|->
name|next
operator|=
name|cp_copy_usings
argument_list|(
name|using
operator|->
name|next
argument_list|,
name|obstack
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|using
operator|->
name|inner
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|using
operator|->
name|outer
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|using
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
block|}
end_function

begin_comment
comment|/* The C++-specific version of name lookup for static and global    names.  This makes sure that names get looked for in all namespaces    that are in scope.  NAME is the natural name of the symbol that    we're looking for, LINKAGE_NAME (which is optional) is its linkage    name, BLOCK is the block that we're searching within, DOMAIN says    what kind of symbols we're looking for, and if SYMTAB is non-NULL,    we should store the symtab where we found the symbol in it.  */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|cp_lookup_symbol_nonlocal
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|linkage_name
parameter_list|,
specifier|const
name|struct
name|block
modifier|*
name|block
parameter_list|,
specifier|const
name|domain_enum
name|domain
parameter_list|,
name|struct
name|symtab
modifier|*
modifier|*
name|symtab
parameter_list|)
block|{
return|return
name|lookup_namespace_scope
argument_list|(
name|name
argument_list|,
name|linkage_name
argument_list|,
name|block
argument_list|,
name|domain
argument_list|,
name|symtab
argument_list|,
name|block_scope
argument_list|(
name|block
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Lookup NAME at namespace scope (or, in C terms, in static and    global variables).  SCOPE is the namespace that the current    function is defined within; only consider namespaces whose length    is at least SCOPE_LEN.  Other arguments are as in    cp_lookup_symbol_nonlocal.     For example, if we're within a function A::B::f and looking for a    symbol x, this will get called with NAME = "x", SCOPE = "A::B", and    SCOPE_LEN = 0.  It then calls itself with NAME and SCOPE the same,    but with SCOPE_LEN = 1.  And then it calls itself with NAME and    SCOPE the same, but with SCOPE_LEN = 4.  This third call looks for    "A::B::x"; if it doesn't find it, then the second call looks for    "A::x", and if that call fails, then the first call looks for    "x".  */
end_comment

begin_function
specifier|static
name|struct
name|symbol
modifier|*
name|lookup_namespace_scope
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|linkage_name
parameter_list|,
specifier|const
name|struct
name|block
modifier|*
name|block
parameter_list|,
specifier|const
name|domain_enum
name|domain
parameter_list|,
name|struct
name|symtab
modifier|*
modifier|*
name|symtab
parameter_list|,
specifier|const
name|char
modifier|*
name|scope
parameter_list|,
name|int
name|scope_len
parameter_list|)
block|{
name|char
modifier|*
name|namespace
decl_stmt|;
if|if
condition|(
name|scope
index|[
name|scope_len
index|]
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Recursively search for names in child namespaces first.  */
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|int
name|new_scope_len
init|=
name|scope_len
decl_stmt|;
comment|/* If the current scope is followed by "::", skip past that.  */
if|if
condition|(
name|new_scope_len
operator|!=
literal|0
condition|)
block|{
name|gdb_assert
argument_list|(
name|scope
index|[
name|new_scope_len
index|]
operator|==
literal|':'
argument_list|)
expr_stmt|;
name|new_scope_len
operator|+=
literal|2
expr_stmt|;
block|}
name|new_scope_len
operator|+=
name|cp_find_first_component
argument_list|(
name|scope
operator|+
name|new_scope_len
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_namespace_scope
argument_list|(
name|name
argument_list|,
name|linkage_name
argument_list|,
name|block
argument_list|,
name|domain
argument_list|,
name|symtab
argument_list|,
name|scope
argument_list|,
name|new_scope_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
return|return
name|sym
return|;
block|}
comment|/* Okay, we didn't find a match in our children, so look for the      name in the current namespace.  */
name|namespace
operator|=
name|alloca
argument_list|(
name|scope_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|namespace
argument_list|,
name|scope
argument_list|,
name|scope_len
argument_list|)
expr_stmt|;
name|namespace
index|[
name|scope_len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|cp_lookup_symbol_namespace
argument_list|(
name|namespace
argument_list|,
name|name
argument_list|,
name|linkage_name
argument_list|,
name|block
argument_list|,
name|domain
argument_list|,
name|symtab
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Look up NAME in the C++ namespace NAMESPACE, applying the using    directives that are active in BLOCK.  Other arguments are as in    cp_lookup_symbol_nonlocal.  */
end_comment

begin_function
name|struct
name|symbol
modifier|*
name|cp_lookup_symbol_namespace
parameter_list|(
specifier|const
name|char
modifier|*
name|namespace
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|linkage_name
parameter_list|,
specifier|const
name|struct
name|block
modifier|*
name|block
parameter_list|,
specifier|const
name|domain_enum
name|domain
parameter_list|,
name|struct
name|symtab
modifier|*
modifier|*
name|symtab
parameter_list|)
block|{
specifier|const
name|struct
name|using_direct
modifier|*
name|current
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
comment|/* First, go through the using directives.  If any of them add new      names to the namespace we're searching in, see if we can find a      match by applying them.  */
for|for
control|(
name|current
operator|=
name|block_using
argument_list|(
name|block
argument_list|)
init|;
name|current
operator|!=
name|NULL
condition|;
name|current
operator|=
name|current
operator|->
name|next
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|namespace
argument_list|,
name|current
operator|->
name|outer
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sym
operator|=
name|cp_lookup_symbol_namespace
argument_list|(
name|current
operator|->
name|inner
argument_list|,
name|name
argument_list|,
name|linkage_name
argument_list|,
name|block
argument_list|,
name|domain
argument_list|,
name|symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
return|return
name|sym
return|;
block|}
block|}
comment|/* We didn't find anything by applying any of the using directives      that are still applicable; so let's see if we've got a match      using the current namespace.  */
if|if
condition|(
name|namespace
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
return|return
name|lookup_symbol_file
argument_list|(
name|name
argument_list|,
name|linkage_name
argument_list|,
name|block
argument_list|,
name|domain
argument_list|,
name|symtab
argument_list|,
literal|0
argument_list|)
return|;
block|}
else|else
block|{
name|char
modifier|*
name|concatenated_name
init|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|namespace
argument_list|)
operator|+
literal|2
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|concatenated_name
argument_list|,
name|namespace
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|concatenated_name
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|concatenated_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|sym
operator|=
name|lookup_symbol_file
argument_list|(
name|concatenated_name
argument_list|,
name|linkage_name
argument_list|,
name|block
argument_list|,
name|domain
argument_list|,
name|symtab
argument_list|,
name|cp_is_anonymous
argument_list|(
name|namespace
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|sym
return|;
block|}
block|}
end_function

begin_comment
comment|/* Look up NAME in BLOCK's static block and in global blocks.  If    ANONYMOUS_NAMESPACE is nonzero, the symbol in question is located    within an anonymous namespace.  Other arguments are as in    cp_lookup_symbol_nonlocal.  */
end_comment

begin_function
specifier|static
name|struct
name|symbol
modifier|*
name|lookup_symbol_file
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|linkage_name
parameter_list|,
specifier|const
name|struct
name|block
modifier|*
name|block
parameter_list|,
specifier|const
name|domain_enum
name|domain
parameter_list|,
name|struct
name|symtab
modifier|*
modifier|*
name|symtab
parameter_list|,
name|int
name|anonymous_namespace
parameter_list|)
block|{
name|struct
name|symbol
modifier|*
name|sym
init|=
name|NULL
decl_stmt|;
name|sym
operator|=
name|lookup_symbol_static
argument_list|(
name|name
argument_list|,
name|linkage_name
argument_list|,
name|block
argument_list|,
name|domain
argument_list|,
name|symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
return|return
name|sym
return|;
if|if
condition|(
name|anonymous_namespace
condition|)
block|{
comment|/* Symbols defined in anonymous namespaces have external linkage 	 but should be treated as local to a single file nonetheless. 	 So we only search the current file's global block.  */
specifier|const
name|struct
name|block
modifier|*
name|global_block
init|=
name|block_global_block
argument_list|(
name|block
argument_list|)
decl_stmt|;
if|if
condition|(
name|global_block
operator|!=
name|NULL
condition|)
name|sym
operator|=
name|lookup_symbol_aux_block
argument_list|(
name|name
argument_list|,
name|linkage_name
argument_list|,
name|global_block
argument_list|,
name|domain
argument_list|,
name|symtab
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sym
operator|=
name|lookup_symbol_global
argument_list|(
name|name
argument_list|,
name|linkage_name
argument_list|,
name|domain
argument_list|,
name|symtab
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
return|return
name|sym
return|;
comment|/* Now call "lookup_possible_namespace_symbol".  Symbols in here      claim to be associated to namespaces, but this claim might be      incorrect: the names in question might actually correspond to      classes instead of namespaces.  But if they correspond to      classes, then we should have found a match for them above.  So if      we find them now, they should be genuine.  */
comment|/* FIXME: carlton/2003-06-12: This is a hack and should eventually      be deleted: see comments below.  */
if|if
condition|(
name|domain
operator|==
name|VAR_DOMAIN
condition|)
block|{
name|sym
operator|=
name|lookup_possible_namespace_symbol
argument_list|(
name|name
argument_list|,
name|symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
return|return
name|sym
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Look up a type named NESTED_NAME that is nested inside the C++    class or namespace given by PARENT_TYPE, from within the context    given by BLOCK.  Return NULL if there is no such nested type.  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|cp_lookup_nested_type
parameter_list|(
name|struct
name|type
modifier|*
name|parent_type
parameter_list|,
specifier|const
name|char
modifier|*
name|nested_name
parameter_list|,
specifier|const
name|struct
name|block
modifier|*
name|block
parameter_list|)
block|{
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|parent_type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_STRUCT
case|:
case|case
name|TYPE_CODE_NAMESPACE
case|:
block|{
comment|/* NOTE: carlton/2003-11-10: We don't treat C++ class members 	   of classes like, say, data or function members.  Instead, 	   they're just represented by symbols whose names are 	   qualified by the name of the surrounding class.  This is 	   just like members of namespaces; in particular, 	   lookup_symbol_namespace works when looking them up.  */
specifier|const
name|char
modifier|*
name|parent_name
init|=
name|TYPE_TAG_NAME
argument_list|(
name|parent_type
argument_list|)
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
init|=
name|cp_lookup_symbol_namespace
argument_list|(
name|parent_name
argument_list|,
name|nested_name
argument_list|,
name|NULL
argument_list|,
name|block
argument_list|,
name|VAR_DOMAIN
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
operator|||
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|!=
name|LOC_TYPEDEF
condition|)
return|return
name|NULL
return|;
else|else
return|return
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
return|;
block|}
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"cp_lookup_nested_type called on a non-aggregate type."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The C++-version of lookup_transparent_type.  */
end_comment

begin_comment
comment|/* FIXME: carlton/2004-01-16: The problem that this is trying to    address is that, unfortunately, sometimes NAME is wrong: it may not    include the name of namespaces enclosing the type in question.    lookup_transparent_type gets called when the the type in question    is a declaration, and we're trying to find its definition; but, for    declarations, our type name deduction mechanism doesn't work.    There's nothing we can do to fix this in general, I think, in the    absence of debug information about namespaces (I've filed PR    gdb/1511 about this); until such debug information becomes more    prevalent, one heuristic which sometimes looks is to search for the    definition in namespaces containing the current namespace.     We should delete this functions once the appropriate debug    information becomes more widespread.  (GCC 3.4 will be the first    released version of GCC with such information.)  */
end_comment

begin_function
name|struct
name|type
modifier|*
name|cp_lookup_transparent_type
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
comment|/* First, try the honest way of looking up the definition.  */
name|struct
name|type
modifier|*
name|t
init|=
name|basic_lookup_transparent_type
argument_list|(
name|name
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|scope
decl_stmt|;
if|if
condition|(
name|t
operator|!=
name|NULL
condition|)
return|return
name|t
return|;
comment|/* If that doesn't work and we're within a namespace, look there      instead.  */
name|scope
operator|=
name|block_scope
argument_list|(
name|get_selected_block
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|scope
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
return|return
name|cp_lookup_transparent_type_loop
argument_list|(
name|name
argument_list|,
name|scope
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Lookup the the type definition associated to NAME in    namespaces/classes containing SCOPE whose name is strictly longer    than LENGTH.  LENGTH must be the index of the start of a    component of SCOPE.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|cp_lookup_transparent_type_loop
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|scope
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|int
name|scope_length
init|=
name|length
operator|+
name|cp_find_first_component
argument_list|(
name|scope
operator|+
name|length
argument_list|)
decl_stmt|;
name|char
modifier|*
name|full_name
decl_stmt|;
comment|/* If the current scope is followed by "::", look in the next      component.  */
if|if
condition|(
name|scope
index|[
name|scope_length
index|]
operator|==
literal|':'
condition|)
block|{
name|struct
name|type
modifier|*
name|retval
init|=
name|cp_lookup_transparent_type_loop
argument_list|(
name|name
argument_list|,
name|scope
argument_list|,
name|scope_length
operator|+
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|retval
operator|!=
name|NULL
condition|)
return|return
name|retval
return|;
block|}
name|full_name
operator|=
name|alloca
argument_list|(
name|scope_length
operator|+
literal|2
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|full_name
argument_list|,
name|scope
argument_list|,
name|scope_length
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|full_name
operator|+
name|scope_length
argument_list|,
literal|"::"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|full_name
operator|+
name|scope_length
operator|+
literal|2
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|basic_lookup_transparent_type
argument_list|(
name|full_name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Now come functions for dealing with symbols associated to    namespaces.  (They're used to store the namespaces themselves, not    objects that live in the namespaces.)  These symbols come in two    varieties: if we run into a DW_TAG_namespace DIE, then we know that    we have a namespace, so dwarf2read.c creates a symbol for it just    like normal.  But, unfortunately, versions of GCC through at least    3.3 don't generate those DIE's.  Our solution is to try to guess    their existence by looking at demangled names.  This might cause us    to misidentify classes as namespaces, however.  So we put those    symbols in a special block (one per objfile), and we only search    that block as a last resort.  */
end_comment

begin_comment
comment|/* FIXME: carlton/2003-06-12: Once versions of GCC that generate    DW_TAG_namespace have been out for a year or two, we should get rid    of all of this "possible namespace" nonsense.  */
end_comment

begin_comment
comment|/* Allocate everything necessary for the possible namespace block    associated to OBJFILE.  */
end_comment

begin_function
specifier|static
name|void
name|initialize_namespace_symtab
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|struct
name|symtab
modifier|*
name|namespace_symtab
decl_stmt|;
name|struct
name|blockvector
modifier|*
name|bv
decl_stmt|;
name|struct
name|block
modifier|*
name|bl
decl_stmt|;
name|namespace_symtab
operator|=
name|allocate_symtab
argument_list|(
literal|"<<C++-namespaces>>"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|namespace_symtab
operator|->
name|language
operator|=
name|language_cplus
expr_stmt|;
name|namespace_symtab
operator|->
name|free_code
operator|=
name|free_nothing
expr_stmt|;
name|namespace_symtab
operator|->
name|dirname
operator|=
name|NULL
expr_stmt|;
name|bv
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|blockvector
argument_list|)
operator|+
name|FIRST_LOCAL_BLOCK
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|block
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|BLOCKVECTOR_NBLOCKS
argument_list|(
name|bv
argument_list|)
operator|=
name|FIRST_LOCAL_BLOCK
operator|+
literal|1
expr_stmt|;
name|BLOCKVECTOR
argument_list|(
name|namespace_symtab
argument_list|)
operator|=
name|bv
expr_stmt|;
comment|/* Allocate empty GLOBAL_BLOCK and STATIC_BLOCK. */
name|bl
operator|=
name|allocate_block
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|)
expr_stmt|;
name|BLOCK_DICT
argument_list|(
name|bl
argument_list|)
operator|=
name|dict_create_linear
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|GLOBAL_BLOCK
argument_list|)
operator|=
name|bl
expr_stmt|;
name|bl
operator|=
name|allocate_block
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|)
expr_stmt|;
name|BLOCK_DICT
argument_list|(
name|bl
argument_list|)
operator|=
name|dict_create_linear
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|STATIC_BLOCK
argument_list|)
operator|=
name|bl
expr_stmt|;
comment|/* Allocate the possible namespace block; we put it where the first      local block will live, though I don't think there's any need to      pretend that it's actually a local block (e.g. by setting      BLOCK_SUPERBLOCK appropriately).  We don't use the global or      static block because we don't want it searched during the normal      search of all global/static blocks in lookup_symbol: we only want      it used as a last resort.  */
comment|/* NOTE: carlton/2003-09-11: I considered not associating the fake      symbols to a block/symtab at all.  But that would cause problems      with lookup_symbol's SYMTAB argument and with block_found, so      having a symtab/block for this purpose seems like the best      solution for now.  */
name|bl
operator|=
name|allocate_block
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|)
expr_stmt|;
name|BLOCK_DICT
argument_list|(
name|bl
argument_list|)
operator|=
name|dict_create_hashed_expandable
argument_list|()
expr_stmt|;
name|BLOCKVECTOR_BLOCK
argument_list|(
name|bv
argument_list|,
name|FIRST_LOCAL_BLOCK
argument_list|)
operator|=
name|bl
expr_stmt|;
name|namespace_symtab
operator|->
name|free_func
operator|=
name|free_namespace_block
expr_stmt|;
name|objfile
operator|->
name|cp_namespace_symtab
operator|=
name|namespace_symtab
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Locate the possible namespace block associated to OBJFILE,    allocating it if necessary.  */
end_comment

begin_function
specifier|static
name|struct
name|block
modifier|*
name|get_possible_namespace_block
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
if|if
condition|(
name|objfile
operator|->
name|cp_namespace_symtab
operator|==
name|NULL
condition|)
name|initialize_namespace_symtab
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
return|return
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|objfile
operator|->
name|cp_namespace_symtab
argument_list|)
argument_list|,
name|FIRST_LOCAL_BLOCK
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Free the dictionary associated to the possible namespace block.  */
end_comment

begin_function
specifier|static
name|void
name|free_namespace_block
parameter_list|(
name|struct
name|symtab
modifier|*
name|symtab
parameter_list|)
block|{
name|struct
name|block
modifier|*
name|possible_namespace_block
decl_stmt|;
name|possible_namespace_block
operator|=
name|BLOCKVECTOR_BLOCK
argument_list|(
name|BLOCKVECTOR
argument_list|(
name|symtab
argument_list|)
argument_list|,
name|FIRST_LOCAL_BLOCK
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|possible_namespace_block
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dict_free
argument_list|(
name|BLOCK_DICT
argument_list|(
name|possible_namespace_block
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Ensure that there are symbols in the possible namespace block    associated to OBJFILE for all initial substrings of NAME that look    like namespaces or classes.  NAME should end in a member variable:    it shouldn't consist solely of namespaces.  */
end_comment

begin_function
name|void
name|cp_check_possible_namespace_symbols
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|check_possible_namespace_symbols_loop
argument_list|(
name|name
argument_list|,
name|cp_find_first_component
argument_list|(
name|name
argument_list|)
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is a helper loop for cp_check_possible_namespace_symbols; it    ensures that there are symbols in the possible namespace block    associated to OBJFILE for all namespaces that are initial    substrings of NAME of length at least LEN.  It returns 1 if a    previous loop had already created the shortest such symbol and 0    otherwise.     This function assumes that if there is already a symbol associated    to a substring of NAME of a given length, then there are already    symbols associated to all substrings of NAME whose length is less    than that length.  So if cp_check_possible_namespace_symbols has    been called once with argument "A::B::C::member", then that will    create symbols "A", "A::B", and "A::B::C".  If it is then later    called with argument "A::B::D::member", then the new call will    generate a new symbol for "A::B::D", but once it sees that "A::B"    has already been created, it doesn't bother checking to see if "A"    has also been created.  */
end_comment

begin_function
specifier|static
name|int
name|check_possible_namespace_symbols_loop
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|len
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
if|if
condition|(
name|name
index|[
name|len
index|]
operator|==
literal|':'
condition|)
block|{
name|int
name|done
decl_stmt|;
name|int
name|next_len
init|=
name|len
operator|+
literal|2
decl_stmt|;
name|next_len
operator|+=
name|cp_find_first_component
argument_list|(
name|name
operator|+
name|next_len
argument_list|)
expr_stmt|;
name|done
operator|=
name|check_possible_namespace_symbols_loop
argument_list|(
name|name
argument_list|,
name|next_len
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|done
condition|)
name|done
operator|=
name|check_one_possible_namespace_symbol
argument_list|(
name|name
argument_list|,
name|len
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
return|return
name|done
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Check to see if there's already a possible namespace symbol in    OBJFILE whose name is the initial substring of NAME of length LEN.    If not, create one and return 0; otherwise, return 1.  */
end_comment

begin_function
specifier|static
name|int
name|check_one_possible_namespace_symbol
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|len
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|struct
name|block
modifier|*
name|block
init|=
name|get_possible_namespace_block
argument_list|(
name|objfile
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name_copy
init|=
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|memcpy
argument_list|(
name|name_copy
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|name_copy
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|block
argument_list|,
name|name_copy
argument_list|,
name|NULL
argument_list|,
name|VAR_DOMAIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|name_copy
operator|=
name|obsavestring
argument_list|(
name|name
argument_list|,
name|len
argument_list|,
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|)
expr_stmt|;
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_NAMESPACE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|name_copy
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|sym
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|objfile_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_LANGUAGE
argument_list|(
name|sym
argument_list|)
operator|=
name|language_cplus
expr_stmt|;
name|SYMBOL_SET_NAMES
argument_list|(
name|sym
argument_list|,
name|name_copy
argument_list|,
name|len
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_TYPEDEF
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|type
expr_stmt|;
name|SYMBOL_DOMAIN
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_DOMAIN
expr_stmt|;
name|dict_add_symbol
argument_list|(
name|BLOCK_DICT
argument_list|(
name|block
argument_list|)
argument_list|,
name|sym
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Look for a symbol named NAME in all the possible namespace blocks.    If one is found, return it; if SYMTAB is non-NULL, set *SYMTAB to    equal the symtab where it was found.  */
end_comment

begin_function
specifier|static
name|struct
name|symbol
modifier|*
name|lookup_possible_namespace_symbol
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|symtab
modifier|*
modifier|*
name|symtab
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|ALL_OBJFILES
argument_list|(
argument|objfile
argument_list|)
block|{
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|sym
operator|=
name|lookup_block_symbol
argument_list|(
name|get_possible_namespace_block
argument_list|(
name|objfile
argument_list|)
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|VAR_DOMAIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
operator|*
name|symtab
operator|=
name|objfile
operator|->
name|cp_namespace_symtab
expr_stmt|;
return|return
name|sym
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Print out all the possible namespace symbols.  */
end_comment

begin_function
specifier|static
name|void
name|maintenance_cplus_namespace
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|printf_unfiltered
argument_list|(
literal|"Possible namespaces:\n"
argument_list|)
expr_stmt|;
name|ALL_OBJFILES
argument_list|(
argument|objfile
argument_list|)
block|{
name|struct
name|dict_iterator
name|iter
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|ALL_BLOCK_SYMBOLS
argument_list|(
argument|get_possible_namespace_block (objfile)
argument_list|,
argument|iter
argument_list|,
argument|sym
argument_list|)
block|{
name|printf_unfiltered
argument_list|(
literal|"%s\n"
argument_list|,
name|SYMBOL_PRINT_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|_initialize_cp_namespace
parameter_list|(
name|void
parameter_list|)
block|{
name|add_cmd
argument_list|(
literal|"namespace"
argument_list|,
name|class_maintenance
argument_list|,
name|maintenance_cplus_namespace
argument_list|,
literal|"Print the list of possible C++ namespaces."
argument_list|,
operator|&
name|maint_cplus_cmd_list
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

