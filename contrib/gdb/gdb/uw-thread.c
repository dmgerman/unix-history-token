begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Low level interface for debugging UnixWare user-mode threads for    GDB, the GNU debugger.     Copyright 1999, 2000, 2001 Free Software Foundation, Inc.    Written by Nick Duffek<nsd@cygnus.com>.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Like many systems, UnixWare implements two classes of threads:    kernel-mode threads, which are scheduled by the kernel; and    user-mode threads, which are scheduled by a library.  UnixWare    calls these two classes lightweight processes (LWPs) and threads,    respectively.     This module deals with user-mode threads.  It calls procfs_ops    functions to deal with LWPs and processes and core_ops functions to    deal with core files.     As of this writing, the user-mode thread debugging interface is not    documented beyond the comments in<thread.h>.  The following    description has been gleaned from experience and from information    provided by SCO.     libthread.so, against which all UnixWare user-mode thread programs    link, provides a global thread_debug structure named _thr_debug.    It has three fields:       (1) thr_map is a pointer to a pointer to an element of a 	 thread_map ring.  A thread_map contains a single thread's id 	 number, state, LWP pointer, recent register state, and other 	 useful information.       (2) thr_brk is a pointer to a stub function that libthread.so 	 calls when it changes a thread's state, e.g. by creating it, 	 switching it to an LWP, or causing it to exit.       (3) thr_debug_on controls whether libthread.so calls thr_brk().     Debuggers are able to track thread activity by setting a private    breakpoint on thr_brk() and setting thr_debug_on to 1.     thr_brk() receives two arguments:       (1) a pointer to a thread_map describing the thread being 	 changed; and       (2) an enum thread_change specifying one of the following 	 changes:  	 invalid		 unknown 	 thread_create		 thread has just been created 	 thread_exit		 thread has just exited 	 switch_begin		 thread will be switched to an LWP 	 switch_complete	 thread has been switched to an LWP 	 cancel_complete	 thread wasn't switched to an LWP 	 thread_suspend		 thread has been thr_suspend()ed 	 thread_suspend_pending	 thread will be thr_suspend()ed 	 thread_continue	 thread has been thr_continue()d     The thread_map argument to thr_brk() is NULL under the following    circumstances:       - The main thread is being acted upon.  The main thread always        has id 1, so its thread_map is easy to find by scanning through        _thr_debug.thr_map.       - A "switch_complete" change is occurring, which means that the        thread specified in the most recent "switch_begin" change has        moved to an LWP.       - A "cancel_complete" change is occurring, which means that the        thread specified in the most recent "switch_begin" change has        not moved to an LWP after all.       - A spurious "switch_begin" change is occurring after a        "thread_exit" change.     Between switch_begin and switch_complete or cancel_complete, the    affected thread's LWP pointer is not reliable.  It is possible that    other parts of the thread's thread_map are also unreliable during    that time. */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdbthread.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_comment
comment|/*<thread.h> includes<sys/priocntl.h>, which requires boolean_t from<sys/types.h>, which doesn't typedef boolean_t with gcc. */
end_comment

begin_define
define|#
directive|define
name|boolean_t
value|int
end_define

begin_include
include|#
directive|include
file|<thread.h>
end_include

begin_undef
undef|#
directive|undef
name|boolean_t
end_undef

begin_include
include|#
directive|include
file|<synch.h>
end_include

begin_comment
comment|/* for UnixWare 2.x */
end_comment

begin_comment
comment|/* Prototypes for supply_gregset etc. */
end_comment

begin_include
include|#
directive|include
file|"gregset.h"
end_include

begin_comment
comment|/* Offset from SP to first arg on stack at first instruction of a    function.  We provide a default here that's right for most, if not    all, targets that use this file.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SP_ARG0
end_ifndef

begin_define
define|#
directive|define
name|SP_ARG0
value|(1 * 4)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Whether to emit debugging output. */
end_comment

begin_define
define|#
directive|define
name|DEBUG
value|0
end_define

begin_comment
comment|/* Default debugging output file, overridden by envvar UWTHR_DEBUG. */
end_comment

begin_define
define|#
directive|define
name|DEBUG_FILE
value|"/dev/tty"
end_define

begin_comment
comment|/* #if DEBUG, write string S to the debugging output channel. */
end_comment

begin_if
if|#
directive|if
operator|!
name|DEBUG
end_if

begin_define
define|#
directive|define
name|DBG
parameter_list|(
name|fmt_and_args
parameter_list|)
end_define

begin_define
define|#
directive|define
name|DBG2
parameter_list|(
name|fmt_and_args
parameter_list|)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DBG
parameter_list|(
name|fmt_and_args
parameter_list|)
value|dbg fmt_and_args
end_define

begin_define
define|#
directive|define
name|DBG2
parameter_list|(
name|fmt_and_args
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Back end to CALL_BASE() and TRY_BASE(): evaluate CALL, then convert    inferior_ptid to a composite thread/process id. */
end_comment

begin_define
define|#
directive|define
name|CALL_BASE_1
parameter_list|(
name|call
parameter_list|)
define|\
value|do {					\   DBG2(("CALL_BASE(" #call ")"));	\   call;					\   do_cleanups (infpid_cleanup);		\ } while (0)
end_define

begin_comment
comment|/* If inferior_ptid can be converted to a composite lwp/process id, do so,    evaluate base_ops function CALL, and then convert inferior_ptid back to a    composite thread/process id.     Otherwise, issue an error message and return nonlocally. */
end_comment

begin_define
define|#
directive|define
name|CALL_BASE
parameter_list|(
name|call
parameter_list|)
define|\
value|do {					\   if (!lwp_infpid ())			\     error ("uw-thread: no lwp");	\   CALL_BASE_1 (call);			\ } while (0)
end_define

begin_comment
comment|/* Like CALL_BASE(), but instead of returning nonlocally on error, set    *CALLED to whether the inferior_ptid conversion was successful. */
end_comment

begin_define
define|#
directive|define
name|TRY_BASE
parameter_list|(
name|call
parameter_list|,
name|called
parameter_list|)
define|\
value|do {					\   if ((*(called) = lwp_infpid ()))	\     CALL_BASE_1 (call);			\ } while (0)
end_define

begin_comment
comment|/* Information passed by thread_iter() to its callback parameter. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|struct
name|thread_map
name|map
decl_stmt|;
name|__lwp_desc_t
name|lwp
decl_stmt|;
name|CORE_ADDR
name|mapp
decl_stmt|;
block|}
name|iter_t
typedef|;
end_typedef

begin_comment
comment|/* Private thread data for the thread_info struct. */
end_comment

begin_struct
struct|struct
name|private_thread_info
block|{
name|int
name|stable
decl_stmt|;
comment|/* 0 if libthread.so is modifying thread map */
name|int
name|thrid
decl_stmt|;
comment|/* thread id assigned by libthread.so */
name|int
name|lwpid
decl_stmt|;
comment|/* thread's lwp if .stable, 0 means no lwp */
name|CORE_ADDR
name|mapp
decl_stmt|;
comment|/* address of thread's map structure */
block|}
struct|;
end_struct

begin_comment
comment|/* procfs.c's target-specific operations. */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|procfs_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag to prevent procfs.c from starting inferior processes. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|procfs_suppress_run
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This module's target-specific operations. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|target_ops
name|uw_thread_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Copy of the target over which uw_thread_ops is pushed.  This is    more convenient than a pointer to procfs_ops or core_ops, because    they lack current_target's default callbacks. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|target_ops
name|base_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Saved pointer to previous owner of target_new_objfile_hook. */
end_comment

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|target_new_objfile_chain
function_decl|)
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Whether we are debugging a user-space thread program.  This isn't    set until after libthread.so is loaded by the program being    debugged.     Except for module one-time intialization and where otherwise    documented, no functions in this module get called when    !uw_thread_active. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|uw_thread_active
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For efficiency, cache the addresses of libthread.so's _thr_debug    structure, its thr_brk stub function, and the main thread's map. */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|thr_debug_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|thr_brk_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|thr_map_main
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Remember the thread most recently marked as switching.  Necessary because    libthread.so passes null map when calling stub with tc_*_complete. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|thread_info
modifier|*
name|switchto_thread
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cleanup chain for safely restoring inferior_ptid after CALL_BASE. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cleanup
modifier|*
name|infpid_cleanup
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|DEBUG
end_if

begin_comment
comment|/* Helper function for DBG() macro: if printf-style FMT is non-null, format it    with args and display the result on the debugging output channel. */
end_comment

begin_function
specifier|static
name|void
name|dbg
parameter_list|(
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
specifier|static
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|,
name|len
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
if|if
condition|(
operator|!
name|fmt
condition|)
return|return;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|path
operator|=
name|getenv
argument_list|(
literal|"UWTHR_DEBUG"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|path
condition|)
name|path
operator|=
name|DEBUG_FILE
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
literal|0664
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"can't open %s\n"
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsprintf
argument_list|(
name|buf
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
index|[
name|len
index|]
operator|=
literal|'\n'
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Return a string representing composite PID's components. */
end_comment

begin_comment
unit|static char * dbgpid (ptid_t ptid) {   static char *buf, buf1[80], buf2[80];   if (!buf || buf == buf2)     buf = buf1;   else     buf = buf2;    if (PIDGET (ptid)<= 0)     sprintf (buf, "%d", PIDGET (ptid));   else     sprintf (buf, "%s %ld/%d", ISTID (pid) ? "thr" : "lwp", 	     TIDGET (pid), PIDGET (pid));    return buf; }
comment|/* Return a string representing thread state CHANGE. */
end_comment

begin_comment
unit|static char * dbgchange (enum thread_change change) {   switch (change) {   case tc_invalid:			return "invalid";   case tc_thread_create:		return "thread_create";   case tc_thread_exit:			return "thread_exit";   case tc_switch_begin:			return "switch_begin";   case tc_switch_complete:		return "switch_complete";   case tc_cancel_complete:		return "cancel_complete";   case tc_thread_suspend:		return "thread_suspend";   case tc_thread_suspend_pending:	return "thread_suspend_pending";   case tc_thread_continue:		return "thread_continue";   default:				return "unknown";   } }
comment|/* Return a string representing thread STATE. */
end_comment

begin_ifdef
unit|static char * dbgstate (int state) {   switch (state) {   case TS_ONPROC:	return "running";   case TS_SLEEP:	return "sleeping";   case TS_RUNNABLE:	return "runnable";   case TS_ZOMBIE:	return "zombie";   case TS_SUSPENDED:	return "suspended";
ifdef|#
directive|ifdef
name|TS_FORK
end_ifdef

begin_endif
unit|case TS_FORK:		return "forking";
endif|#
directive|endif
end_endif

begin_endif
unit|default:		return "confused";   } }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_comment
comment|/* Read the contents of _thr_debug into *DEBUGP.  Return success. */
end_comment

begin_function
specifier|static
name|int
name|read_thr_debug
parameter_list|(
name|struct
name|thread_debug
modifier|*
name|debugp
parameter_list|)
block|{
return|return
name|base_ops
operator|.
name|to_xfer_memory
argument_list|(
name|thr_debug_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|debugp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|debugp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|base_ops
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read into MAP the contents of the thread map at inferior process address    MAPP.  Return success. */
end_comment

begin_function
specifier|static
name|int
name|read_map
parameter_list|(
name|CORE_ADDR
name|mapp
parameter_list|,
name|struct
name|thread_map
modifier|*
name|map
parameter_list|)
block|{
return|return
name|base_ops
operator|.
name|to_xfer_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|THR_MAP
argument_list|(
name|mapp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|map
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|map
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|base_ops
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read into LWP the contents of the lwp decriptor at inferior process address    LWPP.  Return success. */
end_comment

begin_function
specifier|static
name|int
name|read_lwp
parameter_list|(
name|CORE_ADDR
name|lwpp
parameter_list|,
name|__lwp_desc_t
modifier|*
name|lwp
parameter_list|)
block|{
return|return
name|base_ops
operator|.
name|to_xfer_memory
argument_list|(
name|lwpp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|lwp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lwp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|base_ops
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Iterate through all user threads, applying FUNC(<map>,<lwp>, DATA) until      (a) FUNC returns nonzero,      (b) FUNC has been applied to all threads, or      (c) an error occurs,    where<map> is the thread's struct thread_map and<lwp> if non-null is the    thread's current __lwp_desc_t.     If a call to FUNC returns nonzero, return that value; otherwise, return 0. */
end_comment

begin_function
specifier|static
name|int
name|thread_iter
parameter_list|(
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|iter_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|thread_debug
name|debug
decl_stmt|;
name|CORE_ADDR
name|first
decl_stmt|,
name|mapp
decl_stmt|;
name|iter_t
name|iter
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|read_thr_debug
argument_list|(
operator|&
name|debug
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|base_ops
operator|.
name|to_xfer_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|debug
operator|.
name|thr_map
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mapp
argument_list|,
sizeof|sizeof
argument_list|(
name|mapp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|base_ops
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|mapp
condition|)
return|return
literal|0
return|;
for|for
control|(
name|first
operator|=
name|mapp
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|read_map
argument_list|(
name|mapp
argument_list|,
operator|&
name|iter
operator|.
name|map
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|iter
operator|.
name|map
operator|.
name|thr_lwpp
condition|)
if|if
condition|(
operator|!
name|read_lwp
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|iter
operator|.
name|map
operator|.
name|thr_lwpp
argument_list|,
operator|&
name|iter
operator|.
name|lwp
argument_list|)
condition|)
return|return
literal|0
return|;
name|iter
operator|.
name|mapp
operator|=
name|mapp
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|func
argument_list|(
operator|&
name|iter
argument_list|,
name|data
argument_list|)
operator|)
condition|)
return|return
name|ret
return|;
name|mapp
operator|=
operator|(
name|CORE_ADDR
operator|)
name|iter
operator|.
name|map
operator|.
name|thr_next
expr_stmt|;
if|if
condition|(
name|mapp
operator|==
name|first
condition|)
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Deactivate user-mode thread support. */
end_comment

begin_function
specifier|static
name|void
name|deactivate_uw_thread
parameter_list|(
name|void
parameter_list|)
block|{
name|remove_thread_event_breakpoints
argument_list|()
expr_stmt|;
name|uw_thread_active
operator|=
literal|0
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|uw_thread_ops
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the composite lwp/process id corresponding to composite    id PID.  If PID is a thread with no lwp, return 0. */
end_comment

begin_function
specifier|static
name|ptid_t
name|thr_to_lwp
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
name|struct
name|thread_info
modifier|*
name|info
decl_stmt|;
name|ptid_t
name|lid
decl_stmt|;
if|if
condition|(
operator|!
name|ISTID
argument_list|(
name|ptid
argument_list|)
condition|)
name|lid
operator|=
name|ptid
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|info
operator|=
name|find_thread_pid
argument_list|(
name|ptid
argument_list|)
operator|)
condition|)
name|lid
operator|=
name|null_ptid
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|info
operator|->
name|private
operator|->
name|lwpid
condition|)
name|lid
operator|=
name|null_ptid
expr_stmt|;
else|else
name|lid
operator|=
name|MKLID
argument_list|(
name|PIDGET
argument_list|(
name|ptid
argument_list|)
argument_list|,
name|info
operator|->
name|private
operator|->
name|lwpid
argument_list|)
expr_stmt|;
name|DBG2
argument_list|(
operator|(
literal|"  thr_to_lwp(%s) = %s"
operator|,
name|dbgpid
argument_list|(
name|pid
argument_list|)
operator|,
name|dbgpid
argument_list|(
name|lid
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|lid
return|;
block|}
end_function

begin_comment
comment|/* find_thread_lwp() callback: return whether TP describes a thread    associated with lwp id DATA. */
end_comment

begin_function
specifier|static
name|int
name|find_thread_lwp_callback
parameter_list|(
name|struct
name|thread_info
modifier|*
name|tp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|lwpid
init|=
operator|(
name|int
operator|)
name|data
decl_stmt|;
if|if
condition|(
operator|!
name|ISTID
argument_list|(
name|tp
operator|->
name|ptid
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|tp
operator|->
name|private
operator|->
name|stable
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|lwpid
operator|!=
name|tp
operator|->
name|private
operator|->
name|lwpid
condition|)
return|return
literal|0
return|;
comment|/* match */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* If a thread is associated with lwp id LWPID, return the corresponding    member of the global thread list; otherwise, return null. */
end_comment

begin_function
specifier|static
name|struct
name|thread_info
modifier|*
name|find_thread_lwp
parameter_list|(
name|int
name|lwpid
parameter_list|)
block|{
return|return
name|iterate_over_threads
argument_list|(
name|find_thread_lwp_callback
argument_list|,
operator|(
name|void
operator|*
operator|)
name|lwpid
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the composite thread/process id corresponding to composite    id PID.  If PID is an lwp with no thread, return PID. */
end_comment

begin_function
specifier|static
name|ptid_t
name|lwp_to_thr
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
name|struct
name|thread_info
modifier|*
name|info
decl_stmt|;
name|int
name|lwpid
decl_stmt|;
name|ptid_t
name|tid
init|=
name|ptid
decl_stmt|;
if|if
condition|(
name|ISTID
argument_list|(
name|ptid
argument_list|)
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
operator|!
operator|(
name|lwpid
operator|=
name|LIDGET
argument_list|(
name|ptid
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
operator|!
operator|(
name|info
operator|=
name|find_thread_lwp
argument_list|(
name|lwpid
argument_list|)
operator|)
condition|)
goto|goto
name|done
goto|;
name|tid
operator|=
name|MKTID
argument_list|(
name|PIDGET
argument_list|(
name|ptid
argument_list|)
argument_list|,
name|info
operator|->
name|private
operator|->
name|thrid
argument_list|)
expr_stmt|;
name|done
label|:
name|DBG2
argument_list|(
operator|(
name|ISTID
argument_list|(
name|tid
argument_list|)
condition|?
name|NULL
else|:
literal|"lwp_to_thr: no thr for %s"
operator|,
name|dbgpid
argument_list|(
name|ptid
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|tid
return|;
block|}
end_function

begin_comment
comment|/* do_cleanups() callback: convert inferior_ptid to a composite    thread/process id after having made a procfs call. */
end_comment

begin_function
specifier|static
name|void
name|thr_infpid
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|ptid_t
name|ptid
init|=
name|lwp_to_thr
argument_list|(
name|inferior_ptid
argument_list|)
decl_stmt|;
name|DBG2
argument_list|(
operator|(
literal|" inferior_ptid from procfs: %s => %s"
operator|,
name|dbgpid
argument_list|(
name|inferior_ptid
argument_list|)
operator|,
name|dbgpid
argument_list|(
name|ptid
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|inferior_ptid
operator|=
name|ptid
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If possible, convert inferior_ptid to a composite lwp/process id in    preparation for making a procfs call.  Return success. */
end_comment

begin_function
specifier|static
name|int
name|lwp_infpid
parameter_list|(
name|void
parameter_list|)
block|{
name|ptid_t
name|ptid
init|=
name|thr_to_lwp
argument_list|(
name|inferior_ptid
argument_list|)
decl_stmt|;
name|DBG2
argument_list|(
operator|(
literal|" inferior_ptid to procfs: %s => %s"
operator|,
name|dbgpid
argument_list|(
name|inferior_ptid
argument_list|)
operator|,
name|dbgpid
argument_list|(
name|ptid
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptid_equal
argument_list|(
name|ptid
argument_list|,
name|null_ptid
argument_list|)
condition|)
return|return
literal|0
return|;
name|inferior_ptid
operator|=
name|ptid
expr_stmt|;
name|infpid_cleanup
operator|=
name|make_cleanup
argument_list|(
name|thr_infpid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Add to the global thread list a new user-mode thread with system id THRID,    lwp id LWPID, map address MAPP, and composite thread/process PID. */
end_comment

begin_function
specifier|static
name|void
name|add_thread_uw
parameter_list|(
name|int
name|thrid
parameter_list|,
name|int
name|lwpid
parameter_list|,
name|CORE_ADDR
name|mapp
parameter_list|,
name|ptid_t
name|ptid
parameter_list|)
block|{
name|struct
name|thread_info
modifier|*
name|newthread
decl_stmt|;
if|if
condition|(
operator|(
name|newthread
operator|=
name|add_thread
argument_list|(
name|ptid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"failed to create new thread structure"
argument_list|)
expr_stmt|;
name|newthread
operator|->
name|private
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|private_thread_info
argument_list|)
argument_list|)
expr_stmt|;
name|newthread
operator|->
name|private
operator|->
name|stable
operator|=
literal|1
expr_stmt|;
name|newthread
operator|->
name|private
operator|->
name|thrid
operator|=
name|thrid
expr_stmt|;
name|newthread
operator|->
name|private
operator|->
name|lwpid
operator|=
name|lwpid
expr_stmt|;
name|newthread
operator|->
name|private
operator|->
name|mapp
operator|=
name|mapp
expr_stmt|;
if|if
condition|(
name|target_has_execution
condition|)
name|printf_unfiltered
argument_list|(
literal|"[New %s]\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* notice_threads() and find_main() callback: if the thread list doesn't    already contain the thread described by ITER, add it if it's the main    thread or if !DATA. */
end_comment

begin_function
specifier|static
name|int
name|notice_thread
parameter_list|(
name|iter_t
modifier|*
name|iter
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|thrid
init|=
name|iter
operator|->
name|map
operator|.
name|thr_tid
decl_stmt|;
name|int
name|lwpid
init|=
operator|!
name|iter
operator|->
name|map
operator|.
name|thr_lwpp
condition|?
literal|0
else|:
name|iter
operator|->
name|lwp
operator|.
name|lwp_id
decl_stmt|;
name|ptid_t
name|ptid
init|=
name|MKTID
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|thrid
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|find_thread_pid
argument_list|(
name|ptid
argument_list|)
operator|&&
operator|(
operator|!
name|data
operator|||
name|thrid
operator|==
literal|1
operator|)
condition|)
name|add_thread_uw
argument_list|(
name|thrid
argument_list|,
name|lwpid
argument_list|,
name|iter
operator|->
name|mapp
argument_list|,
name|ptid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Add to the thread list any threads it doesn't already contain. */
end_comment

begin_function
specifier|static
name|void
name|notice_threads
parameter_list|(
name|void
parameter_list|)
block|{
name|thread_iter
argument_list|(
name|notice_thread
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the address of the main thread's map.  On error, return 0. */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|find_main
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|thr_map_main
condition|)
block|{
name|struct
name|thread_info
modifier|*
name|info
decl_stmt|;
name|thread_iter
argument_list|(
name|notice_thread
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|info
operator|=
name|find_thread_pid
argument_list|(
name|MKTID
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
name|thr_map_main
operator|=
name|info
operator|->
name|private
operator|->
name|mapp
expr_stmt|;
block|}
return|return
name|thr_map_main
return|;
block|}
end_function

begin_comment
comment|/* Attach to process specified by ARGS, then initialize for debugging it    and wait for the trace-trap that results from attaching.     This function only gets called with uw_thread_active == 0. */
end_comment

begin_function
specifier|static
name|void
name|uw_thread_attach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|procfs_ops
operator|.
name|to_attach
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
if|if
condition|(
name|uw_thread_active
condition|)
name|thr_infpid
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Detach from the process attached to by uw_thread_attach(). */
end_comment

begin_function
specifier|static
name|void
name|uw_thread_detach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|deactivate_uw_thread
argument_list|()
expr_stmt|;
name|base_ops
operator|.
name|to_detach
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Tell the inferior process to continue running thread PID if>= 0    and all threads otherwise. */
end_comment

begin_function
specifier|static
name|void
name|uw_thread_resume
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|step
parameter_list|,
name|enum
name|target_signal
name|signo
parameter_list|)
block|{
if|if
condition|(
name|PIDGET
argument_list|(
name|ptid
argument_list|)
operator|>
literal|0
condition|)
block|{
name|ptid
operator|=
name|thr_to_lwp
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptid_equal
argument_list|(
name|ptid
argument_list|,
name|null_ptid
argument_list|)
condition|)
name|ptid
operator|=
name|pid_to_ptid
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|CALL_BASE
argument_list|(
name|base_ops
operator|.
name|to_resume
argument_list|(
name|ptid
argument_list|,
name|step
argument_list|,
name|signo
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If the trap we just received from lwp PID was due to a breakpoint    on the libthread.so debugging stub, update this module's state    accordingly. */
end_comment

begin_function
specifier|static
name|void
name|libthread_stub
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
name|CORE_ADDR
name|sp
decl_stmt|,
name|mapp
decl_stmt|,
name|mapp_main
decl_stmt|;
name|enum
name|thread_change
name|change
decl_stmt|;
name|struct
name|thread_map
name|map
decl_stmt|;
name|__lwp_desc_t
name|lwp
decl_stmt|;
name|int
name|lwpid
decl_stmt|;
name|ptid_t
name|tid
init|=
name|null_ptid
decl_stmt|;
name|struct
name|thread_info
modifier|*
name|info
decl_stmt|;
comment|/* Check for stub breakpoint. */
if|if
condition|(
name|read_pc_pid
argument_list|(
name|ptid
argument_list|)
operator|-
name|DECR_PC_AFTER_BREAK
operator|!=
name|thr_brk_addr
condition|)
return|return;
comment|/* Retrieve stub args. */
name|sp
operator|=
name|read_register_pid
argument_list|(
name|SP_REGNUM
argument_list|,
name|ptid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|base_ops
operator|.
name|to_xfer_memory
argument_list|(
name|sp
operator|+
name|SP_ARG0
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mapp
argument_list|,
sizeof|sizeof
argument_list|(
name|mapp
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|base_ops
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
name|base_ops
operator|.
name|to_xfer_memory
argument_list|(
name|sp
operator|+
name|SP_ARG0
operator|+
sizeof|sizeof
argument_list|(
name|mapp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|change
argument_list|,
sizeof|sizeof
argument_list|(
name|change
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|base_ops
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* create_inferior() may not have finished yet, so notice the main      thread to ensure that it's displayed first by add_thread(). */
name|mapp_main
operator|=
name|find_main
argument_list|()
expr_stmt|;
comment|/* Notice thread creation, deletion, or stability change. */
switch|switch
condition|(
name|change
condition|)
block|{
case|case
name|tc_switch_begin
case|:
if|if
condition|(
operator|!
name|mapp
condition|)
comment|/* usually means main thread */
name|mapp
operator|=
name|mapp_main
expr_stmt|;
comment|/* fall through */
case|case
name|tc_thread_create
case|:
case|case
name|tc_thread_exit
case|:
if|if
condition|(
operator|!
name|mapp
condition|)
break|break;
if|if
condition|(
operator|!
name|read_map
argument_list|(
name|mapp
argument_list|,
operator|&
name|map
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|tid
operator|=
name|MKTID
argument_list|(
name|PIDGET
argument_list|(
name|ptid
argument_list|)
argument_list|,
name|map
operator|.
name|thr_tid
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|change
condition|)
block|{
case|case
name|tc_thread_create
case|:
comment|/* new thread */
if|if
condition|(
operator|!
name|map
operator|.
name|thr_lwpp
condition|)
name|lwpid
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|read_lwp
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|map
operator|.
name|thr_lwpp
argument_list|,
operator|&
name|lwp
argument_list|)
condition|)
goto|goto
name|err
goto|;
else|else
name|lwpid
operator|=
name|lwp
operator|.
name|lwp_id
expr_stmt|;
name|add_thread_uw
argument_list|(
name|map
operator|.
name|thr_tid
argument_list|,
name|lwpid
argument_list|,
name|mapp
argument_list|,
name|tid
argument_list|)
expr_stmt|;
break|break;
case|case
name|tc_thread_exit
case|:
comment|/* thread has exited */
name|printf_unfiltered
argument_list|(
literal|"[Exited %s]\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|tid
argument_list|)
argument_list|)
expr_stmt|;
name|delete_thread
argument_list|(
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptid_equal
argument_list|(
name|tid
argument_list|,
name|inferior_ptid
argument_list|)
condition|)
name|inferior_ptid
operator|=
name|ptid
expr_stmt|;
break|break;
case|case
name|tc_switch_begin
case|:
comment|/* lwp is switching threads */
if|if
condition|(
name|switchto_thread
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|!
operator|(
name|switchto_thread
operator|=
name|find_thread_pid
argument_list|(
name|tid
argument_list|)
operator|)
condition|)
goto|goto
name|err
goto|;
name|switchto_thread
operator|->
name|private
operator|->
name|stable
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|tc_switch_complete
case|:
comment|/* lwp has switched threads */
case|case
name|tc_cancel_complete
case|:
comment|/* lwp didn't switch threads */
if|if
condition|(
operator|!
name|switchto_thread
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|change
operator|==
name|tc_switch_complete
condition|)
block|{
comment|/* If switchto_thread is the main thread, then (a) the corresponding 	   tc_switch_begin probably received a null map argument and therefore 	   (b) it may have been a spurious switch following a tc_thread_exit.  	   Therefore, explicitly query the thread's lwp before caching it in 	   its thread list entry. */
if|if
condition|(
operator|!
name|read_map
argument_list|(
name|switchto_thread
operator|->
name|private
operator|->
name|mapp
argument_list|,
operator|&
name|map
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|map
operator|.
name|thr_lwpp
condition|)
block|{
if|if
condition|(
operator|!
name|read_lwp
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|map
operator|.
name|thr_lwpp
argument_list|,
operator|&
name|lwp
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
operator|(
name|info
operator|=
name|find_thread_lwp
argument_list|(
name|lwp
operator|.
name|lwp_id
argument_list|)
operator|)
condition|)
name|info
operator|->
name|private
operator|->
name|lwpid
operator|=
literal|0
expr_stmt|;
name|switchto_thread
operator|->
name|private
operator|->
name|lwpid
operator|=
name|lwp
operator|.
name|lwp_id
expr_stmt|;
block|}
block|}
name|switchto_thread
operator|->
name|private
operator|->
name|stable
operator|=
literal|1
expr_stmt|;
name|switchto_thread
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|tc_invalid
case|:
case|case
name|tc_thread_suspend
case|:
case|case
name|tc_thread_suspend_pending
case|:
case|case
name|tc_thread_continue
case|:
name|err
label|:
name|DBG
argument_list|(
operator|(
literal|"unexpected condition in libthread_stub()"
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|DBG2
argument_list|(
operator|(
literal|"libthread_stub(%s): %s %s %s"
operator|,
name|dbgpid
argument_list|(
name|pid
argument_list|)
operator|,
name|dbgpid
argument_list|(
name|tid
argument_list|)
operator|,
name|dbgchange
argument_list|(
name|change
argument_list|)
operator|,
name|tid
condition|?
name|dbgstate
argument_list|(
name|map
operator|.
name|thr_state
argument_list|)
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wait for thread/lwp/process ID if>= 0 or for any thread otherwise. */
end_comment

begin_function
specifier|static
name|ptid_t
name|uw_thread_wait
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
name|status
parameter_list|)
block|{
if|if
condition|(
name|PIDGET
argument_list|(
name|ptid
argument_list|)
operator|>
literal|0
condition|)
name|ptid
operator|=
name|thr_to_lwp
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
if|if
condition|(
name|PIDGET
argument_list|(
name|ptid
argument_list|)
operator|<=
literal|0
condition|)
name|ptid
operator|=
name|pid_to_ptid
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|CALL_BASE
argument_list|(
name|ptid
operator|=
name|base_ops
operator|.
name|to_wait
argument_list|(
name|ptid
argument_list|,
name|status
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|->
name|kind
operator|==
name|TARGET_WAITKIND_STOPPED
operator|&&
name|status
operator|->
name|value
operator|.
name|sig
operator|==
name|TARGET_SIGNAL_TRAP
condition|)
name|libthread_stub
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
return|return
name|lwp_to_thr
argument_list|(
name|ptid
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Tell gdb about the registers in the thread/lwp/process specified by    inferior_ptid. */
end_comment

begin_function
specifier|static
name|void
name|uw_thread_fetch_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|int
name|called
decl_stmt|;
name|struct
name|thread_info
modifier|*
name|info
decl_stmt|;
name|struct
name|thread_map
name|map
decl_stmt|;
name|TRY_BASE
argument_list|(
name|base_ops
operator|.
name|to_fetch_registers
argument_list|(
name|regno
argument_list|)
argument_list|,
operator|&
name|called
argument_list|)
expr_stmt|;
if|if
condition|(
name|called
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|info
operator|=
name|find_thread_pid
argument_list|(
name|inferior_ptid
argument_list|)
operator|)
condition|)
return|return;
if|if
condition|(
operator|!
name|read_map
argument_list|(
name|info
operator|->
name|private
operator|->
name|mapp
argument_list|,
operator|&
name|map
argument_list|)
condition|)
return|return;
name|supply_gregset
argument_list|(
operator|&
name|map
operator|.
name|thr_ucontext
operator|.
name|uc_mcontext
operator|.
name|gregs
argument_list|)
expr_stmt|;
name|supply_fpregset
argument_list|(
operator|&
name|map
operator|.
name|thr_ucontext
operator|.
name|uc_mcontext
operator|.
name|fpregs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store gdb's current view of the register set into the thread/lwp/process    specified by inferior_ptid. */
end_comment

begin_function
specifier|static
name|void
name|uw_thread_store_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|CALL_BASE
argument_list|(
name|base_ops
operator|.
name|to_store_registers
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Prepare to modify the registers array. */
end_comment

begin_function
specifier|static
name|void
name|uw_thread_prepare_to_store
parameter_list|(
name|void
parameter_list|)
block|{
name|CALL_BASE
argument_list|(
name|base_ops
operator|.
name|to_prepare_to_store
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fork an inferior process and start debugging it.     This function only gets called with uw_thread_active == 0. */
end_comment

begin_function
specifier|static
name|void
name|uw_thread_create_inferior
parameter_list|(
name|char
modifier|*
name|exec_file
parameter_list|,
name|char
modifier|*
name|allargs
parameter_list|,
name|char
modifier|*
modifier|*
name|env
parameter_list|)
block|{
if|if
condition|(
name|uw_thread_active
condition|)
name|deactivate_uw_thread
argument_list|()
expr_stmt|;
name|procfs_ops
operator|.
name|to_create_inferior
argument_list|(
name|exec_file
argument_list|,
name|allargs
argument_list|,
name|env
argument_list|)
expr_stmt|;
if|if
condition|(
name|uw_thread_active
condition|)
block|{
name|find_main
argument_list|()
expr_stmt|;
name|thr_infpid
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Kill and forget about the inferior process. */
end_comment

begin_function
specifier|static
name|void
name|uw_thread_kill
parameter_list|(
name|void
parameter_list|)
block|{
name|base_ops
operator|.
name|to_kill
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clean up after the inferior exits. */
end_comment

begin_function
specifier|static
name|void
name|uw_thread_mourn_inferior
parameter_list|(
name|void
parameter_list|)
block|{
name|deactivate_uw_thread
argument_list|()
expr_stmt|;
name|base_ops
operator|.
name|to_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return whether this module can attach to and run processes.     This function only gets called with uw_thread_active == 0. */
end_comment

begin_function
specifier|static
name|int
name|uw_thread_can_run
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|procfs_suppress_run
return|;
block|}
end_function

begin_comment
comment|/* Return whether thread PID is still valid. */
end_comment

begin_function
specifier|static
name|int
name|uw_thread_alive
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ISTID
argument_list|(
name|ptid
argument_list|)
condition|)
return|return
name|base_ops
operator|.
name|to_thread_alive
argument_list|(
name|ptid
argument_list|)
return|;
comment|/* If it's in the thread list, it's valid, because otherwise      libthread_stub() would have deleted it. */
return|return
name|in_thread_list
argument_list|(
name|ptid
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Add to the thread list any threads and lwps it doesn't already contain. */
end_comment

begin_function
specifier|static
name|void
name|uw_thread_find_new_threads
parameter_list|(
name|void
parameter_list|)
block|{
name|CALL_BASE
argument_list|(
argument|if (base_ops.to_find_new_threads) 	       base_ops.to_find_new_threads ()
argument_list|)
empty_stmt|;
name|notice_threads
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a string for pretty-printing PID in "info threads" output.    This may be called by either procfs.c or by generic gdb. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|uw_thread_pid_to_str
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
define|#
directive|define
name|FMT
value|"Thread %ld"
specifier|static
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
name|FMT
argument_list|)
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|ISTID
argument_list|(
name|ptid
argument_list|)
condition|)
comment|/* core_ops says "process foo", so call procfs_ops explicitly. */
return|return
name|procfs_ops
operator|.
name|to_pid_to_str
argument_list|(
name|ptid
argument_list|)
return|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|FMT
argument_list|,
name|TIDGET
argument_list|(
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|FMT
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* Return a string displaying INFO state information in "info threads"    output. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|uw_extra_thread_info
parameter_list|(
name|struct
name|thread_info
modifier|*
name|info
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|struct
name|thread_map
name|map
decl_stmt|;
name|__lwp_desc_t
name|lwp
decl_stmt|;
name|int
name|lwpid
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
operator|!
name|ISTID
argument_list|(
name|info
operator|->
name|ptid
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|info
operator|->
name|private
operator|->
name|stable
condition|)
return|return
literal|"switching"
return|;
if|if
condition|(
operator|!
name|read_map
argument_list|(
name|info
operator|->
name|private
operator|->
name|mapp
argument_list|,
operator|&
name|map
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|!
name|map
operator|.
name|thr_lwpp
operator|||
operator|!
name|read_lwp
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|map
operator|.
name|thr_lwpp
argument_list|,
operator|&
name|lwp
argument_list|)
condition|)
name|lwpid
operator|=
literal|0
expr_stmt|;
else|else
name|lwpid
operator|=
name|lwp
operator|.
name|lwp_id
expr_stmt|;
switch|switch
condition|(
name|map
operator|.
name|thr_state
condition|)
block|{
case|case
name|TS_ONPROC
case|:
name|name
operator|=
literal|"running"
expr_stmt|;
break|break;
case|case
name|TS_SLEEP
case|:
name|name
operator|=
literal|"sleeping"
expr_stmt|;
break|break;
case|case
name|TS_RUNNABLE
case|:
name|name
operator|=
literal|"runnable"
expr_stmt|;
break|break;
case|case
name|TS_ZOMBIE
case|:
name|name
operator|=
literal|"zombie"
expr_stmt|;
break|break;
case|case
name|TS_SUSPENDED
case|:
name|name
operator|=
literal|"suspended"
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|TS_FORK
case|case
name|TS_FORK
case|:
name|name
operator|=
literal|"forking"
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|name
operator|=
literal|"confused"
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|lwpid
condition|)
return|return
name|name
return|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s, LWP %d"
argument_list|,
name|name
argument_list|,
name|lwpid
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* Check whether libthread.so has just been loaded, and if so, try to    initialize user-space thread debugging support.     libthread.so loading happens while (a) an inferior process is being    started by procfs and (b) a core image is being loaded.     This function often gets called with uw_thread_active == 0. */
end_comment

begin_function
specifier|static
name|void
name|libthread_init
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|ms
decl_stmt|;
name|struct
name|thread_debug
name|debug
decl_stmt|;
name|CORE_ADDR
name|onp
decl_stmt|;
name|struct
name|breakpoint
modifier|*
name|b
decl_stmt|;
name|int
name|one
init|=
literal|1
decl_stmt|;
comment|/* Don't initialize twice. */
if|if
condition|(
name|uw_thread_active
condition|)
return|return;
comment|/* Check whether libthread.so has been loaded. */
if|if
condition|(
operator|!
operator|(
name|ms
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"_thr_debug"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
return|return;
comment|/* Cache _thr_debug's address. */
if|if
condition|(
operator|!
operator|(
name|thr_debug_addr
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|ms
argument_list|)
operator|)
condition|)
return|return;
comment|/* Initialize base_ops.to_xfer_memory(). */
name|base_ops
operator|=
name|current_target
expr_stmt|;
comment|/* Load _thr_debug's current contents. */
if|if
condition|(
operator|!
name|read_thr_debug
argument_list|(
operator|&
name|debug
argument_list|)
condition|)
return|return;
comment|/* User code (e.g. my test programs) may dereference _thr_debug,      making it availble to GDB before shared libs are loaded. */
if|if
condition|(
operator|!
name|debug
operator|.
name|thr_map
condition|)
return|return;
comment|/* libthread.so has been loaded, and the current_target should now      reflect core_ops or procfs_ops. */
name|push_target
argument_list|(
operator|&
name|uw_thread_ops
argument_list|)
expr_stmt|;
comment|/* must precede notice_threads() */
name|uw_thread_active
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|target_has_execution
condition|)
comment|/* Locate threads in core file. */
name|notice_threads
argument_list|()
expr_stmt|;
else|else
block|{
comment|/* Set a breakpoint on the stub function provided by libthread.so. */
name|thr_brk_addr
operator|=
operator|(
name|CORE_ADDR
operator|)
name|debug
operator|.
name|thr_brk
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|b
operator|=
name|create_thread_event_breakpoint
argument_list|(
name|thr_brk_addr
argument_list|)
operator|)
condition|)
goto|goto
name|err
goto|;
comment|/* Activate the stub function. */
name|onp
operator|=
operator|(
name|CORE_ADDR
operator|)
operator|&
operator|(
operator|(
expr|struct
name|thread_debug
operator|*
operator|)
name|thr_debug_addr
operator|)
operator|->
name|thr_debug_on
expr_stmt|;
if|if
condition|(
operator|!
name|base_ops
operator|.
name|to_xfer_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|onp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|one
argument_list|,
sizeof|sizeof
argument_list|(
name|one
argument_list|)
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|base_ops
argument_list|)
condition|)
block|{
name|delete_breakpoint
argument_list|(
name|b
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Prepare for finding the main thread, which doesn't yet exist. */
name|thr_map_main
operator|=
literal|0
expr_stmt|;
block|}
return|return;
name|err
label|:
name|warning
argument_list|(
literal|"uw-thread: unable to initialize user-mode thread debugging\n"
argument_list|)
expr_stmt|;
name|deactivate_uw_thread
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* target_new_objfile_hook callback.     If OBJFILE is non-null, check whether libthread.so was just loaded,    and if so, prepare for user-mode thread debugging.     If OBJFILE is null, libthread.so has gone away, so stop debugging    user-mode threads.     This function often gets called with uw_thread_active == 0. */
end_comment

begin_function
specifier|static
name|void
name|uw_thread_new_objfile
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
if|if
condition|(
name|objfile
condition|)
name|libthread_init
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|uw_thread_active
condition|)
name|deactivate_uw_thread
argument_list|()
expr_stmt|;
if|if
condition|(
name|target_new_objfile_chain
condition|)
name|target_new_objfile_chain
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize uw_thread_ops. */
end_comment

begin_function
specifier|static
name|void
name|init_uw_thread_ops
parameter_list|(
name|void
parameter_list|)
block|{
name|uw_thread_ops
operator|.
name|to_shortname
operator|=
literal|"unixware-threads"
expr_stmt|;
name|uw_thread_ops
operator|.
name|to_longname
operator|=
literal|"UnixWare threads and pthread."
expr_stmt|;
name|uw_thread_ops
operator|.
name|to_doc
operator|=
literal|"UnixWare threads and pthread support."
expr_stmt|;
name|uw_thread_ops
operator|.
name|to_attach
operator|=
name|uw_thread_attach
expr_stmt|;
name|uw_thread_ops
operator|.
name|to_detach
operator|=
name|uw_thread_detach
expr_stmt|;
name|uw_thread_ops
operator|.
name|to_resume
operator|=
name|uw_thread_resume
expr_stmt|;
name|uw_thread_ops
operator|.
name|to_wait
operator|=
name|uw_thread_wait
expr_stmt|;
name|uw_thread_ops
operator|.
name|to_fetch_registers
operator|=
name|uw_thread_fetch_registers
expr_stmt|;
name|uw_thread_ops
operator|.
name|to_store_registers
operator|=
name|uw_thread_store_registers
expr_stmt|;
name|uw_thread_ops
operator|.
name|to_prepare_to_store
operator|=
name|uw_thread_prepare_to_store
expr_stmt|;
name|uw_thread_ops
operator|.
name|to_create_inferior
operator|=
name|uw_thread_create_inferior
expr_stmt|;
name|uw_thread_ops
operator|.
name|to_kill
operator|=
name|uw_thread_kill
expr_stmt|;
name|uw_thread_ops
operator|.
name|to_mourn_inferior
operator|=
name|uw_thread_mourn_inferior
expr_stmt|;
name|uw_thread_ops
operator|.
name|to_can_run
operator|=
name|uw_thread_can_run
expr_stmt|;
name|uw_thread_ops
operator|.
name|to_thread_alive
operator|=
name|uw_thread_alive
expr_stmt|;
name|uw_thread_ops
operator|.
name|to_find_new_threads
operator|=
name|uw_thread_find_new_threads
expr_stmt|;
name|uw_thread_ops
operator|.
name|to_pid_to_str
operator|=
name|uw_thread_pid_to_str
expr_stmt|;
name|uw_thread_ops
operator|.
name|to_extra_thread_info
operator|=
name|uw_extra_thread_info
expr_stmt|;
name|uw_thread_ops
operator|.
name|to_stratum
operator|=
name|thread_stratum
expr_stmt|;
name|uw_thread_ops
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Module startup initialization function, automagically called by    init.c. */
end_comment

begin_function
name|void
name|_initialize_uw_thread
parameter_list|(
name|void
parameter_list|)
block|{
name|init_uw_thread_ops
argument_list|()
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|uw_thread_ops
argument_list|)
expr_stmt|;
name|procfs_suppress_run
operator|=
literal|1
expr_stmt|;
comment|/* Notice when libthread.so gets loaded. */
name|target_new_objfile_chain
operator|=
name|target_new_objfile_hook
expr_stmt|;
name|target_new_objfile_hook
operator|=
name|uw_thread_new_objfile
expr_stmt|;
block|}
end_function

end_unit

