begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target-struct-independent code to start (run) and stop an inferior process.    Copyright 1986, 87, 88, 89, 91, 92, 93, 94, 95, 96, 97, 1998    Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbthread.h"
end_include

begin_include
include|#
directive|include
file|"annotate.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_comment
comment|/* for overlay functions */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_decl_stmt
specifier|static
name|void
name|signals_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sig_print_info
name|PARAMS
argument_list|(
operator|(
expr|enum
name|target_signal
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sig_print_header
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|resume_cleanups
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hook_stop_stub
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_breakpoint_current_contents
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|inferior_ignoring_startup_exec_events
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|inferior_ignoring_leading_exec_events
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HPUXHPPA
end_ifdef

begin_comment
comment|/* wait_for_inferior and normal_stop use this to notify the user    when the inferior stopped in a different thread than it had been    running in. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|switched_from_inferior_pid
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* resume and wait_for_inferior use this to ensure that when    stepping over a hit breakpoint in a threaded application    only the thread that hit the breakpoint is stepped and the    other threads don't continue.  This prevents having another    thread run past the breakpoint while it is temporarily    removed.     This is not thread-specific, so it isn't saved as part of    the infrun state.     Versions of gdb which don't use the "step == this thread steps    and others continue" model but instead use the "step == this    thread steps and others wait" shouldn't do this. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|thread_step_needed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|_initialize_infrun
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* GET_LONGJMP_TARGET returns the PC at which longjmp() will resume the    program.  It needs to examine the jmp_buf argument and extract the PC    from it.  The return value is non-zero on success, zero otherwise. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GET_LONGJMP_TARGET
end_ifndef

begin_define
define|#
directive|define
name|GET_LONGJMP_TARGET
parameter_list|(
name|PC_ADDR
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Some machines have trampoline code that sits between function callers    and the actual functions themselves.  If this machine doesn't have    such things, disable their processing.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SKIP_TRAMPOLINE_CODE
end_ifndef

begin_define
define|#
directive|define
name|SKIP_TRAMPOLINE_CODE
parameter_list|(
name|pc
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Dynamic function trampolines are similar to solib trampolines in that they    are between the caller and the callee.  The difference is that when you    enter a dynamic trampoline, you can't determine the callee's address.  Some    (usually complex) code needs to run in the dynamic trampoline to figure out    the callee's address.  This macro is usually called twice.  First, when we    enter the trampoline (looks like a normal function call at that point).  It    should return the PC of a point within the trampoline where the callee's    address is known.  Second, when we hit the breakpoint, this routine returns    the callee's address.  At that point, things proceed as per a step resume    breakpoint.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DYNAMIC_TRAMPOLINE_NEXTPC
end_ifndef

begin_define
define|#
directive|define
name|DYNAMIC_TRAMPOLINE_NEXTPC
parameter_list|(
name|pc
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* On SVR4 based systems, determining the callee's address is exceedingly    difficult and depends on the implementation of the run time loader.    If we are stepping at the source level, we single step until we exit    the run time loader code and reach the callee's address.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|IN_SOLIB_DYNSYM_RESOLVE_CODE
end_ifndef

begin_define
define|#
directive|define
name|IN_SOLIB_DYNSYM_RESOLVE_CODE
parameter_list|(
name|pc
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* For SVR4 shared libraries, each call goes through a small piece of    trampoline code in the ".plt" section.  IN_SOLIB_CALL_TRAMPOLINE evaluates    to nonzero if we are current stopped in one of these. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|IN_SOLIB_CALL_TRAMPOLINE
end_ifndef

begin_define
define|#
directive|define
name|IN_SOLIB_CALL_TRAMPOLINE
parameter_list|(
name|pc
parameter_list|,
name|name
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* In some shared library schemes, the return path from a shared library    call may need to go through a trampoline too.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|IN_SOLIB_RETURN_TRAMPOLINE
end_ifndef

begin_define
define|#
directive|define
name|IN_SOLIB_RETURN_TRAMPOLINE
parameter_list|(
name|pc
parameter_list|,
name|name
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This function returns TRUE if pc is the address of an instruction    that lies within the dynamic linker (such as the event hook, or the    dld itself).     This function must be used only when a dynamic linker event has    been caught, and the inferior is being stepped out of the hook, or    undefined results are guaranteed.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SOLIB_IN_DYNAMIC_LINKER
end_ifndef

begin_define
define|#
directive|define
name|SOLIB_IN_DYNAMIC_LINKER
parameter_list|(
name|pid
parameter_list|,
name|pc
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* On MIPS16, a function that returns a floating point value may call    a library helper function to copy the return value to a floating point    register.  The IGNORE_HELPER_CALL macro returns non-zero if we    should ignore (i.e. step over) this function call.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|IGNORE_HELPER_CALL
end_ifndef

begin_define
define|#
directive|define
name|IGNORE_HELPER_CALL
parameter_list|(
name|pc
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* On some systems, the PC may be left pointing at an instruction that  won't    actually be executed.  This is usually indicated by a bit in the PSW.  If    we find ourselves in such a state, then we step the target beyond the    nullified instruction before returning control to the user so as to avoid    confusion. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|INSTRUCTION_NULLIFIED
end_ifndef

begin_define
define|#
directive|define
name|INSTRUCTION_NULLIFIED
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Tables of how to react to signals; the user sets them.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|signal_stop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|signal_print
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|signal_program
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SET_SIGS
parameter_list|(
name|nsigs
parameter_list|,
name|sigs
parameter_list|,
name|flags
parameter_list|)
define|\
value|do { \     int signum = (nsigs); \     while (signum--> 0) \       if ((sigs)[signum]) \ 	(flags)[signum] = 1; \   } while (0)
end_define

begin_define
define|#
directive|define
name|UNSET_SIGS
parameter_list|(
name|nsigs
parameter_list|,
name|sigs
parameter_list|,
name|flags
parameter_list|)
define|\
value|do { \     int signum = (nsigs); \     while (signum--> 0) \       if ((sigs)[signum]) \ 	(flags)[signum] = 0; \   } while (0)
end_define

begin_comment
comment|/* Command list pointer for the "stop" placeholder.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cmd_list_element
modifier|*
name|stop_command
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if breakpoints are now inserted in the inferior.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|breakpoints_inserted
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function inferior was in as of last step command.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|symbol
modifier|*
name|step_start_function
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we are expecting a trace trap and should proceed from it.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|trap_expected
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SOLIB_ADD
end_ifdef

begin_comment
comment|/* Nonzero if we want to give control to the user when we're notified    of shared library events by the dynamic linker.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stop_on_solib_events
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HP_OS_BUG
end_ifdef

begin_comment
comment|/* Nonzero if the next time we try to continue the inferior, it will    step one instruction and generate a spurious trace trap.    This is used to compensate for a bug in HP-UX.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|trap_expected_after_continue
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Nonzero means expecting a trace trap    and should stop the inferior and return silently when it happens.  */
end_comment

begin_decl_stmt
name|int
name|stop_after_trap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means expecting a trap and caller will handle it themselves.    It is used after attach, due to attaching to a process;    when running in the shell before the child program has been exec'd;    and when running some kinds of remote stuff (FIXME?).  */
end_comment

begin_decl_stmt
name|int
name|stop_soon_quietly
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if proceed is being used for a "finish" command or a similar    situation when stop_registers should be saved.  */
end_comment

begin_decl_stmt
name|int
name|proceed_to_finish
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Save register contents here when about to pop a stack dummy frame,    if-and-only-if proceed_to_finish is set.    Thus this contains the return value from the called function (assuming    values are returned in a register).  */
end_comment

begin_decl_stmt
name|char
name|stop_registers
index|[
name|REGISTER_BYTES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if program stopped due to error trying to insert breakpoints.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|breakpoints_failed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero after stop if current stack frame should be printed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stop_print_frame
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|breakpoint
modifier|*
name|step_resume_breakpoint
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|breakpoint
modifier|*
name|through_sigtramp_breakpoint
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* On some platforms (e.g., HP-UX), hardware watchpoints have bad    interactions with an inferior that is running a kernel function    (aka, a system call or "syscall").  wait_for_inferior therefore    may have a need to know when the inferior is in a syscall.  This    is a count of the number of inferior threads which are known to    currently be running in a syscall. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|number_of_threads_in_syscalls
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is used to remember when a fork, vfork or exec event    was caught by a catchpoint, and thus the event is to be    followed at the next resume of the inferior, and not    immediately. */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|enum
name|target_waitkind
name|kind
decl_stmt|;
struct|struct
block|{
name|int
name|parent_pid
decl_stmt|;
name|int
name|saw_parent_fork
decl_stmt|;
name|int
name|child_pid
decl_stmt|;
name|int
name|saw_child_fork
decl_stmt|;
name|int
name|saw_child_exec
decl_stmt|;
block|}
name|fork_event
struct|;
name|char
modifier|*
name|execd_pathname
decl_stmt|;
block|}
name|pending_follow
struct|;
end_struct

begin_comment
comment|/* Some platforms don't allow us to do anything meaningful with a    vforked child until it has exec'd.  Vforked processes on such    platforms can only be followed after they've exec'd.     When this is set to 0, a vfork can be immediately followed,    and an exec can be followed merely as an exec.  When this is    set to 1, a vfork event has been seen, but cannot be followed    until the exec is seen.     (In the latter case, inferior_pid is still the parent of the    vfork, and pending_follow.fork_event.child_pid is the child.  The    appropriate process is followed, according to the setting of    follow-fork-mode.) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|follow_vfork_when_exec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|follow_fork_mode_kind_names
index|[]
init|=
block|{
comment|/* ??rehrauer:  The "both" option is broken, by what may be a 10.20    kernel problem.  It's also not terribly useful without a GUI to    help the user drive two debuggers.  So for now, I'm disabling    the "both" option.   "parent", "child", "both", "ask" };   */
literal|"parent"
block|,
literal|"child"
block|,
literal|"ask"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|follow_fork_mode_string
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HPUXHPPA
argument_list|)
end_if

begin_function
specifier|static
name|void
name|follow_inferior_fork
parameter_list|(
name|parent_pid
parameter_list|,
name|child_pid
parameter_list|,
name|has_forked
parameter_list|,
name|has_vforked
parameter_list|)
name|int
name|parent_pid
decl_stmt|;
name|int
name|child_pid
decl_stmt|;
name|int
name|has_forked
decl_stmt|;
name|int
name|has_vforked
decl_stmt|;
block|{
name|int
name|followed_parent
init|=
literal|0
decl_stmt|;
name|int
name|followed_child
init|=
literal|0
decl_stmt|;
name|int
name|ima_clone
init|=
literal|0
decl_stmt|;
comment|/* Which process did the user want us to follow? */
name|char
modifier|*
name|follow_mode
init|=
name|savestring
argument_list|(
name|follow_fork_mode_string
argument_list|,
name|strlen
argument_list|(
name|follow_fork_mode_string
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Or, did the user not know, and want us to ask? */
if|if
condition|(
name|STREQ
argument_list|(
name|follow_fork_mode_string
argument_list|,
literal|"ask"
argument_list|)
condition|)
block|{
name|char
name|requested_mode
index|[
literal|100
index|]
decl_stmt|;
name|free
argument_list|(
name|follow_mode
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"\"ask\" mode NYI"
argument_list|)
expr_stmt|;
name|follow_mode
operator|=
name|savestring
argument_list|(
name|requested_mode
argument_list|,
name|strlen
argument_list|(
name|requested_mode
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If we're to be following the parent, then detach from child_pid.      We're already following the parent, so need do nothing explicit      for it. */
if|if
condition|(
name|STREQ
argument_list|(
name|follow_mode
argument_list|,
literal|"parent"
argument_list|)
condition|)
block|{
name|followed_parent
operator|=
literal|1
expr_stmt|;
comment|/* We're already attached to the parent, by default. */
comment|/* Before detaching from the child, remove all breakpoints from          it.  (This won't actually modify the breakpoint list, but will          physically remove the breakpoints from the child.) */
if|if
condition|(
operator|!
name|has_vforked
operator|||
operator|!
name|follow_vfork_when_exec
condition|)
block|{
name|detach_breakpoints
argument_list|(
name|child_pid
argument_list|)
expr_stmt|;
name|SOLIB_REMOVE_INFERIOR_HOOK
argument_list|(
name|child_pid
argument_list|)
expr_stmt|;
block|}
comment|/* Detach from the child. */
name|dont_repeat
argument_list|()
expr_stmt|;
name|target_require_detach
argument_list|(
name|child_pid
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* If we're to be following the child, then attach to it, detach      from inferior_pid, and set inferior_pid to child_pid. */
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|follow_mode
argument_list|,
literal|"child"
argument_list|)
condition|)
block|{
name|char
name|child_pid_spelling
index|[
literal|100
index|]
decl_stmt|;
comment|/* Arbitrary length. */
name|followed_child
operator|=
literal|1
expr_stmt|;
comment|/* Before detaching from the parent, detach all breakpoints from          the child.  But only if we're forking, or if we follow vforks          as soon as they happen.  (If we're following vforks only when          the child has exec'd, then it's very wrong to try to write          back the "shadow contents" of inserted breakpoints now -- they          belong to the child's pre-exec'd a.out.) */
if|if
condition|(
operator|!
name|has_vforked
operator|||
operator|!
name|follow_vfork_when_exec
condition|)
block|{
name|detach_breakpoints
argument_list|(
name|child_pid
argument_list|)
expr_stmt|;
block|}
comment|/* Before detaching from the parent, remove all breakpoints from it. */
name|remove_breakpoints
argument_list|()
expr_stmt|;
comment|/* Also reset the solib inferior hook from the parent. */
name|SOLIB_REMOVE_INFERIOR_HOOK
argument_list|(
name|inferior_pid
argument_list|)
expr_stmt|;
comment|/* Detach from the parent. */
name|dont_repeat
argument_list|()
expr_stmt|;
name|target_detach
argument_list|(
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Attach to the child. */
name|inferior_pid
operator|=
name|child_pid
expr_stmt|;
name|sprintf
argument_list|(
name|child_pid_spelling
argument_list|,
literal|"%d"
argument_list|,
name|child_pid
argument_list|)
expr_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
name|target_require_attach
argument_list|(
name|child_pid_spelling
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Was there a step_resume breakpoint?  (There was if the user          did a "next" at the fork() call.)  If so, explicitly reset its          thread number.           step_resumes are a form of bp that are made to be per-thread.          Since we created the step_resume bp when the parent process          was being debugged, and now are switching to the child process,          from the breakpoint package's viewpoint, that's a switch of          "threads".  We must update the bp's notion of which thread          it is for, or it'll be ignored when it triggers... */
if|if
condition|(
name|step_resume_breakpoint
operator|&&
operator|(
operator|!
name|has_vforked
operator|||
operator|!
name|follow_vfork_when_exec
operator|)
condition|)
name|breakpoint_re_set_thread
argument_list|(
name|step_resume_breakpoint
argument_list|)
expr_stmt|;
comment|/* Reinsert all breakpoints in the child.  (The user may've set          breakpoints after catching the fork, in which case those          actually didn't get set in the child, but only in the parent.) */
if|if
condition|(
operator|!
name|has_vforked
operator|||
operator|!
name|follow_vfork_when_exec
condition|)
block|{
name|breakpoint_re_set
argument_list|()
expr_stmt|;
name|insert_breakpoints
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* If we're to be following both parent and child, then fork ourselves,      and attach the debugger clone to the child. */
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|follow_mode
argument_list|,
literal|"both"
argument_list|)
condition|)
block|{
name|char
name|pid_suffix
index|[
literal|100
index|]
decl_stmt|;
comment|/* Arbitrary length. */
comment|/* Clone ourselves to follow the child.  This is the end of our        involvement with child_pid; our clone will take it from here... */
name|dont_repeat
argument_list|()
expr_stmt|;
name|target_clone_and_follow_inferior
argument_list|(
name|child_pid
argument_list|,
operator|&
name|followed_child
argument_list|)
expr_stmt|;
name|followed_parent
operator|=
operator|!
name|followed_child
expr_stmt|;
comment|/* We continue to follow the parent.  To help distinguish the two          debuggers, though, both we and our clone will reset our prompts. */
name|sprintf
argument_list|(
name|pid_suffix
argument_list|,
literal|"[%d] "
argument_list|,
name|inferior_pid
argument_list|)
expr_stmt|;
name|set_prompt
argument_list|(
name|strcat
argument_list|(
name|get_prompt
argument_list|()
argument_list|,
name|pid_suffix
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* The parent and child of a vfork share the same address space.      Also, on some targets the order in which vfork and exec events      are received for parent in child requires some delicate handling      of the events.       For instance, on ptrace-based HPUX we receive the child's vfork      event first, at which time the parent has been suspended by the      OS and is essentially untouchable until the child's exit or second      exec event arrives.  At that time, the parent's vfork event is      delivered to us, and that's when we see and decide how to follow      the vfork.  But to get to that point, we must continue the child      until it execs or exits.  To do that smoothly, all breakpoints      must be removed from the child, in case there are any set between      the vfork() and exec() calls.  But removing them from the child      also removes them from the parent, due to the shared-address-space      nature of a vfork'd parent and child.  On HPUX, therefore, we must      take care to restore the bp's to the parent before we continue it.      Else, it's likely that we may not stop in the expected place.  (The      worst scenario is when the user tries to step over a vfork() call;      the step-resume bp must be restored for the step to properly stop      in the parent after the call completes!)       Sequence of events, as reported to gdb from HPUX:             Parent        Child           Action for gdb to take          -------------------------------------------------------         1                VFORK               Continue child         2                EXEC         3                EXEC or EXIT         4  VFORK */
if|if
condition|(
name|has_vforked
condition|)
block|{
name|target_post_follow_vfork
argument_list|(
name|parent_pid
argument_list|,
name|followed_parent
argument_list|,
name|child_pid
argument_list|,
name|followed_child
argument_list|)
expr_stmt|;
block|}
name|pending_follow
operator|.
name|fork_event
operator|.
name|saw_parent_fork
operator|=
literal|0
expr_stmt|;
name|pending_follow
operator|.
name|fork_event
operator|.
name|saw_child_fork
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|follow_mode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|follow_fork
parameter_list|(
name|parent_pid
parameter_list|,
name|child_pid
parameter_list|)
name|int
name|parent_pid
decl_stmt|;
name|int
name|child_pid
decl_stmt|;
block|{
name|follow_inferior_fork
argument_list|(
name|parent_pid
argument_list|,
name|child_pid
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Forward declaration. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|follow_exec
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|follow_vfork
parameter_list|(
name|parent_pid
parameter_list|,
name|child_pid
parameter_list|)
name|int
name|parent_pid
decl_stmt|;
name|int
name|child_pid
decl_stmt|;
block|{
name|follow_inferior_fork
argument_list|(
name|parent_pid
argument_list|,
name|child_pid
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Did we follow the child?  Had it exec'd before we saw the parent vfork? */
if|if
condition|(
name|pending_follow
operator|.
name|fork_event
operator|.
name|saw_child_exec
operator|&&
operator|(
name|inferior_pid
operator|==
name|child_pid
operator|)
condition|)
block|{
name|pending_follow
operator|.
name|fork_event
operator|.
name|saw_child_exec
operator|=
literal|0
expr_stmt|;
name|pending_follow
operator|.
name|kind
operator|=
name|TARGET_WAITKIND_SPURIOUS
expr_stmt|;
name|follow_exec
argument_list|(
name|inferior_pid
argument_list|,
name|pending_follow
operator|.
name|execd_pathname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pending_follow
operator|.
name|execd_pathname
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HPUXHPPA */
end_comment

begin_function
specifier|static
name|void
name|follow_exec
parameter_list|(
name|pid
parameter_list|,
name|execd_pathname
parameter_list|)
name|int
name|pid
decl_stmt|;
name|char
modifier|*
name|execd_pathname
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|HPUXHPPA
name|int
name|saved_pid
init|=
name|pid
decl_stmt|;
specifier|extern
name|struct
name|target_ops
name|child_ops
decl_stmt|;
comment|/* Did this exec() follow a vfork()?  If so, we must follow the      vfork now too.  Do it before following the exec. */
if|if
condition|(
name|follow_vfork_when_exec
operator|&&
operator|(
name|pending_follow
operator|.
name|kind
operator|==
name|TARGET_WAITKIND_VFORKED
operator|)
condition|)
block|{
name|pending_follow
operator|.
name|kind
operator|=
name|TARGET_WAITKIND_SPURIOUS
expr_stmt|;
name|follow_vfork
argument_list|(
name|inferior_pid
argument_list|,
name|pending_follow
operator|.
name|fork_event
operator|.
name|child_pid
argument_list|)
expr_stmt|;
name|follow_vfork_when_exec
operator|=
literal|0
expr_stmt|;
name|saved_pid
operator|=
name|inferior_pid
expr_stmt|;
comment|/* Did we follow the parent?  If so, we're done.  If we followed          the child then we must also follow its exec(). */
if|if
condition|(
name|inferior_pid
operator|==
name|pending_follow
operator|.
name|fork_event
operator|.
name|parent_pid
condition|)
return|return;
block|}
comment|/* This is an exec event that we actually wish to pay attention to.      Refresh our symbol table to the newly exec'd program, remove any      momentary bp's, etc.       If there are breakpoints, they aren't really inserted now,      since the exec() transformed our inferior into a fresh set      of instructions.       We want to preserve symbolic breakpoints on the list, since      we have hopes that they can be reset after the new a.out's      symbol table is read.       However, any "raw" breakpoints must be removed from the list      (e.g., the solib bp's), since their address is probably invalid      now.       And, we DON'T want to call delete_breakpoints() here, since      that may write the bp's "shadow contents" (the instruction      value that was overwritten witha TRAP instruction).  Since      we now have a new a.out, those shadow contents aren't valid. */
name|update_breakpoints_after_exec
argument_list|()
expr_stmt|;
comment|/* If there was one, it's gone now.  We cannot truly step-to-next      statement through an exec(). */
name|step_resume_breakpoint
operator|=
name|NULL
expr_stmt|;
name|step_range_start
operator|=
literal|0
expr_stmt|;
name|step_range_end
operator|=
literal|0
expr_stmt|;
comment|/* If there was one, it's gone now. */
name|through_sigtramp_breakpoint
operator|=
name|NULL
expr_stmt|;
comment|/* What is this a.out's name? */
name|printf_unfiltered
argument_list|(
literal|"Executing new program: %s\n"
argument_list|,
name|execd_pathname
argument_list|)
expr_stmt|;
comment|/* We've followed the inferior through an exec.  Therefore, the      inferior has essentially been killed& reborn. */
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|target_mourn_inferior
argument_list|()
expr_stmt|;
name|inferior_pid
operator|=
name|saved_pid
expr_stmt|;
comment|/* Because mourn_inferior resets inferior_pid. */
name|push_target
argument_list|(
operator|&
name|child_ops
argument_list|)
expr_stmt|;
comment|/* That a.out is now the one to use. */
name|exec_file_attach
argument_list|(
name|execd_pathname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* And also is where symbols can be found. */
name|symbol_file_command
argument_list|(
name|execd_pathname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reset the shared library package.  This ensures that we get      a shlib event when the child reaches "_start", at which point      the dld will have had a chance to initialize the child. */
name|SOLIB_RESTART
argument_list|()
expr_stmt|;
name|SOLIB_CREATE_INFERIOR_HOOK
argument_list|(
name|inferior_pid
argument_list|)
expr_stmt|;
comment|/* Reinsert all breakpoints.  (Those which were symbolic have      been reset to the proper address in the new a.out, thanks      to symbol_file_command...) */
name|insert_breakpoints
argument_list|()
expr_stmt|;
comment|/* The next resume of this inferior should bring it to the shlib      startup breakpoints.  (If the user had also set bp's on      "main" from the old (parent) process, then they'll auto-      matically get reset there in the new process.) */
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Non-zero if we just simulating a single-step.  This is needed    because we cannot remove the breakpoints in the inferior process    until after the `wait' in `wait_for_inferior'.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|singlestep_breakpoints_inserted_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Things to clean up if we QUIT out of resume ().  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|resume_cleanups
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
name|normal_stop
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|schedlock_off
index|[]
init|=
literal|"off"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|schedlock_on
index|[]
init|=
literal|"on"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|schedlock_step
index|[]
init|=
literal|"step"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|scheduler_mode
init|=
name|schedlock_off
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|scheduler_enums
index|[]
init|=
block|{
name|schedlock_off
block|,
name|schedlock_on
block|,
name|schedlock_step
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|set_schedlock_func
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|,
name|c
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
block|{
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|set_cmd
condition|)
if|if
condition|(
operator|!
name|target_can_lock_scheduler
condition|)
block|{
name|scheduler_mode
operator|=
name|schedlock_off
expr_stmt|;
name|error
argument_list|(
literal|"Target '%s' cannot support this command."
argument_list|,
name|target_shortname
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Resume the inferior, but allow a QUIT.  This is useful if the user    wants to interrupt some lengthy single-stepping operation    (for child processes, the SIGINT goes to the inferior, and so    we get a SIGINT random_signal, but for remote debugging and perhaps    other targets, that's not true).     STEP nonzero if we should step (zero to continue instead).    SIG is the signal to give the inferior (zero for none).  */
end_comment

begin_function
name|void
name|resume
parameter_list|(
name|step
parameter_list|,
name|sig
parameter_list|)
name|int
name|step
decl_stmt|;
name|enum
name|target_signal
name|sig
decl_stmt|;
block|{
name|int
name|should_resume
init|=
literal|1
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_cleanups
init|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|resume_cleanups
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|QUIT
expr_stmt|;
ifdef|#
directive|ifdef
name|CANNOT_STEP_BREAKPOINT
comment|/* Most targets can step a breakpoint instruction, thus executing it      normally.  But if this one cannot, just continue and we will hit      it anyway.  */
if|if
condition|(
name|step
operator|&&
name|breakpoints_inserted
operator|&&
name|breakpoint_here_p
argument_list|(
name|read_pc
argument_list|()
argument_list|)
condition|)
name|step
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|SOFTWARE_SINGLE_STEP_P
operator|&&
name|step
condition|)
block|{
comment|/* Do it the hard way, w/temp breakpoints */
name|SOFTWARE_SINGLE_STEP
argument_list|(
name|sig
argument_list|,
literal|1
comment|/*insert-breakpoints*/
argument_list|)
expr_stmt|;
comment|/* ...and don't ask hardware to do it.  */
name|step
operator|=
literal|0
expr_stmt|;
comment|/* and do not pull these breakpoints until after a `wait' in          `wait_for_inferior' */
name|singlestep_breakpoints_inserted_p
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Handle any optimized stores to the inferior NOW...  */
ifdef|#
directive|ifdef
name|DO_DEFERRED_STORES
name|DO_DEFERRED_STORES
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HPUXHPPA
comment|/* If there were any forks/vforks/execs that were caught and are      now to be followed, then do so. */
switch|switch
condition|(
name|pending_follow
operator|.
name|kind
condition|)
block|{
case|case
operator|(
name|TARGET_WAITKIND_FORKED
operator|)
case|:
name|pending_follow
operator|.
name|kind
operator|=
name|TARGET_WAITKIND_SPURIOUS
expr_stmt|;
name|follow_fork
argument_list|(
name|inferior_pid
argument_list|,
name|pending_follow
operator|.
name|fork_event
operator|.
name|child_pid
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|TARGET_WAITKIND_VFORKED
operator|)
case|:
block|{
name|int
name|saw_child_exec
init|=
name|pending_follow
operator|.
name|fork_event
operator|.
name|saw_child_exec
decl_stmt|;
name|pending_follow
operator|.
name|kind
operator|=
name|TARGET_WAITKIND_SPURIOUS
expr_stmt|;
name|follow_vfork
argument_list|(
name|inferior_pid
argument_list|,
name|pending_follow
operator|.
name|fork_event
operator|.
name|child_pid
argument_list|)
expr_stmt|;
comment|/* Did we follow the child, but not yet see the child's exec event?              If so, then it actually ought to be waiting for us; we respond to              parent vfork events.  We don't actually want to resume the child              in this situation; we want to just get its exec event. */
if|if
condition|(
operator|!
name|saw_child_exec
operator|&&
operator|(
name|inferior_pid
operator|==
name|pending_follow
operator|.
name|fork_event
operator|.
name|child_pid
operator|)
condition|)
name|should_resume
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
operator|(
name|TARGET_WAITKIND_EXECD
operator|)
case|:
comment|/* If we saw a vfork event but couldn't follow it until we saw            an exec, then now might be the time! */
name|pending_follow
operator|.
name|kind
operator|=
name|TARGET_WAITKIND_SPURIOUS
expr_stmt|;
comment|/* follow_exec is called as soon as the exec event is seen. */
break|break;
default|default:
break|break;
block|}
endif|#
directive|endif
comment|/* HPUXHPPA */
comment|/* Install inferior's terminal modes.  */
name|target_terminal_inferior
argument_list|()
expr_stmt|;
if|if
condition|(
name|should_resume
condition|)
block|{
ifdef|#
directive|ifdef
name|HPUXHPPA
if|if
condition|(
name|thread_step_needed
condition|)
block|{
comment|/* We stopped on a BPT instruction; 	     don't continue other threads and 	     just step this thread. */
name|thread_step_needed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|breakpoint_here_p
argument_list|(
name|read_pc
argument_list|()
argument_list|)
condition|)
block|{
comment|/* Breakpoint deleted: ok to do regular resume 		 where all the threads either step or continue. */
name|target_resume
argument_list|(
operator|-
literal|1
argument_list|,
name|step
argument_list|,
name|sig
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|step
condition|)
block|{
name|warning
argument_list|(
literal|"Internal error, changing continue to step."
argument_list|)
expr_stmt|;
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|breakpoints_inserted
operator|=
literal|0
expr_stmt|;
name|trap_expected
operator|=
literal|1
expr_stmt|;
name|step
operator|=
literal|1
expr_stmt|;
block|}
name|target_resume
argument_list|(
name|inferior_pid
argument_list|,
name|step
argument_list|,
name|sig
argument_list|)
expr_stmt|;
block|}
block|}
else|else
endif|#
directive|endif
comment|/* HPUXHPPA */
block|{
comment|/* Vanilla resume. */
if|if
condition|(
operator|(
name|scheduler_mode
operator|==
name|schedlock_on
operator|)
operator|||
operator|(
name|scheduler_mode
operator|==
name|schedlock_step
operator|&&
name|step
operator|!=
literal|0
operator|)
condition|)
name|target_resume
argument_list|(
name|inferior_pid
argument_list|,
name|step
argument_list|,
name|sig
argument_list|)
expr_stmt|;
else|else
name|target_resume
argument_list|(
operator|-
literal|1
argument_list|,
name|step
argument_list|,
name|sig
argument_list|)
expr_stmt|;
block|}
block|}
name|discard_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Clear out all variables saying what to do when inferior is continued.    First do this, then set the ones you want, then call `proceed'.  */
end_comment

begin_function
name|void
name|clear_proceed_status
parameter_list|()
block|{
name|trap_expected
operator|=
literal|0
expr_stmt|;
name|step_range_start
operator|=
literal|0
expr_stmt|;
name|step_range_end
operator|=
literal|0
expr_stmt|;
name|step_frame_address
operator|=
literal|0
expr_stmt|;
name|step_over_calls
operator|=
operator|-
literal|1
expr_stmt|;
name|stop_after_trap
operator|=
literal|0
expr_stmt|;
name|stop_soon_quietly
operator|=
literal|0
expr_stmt|;
name|proceed_to_finish
operator|=
literal|0
expr_stmt|;
name|breakpoint_proceeded
operator|=
literal|1
expr_stmt|;
comment|/* We're about to proceed... */
comment|/* Discard any remaining commands or status from previous stop.  */
name|bpstat_clear
argument_list|(
operator|&
name|stop_bpstat
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Basic routine for continuing the program in various fashions.     ADDR is the address to resume at, or -1 for resume where stopped.    SIGGNAL is the signal to give it, or 0 for none,      or -1 for act according to how it stopped.    STEP is nonzero if should trap after one instruction.      -1 means return after that and print nothing.      You should probably set various step_... variables      before calling here, if you are stepping.     You should call clear_proceed_status before calling proceed.  */
end_comment

begin_function
name|void
name|proceed
parameter_list|(
name|addr
parameter_list|,
name|siggnal
parameter_list|,
name|step
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|enum
name|target_signal
name|siggnal
decl_stmt|;
name|int
name|step
decl_stmt|;
block|{
name|int
name|oneproc
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|step
operator|>
literal|0
condition|)
name|step_start_function
operator|=
name|find_pc_function
argument_list|(
name|read_pc
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|step
operator|<
literal|0
condition|)
name|stop_after_trap
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|addr
operator|==
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* If there is a breakpoint at the address we will resume at, 	 step one instruction before inserting breakpoints 	 so that we do not stop right away (and report a second          hit at this breakpoint).  */
if|if
condition|(
name|read_pc
argument_list|()
operator|==
name|stop_pc
operator|&&
name|breakpoint_here_p
argument_list|(
name|read_pc
argument_list|()
argument_list|)
condition|)
name|oneproc
operator|=
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|STEP_SKIPS_DELAY
define|#
directive|define
name|STEP_SKIPS_DELAY
parameter_list|(
name|pc
parameter_list|)
value|(0)
define|#
directive|define
name|STEP_SKIPS_DELAY_P
value|(0)
endif|#
directive|endif
comment|/* Check breakpoint_here_p first, because breakpoint_here_p is fast 	 (it just checks internal GDB data structures) and STEP_SKIPS_DELAY 	 is slow (it needs to read memory from the target).  */
if|if
condition|(
name|STEP_SKIPS_DELAY_P
operator|&&
name|breakpoint_here_p
argument_list|(
name|read_pc
argument_list|()
operator|+
literal|4
argument_list|)
operator|&&
name|STEP_SKIPS_DELAY
argument_list|(
name|read_pc
argument_list|()
argument_list|)
condition|)
name|oneproc
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|write_pc
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/* New address; we don't need to single-step a thread 	 over a breakpoint we just hit, 'cause we aren't 	 continuing from there.  	 It's not worth worrying about the case where a user 	 asks for a "jump" at the current PC--if they get the 	 hiccup of re-hiting a hit breakpoint, what else do 	 they expect? */
name|thread_step_needed
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PREPARE_TO_PROCEED
comment|/* In a multi-threaded task we may select another thread      and then continue or step.       But if the old thread was stopped at a breakpoint, it      will immediately cause another breakpoint stop without      any execution (i.e. it will report a breakpoint hit      incorrectly).  So we must step over it first.       PREPARE_TO_PROCEED checks the current thread against the thread      that reported the most recent event.  If a step-over is required      it returns TRUE and sets the current thread to the old thread. */
if|if
condition|(
name|PREPARE_TO_PROCEED
argument_list|()
operator|&&
name|breakpoint_here_p
argument_list|(
name|read_pc
argument_list|()
argument_list|)
condition|)
block|{
name|oneproc
operator|=
literal|1
expr_stmt|;
name|thread_step_needed
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* PREPARE_TO_PROCEED */
ifdef|#
directive|ifdef
name|HP_OS_BUG
if|if
condition|(
name|trap_expected_after_continue
condition|)
block|{
comment|/* If (step == 0), a trap will be automatically generated after 	 the first instruction is executed.  Force step one 	 instruction to clear this condition.  This should not occur 	 if step is nonzero, but it is harmless in that case.  */
name|oneproc
operator|=
literal|1
expr_stmt|;
name|trap_expected_after_continue
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HP_OS_BUG */
if|if
condition|(
name|oneproc
condition|)
comment|/* We will get a trace trap after one instruction.        Continue it automatically and insert breakpoints then.  */
name|trap_expected
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|int
name|temp
init|=
name|insert_breakpoints
argument_list|()
decl_stmt|;
if|if
condition|(
name|temp
condition|)
block|{
name|print_sys_errmsg
argument_list|(
literal|"ptrace"
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Cannot insert breakpoints.\n\ The same program may be running in another process."
argument_list|)
expr_stmt|;
block|}
name|breakpoints_inserted
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|siggnal
operator|!=
name|TARGET_SIGNAL_DEFAULT
condition|)
name|stop_signal
operator|=
name|siggnal
expr_stmt|;
comment|/* If this signal should not be seen by program,      give it zero.  Used for debugging signals.  */
elseif|else
if|if
condition|(
operator|!
name|signal_program
index|[
name|stop_signal
index|]
condition|)
name|stop_signal
operator|=
name|TARGET_SIGNAL_0
expr_stmt|;
name|annotate_starting
argument_list|()
expr_stmt|;
comment|/* Make sure that output from GDB appears before output from the      inferior.  */
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
comment|/* Resume inferior.  */
name|resume
argument_list|(
name|oneproc
operator|||
name|step
operator|||
name|bpstat_should_step
argument_list|()
argument_list|,
name|stop_signal
argument_list|)
expr_stmt|;
comment|/* Wait for it to stop (if not standalone)      and in any case decode why it stopped, and act accordingly.  */
name|wait_for_inferior
argument_list|()
expr_stmt|;
name|normal_stop
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record the pc and sp of the program the last time it stopped.    These are just used internally by wait_for_inferior, but need    to be preserved over calls to it and cleared when the inferior    is started.  */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|prev_pc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|prev_func_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|prev_func_name
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Start remote-debugging of a machine over a serial link.  */
end_comment

begin_function
name|void
name|start_remote
parameter_list|()
block|{
name|init_thread_list
argument_list|()
expr_stmt|;
name|init_wait_for_inferior
argument_list|()
expr_stmt|;
name|stop_soon_quietly
operator|=
literal|1
expr_stmt|;
name|trap_expected
operator|=
literal|0
expr_stmt|;
name|wait_for_inferior
argument_list|()
expr_stmt|;
name|normal_stop
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize static vars when a new inferior begins.  */
end_comment

begin_function
name|void
name|init_wait_for_inferior
parameter_list|()
block|{
comment|/* These are meaningless until the first time through wait_for_inferior.  */
name|prev_pc
operator|=
literal|0
expr_stmt|;
name|prev_func_start
operator|=
literal|0
expr_stmt|;
name|prev_func_name
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|HP_OS_BUG
name|trap_expected_after_continue
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|breakpoints_inserted
operator|=
literal|0
expr_stmt|;
name|breakpoint_init_inferior
argument_list|(
name|inf_starting
argument_list|)
expr_stmt|;
comment|/* Don't confuse first call to proceed(). */
name|stop_signal
operator|=
name|TARGET_SIGNAL_0
expr_stmt|;
comment|/* The first resume is not following a fork/vfork/exec. */
name|pending_follow
operator|.
name|kind
operator|=
name|TARGET_WAITKIND_SPURIOUS
expr_stmt|;
comment|/* I.e., none. */
name|pending_follow
operator|.
name|fork_event
operator|.
name|saw_parent_fork
operator|=
literal|0
expr_stmt|;
name|pending_follow
operator|.
name|fork_event
operator|.
name|saw_child_fork
operator|=
literal|0
expr_stmt|;
name|pending_follow
operator|.
name|fork_event
operator|.
name|saw_child_exec
operator|=
literal|0
expr_stmt|;
comment|/* See wait_for_inferior's handling of SYSCALL_ENTRY/RETURN events. */
name|number_of_threads_in_syscalls
operator|=
literal|0
expr_stmt|;
name|clear_proceed_status
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|delete_breakpoint_current_contents
parameter_list|(
name|arg
parameter_list|)
name|PTR
name|arg
decl_stmt|;
block|{
name|struct
name|breakpoint
modifier|*
modifier|*
name|breakpointp
init|=
operator|(
expr|struct
name|breakpoint
operator|*
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
operator|*
name|breakpointp
operator|!=
name|NULL
condition|)
block|{
name|delete_breakpoint
argument_list|(
operator|*
name|breakpointp
argument_list|)
expr_stmt|;
operator|*
name|breakpointp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Wait for control to return from inferior to debugger.    If inferior gets a signal, we may decide to start it up again    instead of returning.  That is why there is a loop in this function.    When this function actually returns it means the inferior    should be left stopped and GDB should read more commands.  */
end_comment

begin_function
name|void
name|wait_for_inferior
parameter_list|()
block|{
name|struct
name|cleanup
modifier|*
name|old_cleanups
decl_stmt|;
name|struct
name|target_waitstatus
name|w
decl_stmt|;
name|int
name|another_trap
decl_stmt|;
name|int
name|random_signal
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|stop_func_start
decl_stmt|;
name|CORE_ADDR
name|stop_func_end
decl_stmt|;
name|char
modifier|*
name|stop_func_name
decl_stmt|;
if|#
directive|if
literal|0
block|CORE_ADDR prologue_pc = 0;
endif|#
directive|endif
name|CORE_ADDR
name|tmp
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|int
name|remove_breakpoints_on_following_step
init|=
literal|0
decl_stmt|;
name|int
name|current_line
decl_stmt|;
name|struct
name|symtab
modifier|*
name|current_symtab
decl_stmt|;
name|int
name|handling_longjmp
init|=
literal|0
decl_stmt|;
comment|/* FIXME */
name|int
name|pid
decl_stmt|;
name|int
name|saved_inferior_pid
decl_stmt|;
name|int
name|update_step_sp
init|=
literal|0
decl_stmt|;
name|int
name|stepping_through_solib_after_catch
init|=
literal|0
decl_stmt|;
name|bpstat
name|stepping_through_solib_catchpoints
init|=
name|NULL
decl_stmt|;
name|int
name|enable_hw_watchpoints_after_wait
init|=
literal|0
decl_stmt|;
name|int
name|stepping_through_sigtramp
init|=
literal|0
decl_stmt|;
name|int
name|new_thread_event
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_NONSTEPPABLE_WATCHPOINT
name|int
name|stepped_after_stopped_by_watchpoint
decl_stmt|;
endif|#
directive|endif
name|old_cleanups
operator|=
name|make_cleanup
argument_list|(
name|delete_breakpoint_current_contents
argument_list|,
operator|&
name|step_resume_breakpoint
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|delete_breakpoint_current_contents
argument_list|,
operator|&
name|through_sigtramp_breakpoint
argument_list|)
expr_stmt|;
name|sal
operator|=
name|find_pc_line
argument_list|(
name|prev_pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|current_line
operator|=
name|sal
operator|.
name|line
expr_stmt|;
name|current_symtab
operator|=
name|sal
operator|.
name|symtab
expr_stmt|;
comment|/* Are we stepping?  */
define|#
directive|define
name|CURRENTLY_STEPPING
parameter_list|()
define|\
value|((through_sigtramp_breakpoint == NULL \&& !handling_longjmp \&& ((step_range_end&& step_resume_breakpoint == NULL) \ 	|| trap_expected)) \    || stepping_through_solib_after_catch \    || bpstat_should_step ())
empty_stmt|;
name|thread_step_needed
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|HPUXHPPA
comment|/* We'll update this if& when we switch to a new thread. */
name|switched_from_inferior_pid
operator|=
name|inferior_pid
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
literal|1
condition|)
block|{
specifier|extern
name|int
name|overlay_cache_invalid
decl_stmt|;
comment|/* declared in symfile.h */
name|overlay_cache_invalid
operator|=
literal|1
expr_stmt|;
comment|/* We have to invalidate the registers BEFORE calling target_wait because 	 they can be loaded from the target while in target_wait.  This makes 	 remote debugging a bit more efficient for those targets that provide 	 critical registers as part of their normal status mechanism. */
name|registers_changed
argument_list|()
expr_stmt|;
if|if
condition|(
name|target_wait_hook
condition|)
name|pid
operator|=
name|target_wait_hook
argument_list|(
operator|-
literal|1
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
else|else
name|pid
operator|=
name|target_wait
argument_list|(
operator|-
literal|1
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
comment|/* Since we've done a wait, we have a new event.  Don't carry          over any expectations about needing to step over a          breakpoint. */
name|thread_step_needed
operator|=
literal|0
expr_stmt|;
comment|/* See comments where a TARGET_WAITKIND_SYSCALL_RETURN event is          serviced in this loop, below. */
if|if
condition|(
name|enable_hw_watchpoints_after_wait
condition|)
block|{
name|TARGET_ENABLE_HW_WATCHPOINTS
argument_list|(
name|inferior_pid
argument_list|)
expr_stmt|;
name|enable_hw_watchpoints_after_wait
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_NONSTEPPABLE_WATCHPOINT
name|stepped_after_stopped_by_watchpoint
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* Gross.         We goto this label from elsewhere in wait_for_inferior when we want        to continue the main loop without calling "wait" and trashing the        waitstatus contained in W.  */
name|have_waited
label|:
name|flush_cached_frames
argument_list|()
expr_stmt|;
comment|/* If it's a new process, add it to the thread database */
name|new_thread_event
operator|=
operator|(
operator|(
name|pid
operator|!=
name|inferior_pid
operator|)
operator|&&
operator|!
name|in_thread_list
argument_list|(
name|pid
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|w
operator|.
name|kind
operator|!=
name|TARGET_WAITKIND_EXITED
operator|&&
name|w
operator|.
name|kind
operator|!=
name|TARGET_WAITKIND_SIGNALLED
operator|&&
name|new_thread_event
condition|)
block|{
name|add_thread
argument_list|(
name|pid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HPUXHPPA
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"[New %s]\n"
argument_list|,
name|target_pid_or_tid_to_str
argument_list|(
name|pid
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf_filtered
argument_list|(
literal|"[New %s]\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|pid
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* NOTE: This block is ONLY meant to be invoked in case of a 	     "thread creation event"!  If it is invoked for any other 	     sort of event (such as a new thread landing on a breakpoint), 	     the event will be discarded, which is almost certainly 	     a bad thing! 	 	     To avoid this, the low-level module (eg. target_wait) 	     should call in_thread_list and add_thread, so that the 	     new thread is known by the time we get here.  */
comment|/* We may want to consider not doing a resume here in order 	     to give the user a chance to play with the new thread. 	     It might be good to make that a user-settable option.  */
comment|/* At this point, all threads are stopped (happens 	     automatically in either the OS or the native code). 	     Therefore we need to continue all threads in order to 	     make progress.  */
block|target_resume (-1, 0, TARGET_SIGNAL_0); 	  continue;
endif|#
directive|endif
block|}
switch|switch
condition|(
name|w
operator|.
name|kind
condition|)
block|{
case|case
name|TARGET_WAITKIND_LOADED
case|:
comment|/* Ignore gracefully during startup of the inferior, as it 	     might be the shell which has just loaded some objects, 	     otherwise add the symbols for the newly loaded objects.  */
ifdef|#
directive|ifdef
name|SOLIB_ADD
if|if
condition|(
operator|!
name|stop_soon_quietly
condition|)
block|{
specifier|extern
name|int
name|auto_solib_add
decl_stmt|;
comment|/* Remove breakpoints, SOLIB_ADD might adjust 		 breakpoint addresses via breakpoint_re_set.  */
if|if
condition|(
name|breakpoints_inserted
condition|)
name|remove_breakpoints
argument_list|()
expr_stmt|;
comment|/* Check for any newly added shared libraries if we're 		 supposed to be adding them automatically.  */
if|if
condition|(
name|auto_solib_add
condition|)
block|{
comment|/* Switch terminal for any messages produced by 		     breakpoint_re_set.  */
name|target_terminal_ours_for_output
argument_list|()
expr_stmt|;
name|SOLIB_ADD
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|target_terminal_inferior
argument_list|()
expr_stmt|;
block|}
comment|/* Reinsert breakpoints and continue.  */
if|if
condition|(
name|breakpoints_inserted
condition|)
name|insert_breakpoints
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|resume
argument_list|(
literal|0
argument_list|,
name|TARGET_SIGNAL_0
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|TARGET_WAITKIND_SPURIOUS
case|:
name|resume
argument_list|(
literal|0
argument_list|,
name|TARGET_SIGNAL_0
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|TARGET_WAITKIND_EXITED
case|:
name|target_terminal_ours
argument_list|()
expr_stmt|;
comment|/* Must do this before mourn anyway */
name|annotate_exited
argument_list|(
name|w
operator|.
name|value
operator|.
name|integer
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|.
name|value
operator|.
name|integer
condition|)
name|printf_filtered
argument_list|(
literal|"\nProgram exited with code 0%o.\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|w
operator|.
name|value
operator|.
name|integer
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"\nProgram exited normally.\n"
argument_list|)
expr_stmt|;
comment|/* Record the exit code in the convenience variable $_exitcode, so 	     that the user can inspect this again later.  */
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"_exitcode"
argument_list|)
argument_list|,
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|w
operator|.
name|value
operator|.
name|integer
argument_list|)
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|target_mourn_inferior
argument_list|()
expr_stmt|;
name|singlestep_breakpoints_inserted_p
operator|=
literal|0
expr_stmt|;
comment|/*SOFTWARE_SINGLE_STEP_P*/
name|stop_print_frame
operator|=
literal|0
expr_stmt|;
goto|goto
name|stop_stepping
goto|;
case|case
name|TARGET_WAITKIND_SIGNALLED
case|:
name|stop_print_frame
operator|=
literal|0
expr_stmt|;
name|stop_signal
operator|=
name|w
operator|.
name|value
operator|.
name|sig
expr_stmt|;
name|target_terminal_ours
argument_list|()
expr_stmt|;
comment|/* Must do this before mourn anyway */
name|annotate_signalled
argument_list|()
expr_stmt|;
comment|/* This looks pretty bogus to me.  Doesn't TARGET_WAITKIND_SIGNALLED 	     mean it is already dead?  This has been here since GDB 2.8, so 	     perhaps it means rms didn't understand unix waitstatuses? 	     For the moment I'm just kludging around this in remote.c 	     rather than trying to change it here --kingdon, 5 Dec 1994.  */
name|target_kill
argument_list|()
expr_stmt|;
comment|/* kill mourns as well */
name|printf_filtered
argument_list|(
literal|"\nProgram terminated with signal "
argument_list|)
expr_stmt|;
name|annotate_signal_name
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s"
argument_list|,
name|target_signal_to_name
argument_list|(
name|stop_signal
argument_list|)
argument_list|)
expr_stmt|;
name|annotate_signal_name_end
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|annotate_signal_string
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s"
argument_list|,
name|target_signal_to_string
argument_list|(
name|stop_signal
argument_list|)
argument_list|)
expr_stmt|;
name|annotate_signal_string_end
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"The program no longer exists.\n"
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|singlestep_breakpoints_inserted_p
operator|=
literal|0
expr_stmt|;
comment|/*SOFTWARE_SINGLE_STEP_P*/
goto|goto
name|stop_stepping
goto|;
comment|/* The following are the only cases in which we keep going;            the above cases end in a continue or goto. */
case|case
name|TARGET_WAITKIND_FORKED
case|:
name|stop_signal
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
name|pending_follow
operator|.
name|kind
operator|=
name|w
operator|.
name|kind
expr_stmt|;
comment|/* Ignore fork events reported for the parent; we're only              interested in reacting to forks of the child.  Note that              we expect the child's fork event to be available if we              waited for it now. */
if|if
condition|(
name|inferior_pid
operator|==
name|pid
condition|)
block|{
name|pending_follow
operator|.
name|fork_event
operator|.
name|saw_parent_fork
operator|=
literal|1
expr_stmt|;
name|pending_follow
operator|.
name|fork_event
operator|.
name|parent_pid
operator|=
name|pid
expr_stmt|;
name|pending_follow
operator|.
name|fork_event
operator|.
name|child_pid
operator|=
name|w
operator|.
name|value
operator|.
name|related_pid
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|pending_follow
operator|.
name|fork_event
operator|.
name|saw_child_fork
operator|=
literal|1
expr_stmt|;
name|pending_follow
operator|.
name|fork_event
operator|.
name|child_pid
operator|=
name|pid
expr_stmt|;
name|pending_follow
operator|.
name|fork_event
operator|.
name|parent_pid
operator|=
name|w
operator|.
name|value
operator|.
name|related_pid
expr_stmt|;
block|}
name|stop_pc
operator|=
name|read_pc_pid
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|saved_inferior_pid
operator|=
name|inferior_pid
expr_stmt|;
name|inferior_pid
operator|=
name|pid
expr_stmt|;
name|stop_bpstat
operator|=
name|bpstat_stop_status
argument_list|(
operator|&
name|stop_pc
argument_list|,
if|#
directive|if
name|DECR_PC_AFTER_BREAK
operator|(
name|prev_pc
operator|!=
name|stop_pc
operator|-
name|DECR_PC_AFTER_BREAK
operator|&&
name|CURRENTLY_STEPPING
argument_list|()
operator|)
else|#
directive|else
comment|/* DECR_PC_AFTER_BREAK zero */
literal|0
endif|#
directive|endif
comment|/* DECR_PC_AFTER_BREAK zero */
argument_list|)
expr_stmt|;
name|random_signal
operator|=
operator|!
name|bpstat_explains_signal
argument_list|(
name|stop_bpstat
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
name|saved_inferior_pid
expr_stmt|;
goto|goto
name|process_event_stop_test
goto|;
comment|/* If this a platform which doesn't allow a debugger to touch a            vfork'd inferior until after it exec's, then we'd best keep            our fingers entirely off the inferior, other than continuing            it.  This has the unfortunate side-effect that catchpoints            of vforks will be ignored.  But since the platform doesn't            allow the inferior be touched at vfork time, there's really            little choice. */
case|case
name|TARGET_WAITKIND_VFORKED
case|:
name|stop_signal
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
name|pending_follow
operator|.
name|kind
operator|=
name|w
operator|.
name|kind
expr_stmt|;
comment|/* Is this a vfork of the parent?  If so, then give any              vfork catchpoints a chance to trigger now.  (It's              dangerous to do so if the child canot be touched until              it execs, and the child has not yet exec'd.  We probably              should warn the user to that effect when the catchpoint              triggers...) */
if|if
condition|(
name|pid
operator|==
name|inferior_pid
condition|)
block|{
name|pending_follow
operator|.
name|fork_event
operator|.
name|saw_parent_fork
operator|=
literal|1
expr_stmt|;
name|pending_follow
operator|.
name|fork_event
operator|.
name|parent_pid
operator|=
name|pid
expr_stmt|;
name|pending_follow
operator|.
name|fork_event
operator|.
name|child_pid
operator|=
name|w
operator|.
name|value
operator|.
name|related_pid
expr_stmt|;
block|}
comment|/* If we've seen the child's vfork event but cannot really touch              the child until it execs, then we must continue the child now.              Else, give any vfork catchpoints a chance to trigger now. */
else|else
block|{
name|pending_follow
operator|.
name|fork_event
operator|.
name|saw_child_fork
operator|=
literal|1
expr_stmt|;
name|pending_follow
operator|.
name|fork_event
operator|.
name|child_pid
operator|=
name|pid
expr_stmt|;
name|pending_follow
operator|.
name|fork_event
operator|.
name|parent_pid
operator|=
name|w
operator|.
name|value
operator|.
name|related_pid
expr_stmt|;
name|target_post_startup_inferior
argument_list|(
name|pending_follow
operator|.
name|fork_event
operator|.
name|child_pid
argument_list|)
expr_stmt|;
name|follow_vfork_when_exec
operator|=
operator|!
name|target_can_follow_vfork_prior_to_exec
argument_list|()
expr_stmt|;
if|if
condition|(
name|follow_vfork_when_exec
condition|)
block|{
name|target_resume
argument_list|(
name|pid
argument_list|,
literal|0
argument_list|,
name|TARGET_SIGNAL_0
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|stop_pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
name|stop_bpstat
operator|=
name|bpstat_stop_status
argument_list|(
operator|&
name|stop_pc
argument_list|,
if|#
directive|if
name|DECR_PC_AFTER_BREAK
operator|(
name|prev_pc
operator|!=
name|stop_pc
operator|-
name|DECR_PC_AFTER_BREAK
operator|&&
name|CURRENTLY_STEPPING
argument_list|()
operator|)
else|#
directive|else
comment|/* DECR_PC_AFTER_BREAK zero */
literal|0
endif|#
directive|endif
comment|/* DECR_PC_AFTER_BREAK zero */
argument_list|)
expr_stmt|;
name|random_signal
operator|=
operator|!
name|bpstat_explains_signal
argument_list|(
name|stop_bpstat
argument_list|)
expr_stmt|;
goto|goto
name|process_event_stop_test
goto|;
case|case
name|TARGET_WAITKIND_EXECD
case|:
name|stop_signal
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
comment|/* Is this a target which reports multiple exec events per actual              call to exec()?  (HP-UX using ptrace does, for example.)  If so,              ignore all but the last one.  Just resume the exec'r, and wait              for the next exec event. */
if|if
condition|(
name|inferior_ignoring_leading_exec_events
condition|)
block|{
name|inferior_ignoring_leading_exec_events
operator|--
expr_stmt|;
if|if
condition|(
name|pending_follow
operator|.
name|kind
operator|==
name|TARGET_WAITKIND_VFORKED
condition|)
name|ENSURE_VFORKING_PARENT_REMAINS_STOPPED
argument_list|(
name|pending_follow
operator|.
name|fork_event
operator|.
name|parent_pid
argument_list|)
expr_stmt|;
name|target_resume
argument_list|(
name|pid
argument_list|,
literal|0
argument_list|,
name|TARGET_SIGNAL_0
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|inferior_ignoring_leading_exec_events
operator|=
name|target_reported_exec_events_per_exec_call
argument_list|()
operator|-
literal|1
expr_stmt|;
name|pending_follow
operator|.
name|execd_pathname
operator|=
name|savestring
argument_list|(
name|w
operator|.
name|value
operator|.
name|execd_pathname
argument_list|,
name|strlen
argument_list|(
name|w
operator|.
name|value
operator|.
name|execd_pathname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Did inferior_pid exec, or did a (possibly not-yet-followed)              child of a vfork exec?               ??rehrauer: This is unabashedly an HP-UX specific thing.  On              HP-UX, events associated with a vforking inferior come in              threes: a vfork event for the child (always first), followed              a vfork event for the parent and an exec event for the child.              The latter two can come in either order.               If we get the parent vfork event first, life's good: We follow              either the parent or child, and then the child's exec event is              a "don't care".               But if we get the child's exec event first, then we delay              responding to it until we handle the parent's vfork.  Because,              otherwise we can't satisfy a "catch vfork". */
if|if
condition|(
name|pending_follow
operator|.
name|kind
operator|==
name|TARGET_WAITKIND_VFORKED
condition|)
block|{
name|pending_follow
operator|.
name|fork_event
operator|.
name|saw_child_exec
operator|=
literal|1
expr_stmt|;
comment|/* On some targets, the child must be resumed before                  the parent vfork event is delivered.  A single-step                  suffices. */
if|if
condition|(
name|RESUME_EXECD_VFORKING_CHILD_TO_GET_PARENT_VFORK
argument_list|()
condition|)
name|target_resume
argument_list|(
name|pid
argument_list|,
literal|1
argument_list|,
name|TARGET_SIGNAL_0
argument_list|)
expr_stmt|;
comment|/* We expect the parent vfork event to be available now. */
continue|continue;
block|}
comment|/* This causes the eventpoints and symbol table to be reset.  Must              do this now, before trying to determine whether to stop. */
name|follow_exec
argument_list|(
name|inferior_pid
argument_list|,
name|pending_follow
operator|.
name|execd_pathname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pending_follow
operator|.
name|execd_pathname
argument_list|)
expr_stmt|;
name|stop_pc
operator|=
name|read_pc_pid
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|saved_inferior_pid
operator|=
name|inferior_pid
expr_stmt|;
name|inferior_pid
operator|=
name|pid
expr_stmt|;
name|stop_bpstat
operator|=
name|bpstat_stop_status
argument_list|(
operator|&
name|stop_pc
argument_list|,
if|#
directive|if
name|DECR_PC_AFTER_BREAK
operator|(
name|prev_pc
operator|!=
name|stop_pc
operator|-
name|DECR_PC_AFTER_BREAK
operator|&&
name|CURRENTLY_STEPPING
argument_list|()
operator|)
else|#
directive|else
comment|/* DECR_PC_AFTER_BREAK zero */
literal|0
endif|#
directive|endif
comment|/* DECR_PC_AFTER_BREAK zero */
argument_list|)
expr_stmt|;
name|random_signal
operator|=
operator|!
name|bpstat_explains_signal
argument_list|(
name|stop_bpstat
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
name|saved_inferior_pid
expr_stmt|;
goto|goto
name|process_event_stop_test
goto|;
comment|/* These syscall events are returned on HP-UX, as part of its            implementation of page-protection-based "hardware" watchpoints.            HP-UX has unfortunate interactions between page-protections and            some system calls.  Our solution is to disable hardware watches            when a system call is entered, and reenable them when the syscall            completes.  The downside of this is that we may miss the precise            point at which a watched piece of memory is modified.  "Oh well."             Note that we may have multiple threads running, which may each            enter syscalls at roughly the same time.  Since we don't have a            good notion currently of whether a watched piece of memory is            thread-private, we'd best not have any page-protections active            when any thread is in a syscall.  Thus, we only want to reenable            hardware watches when no threads are in a syscall.             Also, be careful not to try to gather much state about a thread            that's in a syscall.  It's frequently a losing proposition. */
case|case
name|TARGET_WAITKIND_SYSCALL_ENTRY
case|:
name|number_of_threads_in_syscalls
operator|++
expr_stmt|;
if|if
condition|(
name|number_of_threads_in_syscalls
operator|==
literal|1
condition|)
block|{
name|TARGET_DISABLE_HW_WATCHPOINTS
argument_list|(
name|inferior_pid
argument_list|)
expr_stmt|;
block|}
name|resume
argument_list|(
literal|0
argument_list|,
name|TARGET_SIGNAL_0
argument_list|)
expr_stmt|;
continue|continue;
comment|/* Before examining the threads further, step this thread to 	   get it entirely out of the syscall.  (We get notice of the 	   event when the thread is just on the verge of exiting a 	   syscall.  Stepping one instruction seems to get it back 	   into user code.)  	   Note that although the logical place to reenable h/w watches 	   is here, we cannot.  We cannot reenable them before stepping 	   the thread (this causes the next wait on the thread to hang).  	   Nor can we enable them after stepping until we've done a wait. 	   Thus, we simply set the flag enable_hw_watchpoints_after_wait 	   here, which will be serviced immediately after the target 	   is waited on. */
case|case
name|TARGET_WAITKIND_SYSCALL_RETURN
case|:
name|target_resume
argument_list|(
name|pid
argument_list|,
literal|1
argument_list|,
name|TARGET_SIGNAL_0
argument_list|)
expr_stmt|;
if|if
condition|(
name|number_of_threads_in_syscalls
operator|>
literal|0
condition|)
block|{
name|number_of_threads_in_syscalls
operator|--
expr_stmt|;
name|enable_hw_watchpoints_after_wait
operator|=
operator|(
name|number_of_threads_in_syscalls
operator|==
literal|0
operator|)
expr_stmt|;
block|}
continue|continue;
case|case
name|TARGET_WAITKIND_STOPPED
case|:
name|stop_signal
operator|=
name|w
operator|.
name|value
operator|.
name|sig
expr_stmt|;
break|break;
block|}
comment|/* We may want to consider not doing a resume here in order to give          the user a chance to play with the new thread.  It might be good          to make that a user-settable option.  */
comment|/* At this point, all threads are stopped (happens automatically in          either the OS or the native code).  Therefore we need to continue          all threads in order to make progress.  */
if|if
condition|(
name|new_thread_event
condition|)
block|{
name|target_resume
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|TARGET_SIGNAL_0
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|stop_pc
operator|=
name|read_pc_pid
argument_list|(
name|pid
argument_list|)
expr_stmt|;
comment|/* See if a thread hit a thread-specific breakpoint that was meant for 	 another thread.  If so, then step that thread past the breakpoint, 	 and continue it.  */
if|if
condition|(
name|stop_signal
operator|==
name|TARGET_SIGNAL_TRAP
condition|)
block|{
if|if
condition|(
name|SOFTWARE_SINGLE_STEP_P
operator|&&
name|singlestep_breakpoints_inserted_p
condition|)
name|random_signal
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|breakpoints_inserted
operator|&&
name|breakpoint_here_p
argument_list|(
name|stop_pc
operator|-
name|DECR_PC_AFTER_BREAK
argument_list|)
condition|)
block|{
name|random_signal
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|breakpoint_thread_match
argument_list|(
name|stop_pc
operator|-
name|DECR_PC_AFTER_BREAK
argument_list|,
name|pid
argument_list|)
condition|)
block|{
name|int
name|remove_status
decl_stmt|;
comment|/* Saw a breakpoint, but it was hit by the wrong thread. 		       Just continue. */
name|write_pc_pid
argument_list|(
name|stop_pc
operator|-
name|DECR_PC_AFTER_BREAK
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|remove_status
operator|=
name|remove_breakpoints
argument_list|()
expr_stmt|;
comment|/* Did we fail to remove breakpoints?  If so, try                        to set the PC past the bp.  (There's at least                        one situation in which we can fail to remove                        the bp's: On HP-UX's that use ttrace, we can't                        change the address space of a vforking child                        process until the child exits (well, okay, not                        then either :-) or execs. */
if|if
condition|(
name|remove_status
operator|!=
literal|0
condition|)
block|{
name|write_pc_pid
argument_list|(
name|stop_pc
operator|-
name|DECR_PC_AFTER_BREAK
operator|+
literal|4
argument_list|,
name|pid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Single step */
name|target_resume
argument_list|(
name|pid
argument_list|,
literal|1
argument_list|,
name|TARGET_SIGNAL_0
argument_list|)
expr_stmt|;
comment|/* FIXME: What if a signal arrives instead of the 			   single-step happening?  */
if|if
condition|(
name|target_wait_hook
condition|)
name|target_wait_hook
argument_list|(
name|pid
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
else|else
name|target_wait
argument_list|(
name|pid
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
name|insert_breakpoints
argument_list|()
expr_stmt|;
block|}
comment|/* We need to restart all the threads now.  */
name|target_resume
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|TARGET_SIGNAL_0
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|/* This breakpoint matches--either it is the right 		       thread or it's a generic breakpoint for all threads. 		       Remember that we'll need to step just _this_ thread 		       on any following user continuation! */
name|thread_step_needed
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
else|else
name|random_signal
operator|=
literal|1
expr_stmt|;
comment|/* See if something interesting happened to the non-current thread.  If          so, then switch to that thread, and eventually give control back to 	 the user.           Note that if there's any kind of pending follow (i.e., of a fork,          vfork or exec), we don't want to do this now.  Rather, we'll let          the next resume handle it. */
if|if
condition|(
operator|(
name|pid
operator|!=
name|inferior_pid
operator|)
operator|&&
operator|(
name|pending_follow
operator|.
name|kind
operator|==
name|TARGET_WAITKIND_SPURIOUS
operator|)
condition|)
block|{
name|int
name|printed
init|=
literal|0
decl_stmt|;
comment|/* If it's a random signal for a non-current thread, notify user 	     if he's expressed an interest. */
if|if
condition|(
name|random_signal
operator|&&
name|signal_print
index|[
name|stop_signal
index|]
condition|)
block|{
comment|/* ??rehrauer: I don't understand the rationale for this code.  If the    inferior will stop as a result of this signal, then the act of handling    the stop ought to print a message that's couches the stoppage in user    terms, e.g., "Stopped for breakpoint/watchpoint".  If the inferior    won't stop as a result of the signal -- i.e., if the signal is merely    a side-effect of something GDB's doing "under the covers" for the    user, such as stepping threads over a breakpoint they shouldn't stop    for -- then the message seems to be a serious annoyance at best.     For now, remove the message altogether. */
if|#
directive|if
literal|0
block|printed = 1; 	      target_terminal_ours_for_output (); 	      printf_filtered ("\nProgram received signal %s, %s.\n", 			       target_signal_to_name (stop_signal), 			       target_signal_to_string (stop_signal)); 	      gdb_flush (gdb_stdout);
endif|#
directive|endif
block|}
comment|/* If it's not SIGTRAP and not a signal we want to stop for, then 	     continue the thread. */
if|if
condition|(
name|stop_signal
operator|!=
name|TARGET_SIGNAL_TRAP
operator|&&
operator|!
name|signal_stop
index|[
name|stop_signal
index|]
condition|)
block|{
if|if
condition|(
name|printed
condition|)
name|target_terminal_inferior
argument_list|()
expr_stmt|;
comment|/* Clear the signal if it should not be passed.  */
if|if
condition|(
name|signal_program
index|[
name|stop_signal
index|]
operator|==
literal|0
condition|)
name|stop_signal
operator|=
name|TARGET_SIGNAL_0
expr_stmt|;
name|target_resume
argument_list|(
name|pid
argument_list|,
literal|0
argument_list|,
name|stop_signal
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* It's a SIGTRAP or a signal we're interested in.  Switch threads, 	     and fall into the rest of wait_for_inferior().  */
comment|/* Save infrun state for the old thread.  */
name|save_infrun_state
argument_list|(
name|inferior_pid
argument_list|,
name|prev_pc
argument_list|,
name|prev_func_start
argument_list|,
name|prev_func_name
argument_list|,
name|trap_expected
argument_list|,
name|step_resume_breakpoint
argument_list|,
name|through_sigtramp_breakpoint
argument_list|,
name|step_range_start
argument_list|,
name|step_range_end
argument_list|,
name|step_frame_address
argument_list|,
name|handling_longjmp
argument_list|,
name|another_trap
argument_list|,
name|stepping_through_solib_after_catch
argument_list|,
name|stepping_through_solib_catchpoints
argument_list|,
name|stepping_through_sigtramp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HPUXHPPA
name|switched_from_inferior_pid
operator|=
name|inferior_pid
expr_stmt|;
endif|#
directive|endif
name|inferior_pid
operator|=
name|pid
expr_stmt|;
comment|/* Load infrun state for the new thread.  */
name|load_infrun_state
argument_list|(
name|inferior_pid
argument_list|,
operator|&
name|prev_pc
argument_list|,
operator|&
name|prev_func_start
argument_list|,
operator|&
name|prev_func_name
argument_list|,
operator|&
name|trap_expected
argument_list|,
operator|&
name|step_resume_breakpoint
argument_list|,
operator|&
name|through_sigtramp_breakpoint
argument_list|,
operator|&
name|step_range_start
argument_list|,
operator|&
name|step_range_end
argument_list|,
operator|&
name|step_frame_address
argument_list|,
operator|&
name|handling_longjmp
argument_list|,
operator|&
name|another_trap
argument_list|,
operator|&
name|stepping_through_solib_after_catch
argument_list|,
operator|&
name|stepping_through_solib_catchpoints
argument_list|,
operator|&
name|stepping_through_sigtramp
argument_list|)
expr_stmt|;
if|if
condition|(
name|context_hook
condition|)
name|context_hook
argument_list|(
name|pid_to_thread_id
argument_list|(
name|pid
argument_list|)
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"[Switching to %s]\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|pid
argument_list|)
argument_list|)
expr_stmt|;
name|flush_cached_frames
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|SOFTWARE_SINGLE_STEP_P
operator|&&
name|singlestep_breakpoints_inserted_p
condition|)
block|{
comment|/* Pull the single step breakpoints out of the target. */
name|SOFTWARE_SINGLE_STEP
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|singlestep_breakpoints_inserted_p
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If PC is pointing at a nullified instruction, then step beyond 	 it so that the user won't be confused when GDB appears to be ready 	 to execute it. */
if|#
directive|if
literal|0
comment|/* XXX DEBUG */
block|printf ("infrun.c:1607: pc = 0x%x\n", read_pc ());
endif|#
directive|endif
comment|/*      if (INSTRUCTION_NULLIFIED&& CURRENTLY_STEPPING ()) */
if|if
condition|(
name|INSTRUCTION_NULLIFIED
condition|)
block|{
name|struct
name|target_waitstatus
name|tmpstatus
decl_stmt|;
if|#
directive|if
literal|0
block|all_registers_info ((char *) 0, 0);
endif|#
directive|endif
name|registers_changed
argument_list|()
expr_stmt|;
name|target_resume
argument_list|(
name|pid
argument_list|,
literal|1
argument_list|,
name|TARGET_SIGNAL_0
argument_list|)
expr_stmt|;
comment|/* We may have received a signal that we want to pass to 	     the inferior; therefore, we must not clobber the waitstatus 	     in W.  So we call wait ourselves, then continue the loop 	     at the "have_waited" label.  */
if|if
condition|(
name|target_wait_hook
condition|)
name|target_wait_hook
argument_list|(
name|pid
argument_list|,
operator|&
name|tmpstatus
argument_list|)
expr_stmt|;
else|else
name|target_wait
argument_list|(
name|pid
argument_list|,
operator|&
name|tmpstatus
argument_list|)
expr_stmt|;
goto|goto
name|have_waited
goto|;
block|}
ifdef|#
directive|ifdef
name|HAVE_STEPPABLE_WATCHPOINT
comment|/* It may not be necessary to disable the watchpoint to stop over 	 it.  For example, the PA can (with some kernel cooperation) 	 single step over a watchpoint without disabling the watchpoint.  */
if|if
condition|(
name|STOPPED_BY_WATCHPOINT
argument_list|(
name|w
argument_list|)
condition|)
block|{
name|resume
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_NONSTEPPABLE_WATCHPOINT
comment|/* It is far more common to need to disable a watchpoint 	 to step the inferior over it.  FIXME.  What else might 	 a debug register or page protection watchpoint scheme need 	 here?  */
if|if
condition|(
name|STOPPED_BY_WATCHPOINT
argument_list|(
name|w
argument_list|)
condition|)
block|{
comment|/* At this point, we are stopped at an instruction which has attempted to write    to a piece of memory under control of a watchpoint.  The instruction hasn't    actually executed yet.  If we were to evaluate the watchpoint expression    now, we would get the old value, and therefore no change would seem to have    occurred.     In order to make watchpoints work `right', we really need to complete the    memory write, and then evaluate the watchpoint expression.  The following    code does that by removing the watchpoint (actually, all watchpoints and    breakpoints), single-stepping the target, re-inserting watchpoints, and then    falling through to let normal single-step processing handle proceed.  Since    this includes evaluating watchpoints, things will come to a stop in the    correct manner.  */
name|write_pc
argument_list|(
name|stop_pc
operator|-
name|DECR_PC_AFTER_BREAK
argument_list|)
expr_stmt|;
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|registers_changed
argument_list|()
expr_stmt|;
name|target_resume
argument_list|(
name|pid
argument_list|,
literal|1
argument_list|,
name|TARGET_SIGNAL_0
argument_list|)
expr_stmt|;
comment|/* Single step */
if|if
condition|(
name|target_wait_hook
condition|)
name|target_wait_hook
argument_list|(
name|pid
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
else|else
name|target_wait
argument_list|(
name|pid
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
name|insert_breakpoints
argument_list|()
expr_stmt|;
comment|/* FIXME-maybe: is this cleaner than setting a flag?  Does it 	     handle things like signals arriving and other things happening 	     in combination correctly?  */
name|stepped_after_stopped_by_watchpoint
operator|=
literal|1
expr_stmt|;
goto|goto
name|have_waited
goto|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_CONTINUABLE_WATCHPOINT
comment|/* It may be possible to simply continue after a watchpoint.  */
name|STOPPED_BY_WATCHPOINT
argument_list|(
name|w
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stop_func_start
operator|=
literal|0
expr_stmt|;
name|stop_func_end
operator|=
literal|0
expr_stmt|;
name|stop_func_name
operator|=
literal|0
expr_stmt|;
comment|/* Don't care about return value; stop_func_start and stop_func_name 	 will both be 0 if it doesn't work.  */
name|find_pc_partial_function
argument_list|(
name|stop_pc
argument_list|,
operator|&
name|stop_func_name
argument_list|,
operator|&
name|stop_func_start
argument_list|,
operator|&
name|stop_func_end
argument_list|)
expr_stmt|;
name|stop_func_start
operator|+=
name|FUNCTION_START_OFFSET
expr_stmt|;
name|another_trap
operator|=
literal|0
expr_stmt|;
name|bpstat_clear
argument_list|(
operator|&
name|stop_bpstat
argument_list|)
expr_stmt|;
name|stop_step
operator|=
literal|0
expr_stmt|;
name|stop_stack_dummy
operator|=
literal|0
expr_stmt|;
name|stop_print_frame
operator|=
literal|1
expr_stmt|;
name|random_signal
operator|=
literal|0
expr_stmt|;
name|stopped_by_random_signal
operator|=
literal|0
expr_stmt|;
name|breakpoints_failed
operator|=
literal|0
expr_stmt|;
comment|/* Look at the cause of the stop, and decide what to do. 	 The alternatives are: 	 1) break; to really stop and return to the debugger, 	 2) drop through to start up again 	 (set another_trap to 1 to single step once) 	 3) set random_signal to 1, and the decision between 1 and 2 	 will be made according to the signal handling tables.  */
comment|/* First, distinguish signals caused by the debugger from signals 	 that have to do with the program's own actions. 	 Note that breakpoint insns may cause SIGTRAP or SIGILL 	 or SIGEMT, depending on the operating system version. 	 Here we detect when a SIGILL or SIGEMT is really a breakpoint 	 and change it to SIGTRAP.  */
if|if
condition|(
name|stop_signal
operator|==
name|TARGET_SIGNAL_TRAP
operator|||
operator|(
name|breakpoints_inserted
operator|&&
operator|(
name|stop_signal
operator|==
name|TARGET_SIGNAL_ILL
operator|||
name|stop_signal
operator|==
name|TARGET_SIGNAL_EMT
operator|)
operator|)
operator|||
name|stop_soon_quietly
condition|)
block|{
if|if
condition|(
name|stop_signal
operator|==
name|TARGET_SIGNAL_TRAP
operator|&&
name|stop_after_trap
condition|)
block|{
name|stop_print_frame
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|stop_soon_quietly
condition|)
break|break;
comment|/* Don't even think about breakpoints 	     if just proceeded over a breakpoint.  	     However, if we are trying to proceed over a breakpoint 	     and end up in sigtramp, then through_sigtramp_breakpoint 	     will be set and we should check whether we've hit the 	     step breakpoint.  */
if|if
condition|(
name|stop_signal
operator|==
name|TARGET_SIGNAL_TRAP
operator|&&
name|trap_expected
operator|&&
name|through_sigtramp_breakpoint
operator|==
name|NULL
condition|)
name|bpstat_clear
argument_list|(
operator|&
name|stop_bpstat
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* See if there is a breakpoint at the current PC.  */
name|stop_bpstat
operator|=
name|bpstat_stop_status
argument_list|(
operator|&
name|stop_pc
argument_list|,
operator|(
name|DECR_PC_AFTER_BREAK
condition|?
comment|/* Notice the case of stepping through a jump 		    that lands just after a breakpoint. 		    Don't confuse that with hitting the breakpoint. 		    What we check for is that 1) stepping is going on 		    and 2) the pc before the last insn does not match 		    the address of the breakpoint before the current pc 		    and 3) we didn't hit a breakpoint in a signal handler 		    without an intervening stop in sigtramp, which is 		    detected by a new stack pointer value below 		    any usual function calling stack adjustments.  */
operator|(
name|CURRENTLY_STEPPING
argument_list|()
operator|&&
name|prev_pc
operator|!=
name|stop_pc
operator|-
name|DECR_PC_AFTER_BREAK
operator|&&
operator|!
operator|(
name|step_range_end
operator|&&
name|INNER_THAN
argument_list|(
name|read_sp
argument_list|()
argument_list|,
operator|(
name|step_sp
operator|-
literal|16
operator|)
argument_list|)
operator|)
operator|)
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* Following in case break condition called a 		 function.  */
name|stop_print_frame
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|stop_signal
operator|==
name|TARGET_SIGNAL_TRAP
condition|)
name|random_signal
operator|=
operator|!
operator|(
name|bpstat_explains_signal
argument_list|(
name|stop_bpstat
argument_list|)
operator|||
name|trap_expected
ifndef|#
directive|ifndef
name|CALL_DUMMY_BREAKPOINT_OFFSET
operator|||
name|PC_IN_CALL_DUMMY
argument_list|(
name|stop_pc
argument_list|,
name|read_sp
argument_list|()
argument_list|,
name|FRAME_FP
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
argument_list|)
endif|#
directive|endif
comment|/* No CALL_DUMMY_BREAKPOINT_OFFSET.  */
operator|||
operator|(
name|step_range_end
operator|&&
name|step_resume_breakpoint
operator|==
name|NULL
operator|)
operator|)
expr_stmt|;
else|else
block|{
name|random_signal
operator|=
operator|!
operator|(
name|bpstat_explains_signal
argument_list|(
name|stop_bpstat
argument_list|)
comment|/* End of a stack dummy.  Some systems (e.g. Sony 		       news) give another signal besides SIGTRAP, 		       so check here as well as above.  */
ifndef|#
directive|ifndef
name|CALL_DUMMY_BREAKPOINT_OFFSET
operator|||
name|PC_IN_CALL_DUMMY
argument_list|(
name|stop_pc
argument_list|,
name|read_sp
argument_list|()
argument_list|,
name|FRAME_FP
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
argument_list|)
endif|#
directive|endif
comment|/* No CALL_DUMMY_BREAKPOINT_OFFSET.  */
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|random_signal
condition|)
name|stop_signal
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
block|}
block|}
comment|/* When we reach this point, we've pretty much decided          that the reason for stopping must've been a random          (unexpected) signal. */
else|else
name|random_signal
operator|=
literal|1
expr_stmt|;
comment|/* If a fork, vfork or exec event was seen, then there are two          possible responses we can make:           1. If a catchpoint triggers for the event (random_signal == 0),             then we must stop now and issue a prompt.  We will resume             the inferior when the user tells us to.          2. If no catchpoint triggers for the event (random_signal == 1),             then we must resume the inferior now and keep checking.           In either case, we must take appropriate steps to "follow" the          the fork/vfork/exec when the inferior is resumed.  For example,          if follow-fork-mode is "child", then we must detach from the          parent inferior and follow the new child inferior.           In either case, setting pending_follow causes the next resume()          to take the appropriate following action. */
name|process_event_stop_test
label|:
if|if
condition|(
name|w
operator|.
name|kind
operator|==
name|TARGET_WAITKIND_FORKED
condition|)
block|{
if|if
condition|(
name|random_signal
condition|)
comment|/* I.e., no catchpoint triggered for this. */
block|{
name|trap_expected
operator|=
literal|1
expr_stmt|;
name|stop_signal
operator|=
name|TARGET_SIGNAL_0
expr_stmt|;
goto|goto
name|keep_going
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|w
operator|.
name|kind
operator|==
name|TARGET_WAITKIND_VFORKED
condition|)
block|{
if|if
condition|(
name|random_signal
condition|)
comment|/* I.e., no catchpoint triggered for this. */
block|{
name|stop_signal
operator|=
name|TARGET_SIGNAL_0
expr_stmt|;
goto|goto
name|keep_going
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|w
operator|.
name|kind
operator|==
name|TARGET_WAITKIND_EXECD
condition|)
block|{
name|pending_follow
operator|.
name|kind
operator|=
name|w
operator|.
name|kind
expr_stmt|;
if|if
condition|(
name|random_signal
condition|)
comment|/* I.e., no catchpoint triggered for this. */
block|{
name|trap_expected
operator|=
literal|1
expr_stmt|;
name|stop_signal
operator|=
name|TARGET_SIGNAL_0
expr_stmt|;
goto|goto
name|keep_going
goto|;
block|}
block|}
comment|/* For the program's own signals, act according to 	 the signal handling tables.  */
if|if
condition|(
name|random_signal
condition|)
block|{
comment|/* Signal not for debugging purposes.  */
name|int
name|printed
init|=
literal|0
decl_stmt|;
name|stopped_by_random_signal
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|signal_print
index|[
name|stop_signal
index|]
condition|)
block|{
name|printed
operator|=
literal|1
expr_stmt|;
name|target_terminal_ours_for_output
argument_list|()
expr_stmt|;
name|annotate_signal
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\nProgram received signal "
argument_list|)
expr_stmt|;
name|annotate_signal_name
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s"
argument_list|,
name|target_signal_to_name
argument_list|(
name|stop_signal
argument_list|)
argument_list|)
expr_stmt|;
name|annotate_signal_name_end
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
name|annotate_signal_string
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s"
argument_list|,
name|target_signal_to_string
argument_list|(
name|stop_signal
argument_list|)
argument_list|)
expr_stmt|;
name|annotate_signal_string_end
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|signal_stop
index|[
name|stop_signal
index|]
condition|)
break|break;
comment|/* If not going to stop, give terminal back 	     if we took it away.  */
elseif|else
if|if
condition|(
name|printed
condition|)
name|target_terminal_inferior
argument_list|()
expr_stmt|;
comment|/* Clear the signal if it should not be passed.  */
if|if
condition|(
name|signal_program
index|[
name|stop_signal
index|]
operator|==
literal|0
condition|)
name|stop_signal
operator|=
name|TARGET_SIGNAL_0
expr_stmt|;
comment|/* If we're in the middle of a "next" command, let the code for              stepping over a function handle this. pai/1997-09-10               A previous comment here suggested it was possible to change              this to jump to keep_going in all cases. */
if|if
condition|(
name|step_over_calls
operator|>
literal|0
condition|)
goto|goto
name|step_over_function
goto|;
else|else
goto|goto
name|check_sigtramp2
goto|;
block|}
comment|/* Handle cases caused by hitting a breakpoint.  */
block|{
name|CORE_ADDR
name|jmp_buf_pc
decl_stmt|;
name|struct
name|bpstat_what
name|what
decl_stmt|;
name|what
operator|=
name|bpstat_what
argument_list|(
name|stop_bpstat
argument_list|)
expr_stmt|;
if|if
condition|(
name|what
operator|.
name|call_dummy
condition|)
block|{
name|stop_stack_dummy
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|HP_OS_BUG
name|trap_expected_after_continue
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
switch|switch
condition|(
name|what
operator|.
name|main_action
condition|)
block|{
case|case
name|BPSTAT_WHAT_SET_LONGJMP_RESUME
case|:
comment|/* If we hit the breakpoint at longjmp, disable it for the 	       duration of this command.  Then, install a temporary 	       breakpoint at the target of the jmp_buf. */
name|disable_longjmp_breakpoint
argument_list|()
expr_stmt|;
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|breakpoints_inserted
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|GET_LONGJMP_TARGET
argument_list|(
operator|&
name|jmp_buf_pc
argument_list|)
condition|)
goto|goto
name|keep_going
goto|;
comment|/* Need to blow away step-resume breakpoint, as it 	       interferes with us */
if|if
condition|(
name|step_resume_breakpoint
operator|!=
name|NULL
condition|)
block|{
name|delete_breakpoint
argument_list|(
name|step_resume_breakpoint
argument_list|)
expr_stmt|;
name|step_resume_breakpoint
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Not sure whether we need to blow this away too, but probably 	       it is like the step-resume breakpoint.  */
if|if
condition|(
name|through_sigtramp_breakpoint
operator|!=
name|NULL
condition|)
block|{
name|delete_breakpoint
argument_list|(
name|through_sigtramp_breakpoint
argument_list|)
expr_stmt|;
name|through_sigtramp_breakpoint
operator|=
name|NULL
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* FIXME - Need to implement nested temporary breakpoints */
block|if (step_over_calls> 0) 	      set_longjmp_resume_breakpoint (jmp_buf_pc, 					     get_current_frame ()); 	    else
endif|#
directive|endif
comment|/* 0 */
name|set_longjmp_resume_breakpoint
argument_list|(
name|jmp_buf_pc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|handling_longjmp
operator|=
literal|1
expr_stmt|;
comment|/* FIXME */
goto|goto
name|keep_going
goto|;
case|case
name|BPSTAT_WHAT_CLEAR_LONGJMP_RESUME
case|:
case|case
name|BPSTAT_WHAT_CLEAR_LONGJMP_RESUME_SINGLE
case|:
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|breakpoints_inserted
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|/* FIXME - Need to implement nested temporary breakpoints */
block|if (step_over_calls&& (INNER_THAN (FRAME_FP (get_current_frame ()), 				step_frame_address))) 	      { 		another_trap = 1; 		goto keep_going; 	      }
endif|#
directive|endif
comment|/* 0 */
name|disable_longjmp_breakpoint
argument_list|()
expr_stmt|;
name|handling_longjmp
operator|=
literal|0
expr_stmt|;
comment|/* FIXME */
if|if
condition|(
name|what
operator|.
name|main_action
operator|==
name|BPSTAT_WHAT_CLEAR_LONGJMP_RESUME
condition|)
break|break;
comment|/* else fallthrough */
case|case
name|BPSTAT_WHAT_SINGLE
case|:
if|if
condition|(
name|breakpoints_inserted
condition|)
block|{
name|thread_step_needed
operator|=
literal|1
expr_stmt|;
name|remove_breakpoints
argument_list|()
expr_stmt|;
block|}
name|breakpoints_inserted
operator|=
literal|0
expr_stmt|;
name|another_trap
operator|=
literal|1
expr_stmt|;
comment|/* Still need to check other stuff, at least the case 	       where we are stepping and step out of the right range.  */
break|break;
case|case
name|BPSTAT_WHAT_STOP_NOISY
case|:
name|stop_print_frame
operator|=
literal|1
expr_stmt|;
comment|/* We are about to nuke the step_resume_breakpoint and 	       through_sigtramp_breakpoint via the cleanup chain, so 	       no need to worry about it here.  */
goto|goto
name|stop_stepping
goto|;
case|case
name|BPSTAT_WHAT_STOP_SILENT
case|:
name|stop_print_frame
operator|=
literal|0
expr_stmt|;
comment|/* We are about to nuke the step_resume_breakpoint and 	       through_sigtramp_breakpoint via the cleanup chain, so 	       no need to worry about it here.  */
goto|goto
name|stop_stepping
goto|;
case|case
name|BPSTAT_WHAT_STEP_RESUME
case|:
comment|/* This proably demands a more elegant solution, but, yeah                right...                 This function's use of the simple variable                step_resume_breakpoint doesn't seem to accomodate                simultaneously active step-resume bp's, although the                breakpoint list certainly can.                 If we reach here and step_resume_breakpoint is already                NULL, then apparently we have multiple active                step-resume bp's.  We'll just delete the breakpoint we                stopped at, and carry on.  */
if|if
condition|(
name|step_resume_breakpoint
operator|==
name|NULL
condition|)
block|{
name|step_resume_breakpoint
operator|=
name|bpstat_find_step_resume_breakpoint
argument_list|(
name|stop_bpstat
argument_list|)
expr_stmt|;
block|}
name|delete_breakpoint
argument_list|(
name|step_resume_breakpoint
argument_list|)
expr_stmt|;
name|step_resume_breakpoint
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|BPSTAT_WHAT_THROUGH_SIGTRAMP
case|:
if|if
condition|(
name|through_sigtramp_breakpoint
condition|)
name|delete_breakpoint
argument_list|(
name|through_sigtramp_breakpoint
argument_list|)
expr_stmt|;
name|through_sigtramp_breakpoint
operator|=
name|NULL
expr_stmt|;
comment|/* If were waiting for a trap, hitting the step_resume_break 	       doesn't count as getting it.  */
if|if
condition|(
name|trap_expected
condition|)
name|another_trap
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|BPSTAT_WHAT_CHECK_SHLIBS
case|:
case|case
name|BPSTAT_WHAT_CHECK_SHLIBS_RESUME_FROM_HOOK
case|:
ifdef|#
directive|ifdef
name|SOLIB_ADD
block|{
specifier|extern
name|int
name|auto_solib_add
decl_stmt|;
comment|/* Remove breakpoints, we eventually want to step over the 		 shlib event breakpoint, and SOLIB_ADD might adjust 		 breakpoint addresses via breakpoint_re_set.  */
if|if
condition|(
name|breakpoints_inserted
condition|)
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|breakpoints_inserted
operator|=
literal|0
expr_stmt|;
comment|/* Check for any newly added shared libraries if we're 		 supposed to be adding them automatically.  */
if|if
condition|(
name|auto_solib_add
condition|)
block|{
comment|/* Switch terminal for any messages produced by 		     breakpoint_re_set.  */
name|target_terminal_ours_for_output
argument_list|()
expr_stmt|;
name|SOLIB_ADD
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|target_terminal_inferior
argument_list|()
expr_stmt|;
block|}
comment|/* Try to reenable shared library breakpoints, additional 		 code segments in shared libraries might be mapped in now. */
name|re_enable_breakpoints_in_shlibs
argument_list|()
expr_stmt|;
comment|/* If requested, stop when the dynamic linker notifies 		 gdb of events.  This allows the user to get control 		 and place breakpoints in initializer routines for 		 dynamically loaded objects (among other things).  */
if|if
condition|(
name|stop_on_solib_events
condition|)
block|{
name|stop_print_frame
operator|=
literal|0
expr_stmt|;
goto|goto
name|stop_stepping
goto|;
block|}
comment|/* If we stopped due to an explicit catchpoint, then the                  (see above) call to SOLIB_ADD pulled in any symbols                  from a newly-loaded library, if appropriate.                   We do want the inferior to stop, but not where it is                  now, which is in the dynamic linker callback.  Rather,                  we would like it stop in the user's program, just after                  the call that caused this catchpoint to trigger.  That                  gives the user a more useful vantage from which to                  examine their program's state. */
elseif|else
if|if
condition|(
name|what
operator|.
name|main_action
operator|==
name|BPSTAT_WHAT_CHECK_SHLIBS_RESUME_FROM_HOOK
condition|)
block|{
comment|/* ??rehrauer: If I could figure out how to get the                      right return PC from here, we could just set a temp                      breakpoint and resume.  I'm not sure we can without                      cracking open the dld's shared libraries and sniffing                      their unwind tables and text/data ranges, and that's                      not a terribly portable notion.                       Until that time, we must step the inferior out of the                      dld callback, and also out of the dld itself (and any                      code or stubs in libdld.sl, such as "shl_load" and                      friends) until we reach non-dld code.  At that point,                      we can stop stepping. */
name|bpstat_get_triggered_catchpoints
argument_list|(
name|stop_bpstat
argument_list|,
operator|&
name|stepping_through_solib_catchpoints
argument_list|)
expr_stmt|;
name|stepping_through_solib_after_catch
operator|=
literal|1
expr_stmt|;
comment|/* Be sure to lift all breakpoints, so the inferior does                      actually step past this point... */
name|another_trap
operator|=
literal|1
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* We want to step over this breakpoint, then keep going.  */
name|another_trap
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
break|break;
case|case
name|BPSTAT_WHAT_LAST
case|:
comment|/* Not a real code, but listed here to shut up gcc -Wall.  */
case|case
name|BPSTAT_WHAT_KEEP_CHECKING
case|:
break|break;
block|}
block|}
comment|/* We come here if we hit a breakpoint but should not 	 stop for it.  Possibly we also were stepping 	 and should stop for that.  So fall through and 	 test for stepping.  But, if not stepping, 	 do not stop.  */
comment|/* Are we stepping to get the inferior out of the dynamic          linker's hook (and possibly the dld itself) after catching          a shlib event? */
if|if
condition|(
name|stepping_through_solib_after_catch
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|SOLIB_ADD
argument_list|)
comment|/* Have we reached our destination?  If not, keep going. */
if|if
condition|(
name|SOLIB_IN_DYNAMIC_LINKER
argument_list|(
name|pid
argument_list|,
name|stop_pc
argument_list|)
condition|)
block|{
name|another_trap
operator|=
literal|1
expr_stmt|;
goto|goto
name|keep_going
goto|;
block|}
endif|#
directive|endif
comment|/* Else, stop and report the catchpoint(s) whose triggering              caused us to begin stepping. */
name|stepping_through_solib_after_catch
operator|=
literal|0
expr_stmt|;
name|bpstat_clear
argument_list|(
operator|&
name|stop_bpstat
argument_list|)
expr_stmt|;
name|stop_bpstat
operator|=
name|bpstat_copy
argument_list|(
name|stepping_through_solib_catchpoints
argument_list|)
expr_stmt|;
name|bpstat_clear
argument_list|(
operator|&
name|stepping_through_solib_catchpoints
argument_list|)
expr_stmt|;
name|stop_print_frame
operator|=
literal|1
expr_stmt|;
goto|goto
name|stop_stepping
goto|;
block|}
ifndef|#
directive|ifndef
name|CALL_DUMMY_BREAKPOINT_OFFSET
comment|/* This is the old way of detecting the end of the stack dummy. 	 An architecture which defines CALL_DUMMY_BREAKPOINT_OFFSET gets 	 handled above.  As soon as we can test it on all of them, all 	 architectures should define it.  */
comment|/* If this is the breakpoint at the end of a stack dummy, 	 just stop silently, unless the user was doing an si/ni, in which 	 case she'd better know what she's doing.  */
if|if
condition|(
name|CALL_DUMMY_HAS_COMPLETED
argument_list|(
name|stop_pc
argument_list|,
name|read_sp
argument_list|()
argument_list|,
name|FRAME_FP
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
argument_list|)
operator|&&
operator|!
name|step_range_end
condition|)
block|{
name|stop_print_frame
operator|=
literal|0
expr_stmt|;
name|stop_stack_dummy
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|HP_OS_BUG
name|trap_expected_after_continue
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
endif|#
directive|endif
comment|/* No CALL_DUMMY_BREAKPOINT_OFFSET.  */
if|if
condition|(
name|step_resume_breakpoint
condition|)
comment|/* Having a step-resume breakpoint overrides anything 	   else having to do with stepping commands until 	   that breakpoint is reached.  */
comment|/* I'm not sure whether this needs to be check_sigtramp2 or 	   whether it could/should be keep_going.  */
goto|goto
name|check_sigtramp2
goto|;
if|if
condition|(
name|step_range_end
operator|==
literal|0
condition|)
comment|/* Likewise if we aren't even stepping.  */
comment|/* I'm not sure whether this needs to be check_sigtramp2 or 	   whether it could/should be keep_going.  */
goto|goto
name|check_sigtramp2
goto|;
comment|/* If stepping through a line, keep going if still within it.           Note that step_range_end is the address of the first instruction          beyond the step range, and NOT the address of the last instruction          within it! */
if|if
condition|(
name|stop_pc
operator|>=
name|step_range_start
operator|&&
name|stop_pc
operator|<
name|step_range_end
if|#
directive|if
literal|0
comment|/* I haven't a clue what might trigger this clause, and it seems wrong    anyway, so I've disabled it until someone complains.  -Stu 10/24/95 */
comment|/* The step range might include the start of the 	     function, so if we are at the start of the 	     step range and either the stack or frame pointers 	     just changed, we've stepped outside */
condition|&& !(stop_pc == step_range_start&& FRAME_FP (get_current_frame ())&& (INNER_THAN (read_sp (), step_sp) 		   || FRAME_FP (get_current_frame ()) != step_frame_address))
endif|#
directive|endif
condition|)
block|{
comment|/* We might be doing a BPSTAT_WHAT_SINGLE and getting a signal. 	     So definately need to check for sigtramp here.  */
goto|goto
name|check_sigtramp2
goto|;
block|}
comment|/* We stepped out of the stepping range.  */
comment|/* If we are stepping at the source level and entered the runtime          loader dynamic symbol resolution code, we keep on single stepping 	 until we exit the run time loader code and reach the callee's 	 address.  */
if|if
condition|(
name|step_over_calls
operator|<
literal|0
operator|&&
name|IN_SOLIB_DYNSYM_RESOLVE_CODE
argument_list|(
name|stop_pc
argument_list|)
condition|)
goto|goto
name|keep_going
goto|;
comment|/* We can't update step_sp every time through the loop, because 	 reading the stack pointer would slow down stepping too much. 	 But we can update it every time we leave the step range.  */
name|update_step_sp
operator|=
literal|1
expr_stmt|;
comment|/* Did we just take a signal?  */
if|if
condition|(
name|IN_SIGTRAMP
argument_list|(
name|stop_pc
argument_list|,
name|stop_func_name
argument_list|)
operator|&&
operator|!
name|IN_SIGTRAMP
argument_list|(
name|prev_pc
argument_list|,
name|prev_func_name
argument_list|)
operator|&&
name|INNER_THAN
argument_list|(
name|read_sp
argument_list|()
argument_list|,
name|step_sp
argument_list|)
condition|)
block|{
comment|/* We've just taken a signal; go until we are back to 	     the point where we took it and one more.  */
comment|/* Note: The test above succeeds not only when we stepped              into a signal handler, but also when we step past the last              statement of a signal handler and end up in the return stub              of the signal handler trampoline.  To distinguish between              these two cases, check that the frame is INNER_THAN the              previous one below. pai/1997-09-11 */
block|{
name|CORE_ADDR
name|current_frame
init|=
name|FRAME_FP
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|INNER_THAN
argument_list|(
name|current_frame
argument_list|,
name|step_frame_address
argument_list|)
condition|)
block|{
comment|/* We have just taken a signal; go until we are back to                    the point where we took it and one more.  */
comment|/* This code is needed at least in the following case:                    The user types "next" and then a signal arrives (before                    the "next" is done).  */
comment|/* Note that if we are stopped at a breakpoint, then we need                    the step_resume breakpoint to override any breakpoints at                    the same location, so that we will still step over the                    breakpoint even though the signal happened.  */
name|struct
name|symtab_and_line
name|sr_sal
decl_stmt|;
name|INIT_SAL
argument_list|(
operator|&
name|sr_sal
argument_list|)
expr_stmt|;
name|sr_sal
operator|.
name|symtab
operator|=
name|NULL
expr_stmt|;
name|sr_sal
operator|.
name|line
operator|=
literal|0
expr_stmt|;
name|sr_sal
operator|.
name|pc
operator|=
name|prev_pc
expr_stmt|;
comment|/* We could probably be setting the frame to                    step_frame_address; I don't think anyone thought to                    try it.  */
name|step_resume_breakpoint
operator|=
name|set_momentary_breakpoint
argument_list|(
name|sr_sal
argument_list|,
name|NULL
argument_list|,
name|bp_step_resume
argument_list|)
expr_stmt|;
if|if
condition|(
name|breakpoints_inserted
condition|)
name|insert_breakpoints
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* We just stepped out of a signal handler and into                    its calling trampoline.                     Normally, we'd jump to step_over_function from                    here, but for some reason GDB can't unwind the                    stack correctly to find the real PC for the point                    user code where the signal trampoline will return                    -- FRAME_SAVED_PC fails, at least on HP-UX 10.20.                    But signal trampolines are pretty small stubs of                    code, anyway, so it's OK instead to just                    single-step out.  Note: assuming such trampolines                    don't exhibit recursion on any platform... */
name|find_pc_partial_function
argument_list|(
name|stop_pc
argument_list|,
operator|&
name|stop_func_name
argument_list|,
operator|&
name|stop_func_start
argument_list|,
operator|&
name|stop_func_end
argument_list|)
expr_stmt|;
comment|/* Readjust stepping range */
name|step_range_start
operator|=
name|stop_func_start
expr_stmt|;
name|step_range_end
operator|=
name|stop_func_end
expr_stmt|;
name|stepping_through_sigtramp
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* If this is stepi or nexti, make sure that the stepping range 	     gets us past that instruction.  */
if|if
condition|(
name|step_range_end
operator|==
literal|1
condition|)
comment|/* FIXME: Does this run afoul of the code below which, if 	       we step into the middle of a line, resets the stepping 	       range?  */
name|step_range_end
operator|=
operator|(
name|step_range_start
operator|=
name|prev_pc
operator|)
operator|+
literal|1
expr_stmt|;
name|remove_breakpoints_on_following_step
operator|=
literal|1
expr_stmt|;
goto|goto
name|keep_going
goto|;
block|}
if|#
directive|if
literal|0
comment|/* I disabled this test because it was too complicated and slow. 	 The SKIP_PROLOGUE was especially slow, because it caused 	 unnecessary prologue examination on various architectures. 	 The code in the #else clause has been tested on the Sparc, 	 Mips, PA, and Power architectures, so it's pretty likely to 	 be correct.  -Stu 10/24/95 */
comment|/* See if we left the step range due to a subroutine call that 	 we should proceed to the end of.  */
block|if (stop_func_start) 	{ 	  struct symtab *s;
comment|/* Do this after the IN_SIGTRAMP check; it might give 	     an error.  */
block|prologue_pc = stop_func_start;
comment|/* Don't skip the prologue if this is assembly source */
block|s = find_pc_symtab (stop_pc); 	  if (s&& s->language != language_asm) 	    SKIP_PROLOGUE (prologue_pc); 	}        if (!(INNER_THAN (step_sp, read_sp ()))
comment|/* don't mistake (sig)return 						   as a call */
block|&& (
comment|/* Might be a non-recursive call.  If the symbols are missing 		 enough that stop_func_start == prev_func_start even though 		 they are really two functions, we will treat some calls as 		 jumps.  */
block|stop_func_start != prev_func_start
comment|/* Might be a recursive call if either we have a prologue 		 or the call instruction itself saves the PC on the stack.  */
block||| prologue_pc != stop_func_start 	       || read_sp () != step_sp)&& (
comment|/* PC is completely out of bounds of any known objfiles.  Treat 		 like a subroutine call. */
block|!stop_func_start
comment|/* If we do a call, we will be at the start of a function...  */
block||| stop_pc == stop_func_start
comment|/* ...except on the Alpha with -O (and also Irix 5 and 		 perhaps others), in which we might call the address 		 after the load of gp.  Since prologues don't contain 		 calls, we can't return to within one, and we don't 		 jump back into them, so this check is OK.  */
block||| stop_pc< prologue_pc
comment|/* ...and if it is a leaf function, the prologue might  		 consist of gp loading only, so the call transfers to  		 the first instruction after the prologue.  */
block||| (stop_pc == prologue_pc
comment|/* Distinguish this from the case where we jump back 		     to the first instruction after the prologue, 		     within a function.  */
block|&& stop_func_start != prev_func_start)
comment|/* If we end up in certain places, it means we did a subroutine 		 call.  I'm not completely sure this is necessary now that we 		 have the above checks with stop_func_start (and now that 		 find_pc_partial_function is pickier).  */
block||| IN_SOLIB_CALL_TRAMPOLINE (stop_pc, stop_func_name)
comment|/* If none of the above apply, it is a jump within a function, 		 or a return from a subroutine.  The other case is longjmp, 		 which can no longer happen here as long as the 		 handling_longjmp stuff is working.  */
block|))
else|#
directive|else
comment|/* This test is a much more streamlined, (but hopefully correct) 	   replacement for the code above.  It's been tested on the Sparc, 	   Mips, PA, and Power architectures with good results.  */
if|if
condition|(
name|stop_pc
operator|==
name|stop_func_start
comment|/* Quick test */
operator|||
operator|(
name|in_prologue
argument_list|(
name|stop_pc
argument_list|,
name|stop_func_start
argument_list|)
operator|&&
operator|!
name|IN_SOLIB_RETURN_TRAMPOLINE
argument_list|(
name|stop_pc
argument_list|,
name|stop_func_name
argument_list|)
operator|)
operator|||
name|IN_SOLIB_CALL_TRAMPOLINE
argument_list|(
name|stop_pc
argument_list|,
name|stop_func_name
argument_list|)
operator|||
name|stop_func_name
operator|==
literal|0
condition|)
endif|#
directive|endif
block|{
comment|/* It's a subroutine call.  */
if|if
condition|(
name|step_over_calls
operator|==
literal|0
condition|)
block|{
comment|/* I presume that step_over_calls is only 0 when we're 		 supposed to be stepping at the assembly language level 		 ("stepi").  Just stop.  */
name|stop_step
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|step_over_calls
operator|>
literal|0
operator|||
name|IGNORE_HELPER_CALL
argument_list|(
name|stop_pc
argument_list|)
condition|)
comment|/* We're doing a "next".  */
goto|goto
name|step_over_function
goto|;
comment|/* If we are in a function call trampoline (a stub between 	     the calling routine and the real function), locate the real 	     function.  That's what tells us (a) whether we want to step 	     into it at all, and (b) what prologue we want to run to 	     the end of, if we do step into it.  */
name|tmp
operator|=
name|SKIP_TRAMPOLINE_CODE
argument_list|(
name|stop_pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
literal|0
condition|)
name|stop_func_start
operator|=
name|tmp
expr_stmt|;
else|else
block|{
name|tmp
operator|=
name|DYNAMIC_TRAMPOLINE_NEXTPC
argument_list|(
name|stop_pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
condition|)
block|{
name|struct
name|symtab_and_line
name|xxx
decl_stmt|;
comment|/* Why isn't this s_a_l called "sr_sal", like all of the 		     other s_a_l's where this code is duplicated?  */
name|INIT_SAL
argument_list|(
operator|&
name|xxx
argument_list|)
expr_stmt|;
comment|/* initialize to zeroes */
name|xxx
operator|.
name|pc
operator|=
name|tmp
expr_stmt|;
name|xxx
operator|.
name|section
operator|=
name|find_pc_overlay
argument_list|(
name|xxx
operator|.
name|pc
argument_list|)
expr_stmt|;
name|step_resume_breakpoint
operator|=
name|set_momentary_breakpoint
argument_list|(
name|xxx
argument_list|,
name|NULL
argument_list|,
name|bp_step_resume
argument_list|)
expr_stmt|;
name|insert_breakpoints
argument_list|()
expr_stmt|;
goto|goto
name|keep_going
goto|;
block|}
block|}
comment|/* If we have line number information for the function we 	     are thinking of stepping into, step into it.  	     If there are several symtabs at that PC (e.g. with include 	     files), just want to know whether *any* of them have line 	     numbers.  find_pc_line handles this.  */
block|{
name|struct
name|symtab_and_line
name|tmp_sal
decl_stmt|;
name|tmp_sal
operator|=
name|find_pc_line
argument_list|(
name|stop_func_start
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_sal
operator|.
name|line
operator|!=
literal|0
condition|)
goto|goto
name|step_into_function
goto|;
block|}
name|step_over_function
label|:
comment|/* A subroutine call has happened.  */
block|{
comment|/* Set a special breakpoint after the return */
name|struct
name|symtab_and_line
name|sr_sal
decl_stmt|;
name|INIT_SAL
argument_list|(
operator|&
name|sr_sal
argument_list|)
expr_stmt|;
name|sr_sal
operator|.
name|symtab
operator|=
name|NULL
expr_stmt|;
name|sr_sal
operator|.
name|line
operator|=
literal|0
expr_stmt|;
comment|/* If we came here after encountering a signal in the middle of                a "next", use the stashed-away previous frame pc */
name|sr_sal
operator|.
name|pc
operator|=
name|stopped_by_random_signal
condition|?
name|prev_pc
else|:
name|ADDR_BITS_REMOVE
argument_list|(
name|SAVED_PC_AFTER_CALL
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|step_resume_breakpoint
operator|=
name|set_momentary_breakpoint
argument_list|(
name|sr_sal
argument_list|,
name|stopped_by_random_signal
condition|?
name|NULL
else|:
name|get_current_frame
argument_list|()
argument_list|,
name|bp_step_resume
argument_list|)
expr_stmt|;
comment|/* We've just entered a callee, and we wish to resume until                it returns to the caller.  Setting a step_resume bp on                the return PC will catch a return from the callee.                 However, if the callee is recursing, we want to be                careful not to catch returns of those recursive calls,                but of THIS instance of the call.                 To do this, we set the step_resume bp's frame to our                current caller's frame (step_frame_address, which is                set by the "next" or "until" command, before execution                begins).                 But ... don't do it if we're single-stepping out of a                sigtramp, because the reason we're single-stepping is                precisely because unwinding is a problem (HP-UX 10.20,                e.g.) and the frame address is likely to be incorrect.                No danger of sigtramp recursion.  */
if|if
condition|(
name|stepping_through_sigtramp
condition|)
block|{
name|step_resume_breakpoint
operator|->
name|frame
operator|=
operator|(
name|CORE_ADDR
operator|)
name|NULL
expr_stmt|;
name|stepping_through_sigtramp
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|IN_SOLIB_DYNSYM_RESOLVE_CODE
argument_list|(
name|sr_sal
operator|.
name|pc
argument_list|)
condition|)
name|step_resume_breakpoint
operator|->
name|frame
operator|=
name|step_frame_address
expr_stmt|;
if|if
condition|(
name|breakpoints_inserted
condition|)
name|insert_breakpoints
argument_list|()
expr_stmt|;
block|}
goto|goto
name|keep_going
goto|;
name|step_into_function
label|:
comment|/* Subroutine call with source code we should not step over. 	     Do step to the first line of code in it.  */
block|{
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|find_pc_symtab
argument_list|(
name|stop_pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|&&
name|s
operator|->
name|language
operator|!=
name|language_asm
condition|)
name|SKIP_PROLOGUE
argument_list|(
name|stop_func_start
argument_list|)
expr_stmt|;
block|}
name|sal
operator|=
name|find_pc_line
argument_list|(
name|stop_func_start
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Use the step_resume_break to step until 	     the end of the prologue, even if that involves jumps 	     (as it seems to on the vax under 4.2).  */
comment|/* If the prologue ends in the middle of a source line, 	     continue to the end of that source line (if it is still 	     within the function).  Otherwise, just go to end of prologue.  */
ifdef|#
directive|ifdef
name|PROLOGUE_FIRSTLINE_OVERLAP
comment|/* no, don't either.  It skips any code that's 	     legitimately on the first line.  */
else|#
directive|else
if|if
condition|(
name|sal
operator|.
name|end
operator|&&
name|sal
operator|.
name|pc
operator|!=
name|stop_func_start
operator|&&
name|sal
operator|.
name|end
operator|<
name|stop_func_end
condition|)
name|stop_func_start
operator|=
name|sal
operator|.
name|end
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|stop_func_start
operator|==
name|stop_pc
condition|)
block|{
comment|/* We are already there: stop now.  */
name|stop_step
operator|=
literal|1
expr_stmt|;
break|break;
block|}
else|else
comment|/* Put the step-breakpoint there and go until there. */
block|{
name|struct
name|symtab_and_line
name|sr_sal
decl_stmt|;
name|INIT_SAL
argument_list|(
operator|&
name|sr_sal
argument_list|)
expr_stmt|;
comment|/* initialize to zeroes */
name|sr_sal
operator|.
name|pc
operator|=
name|stop_func_start
expr_stmt|;
name|sr_sal
operator|.
name|section
operator|=
name|find_pc_overlay
argument_list|(
name|stop_func_start
argument_list|)
expr_stmt|;
comment|/* Do not specify what the fp should be when we stop 		 since on some machines the prologue 		 is where the new fp value is established.  */
name|step_resume_breakpoint
operator|=
name|set_momentary_breakpoint
argument_list|(
name|sr_sal
argument_list|,
name|NULL
argument_list|,
name|bp_step_resume
argument_list|)
expr_stmt|;
if|if
condition|(
name|breakpoints_inserted
condition|)
name|insert_breakpoints
argument_list|()
expr_stmt|;
comment|/* And make sure stepping stops right away then.  */
name|step_range_end
operator|=
name|step_range_start
expr_stmt|;
block|}
goto|goto
name|keep_going
goto|;
block|}
comment|/* We've wandered out of the step range.  */
name|sal
operator|=
name|find_pc_line
argument_list|(
name|stop_pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|step_range_end
operator|==
literal|1
condition|)
block|{
comment|/* It is stepi or nexti.  We always want to stop stepping after 	     one instruction.  */
name|stop_step
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* If we're in the return path from a shared library trampoline, 	 we want to proceed through the trampoline when stepping.  */
if|if
condition|(
name|IN_SOLIB_RETURN_TRAMPOLINE
argument_list|(
name|stop_pc
argument_list|,
name|stop_func_name
argument_list|)
condition|)
block|{
name|CORE_ADDR
name|tmp
decl_stmt|;
comment|/* Determine where this trampoline returns.  */
name|tmp
operator|=
name|SKIP_TRAMPOLINE_CODE
argument_list|(
name|stop_pc
argument_list|)
expr_stmt|;
comment|/* Only proceed through if we know where it's going.  */
if|if
condition|(
name|tmp
condition|)
block|{
comment|/* And put the step-breakpoint there and go until there. */
name|struct
name|symtab_and_line
name|sr_sal
decl_stmt|;
name|INIT_SAL
argument_list|(
operator|&
name|sr_sal
argument_list|)
expr_stmt|;
comment|/* initialize to zeroes */
name|sr_sal
operator|.
name|pc
operator|=
name|tmp
expr_stmt|;
name|sr_sal
operator|.
name|section
operator|=
name|find_pc_overlay
argument_list|(
name|sr_sal
operator|.
name|pc
argument_list|)
expr_stmt|;
comment|/* Do not specify what the fp should be when we stop 		 since on some machines the prologue 		 is where the new fp value is established.  */
name|step_resume_breakpoint
operator|=
name|set_momentary_breakpoint
argument_list|(
name|sr_sal
argument_list|,
name|NULL
argument_list|,
name|bp_step_resume
argument_list|)
expr_stmt|;
if|if
condition|(
name|breakpoints_inserted
condition|)
name|insert_breakpoints
argument_list|()
expr_stmt|;
comment|/* Restart without fiddling with the step ranges or 		 other state.  */
goto|goto
name|keep_going
goto|;
block|}
block|}
if|if
condition|(
name|sal
operator|.
name|line
operator|==
literal|0
condition|)
block|{
comment|/* We have no line number information.  That means to stop 	     stepping (does this always happen right after one instruction, 	     when we do "s" in a function with no line numbers, 	     or can this happen as a result of a return or longjmp?).  */
name|stop_step
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|stop_pc
operator|==
name|sal
operator|.
name|pc
operator|)
operator|&&
operator|(
name|current_line
operator|!=
name|sal
operator|.
name|line
operator|||
name|current_symtab
operator|!=
name|sal
operator|.
name|symtab
operator|)
condition|)
block|{
comment|/* We are at the start of a different line.  So stop.  Note that 	     we don't stop if we step into the middle of a different line. 	     That is said to make things like for (;;) statements work 	     better.  */
name|stop_step
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* We aren't done stepping.  	 Optimize by setting the stepping range to the line. 	 (We might not be in the original line, but if we entered a 	 new line in mid-statement, we continue stepping.  This makes 	 things like for(;;) statements work better.)  */
if|if
condition|(
name|stop_func_end
operator|&&
name|sal
operator|.
name|end
operator|>=
name|stop_func_end
condition|)
block|{
comment|/* If this is the last line of the function, don't keep stepping 	     (it would probably step us out of the function). 	     This is particularly necessary for a one-line function, 	     in which after skipping the prologue we better stop even though 	     we will be in mid-line.  */
name|stop_step
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|step_range_start
operator|=
name|sal
operator|.
name|pc
expr_stmt|;
name|step_range_end
operator|=
name|sal
operator|.
name|end
expr_stmt|;
name|step_frame_address
operator|=
name|FRAME_FP
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
expr_stmt|;
name|current_line
operator|=
name|sal
operator|.
name|line
expr_stmt|;
name|current_symtab
operator|=
name|sal
operator|.
name|symtab
expr_stmt|;
comment|/* In the case where we just stepped out of a function into the middle          of a line of the caller, continue stepping, but step_frame_address          must be modified to current frame */
block|{
name|CORE_ADDR
name|current_frame
init|=
name|FRAME_FP
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|INNER_THAN
argument_list|(
name|current_frame
argument_list|,
name|step_frame_address
argument_list|)
operator|)
condition|)
name|step_frame_address
operator|=
name|current_frame
expr_stmt|;
block|}
goto|goto
name|keep_going
goto|;
name|check_sigtramp2
label|:
if|if
condition|(
name|trap_expected
operator|&&
name|IN_SIGTRAMP
argument_list|(
name|stop_pc
argument_list|,
name|stop_func_name
argument_list|)
operator|&&
operator|!
name|IN_SIGTRAMP
argument_list|(
name|prev_pc
argument_list|,
name|prev_func_name
argument_list|)
operator|&&
name|INNER_THAN
argument_list|(
name|read_sp
argument_list|()
argument_list|,
name|step_sp
argument_list|)
condition|)
block|{
comment|/* What has happened here is that we have just stepped the inferior 	     with a signal (because it is a signal which shouldn't make 	     us stop), thus stepping into sigtramp.  	     So we need to set a step_resume_break_address breakpoint 	     and continue until we hit it, and then step.  FIXME: This should 	     be more enduring than a step_resume breakpoint; we should know 	     that we will later need to keep going rather than re-hitting 	     the breakpoint here (see testsuite/gdb.t06/signals.exp where 	     it says "exceedingly difficult").  */
name|struct
name|symtab_and_line
name|sr_sal
decl_stmt|;
name|INIT_SAL
argument_list|(
operator|&
name|sr_sal
argument_list|)
expr_stmt|;
comment|/* initialize to zeroes */
name|sr_sal
operator|.
name|pc
operator|=
name|prev_pc
expr_stmt|;
name|sr_sal
operator|.
name|section
operator|=
name|find_pc_overlay
argument_list|(
name|sr_sal
operator|.
name|pc
argument_list|)
expr_stmt|;
comment|/* We perhaps could set the frame if we kept track of what 	     the frame corresponding to prev_pc was.  But we don't, 	     so don't.  */
name|through_sigtramp_breakpoint
operator|=
name|set_momentary_breakpoint
argument_list|(
name|sr_sal
argument_list|,
name|NULL
argument_list|,
name|bp_through_sigtramp
argument_list|)
expr_stmt|;
if|if
condition|(
name|breakpoints_inserted
condition|)
name|insert_breakpoints
argument_list|()
expr_stmt|;
name|remove_breakpoints_on_following_step
operator|=
literal|1
expr_stmt|;
name|another_trap
operator|=
literal|1
expr_stmt|;
block|}
name|keep_going
label|:
comment|/* Come to this label when you need to resume the inferior. 	 It's really much cleaner to do a goto than a maze of if-else 	 conditions.  */
comment|/* ??rehrauer: ttrace on HP-UX theoretically allows one to debug          a vforked child beetween its creation and subsequent exit or          call to exec().  However, I had big problems in this rather          creaky exec engine, getting that to work.  The fundamental          problem is that I'm trying to debug two processes via an          engine that only understands a single process with possibly          multiple threads.           Hence, this spot is known to have problems when          target_can_follow_vfork_prior_to_exec returns 1. */
comment|/* Save the pc before execution, to compare with pc after stop.  */
name|prev_pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
comment|/* Might have been DECR_AFTER_BREAK */
name|prev_func_start
operator|=
name|stop_func_start
expr_stmt|;
comment|/* Ok, since if DECR_PC_AFTER 					  BREAK is defined, the 					  original pc would not have 					  been at the start of a 					  function. */
name|prev_func_name
operator|=
name|stop_func_name
expr_stmt|;
if|if
condition|(
name|update_step_sp
condition|)
name|step_sp
operator|=
name|read_sp
argument_list|()
expr_stmt|;
name|update_step_sp
operator|=
literal|0
expr_stmt|;
comment|/* If we did not do break;, it means we should keep 	 running the inferior and not return to debugger.  */
if|if
condition|(
name|trap_expected
operator|&&
name|stop_signal
operator|!=
name|TARGET_SIGNAL_TRAP
condition|)
block|{
comment|/* We took a signal (which we are supposed to pass through to 	     the inferior, else we'd have done a break above) and we 	     haven't yet gotten our trap.  Simply continue.  */
name|resume
argument_list|(
name|CURRENTLY_STEPPING
argument_list|()
argument_list|,
name|stop_signal
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Either the trap was not expected, but we are continuing 	     anyway (the user asked that this signal be passed to the 	     child) 	       -- or -- 	     The signal was SIGTRAP, e.g. it was our signal, but we 	     decided we should resume from it.  	     We're going to run this baby now!  	     Insert breakpoints now, unless we are trying 	     to one-proceed past a breakpoint.  */
comment|/* If we've just finished a special step resume and we don't 	     want to hit a breakpoint, pull em out.  */
if|if
condition|(
name|step_resume_breakpoint
operator|==
name|NULL
operator|&&
name|through_sigtramp_breakpoint
operator|==
name|NULL
operator|&&
name|remove_breakpoints_on_following_step
condition|)
block|{
name|remove_breakpoints_on_following_step
operator|=
literal|0
expr_stmt|;
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|breakpoints_inserted
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|breakpoints_inserted
operator|&&
operator|(
name|through_sigtramp_breakpoint
operator|!=
name|NULL
operator|||
operator|!
name|another_trap
operator|)
condition|)
block|{
name|breakpoints_failed
operator|=
name|insert_breakpoints
argument_list|()
expr_stmt|;
if|if
condition|(
name|breakpoints_failed
condition|)
break|break;
name|breakpoints_inserted
operator|=
literal|1
expr_stmt|;
block|}
name|trap_expected
operator|=
name|another_trap
expr_stmt|;
comment|/* Do not deliver SIGNAL_TRAP (except when the user 	     explicitly specifies that such a signal should be 	     delivered to the target program).  	     Typically, this would occure when a user is debugging a 	     target monitor on a simulator: the target monitor sets a 	     breakpoint; the simulator encounters this break-point and 	     halts the simulation handing control to GDB; GDB, noteing 	     that the break-point isn't valid, returns control back to 	     the simulator; the simulator then delivers the hardware 	     equivalent of a SIGNAL_TRAP to the program being 	     debugged. */
if|if
condition|(
name|stop_signal
operator|==
name|TARGET_SIGNAL_TRAP
operator|&&
operator|!
name|signal_program
index|[
name|stop_signal
index|]
condition|)
name|stop_signal
operator|=
name|TARGET_SIGNAL_0
expr_stmt|;
ifdef|#
directive|ifdef
name|SHIFT_INST_REGS
comment|/* I'm not sure when this following segment applies.  I do know, 	     now, that we shouldn't rewrite the regs when we were stopped 	     by a random signal from the inferior process.  */
comment|/* FIXME: Shouldn't this be based on the valid bit of the SXIP? 	     (this is only used on the 88k).  */
if|if
condition|(
operator|!
name|bpstat_explains_signal
argument_list|(
name|stop_bpstat
argument_list|)
operator|&&
operator|(
name|stop_signal
operator|!=
name|TARGET_SIGNAL_CHLD
operator|)
operator|&&
operator|!
name|stopped_by_random_signal
condition|)
name|SHIFT_INST_REGS
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* SHIFT_INST_REGS */
name|resume
argument_list|(
name|CURRENTLY_STEPPING
argument_list|()
argument_list|,
name|stop_signal
argument_list|)
expr_stmt|;
block|}
block|}
name|stop_stepping
label|:
if|if
condition|(
name|target_has_execution
condition|)
block|{
comment|/* Are we stopping for a vfork event?  We only stop when we see          the child's event.  However, we may not yet have seen the          parent's event.  And, inferior_pid is still set to the parent's          pid, until we resume again and follow either the parent or child.           To ensure that we can really touch inferior_pid (aka, the          parent process) -- which calls to functions like read_pc          implicitly do -- wait on the parent if necessary. */
if|if
condition|(
operator|(
name|pending_follow
operator|.
name|kind
operator|==
name|TARGET_WAITKIND_VFORKED
operator|)
operator|&&
operator|!
name|pending_follow
operator|.
name|fork_event
operator|.
name|saw_parent_fork
condition|)
block|{
name|int
name|parent_pid
decl_stmt|;
do|do
block|{
if|if
condition|(
name|target_wait_hook
condition|)
name|parent_pid
operator|=
name|target_wait_hook
argument_list|(
operator|-
literal|1
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
else|else
name|parent_pid
operator|=
name|target_wait
argument_list|(
operator|-
literal|1
argument_list|,
operator|&
name|w
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|parent_pid
operator|!=
name|inferior_pid
condition|)
do|;
block|}
comment|/* Assuming the inferior still exists, set these up for next 	 time, just like we did above if we didn't break out of the 	 loop.  */
name|prev_pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
name|prev_func_start
operator|=
name|stop_func_start
expr_stmt|;
name|prev_func_name
operator|=
name|stop_func_name
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function returns TRUE if ep is an internal breakpoint    set to catch generic shared library (aka dynamically-linked    library) events.  (This is *NOT* the same as a catchpoint for a    shlib event.  The latter is something a user can set; this is    something gdb sets for its own use, and isn't ever shown to a    user.) */
end_comment

begin_function
specifier|static
name|int
name|is_internal_shlib_eventpoint
parameter_list|(
name|ep
parameter_list|)
name|struct
name|breakpoint
modifier|*
name|ep
decl_stmt|;
block|{
return|return
operator|(
name|ep
operator|->
name|type
operator|==
name|bp_shlib_event
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This function returns TRUE if bs indicates that the inferior    stopped due to a shared library (aka dynamically-linked library)    event. */
end_comment

begin_function
specifier|static
name|int
name|stopped_for_internal_shlib_event
parameter_list|(
name|bs
parameter_list|)
name|bpstat
name|bs
decl_stmt|;
block|{
comment|/* Note that multiple eventpoints may've caused the stop.  Any      that are associated with shlib events will be accepted. */
for|for
control|(
init|;
name|bs
operator|!=
name|NULL
condition|;
name|bs
operator|=
name|bs
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|bs
operator|->
name|breakpoint_at
operator|!=
name|NULL
operator|)
operator|&&
name|is_internal_shlib_eventpoint
argument_list|(
name|bs
operator|->
name|breakpoint_at
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
comment|/* If we get here, then no candidate was found. */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This function returns TRUE if bs indicates that the inferior    stopped due to a shared library (aka dynamically-linked library)    event caught by a catchpoint.     If TRUE, cp_p is set to point to the catchpoint.     Else, the value of cp_p is undefined. */
end_comment

begin_function
specifier|static
name|int
name|stopped_for_shlib_catchpoint
parameter_list|(
name|bs
parameter_list|,
name|cp_p
parameter_list|)
name|bpstat
name|bs
decl_stmt|;
name|struct
name|breakpoint
modifier|*
modifier|*
name|cp_p
decl_stmt|;
block|{
comment|/* Note that multiple eventpoints may've caused the stop.  Any      that are associated with shlib events will be accepted. */
operator|*
name|cp_p
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
name|bs
operator|!=
name|NULL
condition|;
name|bs
operator|=
name|bs
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
name|bs
operator|->
name|breakpoint_at
operator|!=
name|NULL
operator|)
operator|&&
name|ep_is_shlib_catchpoint
argument_list|(
name|bs
operator|->
name|breakpoint_at
argument_list|)
condition|)
block|{
operator|*
name|cp_p
operator|=
name|bs
operator|->
name|breakpoint_at
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* If we get here, then no candidate was found. */
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Here to return control to GDB when the inferior stops for real.    Print appropriate messages, remove breakpoints, give terminal our modes.     STOP_PRINT_FRAME nonzero means print the executing frame    (pc, function, args, file, line number and line text).    BREAKPOINTS_FAILED nonzero means stop was due to error    attempting to insert breakpoints.  */
end_comment

begin_function
name|void
name|normal_stop
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|HPUXHPPA
comment|/* As with the notification of thread events, we want to delay      notifying the user that we've switched thread context until      the inferior actually stops.       (Note that there's no point in saying anything if the inferior      has exited!) */
if|if
condition|(
operator|(
name|switched_from_inferior_pid
operator|!=
name|inferior_pid
operator|)
operator|&&
name|target_has_execution
condition|)
block|{
name|target_terminal_ours_for_output
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"[Switched to %s]\n"
argument_list|,
name|target_pid_or_tid_to_str
argument_list|(
name|inferior_pid
argument_list|)
argument_list|)
expr_stmt|;
name|switched_from_inferior_pid
operator|=
name|inferior_pid
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Make sure that the current_frame's pc is correct.  This      is a correction for setting up the frame info before doing      DECR_PC_AFTER_BREAK */
if|if
condition|(
name|target_has_execution
operator|&&
name|get_current_frame
argument_list|()
condition|)
operator|(
name|get_current_frame
argument_list|()
operator|)
operator|->
name|pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
if|if
condition|(
name|breakpoints_failed
condition|)
block|{
name|target_terminal_ours_for_output
argument_list|()
expr_stmt|;
name|print_sys_errmsg
argument_list|(
literal|"ptrace"
argument_list|,
name|breakpoints_failed
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Stopped; cannot insert breakpoints.\n\ The same program may be running in another process.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|target_has_execution
operator|&&
name|breakpoints_inserted
condition|)
block|{
if|if
condition|(
name|remove_breakpoints
argument_list|()
condition|)
block|{
name|target_terminal_ours_for_output
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Cannot remove breakpoints because "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"program is no longer writable.\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"It might be running in another process.\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Further execution is probably impossible.\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|breakpoints_inserted
operator|=
literal|0
expr_stmt|;
comment|/* Delete the breakpoint we stopped at, if it wants to be deleted.      Delete any breakpoint that is to be deleted at the next stop.  */
name|breakpoint_auto_delete
argument_list|(
name|stop_bpstat
argument_list|)
expr_stmt|;
comment|/* If an auto-display called a function and that got a signal,      delete that auto-display to avoid an infinite recursion.  */
if|if
condition|(
name|stopped_by_random_signal
condition|)
name|disable_current_display
argument_list|()
expr_stmt|;
comment|/* Don't print a message if in the middle of doing a "step n"      operation for n> 1 */
if|if
condition|(
name|step_multi
operator|&&
name|stop_step
condition|)
goto|goto
name|done
goto|;
name|target_terminal_ours
argument_list|()
expr_stmt|;
comment|/* Did we stop because the user set the stop_on_solib_events      variable?  (If so, we report this as a generic, "Stopped due      to shlib event" message.) */
if|if
condition|(
name|stopped_for_internal_shlib_event
argument_list|(
name|stop_bpstat
argument_list|)
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Stopped due to shared library event\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Look up the hook_stop and run it if it exists.  */
if|if
condition|(
name|stop_command
operator|&&
name|stop_command
operator|->
name|hook
condition|)
block|{
name|catch_errors
argument_list|(
name|hook_stop_stub
argument_list|,
name|stop_command
operator|->
name|hook
argument_list|,
literal|"Error while running hook_stop:\n"
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|target_has_stack
condition|)
block|{
goto|goto
name|done
goto|;
block|}
comment|/* Select innermost stack frame - i.e., current frame is frame 0,      and current location is based on that.      Don't do this on return from a stack dummy routine,      or if the program has exited. */
if|if
condition|(
operator|!
name|stop_stack_dummy
condition|)
block|{
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Print current location without a level number, if 	 we have changed functions or hit a breakpoint. 	 Print source line if we have one. 	 bpstat_print() contains the logic deciding in detail 	 what to print, based on the event(s) that just occurred. */
if|if
condition|(
name|stop_print_frame
condition|)
block|{
name|int
name|bpstat_ret
decl_stmt|;
name|int
name|source_flag
decl_stmt|;
name|bpstat_ret
operator|=
name|bpstat_print
argument_list|(
name|stop_bpstat
argument_list|)
expr_stmt|;
comment|/* bpstat_print() returned one of:              -1: Didn't print anything               0: Printed preliminary "Breakpoint n, " message, desires                  location tacked on               1: Printed something, don't tack on location */
if|if
condition|(
name|bpstat_ret
operator|==
operator|-
literal|1
condition|)
if|if
condition|(
name|stop_step
operator|&&
name|step_frame_address
operator|==
name|FRAME_FP
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
operator|&&
name|step_start_function
operator|==
name|find_pc_function
argument_list|(
name|stop_pc
argument_list|)
condition|)
name|source_flag
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* finished step, just print source line */
else|else
name|source_flag
operator|=
literal|1
expr_stmt|;
comment|/* print location and source line */
elseif|else
if|if
condition|(
name|bpstat_ret
operator|==
literal|0
condition|)
comment|/* hit bpt, desire location */
name|source_flag
operator|=
literal|1
expr_stmt|;
comment|/* print location and source line */
else|else
comment|/* bpstat_ret == 1, hit bpt, do not desire location */
name|source_flag
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* just print source line */
comment|/* The behavior of this routine with respect to the source 	     flag is: 	     -1: Print only source line 	     0: Print only location 	     1: Print location and source line */
name|show_and_print_stack_frame
argument_list|(
name|selected_frame
argument_list|,
operator|-
literal|1
argument_list|,
name|source_flag
argument_list|)
expr_stmt|;
comment|/* Display the auto-display expressions.  */
name|do_displays
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Save the function value return registers, if we care.      We might be about to restore their previous contents.  */
if|if
condition|(
name|proceed_to_finish
condition|)
name|read_register_bytes
argument_list|(
literal|0
argument_list|,
name|stop_registers
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
if|if
condition|(
name|stop_stack_dummy
condition|)
block|{
comment|/* Pop the empty frame that contains the stack dummy.          POP_FRAME ends with a setting of the current frame, so we 	 can use that next. */
name|POP_FRAME
expr_stmt|;
comment|/* Set stop_pc to what it was before we called the function. 	 Can't rely on restore_inferior_status because that only gets 	 called if we don't stop in the called function.  */
name|stop_pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|TUIDO
argument_list|(
operator|(
operator|(
name|TuiOpaqueFuncPtr
operator|)
name|tui_vCheckDataValues
operator|,
name|selected_frame
operator|)
argument_list|)
expr_stmt|;
name|done
label|:
name|annotate_stopped
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|hook_stop_stub
parameter_list|(
name|cmd
parameter_list|)
name|PTR
name|cmd
decl_stmt|;
block|{
name|execute_user_command
argument_list|(
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|)
name|cmd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|signal_stop_state
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
return|return
name|signal_stop
index|[
name|signo
index|]
return|;
block|}
end_function

begin_function
name|int
name|signal_print_state
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
return|return
name|signal_print
index|[
name|signo
index|]
return|;
block|}
end_function

begin_function
name|int
name|signal_pass_state
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
return|return
name|signal_program
index|[
name|signo
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sig_print_header
parameter_list|()
block|{
name|printf_filtered
argument_list|(
literal|"\ Signal        Stop\tPrint\tPass to program\tDescription\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sig_print_info
parameter_list|(
name|oursig
parameter_list|)
name|enum
name|target_signal
name|oursig
decl_stmt|;
block|{
name|char
modifier|*
name|name
init|=
name|target_signal_to_name
argument_list|(
name|oursig
argument_list|)
decl_stmt|;
name|int
name|name_padding
init|=
literal|13
operator|-
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|name_padding
operator|<=
literal|0
condition|)
name|name_padding
operator|=
literal|0
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%*.*s "
argument_list|,
name|name_padding
argument_list|,
name|name_padding
argument_list|,
literal|"                 "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s\t"
argument_list|,
name|signal_stop
index|[
name|oursig
index|]
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s\t"
argument_list|,
name|signal_print
index|[
name|oursig
index|]
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s\t\t"
argument_list|,
name|signal_program
index|[
name|oursig
index|]
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s\n"
argument_list|,
name|target_signal_to_string
argument_list|(
name|oursig
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Specify how various signals in the inferior should be handled.  */
end_comment

begin_function
specifier|static
name|void
name|handle_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|digits
decl_stmt|,
name|wordlen
decl_stmt|;
name|int
name|sigfirst
decl_stmt|,
name|signum
decl_stmt|,
name|siglast
decl_stmt|;
name|enum
name|target_signal
name|oursig
decl_stmt|;
name|int
name|allsigs
decl_stmt|;
name|int
name|nsigs
decl_stmt|;
name|unsigned
name|char
modifier|*
name|sigs
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
block|{
name|error_no_arg
argument_list|(
literal|"signal to handle"
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate and zero an array of flags for which signals to handle. */
name|nsigs
operator|=
operator|(
name|int
operator|)
name|TARGET_SIGNAL_LAST
expr_stmt|;
name|sigs
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|nsigs
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sigs
argument_list|,
literal|0
argument_list|,
name|nsigs
argument_list|)
expr_stmt|;
comment|/* Break the command line up into args. */
name|argv
operator|=
name|buildargv
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
operator|==
name|NULL
condition|)
block|{
name|nomem
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|old_chain
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|freeargv
argument_list|,
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
comment|/* Walk through the args, looking for signal oursigs, signal names, and      actions.  Signal numbers and signal names may be interspersed with      actions, with the actions being performed for all signals cumulatively      specified.  Signal ranges can be specified as<LOW>-<HIGH>. */
while|while
condition|(
operator|*
name|argv
operator|!=
name|NULL
condition|)
block|{
name|wordlen
operator|=
name|strlen
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
for|for
control|(
name|digits
operator|=
literal|0
init|;
name|isdigit
argument_list|(
operator|(
operator|*
name|argv
operator|)
index|[
name|digits
index|]
argument_list|)
condition|;
name|digits
operator|++
control|)
block|{
empty_stmt|;
block|}
name|allsigs
operator|=
literal|0
expr_stmt|;
name|sigfirst
operator|=
name|siglast
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|wordlen
operator|>=
literal|1
operator|&&
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"all"
argument_list|,
name|wordlen
argument_list|)
condition|)
block|{
comment|/* Apply action to all signals except those used by the 	     debugger.  Silently skip those. */
name|allsigs
operator|=
literal|1
expr_stmt|;
name|sigfirst
operator|=
literal|0
expr_stmt|;
name|siglast
operator|=
name|nsigs
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wordlen
operator|>=
literal|1
operator|&&
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"stop"
argument_list|,
name|wordlen
argument_list|)
condition|)
block|{
name|SET_SIGS
argument_list|(
name|nsigs
argument_list|,
name|sigs
argument_list|,
name|signal_stop
argument_list|)
expr_stmt|;
name|SET_SIGS
argument_list|(
name|nsigs
argument_list|,
name|sigs
argument_list|,
name|signal_print
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wordlen
operator|>=
literal|1
operator|&&
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"ignore"
argument_list|,
name|wordlen
argument_list|)
condition|)
block|{
name|UNSET_SIGS
argument_list|(
name|nsigs
argument_list|,
name|sigs
argument_list|,
name|signal_program
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wordlen
operator|>=
literal|2
operator|&&
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"print"
argument_list|,
name|wordlen
argument_list|)
condition|)
block|{
name|SET_SIGS
argument_list|(
name|nsigs
argument_list|,
name|sigs
argument_list|,
name|signal_print
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wordlen
operator|>=
literal|2
operator|&&
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"pass"
argument_list|,
name|wordlen
argument_list|)
condition|)
block|{
name|SET_SIGS
argument_list|(
name|nsigs
argument_list|,
name|sigs
argument_list|,
name|signal_program
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wordlen
operator|>=
literal|3
operator|&&
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"nostop"
argument_list|,
name|wordlen
argument_list|)
condition|)
block|{
name|UNSET_SIGS
argument_list|(
name|nsigs
argument_list|,
name|sigs
argument_list|,
name|signal_stop
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wordlen
operator|>=
literal|3
operator|&&
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"noignore"
argument_list|,
name|wordlen
argument_list|)
condition|)
block|{
name|SET_SIGS
argument_list|(
name|nsigs
argument_list|,
name|sigs
argument_list|,
name|signal_program
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wordlen
operator|>=
literal|4
operator|&&
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"noprint"
argument_list|,
name|wordlen
argument_list|)
condition|)
block|{
name|UNSET_SIGS
argument_list|(
name|nsigs
argument_list|,
name|sigs
argument_list|,
name|signal_print
argument_list|)
expr_stmt|;
name|UNSET_SIGS
argument_list|(
name|nsigs
argument_list|,
name|sigs
argument_list|,
name|signal_stop
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wordlen
operator|>=
literal|4
operator|&&
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"nopass"
argument_list|,
name|wordlen
argument_list|)
condition|)
block|{
name|UNSET_SIGS
argument_list|(
name|nsigs
argument_list|,
name|sigs
argument_list|,
name|signal_program
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|digits
operator|>
literal|0
condition|)
block|{
comment|/* It is numeric.  The numeric signal refers to our own 	     internal signal numbering from target.h, not to host/target 	     signal  number.  This is a feature; users really should be 	     using symbolic names anyway, and the common ones like 	     SIGHUP, SIGINT, SIGALRM, etc. will work right anyway.  */
name|sigfirst
operator|=
name|siglast
operator|=
operator|(
name|int
operator|)
name|target_signal_from_command
argument_list|(
name|atoi
argument_list|(
operator|*
name|argv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
name|digits
index|]
operator|==
literal|'-'
condition|)
block|{
name|siglast
operator|=
operator|(
name|int
operator|)
name|target_signal_from_command
argument_list|(
name|atoi
argument_list|(
operator|(
operator|*
name|argv
operator|)
operator|+
name|digits
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sigfirst
operator|>
name|siglast
condition|)
block|{
comment|/* Bet he didn't figure we'd think of this case... */
name|signum
operator|=
name|sigfirst
expr_stmt|;
name|sigfirst
operator|=
name|siglast
expr_stmt|;
name|siglast
operator|=
name|signum
expr_stmt|;
block|}
block|}
else|else
block|{
name|oursig
operator|=
name|target_signal_from_name
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|oursig
operator|!=
name|TARGET_SIGNAL_UNKNOWN
condition|)
block|{
name|sigfirst
operator|=
name|siglast
operator|=
operator|(
name|int
operator|)
name|oursig
expr_stmt|;
block|}
else|else
block|{
comment|/* Not a number and not a recognized flag word => complain.  */
name|error
argument_list|(
literal|"Unrecognized or ambiguous flag word: \"%s\"."
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If any signal numbers or symbol names were found, set flags for 	 which signals to apply actions to. */
for|for
control|(
name|signum
operator|=
name|sigfirst
init|;
name|signum
operator|>=
literal|0
operator|&&
name|signum
operator|<=
name|siglast
condition|;
name|signum
operator|++
control|)
block|{
switch|switch
condition|(
operator|(
expr|enum
name|target_signal
operator|)
name|signum
condition|)
block|{
case|case
name|TARGET_SIGNAL_TRAP
case|:
case|case
name|TARGET_SIGNAL_INT
case|:
if|if
condition|(
operator|!
name|allsigs
operator|&&
operator|!
name|sigs
index|[
name|signum
index|]
condition|)
block|{
if|if
condition|(
name|query
argument_list|(
literal|"%s is used by the debugger.\n\ Are you sure you want to change it? "
argument_list|,
name|target_signal_to_name
argument_list|(
operator|(
expr|enum
name|target_signal
operator|)
name|signum
argument_list|)
argument_list|)
condition|)
block|{
name|sigs
index|[
name|signum
index|]
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|printf_unfiltered
argument_list|(
literal|"Not confirmed, unchanged.\n"
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TARGET_SIGNAL_0
case|:
case|case
name|TARGET_SIGNAL_DEFAULT
case|:
case|case
name|TARGET_SIGNAL_UNKNOWN
case|:
comment|/* Make sure that "all" doesn't print these.  */
break|break;
default|default:
name|sigs
index|[
name|signum
index|]
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|argv
operator|++
expr_stmt|;
block|}
name|target_notice_signals
argument_list|(
name|inferior_pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
comment|/* Show the results.  */
name|sig_print_header
argument_list|()
expr_stmt|;
for|for
control|(
name|signum
operator|=
literal|0
init|;
name|signum
operator|<
name|nsigs
condition|;
name|signum
operator|++
control|)
block|{
if|if
condition|(
name|sigs
index|[
name|signum
index|]
condition|)
block|{
name|sig_print_info
argument_list|(
name|signum
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xdb_handle_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
comment|/* Break the command line up into args. */
name|argv
operator|=
name|buildargv
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
operator|==
name|NULL
condition|)
block|{
name|nomem
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|old_chain
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|freeargv
argument_list|,
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
index|[
literal|1
index|]
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|char
modifier|*
name|argBuf
decl_stmt|;
name|int
name|bufLen
decl_stmt|;
name|bufLen
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|+
literal|20
expr_stmt|;
name|argBuf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|bufLen
argument_list|)
expr_stmt|;
if|if
condition|(
name|argBuf
condition|)
block|{
name|int
name|validFlag
init|=
literal|1
decl_stmt|;
name|enum
name|target_signal
name|oursig
decl_stmt|;
name|oursig
operator|=
name|target_signal_from_name
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|argBuf
argument_list|,
literal|0
argument_list|,
name|bufLen
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"Q"
argument_list|)
operator|==
literal|0
condition|)
name|sprintf
argument_list|(
name|argBuf
argument_list|,
literal|"%s %s"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"noprint"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"s"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|signal_stop
index|[
name|oursig
index|]
condition|)
name|sprintf
argument_list|(
name|argBuf
argument_list|,
literal|"%s %s"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"stop"
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|argBuf
argument_list|,
literal|"%s %s"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"nostop"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"i"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|signal_program
index|[
name|oursig
index|]
condition|)
name|sprintf
argument_list|(
name|argBuf
argument_list|,
literal|"%s %s"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"pass"
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|argBuf
argument_list|,
literal|"%s %s"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"nopass"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"r"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|signal_print
index|[
name|oursig
index|]
condition|)
name|sprintf
argument_list|(
name|argBuf
argument_list|,
literal|"%s %s"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"print"
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|argBuf
argument_list|,
literal|"%s %s"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"noprint"
argument_list|)
expr_stmt|;
block|}
else|else
name|validFlag
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|validFlag
condition|)
name|handle_command
argument_list|(
name|argBuf
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"Invalid signal handling flag.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|argBuf
condition|)
name|free
argument_list|(
name|argBuf
argument_list|)
expr_stmt|;
block|}
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print current contents of the tables set by the handle command.    It is possible we should just be printing signals actually used    by the current target (but for things to work right when switching    targets, all signals should be in the signal tables).  */
end_comment

begin_function
specifier|static
name|void
name|signals_info
parameter_list|(
name|signum_exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|signum_exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|enum
name|target_signal
name|oursig
decl_stmt|;
name|sig_print_header
argument_list|()
expr_stmt|;
if|if
condition|(
name|signum_exp
condition|)
block|{
comment|/* First see if this is a symbol name.  */
name|oursig
operator|=
name|target_signal_from_name
argument_list|(
name|signum_exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|oursig
operator|==
name|TARGET_SIGNAL_UNKNOWN
condition|)
block|{
comment|/* No, try numeric.  */
name|oursig
operator|=
name|target_signal_from_command
argument_list|(
name|parse_and_eval_address
argument_list|(
name|signum_exp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sig_print_info
argument_list|(
name|oursig
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* These ugly casts brought to you by the native VAX compiler.  */
for|for
control|(
name|oursig
operator|=
name|TARGET_SIGNAL_FIRST
init|;
operator|(
name|int
operator|)
name|oursig
operator|<
operator|(
name|int
operator|)
name|TARGET_SIGNAL_LAST
condition|;
name|oursig
operator|=
operator|(
expr|enum
name|target_signal
operator|)
operator|(
operator|(
name|int
operator|)
name|oursig
operator|+
literal|1
operator|)
control|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|oursig
operator|!=
name|TARGET_SIGNAL_UNKNOWN
operator|&&
name|oursig
operator|!=
name|TARGET_SIGNAL_DEFAULT
operator|&&
name|oursig
operator|!=
name|TARGET_SIGNAL_0
condition|)
name|sig_print_info
argument_list|(
name|oursig
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"\nUse the \"handle\" command to change these tables.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Save all of the information associated with the inferior<==>gdb    connection.  INF_STATUS is a pointer to a "struct inferior_status"    (defined in inferior.h).  */
end_comment

begin_function
name|void
name|save_inferior_status
parameter_list|(
name|inf_status
parameter_list|,
name|restore_stack_info
parameter_list|)
name|struct
name|inferior_status
modifier|*
name|inf_status
decl_stmt|;
name|int
name|restore_stack_info
decl_stmt|;
block|{
name|inf_status
operator|->
name|stop_signal
operator|=
name|stop_signal
expr_stmt|;
name|inf_status
operator|->
name|stop_pc
operator|=
name|stop_pc
expr_stmt|;
name|inf_status
operator|->
name|stop_step
operator|=
name|stop_step
expr_stmt|;
name|inf_status
operator|->
name|stop_stack_dummy
operator|=
name|stop_stack_dummy
expr_stmt|;
name|inf_status
operator|->
name|stopped_by_random_signal
operator|=
name|stopped_by_random_signal
expr_stmt|;
name|inf_status
operator|->
name|trap_expected
operator|=
name|trap_expected
expr_stmt|;
name|inf_status
operator|->
name|step_range_start
operator|=
name|step_range_start
expr_stmt|;
name|inf_status
operator|->
name|step_range_end
operator|=
name|step_range_end
expr_stmt|;
name|inf_status
operator|->
name|step_frame_address
operator|=
name|step_frame_address
expr_stmt|;
name|inf_status
operator|->
name|step_over_calls
operator|=
name|step_over_calls
expr_stmt|;
name|inf_status
operator|->
name|stop_after_trap
operator|=
name|stop_after_trap
expr_stmt|;
name|inf_status
operator|->
name|stop_soon_quietly
operator|=
name|stop_soon_quietly
expr_stmt|;
comment|/* Save original bpstat chain here; replace it with copy of chain.      If caller's caller is walking the chain, they'll be happier if we      hand them back the original chain when restore_i_s is called.  */
name|inf_status
operator|->
name|stop_bpstat
operator|=
name|stop_bpstat
expr_stmt|;
name|stop_bpstat
operator|=
name|bpstat_copy
argument_list|(
name|stop_bpstat
argument_list|)
expr_stmt|;
name|inf_status
operator|->
name|breakpoint_proceeded
operator|=
name|breakpoint_proceeded
expr_stmt|;
name|inf_status
operator|->
name|restore_stack_info
operator|=
name|restore_stack_info
expr_stmt|;
name|inf_status
operator|->
name|proceed_to_finish
operator|=
name|proceed_to_finish
expr_stmt|;
name|memcpy
argument_list|(
name|inf_status
operator|->
name|stop_registers
argument_list|,
name|stop_registers
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
name|read_register_bytes
argument_list|(
literal|0
argument_list|,
name|inf_status
operator|->
name|registers
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
name|record_selected_frame
argument_list|(
operator|&
operator|(
name|inf_status
operator|->
name|selected_frame_address
operator|)
argument_list|,
operator|&
operator|(
name|inf_status
operator|->
name|selected_level
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_struct
struct|struct
name|restore_selected_frame_args
block|{
name|CORE_ADDR
name|frame_address
decl_stmt|;
name|int
name|level
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|restore_selected_frame
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Restore the selected frame.  args is really a struct    restore_selected_frame_args * (declared as char * for catch_errors)    telling us what frame to restore.  Returns 1 for success, or 0 for    failure.  An error message will have been printed on error.  */
end_comment

begin_function
specifier|static
name|int
name|restore_selected_frame
parameter_list|(
name|args
parameter_list|)
name|PTR
name|args
decl_stmt|;
block|{
name|struct
name|restore_selected_frame_args
modifier|*
name|fr
init|=
operator|(
expr|struct
name|restore_selected_frame_args
operator|*
operator|)
name|args
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
name|int
name|level
init|=
name|fr
operator|->
name|level
decl_stmt|;
name|frame
operator|=
name|find_relative_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
operator|&
name|level
argument_list|)
expr_stmt|;
comment|/* If inf_status->selected_frame_address is NULL, there was no      previously selected frame.  */
if|if
condition|(
name|frame
operator|==
name|NULL
operator|||
comment|/*  FRAME_FP (frame) != fr->frame_address || */
comment|/* elz: deleted this check as a quick fix to the problem that 	 for function called by hand gdb creates no internal frame 	 structure and the real stack and gdb's idea of stack are 	 different if nested calls by hands are made.  	 mvs: this worries me.  */
name|level
operator|!=
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to restore previously selected frame.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|select_frame
argument_list|(
name|frame
argument_list|,
name|fr
operator|->
name|level
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|restore_inferior_status
parameter_list|(
name|inf_status
parameter_list|)
name|struct
name|inferior_status
modifier|*
name|inf_status
decl_stmt|;
block|{
name|stop_signal
operator|=
name|inf_status
operator|->
name|stop_signal
expr_stmt|;
name|stop_pc
operator|=
name|inf_status
operator|->
name|stop_pc
expr_stmt|;
name|stop_step
operator|=
name|inf_status
operator|->
name|stop_step
expr_stmt|;
name|stop_stack_dummy
operator|=
name|inf_status
operator|->
name|stop_stack_dummy
expr_stmt|;
name|stopped_by_random_signal
operator|=
name|inf_status
operator|->
name|stopped_by_random_signal
expr_stmt|;
name|trap_expected
operator|=
name|inf_status
operator|->
name|trap_expected
expr_stmt|;
name|step_range_start
operator|=
name|inf_status
operator|->
name|step_range_start
expr_stmt|;
name|step_range_end
operator|=
name|inf_status
operator|->
name|step_range_end
expr_stmt|;
name|step_frame_address
operator|=
name|inf_status
operator|->
name|step_frame_address
expr_stmt|;
name|step_over_calls
operator|=
name|inf_status
operator|->
name|step_over_calls
expr_stmt|;
name|stop_after_trap
operator|=
name|inf_status
operator|->
name|stop_after_trap
expr_stmt|;
name|stop_soon_quietly
operator|=
name|inf_status
operator|->
name|stop_soon_quietly
expr_stmt|;
name|bpstat_clear
argument_list|(
operator|&
name|stop_bpstat
argument_list|)
expr_stmt|;
name|stop_bpstat
operator|=
name|inf_status
operator|->
name|stop_bpstat
expr_stmt|;
name|breakpoint_proceeded
operator|=
name|inf_status
operator|->
name|breakpoint_proceeded
expr_stmt|;
name|proceed_to_finish
operator|=
name|inf_status
operator|->
name|proceed_to_finish
expr_stmt|;
name|memcpy
argument_list|(
name|stop_registers
argument_list|,
name|inf_status
operator|->
name|stop_registers
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
comment|/* The inferior can be gone if the user types "print exit(0)"      (and perhaps other times).  */
if|if
condition|(
name|target_has_execution
condition|)
name|write_register_bytes
argument_list|(
literal|0
argument_list|,
name|inf_status
operator|->
name|registers
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
comment|/* The inferior can be gone if the user types "print exit(0)"      (and perhaps other times).  */
comment|/* FIXME: If we are being called after stopping in a function which      is called from gdb, we should not be trying to restore the      selected frame; it just prints a spurious error message (The      message is useful, however, in detecting bugs in gdb (like if gdb      clobbers the stack)).  In fact, should we be restoring the      inferior status at all in that case?  .  */
if|if
condition|(
name|target_has_stack
operator|&&
name|inf_status
operator|->
name|restore_stack_info
condition|)
block|{
name|struct
name|restore_selected_frame_args
name|fr
decl_stmt|;
name|fr
operator|.
name|level
operator|=
name|inf_status
operator|->
name|selected_level
expr_stmt|;
name|fr
operator|.
name|frame_address
operator|=
name|inf_status
operator|->
name|selected_frame_address
expr_stmt|;
comment|/* The point of catch_errors is that if the stack is clobbered, 	 walking the stack might encounter a garbage pointer and error() 	 trying to dereference it.  */
if|if
condition|(
name|catch_errors
argument_list|(
name|restore_selected_frame
argument_list|,
operator|&
name|fr
argument_list|,
literal|"Unable to restore previously selected frame:\n"
argument_list|,
name|RETURN_MASK_ERROR
argument_list|)
operator|==
literal|0
condition|)
comment|/* Error in restoring the selected frame.  Select the innermost 	   frame.  */
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|set_follow_fork_mode_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|,
name|c
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|STREQ
argument_list|(
name|arg
argument_list|,
literal|"parent"
argument_list|)
operator|&&
operator|!
name|STREQ
argument_list|(
name|arg
argument_list|,
literal|"child"
argument_list|)
operator|&&
operator|!
name|STREQ
argument_list|(
name|arg
argument_list|,
literal|"both"
argument_list|)
operator|&&
operator|!
name|STREQ
argument_list|(
name|arg
argument_list|,
literal|"ask"
argument_list|)
condition|)
name|error
argument_list|(
literal|"follow-fork-mode must be one of \"parent\", \"child\", \"both\" or \"ask\"."
argument_list|)
expr_stmt|;
if|if
condition|(
name|follow_fork_mode_string
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|follow_fork_mode_string
argument_list|)
expr_stmt|;
name|follow_fork_mode_string
operator|=
name|savestring
argument_list|(
name|arg
argument_list|,
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|_initialize_infrun
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|numsigs
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|add_info
argument_list|(
literal|"signals"
argument_list|,
name|signals_info
argument_list|,
literal|"What debugger does when program gets various signals.\n\ Specify a signal as argument to print info on that signal only."
argument_list|)
expr_stmt|;
name|add_info_alias
argument_list|(
literal|"handle"
argument_list|,
literal|"signals"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"handle"
argument_list|,
name|class_run
argument_list|,
name|handle_command
argument_list|,
name|concat
argument_list|(
literal|"Specify how to handle a signal.\n\ Args are signals and actions to apply to those signals.\n\ Symbolic signals (e.g. SIGSEGV) are recommended but numeric signals\n\ from 1-15 are allowed for compatibility with old versions of GDB.\n\ Numeric ranges may be specified with the form LOW-HIGH (e.g. 1-5).\n\ The special arg \"all\" is recognized to mean all signals except those\n\ used by the debugger, typically SIGTRAP and SIGINT.\n"
argument_list|,
literal|"Recognized actions include \"stop\", \"nostop\", \"print\", \"noprint\",\n\ \"pass\", \"nopass\", \"ignore\", or \"noignore\".\n\ Stop means reenter debugger if this signal happens (implies print).\n\ Print means print a message if this signal happens.\n\ Pass means let program see this signal; otherwise program doesn't know.\n\ Ignore is a synonym for nopass and noignore is a synonym for pass.\n\ Pass and Stop may be combined."
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdb_commands
condition|)
block|{
name|add_com
argument_list|(
literal|"lz"
argument_list|,
name|class_info
argument_list|,
name|signals_info
argument_list|,
literal|"What debugger does when program gets various signals.\n\ Specify a signal as argument to print info on that signal only."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"z"
argument_list|,
name|class_run
argument_list|,
name|xdb_handle_command
argument_list|,
name|concat
argument_list|(
literal|"Specify how to handle a signal.\n\ Args are signals and actions to apply to those signals.\n\ Symbolic signals (e.g. SIGSEGV) are recommended but numeric signals\n\ from 1-15 are allowed for compatibility with old versions of GDB.\n\ Numeric ranges may be specified with the form LOW-HIGH (e.g. 1-5).\n\ The special arg \"all\" is recognized to mean all signals except those\n\ used by the debugger, typically SIGTRAP and SIGINT.\n"
argument_list|,
literal|"Recognized actions include \"s\" (toggles between stop and nostop), \n\ \"r\" (toggles between print and noprint), \"i\" (toggles between pass and \ nopass), \"Q\" (noprint)\n\ Stop means reenter debugger if this signal happens (implies print).\n\ Print means print a message if this signal happens.\n\ Pass means let program see this signal; otherwise program doesn't know.\n\ Ignore is a synonym for nopass and noignore is a synonym for pass.\n\ Pass and Stop may be combined."
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dbx_commands
condition|)
name|stop_command
operator|=
name|add_cmd
argument_list|(
literal|"stop"
argument_list|,
name|class_obscure
argument_list|,
name|not_just_help_class_command
argument_list|,
literal|"There is no `stop' command, but you can set a hook on `stop'.\n\ This allows you to set a list of commands to be run each time execution\n\ of the program stops."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|numsigs
operator|=
operator|(
name|int
operator|)
name|TARGET_SIGNAL_LAST
expr_stmt|;
name|signal_stop
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|signal_stop
index|[
literal|0
index|]
argument_list|)
operator|*
name|numsigs
argument_list|)
expr_stmt|;
name|signal_print
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|signal_print
index|[
literal|0
index|]
argument_list|)
operator|*
name|numsigs
argument_list|)
expr_stmt|;
name|signal_program
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|signal_program
index|[
literal|0
index|]
argument_list|)
operator|*
name|numsigs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numsigs
condition|;
name|i
operator|++
control|)
block|{
name|signal_stop
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|signal_print
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|signal_program
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Signals caused by debugger's own actions      should not be given to the program afterwards.  */
name|signal_program
index|[
name|TARGET_SIGNAL_TRAP
index|]
operator|=
literal|0
expr_stmt|;
name|signal_program
index|[
name|TARGET_SIGNAL_INT
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Signals that are not errors should not normally enter the debugger.  */
name|signal_stop
index|[
name|TARGET_SIGNAL_ALRM
index|]
operator|=
literal|0
expr_stmt|;
name|signal_print
index|[
name|TARGET_SIGNAL_ALRM
index|]
operator|=
literal|0
expr_stmt|;
name|signal_stop
index|[
name|TARGET_SIGNAL_VTALRM
index|]
operator|=
literal|0
expr_stmt|;
name|signal_print
index|[
name|TARGET_SIGNAL_VTALRM
index|]
operator|=
literal|0
expr_stmt|;
name|signal_stop
index|[
name|TARGET_SIGNAL_PROF
index|]
operator|=
literal|0
expr_stmt|;
name|signal_print
index|[
name|TARGET_SIGNAL_PROF
index|]
operator|=
literal|0
expr_stmt|;
name|signal_stop
index|[
name|TARGET_SIGNAL_CHLD
index|]
operator|=
literal|0
expr_stmt|;
name|signal_print
index|[
name|TARGET_SIGNAL_CHLD
index|]
operator|=
literal|0
expr_stmt|;
name|signal_stop
index|[
name|TARGET_SIGNAL_IO
index|]
operator|=
literal|0
expr_stmt|;
name|signal_print
index|[
name|TARGET_SIGNAL_IO
index|]
operator|=
literal|0
expr_stmt|;
name|signal_stop
index|[
name|TARGET_SIGNAL_POLL
index|]
operator|=
literal|0
expr_stmt|;
name|signal_print
index|[
name|TARGET_SIGNAL_POLL
index|]
operator|=
literal|0
expr_stmt|;
name|signal_stop
index|[
name|TARGET_SIGNAL_URG
index|]
operator|=
literal|0
expr_stmt|;
name|signal_print
index|[
name|TARGET_SIGNAL_URG
index|]
operator|=
literal|0
expr_stmt|;
name|signal_stop
index|[
name|TARGET_SIGNAL_WINCH
index|]
operator|=
literal|0
expr_stmt|;
name|signal_print
index|[
name|TARGET_SIGNAL_WINCH
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SOLIB_ADD
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"stop-on-solib-events"
argument_list|,
name|class_support
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|stop_on_solib_events
argument_list|,
literal|"Set stopping for shared library events.\n\ If nonzero, gdb will give control to the user when the dynamic linker\n\ notifies gdb of shared library events.  The most common event of interest\n\ to the user would be loading/unloading of a new library.\n"
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|c
operator|=
name|add_set_enum_cmd
argument_list|(
literal|"follow-fork-mode"
argument_list|,
name|class_run
argument_list|,
name|follow_fork_mode_kind_names
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|follow_fork_mode_string
argument_list|,
comment|/* ??rehrauer:  The "both" option is broken, by what may be a 10.20    kernel problem.  It's also not terribly useful without a GUI to    help the user drive two debuggers.  So for now, I'm disabling    the "both" option.  */
comment|/*			"Set debugger response to a program call of fork \ or vfork.\n\ A fork or vfork creates a new process.  follow-fork-mode can be:\n\   parent  - the original process is debugged after a fork\n\   child   - the new process is debugged after a fork\n\   both    - both the parent and child are debugged after a fork\n\   ask     - the debugger will ask for one of the above choices\n\ For \"both\", another copy of the debugger will be started to follow\n\ the new child process.  The original debugger will continue to follow\n\ the original parent process.  To distinguish their prompts, the\n\ debugger copy's prompt will be changed.\n\ For \"parent\" or \"child\", the unfollowed process will run free.\n\ By default, the debugger will follow the parent process.", */
literal|"Set debugger response to a program call of fork \ or vfork.\n\ A fork or vfork creates a new process.  follow-fork-mode can be:\n\   parent  - the original process is debugged after a fork\n\   child   - the new process is debugged after a fork\n\   ask     - the debugger will ask for one of the above choices\n\ For \"parent\" or \"child\", the unfollowed process will run free.\n\ By default, the debugger will follow the parent process."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
comment|/*  c->function.sfunc = ;*/
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|set_follow_fork_mode_command
argument_list|(
literal|"parent"
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_set_enum_cmd
argument_list|(
literal|"scheduler-locking"
argument_list|,
name|class_run
argument_list|,
name|scheduler_enums
argument_list|,
comment|/* array of string names */
operator|(
name|char
operator|*
operator|)
operator|&
name|scheduler_mode
argument_list|,
comment|/* current mode  */
literal|"Set mode for locking scheduler during execution.\n\ off  == no locking (threads may preempt at any time)\n\ on   == full locking (no thread except the current thread may run)\n\ step == scheduler locked during every single-step operation.\n\ 	In this mode, no other thread may run during a step command.\n\ 	Other threads may run while stepping over a function call ('next')."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|c
operator|->
name|function
operator|.
name|sfunc
operator|=
name|set_schedlock_func
expr_stmt|;
comment|/* traps on target vector */
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

