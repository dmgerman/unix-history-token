begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target-struct-independent code to start (run) and stop an inferior    process.     Copyright 1986, 1987, 1988, 1989, 1990, 1991, 1992, 1993, 1994,    1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free    Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"gdb_wait.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"cli/cli-script.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbthread.h"
end_include

begin_include
include|#
directive|include
file|"annotate.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"top.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"inf-loop.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"observer.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_function_decl
specifier|static
name|void
name|signals_info
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sig_print_info
parameter_list|(
name|enum
name|target_signal
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sig_print_header
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|resume_cleanups
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hook_stop_stub
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|delete_breakpoint_current_contents
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|restore_selected_frame
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_infrun
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|follow_fork
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_schedlock_func
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_struct_decl
struct_decl|struct
name|execution_control_state
struct_decl|;
end_struct_decl

begin_function_decl
specifier|static
name|int
name|currently_stepping
parameter_list|(
name|struct
name|execution_control_state
modifier|*
name|ecs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xdb_handle_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|prepare_to_proceed
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|_initialize_infrun
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|inferior_ignoring_startup_exec_events
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|inferior_ignoring_leading_exec_events
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When set, stop the 'step' command if we enter a function which has    no line number information.  The normal behavior is that we step    over such function.  */
end_comment

begin_decl_stmt
name|int
name|step_stop_if_no_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In asynchronous mode, but simulating synchronous execution. */
end_comment

begin_decl_stmt
name|int
name|sync_execution
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* wait_for_inferior and normal_stop use this to notify the user    when the inferior stopped in a different thread than it had been    running in.  */
end_comment

begin_decl_stmt
specifier|static
name|ptid_t
name|previous_inferior_ptid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is true for configurations that may follow through execl() and    similar functions.  At present this is only true for HP-UX native.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAY_FOLLOW_EXEC
end_ifndef

begin_define
define|#
directive|define
name|MAY_FOLLOW_EXEC
value|(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|may_follow_exec
init|=
name|MAY_FOLLOW_EXEC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If the program uses ELF-style shared libraries, then calls to    functions in shared libraries go through stubs, which live in a    table called the PLT (Procedure Linkage Table).  The first time the    function is called, the stub sends control to the dynamic linker,    which looks up the function's real address, patches the stub so    that future calls will go directly to the function, and then passes    control to the function.     If we are stepping at the source level, we don't want to see any of    this --- we just want to skip over the stub and the dynamic linker.    The simple approach is to single-step until control leaves the    dynamic linker.     However, on some systems (e.g., Red Hat's 5.2 distribution) the    dynamic linker calls functions in the shared C library, so you    can't tell from the PC alone whether the dynamic linker is still    running.  In this case, we use a step-resume breakpoint to get us    past the dynamic linker, as if we were using "next" to step over a    function call.     IN_SOLIB_DYNSYM_RESOLVE_CODE says whether we're in the dynamic    linker code or not.  Normally, this means we single-step.  However,    if SKIP_SOLIB_RESOLVER then returns non-zero, then its value is an    address where we can place a step-resume breakpoint to get past the    linker's symbol resolution function.     IN_SOLIB_DYNSYM_RESOLVE_CODE can generally be implemented in a    pretty portable way, by comparing the PC against the address ranges    of the dynamic linker's sections.     SKIP_SOLIB_RESOLVER is generally going to be system-specific, since    it depends on internal details of the dynamic linker.  It's usually    not too hard to figure out where to put a breakpoint, but it    certainly isn't portable.  SKIP_SOLIB_RESOLVER should do plenty of    sanity checking.  If it can't figure things out, returning zero and    getting the (possibly confusing) stepping behavior is better than    signalling an error, which will obscure the change in the    inferior's state.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|IN_SOLIB_DYNSYM_RESOLVE_CODE
end_ifndef

begin_define
define|#
directive|define
name|IN_SOLIB_DYNSYM_RESOLVE_CODE
parameter_list|(
name|pc
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This function returns TRUE if pc is the address of an instruction    that lies within the dynamic linker (such as the event hook, or the    dld itself).     This function must be used only when a dynamic linker event has    been caught, and the inferior is being stepped out of the hook, or    undefined results are guaranteed.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SOLIB_IN_DYNAMIC_LINKER
end_ifndef

begin_define
define|#
directive|define
name|SOLIB_IN_DYNAMIC_LINKER
parameter_list|(
name|pid
parameter_list|,
name|pc
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* On MIPS16, a function that returns a floating point value may call    a library helper function to copy the return value to a floating point    register.  The IGNORE_HELPER_CALL macro returns non-zero if we    should ignore (i.e. step over) this function call.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|IGNORE_HELPER_CALL
end_ifndef

begin_define
define|#
directive|define
name|IGNORE_HELPER_CALL
parameter_list|(
name|pc
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* On some systems, the PC may be left pointing at an instruction that  won't    actually be executed.  This is usually indicated by a bit in the PSW.  If    we find ourselves in such a state, then we step the target beyond the    nullified instruction before returning control to the user so as to avoid    confusion. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|INSTRUCTION_NULLIFIED
end_ifndef

begin_define
define|#
directive|define
name|INSTRUCTION_NULLIFIED
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We can't step off a permanent breakpoint in the ordinary way, because we    can't remove it.  Instead, we have to advance the PC to the next    instruction.  This macro should expand to a pointer to a function that    does that, or zero if we have no such function.  If we don't have a    definition for it, we have to report an error.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SKIP_PERMANENT_BREAKPOINT
end_ifndef

begin_define
define|#
directive|define
name|SKIP_PERMANENT_BREAKPOINT
value|(default_skip_permanent_breakpoint)
end_define

begin_function
specifier|static
name|void
name|default_skip_permanent_breakpoint
parameter_list|(
name|void
parameter_list|)
block|{
name|error
argument_list|(
literal|"\ The program is stopped at a permanent breakpoint, but GDB does not know\n\ how to step past a permanent breakpoint on this architecture.  Try using\n\ a command like `return' or `jump' to continue execution."
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Convert the #defines into values.  This is temporary until wfi control    flow is completely sorted out.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_STEPPABLE_WATCHPOINT
end_ifndef

begin_define
define|#
directive|define
name|HAVE_STEPPABLE_WATCHPOINT
value|0
end_define

begin_else
else|#
directive|else
end_else

begin_undef
undef|#
directive|undef
name|HAVE_STEPPABLE_WATCHPOINT
end_undef

begin_define
define|#
directive|define
name|HAVE_STEPPABLE_WATCHPOINT
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CANNOT_STEP_HW_WATCHPOINTS
end_ifndef

begin_define
define|#
directive|define
name|CANNOT_STEP_HW_WATCHPOINTS
value|0
end_define

begin_else
else|#
directive|else
end_else

begin_undef
undef|#
directive|undef
name|CANNOT_STEP_HW_WATCHPOINTS
end_undef

begin_define
define|#
directive|define
name|CANNOT_STEP_HW_WATCHPOINTS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Tables of how to react to signals; the user sets them.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|signal_stop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|signal_print
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|char
modifier|*
name|signal_program
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SET_SIGS
parameter_list|(
name|nsigs
parameter_list|,
name|sigs
parameter_list|,
name|flags
parameter_list|)
define|\
value|do { \     int signum = (nsigs); \     while (signum--> 0) \       if ((sigs)[signum]) \ 	(flags)[signum] = 1; \   } while (0)
end_define

begin_define
define|#
directive|define
name|UNSET_SIGS
parameter_list|(
name|nsigs
parameter_list|,
name|sigs
parameter_list|,
name|flags
parameter_list|)
define|\
value|do { \     int signum = (nsigs); \     while (signum--> 0) \       if ((sigs)[signum]) \ 	(flags)[signum] = 0; \   } while (0)
end_define

begin_comment
comment|/* Value to pass to target_resume() to cause all threads to resume */
end_comment

begin_define
define|#
directive|define
name|RESUME_ALL
value|(pid_to_ptid (-1))
end_define

begin_comment
comment|/* Command list pointer for the "stop" placeholder.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cmd_list_element
modifier|*
name|stop_command
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if breakpoints are now inserted in the inferior.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|breakpoints_inserted
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function inferior was in as of last step command.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|symbol
modifier|*
name|step_start_function
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we are expecting a trace trap and should proceed from it.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|trap_expected
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SOLIB_ADD
end_ifdef

begin_comment
comment|/* Nonzero if we want to give control to the user when we're notified    of shared library events by the dynamic linker.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stop_on_solib_events
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HP_OS_BUG
end_ifdef

begin_comment
comment|/* Nonzero if the next time we try to continue the inferior, it will    step one instruction and generate a spurious trace trap.    This is used to compensate for a bug in HP-UX.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|trap_expected_after_continue
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Nonzero means expecting a trace trap    and should stop the inferior and return silently when it happens.  */
end_comment

begin_decl_stmt
name|int
name|stop_after_trap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means expecting a trap and caller will handle it themselves.    It is used after attach, due to attaching to a process;    when running in the shell before the child program has been exec'd;    and when running some kinds of remote stuff (FIXME?).  */
end_comment

begin_decl_stmt
name|enum
name|stop_kind
name|stop_soon
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if proceed is being used for a "finish" command or a similar    situation when stop_registers should be saved.  */
end_comment

begin_decl_stmt
name|int
name|proceed_to_finish
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Save register contents here when about to pop a stack dummy frame,    if-and-only-if proceed_to_finish is set.    Thus this contains the return value from the called function (assuming    values are returned in a register).  */
end_comment

begin_decl_stmt
name|struct
name|regcache
modifier|*
name|stop_registers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if program stopped due to error trying to insert breakpoints.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|breakpoints_failed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero after stop if current stack frame should be printed.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stop_print_frame
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|breakpoint
modifier|*
name|step_resume_breakpoint
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|breakpoint
modifier|*
name|through_sigtramp_breakpoint
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* On some platforms (e.g., HP-UX), hardware watchpoints have bad    interactions with an inferior that is running a kernel function    (aka, a system call or "syscall").  wait_for_inferior therefore    may have a need to know when the inferior is in a syscall.  This    is a count of the number of inferior threads which are known to    currently be running in a syscall. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|number_of_threads_in_syscalls
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is a cached copy of the pid/waitstatus of the last event    returned by target_wait()/target_wait_hook().  This information is    returned by get_last_target_status(). */
end_comment

begin_decl_stmt
specifier|static
name|ptid_t
name|target_last_wait_ptid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|target_waitstatus
name|target_last_waitstatus
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is used to remember when a fork, vfork or exec event    was caught by a catchpoint, and thus the event is to be    followed at the next resume of the inferior, and not    immediately. */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|enum
name|target_waitkind
name|kind
decl_stmt|;
struct|struct
block|{
name|int
name|parent_pid
decl_stmt|;
name|int
name|child_pid
decl_stmt|;
block|}
name|fork_event
struct|;
name|char
modifier|*
name|execd_pathname
decl_stmt|;
block|}
name|pending_follow
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|char
name|follow_fork_mode_child
index|[]
init|=
literal|"child"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|follow_fork_mode_parent
index|[]
init|=
literal|"parent"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|follow_fork_mode_kind_names
index|[]
init|=
block|{
name|follow_fork_mode_child
block|,
name|follow_fork_mode_parent
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|follow_fork_mode_string
init|=
name|follow_fork_mode_parent
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
specifier|static
name|int
name|follow_fork
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|follow_child
init|=
operator|(
name|follow_fork_mode_string
operator|==
name|follow_fork_mode_child
operator|)
decl_stmt|;
return|return
name|target_follow_fork
argument_list|(
name|follow_child
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|follow_inferior_reset_breakpoints
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Was there a step_resume breakpoint?  (There was if the user      did a "next" at the fork() call.)  If so, explicitly reset its      thread number.       step_resumes are a form of bp that are made to be per-thread.      Since we created the step_resume bp when the parent process      was being debugged, and now are switching to the child process,      from the breakpoint package's viewpoint, that's a switch of      "threads".  We must update the bp's notion of which thread      it is for, or it'll be ignored when it triggers.  */
if|if
condition|(
name|step_resume_breakpoint
condition|)
name|breakpoint_re_set_thread
argument_list|(
name|step_resume_breakpoint
argument_list|)
expr_stmt|;
comment|/* Reinsert all breakpoints in the child.  The user may have set      breakpoints after catching the fork, in which case those      were never set in the child, but only in the parent.  This makes      sure the inserted breakpoints match the breakpoint list.  */
name|breakpoint_re_set
argument_list|()
expr_stmt|;
name|insert_breakpoints
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* EXECD_PATHNAME is assumed to be non-NULL. */
end_comment

begin_function
specifier|static
name|void
name|follow_exec
parameter_list|(
name|int
name|pid
parameter_list|,
name|char
modifier|*
name|execd_pathname
parameter_list|)
block|{
name|int
name|saved_pid
init|=
name|pid
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|tgt
decl_stmt|;
if|if
condition|(
operator|!
name|may_follow_exec
condition|)
return|return;
comment|/* This is an exec event that we actually wish to pay attention to.      Refresh our symbol table to the newly exec'd program, remove any      momentary bp's, etc.       If there are breakpoints, they aren't really inserted now,      since the exec() transformed our inferior into a fresh set      of instructions.       We want to preserve symbolic breakpoints on the list, since      we have hopes that they can be reset after the new a.out's      symbol table is read.       However, any "raw" breakpoints must be removed from the list      (e.g., the solib bp's), since their address is probably invalid      now.       And, we DON'T want to call delete_breakpoints() here, since      that may write the bp's "shadow contents" (the instruction      value that was overwritten witha TRAP instruction).  Since      we now have a new a.out, those shadow contents aren't valid. */
name|update_breakpoints_after_exec
argument_list|()
expr_stmt|;
comment|/* If there was one, it's gone now.  We cannot truly step-to-next      statement through an exec(). */
name|step_resume_breakpoint
operator|=
name|NULL
expr_stmt|;
name|step_range_start
operator|=
literal|0
expr_stmt|;
name|step_range_end
operator|=
literal|0
expr_stmt|;
comment|/* If there was one, it's gone now. */
name|through_sigtramp_breakpoint
operator|=
name|NULL
expr_stmt|;
comment|/* What is this a.out's name? */
name|printf_unfiltered
argument_list|(
literal|"Executing new program: %s\n"
argument_list|,
name|execd_pathname
argument_list|)
expr_stmt|;
comment|/* We've followed the inferior through an exec.  Therefore, the      inferior has essentially been killed& reborn. */
comment|/* First collect the run target in effect.  */
name|tgt
operator|=
name|find_run_target
argument_list|()
expr_stmt|;
comment|/* If we can't find one, things are in a very strange state...  */
if|if
condition|(
name|tgt
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Could find run target to save before following exec"
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|target_mourn_inferior
argument_list|()
expr_stmt|;
name|inferior_ptid
operator|=
name|pid_to_ptid
argument_list|(
name|saved_pid
argument_list|)
expr_stmt|;
comment|/* Because mourn_inferior resets inferior_ptid. */
name|push_target
argument_list|(
name|tgt
argument_list|)
expr_stmt|;
comment|/* That a.out is now the one to use. */
name|exec_file_attach
argument_list|(
name|execd_pathname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* And also is where symbols can be found. */
name|symbol_file_add_main
argument_list|(
name|execd_pathname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Reset the shared library package.  This ensures that we get      a shlib event when the child reaches "_start", at which point      the dld will have had a chance to initialize the child. */
if|#
directive|if
name|defined
argument_list|(
name|SOLIB_RESTART
argument_list|)
name|SOLIB_RESTART
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SOLIB_CREATE_INFERIOR_HOOK
name|SOLIB_CREATE_INFERIOR_HOOK
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Reinsert all breakpoints.  (Those which were symbolic have      been reset to the proper address in the new a.out, thanks      to symbol_file_command...) */
name|insert_breakpoints
argument_list|()
expr_stmt|;
comment|/* The next resume of this inferior should bring it to the shlib      startup breakpoints.  (If the user had also set bp's on      "main" from the old (parent) process, then they'll auto-      matically get reset there in the new process.) */
block|}
end_function

begin_comment
comment|/* Non-zero if we just simulating a single-step.  This is needed    because we cannot remove the breakpoints in the inferior process    until after the `wait' in `wait_for_inferior'.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|singlestep_breakpoints_inserted_p
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The thread we inserted single-step breakpoints for.  */
end_comment

begin_decl_stmt
specifier|static
name|ptid_t
name|singlestep_ptid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If another thread hit the singlestep breakpoint, we save the original    thread here so that we can resume single-stepping it later.  */
end_comment

begin_decl_stmt
specifier|static
name|ptid_t
name|saved_singlestep_ptid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stepping_past_singlestep_breakpoint
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Things to clean up if we QUIT out of resume ().  */
end_comment

begin_function
specifier|static
name|void
name|resume_cleanups
parameter_list|(
name|void
modifier|*
name|ignore
parameter_list|)
block|{
name|normal_stop
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
name|schedlock_off
index|[]
init|=
literal|"off"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|schedlock_on
index|[]
init|=
literal|"on"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|schedlock_step
index|[]
init|=
literal|"step"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|scheduler_mode
init|=
name|schedlock_off
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|scheduler_enums
index|[]
init|=
block|{
name|schedlock_off
block|,
name|schedlock_on
block|,
name|schedlock_step
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|set_schedlock_func
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
comment|/* NOTE: cagney/2002-03-17: The add_show_from_set() function clones      the set command passed as a parameter.  The clone operation will      include (BUG?) any ``set'' command callback, if present.      Commands like ``info set'' call all the ``show'' command      callbacks.  Unfortunately, for ``show'' commands cloned from      ``set'', this includes callbacks belonging to ``set'' commands.      Making this worse, this only occures if add_show_from_set() is      called after add_cmd_sfunc() (BUG?).  */
if|if
condition|(
name|cmd_type
argument_list|(
name|c
argument_list|)
operator|==
name|set_cmd
condition|)
if|if
condition|(
operator|!
name|target_can_lock_scheduler
condition|)
block|{
name|scheduler_mode
operator|=
name|schedlock_off
expr_stmt|;
name|error
argument_list|(
literal|"Target '%s' cannot support this command."
argument_list|,
name|target_shortname
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Resume the inferior, but allow a QUIT.  This is useful if the user    wants to interrupt some lengthy single-stepping operation    (for child processes, the SIGINT goes to the inferior, and so    we get a SIGINT random_signal, but for remote debugging and perhaps    other targets, that's not true).     STEP nonzero if we should step (zero to continue instead).    SIG is the signal to give the inferior (zero for none).  */
end_comment

begin_function
name|void
name|resume
parameter_list|(
name|int
name|step
parameter_list|,
name|enum
name|target_signal
name|sig
parameter_list|)
block|{
name|int
name|should_resume
init|=
literal|1
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_cleanups
init|=
name|make_cleanup
argument_list|(
name|resume_cleanups
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|QUIT
expr_stmt|;
comment|/* FIXME: calling breakpoint_here_p (read_pc ()) three times! */
comment|/* Some targets (e.g. Solaris x86) have a kernel bug when stepping      over an instruction that causes a page fault without triggering      a hardware watchpoint. The kernel properly notices that it shouldn't      stop, because the hardware watchpoint is not triggered, but it forgets      the step request and continues the program normally.      Work around the problem by removing hardware watchpoints if a step is      requested, GDB will check for a hardware watchpoint trigger after the      step anyway.  */
if|if
condition|(
name|CANNOT_STEP_HW_WATCHPOINTS
operator|&&
name|step
operator|&&
name|breakpoints_inserted
condition|)
name|remove_hw_watchpoints
argument_list|()
expr_stmt|;
comment|/* Normally, by the time we reach `resume', the breakpoints are either      removed or inserted, as appropriate.  The exception is if we're sitting      at a permanent breakpoint; we need to step over it, but permanent      breakpoints can't be removed.  So we have to test for it here.  */
if|if
condition|(
name|breakpoint_here_p
argument_list|(
name|read_pc
argument_list|()
argument_list|)
operator|==
name|permanent_breakpoint_here
condition|)
name|SKIP_PERMANENT_BREAKPOINT
argument_list|()
expr_stmt|;
if|if
condition|(
name|SOFTWARE_SINGLE_STEP_P
argument_list|()
operator|&&
name|step
condition|)
block|{
comment|/* Do it the hard way, w/temp breakpoints */
name|SOFTWARE_SINGLE_STEP
argument_list|(
name|sig
argument_list|,
literal|1
comment|/*insert-breakpoints */
argument_list|)
expr_stmt|;
comment|/* ...and don't ask hardware to do it.  */
name|step
operator|=
literal|0
expr_stmt|;
comment|/* and do not pull these breakpoints until after a `wait' in          `wait_for_inferior' */
name|singlestep_breakpoints_inserted_p
operator|=
literal|1
expr_stmt|;
name|singlestep_ptid
operator|=
name|inferior_ptid
expr_stmt|;
block|}
comment|/* Handle any optimized stores to the inferior NOW...  */
ifdef|#
directive|ifdef
name|DO_DEFERRED_STORES
name|DO_DEFERRED_STORES
expr_stmt|;
endif|#
directive|endif
comment|/* If there were any forks/vforks/execs that were caught and are      now to be followed, then do so.  */
switch|switch
condition|(
name|pending_follow
operator|.
name|kind
condition|)
block|{
case|case
name|TARGET_WAITKIND_FORKED
case|:
case|case
name|TARGET_WAITKIND_VFORKED
case|:
name|pending_follow
operator|.
name|kind
operator|=
name|TARGET_WAITKIND_SPURIOUS
expr_stmt|;
if|if
condition|(
name|follow_fork
argument_list|()
condition|)
name|should_resume
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|TARGET_WAITKIND_EXECD
case|:
comment|/* follow_exec is called as soon as the exec event is seen. */
name|pending_follow
operator|.
name|kind
operator|=
name|TARGET_WAITKIND_SPURIOUS
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Install inferior's terminal modes.  */
name|target_terminal_inferior
argument_list|()
expr_stmt|;
if|if
condition|(
name|should_resume
condition|)
block|{
name|ptid_t
name|resume_ptid
decl_stmt|;
name|resume_ptid
operator|=
name|RESUME_ALL
expr_stmt|;
comment|/* Default */
if|if
condition|(
operator|(
name|step
operator|||
name|singlestep_breakpoints_inserted_p
operator|)
operator|&&
operator|(
name|stepping_past_singlestep_breakpoint
operator|||
operator|(
operator|!
name|breakpoints_inserted
operator|&&
name|breakpoint_here_p
argument_list|(
name|read_pc
argument_list|()
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* Stepping past a breakpoint without inserting breakpoints. 	     Make sure only the current thread gets to step, so that 	     other threads don't sneak past breakpoints while they are 	     not inserted. */
name|resume_ptid
operator|=
name|inferior_ptid
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|scheduler_mode
operator|==
name|schedlock_on
operator|)
operator|||
operator|(
name|scheduler_mode
operator|==
name|schedlock_step
operator|&&
operator|(
name|step
operator|||
name|singlestep_breakpoints_inserted_p
operator|)
operator|)
condition|)
block|{
comment|/* User-settable 'scheduler' mode requires solo thread resume. */
name|resume_ptid
operator|=
name|inferior_ptid
expr_stmt|;
block|}
if|if
condition|(
name|CANNOT_STEP_BREAKPOINT
condition|)
block|{
comment|/* Most targets can step a breakpoint instruction, thus 	     executing it normally.  But if this one cannot, just 	     continue and we will hit it anyway.  */
if|if
condition|(
name|step
operator|&&
name|breakpoints_inserted
operator|&&
name|breakpoint_here_p
argument_list|(
name|read_pc
argument_list|()
argument_list|)
condition|)
name|step
operator|=
literal|0
expr_stmt|;
block|}
name|target_resume
argument_list|(
name|resume_ptid
argument_list|,
name|step
argument_list|,
name|sig
argument_list|)
expr_stmt|;
block|}
name|discard_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Clear out all variables saying what to do when inferior is continued.    First do this, then set the ones you want, then call `proceed'.  */
end_comment

begin_function
name|void
name|clear_proceed_status
parameter_list|(
name|void
parameter_list|)
block|{
name|trap_expected
operator|=
literal|0
expr_stmt|;
name|step_range_start
operator|=
literal|0
expr_stmt|;
name|step_range_end
operator|=
literal|0
expr_stmt|;
name|step_frame_id
operator|=
name|null_frame_id
expr_stmt|;
name|step_over_calls
operator|=
name|STEP_OVER_UNDEBUGGABLE
expr_stmt|;
name|stop_after_trap
operator|=
literal|0
expr_stmt|;
name|stop_soon
operator|=
name|NO_STOP_QUIETLY
expr_stmt|;
name|proceed_to_finish
operator|=
literal|0
expr_stmt|;
name|breakpoint_proceeded
operator|=
literal|1
expr_stmt|;
comment|/* We're about to proceed... */
comment|/* Discard any remaining commands or status from previous stop.  */
name|bpstat_clear
argument_list|(
operator|&
name|stop_bpstat
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This should be suitable for any targets that support threads. */
end_comment

begin_function
specifier|static
name|int
name|prepare_to_proceed
parameter_list|(
name|void
parameter_list|)
block|{
name|ptid_t
name|wait_ptid
decl_stmt|;
name|struct
name|target_waitstatus
name|wait_status
decl_stmt|;
comment|/* Get the last target status returned by target_wait().  */
name|get_last_target_status
argument_list|(
operator|&
name|wait_ptid
argument_list|,
operator|&
name|wait_status
argument_list|)
expr_stmt|;
comment|/* Make sure we were stopped either at a breakpoint, or because      of a Ctrl-C.  */
if|if
condition|(
name|wait_status
operator|.
name|kind
operator|!=
name|TARGET_WAITKIND_STOPPED
operator|||
operator|(
name|wait_status
operator|.
name|value
operator|.
name|sig
operator|!=
name|TARGET_SIGNAL_TRAP
operator|&&
name|wait_status
operator|.
name|value
operator|.
name|sig
operator|!=
name|TARGET_SIGNAL_INT
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|ptid_equal
argument_list|(
name|wait_ptid
argument_list|,
name|minus_one_ptid
argument_list|)
operator|&&
operator|!
name|ptid_equal
argument_list|(
name|inferior_ptid
argument_list|,
name|wait_ptid
argument_list|)
condition|)
block|{
comment|/* Switched over from WAIT_PID.  */
name|CORE_ADDR
name|wait_pc
init|=
name|read_pc_pid
argument_list|(
name|wait_ptid
argument_list|)
decl_stmt|;
if|if
condition|(
name|wait_pc
operator|!=
name|read_pc
argument_list|()
condition|)
block|{
comment|/* Switch back to WAIT_PID thread.  */
name|inferior_ptid
operator|=
name|wait_ptid
expr_stmt|;
comment|/* FIXME: This stuff came from switch_to_thread() in 	     thread.c (which should probably be a public function).  */
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|registers_changed
argument_list|()
expr_stmt|;
name|stop_pc
operator|=
name|wait_pc
expr_stmt|;
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* We return 1 to indicate that there is a breakpoint here, 	   so we need to step over it before continuing to avoid 	   hitting it straight away. */
if|if
condition|(
name|breakpoint_here_p
argument_list|(
name|wait_pc
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Record the pc of the program the last time it stopped.  This is    just used internally by wait_for_inferior, but need to be preserved    over calls to it and cleared when the inferior is started.  */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|prev_pc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Basic routine for continuing the program in various fashions.     ADDR is the address to resume at, or -1 for resume where stopped.    SIGGNAL is the signal to give it, or 0 for none,    or -1 for act according to how it stopped.    STEP is nonzero if should trap after one instruction.    -1 means return after that and print nothing.    You should probably set various step_... variables    before calling here, if you are stepping.     You should call clear_proceed_status before calling proceed.  */
end_comment

begin_function
name|void
name|proceed
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|enum
name|target_signal
name|siggnal
parameter_list|,
name|int
name|step
parameter_list|)
block|{
name|int
name|oneproc
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|step
operator|>
literal|0
condition|)
name|step_start_function
operator|=
name|find_pc_function
argument_list|(
name|read_pc
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|step
operator|<
literal|0
condition|)
name|stop_after_trap
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|addr
operator|==
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* If there is a breakpoint at the address we will resume at,          step one instruction before inserting breakpoints          so that we do not stop right away (and report a second          hit at this breakpoint).  */
if|if
condition|(
name|read_pc
argument_list|()
operator|==
name|stop_pc
operator|&&
name|breakpoint_here_p
argument_list|(
name|read_pc
argument_list|()
argument_list|)
condition|)
name|oneproc
operator|=
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|STEP_SKIPS_DELAY
define|#
directive|define
name|STEP_SKIPS_DELAY
parameter_list|(
name|pc
parameter_list|)
value|(0)
define|#
directive|define
name|STEP_SKIPS_DELAY_P
value|(0)
endif|#
directive|endif
comment|/* Check breakpoint_here_p first, because breakpoint_here_p is fast          (it just checks internal GDB data structures) and STEP_SKIPS_DELAY          is slow (it needs to read memory from the target).  */
if|if
condition|(
name|STEP_SKIPS_DELAY_P
operator|&&
name|breakpoint_here_p
argument_list|(
name|read_pc
argument_list|()
operator|+
literal|4
argument_list|)
operator|&&
name|STEP_SKIPS_DELAY
argument_list|(
name|read_pc
argument_list|()
argument_list|)
condition|)
name|oneproc
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|write_pc
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
comment|/* In a multi-threaded task we may select another thread      and then continue or step.       But if the old thread was stopped at a breakpoint, it      will immediately cause another breakpoint stop without      any execution (i.e. it will report a breakpoint hit      incorrectly).  So we must step over it first.       prepare_to_proceed checks the current thread against the thread      that reported the most recent event.  If a step-over is required      it returns TRUE and sets the current thread to the old thread. */
if|if
condition|(
name|prepare_to_proceed
argument_list|()
operator|&&
name|breakpoint_here_p
argument_list|(
name|read_pc
argument_list|()
argument_list|)
condition|)
name|oneproc
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|HP_OS_BUG
if|if
condition|(
name|trap_expected_after_continue
condition|)
block|{
comment|/* If (step == 0), a trap will be automatically generated after          the first instruction is executed.  Force step one          instruction to clear this condition.  This should not occur          if step is nonzero, but it is harmless in that case.  */
name|oneproc
operator|=
literal|1
expr_stmt|;
name|trap_expected_after_continue
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* HP_OS_BUG */
if|if
condition|(
name|oneproc
condition|)
comment|/* We will get a trace trap after one instruction.        Continue it automatically and insert breakpoints then.  */
name|trap_expected
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|insert_breakpoints
argument_list|()
expr_stmt|;
comment|/* If we get here there was no call to error() in  	 insert breakpoints -- so they were inserted.  */
name|breakpoints_inserted
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|siggnal
operator|!=
name|TARGET_SIGNAL_DEFAULT
condition|)
name|stop_signal
operator|=
name|siggnal
expr_stmt|;
comment|/* If this signal should not be seen by program,      give it zero.  Used for debugging signals.  */
elseif|else
if|if
condition|(
operator|!
name|signal_program
index|[
name|stop_signal
index|]
condition|)
name|stop_signal
operator|=
name|TARGET_SIGNAL_0
expr_stmt|;
name|annotate_starting
argument_list|()
expr_stmt|;
comment|/* Make sure that output from GDB appears before output from the      inferior.  */
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
comment|/* Refresh prev_pc value just prior to resuming.  This used to be      done in stop_stepping, however, setting prev_pc there did not handle      scenarios such as inferior function calls or returning from      a function via the return command.  In those cases, the prev_pc      value was not set properly for subsequent commands.  The prev_pc value       is used to initialize the starting line number in the ecs.  With an       invalid value, the gdb next command ends up stopping at the position      represented by the next line table entry past our start position.      On platforms that generate one line table entry per line, this      is not a problem.  However, on the ia64, the compiler generates      extraneous line table entries that do not increase the line number.      When we issue the gdb next command on the ia64 after an inferior call      or a return command, we often end up a few instructions forward, still       within the original line we started.       An attempt was made to have init_execution_control_state () refresh      the prev_pc value before calculating the line number.  This approach      did not work because on platforms that use ptrace, the pc register      cannot be read unless the inferior is stopped.  At that point, we      are not guaranteed the inferior is stopped and so the read_pc ()      call can fail.  Setting the prev_pc value here ensures the value is       updated correctly when the inferior is stopped.  */
name|prev_pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
comment|/* Resume inferior.  */
name|resume
argument_list|(
name|oneproc
operator|||
name|step
operator|||
name|bpstat_should_step
argument_list|()
argument_list|,
name|stop_signal
argument_list|)
expr_stmt|;
comment|/* Wait for it to stop (if not standalone)      and in any case decode why it stopped, and act accordingly.  */
comment|/* Do this only if we are not using the event loop, or if the target      does not support asynchronous execution. */
if|if
condition|(
operator|!
name|event_loop_p
operator|||
operator|!
name|target_can_async_p
argument_list|()
condition|)
block|{
name|wait_for_inferior
argument_list|()
expr_stmt|;
name|normal_stop
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Start remote-debugging of a machine over a serial link.  */
end_comment

begin_function
name|void
name|start_remote
parameter_list|(
name|void
parameter_list|)
block|{
name|init_thread_list
argument_list|()
expr_stmt|;
name|init_wait_for_inferior
argument_list|()
expr_stmt|;
name|stop_soon
operator|=
name|STOP_QUIETLY
expr_stmt|;
name|trap_expected
operator|=
literal|0
expr_stmt|;
comment|/* Always go on waiting for the target, regardless of the mode. */
comment|/* FIXME: cagney/1999-09-23: At present it isn't possible to      indicate to wait_for_inferior that a target should timeout if      nothing is returned (instead of just blocking).  Because of this,      targets expecting an immediate response need to, internally, set      things up so that the target_wait() is forced to eventually      timeout. */
comment|/* FIXME: cagney/1999-09-24: It isn't possible for target_open() to      differentiate to its caller what the state of the target is after      the initial open has been performed.  Here we're assuming that      the target has stopped.  It should be possible to eventually have      target_open() return to the caller an indication that the target      is currently running and GDB state should be set to the same as      for an async run. */
name|wait_for_inferior
argument_list|()
expr_stmt|;
name|normal_stop
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize static vars when a new inferior begins.  */
end_comment

begin_function
name|void
name|init_wait_for_inferior
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* These are meaningless until the first time through wait_for_inferior.  */
name|prev_pc
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|HP_OS_BUG
name|trap_expected_after_continue
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|breakpoints_inserted
operator|=
literal|0
expr_stmt|;
name|breakpoint_init_inferior
argument_list|(
name|inf_starting
argument_list|)
expr_stmt|;
comment|/* Don't confuse first call to proceed(). */
name|stop_signal
operator|=
name|TARGET_SIGNAL_0
expr_stmt|;
comment|/* The first resume is not following a fork/vfork/exec. */
name|pending_follow
operator|.
name|kind
operator|=
name|TARGET_WAITKIND_SPURIOUS
expr_stmt|;
comment|/* I.e., none. */
comment|/* See wait_for_inferior's handling of SYSCALL_ENTRY/RETURN events. */
name|number_of_threads_in_syscalls
operator|=
literal|0
expr_stmt|;
name|clear_proceed_status
argument_list|()
expr_stmt|;
name|stepping_past_singlestep_breakpoint
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|delete_breakpoint_current_contents
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|breakpoint
modifier|*
modifier|*
name|breakpointp
init|=
operator|(
expr|struct
name|breakpoint
operator|*
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
operator|*
name|breakpointp
operator|!=
name|NULL
condition|)
block|{
name|delete_breakpoint
argument_list|(
operator|*
name|breakpointp
argument_list|)
expr_stmt|;
operator|*
name|breakpointp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This enum encodes possible reasons for doing a target_wait, so that    wfi can call target_wait in one place.  (Ultimately the call will be    moved out of the infinite loop entirely.) */
end_comment

begin_enum
enum|enum
name|infwait_states
block|{
name|infwait_normal_state
block|,
name|infwait_thread_hop_state
block|,
name|infwait_nullified_state
block|,
name|infwait_nonstep_watch_state
block|}
enum|;
end_enum

begin_comment
comment|/* Why did the inferior stop? Used to print the appropriate messages    to the interface from within handle_inferior_event(). */
end_comment

begin_enum
enum|enum
name|inferior_stop_reason
block|{
comment|/* We don't know why. */
name|STOP_UNKNOWN
block|,
comment|/* Step, next, nexti, stepi finished. */
name|END_STEPPING_RANGE
block|,
comment|/* Found breakpoint. */
name|BREAKPOINT_HIT
block|,
comment|/* Inferior terminated by signal. */
name|SIGNAL_EXITED
block|,
comment|/* Inferior exited. */
name|EXITED
block|,
comment|/* Inferior received signal, and user asked to be notified. */
name|SIGNAL_RECEIVED
block|}
enum|;
end_enum

begin_comment
comment|/* This structure contains what used to be local variables in    wait_for_inferior.  Probably many of them can return to being    locals in handle_inferior_event.  */
end_comment

begin_struct
struct|struct
name|execution_control_state
block|{
name|struct
name|target_waitstatus
name|ws
decl_stmt|;
name|struct
name|target_waitstatus
modifier|*
name|wp
decl_stmt|;
name|int
name|another_trap
decl_stmt|;
name|int
name|random_signal
decl_stmt|;
name|CORE_ADDR
name|stop_func_start
decl_stmt|;
name|CORE_ADDR
name|stop_func_end
decl_stmt|;
name|char
modifier|*
name|stop_func_name
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|int
name|remove_breakpoints_on_following_step
decl_stmt|;
name|int
name|current_line
decl_stmt|;
name|struct
name|symtab
modifier|*
name|current_symtab
decl_stmt|;
name|int
name|handling_longjmp
decl_stmt|;
comment|/* FIXME */
name|ptid_t
name|ptid
decl_stmt|;
name|ptid_t
name|saved_inferior_ptid
decl_stmt|;
name|int
name|update_step_sp
decl_stmt|;
name|int
name|stepping_through_solib_after_catch
decl_stmt|;
name|bpstat
name|stepping_through_solib_catchpoints
decl_stmt|;
name|int
name|enable_hw_watchpoints_after_wait
decl_stmt|;
name|int
name|stepping_through_sigtramp
decl_stmt|;
name|int
name|new_thread_event
decl_stmt|;
name|struct
name|target_waitstatus
name|tmpstatus
decl_stmt|;
name|enum
name|infwait_states
name|infwait_state
decl_stmt|;
name|ptid_t
name|waiton_ptid
decl_stmt|;
name|int
name|wait_some_more
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
name|void
name|init_execution_control_state
parameter_list|(
name|struct
name|execution_control_state
modifier|*
name|ecs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|handle_step_into_function
parameter_list|(
name|struct
name|execution_control_state
modifier|*
name|ecs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|handle_inferior_event
parameter_list|(
name|struct
name|execution_control_state
modifier|*
name|ecs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|check_sigtramp2
parameter_list|(
name|struct
name|execution_control_state
modifier|*
name|ecs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|step_into_function
parameter_list|(
name|struct
name|execution_control_state
modifier|*
name|ecs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|step_over_function
parameter_list|(
name|struct
name|execution_control_state
modifier|*
name|ecs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stop_stepping
parameter_list|(
name|struct
name|execution_control_state
modifier|*
name|ecs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prepare_to_wait
parameter_list|(
name|struct
name|execution_control_state
modifier|*
name|ecs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|keep_going
parameter_list|(
name|struct
name|execution_control_state
modifier|*
name|ecs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_stop_reason
parameter_list|(
name|enum
name|inferior_stop_reason
name|stop_reason
parameter_list|,
name|int
name|stop_info
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Wait for control to return from inferior to debugger.    If inferior gets a signal, we may decide to start it up again    instead of returning.  That is why there is a loop in this function.    When this function actually returns it means the inferior    should be left stopped and GDB should read more commands.  */
end_comment

begin_function
name|void
name|wait_for_inferior
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_cleanups
decl_stmt|;
name|struct
name|execution_control_state
name|ecss
decl_stmt|;
name|struct
name|execution_control_state
modifier|*
name|ecs
decl_stmt|;
name|old_cleanups
operator|=
name|make_cleanup
argument_list|(
name|delete_step_resume_breakpoint
argument_list|,
operator|&
name|step_resume_breakpoint
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|delete_breakpoint_current_contents
argument_list|,
operator|&
name|through_sigtramp_breakpoint
argument_list|)
expr_stmt|;
comment|/* wfi still stays in a loop, so it's OK just to take the address of      a local to get the ecs pointer.  */
name|ecs
operator|=
operator|&
name|ecss
expr_stmt|;
comment|/* Fill in with reasonable starting values.  */
name|init_execution_control_state
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
comment|/* We'll update this if& when we switch to a new thread. */
name|previous_inferior_ptid
operator|=
name|inferior_ptid
expr_stmt|;
name|overlay_cache_invalid
operator|=
literal|1
expr_stmt|;
comment|/* We have to invalidate the registers BEFORE calling target_wait      because they can be loaded from the target while in target_wait.      This makes remote debugging a bit more efficient for those      targets that provide critical registers as part of their normal      status mechanism. */
name|registers_changed
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|target_wait_hook
condition|)
name|ecs
operator|->
name|ptid
operator|=
name|target_wait_hook
argument_list|(
name|ecs
operator|->
name|waiton_ptid
argument_list|,
name|ecs
operator|->
name|wp
argument_list|)
expr_stmt|;
else|else
name|ecs
operator|->
name|ptid
operator|=
name|target_wait
argument_list|(
name|ecs
operator|->
name|waiton_ptid
argument_list|,
name|ecs
operator|->
name|wp
argument_list|)
expr_stmt|;
comment|/* Now figure out what to do with the result of the result.  */
name|handle_inferior_event
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ecs
operator|->
name|wait_some_more
condition|)
break|break;
block|}
name|do_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Asynchronous version of wait_for_inferior. It is called by the    event loop whenever a change of state is detected on the file    descriptor corresponding to the target. It can be called more than    once to complete a single execution command. In such cases we need    to keep the state in a global variable ASYNC_ECSS. If it is the    last time that this function is called for a single execution    command, then report to the user that the inferior has stopped, and    do the necessary cleanups. */
end_comment

begin_decl_stmt
name|struct
name|execution_control_state
name|async_ecss
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|execution_control_state
modifier|*
name|async_ecs
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|fetch_inferior_event
parameter_list|(
name|void
modifier|*
name|client_data
parameter_list|)
block|{
specifier|static
name|struct
name|cleanup
modifier|*
name|old_cleanups
decl_stmt|;
name|async_ecs
operator|=
operator|&
name|async_ecss
expr_stmt|;
if|if
condition|(
operator|!
name|async_ecs
operator|->
name|wait_some_more
condition|)
block|{
name|old_cleanups
operator|=
name|make_exec_cleanup
argument_list|(
name|delete_step_resume_breakpoint
argument_list|,
operator|&
name|step_resume_breakpoint
argument_list|)
expr_stmt|;
name|make_exec_cleanup
argument_list|(
name|delete_breakpoint_current_contents
argument_list|,
operator|&
name|through_sigtramp_breakpoint
argument_list|)
expr_stmt|;
comment|/* Fill in with reasonable starting values.  */
name|init_execution_control_state
argument_list|(
name|async_ecs
argument_list|)
expr_stmt|;
comment|/* We'll update this if& when we switch to a new thread. */
name|previous_inferior_ptid
operator|=
name|inferior_ptid
expr_stmt|;
name|overlay_cache_invalid
operator|=
literal|1
expr_stmt|;
comment|/* We have to invalidate the registers BEFORE calling target_wait          because they can be loaded from the target while in target_wait.          This makes remote debugging a bit more efficient for those          targets that provide critical registers as part of their normal          status mechanism. */
name|registers_changed
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|target_wait_hook
condition|)
name|async_ecs
operator|->
name|ptid
operator|=
name|target_wait_hook
argument_list|(
name|async_ecs
operator|->
name|waiton_ptid
argument_list|,
name|async_ecs
operator|->
name|wp
argument_list|)
expr_stmt|;
else|else
name|async_ecs
operator|->
name|ptid
operator|=
name|target_wait
argument_list|(
name|async_ecs
operator|->
name|waiton_ptid
argument_list|,
name|async_ecs
operator|->
name|wp
argument_list|)
expr_stmt|;
comment|/* Now figure out what to do with the result of the result.  */
name|handle_inferior_event
argument_list|(
name|async_ecs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|async_ecs
operator|->
name|wait_some_more
condition|)
block|{
comment|/* Do only the cleanups that have been added by this          function. Let the continuations for the commands do the rest,          if there are any. */
name|do_exec_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
name|normal_stop
argument_list|()
expr_stmt|;
if|if
condition|(
name|step_multi
operator|&&
name|stop_step
condition|)
name|inferior_event_handler
argument_list|(
name|INF_EXEC_CONTINUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|inferior_event_handler
argument_list|(
name|INF_EXEC_COMPLETE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Prepare an execution control state for looping through a    wait_for_inferior-type loop.  */
end_comment

begin_function
name|void
name|init_execution_control_state
parameter_list|(
name|struct
name|execution_control_state
modifier|*
name|ecs
parameter_list|)
block|{
comment|/* ecs->another_trap? */
name|ecs
operator|->
name|random_signal
operator|=
literal|0
expr_stmt|;
name|ecs
operator|->
name|remove_breakpoints_on_following_step
operator|=
literal|0
expr_stmt|;
name|ecs
operator|->
name|handling_longjmp
operator|=
literal|0
expr_stmt|;
comment|/* FIXME */
name|ecs
operator|->
name|update_step_sp
operator|=
literal|0
expr_stmt|;
name|ecs
operator|->
name|stepping_through_solib_after_catch
operator|=
literal|0
expr_stmt|;
name|ecs
operator|->
name|stepping_through_solib_catchpoints
operator|=
name|NULL
expr_stmt|;
name|ecs
operator|->
name|enable_hw_watchpoints_after_wait
operator|=
literal|0
expr_stmt|;
name|ecs
operator|->
name|stepping_through_sigtramp
operator|=
literal|0
expr_stmt|;
name|ecs
operator|->
name|sal
operator|=
name|find_pc_line
argument_list|(
name|prev_pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ecs
operator|->
name|current_line
operator|=
name|ecs
operator|->
name|sal
operator|.
name|line
expr_stmt|;
name|ecs
operator|->
name|current_symtab
operator|=
name|ecs
operator|->
name|sal
operator|.
name|symtab
expr_stmt|;
name|ecs
operator|->
name|infwait_state
operator|=
name|infwait_normal_state
expr_stmt|;
name|ecs
operator|->
name|waiton_ptid
operator|=
name|pid_to_ptid
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ecs
operator|->
name|wp
operator|=
operator|&
operator|(
name|ecs
operator|->
name|ws
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call this function before setting step_resume_breakpoint, as a    sanity check.  There should never be more than one step-resume    breakpoint per thread, so we should never be setting a new    step_resume_breakpoint when one is already active.  */
end_comment

begin_function
specifier|static
name|void
name|check_for_old_step_resume_breakpoint
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|step_resume_breakpoint
condition|)
name|warning
argument_list|(
literal|"GDB bug: infrun.c (wait_for_inferior): dropping old step_resume breakpoint"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the cached copy of the last pid/waitstatus returned by    target_wait()/target_wait_hook().  The data is actually cached by    handle_inferior_event(), which gets called immediately after    target_wait()/target_wait_hook().  */
end_comment

begin_function
name|void
name|get_last_target_status
parameter_list|(
name|ptid_t
modifier|*
name|ptidp
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
name|status
parameter_list|)
block|{
operator|*
name|ptidp
operator|=
name|target_last_wait_ptid
expr_stmt|;
operator|*
name|status
operator|=
name|target_last_waitstatus
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Switch thread contexts, maintaining "infrun state". */
end_comment

begin_function
specifier|static
name|void
name|context_switch
parameter_list|(
name|struct
name|execution_control_state
modifier|*
name|ecs
parameter_list|)
block|{
comment|/* Caution: it may happen that the new thread (or the old one!)      is not in the thread list.  In this case we must not attempt      to "switch context", or we run the risk that our context may      be lost.  This may happen as a result of the target module      mishandling thread creation.  */
if|if
condition|(
name|in_thread_list
argument_list|(
name|inferior_ptid
argument_list|)
operator|&&
name|in_thread_list
argument_list|(
name|ecs
operator|->
name|ptid
argument_list|)
condition|)
block|{
comment|/* Perform infrun state context switch: */
comment|/* Save infrun state for the old thread.  */
name|save_infrun_state
argument_list|(
name|inferior_ptid
argument_list|,
name|prev_pc
argument_list|,
name|trap_expected
argument_list|,
name|step_resume_breakpoint
argument_list|,
name|through_sigtramp_breakpoint
argument_list|,
name|step_range_start
argument_list|,
name|step_range_end
argument_list|,
operator|&
name|step_frame_id
argument_list|,
name|ecs
operator|->
name|handling_longjmp
argument_list|,
name|ecs
operator|->
name|another_trap
argument_list|,
name|ecs
operator|->
name|stepping_through_solib_after_catch
argument_list|,
name|ecs
operator|->
name|stepping_through_solib_catchpoints
argument_list|,
name|ecs
operator|->
name|stepping_through_sigtramp
argument_list|,
name|ecs
operator|->
name|current_line
argument_list|,
name|ecs
operator|->
name|current_symtab
argument_list|,
name|step_sp
argument_list|)
expr_stmt|;
comment|/* Load infrun state for the new thread.  */
name|load_infrun_state
argument_list|(
name|ecs
operator|->
name|ptid
argument_list|,
operator|&
name|prev_pc
argument_list|,
operator|&
name|trap_expected
argument_list|,
operator|&
name|step_resume_breakpoint
argument_list|,
operator|&
name|through_sigtramp_breakpoint
argument_list|,
operator|&
name|step_range_start
argument_list|,
operator|&
name|step_range_end
argument_list|,
operator|&
name|step_frame_id
argument_list|,
operator|&
name|ecs
operator|->
name|handling_longjmp
argument_list|,
operator|&
name|ecs
operator|->
name|another_trap
argument_list|,
operator|&
name|ecs
operator|->
name|stepping_through_solib_after_catch
argument_list|,
operator|&
name|ecs
operator|->
name|stepping_through_solib_catchpoints
argument_list|,
operator|&
name|ecs
operator|->
name|stepping_through_sigtramp
argument_list|,
operator|&
name|ecs
operator|->
name|current_line
argument_list|,
operator|&
name|ecs
operator|->
name|current_symtab
argument_list|,
operator|&
name|step_sp
argument_list|)
expr_stmt|;
block|}
name|inferior_ptid
operator|=
name|ecs
operator|->
name|ptid
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wrapper for PC_IN_SIGTRAMP that takes care of the need to find the    function's name.     In a classic example of "left hand VS right hand", "infrun.c" was    trying to improve GDB's performance by caching the result of calls    to calls to find_pc_partial_funtion, while at the same time    find_pc_partial_function was also trying to ramp up performance by    caching its most recent return value.  The below makes the the    function find_pc_partial_function solely responsibile for    performance issues (the local cache that relied on a global    variable - arrrggg - deleted).     Using the testsuite and gcov, it was found that dropping the local    "infrun.c" cache and instead relying on find_pc_partial_function    increased the number of calls to 12000 (from 10000), but the number    of times find_pc_partial_function's cache missed (this is what    matters) was only increased by only 4 (to 3569).  (A quick back of    envelope caculation suggests that the extra 2000 function calls    @1000 extra instructions per call make the 1 MIP VAX testsuite run    take two extra seconds, oops :-)     Long term, this function can be eliminated, replaced by the code:    get_frame_type(current_frame()) == SIGTRAMP_FRAME (for new    architectures this is very cheap).  */
end_comment

begin_function
specifier|static
name|int
name|pc_in_sigtramp
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
operator|&
name|name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|PC_IN_SIGTRAMP
argument_list|(
name|pc
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Handle the inferior event in the cases when we just stepped    into a function.  */
end_comment

begin_function
specifier|static
name|void
name|handle_step_into_function
parameter_list|(
name|struct
name|execution_control_state
modifier|*
name|ecs
parameter_list|)
block|{
name|CORE_ADDR
name|real_stop_pc
decl_stmt|;
if|if
condition|(
operator|(
name|step_over_calls
operator|==
name|STEP_OVER_NONE
operator|)
operator|||
operator|(
operator|(
name|step_range_end
operator|==
literal|1
operator|)
operator|&&
name|in_prologue
argument_list|(
name|prev_pc
argument_list|,
name|ecs
operator|->
name|stop_func_start
argument_list|)
operator|)
condition|)
block|{
comment|/* I presume that step_over_calls is only 0 when we're          supposed to be stepping at the assembly language level          ("stepi").  Just stop.  */
comment|/* Also, maybe we just did a "nexti" inside a prolog,          so we thought it was a subroutine call but it was not.          Stop as well.  FENN */
name|stop_step
operator|=
literal|1
expr_stmt|;
name|print_stop_reason
argument_list|(
name|END_STEPPING_RANGE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stop_stepping
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|step_over_calls
operator|==
name|STEP_OVER_ALL
operator|||
name|IGNORE_HELPER_CALL
argument_list|(
name|stop_pc
argument_list|)
condition|)
block|{
comment|/* We're doing a "next".  */
if|if
condition|(
name|pc_in_sigtramp
argument_list|(
name|stop_pc
argument_list|)
operator|&&
name|frame_id_inner
argument_list|(
name|step_frame_id
argument_list|,
name|frame_id_build
argument_list|(
name|read_sp
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
comment|/* We stepped out of a signal handler, and into its            calling trampoline.  This is misdetected as a            subroutine call, but stepping over the signal            trampoline isn't such a bad idea.  In order to do that,            we have to ignore the value in step_frame_id, since            that doesn't represent the frame that'll reach when we            return from the signal trampoline.  Otherwise we'll            probably continue to the end of the program.  */
name|step_frame_id
operator|=
name|null_frame_id
expr_stmt|;
name|step_over_function
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
name|keep_going
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we are in a function call trampoline (a stub between      the calling routine and the real function), locate the real      function.  That's what tells us (a) whether we want to step      into it at all, and (b) what prologue we want to run to      the end of, if we do step into it.  */
name|real_stop_pc
operator|=
name|skip_language_trampoline
argument_list|(
name|stop_pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_stop_pc
operator|==
literal|0
condition|)
name|real_stop_pc
operator|=
name|SKIP_TRAMPOLINE_CODE
argument_list|(
name|stop_pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_stop_pc
operator|!=
literal|0
condition|)
name|ecs
operator|->
name|stop_func_start
operator|=
name|real_stop_pc
expr_stmt|;
comment|/* If we have line number information for the function we      are thinking of stepping into, step into it.       If there are several symtabs at that PC (e.g. with include      files), just want to know whether *any* of them have line      numbers.  find_pc_line handles this.  */
block|{
name|struct
name|symtab_and_line
name|tmp_sal
decl_stmt|;
name|tmp_sal
operator|=
name|find_pc_line
argument_list|(
name|ecs
operator|->
name|stop_func_start
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_sal
operator|.
name|line
operator|!=
literal|0
condition|)
block|{
name|step_into_function
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* If we have no line number and the step-stop-if-no-debug      is set, we stop the step so that the user has a chance to      switch in assembly mode.  */
if|if
condition|(
name|step_over_calls
operator|==
name|STEP_OVER_UNDEBUGGABLE
operator|&&
name|step_stop_if_no_debug
condition|)
block|{
name|stop_step
operator|=
literal|1
expr_stmt|;
name|print_stop_reason
argument_list|(
name|END_STEPPING_RANGE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stop_stepping
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
block|}
name|step_over_function
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
name|keep_going
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|adjust_pc_after_break
parameter_list|(
name|struct
name|execution_control_state
modifier|*
name|ecs
parameter_list|)
block|{
name|CORE_ADDR
name|stop_pc
decl_stmt|;
comment|/* If this target does not decrement the PC after breakpoints, then      we have nothing to do.  */
if|if
condition|(
name|DECR_PC_AFTER_BREAK
operator|==
literal|0
condition|)
return|return;
comment|/* If we've hit a breakpoint, we'll normally be stopped with SIGTRAP.  If      we aren't, just return.       We assume that waitkinds other than TARGET_WAITKIND_STOPPED are not      affected by DECR_PC_AFTER_BREAK.  Other waitkinds which are implemented      by software breakpoints should be handled through the normal breakpoint      layer.            NOTE drow/2004-01-31: On some targets, breakpoints may generate      different signals (SIGILL or SIGEMT for instance), but it is less      clear where the PC is pointing afterwards.  It may not match      DECR_PC_AFTER_BREAK.  I don't know any specific target that generates      these signals at breakpoints (the code has been in GDB since at least      1992) so I can not guess how to handle them here.            In earlier versions of GDB, a target with HAVE_NONSTEPPABLE_WATCHPOINTS      would have the PC after hitting a watchpoint affected by      DECR_PC_AFTER_BREAK.  I haven't found any target with both of these set      in GDB history, and it seems unlikely to be correct, so      HAVE_NONSTEPPABLE_WATCHPOINTS is not checked here.  */
if|if
condition|(
name|ecs
operator|->
name|ws
operator|.
name|kind
operator|!=
name|TARGET_WAITKIND_STOPPED
condition|)
return|return;
if|if
condition|(
name|ecs
operator|->
name|ws
operator|.
name|value
operator|.
name|sig
operator|!=
name|TARGET_SIGNAL_TRAP
condition|)
return|return;
comment|/* Find the location where (if we've hit a breakpoint) the breakpoint would      be.  */
name|stop_pc
operator|=
name|read_pc_pid
argument_list|(
name|ecs
operator|->
name|ptid
argument_list|)
operator|-
name|DECR_PC_AFTER_BREAK
expr_stmt|;
comment|/* If we're software-single-stepping, then assume this is a breakpoint.      NOTE drow/2004-01-17: This doesn't check that the PC matches, or that      we're even in the right thread.  The software-single-step code needs      some modernization.       If we're not software-single-stepping, then we first check that there      is an enabled software breakpoint at this address.  If there is, and      we weren't using hardware-single-step, then we've hit the breakpoint.       If we were using hardware-single-step, we check prev_pc; if we just      stepped over an inserted software breakpoint, then we should decrement      the PC and eventually report hitting the breakpoint.  The prev_pc check      prevents us from decrementing the PC if we just stepped over a jump      instruction and landed on the instruction after a breakpoint.       The last bit checks that we didn't hit a breakpoint in a signal handler      without an intervening stop in sigtramp, which is detected by a new      stack pointer value below any usual function calling stack adjustments.       NOTE drow/2004-01-17: I'm not sure that this is necessary.  The check      predates checking for software single step at the same time.  Also,      if we've moved into a signal handler we should have seen the      signal.  */
if|if
condition|(
operator|(
name|SOFTWARE_SINGLE_STEP_P
argument_list|()
operator|&&
name|singlestep_breakpoints_inserted_p
operator|)
operator|||
operator|(
name|software_breakpoint_inserted_here_p
argument_list|(
name|stop_pc
argument_list|)
operator|&&
operator|!
operator|(
name|currently_stepping
argument_list|(
name|ecs
argument_list|)
operator|&&
name|prev_pc
operator|!=
name|stop_pc
operator|&&
operator|!
operator|(
name|step_range_end
operator|&&
name|INNER_THAN
argument_list|(
name|read_sp
argument_list|()
argument_list|,
operator|(
name|step_sp
operator|-
literal|16
operator|)
argument_list|)
operator|)
operator|)
operator|)
condition|)
name|write_pc_pid
argument_list|(
name|stop_pc
argument_list|,
name|ecs
operator|->
name|ptid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given an execution control state that has been freshly filled in    by an event from the inferior, figure out what it means and take    appropriate action.  */
end_comment

begin_function
name|void
name|handle_inferior_event
parameter_list|(
name|struct
name|execution_control_state
modifier|*
name|ecs
parameter_list|)
block|{
comment|/* NOTE: cagney/2003-03-28: If you're looking at this code and      thinking that the variable stepped_after_stopped_by_watchpoint      isn't used, then you're wrong!  The macro STOPPED_BY_WATCHPOINT,      defined in the file "config/pa/nm-hppah.h", accesses the variable      indirectly.  Mutter something rude about the HP merge.  */
name|int
name|stepped_after_stopped_by_watchpoint
decl_stmt|;
name|int
name|sw_single_step_trap_p
init|=
literal|0
decl_stmt|;
comment|/* Cache the last pid/waitstatus. */
name|target_last_wait_ptid
operator|=
name|ecs
operator|->
name|ptid
expr_stmt|;
name|target_last_waitstatus
operator|=
operator|*
name|ecs
operator|->
name|wp
expr_stmt|;
name|adjust_pc_after_break
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ecs
operator|->
name|infwait_state
condition|)
block|{
case|case
name|infwait_thread_hop_state
case|:
comment|/* Cancel the waiton_ptid. */
name|ecs
operator|->
name|waiton_ptid
operator|=
name|pid_to_ptid
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* See comments where a TARGET_WAITKIND_SYSCALL_RETURN event          is serviced in this loop, below. */
if|if
condition|(
name|ecs
operator|->
name|enable_hw_watchpoints_after_wait
condition|)
block|{
name|TARGET_ENABLE_HW_WATCHPOINTS
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
name|ecs
operator|->
name|enable_hw_watchpoints_after_wait
operator|=
literal|0
expr_stmt|;
block|}
name|stepped_after_stopped_by_watchpoint
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|infwait_normal_state
case|:
comment|/* See comments where a TARGET_WAITKIND_SYSCALL_RETURN event          is serviced in this loop, below. */
if|if
condition|(
name|ecs
operator|->
name|enable_hw_watchpoints_after_wait
condition|)
block|{
name|TARGET_ENABLE_HW_WATCHPOINTS
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
name|ecs
operator|->
name|enable_hw_watchpoints_after_wait
operator|=
literal|0
expr_stmt|;
block|}
name|stepped_after_stopped_by_watchpoint
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|infwait_nullified_state
case|:
name|stepped_after_stopped_by_watchpoint
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|infwait_nonstep_watch_state
case|:
name|insert_breakpoints
argument_list|()
expr_stmt|;
comment|/* FIXME-maybe: is this cleaner than setting a flag?  Does it          handle things like signals arriving and other things happening          in combination correctly?  */
name|stepped_after_stopped_by_watchpoint
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"bad switch"
argument_list|)
expr_stmt|;
block|}
name|ecs
operator|->
name|infwait_state
operator|=
name|infwait_normal_state
expr_stmt|;
name|flush_cached_frames
argument_list|()
expr_stmt|;
comment|/* If it's a new process, add it to the thread database */
name|ecs
operator|->
name|new_thread_event
operator|=
operator|(
operator|!
name|ptid_equal
argument_list|(
name|ecs
operator|->
name|ptid
argument_list|,
name|inferior_ptid
argument_list|)
operator|&&
operator|!
name|in_thread_list
argument_list|(
name|ecs
operator|->
name|ptid
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ecs
operator|->
name|ws
operator|.
name|kind
operator|!=
name|TARGET_WAITKIND_EXITED
operator|&&
name|ecs
operator|->
name|ws
operator|.
name|kind
operator|!=
name|TARGET_WAITKIND_SIGNALLED
operator|&&
name|ecs
operator|->
name|new_thread_event
condition|)
block|{
name|add_thread
argument_list|(
name|ecs
operator|->
name|ptid
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"[New "
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
name|target_pid_or_tid_to_str
argument_list|(
name|ecs
operator|->
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"]\n"
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* NOTE: This block is ONLY meant to be invoked in case of a          "thread creation event"!  If it is invoked for any other          sort of event (such as a new thread landing on a breakpoint),          the event will be discarded, which is almost certainly          a bad thing!           To avoid this, the low-level module (eg. target_wait)          should call in_thread_list and add_thread, so that the          new thread is known by the time we get here.  */
comment|/* We may want to consider not doing a resume here in order          to give the user a chance to play with the new thread.          It might be good to make that a user-settable option.  */
comment|/* At this point, all threads are stopped (happens          automatically in either the OS or the native code).          Therefore we need to continue all threads in order to          make progress.  */
block|target_resume (RESUME_ALL, 0, TARGET_SIGNAL_0);       prepare_to_wait (ecs);       return;
endif|#
directive|endif
block|}
switch|switch
condition|(
name|ecs
operator|->
name|ws
operator|.
name|kind
condition|)
block|{
case|case
name|TARGET_WAITKIND_LOADED
case|:
comment|/* Ignore gracefully during startup of the inferior, as it          might be the shell which has just loaded some objects,          otherwise add the symbols for the newly loaded objects.  */
ifdef|#
directive|ifdef
name|SOLIB_ADD
if|if
condition|(
name|stop_soon
operator|==
name|NO_STOP_QUIETLY
condition|)
block|{
comment|/* Remove breakpoints, SOLIB_ADD might adjust 	     breakpoint addresses via breakpoint_re_set.  */
if|if
condition|(
name|breakpoints_inserted
condition|)
name|remove_breakpoints
argument_list|()
expr_stmt|;
comment|/* Check for any newly added shared libraries if we're 	     supposed to be adding them automatically.  Switch 	     terminal for any messages produced by 	     breakpoint_re_set.  */
name|target_terminal_ours_for_output
argument_list|()
expr_stmt|;
comment|/* NOTE: cagney/2003-11-25: Make certain that the target              stack's section table is kept up-to-date.  Architectures,              (e.g., PPC64), use the section table to perform              operations such as address => section name and hence              require the table to contain all sections (including              those found in shared libraries).  */
comment|/* NOTE: cagney/2003-11-25: Pass current_target and not              exec_ops to SOLIB_ADD.  This is because current GDB is              only tooled to propagate section_table changes out from              the "current_target" (see target_resize_to_sections), and              not up from the exec stratum.  This, of course, isn't              right.  "infrun.c" should only interact with the              exec/process stratum, instead relying on the target stack              to propagate relevant changes (stop, section table              changed, ...) up to other layers.  */
name|SOLIB_ADD
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|current_target
argument_list|,
name|auto_solib_add
argument_list|)
expr_stmt|;
name|target_terminal_inferior
argument_list|()
expr_stmt|;
comment|/* Reinsert breakpoints and continue.  */
if|if
condition|(
name|breakpoints_inserted
condition|)
name|insert_breakpoints
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|resume
argument_list|(
literal|0
argument_list|,
name|TARGET_SIGNAL_0
argument_list|)
expr_stmt|;
name|prepare_to_wait
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
case|case
name|TARGET_WAITKIND_SPURIOUS
case|:
name|resume
argument_list|(
literal|0
argument_list|,
name|TARGET_SIGNAL_0
argument_list|)
expr_stmt|;
name|prepare_to_wait
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
case|case
name|TARGET_WAITKIND_EXITED
case|:
name|target_terminal_ours
argument_list|()
expr_stmt|;
comment|/* Must do this before mourn anyway */
name|print_stop_reason
argument_list|(
name|EXITED
argument_list|,
name|ecs
operator|->
name|ws
operator|.
name|value
operator|.
name|integer
argument_list|)
expr_stmt|;
comment|/* Record the exit code in the convenience variable $_exitcode, so          that the user can inspect this again later.  */
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"_exitcode"
argument_list|)
argument_list|,
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|ecs
operator|->
name|ws
operator|.
name|value
operator|.
name|integer
argument_list|)
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|target_mourn_inferior
argument_list|()
expr_stmt|;
name|singlestep_breakpoints_inserted_p
operator|=
literal|0
expr_stmt|;
comment|/*SOFTWARE_SINGLE_STEP_P() */
name|stop_print_frame
operator|=
literal|0
expr_stmt|;
name|stop_stepping
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
case|case
name|TARGET_WAITKIND_SIGNALLED
case|:
name|stop_print_frame
operator|=
literal|0
expr_stmt|;
name|stop_signal
operator|=
name|ecs
operator|->
name|ws
operator|.
name|value
operator|.
name|sig
expr_stmt|;
name|target_terminal_ours
argument_list|()
expr_stmt|;
comment|/* Must do this before mourn anyway */
comment|/* Note: By definition of TARGET_WAITKIND_SIGNALLED, we shouldn't          reach here unless the inferior is dead.  However, for years          target_kill() was called here, which hints that fatal signals aren't          really fatal on some systems.  If that's true, then some changes          may be needed. */
name|target_mourn_inferior
argument_list|()
expr_stmt|;
name|print_stop_reason
argument_list|(
name|SIGNAL_EXITED
argument_list|,
name|stop_signal
argument_list|)
expr_stmt|;
name|singlestep_breakpoints_inserted_p
operator|=
literal|0
expr_stmt|;
comment|/*SOFTWARE_SINGLE_STEP_P() */
name|stop_stepping
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
comment|/* The following are the only cases in which we keep going;          the above cases end in a continue or goto. */
case|case
name|TARGET_WAITKIND_FORKED
case|:
case|case
name|TARGET_WAITKIND_VFORKED
case|:
name|stop_signal
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
name|pending_follow
operator|.
name|kind
operator|=
name|ecs
operator|->
name|ws
operator|.
name|kind
expr_stmt|;
name|pending_follow
operator|.
name|fork_event
operator|.
name|parent_pid
operator|=
name|PIDGET
argument_list|(
name|ecs
operator|->
name|ptid
argument_list|)
expr_stmt|;
name|pending_follow
operator|.
name|fork_event
operator|.
name|child_pid
operator|=
name|ecs
operator|->
name|ws
operator|.
name|value
operator|.
name|related_pid
expr_stmt|;
name|stop_pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
name|stop_bpstat
operator|=
name|bpstat_stop_status
argument_list|(
name|stop_pc
argument_list|,
name|ecs
operator|->
name|ptid
argument_list|)
expr_stmt|;
name|ecs
operator|->
name|random_signal
operator|=
operator|!
name|bpstat_explains_signal
argument_list|(
name|stop_bpstat
argument_list|)
expr_stmt|;
comment|/* If no catchpoint triggered for this, then keep going.  */
if|if
condition|(
name|ecs
operator|->
name|random_signal
condition|)
block|{
name|stop_signal
operator|=
name|TARGET_SIGNAL_0
expr_stmt|;
name|keep_going
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
block|}
goto|goto
name|process_event_stop_test
goto|;
case|case
name|TARGET_WAITKIND_EXECD
case|:
name|stop_signal
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
comment|/* NOTE drow/2002-12-05: This code should be pushed down into the 	 target_wait function.  Until then following vfork on HP/UX 10.20 	 is probably broken by this.  Of course, it's broken anyway.  */
comment|/* Is this a target which reports multiple exec events per actual          call to exec()?  (HP-UX using ptrace does, for example.)  If so,          ignore all but the last one.  Just resume the exec'r, and wait          for the next exec event. */
if|if
condition|(
name|inferior_ignoring_leading_exec_events
condition|)
block|{
name|inferior_ignoring_leading_exec_events
operator|--
expr_stmt|;
if|if
condition|(
name|pending_follow
operator|.
name|kind
operator|==
name|TARGET_WAITKIND_VFORKED
condition|)
name|ENSURE_VFORKING_PARENT_REMAINS_STOPPED
argument_list|(
name|pending_follow
operator|.
name|fork_event
operator|.
name|parent_pid
argument_list|)
expr_stmt|;
name|target_resume
argument_list|(
name|ecs
operator|->
name|ptid
argument_list|,
literal|0
argument_list|,
name|TARGET_SIGNAL_0
argument_list|)
expr_stmt|;
name|prepare_to_wait
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
block|}
name|inferior_ignoring_leading_exec_events
operator|=
name|target_reported_exec_events_per_exec_call
argument_list|()
operator|-
literal|1
expr_stmt|;
name|pending_follow
operator|.
name|execd_pathname
operator|=
name|savestring
argument_list|(
name|ecs
operator|->
name|ws
operator|.
name|value
operator|.
name|execd_pathname
argument_list|,
name|strlen
argument_list|(
name|ecs
operator|->
name|ws
operator|.
name|value
operator|.
name|execd_pathname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This causes the eventpoints and symbol table to be reset.  Must          do this now, before trying to determine whether to stop. */
name|follow_exec
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|pending_follow
operator|.
name|execd_pathname
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|pending_follow
operator|.
name|execd_pathname
argument_list|)
expr_stmt|;
name|stop_pc
operator|=
name|read_pc_pid
argument_list|(
name|ecs
operator|->
name|ptid
argument_list|)
expr_stmt|;
name|ecs
operator|->
name|saved_inferior_ptid
operator|=
name|inferior_ptid
expr_stmt|;
name|inferior_ptid
operator|=
name|ecs
operator|->
name|ptid
expr_stmt|;
name|stop_bpstat
operator|=
name|bpstat_stop_status
argument_list|(
name|stop_pc
argument_list|,
name|ecs
operator|->
name|ptid
argument_list|)
expr_stmt|;
name|ecs
operator|->
name|random_signal
operator|=
operator|!
name|bpstat_explains_signal
argument_list|(
name|stop_bpstat
argument_list|)
expr_stmt|;
name|inferior_ptid
operator|=
name|ecs
operator|->
name|saved_inferior_ptid
expr_stmt|;
comment|/* If no catchpoint triggered for this, then keep going.  */
if|if
condition|(
name|ecs
operator|->
name|random_signal
condition|)
block|{
name|stop_signal
operator|=
name|TARGET_SIGNAL_0
expr_stmt|;
name|keep_going
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
block|}
goto|goto
name|process_event_stop_test
goto|;
comment|/* These syscall events are returned on HP-UX, as part of its          implementation of page-protection-based "hardware" watchpoints.          HP-UX has unfortunate interactions between page-protections and          some system calls.  Our solution is to disable hardware watches          when a system call is entered, and reenable them when the syscall          completes.  The downside of this is that we may miss the precise          point at which a watched piece of memory is modified.  "Oh well."           Note that we may have multiple threads running, which may each          enter syscalls at roughly the same time.  Since we don't have a          good notion currently of whether a watched piece of memory is          thread-private, we'd best not have any page-protections active          when any thread is in a syscall.  Thus, we only want to reenable          hardware watches when no threads are in a syscall.           Also, be careful not to try to gather much state about a thread          that's in a syscall.  It's frequently a losing proposition. */
case|case
name|TARGET_WAITKIND_SYSCALL_ENTRY
case|:
name|number_of_threads_in_syscalls
operator|++
expr_stmt|;
if|if
condition|(
name|number_of_threads_in_syscalls
operator|==
literal|1
condition|)
block|{
name|TARGET_DISABLE_HW_WATCHPOINTS
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|resume
argument_list|(
literal|0
argument_list|,
name|TARGET_SIGNAL_0
argument_list|)
expr_stmt|;
name|prepare_to_wait
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
comment|/* Before examining the threads further, step this thread to          get it entirely out of the syscall.  (We get notice of the          event when the thread is just on the verge of exiting a          syscall.  Stepping one instruction seems to get it back          into user code.)           Note that although the logical place to reenable h/w watches          is here, we cannot.  We cannot reenable them before stepping          the thread (this causes the next wait on the thread to hang).           Nor can we enable them after stepping until we've done a wait.          Thus, we simply set the flag ecs->enable_hw_watchpoints_after_wait          here, which will be serviced immediately after the target          is waited on. */
case|case
name|TARGET_WAITKIND_SYSCALL_RETURN
case|:
name|target_resume
argument_list|(
name|ecs
operator|->
name|ptid
argument_list|,
literal|1
argument_list|,
name|TARGET_SIGNAL_0
argument_list|)
expr_stmt|;
if|if
condition|(
name|number_of_threads_in_syscalls
operator|>
literal|0
condition|)
block|{
name|number_of_threads_in_syscalls
operator|--
expr_stmt|;
name|ecs
operator|->
name|enable_hw_watchpoints_after_wait
operator|=
operator|(
name|number_of_threads_in_syscalls
operator|==
literal|0
operator|)
expr_stmt|;
block|}
name|prepare_to_wait
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
case|case
name|TARGET_WAITKIND_STOPPED
case|:
name|stop_signal
operator|=
name|ecs
operator|->
name|ws
operator|.
name|value
operator|.
name|sig
expr_stmt|;
break|break;
comment|/* We had an event in the inferior, but we are not interested          in handling it at this level. The lower layers have already          done what needs to be done, if anything. 	  	 One of the possible circumstances for this is when the 	 inferior produces output for the console. The inferior has 	 not stopped, and we are ignoring the event.  Another possible 	 circumstance is any event which the lower level knows will be 	 reported multiple times without an intervening resume.  */
case|case
name|TARGET_WAITKIND_IGNORE
case|:
name|prepare_to_wait
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We may want to consider not doing a resume here in order to give      the user a chance to play with the new thread.  It might be good      to make that a user-settable option.  */
comment|/* At this point, all threads are stopped (happens automatically in      either the OS or the native code).  Therefore we need to continue      all threads in order to make progress.  */
if|if
condition|(
name|ecs
operator|->
name|new_thread_event
condition|)
block|{
name|target_resume
argument_list|(
name|RESUME_ALL
argument_list|,
literal|0
argument_list|,
name|TARGET_SIGNAL_0
argument_list|)
expr_stmt|;
name|prepare_to_wait
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
block|}
name|stop_pc
operator|=
name|read_pc_pid
argument_list|(
name|ecs
operator|->
name|ptid
argument_list|)
expr_stmt|;
if|if
condition|(
name|stepping_past_singlestep_breakpoint
condition|)
block|{
name|gdb_assert
argument_list|(
name|SOFTWARE_SINGLE_STEP_P
argument_list|()
operator|&&
name|singlestep_breakpoints_inserted_p
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|ptid_equal
argument_list|(
name|singlestep_ptid
argument_list|,
name|ecs
operator|->
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
operator|!
name|ptid_equal
argument_list|(
name|singlestep_ptid
argument_list|,
name|saved_singlestep_ptid
argument_list|)
argument_list|)
expr_stmt|;
name|stepping_past_singlestep_breakpoint
operator|=
literal|0
expr_stmt|;
comment|/* We've either finished single-stepping past the single-step 	 breakpoint, or stopped for some other reason.  It would be nice if 	 we could tell, but we can't reliably.  */
if|if
condition|(
name|stop_signal
operator|==
name|TARGET_SIGNAL_TRAP
condition|)
block|{
comment|/* Pull the single step breakpoints out of the target.  */
name|SOFTWARE_SINGLE_STEP
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|singlestep_breakpoints_inserted_p
operator|=
literal|0
expr_stmt|;
name|ecs
operator|->
name|random_signal
operator|=
literal|0
expr_stmt|;
name|ecs
operator|->
name|ptid
operator|=
name|saved_singlestep_ptid
expr_stmt|;
name|context_switch
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
if|if
condition|(
name|context_hook
condition|)
name|context_hook
argument_list|(
name|pid_to_thread_id
argument_list|(
name|ecs
operator|->
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
name|resume
argument_list|(
literal|1
argument_list|,
name|TARGET_SIGNAL_0
argument_list|)
expr_stmt|;
name|prepare_to_wait
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|stepping_past_singlestep_breakpoint
operator|=
literal|0
expr_stmt|;
comment|/* See if a thread hit a thread-specific breakpoint that was meant for      another thread.  If so, then step that thread past the breakpoint,      and continue it.  */
if|if
condition|(
name|stop_signal
operator|==
name|TARGET_SIGNAL_TRAP
condition|)
block|{
name|int
name|thread_hop_needed
init|=
literal|0
decl_stmt|;
comment|/* Check if a regular breakpoint has been hit before checking          for a potential single step breakpoint. Otherwise, GDB will          not see this breakpoint hit when stepping onto breakpoints.  */
if|if
condition|(
name|breakpoints_inserted
operator|&&
name|breakpoint_here_p
argument_list|(
name|stop_pc
argument_list|)
condition|)
block|{
name|ecs
operator|->
name|random_signal
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|breakpoint_thread_match
argument_list|(
name|stop_pc
argument_list|,
name|ecs
operator|->
name|ptid
argument_list|)
condition|)
name|thread_hop_needed
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SOFTWARE_SINGLE_STEP_P
argument_list|()
operator|&&
name|singlestep_breakpoints_inserted_p
condition|)
block|{
name|ecs
operator|->
name|random_signal
operator|=
literal|0
expr_stmt|;
comment|/* The call to in_thread_list is necessary because PTIDs sometimes 	     change when we go from single-threaded to multi-threaded.  If 	     the singlestep_ptid is still in the list, assume that it is 	     really different from ecs->ptid.  */
if|if
condition|(
operator|!
name|ptid_equal
argument_list|(
name|singlestep_ptid
argument_list|,
name|ecs
operator|->
name|ptid
argument_list|)
operator|&&
name|in_thread_list
argument_list|(
name|singlestep_ptid
argument_list|)
condition|)
block|{
name|thread_hop_needed
operator|=
literal|1
expr_stmt|;
name|stepping_past_singlestep_breakpoint
operator|=
literal|1
expr_stmt|;
name|saved_singlestep_ptid
operator|=
name|singlestep_ptid
expr_stmt|;
block|}
block|}
if|if
condition|(
name|thread_hop_needed
condition|)
block|{
name|int
name|remove_status
decl_stmt|;
comment|/* Saw a breakpoint, but it was hit by the wrong thread. 	         Just continue. */
if|if
condition|(
name|SOFTWARE_SINGLE_STEP_P
argument_list|()
operator|&&
name|singlestep_breakpoints_inserted_p
condition|)
block|{
comment|/* Pull the single step breakpoints out of the target. */
name|SOFTWARE_SINGLE_STEP
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|singlestep_breakpoints_inserted_p
operator|=
literal|0
expr_stmt|;
block|}
name|remove_status
operator|=
name|remove_breakpoints
argument_list|()
expr_stmt|;
comment|/* Did we fail to remove breakpoints?  If so, try 	         to set the PC past the bp.  (There's at least 	         one situation in which we can fail to remove 	         the bp's: On HP-UX's that use ttrace, we can't 	         change the address space of a vforking child 	         process until the child exits (well, okay, not 	         then either :-) or execs. */
if|if
condition|(
name|remove_status
operator|!=
literal|0
condition|)
block|{
comment|/* FIXME!  This is obviously non-portable! */
name|write_pc_pid
argument_list|(
name|stop_pc
operator|+
literal|4
argument_list|,
name|ecs
operator|->
name|ptid
argument_list|)
expr_stmt|;
comment|/* We need to restart all the threads now, 		   * unles we're running in scheduler-locked mode.  		   * Use currently_stepping to determine whether to  		   * step or continue. 		   */
comment|/* FIXME MVS: is there any reason not to call resume()? */
if|if
condition|(
name|scheduler_mode
operator|==
name|schedlock_on
condition|)
name|target_resume
argument_list|(
name|ecs
operator|->
name|ptid
argument_list|,
name|currently_stepping
argument_list|(
name|ecs
argument_list|)
argument_list|,
name|TARGET_SIGNAL_0
argument_list|)
expr_stmt|;
else|else
name|target_resume
argument_list|(
name|RESUME_ALL
argument_list|,
name|currently_stepping
argument_list|(
name|ecs
argument_list|)
argument_list|,
name|TARGET_SIGNAL_0
argument_list|)
expr_stmt|;
name|prepare_to_wait
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* Single step */
name|breakpoints_inserted
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|ptid_equal
argument_list|(
name|inferior_ptid
argument_list|,
name|ecs
operator|->
name|ptid
argument_list|)
condition|)
name|context_switch
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
name|ecs
operator|->
name|waiton_ptid
operator|=
name|ecs
operator|->
name|ptid
expr_stmt|;
name|ecs
operator|->
name|wp
operator|=
operator|&
operator|(
name|ecs
operator|->
name|ws
operator|)
expr_stmt|;
name|ecs
operator|->
name|another_trap
operator|=
literal|1
expr_stmt|;
name|ecs
operator|->
name|infwait_state
operator|=
name|infwait_thread_hop_state
expr_stmt|;
name|keep_going
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
name|registers_changed
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|SOFTWARE_SINGLE_STEP_P
argument_list|()
operator|&&
name|singlestep_breakpoints_inserted_p
condition|)
block|{
name|sw_single_step_trap_p
operator|=
literal|1
expr_stmt|;
name|ecs
operator|->
name|random_signal
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|ecs
operator|->
name|random_signal
operator|=
literal|1
expr_stmt|;
comment|/* See if something interesting happened to the non-current thread.  If      so, then switch to that thread, and eventually give control back to      the user.       Note that if there's any kind of pending follow (i.e., of a fork,      vfork or exec), we don't want to do this now.  Rather, we'll let      the next resume handle it. */
if|if
condition|(
operator|!
name|ptid_equal
argument_list|(
name|ecs
operator|->
name|ptid
argument_list|,
name|inferior_ptid
argument_list|)
operator|&&
operator|(
name|pending_follow
operator|.
name|kind
operator|==
name|TARGET_WAITKIND_SPURIOUS
operator|)
condition|)
block|{
name|int
name|printed
init|=
literal|0
decl_stmt|;
comment|/* If it's a random signal for a non-current thread, notify user          if he's expressed an interest. */
if|if
condition|(
name|ecs
operator|->
name|random_signal
operator|&&
name|signal_print
index|[
name|stop_signal
index|]
condition|)
block|{
comment|/* ??rehrauer: I don't understand the rationale for this code.  If the    inferior will stop as a result of this signal, then the act of handling    the stop ought to print a message that's couches the stoppage in user    terms, e.g., "Stopped for breakpoint/watchpoint".  If the inferior    won't stop as a result of the signal -- i.e., if the signal is merely    a side-effect of something GDB's doing "under the covers" for the    user, such as stepping threads over a breakpoint they shouldn't stop    for -- then the message seems to be a serious annoyance at best.     For now, remove the message altogether. */
if|#
directive|if
literal|0
block|printed = 1; 	  target_terminal_ours_for_output (); 	  printf_filtered ("\nProgram received signal %s, %s.\n", 			   target_signal_to_name (stop_signal), 			   target_signal_to_string (stop_signal)); 	  gdb_flush (gdb_stdout);
endif|#
directive|endif
block|}
comment|/* If it's not SIGTRAP and not a signal we want to stop for, then          continue the thread. */
if|if
condition|(
name|stop_signal
operator|!=
name|TARGET_SIGNAL_TRAP
operator|&&
operator|!
name|signal_stop
index|[
name|stop_signal
index|]
condition|)
block|{
if|if
condition|(
name|printed
condition|)
name|target_terminal_inferior
argument_list|()
expr_stmt|;
comment|/* Clear the signal if it should not be passed.  */
if|if
condition|(
name|signal_program
index|[
name|stop_signal
index|]
operator|==
literal|0
condition|)
name|stop_signal
operator|=
name|TARGET_SIGNAL_0
expr_stmt|;
name|target_resume
argument_list|(
name|ecs
operator|->
name|ptid
argument_list|,
literal|0
argument_list|,
name|stop_signal
argument_list|)
expr_stmt|;
name|prepare_to_wait
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* It's a SIGTRAP or a signal we're interested in.  Switch threads,          and fall into the rest of wait_for_inferior().  */
name|context_switch
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
if|if
condition|(
name|context_hook
condition|)
name|context_hook
argument_list|(
name|pid_to_thread_id
argument_list|(
name|ecs
operator|->
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
name|flush_cached_frames
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|SOFTWARE_SINGLE_STEP_P
argument_list|()
operator|&&
name|singlestep_breakpoints_inserted_p
condition|)
block|{
comment|/* Pull the single step breakpoints out of the target. */
name|SOFTWARE_SINGLE_STEP
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|singlestep_breakpoints_inserted_p
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If PC is pointing at a nullified instruction, then step beyond      it so that the user won't be confused when GDB appears to be ready      to execute it. */
comment|/*      if (INSTRUCTION_NULLIFIED&& currently_stepping (ecs)) */
if|if
condition|(
name|INSTRUCTION_NULLIFIED
condition|)
block|{
name|registers_changed
argument_list|()
expr_stmt|;
name|target_resume
argument_list|(
name|ecs
operator|->
name|ptid
argument_list|,
literal|1
argument_list|,
name|TARGET_SIGNAL_0
argument_list|)
expr_stmt|;
comment|/* We may have received a signal that we want to pass to          the inferior; therefore, we must not clobber the waitstatus          in WS. */
name|ecs
operator|->
name|infwait_state
operator|=
name|infwait_nullified_state
expr_stmt|;
name|ecs
operator|->
name|waiton_ptid
operator|=
name|ecs
operator|->
name|ptid
expr_stmt|;
name|ecs
operator|->
name|wp
operator|=
operator|&
operator|(
name|ecs
operator|->
name|tmpstatus
operator|)
expr_stmt|;
name|prepare_to_wait
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* It may not be necessary to disable the watchpoint to stop over      it.  For example, the PA can (with some kernel cooperation)      single step over a watchpoint without disabling the watchpoint.  */
if|if
condition|(
name|HAVE_STEPPABLE_WATCHPOINT
operator|&&
name|STOPPED_BY_WATCHPOINT
argument_list|(
name|ecs
operator|->
name|ws
argument_list|)
condition|)
block|{
name|resume
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|prepare_to_wait
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* It is far more common to need to disable a watchpoint to step      the inferior over it.  FIXME.  What else might a debug      register or page protection watchpoint scheme need here?  */
if|if
condition|(
name|HAVE_NONSTEPPABLE_WATCHPOINT
operator|&&
name|STOPPED_BY_WATCHPOINT
argument_list|(
name|ecs
operator|->
name|ws
argument_list|)
condition|)
block|{
comment|/* At this point, we are stopped at an instruction which has          attempted to write to a piece of memory under control of          a watchpoint.  The instruction hasn't actually executed          yet.  If we were to evaluate the watchpoint expression          now, we would get the old value, and therefore no change          would seem to have occurred.           In order to make watchpoints work `right', we really need          to complete the memory write, and then evaluate the          watchpoint expression.  The following code does that by          removing the watchpoint (actually, all watchpoints and          breakpoints), single-stepping the target, re-inserting          watchpoints, and then falling through to let normal          single-step processing handle proceed.  Since this          includes evaluating watchpoints, things will come to a          stop in the correct manner.  */
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|registers_changed
argument_list|()
expr_stmt|;
name|target_resume
argument_list|(
name|ecs
operator|->
name|ptid
argument_list|,
literal|1
argument_list|,
name|TARGET_SIGNAL_0
argument_list|)
expr_stmt|;
comment|/* Single step */
name|ecs
operator|->
name|waiton_ptid
operator|=
name|ecs
operator|->
name|ptid
expr_stmt|;
name|ecs
operator|->
name|wp
operator|=
operator|&
operator|(
name|ecs
operator|->
name|ws
operator|)
expr_stmt|;
name|ecs
operator|->
name|infwait_state
operator|=
name|infwait_nonstep_watch_state
expr_stmt|;
name|prepare_to_wait
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* It may be possible to simply continue after a watchpoint.  */
if|if
condition|(
name|HAVE_CONTINUABLE_WATCHPOINT
condition|)
name|STOPPED_BY_WATCHPOINT
argument_list|(
name|ecs
operator|->
name|ws
argument_list|)
expr_stmt|;
name|ecs
operator|->
name|stop_func_start
operator|=
literal|0
expr_stmt|;
name|ecs
operator|->
name|stop_func_end
operator|=
literal|0
expr_stmt|;
name|ecs
operator|->
name|stop_func_name
operator|=
literal|0
expr_stmt|;
comment|/* Don't care about return value; stop_func_start and stop_func_name      will both be 0 if it doesn't work.  */
name|find_pc_partial_function
argument_list|(
name|stop_pc
argument_list|,
operator|&
name|ecs
operator|->
name|stop_func_name
argument_list|,
operator|&
name|ecs
operator|->
name|stop_func_start
argument_list|,
operator|&
name|ecs
operator|->
name|stop_func_end
argument_list|)
expr_stmt|;
name|ecs
operator|->
name|stop_func_start
operator|+=
name|FUNCTION_START_OFFSET
expr_stmt|;
name|ecs
operator|->
name|another_trap
operator|=
literal|0
expr_stmt|;
name|bpstat_clear
argument_list|(
operator|&
name|stop_bpstat
argument_list|)
expr_stmt|;
name|stop_step
operator|=
literal|0
expr_stmt|;
name|stop_stack_dummy
operator|=
literal|0
expr_stmt|;
name|stop_print_frame
operator|=
literal|1
expr_stmt|;
name|ecs
operator|->
name|random_signal
operator|=
literal|0
expr_stmt|;
name|stopped_by_random_signal
operator|=
literal|0
expr_stmt|;
name|breakpoints_failed
operator|=
literal|0
expr_stmt|;
comment|/* Look at the cause of the stop, and decide what to do.      The alternatives are:      1) break; to really stop and return to the debugger,      2) drop through to start up again      (set ecs->another_trap to 1 to single step once)      3) set ecs->random_signal to 1, and the decision between 1 and 2      will be made according to the signal handling tables.  */
comment|/* First, distinguish signals caused by the debugger from signals      that have to do with the program's own actions.  Note that      breakpoint insns may cause SIGTRAP or SIGILL or SIGEMT, depending      on the operating system version.  Here we detect when a SIGILL or      SIGEMT is really a breakpoint and change it to SIGTRAP.  We do      something similar for SIGSEGV, since a SIGSEGV will be generated      when we're trying to execute a breakpoint instruction on a      non-executable stack.  This happens for call dummy breakpoints      for architectures like SPARC that place call dummies on the      stack.  */
if|if
condition|(
name|stop_signal
operator|==
name|TARGET_SIGNAL_TRAP
operator|||
operator|(
name|breakpoints_inserted
operator|&&
operator|(
name|stop_signal
operator|==
name|TARGET_SIGNAL_ILL
operator|||
name|stop_signal
operator|==
name|TARGET_SIGNAL_SEGV
operator|||
name|stop_signal
operator|==
name|TARGET_SIGNAL_EMT
operator|)
operator|)
operator|||
name|stop_soon
operator|==
name|STOP_QUIETLY
operator|||
name|stop_soon
operator|==
name|STOP_QUIETLY_NO_SIGSTOP
condition|)
block|{
if|if
condition|(
name|stop_signal
operator|==
name|TARGET_SIGNAL_TRAP
operator|&&
name|stop_after_trap
condition|)
block|{
name|stop_print_frame
operator|=
literal|0
expr_stmt|;
name|stop_stepping
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* This is originated from start_remote(), start_inferior() and          shared libraries hook functions.  */
if|if
condition|(
name|stop_soon
operator|==
name|STOP_QUIETLY
condition|)
block|{
name|stop_stepping
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* This originates from attach_command().  We need to overwrite          the stop_signal here, because some kernels don't ignore a          SIGSTOP in a subsequent ptrace(PTRACE_SONT,SOGSTOP) call.          See more comments in inferior.h.  */
if|if
condition|(
name|stop_soon
operator|==
name|STOP_QUIETLY_NO_SIGSTOP
condition|)
block|{
name|stop_stepping
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
if|if
condition|(
name|stop_signal
operator|==
name|TARGET_SIGNAL_STOP
condition|)
name|stop_signal
operator|=
name|TARGET_SIGNAL_0
expr_stmt|;
return|return;
block|}
comment|/* Don't even think about breakpoints          if just proceeded over a breakpoint.           However, if we are trying to proceed over a breakpoint          and end up in sigtramp, then through_sigtramp_breakpoint          will be set and we should check whether we've hit the          step breakpoint.  */
if|if
condition|(
name|stop_signal
operator|==
name|TARGET_SIGNAL_TRAP
operator|&&
name|trap_expected
operator|&&
name|through_sigtramp_breakpoint
operator|==
name|NULL
condition|)
name|bpstat_clear
argument_list|(
operator|&
name|stop_bpstat
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* See if there is a breakpoint at the current PC.  */
name|stop_bpstat
operator|=
name|bpstat_stop_status
argument_list|(
name|stop_pc
argument_list|,
name|ecs
operator|->
name|ptid
argument_list|)
expr_stmt|;
comment|/* Following in case break condition called a 	     function.  */
name|stop_print_frame
operator|=
literal|1
expr_stmt|;
block|}
comment|/* NOTE: cagney/2003-03-29: These two checks for a random signal 	 at one stage in the past included checks for an inferior 	 function call's call dummy's return breakpoint.  The original 	 comment, that went with the test, read:  	 ``End of a stack dummy.  Some systems (e.g. Sony news) give 	 another signal besides SIGTRAP, so check here as well as 	 above.''           If someone ever tries to get get call dummys on a          non-executable stack to work (where the target would stop          with something like a SIGSEGV), then those tests might need          to be re-instated.  Given, however, that the tests were only          enabled when momentary breakpoints were not being used, I          suspect that it won't be the case.  	 NOTE: kettenis/2004-02-05: Indeed such checks don't seem to 	 be necessary for call dummies on a non-executable stack on 	 SPARC.  */
if|if
condition|(
name|stop_signal
operator|==
name|TARGET_SIGNAL_TRAP
condition|)
name|ecs
operator|->
name|random_signal
operator|=
operator|!
operator|(
name|bpstat_explains_signal
argument_list|(
name|stop_bpstat
argument_list|)
operator|||
name|trap_expected
operator|||
operator|(
name|step_range_end
operator|&&
name|step_resume_breakpoint
operator|==
name|NULL
operator|)
operator|)
expr_stmt|;
else|else
block|{
name|ecs
operator|->
name|random_signal
operator|=
operator|!
name|bpstat_explains_signal
argument_list|(
name|stop_bpstat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ecs
operator|->
name|random_signal
condition|)
name|stop_signal
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
block|}
block|}
comment|/* When we reach this point, we've pretty much decided      that the reason for stopping must've been a random      (unexpected) signal. */
else|else
name|ecs
operator|->
name|random_signal
operator|=
literal|1
expr_stmt|;
name|process_event_stop_test
label|:
comment|/* For the program's own signals, act according to      the signal handling tables.  */
if|if
condition|(
name|ecs
operator|->
name|random_signal
condition|)
block|{
comment|/* Signal not for debugging purposes.  */
name|int
name|printed
init|=
literal|0
decl_stmt|;
name|stopped_by_random_signal
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|signal_print
index|[
name|stop_signal
index|]
condition|)
block|{
name|printed
operator|=
literal|1
expr_stmt|;
name|target_terminal_ours_for_output
argument_list|()
expr_stmt|;
name|print_stop_reason
argument_list|(
name|SIGNAL_RECEIVED
argument_list|,
name|stop_signal
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|signal_stop
index|[
name|stop_signal
index|]
condition|)
block|{
name|stop_stepping
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If not going to stop, give terminal back          if we took it away.  */
elseif|else
if|if
condition|(
name|printed
condition|)
name|target_terminal_inferior
argument_list|()
expr_stmt|;
comment|/* Clear the signal if it should not be passed.  */
if|if
condition|(
name|signal_program
index|[
name|stop_signal
index|]
operator|==
literal|0
condition|)
name|stop_signal
operator|=
name|TARGET_SIGNAL_0
expr_stmt|;
comment|/* I'm not sure whether this needs to be check_sigtramp2 or          whether it could/should be keep_going.           This used to jump to step_over_function if we are stepping,          which is wrong.           Suppose the user does a `next' over a function call, and while          that call is in progress, the inferior receives a signal for          which GDB does not stop (i.e., signal_stop[SIG] is false).  In          that case, when we reach this point, there is already a          step-resume breakpoint established, right where it should be:          immediately after the function call the user is "next"-ing          over.  If we call step_over_function now, two bad things          happen:           - we'll create a new breakpoint, at wherever the current          frame's return address happens to be.  That could be          anywhere, depending on what function call happens to be on          the top of the stack at that point.  Point is, it's probably          not where we need it.           - the existing step-resume breakpoint (which is at the correct          address) will get orphaned: step_resume_breakpoint will point          to the new breakpoint, and the old step-resume breakpoint          will never be cleaned up.           The old behavior was meant to help HP-UX single-step out of          sigtramps.  It would place the new breakpoint at prev_pc, which          was certainly wrong.  I don't know the details there, so fixing          this probably breaks that.  As with anything else, it's up to          the HP-UX maintainer to furnish a fix that doesn't break other          platforms.  --JimB, 20 May 1999 */
name|check_sigtramp2
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
name|keep_going
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Handle cases caused by hitting a breakpoint.  */
block|{
name|CORE_ADDR
name|jmp_buf_pc
decl_stmt|;
name|struct
name|bpstat_what
name|what
decl_stmt|;
name|what
operator|=
name|bpstat_what
argument_list|(
name|stop_bpstat
argument_list|)
expr_stmt|;
if|if
condition|(
name|what
operator|.
name|call_dummy
condition|)
block|{
name|stop_stack_dummy
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|HP_OS_BUG
name|trap_expected_after_continue
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
switch|switch
condition|(
name|what
operator|.
name|main_action
condition|)
block|{
case|case
name|BPSTAT_WHAT_SET_LONGJMP_RESUME
case|:
comment|/* If we hit the breakpoint at longjmp, disable it for the 	   duration of this command.  Then, install a temporary 	   breakpoint at the target of the jmp_buf. */
name|disable_longjmp_breakpoint
argument_list|()
expr_stmt|;
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|breakpoints_inserted
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|GET_LONGJMP_TARGET_P
argument_list|()
operator|||
operator|!
name|GET_LONGJMP_TARGET
argument_list|(
operator|&
name|jmp_buf_pc
argument_list|)
condition|)
block|{
name|keep_going
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Need to blow away step-resume breakpoint, as it 	   interferes with us */
if|if
condition|(
name|step_resume_breakpoint
operator|!=
name|NULL
condition|)
block|{
name|delete_step_resume_breakpoint
argument_list|(
operator|&
name|step_resume_breakpoint
argument_list|)
expr_stmt|;
block|}
comment|/* Not sure whether we need to blow this away too, but probably 	   it is like the step-resume breakpoint.  */
if|if
condition|(
name|through_sigtramp_breakpoint
operator|!=
name|NULL
condition|)
block|{
name|delete_breakpoint
argument_list|(
name|through_sigtramp_breakpoint
argument_list|)
expr_stmt|;
name|through_sigtramp_breakpoint
operator|=
name|NULL
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* FIXME - Need to implement nested temporary breakpoints */
block|if (step_over_calls> 0) 	  set_longjmp_resume_breakpoint (jmp_buf_pc, get_current_frame ()); 	else
endif|#
directive|endif
comment|/* 0 */
name|set_longjmp_resume_breakpoint
argument_list|(
name|jmp_buf_pc
argument_list|,
name|null_frame_id
argument_list|)
expr_stmt|;
name|ecs
operator|->
name|handling_longjmp
operator|=
literal|1
expr_stmt|;
comment|/* FIXME */
name|keep_going
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
case|case
name|BPSTAT_WHAT_CLEAR_LONGJMP_RESUME
case|:
case|case
name|BPSTAT_WHAT_CLEAR_LONGJMP_RESUME_SINGLE
case|:
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|breakpoints_inserted
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|/* FIXME - Need to implement nested temporary breakpoints */
block|if (step_over_calls&& (frame_id_inner (get_frame_id (get_current_frame ()), 				step_frame_id))) 	  { 	    ecs->another_trap = 1; 	    keep_going (ecs); 	    return; 	  }
endif|#
directive|endif
comment|/* 0 */
name|disable_longjmp_breakpoint
argument_list|()
expr_stmt|;
name|ecs
operator|->
name|handling_longjmp
operator|=
literal|0
expr_stmt|;
comment|/* FIXME */
if|if
condition|(
name|what
operator|.
name|main_action
operator|==
name|BPSTAT_WHAT_CLEAR_LONGJMP_RESUME
condition|)
break|break;
comment|/* else fallthrough */
case|case
name|BPSTAT_WHAT_SINGLE
case|:
if|if
condition|(
name|breakpoints_inserted
condition|)
block|{
name|remove_breakpoints
argument_list|()
expr_stmt|;
block|}
name|breakpoints_inserted
operator|=
literal|0
expr_stmt|;
name|ecs
operator|->
name|another_trap
operator|=
literal|1
expr_stmt|;
comment|/* Still need to check other stuff, at least the case 	   where we are stepping and step out of the right range.  */
break|break;
case|case
name|BPSTAT_WHAT_STOP_NOISY
case|:
name|stop_print_frame
operator|=
literal|1
expr_stmt|;
comment|/* We are about to nuke the step_resume_breakpoint and 	   through_sigtramp_breakpoint via the cleanup chain, so 	   no need to worry about it here.  */
name|stop_stepping
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
case|case
name|BPSTAT_WHAT_STOP_SILENT
case|:
name|stop_print_frame
operator|=
literal|0
expr_stmt|;
comment|/* We are about to nuke the step_resume_breakpoint and 	   through_sigtramp_breakpoint via the cleanup chain, so 	   no need to worry about it here.  */
name|stop_stepping
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
case|case
name|BPSTAT_WHAT_STEP_RESUME
case|:
comment|/* This proably demands a more elegant solution, but, yeah 	   right...  	   This function's use of the simple variable 	   step_resume_breakpoint doesn't seem to accomodate 	   simultaneously active step-resume bp's, although the 	   breakpoint list certainly can.  	   If we reach here and step_resume_breakpoint is already 	   NULL, then apparently we have multiple active 	   step-resume bp's.  We'll just delete the breakpoint we 	   stopped at, and carry on.    	   Correction: what the code currently does is delete a 	   step-resume bp, but it makes no effort to ensure that 	   the one deleted is the one currently stopped at.  MVS  */
if|if
condition|(
name|step_resume_breakpoint
operator|==
name|NULL
condition|)
block|{
name|step_resume_breakpoint
operator|=
name|bpstat_find_step_resume_breakpoint
argument_list|(
name|stop_bpstat
argument_list|)
expr_stmt|;
block|}
name|delete_step_resume_breakpoint
argument_list|(
operator|&
name|step_resume_breakpoint
argument_list|)
expr_stmt|;
break|break;
case|case
name|BPSTAT_WHAT_THROUGH_SIGTRAMP
case|:
if|if
condition|(
name|through_sigtramp_breakpoint
condition|)
name|delete_breakpoint
argument_list|(
name|through_sigtramp_breakpoint
argument_list|)
expr_stmt|;
name|through_sigtramp_breakpoint
operator|=
name|NULL
expr_stmt|;
comment|/* If were waiting for a trap, hitting the step_resume_break 	   doesn't count as getting it.  */
if|if
condition|(
name|trap_expected
condition|)
name|ecs
operator|->
name|another_trap
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|BPSTAT_WHAT_CHECK_SHLIBS
case|:
case|case
name|BPSTAT_WHAT_CHECK_SHLIBS_RESUME_FROM_HOOK
case|:
ifdef|#
directive|ifdef
name|SOLIB_ADD
block|{
comment|/* Remove breakpoints, we eventually want to step over the 	     shlib event breakpoint, and SOLIB_ADD might adjust 	     breakpoint addresses via breakpoint_re_set.  */
if|if
condition|(
name|breakpoints_inserted
condition|)
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|breakpoints_inserted
operator|=
literal|0
expr_stmt|;
comment|/* Check for any newly added shared libraries if we're 	     supposed to be adding them automatically.  Switch 	     terminal for any messages produced by 	     breakpoint_re_set.  */
name|target_terminal_ours_for_output
argument_list|()
expr_stmt|;
comment|/* NOTE: cagney/2003-11-25: Make certain that the target              stack's section table is kept up-to-date.  Architectures,              (e.g., PPC64), use the section table to perform              operations such as address => section name and hence              require the table to contain all sections (including              those found in shared libraries).  */
comment|/* NOTE: cagney/2003-11-25: Pass current_target and not              exec_ops to SOLIB_ADD.  This is because current GDB is              only tooled to propagate section_table changes out from              the "current_target" (see target_resize_to_sections), and              not up from the exec stratum.  This, of course, isn't              right.  "infrun.c" should only interact with the              exec/process stratum, instead relying on the target stack              to propagate relevant changes (stop, section table              changed, ...) up to other layers.  */
name|SOLIB_ADD
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|current_target
argument_list|,
name|auto_solib_add
argument_list|)
expr_stmt|;
name|target_terminal_inferior
argument_list|()
expr_stmt|;
comment|/* Try to reenable shared library breakpoints, additional 	     code segments in shared libraries might be mapped in now. */
name|re_enable_breakpoints_in_shlibs
argument_list|()
expr_stmt|;
comment|/* If requested, stop when the dynamic linker notifies 	     gdb of events.  This allows the user to get control 	     and place breakpoints in initializer routines for 	     dynamically loaded objects (among other things).  */
if|if
condition|(
name|stop_on_solib_events
operator|||
name|stop_stack_dummy
condition|)
block|{
name|stop_stepping
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we stopped due to an explicit catchpoint, then the 	     (see above) call to SOLIB_ADD pulled in any symbols 	     from a newly-loaded library, if appropriate.  	     We do want the inferior to stop, but not where it is 	     now, which is in the dynamic linker callback.  Rather, 	     we would like it stop in the user's program, just after 	     the call that caused this catchpoint to trigger.  That 	     gives the user a more useful vantage from which to 	     examine their program's state. */
elseif|else
if|if
condition|(
name|what
operator|.
name|main_action
operator|==
name|BPSTAT_WHAT_CHECK_SHLIBS_RESUME_FROM_HOOK
condition|)
block|{
comment|/* ??rehrauer: If I could figure out how to get the 	         right return PC from here, we could just set a temp 	         breakpoint and resume.  I'm not sure we can without 	         cracking open the dld's shared libraries and sniffing 	         their unwind tables and text/data ranges, and that's 	         not a terribly portable notion.  	         Until that time, we must step the inferior out of the 	         dld callback, and also out of the dld itself (and any 	         code or stubs in libdld.sl, such as "shl_load" and 	         friends) until we reach non-dld code.  At that point, 	         we can stop stepping. */
name|bpstat_get_triggered_catchpoints
argument_list|(
name|stop_bpstat
argument_list|,
operator|&
name|ecs
operator|->
name|stepping_through_solib_catchpoints
argument_list|)
expr_stmt|;
name|ecs
operator|->
name|stepping_through_solib_after_catch
operator|=
literal|1
expr_stmt|;
comment|/* Be sure to lift all breakpoints, so the inferior does 	         actually step past this point... */
name|ecs
operator|->
name|another_trap
operator|=
literal|1
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* We want to step over this breakpoint, then keep going.  */
name|ecs
operator|->
name|another_trap
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
break|break;
case|case
name|BPSTAT_WHAT_LAST
case|:
comment|/* Not a real code, but listed here to shut up gcc -Wall.  */
case|case
name|BPSTAT_WHAT_KEEP_CHECKING
case|:
break|break;
block|}
block|}
comment|/* We come here if we hit a breakpoint but should not      stop for it.  Possibly we also were stepping      and should stop for that.  So fall through and      test for stepping.  But, if not stepping,      do not stop.  */
comment|/* Are we stepping to get the inferior out of the dynamic      linker's hook (and possibly the dld itself) after catching      a shlib event? */
if|if
condition|(
name|ecs
operator|->
name|stepping_through_solib_after_catch
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|SOLIB_ADD
argument_list|)
comment|/* Have we reached our destination?  If not, keep going. */
if|if
condition|(
name|SOLIB_IN_DYNAMIC_LINKER
argument_list|(
name|PIDGET
argument_list|(
name|ecs
operator|->
name|ptid
argument_list|)
argument_list|,
name|stop_pc
argument_list|)
condition|)
block|{
name|ecs
operator|->
name|another_trap
operator|=
literal|1
expr_stmt|;
name|keep_going
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* Else, stop and report the catchpoint(s) whose triggering          caused us to begin stepping. */
name|ecs
operator|->
name|stepping_through_solib_after_catch
operator|=
literal|0
expr_stmt|;
name|bpstat_clear
argument_list|(
operator|&
name|stop_bpstat
argument_list|)
expr_stmt|;
name|stop_bpstat
operator|=
name|bpstat_copy
argument_list|(
name|ecs
operator|->
name|stepping_through_solib_catchpoints
argument_list|)
expr_stmt|;
name|bpstat_clear
argument_list|(
operator|&
name|ecs
operator|->
name|stepping_through_solib_catchpoints
argument_list|)
expr_stmt|;
name|stop_print_frame
operator|=
literal|1
expr_stmt|;
name|stop_stepping
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|step_resume_breakpoint
condition|)
block|{
comment|/* Having a step-resume breakpoint overrides anything          else having to do with stepping commands until          that breakpoint is reached.  */
comment|/* I'm not sure whether this needs to be check_sigtramp2 or          whether it could/should be keep_going.  */
name|check_sigtramp2
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
name|keep_going
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|step_range_end
operator|==
literal|0
condition|)
block|{
comment|/* Likewise if we aren't even stepping.  */
comment|/* I'm not sure whether this needs to be check_sigtramp2 or          whether it could/should be keep_going.  */
name|check_sigtramp2
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
name|keep_going
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If stepping through a line, keep going if still within it.       Note that step_range_end is the address of the first instruction      beyond the step range, and NOT the address of the last instruction      within it! */
if|if
condition|(
name|stop_pc
operator|>=
name|step_range_start
operator|&&
name|stop_pc
operator|<
name|step_range_end
condition|)
block|{
comment|/* We might be doing a BPSTAT_WHAT_SINGLE and getting a signal.          So definately need to check for sigtramp here.  */
name|check_sigtramp2
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
name|keep_going
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We stepped out of the stepping range.  */
comment|/* If we are stepping at the source level and entered the runtime      loader dynamic symbol resolution code, we keep on single stepping      until we exit the run time loader code and reach the callee's      address.  */
if|if
condition|(
name|step_over_calls
operator|==
name|STEP_OVER_UNDEBUGGABLE
operator|&&
name|IN_SOLIB_DYNSYM_RESOLVE_CODE
argument_list|(
name|stop_pc
argument_list|)
condition|)
block|{
name|CORE_ADDR
name|pc_after_resolver
init|=
name|gdbarch_skip_solib_resolver
argument_list|(
name|current_gdbarch
argument_list|,
name|stop_pc
argument_list|)
decl_stmt|;
if|if
condition|(
name|pc_after_resolver
condition|)
block|{
comment|/* Set up a step-resume breakpoint at the address 	     indicated by SKIP_SOLIB_RESOLVER.  */
name|struct
name|symtab_and_line
name|sr_sal
decl_stmt|;
name|init_sal
argument_list|(
operator|&
name|sr_sal
argument_list|)
expr_stmt|;
name|sr_sal
operator|.
name|pc
operator|=
name|pc_after_resolver
expr_stmt|;
name|check_for_old_step_resume_breakpoint
argument_list|()
expr_stmt|;
name|step_resume_breakpoint
operator|=
name|set_momentary_breakpoint
argument_list|(
name|sr_sal
argument_list|,
name|null_frame_id
argument_list|,
name|bp_step_resume
argument_list|)
expr_stmt|;
if|if
condition|(
name|breakpoints_inserted
condition|)
name|insert_breakpoints
argument_list|()
expr_stmt|;
block|}
name|keep_going
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We can't update step_sp every time through the loop, because      reading the stack pointer would slow down stepping too much.      But we can update it every time we leave the step range.  */
name|ecs
operator|->
name|update_step_sp
operator|=
literal|1
expr_stmt|;
comment|/* Did we just take a signal?  */
if|if
condition|(
name|pc_in_sigtramp
argument_list|(
name|stop_pc
argument_list|)
operator|&&
operator|!
name|pc_in_sigtramp
argument_list|(
name|prev_pc
argument_list|)
operator|&&
name|INNER_THAN
argument_list|(
name|read_sp
argument_list|()
argument_list|,
name|step_sp
argument_list|)
condition|)
block|{
comment|/* We've just taken a signal; go until we are back to          the point where we took it and one more.  */
comment|/* Note: The test above succeeds not only when we stepped          into a signal handler, but also when we step past the last          statement of a signal handler and end up in the return stub          of the signal handler trampoline.  To distinguish between          these two cases, check that the frame is INNER_THAN the          previous one below. pai/1997-09-11 */
block|{
name|struct
name|frame_id
name|current_frame
init|=
name|get_frame_id
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|frame_id_inner
argument_list|(
name|current_frame
argument_list|,
name|step_frame_id
argument_list|)
condition|)
block|{
comment|/* We have just taken a signal; go until we are back to 	       the point where we took it and one more.  */
comment|/* This code is needed at least in the following case: 	       The user types "next" and then a signal arrives (before 	       the "next" is done).  */
comment|/* Note that if we are stopped at a breakpoint, then we need 	       the step_resume breakpoint to override any breakpoints at 	       the same location, so that we will still step over the 	       breakpoint even though the signal happened.  */
name|struct
name|symtab_and_line
name|sr_sal
decl_stmt|;
name|init_sal
argument_list|(
operator|&
name|sr_sal
argument_list|)
expr_stmt|;
name|sr_sal
operator|.
name|symtab
operator|=
name|NULL
expr_stmt|;
name|sr_sal
operator|.
name|line
operator|=
literal|0
expr_stmt|;
name|sr_sal
operator|.
name|pc
operator|=
name|prev_pc
expr_stmt|;
comment|/* We could probably be setting the frame to 	       step_frame_id; I don't think anyone thought to try it.  */
name|check_for_old_step_resume_breakpoint
argument_list|()
expr_stmt|;
name|step_resume_breakpoint
operator|=
name|set_momentary_breakpoint
argument_list|(
name|sr_sal
argument_list|,
name|null_frame_id
argument_list|,
name|bp_step_resume
argument_list|)
expr_stmt|;
if|if
condition|(
name|breakpoints_inserted
condition|)
name|insert_breakpoints
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* We just stepped out of a signal handler and into 	       its calling trampoline.  	       Normally, we'd call step_over_function from 	       here, but for some reason GDB can't unwind the 	       stack correctly to find the real PC for the point 	       user code where the signal trampoline will return 	       -- FRAME_SAVED_PC fails, at least on HP-UX 10.20. 	       But signal trampolines are pretty small stubs of 	       code, anyway, so it's OK instead to just 	       single-step out.  Note: assuming such trampolines 	       don't exhibit recursion on any platform... */
name|find_pc_partial_function
argument_list|(
name|stop_pc
argument_list|,
operator|&
name|ecs
operator|->
name|stop_func_name
argument_list|,
operator|&
name|ecs
operator|->
name|stop_func_start
argument_list|,
operator|&
name|ecs
operator|->
name|stop_func_end
argument_list|)
expr_stmt|;
comment|/* Readjust stepping range */
name|step_range_start
operator|=
name|ecs
operator|->
name|stop_func_start
expr_stmt|;
name|step_range_end
operator|=
name|ecs
operator|->
name|stop_func_end
expr_stmt|;
name|ecs
operator|->
name|stepping_through_sigtramp
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* If this is stepi or nexti, make sure that the stepping range          gets us past that instruction.  */
if|if
condition|(
name|step_range_end
operator|==
literal|1
condition|)
comment|/* FIXME: Does this run afoul of the code below which, if 	   we step into the middle of a line, resets the stepping 	   range?  */
name|step_range_end
operator|=
operator|(
name|step_range_start
operator|=
name|prev_pc
operator|)
operator|+
literal|1
expr_stmt|;
name|ecs
operator|->
name|remove_breakpoints_on_following_step
operator|=
literal|1
expr_stmt|;
name|keep_going
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
operator|(
name|stop_pc
operator|==
name|ecs
operator|->
name|stop_func_start
comment|/* Quick test */
operator|||
name|in_prologue
argument_list|(
name|stop_pc
argument_list|,
name|ecs
operator|->
name|stop_func_start
argument_list|)
operator|)
operator|&&
operator|!
name|IN_SOLIB_RETURN_TRAMPOLINE
argument_list|(
name|stop_pc
argument_list|,
name|ecs
operator|->
name|stop_func_name
argument_list|)
operator|)
operator|||
name|IN_SOLIB_CALL_TRAMPOLINE
argument_list|(
name|stop_pc
argument_list|,
name|ecs
operator|->
name|stop_func_name
argument_list|)
operator|||
name|ecs
operator|->
name|stop_func_name
operator|==
literal|0
condition|)
block|{
comment|/* It's a subroutine call.  */
name|handle_step_into_function
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We've wandered out of the step range.  */
name|ecs
operator|->
name|sal
operator|=
name|find_pc_line
argument_list|(
name|stop_pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|step_range_end
operator|==
literal|1
condition|)
block|{
comment|/* It is stepi or nexti.  We always want to stop stepping after          one instruction.  */
name|stop_step
operator|=
literal|1
expr_stmt|;
name|print_stop_reason
argument_list|(
name|END_STEPPING_RANGE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stop_stepping
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we're in the return path from a shared library trampoline,      we want to proceed through the trampoline when stepping.  */
if|if
condition|(
name|IN_SOLIB_RETURN_TRAMPOLINE
argument_list|(
name|stop_pc
argument_list|,
name|ecs
operator|->
name|stop_func_name
argument_list|)
condition|)
block|{
comment|/* Determine where this trampoline returns.  */
name|CORE_ADDR
name|real_stop_pc
init|=
name|SKIP_TRAMPOLINE_CODE
argument_list|(
name|stop_pc
argument_list|)
decl_stmt|;
comment|/* Only proceed through if we know where it's going.  */
if|if
condition|(
name|real_stop_pc
condition|)
block|{
comment|/* And put the step-breakpoint there and go until there. */
name|struct
name|symtab_and_line
name|sr_sal
decl_stmt|;
name|init_sal
argument_list|(
operator|&
name|sr_sal
argument_list|)
expr_stmt|;
comment|/* initialize to zeroes */
name|sr_sal
operator|.
name|pc
operator|=
name|real_stop_pc
expr_stmt|;
name|sr_sal
operator|.
name|section
operator|=
name|find_pc_overlay
argument_list|(
name|sr_sal
operator|.
name|pc
argument_list|)
expr_stmt|;
comment|/* Do not specify what the fp should be when we stop 	     since on some machines the prologue 	     is where the new fp value is established.  */
name|check_for_old_step_resume_breakpoint
argument_list|()
expr_stmt|;
name|step_resume_breakpoint
operator|=
name|set_momentary_breakpoint
argument_list|(
name|sr_sal
argument_list|,
name|null_frame_id
argument_list|,
name|bp_step_resume
argument_list|)
expr_stmt|;
if|if
condition|(
name|breakpoints_inserted
condition|)
name|insert_breakpoints
argument_list|()
expr_stmt|;
comment|/* Restart without fiddling with the step ranges or 	     other state.  */
name|keep_going
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|ecs
operator|->
name|sal
operator|.
name|line
operator|==
literal|0
condition|)
block|{
comment|/* We have no line number information.  That means to stop          stepping (does this always happen right after one instruction,          when we do "s" in a function with no line numbers,          or can this happen as a result of a return or longjmp?).  */
name|stop_step
operator|=
literal|1
expr_stmt|;
name|print_stop_reason
argument_list|(
name|END_STEPPING_RANGE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stop_stepping
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|stop_pc
operator|==
name|ecs
operator|->
name|sal
operator|.
name|pc
operator|)
operator|&&
operator|(
name|ecs
operator|->
name|current_line
operator|!=
name|ecs
operator|->
name|sal
operator|.
name|line
operator|||
name|ecs
operator|->
name|current_symtab
operator|!=
name|ecs
operator|->
name|sal
operator|.
name|symtab
operator|)
condition|)
block|{
comment|/* We are at the start of a different line.  So stop.  Note that          we don't stop if we step into the middle of a different line.          That is said to make things like for (;;) statements work          better.  */
name|stop_step
operator|=
literal|1
expr_stmt|;
name|print_stop_reason
argument_list|(
name|END_STEPPING_RANGE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stop_stepping
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We aren't done stepping.       Optimize by setting the stepping range to the line.      (We might not be in the original line, but if we entered a      new line in mid-statement, we continue stepping.  This makes      things like for(;;) statements work better.)  */
if|if
condition|(
name|ecs
operator|->
name|stop_func_end
operator|&&
name|ecs
operator|->
name|sal
operator|.
name|end
operator|>=
name|ecs
operator|->
name|stop_func_end
condition|)
block|{
comment|/* If this is the last line of the function, don't keep stepping          (it would probably step us out of the function).          This is particularly necessary for a one-line function,          in which after skipping the prologue we better stop even though          we will be in mid-line.  */
name|stop_step
operator|=
literal|1
expr_stmt|;
name|print_stop_reason
argument_list|(
name|END_STEPPING_RANGE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stop_stepping
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
block|}
name|step_range_start
operator|=
name|ecs
operator|->
name|sal
operator|.
name|pc
expr_stmt|;
name|step_range_end
operator|=
name|ecs
operator|->
name|sal
operator|.
name|end
expr_stmt|;
name|step_frame_id
operator|=
name|get_frame_id
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
expr_stmt|;
name|ecs
operator|->
name|current_line
operator|=
name|ecs
operator|->
name|sal
operator|.
name|line
expr_stmt|;
name|ecs
operator|->
name|current_symtab
operator|=
name|ecs
operator|->
name|sal
operator|.
name|symtab
expr_stmt|;
comment|/* In the case where we just stepped out of a function into the      middle of a line of the caller, continue stepping, but      step_frame_id must be modified to current frame */
if|#
directive|if
literal|0
comment|/* NOTE: cagney/2003-10-16: I think this frame ID inner test is too      generous.  It will trigger on things like a step into a frameless      stackless leaf function.  I think the logic should instead look      at the unwound frame ID has that should give a more robust      indication of what happened.  */
block|if (step-ID == current-ID)        still stepping in same function;      else if (step-ID == unwind (current-ID))        stepped into a function;      else        stepped out of a function;
comment|/* Of course this assumes that the frame ID unwind code is robust         and we're willing to introduce frame unwind logic into this         function.  Fortunately, those days are nearly upon us.  */
endif|#
directive|endif
block|{
name|struct
name|frame_id
name|current_frame
init|=
name|get_frame_id
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|frame_id_inner
argument_list|(
name|current_frame
argument_list|,
name|step_frame_id
argument_list|)
operator|)
condition|)
name|step_frame_id
operator|=
name|current_frame
expr_stmt|;
block|}
name|keep_going
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Are we in the middle of stepping?  */
end_comment

begin_function
specifier|static
name|int
name|currently_stepping
parameter_list|(
name|struct
name|execution_control_state
modifier|*
name|ecs
parameter_list|)
block|{
return|return
operator|(
operator|(
name|through_sigtramp_breakpoint
operator|==
name|NULL
operator|&&
operator|!
name|ecs
operator|->
name|handling_longjmp
operator|&&
operator|(
operator|(
name|step_range_end
operator|&&
name|step_resume_breakpoint
operator|==
name|NULL
operator|)
operator|||
name|trap_expected
operator|)
operator|)
operator|||
name|ecs
operator|->
name|stepping_through_solib_after_catch
operator|||
name|bpstat_should_step
argument_list|()
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_sigtramp2
parameter_list|(
name|struct
name|execution_control_state
modifier|*
name|ecs
parameter_list|)
block|{
if|if
condition|(
name|trap_expected
operator|&&
name|pc_in_sigtramp
argument_list|(
name|stop_pc
argument_list|)
operator|&&
operator|!
name|pc_in_sigtramp
argument_list|(
name|prev_pc
argument_list|)
operator|&&
name|INNER_THAN
argument_list|(
name|read_sp
argument_list|()
argument_list|,
name|step_sp
argument_list|)
condition|)
block|{
comment|/* What has happened here is that we have just stepped the          inferior with a signal (because it is a signal which          shouldn't make us stop), thus stepping into sigtramp.           So we need to set a step_resume_break_address breakpoint and          continue until we hit it, and then step.  FIXME: This should          be more enduring than a step_resume breakpoint; we should          know that we will later need to keep going rather than          re-hitting the breakpoint here (see the testsuite,          gdb.base/signals.exp where it says "exceedingly difficult").  */
name|struct
name|symtab_and_line
name|sr_sal
decl_stmt|;
name|init_sal
argument_list|(
operator|&
name|sr_sal
argument_list|)
expr_stmt|;
comment|/* initialize to zeroes */
name|sr_sal
operator|.
name|pc
operator|=
name|prev_pc
expr_stmt|;
name|sr_sal
operator|.
name|section
operator|=
name|find_pc_overlay
argument_list|(
name|sr_sal
operator|.
name|pc
argument_list|)
expr_stmt|;
comment|/* We perhaps could set the frame if we kept track of what the          frame corresponding to prev_pc was.  But we don't, so don't.  */
name|through_sigtramp_breakpoint
operator|=
name|set_momentary_breakpoint
argument_list|(
name|sr_sal
argument_list|,
name|null_frame_id
argument_list|,
name|bp_through_sigtramp
argument_list|)
expr_stmt|;
if|if
condition|(
name|breakpoints_inserted
condition|)
name|insert_breakpoints
argument_list|()
expr_stmt|;
name|ecs
operator|->
name|remove_breakpoints_on_following_step
operator|=
literal|1
expr_stmt|;
name|ecs
operator|->
name|another_trap
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Subroutine call with source code we should not step over.  Do step    to the first line of code in it.  */
end_comment

begin_function
specifier|static
name|void
name|step_into_function
parameter_list|(
name|struct
name|execution_control_state
modifier|*
name|ecs
parameter_list|)
block|{
name|struct
name|symtab
modifier|*
name|s
decl_stmt|;
name|struct
name|symtab_and_line
name|sr_sal
decl_stmt|;
name|s
operator|=
name|find_pc_symtab
argument_list|(
name|stop_pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|&&
name|s
operator|->
name|language
operator|!=
name|language_asm
condition|)
name|ecs
operator|->
name|stop_func_start
operator|=
name|SKIP_PROLOGUE
argument_list|(
name|ecs
operator|->
name|stop_func_start
argument_list|)
expr_stmt|;
name|ecs
operator|->
name|sal
operator|=
name|find_pc_line
argument_list|(
name|ecs
operator|->
name|stop_func_start
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Use the step_resume_break to step until the end of the prologue,      even if that involves jumps (as it seems to on the vax under      4.2).  */
comment|/* If the prologue ends in the middle of a source line, continue to      the end of that source line (if it is still within the function).      Otherwise, just go to end of prologue.  */
if|if
condition|(
name|ecs
operator|->
name|sal
operator|.
name|end
operator|&&
name|ecs
operator|->
name|sal
operator|.
name|pc
operator|!=
name|ecs
operator|->
name|stop_func_start
operator|&&
name|ecs
operator|->
name|sal
operator|.
name|end
operator|<
name|ecs
operator|->
name|stop_func_end
condition|)
name|ecs
operator|->
name|stop_func_start
operator|=
name|ecs
operator|->
name|sal
operator|.
name|end
expr_stmt|;
comment|/* Architectures which require breakpoint adjustment might not be able      to place a breakpoint at the computed address.  If so, the test      ``ecs->stop_func_start == stop_pc'' will never succeed.  Adjust      ecs->stop_func_start to an address at which a breakpoint may be      legitimately placed.            Note:  kevinb/2004-01-19:  On FR-V, if this adjustment is not      made, GDB will enter an infinite loop when stepping through      optimized code consisting of VLIW instructions which contain      subinstructions corresponding to different source lines.  On      FR-V, it's not permitted to place a breakpoint on any but the      first subinstruction of a VLIW instruction.  When a breakpoint is      set, GDB will adjust the breakpoint address to the beginning of      the VLIW instruction.  Thus, we need to make the corresponding      adjustment here when computing the stop address.  */
if|if
condition|(
name|gdbarch_adjust_breakpoint_address_p
argument_list|(
name|current_gdbarch
argument_list|)
condition|)
block|{
name|ecs
operator|->
name|stop_func_start
operator|=
name|gdbarch_adjust_breakpoint_address
argument_list|(
name|current_gdbarch
argument_list|,
name|ecs
operator|->
name|stop_func_start
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ecs
operator|->
name|stop_func_start
operator|==
name|stop_pc
condition|)
block|{
comment|/* We are already there: stop now.  */
name|stop_step
operator|=
literal|1
expr_stmt|;
name|print_stop_reason
argument_list|(
name|END_STEPPING_RANGE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stop_stepping
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* Put the step-breakpoint there and go until there.  */
name|init_sal
argument_list|(
operator|&
name|sr_sal
argument_list|)
expr_stmt|;
comment|/* initialize to zeroes */
name|sr_sal
operator|.
name|pc
operator|=
name|ecs
operator|->
name|stop_func_start
expr_stmt|;
name|sr_sal
operator|.
name|section
operator|=
name|find_pc_overlay
argument_list|(
name|ecs
operator|->
name|stop_func_start
argument_list|)
expr_stmt|;
comment|/* Do not specify what the fp should be when we stop since on          some machines the prologue is where the new fp value is          established.  */
name|check_for_old_step_resume_breakpoint
argument_list|()
expr_stmt|;
name|step_resume_breakpoint
operator|=
name|set_momentary_breakpoint
argument_list|(
name|sr_sal
argument_list|,
name|null_frame_id
argument_list|,
name|bp_step_resume
argument_list|)
expr_stmt|;
if|if
condition|(
name|breakpoints_inserted
condition|)
name|insert_breakpoints
argument_list|()
expr_stmt|;
comment|/* And make sure stepping stops right away then.  */
name|step_range_end
operator|=
name|step_range_start
expr_stmt|;
block|}
name|keep_going
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We've just entered a callee, and we wish to resume until it returns    to the caller.  Setting a step_resume breakpoint on the return    address will catch a return from the callee.          However, if the callee is recursing, we want to be careful not to    catch returns of those recursive calls, but only of THIS instance    of the call.     To do this, we set the step_resume bp's frame to our current    caller's frame (step_frame_id, which is set by the "next" or    "until" command, before execution begins).  */
end_comment

begin_function
specifier|static
name|void
name|step_over_function
parameter_list|(
name|struct
name|execution_control_state
modifier|*
name|ecs
parameter_list|)
block|{
name|struct
name|symtab_and_line
name|sr_sal
decl_stmt|;
name|init_sal
argument_list|(
operator|&
name|sr_sal
argument_list|)
expr_stmt|;
comment|/* initialize to zeros */
comment|/* NOTE: cagney/2003-04-06:       At this point the equality get_frame_pc() == get_frame_func()      should hold.  This may make it possible for this code to tell the      frame where it's function is, instead of the reverse.  This would      avoid the need to search for the frame's function, which can get      very messy when there is no debug info available (look at the      heuristic find pc start code found in targets like the MIPS).  */
comment|/* NOTE: cagney/2003-04-06:       The intent of DEPRECATED_SAVED_PC_AFTER_CALL was to:       - provide a very light weight equivalent to frame_unwind_pc()      (nee FRAME_SAVED_PC) that avoids the prologue analyzer       - avoid handling the case where the PC hasn't been saved in the      prologue analyzer       Unfortunately, not five lines further down, is a call to      get_frame_id() and that is guarenteed to trigger the prologue      analyzer.            The `correct fix' is for the prologe analyzer to handle the case      where the prologue is incomplete (PC in prologue) and,      consequently, the return pc has not yet been saved.  It should be      noted that the prologue analyzer needs to handle this case      anyway: frameless leaf functions that don't save the return PC;      single stepping through a prologue.       The d10v handles all this by bailing out of the prologue analsis      when it reaches the current instruction.  */
if|if
condition|(
name|DEPRECATED_SAVED_PC_AFTER_CALL_P
argument_list|()
condition|)
name|sr_sal
operator|.
name|pc
operator|=
name|ADDR_BITS_REMOVE
argument_list|(
name|DEPRECATED_SAVED_PC_AFTER_CALL
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sr_sal
operator|.
name|pc
operator|=
name|ADDR_BITS_REMOVE
argument_list|(
name|frame_pc_unwind
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|sr_sal
operator|.
name|section
operator|=
name|find_pc_overlay
argument_list|(
name|sr_sal
operator|.
name|pc
argument_list|)
expr_stmt|;
name|check_for_old_step_resume_breakpoint
argument_list|()
expr_stmt|;
name|step_resume_breakpoint
operator|=
name|set_momentary_breakpoint
argument_list|(
name|sr_sal
argument_list|,
name|get_frame_id
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
argument_list|,
name|bp_step_resume
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame_id_p
argument_list|(
name|step_frame_id
argument_list|)
operator|&&
operator|!
name|IN_SOLIB_DYNSYM_RESOLVE_CODE
argument_list|(
name|sr_sal
operator|.
name|pc
argument_list|)
condition|)
name|step_resume_breakpoint
operator|->
name|frame_id
operator|=
name|step_frame_id
expr_stmt|;
if|if
condition|(
name|breakpoints_inserted
condition|)
name|insert_breakpoints
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|stop_stepping
parameter_list|(
name|struct
name|execution_control_state
modifier|*
name|ecs
parameter_list|)
block|{
comment|/* Let callers know we don't want to wait for the inferior anymore.  */
name|ecs
operator|->
name|wait_some_more
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function handles various cases where we need to continue    waiting for the inferior.  */
end_comment

begin_comment
comment|/* (Used to be the keep_going: label in the old wait_for_inferior) */
end_comment

begin_function
specifier|static
name|void
name|keep_going
parameter_list|(
name|struct
name|execution_control_state
modifier|*
name|ecs
parameter_list|)
block|{
comment|/* Save the pc before execution, to compare with pc after stop.  */
name|prev_pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
comment|/* Might have been DECR_AFTER_BREAK */
if|if
condition|(
name|ecs
operator|->
name|update_step_sp
condition|)
name|step_sp
operator|=
name|read_sp
argument_list|()
expr_stmt|;
name|ecs
operator|->
name|update_step_sp
operator|=
literal|0
expr_stmt|;
comment|/* If we did not do break;, it means we should keep running the      inferior and not return to debugger.  */
if|if
condition|(
name|trap_expected
operator|&&
name|stop_signal
operator|!=
name|TARGET_SIGNAL_TRAP
condition|)
block|{
comment|/* We took a signal (which we are supposed to pass through to          the inferior, else we'd have done a break above) and we          haven't yet gotten our trap.  Simply continue.  */
name|resume
argument_list|(
name|currently_stepping
argument_list|(
name|ecs
argument_list|)
argument_list|,
name|stop_signal
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Either the trap was not expected, but we are continuing          anyway (the user asked that this signal be passed to the          child)          -- or --          The signal was SIGTRAP, e.g. it was our signal, but we          decided we should resume from it.           We're going to run this baby now!           Insert breakpoints now, unless we are trying to one-proceed          past a breakpoint.  */
comment|/* If we've just finished a special step resume and we don't          want to hit a breakpoint, pull em out.  */
if|if
condition|(
name|step_resume_breakpoint
operator|==
name|NULL
operator|&&
name|through_sigtramp_breakpoint
operator|==
name|NULL
operator|&&
name|ecs
operator|->
name|remove_breakpoints_on_following_step
condition|)
block|{
name|ecs
operator|->
name|remove_breakpoints_on_following_step
operator|=
literal|0
expr_stmt|;
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|breakpoints_inserted
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|breakpoints_inserted
operator|&&
operator|(
name|through_sigtramp_breakpoint
operator|!=
name|NULL
operator|||
operator|!
name|ecs
operator|->
name|another_trap
operator|)
condition|)
block|{
name|breakpoints_failed
operator|=
name|insert_breakpoints
argument_list|()
expr_stmt|;
if|if
condition|(
name|breakpoints_failed
condition|)
block|{
name|stop_stepping
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
return|return;
block|}
name|breakpoints_inserted
operator|=
literal|1
expr_stmt|;
block|}
name|trap_expected
operator|=
name|ecs
operator|->
name|another_trap
expr_stmt|;
comment|/* Do not deliver SIGNAL_TRAP (except when the user explicitly          specifies that such a signal should be delivered to the          target program).           Typically, this would occure when a user is debugging a          target monitor on a simulator: the target monitor sets a          breakpoint; the simulator encounters this break-point and          halts the simulation handing control to GDB; GDB, noteing          that the break-point isn't valid, returns control back to the          simulator; the simulator then delivers the hardware          equivalent of a SIGNAL_TRAP to the program being debugged. */
if|if
condition|(
name|stop_signal
operator|==
name|TARGET_SIGNAL_TRAP
operator|&&
operator|!
name|signal_program
index|[
name|stop_signal
index|]
condition|)
name|stop_signal
operator|=
name|TARGET_SIGNAL_0
expr_stmt|;
name|resume
argument_list|(
name|currently_stepping
argument_list|(
name|ecs
argument_list|)
argument_list|,
name|stop_signal
argument_list|)
expr_stmt|;
block|}
name|prepare_to_wait
argument_list|(
name|ecs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function normally comes after a resume, before    handle_inferior_event exits.  It takes care of any last bits of    housekeeping, and sets the all-important wait_some_more flag.  */
end_comment

begin_function
specifier|static
name|void
name|prepare_to_wait
parameter_list|(
name|struct
name|execution_control_state
modifier|*
name|ecs
parameter_list|)
block|{
if|if
condition|(
name|ecs
operator|->
name|infwait_state
operator|==
name|infwait_normal_state
condition|)
block|{
name|overlay_cache_invalid
operator|=
literal|1
expr_stmt|;
comment|/* We have to invalidate the registers BEFORE calling          target_wait because they can be loaded from the target while          in target_wait.  This makes remote debugging a bit more          efficient for those targets that provide critical registers          as part of their normal status mechanism. */
name|registers_changed
argument_list|()
expr_stmt|;
name|ecs
operator|->
name|waiton_ptid
operator|=
name|pid_to_ptid
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ecs
operator|->
name|wp
operator|=
operator|&
operator|(
name|ecs
operator|->
name|ws
operator|)
expr_stmt|;
block|}
comment|/* This is the old end of the while loop.  Let everybody know we      want to wait for the inferior some more and get called again      soon.  */
name|ecs
operator|->
name|wait_some_more
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print why the inferior has stopped. We always print something when    the inferior exits, or receives a signal. The rest of the cases are    dealt with later on in normal_stop() and print_it_typical().  Ideally    there should be a call to this function from handle_inferior_event()    each time stop_stepping() is called.*/
end_comment

begin_function
specifier|static
name|void
name|print_stop_reason
parameter_list|(
name|enum
name|inferior_stop_reason
name|stop_reason
parameter_list|,
name|int
name|stop_info
parameter_list|)
block|{
switch|switch
condition|(
name|stop_reason
condition|)
block|{
case|case
name|STOP_UNKNOWN
case|:
comment|/* We don't deal with these cases from handle_inferior_event()          yet. */
break|break;
case|case
name|END_STEPPING_RANGE
case|:
comment|/* We are done with a step/next/si/ni command. */
comment|/* For now print nothing. */
comment|/* Print a message only if not in the middle of doing a "step n"          operation for n> 1 */
if|if
condition|(
operator|!
name|step_multi
operator|||
operator|!
name|stop_step
condition|)
if|if
condition|(
name|ui_out_is_mi_like_p
argument_list|(
name|uiout
argument_list|)
condition|)
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"reason"
argument_list|,
literal|"end-stepping-range"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BREAKPOINT_HIT
case|:
comment|/* We found a breakpoint. */
comment|/* For now print nothing. */
break|break;
case|case
name|SIGNAL_EXITED
case|:
comment|/* The inferior was terminated by a signal. */
name|annotate_signalled
argument_list|()
expr_stmt|;
if|if
condition|(
name|ui_out_is_mi_like_p
argument_list|(
name|uiout
argument_list|)
condition|)
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"reason"
argument_list|,
literal|"exited-signalled"
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\nProgram terminated with signal "
argument_list|)
expr_stmt|;
name|annotate_signal_name
argument_list|()
expr_stmt|;
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"signal-name"
argument_list|,
name|target_signal_to_name
argument_list|(
name|stop_info
argument_list|)
argument_list|)
expr_stmt|;
name|annotate_signal_name_end
argument_list|()
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|annotate_signal_string
argument_list|()
expr_stmt|;
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"signal-meaning"
argument_list|,
name|target_signal_to_string
argument_list|(
name|stop_info
argument_list|)
argument_list|)
expr_stmt|;
name|annotate_signal_string_end
argument_list|()
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"The program no longer exists.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|EXITED
case|:
comment|/* The inferior program is finished. */
name|annotate_exited
argument_list|(
name|stop_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|stop_info
condition|)
block|{
if|if
condition|(
name|ui_out_is_mi_like_p
argument_list|(
name|uiout
argument_list|)
condition|)
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"reason"
argument_list|,
literal|"exited"
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\nProgram exited with code "
argument_list|)
expr_stmt|;
name|ui_out_field_fmt
argument_list|(
name|uiout
argument_list|,
literal|"exit-code"
argument_list|,
literal|"0%o"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|stop_info
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ui_out_is_mi_like_p
argument_list|(
name|uiout
argument_list|)
condition|)
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"reason"
argument_list|,
literal|"exited-normally"
argument_list|)
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\nProgram exited normally.\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIGNAL_RECEIVED
case|:
comment|/* Signal received. The signal table tells us to print about          it. */
name|annotate_signal
argument_list|()
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|"\nProgram received signal "
argument_list|)
expr_stmt|;
name|annotate_signal_name
argument_list|()
expr_stmt|;
if|if
condition|(
name|ui_out_is_mi_like_p
argument_list|(
name|uiout
argument_list|)
condition|)
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"reason"
argument_list|,
literal|"signal-received"
argument_list|)
expr_stmt|;
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"signal-name"
argument_list|,
name|target_signal_to_name
argument_list|(
name|stop_info
argument_list|)
argument_list|)
expr_stmt|;
name|annotate_signal_name_end
argument_list|()
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|annotate_signal_string
argument_list|()
expr_stmt|;
name|ui_out_field_string
argument_list|(
name|uiout
argument_list|,
literal|"signal-meaning"
argument_list|,
name|target_signal_to_string
argument_list|(
name|stop_info
argument_list|)
argument_list|)
expr_stmt|;
name|annotate_signal_string_end
argument_list|()
expr_stmt|;
name|ui_out_text
argument_list|(
name|uiout
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"print_stop_reason: unrecognized enum value"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Here to return control to GDB when the inferior stops for real.    Print appropriate messages, remove breakpoints, give terminal our modes.     STOP_PRINT_FRAME nonzero means print the executing frame    (pc, function, args, file, line number and line text).    BREAKPOINTS_FAILED nonzero means stop was due to error    attempting to insert breakpoints.  */
end_comment

begin_function
name|void
name|normal_stop
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|target_waitstatus
name|last
decl_stmt|;
name|ptid_t
name|last_ptid
decl_stmt|;
name|get_last_target_status
argument_list|(
operator|&
name|last_ptid
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
comment|/* As with the notification of thread events, we want to delay      notifying the user that we've switched thread context until      the inferior actually stops.       There's no point in saying anything if the inferior has exited.      Note that SIGNALLED here means "exited with a signal", not      "received a signal".  */
if|if
condition|(
operator|!
name|ptid_equal
argument_list|(
name|previous_inferior_ptid
argument_list|,
name|inferior_ptid
argument_list|)
operator|&&
name|target_has_execution
operator|&&
name|last
operator|.
name|kind
operator|!=
name|TARGET_WAITKIND_SIGNALLED
operator|&&
name|last
operator|.
name|kind
operator|!=
name|TARGET_WAITKIND_EXITED
condition|)
block|{
name|target_terminal_ours_for_output
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"[Switching to %s]\n"
argument_list|,
name|target_pid_or_tid_to_str
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
name|previous_inferior_ptid
operator|=
name|inferior_ptid
expr_stmt|;
block|}
comment|/* NOTE drow/2004-01-17: Is this still necessary?  */
comment|/* Make sure that the current_frame's pc is correct.  This      is a correction for setting up the frame info before doing      DECR_PC_AFTER_BREAK */
if|if
condition|(
name|target_has_execution
condition|)
comment|/* FIXME: cagney/2002-12-06: Has the PC changed?  Thanks to        DECR_PC_AFTER_BREAK, the program counter can change.  Ask the        frame code to check for this and sort out any resultant mess.        DECR_PC_AFTER_BREAK needs to just go away.  */
name|deprecated_update_frame_pc_hack
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
name|read_pc
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_has_execution
operator|&&
name|breakpoints_inserted
condition|)
block|{
if|if
condition|(
name|remove_breakpoints
argument_list|()
condition|)
block|{
name|target_terminal_ours_for_output
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Cannot remove breakpoints because "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"program is no longer writable.\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"It might be running in another process.\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Further execution is probably impossible.\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|breakpoints_inserted
operator|=
literal|0
expr_stmt|;
comment|/* Delete the breakpoint we stopped at, if it wants to be deleted.      Delete any breakpoint that is to be deleted at the next stop.  */
name|breakpoint_auto_delete
argument_list|(
name|stop_bpstat
argument_list|)
expr_stmt|;
comment|/* If an auto-display called a function and that got a signal,      delete that auto-display to avoid an infinite recursion.  */
if|if
condition|(
name|stopped_by_random_signal
condition|)
name|disable_current_display
argument_list|()
expr_stmt|;
comment|/* Don't print a message if in the middle of doing a "step n"      operation for n> 1 */
if|if
condition|(
name|step_multi
operator|&&
name|stop_step
condition|)
goto|goto
name|done
goto|;
name|target_terminal_ours
argument_list|()
expr_stmt|;
comment|/* Look up the hook_stop and run it (CLI internally handles problem      of stop_command's pre-hook not existing).  */
if|if
condition|(
name|stop_command
condition|)
name|catch_errors
argument_list|(
name|hook_stop_stub
argument_list|,
name|stop_command
argument_list|,
literal|"Error while running hook_stop:\n"
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target_has_stack
condition|)
block|{
goto|goto
name|done
goto|;
block|}
comment|/* Select innermost stack frame - i.e., current frame is frame 0,      and current location is based on that.      Don't do this on return from a stack dummy routine,      or if the program has exited. */
if|if
condition|(
operator|!
name|stop_stack_dummy
condition|)
block|{
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Print current location without a level number, if          we have changed functions or hit a breakpoint.          Print source line if we have one.          bpstat_print() contains the logic deciding in detail          what to print, based on the event(s) that just occurred. */
if|if
condition|(
name|stop_print_frame
operator|&&
name|deprecated_selected_frame
condition|)
block|{
name|int
name|bpstat_ret
decl_stmt|;
name|int
name|source_flag
decl_stmt|;
name|int
name|do_frame_printing
init|=
literal|1
decl_stmt|;
name|bpstat_ret
operator|=
name|bpstat_print
argument_list|(
name|stop_bpstat
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bpstat_ret
condition|)
block|{
case|case
name|PRINT_UNKNOWN
case|:
comment|/* FIXME: cagney/2002-12-01: Given that a frame ID does 		 (or should) carry around the function and does (or 		 should) use that when doing a frame comparison.  */
if|if
condition|(
name|stop_step
operator|&&
name|frame_id_eq
argument_list|(
name|step_frame_id
argument_list|,
name|get_frame_id
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
argument_list|)
operator|&&
name|step_start_function
operator|==
name|find_pc_function
argument_list|(
name|stop_pc
argument_list|)
condition|)
name|source_flag
operator|=
name|SRC_LINE
expr_stmt|;
comment|/* finished step, just print source line */
else|else
name|source_flag
operator|=
name|SRC_AND_LOC
expr_stmt|;
comment|/* print location and source line */
break|break;
case|case
name|PRINT_SRC_AND_LOC
case|:
name|source_flag
operator|=
name|SRC_AND_LOC
expr_stmt|;
comment|/* print location and source line */
break|break;
case|case
name|PRINT_SRC_ONLY
case|:
name|source_flag
operator|=
name|SRC_LINE
expr_stmt|;
break|break;
case|case
name|PRINT_NOTHING
case|:
name|source_flag
operator|=
name|SRC_LINE
expr_stmt|;
comment|/* something bogus */
name|do_frame_printing
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Unknown value."
argument_list|)
expr_stmt|;
block|}
comment|/* For mi, have the same behavior every time we stop: 	     print everything but the source line. */
if|if
condition|(
name|ui_out_is_mi_like_p
argument_list|(
name|uiout
argument_list|)
condition|)
name|source_flag
operator|=
name|LOC_AND_ADDRESS
expr_stmt|;
if|if
condition|(
name|ui_out_is_mi_like_p
argument_list|(
name|uiout
argument_list|)
condition|)
name|ui_out_field_int
argument_list|(
name|uiout
argument_list|,
literal|"thread-id"
argument_list|,
name|pid_to_thread_id
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The behavior of this routine with respect to the source 	     flag is: 	     SRC_LINE: Print only source line 	     LOCATION: Print only location 	     SRC_AND_LOC: Print location and source line */
if|if
condition|(
name|do_frame_printing
condition|)
name|print_stack_frame
argument_list|(
name|deprecated_selected_frame
argument_list|,
operator|-
literal|1
argument_list|,
name|source_flag
argument_list|)
expr_stmt|;
comment|/* Display the auto-display expressions.  */
name|do_displays
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Save the function value return registers, if we care.      We might be about to restore their previous contents.  */
if|if
condition|(
name|proceed_to_finish
condition|)
comment|/* NB: The copy goes through to the target picking up the value of        all the registers.  */
name|regcache_cpy
argument_list|(
name|stop_registers
argument_list|,
name|current_regcache
argument_list|)
expr_stmt|;
if|if
condition|(
name|stop_stack_dummy
condition|)
block|{
comment|/* Pop the empty frame that contains the stack dummy.  POP_FRAME          ends with a setting of the current frame, so we can use that          next. */
name|frame_pop
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Set stop_pc to what it was before we called the function.          Can't rely on restore_inferior_status because that only gets          called if we don't stop in the called function.  */
name|stop_pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|done
label|:
name|annotate_stopped
argument_list|()
expr_stmt|;
name|observer_notify_normal_stop
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|hook_stop_stub
parameter_list|(
name|void
modifier|*
name|cmd
parameter_list|)
block|{
name|execute_cmd_pre_hook
argument_list|(
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|)
name|cmd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|int
name|signal_stop_state
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
return|return
name|signal_stop
index|[
name|signo
index|]
return|;
block|}
end_function

begin_function
name|int
name|signal_print_state
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
return|return
name|signal_print
index|[
name|signo
index|]
return|;
block|}
end_function

begin_function
name|int
name|signal_pass_state
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
return|return
name|signal_program
index|[
name|signo
index|]
return|;
block|}
end_function

begin_function
name|int
name|signal_stop_update
parameter_list|(
name|int
name|signo
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|int
name|ret
init|=
name|signal_stop
index|[
name|signo
index|]
decl_stmt|;
name|signal_stop
index|[
name|signo
index|]
operator|=
name|state
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|signal_print_update
parameter_list|(
name|int
name|signo
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|int
name|ret
init|=
name|signal_print
index|[
name|signo
index|]
decl_stmt|;
name|signal_print
index|[
name|signo
index|]
operator|=
name|state
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|signal_pass_update
parameter_list|(
name|int
name|signo
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|int
name|ret
init|=
name|signal_program
index|[
name|signo
index|]
decl_stmt|;
name|signal_program
index|[
name|signo
index|]
operator|=
name|state
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sig_print_header
parameter_list|(
name|void
parameter_list|)
block|{
name|printf_filtered
argument_list|(
literal|"\ Signal        Stop\tPrint\tPass to program\tDescription\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sig_print_info
parameter_list|(
name|enum
name|target_signal
name|oursig
parameter_list|)
block|{
name|char
modifier|*
name|name
init|=
name|target_signal_to_name
argument_list|(
name|oursig
argument_list|)
decl_stmt|;
name|int
name|name_padding
init|=
literal|13
operator|-
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|name_padding
operator|<=
literal|0
condition|)
name|name_padding
operator|=
literal|0
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%*.*s "
argument_list|,
name|name_padding
argument_list|,
name|name_padding
argument_list|,
literal|"                 "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s\t"
argument_list|,
name|signal_stop
index|[
name|oursig
index|]
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s\t"
argument_list|,
name|signal_print
index|[
name|oursig
index|]
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s\t\t"
argument_list|,
name|signal_program
index|[
name|oursig
index|]
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s\n"
argument_list|,
name|target_signal_to_string
argument_list|(
name|oursig
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Specify how various signals in the inferior should be handled.  */
end_comment

begin_function
specifier|static
name|void
name|handle_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|digits
decl_stmt|,
name|wordlen
decl_stmt|;
name|int
name|sigfirst
decl_stmt|,
name|signum
decl_stmt|,
name|siglast
decl_stmt|;
name|enum
name|target_signal
name|oursig
decl_stmt|;
name|int
name|allsigs
decl_stmt|;
name|int
name|nsigs
decl_stmt|;
name|unsigned
name|char
modifier|*
name|sigs
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
block|{
name|error_no_arg
argument_list|(
literal|"signal to handle"
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate and zero an array of flags for which signals to handle. */
name|nsigs
operator|=
operator|(
name|int
operator|)
name|TARGET_SIGNAL_LAST
expr_stmt|;
name|sigs
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|nsigs
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sigs
argument_list|,
literal|0
argument_list|,
name|nsigs
argument_list|)
expr_stmt|;
comment|/* Break the command line up into args. */
name|argv
operator|=
name|buildargv
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
operator|==
name|NULL
condition|)
block|{
name|nomem
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|old_chain
operator|=
name|make_cleanup_freeargv
argument_list|(
name|argv
argument_list|)
expr_stmt|;
comment|/* Walk through the args, looking for signal oursigs, signal names, and      actions.  Signal numbers and signal names may be interspersed with      actions, with the actions being performed for all signals cumulatively      specified.  Signal ranges can be specified as<LOW>-<HIGH>. */
while|while
condition|(
operator|*
name|argv
operator|!=
name|NULL
condition|)
block|{
name|wordlen
operator|=
name|strlen
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
for|for
control|(
name|digits
operator|=
literal|0
init|;
name|isdigit
argument_list|(
operator|(
operator|*
name|argv
operator|)
index|[
name|digits
index|]
argument_list|)
condition|;
name|digits
operator|++
control|)
block|{
empty_stmt|;
block|}
name|allsigs
operator|=
literal|0
expr_stmt|;
name|sigfirst
operator|=
name|siglast
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|wordlen
operator|>=
literal|1
operator|&&
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"all"
argument_list|,
name|wordlen
argument_list|)
condition|)
block|{
comment|/* Apply action to all signals except those used by the 	     debugger.  Silently skip those. */
name|allsigs
operator|=
literal|1
expr_stmt|;
name|sigfirst
operator|=
literal|0
expr_stmt|;
name|siglast
operator|=
name|nsigs
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wordlen
operator|>=
literal|1
operator|&&
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"stop"
argument_list|,
name|wordlen
argument_list|)
condition|)
block|{
name|SET_SIGS
argument_list|(
name|nsigs
argument_list|,
name|sigs
argument_list|,
name|signal_stop
argument_list|)
expr_stmt|;
name|SET_SIGS
argument_list|(
name|nsigs
argument_list|,
name|sigs
argument_list|,
name|signal_print
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wordlen
operator|>=
literal|1
operator|&&
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"ignore"
argument_list|,
name|wordlen
argument_list|)
condition|)
block|{
name|UNSET_SIGS
argument_list|(
name|nsigs
argument_list|,
name|sigs
argument_list|,
name|signal_program
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wordlen
operator|>=
literal|2
operator|&&
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"print"
argument_list|,
name|wordlen
argument_list|)
condition|)
block|{
name|SET_SIGS
argument_list|(
name|nsigs
argument_list|,
name|sigs
argument_list|,
name|signal_print
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wordlen
operator|>=
literal|2
operator|&&
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"pass"
argument_list|,
name|wordlen
argument_list|)
condition|)
block|{
name|SET_SIGS
argument_list|(
name|nsigs
argument_list|,
name|sigs
argument_list|,
name|signal_program
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wordlen
operator|>=
literal|3
operator|&&
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"nostop"
argument_list|,
name|wordlen
argument_list|)
condition|)
block|{
name|UNSET_SIGS
argument_list|(
name|nsigs
argument_list|,
name|sigs
argument_list|,
name|signal_stop
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wordlen
operator|>=
literal|3
operator|&&
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"noignore"
argument_list|,
name|wordlen
argument_list|)
condition|)
block|{
name|SET_SIGS
argument_list|(
name|nsigs
argument_list|,
name|sigs
argument_list|,
name|signal_program
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wordlen
operator|>=
literal|4
operator|&&
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"noprint"
argument_list|,
name|wordlen
argument_list|)
condition|)
block|{
name|UNSET_SIGS
argument_list|(
name|nsigs
argument_list|,
name|sigs
argument_list|,
name|signal_print
argument_list|)
expr_stmt|;
name|UNSET_SIGS
argument_list|(
name|nsigs
argument_list|,
name|sigs
argument_list|,
name|signal_stop
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wordlen
operator|>=
literal|4
operator|&&
operator|!
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"nopass"
argument_list|,
name|wordlen
argument_list|)
condition|)
block|{
name|UNSET_SIGS
argument_list|(
name|nsigs
argument_list|,
name|sigs
argument_list|,
name|signal_program
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|digits
operator|>
literal|0
condition|)
block|{
comment|/* It is numeric.  The numeric signal refers to our own 	     internal signal numbering from target.h, not to host/target 	     signal  number.  This is a feature; users really should be 	     using symbolic names anyway, and the common ones like 	     SIGHUP, SIGINT, SIGALRM, etc. will work right anyway.  */
name|sigfirst
operator|=
name|siglast
operator|=
operator|(
name|int
operator|)
name|target_signal_from_command
argument_list|(
name|atoi
argument_list|(
operator|*
name|argv
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|argv
operator|)
index|[
name|digits
index|]
operator|==
literal|'-'
condition|)
block|{
name|siglast
operator|=
operator|(
name|int
operator|)
name|target_signal_from_command
argument_list|(
name|atoi
argument_list|(
operator|(
operator|*
name|argv
operator|)
operator|+
name|digits
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sigfirst
operator|>
name|siglast
condition|)
block|{
comment|/* Bet he didn't figure we'd think of this case... */
name|signum
operator|=
name|sigfirst
expr_stmt|;
name|sigfirst
operator|=
name|siglast
expr_stmt|;
name|siglast
operator|=
name|signum
expr_stmt|;
block|}
block|}
else|else
block|{
name|oursig
operator|=
name|target_signal_from_name
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|oursig
operator|!=
name|TARGET_SIGNAL_UNKNOWN
condition|)
block|{
name|sigfirst
operator|=
name|siglast
operator|=
operator|(
name|int
operator|)
name|oursig
expr_stmt|;
block|}
else|else
block|{
comment|/* Not a number and not a recognized flag word => complain.  */
name|error
argument_list|(
literal|"Unrecognized or ambiguous flag word: \"%s\"."
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If any signal numbers or symbol names were found, set flags for          which signals to apply actions to. */
for|for
control|(
name|signum
operator|=
name|sigfirst
init|;
name|signum
operator|>=
literal|0
operator|&&
name|signum
operator|<=
name|siglast
condition|;
name|signum
operator|++
control|)
block|{
switch|switch
condition|(
operator|(
expr|enum
name|target_signal
operator|)
name|signum
condition|)
block|{
case|case
name|TARGET_SIGNAL_TRAP
case|:
case|case
name|TARGET_SIGNAL_INT
case|:
if|if
condition|(
operator|!
name|allsigs
operator|&&
operator|!
name|sigs
index|[
name|signum
index|]
condition|)
block|{
if|if
condition|(
name|query
argument_list|(
literal|"%s is used by the debugger.\n\ Are you sure you want to change it? "
argument_list|,
name|target_signal_to_name
argument_list|(
operator|(
expr|enum
name|target_signal
operator|)
name|signum
argument_list|)
argument_list|)
condition|)
block|{
name|sigs
index|[
name|signum
index|]
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|printf_unfiltered
argument_list|(
literal|"Not confirmed, unchanged.\n"
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TARGET_SIGNAL_0
case|:
case|case
name|TARGET_SIGNAL_DEFAULT
case|:
case|case
name|TARGET_SIGNAL_UNKNOWN
case|:
comment|/* Make sure that "all" doesn't print these.  */
break|break;
default|default:
name|sigs
index|[
name|signum
index|]
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|argv
operator|++
expr_stmt|;
block|}
name|target_notice_signals
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
comment|/* Show the results.  */
name|sig_print_header
argument_list|()
expr_stmt|;
for|for
control|(
name|signum
operator|=
literal|0
init|;
name|signum
operator|<
name|nsigs
condition|;
name|signum
operator|++
control|)
block|{
if|if
condition|(
name|sigs
index|[
name|signum
index|]
condition|)
block|{
name|sig_print_info
argument_list|(
name|signum
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|xdb_handle_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
comment|/* Break the command line up into args. */
name|argv
operator|=
name|buildargv
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
operator|==
name|NULL
condition|)
block|{
name|nomem
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|old_chain
operator|=
name|make_cleanup_freeargv
argument_list|(
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
index|[
literal|1
index|]
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
block|{
name|char
modifier|*
name|argBuf
decl_stmt|;
name|int
name|bufLen
decl_stmt|;
name|bufLen
operator|=
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
operator|+
literal|20
expr_stmt|;
name|argBuf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|bufLen
argument_list|)
expr_stmt|;
if|if
condition|(
name|argBuf
condition|)
block|{
name|int
name|validFlag
init|=
literal|1
decl_stmt|;
name|enum
name|target_signal
name|oursig
decl_stmt|;
name|oursig
operator|=
name|target_signal_from_name
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|argBuf
argument_list|,
literal|0
argument_list|,
name|bufLen
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"Q"
argument_list|)
operator|==
literal|0
condition|)
name|sprintf
argument_list|(
name|argBuf
argument_list|,
literal|"%s %s"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"noprint"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"s"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|signal_stop
index|[
name|oursig
index|]
condition|)
name|sprintf
argument_list|(
name|argBuf
argument_list|,
literal|"%s %s"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"stop"
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|argBuf
argument_list|,
literal|"%s %s"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"nostop"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"i"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|signal_program
index|[
name|oursig
index|]
condition|)
name|sprintf
argument_list|(
name|argBuf
argument_list|,
literal|"%s %s"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"pass"
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|argBuf
argument_list|,
literal|"%s %s"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"nopass"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"r"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|signal_print
index|[
name|oursig
index|]
condition|)
name|sprintf
argument_list|(
name|argBuf
argument_list|,
literal|"%s %s"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"print"
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|argBuf
argument_list|,
literal|"%s %s"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"noprint"
argument_list|)
expr_stmt|;
block|}
else|else
name|validFlag
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|validFlag
condition|)
name|handle_command
argument_list|(
name|argBuf
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"Invalid signal handling flag.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|argBuf
condition|)
name|xfree
argument_list|(
name|argBuf
argument_list|)
expr_stmt|;
block|}
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print current contents of the tables set by the handle command.    It is possible we should just be printing signals actually used    by the current target (but for things to work right when switching    targets, all signals should be in the signal tables).  */
end_comment

begin_function
specifier|static
name|void
name|signals_info
parameter_list|(
name|char
modifier|*
name|signum_exp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|enum
name|target_signal
name|oursig
decl_stmt|;
name|sig_print_header
argument_list|()
expr_stmt|;
if|if
condition|(
name|signum_exp
condition|)
block|{
comment|/* First see if this is a symbol name.  */
name|oursig
operator|=
name|target_signal_from_name
argument_list|(
name|signum_exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|oursig
operator|==
name|TARGET_SIGNAL_UNKNOWN
condition|)
block|{
comment|/* No, try numeric.  */
name|oursig
operator|=
name|target_signal_from_command
argument_list|(
name|parse_and_eval_long
argument_list|(
name|signum_exp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sig_print_info
argument_list|(
name|oursig
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* These ugly casts brought to you by the native VAX compiler.  */
for|for
control|(
name|oursig
operator|=
name|TARGET_SIGNAL_FIRST
init|;
operator|(
name|int
operator|)
name|oursig
operator|<
operator|(
name|int
operator|)
name|TARGET_SIGNAL_LAST
condition|;
name|oursig
operator|=
operator|(
expr|enum
name|target_signal
operator|)
operator|(
operator|(
name|int
operator|)
name|oursig
operator|+
literal|1
operator|)
control|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|oursig
operator|!=
name|TARGET_SIGNAL_UNKNOWN
operator|&&
name|oursig
operator|!=
name|TARGET_SIGNAL_DEFAULT
operator|&&
name|oursig
operator|!=
name|TARGET_SIGNAL_0
condition|)
name|sig_print_info
argument_list|(
name|oursig
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"\nUse the \"handle\" command to change these tables.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_struct
struct|struct
name|inferior_status
block|{
name|enum
name|target_signal
name|stop_signal
decl_stmt|;
name|CORE_ADDR
name|stop_pc
decl_stmt|;
name|bpstat
name|stop_bpstat
decl_stmt|;
name|int
name|stop_step
decl_stmt|;
name|int
name|stop_stack_dummy
decl_stmt|;
name|int
name|stopped_by_random_signal
decl_stmt|;
name|int
name|trap_expected
decl_stmt|;
name|CORE_ADDR
name|step_range_start
decl_stmt|;
name|CORE_ADDR
name|step_range_end
decl_stmt|;
name|struct
name|frame_id
name|step_frame_id
decl_stmt|;
name|enum
name|step_over_calls_kind
name|step_over_calls
decl_stmt|;
name|CORE_ADDR
name|step_resume_break_address
decl_stmt|;
name|int
name|stop_after_trap
decl_stmt|;
name|int
name|stop_soon
decl_stmt|;
name|struct
name|regcache
modifier|*
name|stop_registers
decl_stmt|;
comment|/* These are here because if call_function_by_hand has written some      registers and then decides to call error(), we better not have changed      any registers.  */
name|struct
name|regcache
modifier|*
name|registers
decl_stmt|;
comment|/* A frame unique identifier.  */
name|struct
name|frame_id
name|selected_frame_id
decl_stmt|;
name|int
name|breakpoint_proceeded
decl_stmt|;
name|int
name|restore_stack_info
decl_stmt|;
name|int
name|proceed_to_finish
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|void
name|write_inferior_status_register
parameter_list|(
name|struct
name|inferior_status
modifier|*
name|inf_status
parameter_list|,
name|int
name|regno
parameter_list|,
name|LONGEST
name|val
parameter_list|)
block|{
name|int
name|size
init|=
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
decl_stmt|;
name|void
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|store_signed_integer
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|regcache_raw_write
argument_list|(
name|inf_status
operator|->
name|registers
argument_list|,
name|regno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Save all of the information associated with the inferior<==>gdb    connection.  INF_STATUS is a pointer to a "struct inferior_status"    (defined in inferior.h).  */
end_comment

begin_function
name|struct
name|inferior_status
modifier|*
name|save_inferior_status
parameter_list|(
name|int
name|restore_stack_info
parameter_list|)
block|{
name|struct
name|inferior_status
modifier|*
name|inf_status
init|=
name|XMALLOC
argument_list|(
expr|struct
name|inferior_status
argument_list|)
decl_stmt|;
name|inf_status
operator|->
name|stop_signal
operator|=
name|stop_signal
expr_stmt|;
name|inf_status
operator|->
name|stop_pc
operator|=
name|stop_pc
expr_stmt|;
name|inf_status
operator|->
name|stop_step
operator|=
name|stop_step
expr_stmt|;
name|inf_status
operator|->
name|stop_stack_dummy
operator|=
name|stop_stack_dummy
expr_stmt|;
name|inf_status
operator|->
name|stopped_by_random_signal
operator|=
name|stopped_by_random_signal
expr_stmt|;
name|inf_status
operator|->
name|trap_expected
operator|=
name|trap_expected
expr_stmt|;
name|inf_status
operator|->
name|step_range_start
operator|=
name|step_range_start
expr_stmt|;
name|inf_status
operator|->
name|step_range_end
operator|=
name|step_range_end
expr_stmt|;
name|inf_status
operator|->
name|step_frame_id
operator|=
name|step_frame_id
expr_stmt|;
name|inf_status
operator|->
name|step_over_calls
operator|=
name|step_over_calls
expr_stmt|;
name|inf_status
operator|->
name|stop_after_trap
operator|=
name|stop_after_trap
expr_stmt|;
name|inf_status
operator|->
name|stop_soon
operator|=
name|stop_soon
expr_stmt|;
comment|/* Save original bpstat chain here; replace it with copy of chain.      If caller's caller is walking the chain, they'll be happier if we      hand them back the original chain when restore_inferior_status is      called.  */
name|inf_status
operator|->
name|stop_bpstat
operator|=
name|stop_bpstat
expr_stmt|;
name|stop_bpstat
operator|=
name|bpstat_copy
argument_list|(
name|stop_bpstat
argument_list|)
expr_stmt|;
name|inf_status
operator|->
name|breakpoint_proceeded
operator|=
name|breakpoint_proceeded
expr_stmt|;
name|inf_status
operator|->
name|restore_stack_info
operator|=
name|restore_stack_info
expr_stmt|;
name|inf_status
operator|->
name|proceed_to_finish
operator|=
name|proceed_to_finish
expr_stmt|;
name|inf_status
operator|->
name|stop_registers
operator|=
name|regcache_dup_no_passthrough
argument_list|(
name|stop_registers
argument_list|)
expr_stmt|;
name|inf_status
operator|->
name|registers
operator|=
name|regcache_dup
argument_list|(
name|current_regcache
argument_list|)
expr_stmt|;
name|inf_status
operator|->
name|selected_frame_id
operator|=
name|get_frame_id
argument_list|(
name|deprecated_selected_frame
argument_list|)
expr_stmt|;
return|return
name|inf_status
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|restore_selected_frame
parameter_list|(
name|void
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|frame_id
modifier|*
name|fid
init|=
operator|(
expr|struct
name|frame_id
operator|*
operator|)
name|args
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
name|frame
operator|=
name|frame_find_by_id
argument_list|(
operator|*
name|fid
argument_list|)
expr_stmt|;
comment|/* If inf_status->selected_frame_id is NULL, there was no previously      selected frame.  */
if|if
condition|(
name|frame
operator|==
name|NULL
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to restore previously selected frame.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|select_frame
argument_list|(
name|frame
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|restore_inferior_status
parameter_list|(
name|struct
name|inferior_status
modifier|*
name|inf_status
parameter_list|)
block|{
name|stop_signal
operator|=
name|inf_status
operator|->
name|stop_signal
expr_stmt|;
name|stop_pc
operator|=
name|inf_status
operator|->
name|stop_pc
expr_stmt|;
name|stop_step
operator|=
name|inf_status
operator|->
name|stop_step
expr_stmt|;
name|stop_stack_dummy
operator|=
name|inf_status
operator|->
name|stop_stack_dummy
expr_stmt|;
name|stopped_by_random_signal
operator|=
name|inf_status
operator|->
name|stopped_by_random_signal
expr_stmt|;
name|trap_expected
operator|=
name|inf_status
operator|->
name|trap_expected
expr_stmt|;
name|step_range_start
operator|=
name|inf_status
operator|->
name|step_range_start
expr_stmt|;
name|step_range_end
operator|=
name|inf_status
operator|->
name|step_range_end
expr_stmt|;
name|step_frame_id
operator|=
name|inf_status
operator|->
name|step_frame_id
expr_stmt|;
name|step_over_calls
operator|=
name|inf_status
operator|->
name|step_over_calls
expr_stmt|;
name|stop_after_trap
operator|=
name|inf_status
operator|->
name|stop_after_trap
expr_stmt|;
name|stop_soon
operator|=
name|inf_status
operator|->
name|stop_soon
expr_stmt|;
name|bpstat_clear
argument_list|(
operator|&
name|stop_bpstat
argument_list|)
expr_stmt|;
name|stop_bpstat
operator|=
name|inf_status
operator|->
name|stop_bpstat
expr_stmt|;
name|breakpoint_proceeded
operator|=
name|inf_status
operator|->
name|breakpoint_proceeded
expr_stmt|;
name|proceed_to_finish
operator|=
name|inf_status
operator|->
name|proceed_to_finish
expr_stmt|;
comment|/* FIXME: Is the restore of stop_registers always needed. */
name|regcache_xfree
argument_list|(
name|stop_registers
argument_list|)
expr_stmt|;
name|stop_registers
operator|=
name|inf_status
operator|->
name|stop_registers
expr_stmt|;
comment|/* The inferior can be gone if the user types "print exit(0)"      (and perhaps other times).  */
if|if
condition|(
name|target_has_execution
condition|)
comment|/* NB: The register write goes through to the target.  */
name|regcache_cpy
argument_list|(
name|current_regcache
argument_list|,
name|inf_status
operator|->
name|registers
argument_list|)
expr_stmt|;
name|regcache_xfree
argument_list|(
name|inf_status
operator|->
name|registers
argument_list|)
expr_stmt|;
comment|/* FIXME: If we are being called after stopping in a function which      is called from gdb, we should not be trying to restore the      selected frame; it just prints a spurious error message (The      message is useful, however, in detecting bugs in gdb (like if gdb      clobbers the stack)).  In fact, should we be restoring the      inferior status at all in that case?  .  */
if|if
condition|(
name|target_has_stack
operator|&&
name|inf_status
operator|->
name|restore_stack_info
condition|)
block|{
comment|/* The point of catch_errors is that if the stack is clobbered,          walking the stack might encounter a garbage pointer and          error() trying to dereference it.  */
if|if
condition|(
name|catch_errors
argument_list|(
name|restore_selected_frame
argument_list|,
operator|&
name|inf_status
operator|->
name|selected_frame_id
argument_list|,
literal|"Unable to restore previously selected frame:\n"
argument_list|,
name|RETURN_MASK_ERROR
argument_list|)
operator|==
literal|0
condition|)
comment|/* Error in restoring the selected frame.  Select the innermost 	   frame.  */
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|xfree
argument_list|(
name|inf_status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_restore_inferior_status_cleanup
parameter_list|(
name|void
modifier|*
name|sts
parameter_list|)
block|{
name|restore_inferior_status
argument_list|(
name|sts
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|cleanup
modifier|*
name|make_cleanup_restore_inferior_status
parameter_list|(
name|struct
name|inferior_status
modifier|*
name|inf_status
parameter_list|)
block|{
return|return
name|make_cleanup
argument_list|(
name|do_restore_inferior_status_cleanup
argument_list|,
name|inf_status
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|discard_inferior_status
parameter_list|(
name|struct
name|inferior_status
modifier|*
name|inf_status
parameter_list|)
block|{
comment|/* See save_inferior_status for info on stop_bpstat. */
name|bpstat_clear
argument_list|(
operator|&
name|inf_status
operator|->
name|stop_bpstat
argument_list|)
expr_stmt|;
name|regcache_xfree
argument_list|(
name|inf_status
operator|->
name|registers
argument_list|)
expr_stmt|;
name|regcache_xfree
argument_list|(
name|inf_status
operator|->
name|stop_registers
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|inf_status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|inferior_has_forked
parameter_list|(
name|int
name|pid
parameter_list|,
name|int
modifier|*
name|child_pid
parameter_list|)
block|{
name|struct
name|target_waitstatus
name|last
decl_stmt|;
name|ptid_t
name|last_ptid
decl_stmt|;
name|get_last_target_status
argument_list|(
operator|&
name|last_ptid
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
operator|.
name|kind
operator|!=
name|TARGET_WAITKIND_FORKED
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ptid_get_pid
argument_list|(
name|last_ptid
argument_list|)
operator|!=
name|pid
condition|)
return|return
literal|0
return|;
operator|*
name|child_pid
operator|=
name|last
operator|.
name|value
operator|.
name|related_pid
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|inferior_has_vforked
parameter_list|(
name|int
name|pid
parameter_list|,
name|int
modifier|*
name|child_pid
parameter_list|)
block|{
name|struct
name|target_waitstatus
name|last
decl_stmt|;
name|ptid_t
name|last_ptid
decl_stmt|;
name|get_last_target_status
argument_list|(
operator|&
name|last_ptid
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
operator|.
name|kind
operator|!=
name|TARGET_WAITKIND_VFORKED
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ptid_get_pid
argument_list|(
name|last_ptid
argument_list|)
operator|!=
name|pid
condition|)
return|return
literal|0
return|;
operator|*
name|child_pid
operator|=
name|last
operator|.
name|value
operator|.
name|related_pid
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|inferior_has_execd
parameter_list|(
name|int
name|pid
parameter_list|,
name|char
modifier|*
modifier|*
name|execd_pathname
parameter_list|)
block|{
name|struct
name|target_waitstatus
name|last
decl_stmt|;
name|ptid_t
name|last_ptid
decl_stmt|;
name|get_last_target_status
argument_list|(
operator|&
name|last_ptid
argument_list|,
operator|&
name|last
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
operator|.
name|kind
operator|!=
name|TARGET_WAITKIND_EXECD
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ptid_get_pid
argument_list|(
name|last_ptid
argument_list|)
operator|!=
name|pid
condition|)
return|return
literal|0
return|;
operator|*
name|execd_pathname
operator|=
name|xstrdup
argument_list|(
name|last
operator|.
name|value
operator|.
name|execd_pathname
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Oft used ptids */
end_comment

begin_decl_stmt
name|ptid_t
name|null_ptid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ptid_t
name|minus_one_ptid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Create a ptid given the necessary PID, LWP, and TID components.  */
end_comment

begin_function
name|ptid_t
name|ptid_build
parameter_list|(
name|int
name|pid
parameter_list|,
name|long
name|lwp
parameter_list|,
name|long
name|tid
parameter_list|)
block|{
name|ptid_t
name|ptid
decl_stmt|;
name|ptid
operator|.
name|pid
operator|=
name|pid
expr_stmt|;
name|ptid
operator|.
name|lwp
operator|=
name|lwp
expr_stmt|;
name|ptid
operator|.
name|tid
operator|=
name|tid
expr_stmt|;
return|return
name|ptid
return|;
block|}
end_function

begin_comment
comment|/* Create a ptid from just a pid.  */
end_comment

begin_function
name|ptid_t
name|pid_to_ptid
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
return|return
name|ptid_build
argument_list|(
name|pid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Fetch the pid (process id) component from a ptid.  */
end_comment

begin_function
name|int
name|ptid_get_pid
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
return|return
name|ptid
operator|.
name|pid
return|;
block|}
end_function

begin_comment
comment|/* Fetch the lwp (lightweight process) component from a ptid.  */
end_comment

begin_function
name|long
name|ptid_get_lwp
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
return|return
name|ptid
operator|.
name|lwp
return|;
block|}
end_function

begin_comment
comment|/* Fetch the tid (thread id) component from a ptid.  */
end_comment

begin_function
name|long
name|ptid_get_tid
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
return|return
name|ptid
operator|.
name|tid
return|;
block|}
end_function

begin_comment
comment|/* ptid_equal() is used to test equality of two ptids.  */
end_comment

begin_function
name|int
name|ptid_equal
parameter_list|(
name|ptid_t
name|ptid1
parameter_list|,
name|ptid_t
name|ptid2
parameter_list|)
block|{
return|return
operator|(
name|ptid1
operator|.
name|pid
operator|==
name|ptid2
operator|.
name|pid
operator|&&
name|ptid1
operator|.
name|lwp
operator|==
name|ptid2
operator|.
name|lwp
operator|&&
name|ptid1
operator|.
name|tid
operator|==
name|ptid2
operator|.
name|tid
operator|)
return|;
block|}
end_function

begin_comment
comment|/* restore_inferior_ptid() will be used by the cleanup machinery    to restore the inferior_ptid value saved in a call to    save_inferior_ptid().  */
end_comment

begin_function
specifier|static
name|void
name|restore_inferior_ptid
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|ptid_t
modifier|*
name|saved_ptid_ptr
init|=
name|arg
decl_stmt|;
name|inferior_ptid
operator|=
operator|*
name|saved_ptid_ptr
expr_stmt|;
name|xfree
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Save the value of inferior_ptid so that it may be restored by a    later call to do_cleanups().  Returns the struct cleanup pointer    needed for later doing the cleanup.  */
end_comment

begin_function
name|struct
name|cleanup
modifier|*
name|save_inferior_ptid
parameter_list|(
name|void
parameter_list|)
block|{
name|ptid_t
modifier|*
name|saved_ptid_ptr
decl_stmt|;
name|saved_ptid_ptr
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ptid_t
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|saved_ptid_ptr
operator|=
name|inferior_ptid
expr_stmt|;
return|return
name|make_cleanup
argument_list|(
name|restore_inferior_ptid
argument_list|,
name|saved_ptid_ptr
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|build_infrun
parameter_list|(
name|void
parameter_list|)
block|{
name|stop_registers
operator|=
name|regcache_xmalloc
argument_list|(
name|current_gdbarch
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_infrun
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|numsigs
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|stop_registers
argument_list|)
expr_stmt|;
name|deprecated_register_gdbarch_swap
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|build_infrun
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"signals"
argument_list|,
name|signals_info
argument_list|,
literal|"What debugger does when program gets various signals.\n\ Specify a signal as argument to print info on that signal only."
argument_list|)
expr_stmt|;
name|add_info_alias
argument_list|(
literal|"handle"
argument_list|,
literal|"signals"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"handle"
argument_list|,
name|class_run
argument_list|,
name|handle_command
argument_list|,
name|concat
argument_list|(
literal|"Specify how to handle a signal.\n\ Args are signals and actions to apply to those signals.\n\ Symbolic signals (e.g. SIGSEGV) are recommended but numeric signals\n\ from 1-15 are allowed for compatibility with old versions of GDB.\n\ Numeric ranges may be specified with the form LOW-HIGH (e.g. 1-5).\n\ The special arg \"all\" is recognized to mean all signals except those\n\ used by the debugger, typically SIGTRAP and SIGINT.\n"
argument_list|,
literal|"Recognized actions include \"stop\", \"nostop\", \"print\", \"noprint\",\n\ \"pass\", \"nopass\", \"ignore\", or \"noignore\".\n\ Stop means reenter debugger if this signal happens (implies print).\n\ Print means print a message if this signal happens.\n\ Pass means let program see this signal; otherwise program doesn't know.\n\ Ignore is a synonym for nopass and noignore is a synonym for pass.\n\ Pass and Stop may be combined."
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdb_commands
condition|)
block|{
name|add_com
argument_list|(
literal|"lz"
argument_list|,
name|class_info
argument_list|,
name|signals_info
argument_list|,
literal|"What debugger does when program gets various signals.\n\ Specify a signal as argument to print info on that signal only."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"z"
argument_list|,
name|class_run
argument_list|,
name|xdb_handle_command
argument_list|,
name|concat
argument_list|(
literal|"Specify how to handle a signal.\n\ Args are signals and actions to apply to those signals.\n\ Symbolic signals (e.g. SIGSEGV) are recommended but numeric signals\n\ from 1-15 are allowed for compatibility with old versions of GDB.\n\ Numeric ranges may be specified with the form LOW-HIGH (e.g. 1-5).\n\ The special arg \"all\" is recognized to mean all signals except those\n\ used by the debugger, typically SIGTRAP and SIGINT.\n"
argument_list|,
literal|"Recognized actions include \"s\" (toggles between stop and nostop), \n\ \"r\" (toggles between print and noprint), \"i\" (toggles between pass and \ nopass), \"Q\" (noprint)\n\ Stop means reenter debugger if this signal happens (implies print).\n\ Print means print a message if this signal happens.\n\ Pass means let program see this signal; otherwise program doesn't know.\n\ Ignore is a synonym for nopass and noignore is a synonym for pass.\n\ Pass and Stop may be combined."
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dbx_commands
condition|)
name|stop_command
operator|=
name|add_cmd
argument_list|(
literal|"stop"
argument_list|,
name|class_obscure
argument_list|,
name|not_just_help_class_command
argument_list|,
literal|"There is no `stop' command, but you can set a hook on `stop'.\n\ This allows you to set a list of commands to be run each time execution\n\ of the program stops."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|numsigs
operator|=
operator|(
name|int
operator|)
name|TARGET_SIGNAL_LAST
expr_stmt|;
name|signal_stop
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|signal_stop
index|[
literal|0
index|]
argument_list|)
operator|*
name|numsigs
argument_list|)
expr_stmt|;
name|signal_print
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|signal_print
index|[
literal|0
index|]
argument_list|)
operator|*
name|numsigs
argument_list|)
expr_stmt|;
name|signal_program
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|signal_program
index|[
literal|0
index|]
argument_list|)
operator|*
name|numsigs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numsigs
condition|;
name|i
operator|++
control|)
block|{
name|signal_stop
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|signal_print
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|signal_program
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Signals caused by debugger's own actions      should not be given to the program afterwards.  */
name|signal_program
index|[
name|TARGET_SIGNAL_TRAP
index|]
operator|=
literal|0
expr_stmt|;
name|signal_program
index|[
name|TARGET_SIGNAL_INT
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Signals that are not errors should not normally enter the debugger.  */
name|signal_stop
index|[
name|TARGET_SIGNAL_ALRM
index|]
operator|=
literal|0
expr_stmt|;
name|signal_print
index|[
name|TARGET_SIGNAL_ALRM
index|]
operator|=
literal|0
expr_stmt|;
name|signal_stop
index|[
name|TARGET_SIGNAL_VTALRM
index|]
operator|=
literal|0
expr_stmt|;
name|signal_print
index|[
name|TARGET_SIGNAL_VTALRM
index|]
operator|=
literal|0
expr_stmt|;
name|signal_stop
index|[
name|TARGET_SIGNAL_PROF
index|]
operator|=
literal|0
expr_stmt|;
name|signal_print
index|[
name|TARGET_SIGNAL_PROF
index|]
operator|=
literal|0
expr_stmt|;
name|signal_stop
index|[
name|TARGET_SIGNAL_CHLD
index|]
operator|=
literal|0
expr_stmt|;
name|signal_print
index|[
name|TARGET_SIGNAL_CHLD
index|]
operator|=
literal|0
expr_stmt|;
name|signal_stop
index|[
name|TARGET_SIGNAL_IO
index|]
operator|=
literal|0
expr_stmt|;
name|signal_print
index|[
name|TARGET_SIGNAL_IO
index|]
operator|=
literal|0
expr_stmt|;
name|signal_stop
index|[
name|TARGET_SIGNAL_POLL
index|]
operator|=
literal|0
expr_stmt|;
name|signal_print
index|[
name|TARGET_SIGNAL_POLL
index|]
operator|=
literal|0
expr_stmt|;
name|signal_stop
index|[
name|TARGET_SIGNAL_URG
index|]
operator|=
literal|0
expr_stmt|;
name|signal_print
index|[
name|TARGET_SIGNAL_URG
index|]
operator|=
literal|0
expr_stmt|;
name|signal_stop
index|[
name|TARGET_SIGNAL_WINCH
index|]
operator|=
literal|0
expr_stmt|;
name|signal_print
index|[
name|TARGET_SIGNAL_WINCH
index|]
operator|=
literal|0
expr_stmt|;
comment|/* These signals are used internally by user-level thread      implementations.  (See signal(5) on Solaris.)  Like the above      signals, a healthy program receives and handles them as part of      its normal operation.  */
name|signal_stop
index|[
name|TARGET_SIGNAL_LWP
index|]
operator|=
literal|0
expr_stmt|;
name|signal_print
index|[
name|TARGET_SIGNAL_LWP
index|]
operator|=
literal|0
expr_stmt|;
name|signal_stop
index|[
name|TARGET_SIGNAL_WAITING
index|]
operator|=
literal|0
expr_stmt|;
name|signal_print
index|[
name|TARGET_SIGNAL_WAITING
index|]
operator|=
literal|0
expr_stmt|;
name|signal_stop
index|[
name|TARGET_SIGNAL_CANCEL
index|]
operator|=
literal|0
expr_stmt|;
name|signal_print
index|[
name|TARGET_SIGNAL_CANCEL
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SOLIB_ADD
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"stop-on-solib-events"
argument_list|,
name|class_support
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|stop_on_solib_events
argument_list|,
literal|"Set stopping for shared library events.\n\ If nonzero, gdb will give control to the user when the dynamic linker\n\ notifies gdb of shared library events.  The most common event of interest\n\ to the user would be loading/unloading of a new library.\n"
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|c
operator|=
name|add_set_enum_cmd
argument_list|(
literal|"follow-fork-mode"
argument_list|,
name|class_run
argument_list|,
name|follow_fork_mode_kind_names
argument_list|,
operator|&
name|follow_fork_mode_string
argument_list|,
literal|"Set debugger response to a program call of fork \ or vfork.\n\ A fork or vfork creates a new process.  follow-fork-mode can be:\n\   parent  - the original process is debugged after a fork\n\   child   - the new process is debugged after a fork\n\ The unfollowed process will continue to run.\n\ By default, the debugger will follow the parent process."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_set_enum_cmd
argument_list|(
literal|"scheduler-locking"
argument_list|,
name|class_run
argument_list|,
name|scheduler_enums
argument_list|,
comment|/* array of string names */
operator|&
name|scheduler_mode
argument_list|,
comment|/* current mode  */
literal|"Set mode for locking scheduler during execution.\n\ off  == no locking (threads may preempt at any time)\n\ on   == full locking (no thread except the current thread may run)\n\ step == scheduler locked during every single-step operation.\n\ 	In this mode, no other thread may run during a step command.\n\ 	Other threads may run while stepping over a function call ('next')."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|set_cmd_sfunc
argument_list|(
name|c
argument_list|,
name|set_schedlock_func
argument_list|)
expr_stmt|;
comment|/* traps on target vector */
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"step-mode"
argument_list|,
name|class_run
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|step_stop_if_no_debug
argument_list|,
literal|"Set mode of the step operation. When set, doing a step over a\n\ function without debug line information will stop at the first\n\ instruction of that function. Otherwise, the function is skipped and\n\ the step command stops at a different source line."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
comment|/* ptid initializations */
name|null_ptid
operator|=
name|ptid_build
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|minus_one_ptid
operator|=
name|ptid_build
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|inferior_ptid
operator|=
name|null_ptid
expr_stmt|;
name|target_last_wait_ptid
operator|=
name|minus_one_ptid
expr_stmt|;
block|}
end_function

end_unit

