begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle OSF/1, Digital UNIX, and Tru64 shared libraries    for GDB, the GNU Debugger.    Copyright 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* When handling shared libraries, GDB has to find out the pathnames    of all shared libraries that are currently loaded (to read in their    symbols) and where the shared libraries are loaded in memory    (to relocate them properly from their prelinked addresses to the    current load address).     Under OSF/1 there are two possibilities to get at this information:     1) Peek around in the runtime loader structures.    These are not documented, and they are not defined in the system    header files. The definitions below were obtained by experimentation,    but they seem stable enough.     2) Use the libxproc.a library, which contains the equivalent ldr_*    routines.  The library is documented in Tru64 5.x, but as of 5.1, it    only allows a process to examine itself.  On earlier versions, it    may require that the GDB executable be dynamically linked and that    NAT_CLIBS include -lxproc -Wl,-expect_unresolved,ldr_process_context    for GDB and all applications that are using libgdb.     We will use the peeking approach until libxproc.a works for other    processes.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"solist.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USE_LDR_ROUTINES
end_ifdef

begin_include
include|#
directive|include
file|<loader.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|USE_LDR_ROUTINES
end_ifndef

begin_comment
comment|/* Definition of runtime loader structures, found by experimentation.  */
end_comment

begin_define
define|#
directive|define
name|RLD_CONTEXT_ADDRESS
value|0x3ffc0000000
end_define

begin_comment
comment|/* Per-module information structure referenced by ldr_context_t.head.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|CORE_ADDR
name|next
decl_stmt|;
name|CORE_ADDR
name|previous
decl_stmt|;
name|CORE_ADDR
name|unknown1
decl_stmt|;
name|CORE_ADDR
name|module_name
decl_stmt|;
name|CORE_ADDR
name|modinfo_addr
decl_stmt|;
comment|/* used by next_link_map_member() to detect 				   the end of the shared module list */
name|long
name|module_id
decl_stmt|;
name|CORE_ADDR
name|unknown2
decl_stmt|;
name|CORE_ADDR
name|unknown3
decl_stmt|;
name|long
name|region_count
decl_stmt|;
name|CORE_ADDR
name|regioninfo_addr
decl_stmt|;
block|}
name|ldr_module_info_t
typedef|;
end_typedef

begin_comment
comment|/* Per-region structure referenced by ldr_module_info_t.regioninfo_addr.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|long
name|unknown1
decl_stmt|;
name|CORE_ADDR
name|regionname_addr
decl_stmt|;
name|long
name|protection
decl_stmt|;
name|CORE_ADDR
name|vaddr
decl_stmt|;
name|CORE_ADDR
name|mapaddr
decl_stmt|;
name|long
name|size
decl_stmt|;
name|long
name|unknown2
index|[
literal|5
index|]
decl_stmt|;
block|}
name|ldr_region_info_t
typedef|;
end_typedef

begin_comment
comment|/* Structure at RLD_CONTEXT_ADDRESS specifying the start and finish addresses    of the shared module list.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|CORE_ADDR
name|unknown1
decl_stmt|;
name|CORE_ADDR
name|unknown2
decl_stmt|;
name|CORE_ADDR
name|head
decl_stmt|;
name|CORE_ADDR
name|tail
decl_stmt|;
block|}
name|ldr_context_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !USE_LDR_ROUTINES */
end_comment

begin_comment
comment|/* Per-section information, stored in struct lm_info.secs.  */
end_comment

begin_struct
struct|struct
name|lm_sec
block|{
name|CORE_ADDR
name|offset
decl_stmt|;
comment|/* difference between default and actual 				   virtual addresses of section .name */
name|CORE_ADDR
name|nameaddr
decl_stmt|;
comment|/* address in inferior of section name */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of section, null if not fetched */
block|}
struct|;
end_struct

begin_comment
comment|/* Per-module information, stored in struct so_list.lm_info.  */
end_comment

begin_struct
struct|struct
name|lm_info
block|{
name|int
name|isloader
decl_stmt|;
comment|/* whether the module is /sbin/loader */
name|int
name|nsecs
decl_stmt|;
comment|/* length of .secs */
name|struct
name|lm_sec
name|secs
index|[
literal|1
index|]
decl_stmt|;
comment|/* variable-length array of sections, sorted 				   by name */
block|}
struct|;
end_struct

begin_comment
comment|/* Context for iterating through the inferior's shared module list.  */
end_comment

begin_struct
struct|struct
name|read_map_ctxt
block|{
ifdef|#
directive|ifdef
name|USE_LDR_ROUTINES
name|ldr_process_t
name|proc
decl_stmt|;
name|ldr_module_t
name|next
decl_stmt|;
else|#
directive|else
name|CORE_ADDR
name|next
decl_stmt|;
comment|/* next element in module list */
name|CORE_ADDR
name|tail
decl_stmt|;
comment|/* last element in module list */
endif|#
directive|endif
block|}
struct|;
end_struct

begin_comment
comment|/* Forward declaration for this module's autoinit function.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|_initialize_osf_solib
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|USE_LDR_ROUTINES
end_ifdef

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* This routine is intended to be called by ldr_* routines to read memory from    the current target.  Usage:       ldr_process = ldr_core_process ();      ldr_set_core_reader (ldr_read_memory);      ldr_xdetach (ldr_process);      ldr_xattach (ldr_process);     ldr_core_process() and ldr_read_memory() are neither documented nor    declared in system header files.  They work with OSF/1 2.x, and they might    work with later versions as well.  */
end_comment

begin_endif
unit|static int ldr_read_memory (CORE_ADDR memaddr, char *myaddr, int len, int readstring) {   int result;   char *buffer;    if (readstring)     {       target_read_string (memaddr,&buffer, len,&result);       if (result == 0) 	strcpy (myaddr, buffer);       xfree (buffer);     }   else     result = target_read_memory (memaddr, myaddr, len);    if (result != 0)     result = -result;   return result; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_LDR_ROUTINES */
end_comment

begin_comment
comment|/* Comparison for qsort() and bsearch(): return -1, 0, or 1 according to    whether lm_sec *P1's name is lexically less than, equal to, or greater    than that of *P2.  */
end_comment

begin_function
specifier|static
name|int
name|lm_sec_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
specifier|const
name|struct
name|lm_sec
modifier|*
name|lms1
init|=
name|p1
decl_stmt|,
modifier|*
name|lms2
init|=
name|p2
decl_stmt|;
return|return
name|strcmp
argument_list|(
name|lms1
operator|->
name|name
argument_list|,
name|lms2
operator|->
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Sort LMI->secs so that osf_relocate_section_addresses() can binary-search    it.  */
end_comment

begin_function
specifier|static
name|void
name|lm_secs_sort
parameter_list|(
name|struct
name|lm_info
modifier|*
name|lmi
parameter_list|)
block|{
name|qsort
argument_list|(
name|lmi
operator|->
name|secs
argument_list|,
name|lmi
operator|->
name|nsecs
argument_list|,
sizeof|sizeof
expr|*
name|lmi
operator|->
name|secs
argument_list|,
name|lm_sec_cmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Populate name fields of LMI->secs.  */
end_comment

begin_function
specifier|static
name|void
name|fetch_sec_names
parameter_list|(
name|struct
name|lm_info
modifier|*
name|lmi
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|USE_LDR_ROUTINES
name|int
name|i
decl_stmt|,
name|errcode
decl_stmt|;
name|struct
name|lm_sec
modifier|*
name|lms
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lmi
operator|->
name|nsecs
condition|;
name|i
operator|++
control|)
block|{
name|lms
operator|=
name|lmi
operator|->
name|secs
operator|+
name|i
expr_stmt|;
name|target_read_string
argument_list|(
name|lms
operator|->
name|nameaddr
argument_list|,
operator|&
name|name
argument_list|,
name|PATH_MAX
argument_list|,
operator|&
name|errcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
operator|!=
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"unable to read shared sec name at 0x%lx"
argument_list|,
name|lms
operator|->
name|nameaddr
argument_list|)
expr_stmt|;
name|name
operator|=
name|xstrdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
name|lms
operator|->
name|name
operator|=
name|name
expr_stmt|;
block|}
name|lm_secs_sort
argument_list|(
name|lmi
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* target_so_ops callback.  Adjust SEC's addresses after it's been mapped into    the process.  */
end_comment

begin_function
specifier|static
name|void
name|osf_relocate_section_addresses
parameter_list|(
name|struct
name|so_list
modifier|*
name|so
parameter_list|,
name|struct
name|section_table
modifier|*
name|sec
parameter_list|)
block|{
name|struct
name|lm_info
modifier|*
name|lmi
decl_stmt|;
name|struct
name|lm_sec
name|lms_key
decl_stmt|,
modifier|*
name|lms
decl_stmt|;
comment|/* Fetch SO's section names if we haven't done so already.  */
name|lmi
operator|=
name|so
operator|->
name|lm_info
expr_stmt|;
if|if
condition|(
name|lmi
operator|->
name|nsecs
operator|&&
operator|!
name|lmi
operator|->
name|secs
index|[
literal|0
index|]
operator|.
name|name
condition|)
name|fetch_sec_names
argument_list|(
name|lmi
argument_list|)
expr_stmt|;
comment|/* Binary-search for offset information corresponding to SEC.  */
name|lms_key
operator|.
name|name
operator|=
name|sec
operator|->
name|the_bfd_section
operator|->
name|name
expr_stmt|;
name|lms
operator|=
name|bsearch
argument_list|(
operator|&
name|lms_key
argument_list|,
name|lmi
operator|->
name|secs
argument_list|,
name|lmi
operator|->
name|nsecs
argument_list|,
sizeof|sizeof
expr|*
name|lms
argument_list|,
name|lm_sec_cmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lms
condition|)
block|{
name|sec
operator|->
name|addr
operator|+=
name|lms
operator|->
name|offset
expr_stmt|;
name|sec
operator|->
name|endaddr
operator|+=
name|lms
operator|->
name|offset
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* target_so_ops callback.  Free parts of SO allocated by this file.  */
end_comment

begin_function
specifier|static
name|void
name|osf_free_so
parameter_list|(
name|struct
name|so_list
modifier|*
name|so
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|so
operator|->
name|lm_info
operator|->
name|nsecs
condition|;
name|i
operator|++
control|)
block|{
name|name
operator|=
name|so
operator|->
name|lm_info
operator|->
name|secs
index|[
name|i
index|]
operator|.
name|name
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|xfree
argument_list|(
operator|(
name|void
operator|*
operator|)
name|name
argument_list|)
expr_stmt|;
block|}
name|xfree
argument_list|(
name|so
operator|->
name|lm_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* target_so_ops callback.  Discard information accumulated by this file and    not freed by osf_free_so().  */
end_comment

begin_function
specifier|static
name|void
name|osf_clear_solib
parameter_list|(
name|void
parameter_list|)
block|{
return|return;
block|}
end_function

begin_comment
comment|/* target_so_ops callback.  Prepare to handle shared libraries after the    inferior process has been created but before it's executed any    instructions.     For a statically bound executable, the inferior's first instruction is the    one at "_start", or a similar text label. No further processing is needed    in that case.     For a dynamically bound executable, this first instruction is somewhere    in the rld, and the actual user executable is not yet mapped in.    We continue the inferior again, rld then maps in the actual user    executable and any needed shared libraries and then sends    itself a SIGTRAP.     At that point we discover the names of all shared libraries and    read their symbols in.     FIXME     This code does not properly handle hitting breakpoints which the    user might have set in the rld itself.  Proper handling would have    to check if the SIGTRAP happened due to a kill call.     Also, what if child has exit()ed?  Must exit loop somehow.  */
end_comment

begin_function
specifier|static
name|void
name|osf_solib_create_inferior_hook
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Nothing to do for statically bound executables.  */
if|if
condition|(
name|symfile_objfile
operator|==
name|NULL
operator|||
name|symfile_objfile
operator|->
name|obfd
operator|==
name|NULL
operator|||
operator|(
operator|(
name|bfd_get_file_flags
argument_list|(
name|symfile_objfile
operator|->
name|obfd
argument_list|)
operator|&
name|DYNAMIC
operator|)
operator|==
literal|0
operator|)
condition|)
return|return;
comment|/* Now run the target.  It will eventually get a SIGTRAP, at      which point all of the libraries will have been mapped in and we      can go groveling around in the rld structures to find      out what we need to know about them. */
name|clear_proceed_status
argument_list|()
expr_stmt|;
name|stop_soon
operator|=
name|STOP_QUIETLY
expr_stmt|;
name|stop_signal
operator|=
name|TARGET_SIGNAL_0
expr_stmt|;
do|do
block|{
name|target_resume
argument_list|(
name|minus_one_ptid
argument_list|,
literal|0
argument_list|,
name|stop_signal
argument_list|)
expr_stmt|;
name|wait_for_inferior
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|stop_signal
operator|!=
name|TARGET_SIGNAL_TRAP
condition|)
do|;
comment|/*  solib_add will call reinit_frame_cache.      But we are stopped in the runtime loader and we do not have symbols      for the runtime loader. So heuristic_proc_start will be called      and will put out an annoying warning.      Delaying the resetting of stop_soon until after symbol loading      suppresses the warning.  */
name|solib_add
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|target_ops
operator|*
operator|)
literal|0
argument_list|,
name|auto_solib_add
argument_list|)
expr_stmt|;
name|stop_soon
operator|=
name|NO_STOP_QUIETLY
expr_stmt|;
comment|/* Enable breakpoints disabled (unnecessarily) by clear_solib().  */
name|re_enable_breakpoints_in_shlibs
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* target_so_ops callback.  Do additional symbol handling, lookup, etc. after    symbols for a shared object have been loaded.  */
end_comment

begin_function
specifier|static
name|void
name|osf_special_symbol_handling
parameter_list|(
name|void
parameter_list|)
block|{
return|return;
block|}
end_function

begin_comment
comment|/* Initialize CTXT in preparation for iterating through the inferior's module    list using read_map().  Return success.  */
end_comment

begin_function
specifier|static
name|int
name|open_map
parameter_list|(
name|struct
name|read_map_ctxt
modifier|*
name|ctxt
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_LDR_ROUTINES
comment|/* Note: As originally written, ldr_my_process() was used to obtain      the value for ctxt->proc.  This is incorrect, however, since      ldr_my_process() retrieves the "unique identifier" associated      with the current process (i.e. GDB) and not the one being      debugged.  Presumably, the pid of the process being debugged is      compatible with the "unique identifier" used by the ldr_      routines, so we use that.  */
name|ctxt
operator|->
name|proc
operator|=
name|ptid_get_pid
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldr_xattach
argument_list|(
name|ctxt
operator|->
name|proc
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|ctxt
operator|->
name|next
operator|=
name|LDR_NULL_MODULE
expr_stmt|;
else|#
directive|else
name|CORE_ADDR
name|ldr_context_addr
decl_stmt|,
name|prev
decl_stmt|,
name|next
decl_stmt|;
name|ldr_context_t
name|ldr_context
decl_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|RLD_CONTEXT_ADDRESS
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ldr_context_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|ldr_context_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ldr_context
argument_list|,
sizeof|sizeof
argument_list|(
name|ldr_context_t
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|ctxt
operator|->
name|next
operator|=
name|ldr_context
operator|.
name|head
expr_stmt|;
name|ctxt
operator|->
name|tail
operator|=
name|ldr_context
operator|.
name|tail
expr_stmt|;
endif|#
directive|endif
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Initialize SO to have module NAME, /sbin/loader indicator ISLOADR, and    space for NSECS sections.  */
end_comment

begin_function
specifier|static
name|void
name|init_so
parameter_list|(
name|struct
name|so_list
modifier|*
name|so
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|isloader
parameter_list|,
name|int
name|nsecs
parameter_list|)
block|{
name|int
name|namelen
decl_stmt|,
name|i
decl_stmt|;
comment|/* solib.c requires various fields to be initialized to 0.  */
name|memset
argument_list|(
name|so
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|so
argument_list|)
expr_stmt|;
comment|/* Copy the name.  */
name|namelen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|namelen
operator|>=
name|SO_NAME_MAX_PATH_SIZE
condition|)
name|namelen
operator|=
name|SO_NAME_MAX_PATH_SIZE
operator|-
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|so
operator|->
name|so_original_name
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_original_name
index|[
name|namelen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|memcpy
argument_list|(
name|so
operator|->
name|so_name
argument_list|,
name|so
operator|->
name|so_original_name
argument_list|,
name|namelen
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Allocate section space.  */
name|so
operator|->
name|lm_info
operator|=
name|xmalloc
argument_list|(
operator|(
name|unsigned
operator|)
operator|&
operator|(
operator|(
operator|(
expr|struct
name|lm_info
operator|*
operator|)
literal|0
operator|)
operator|->
name|secs
operator|)
operator|+
name|nsecs
operator|*
sizeof|sizeof
expr|*
name|so
operator|->
name|lm_info
argument_list|)
expr_stmt|;
name|so
operator|->
name|lm_info
operator|->
name|isloader
operator|=
name|isloader
expr_stmt|;
name|so
operator|->
name|lm_info
operator|->
name|nsecs
operator|=
name|nsecs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsecs
condition|;
name|i
operator|++
control|)
name|so
operator|->
name|lm_info
operator|->
name|secs
index|[
name|i
index|]
operator|.
name|name
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize SO's section SECIDX with name address NAMEADDR, name string    NAME, default virtual address VADDR, and actual virtual address    MAPADDR.  */
end_comment

begin_function
specifier|static
name|void
name|init_sec
parameter_list|(
name|struct
name|so_list
modifier|*
name|so
parameter_list|,
name|int
name|secidx
parameter_list|,
name|CORE_ADDR
name|nameaddr
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|CORE_ADDR
name|vaddr
parameter_list|,
name|CORE_ADDR
name|mapaddr
parameter_list|)
block|{
name|struct
name|lm_sec
modifier|*
name|lms
decl_stmt|;
name|lms
operator|=
name|so
operator|->
name|lm_info
operator|->
name|secs
operator|+
name|secidx
expr_stmt|;
name|lms
operator|->
name|nameaddr
operator|=
name|nameaddr
expr_stmt|;
name|lms
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|lms
operator|->
name|offset
operator|=
name|mapaddr
operator|-
name|vaddr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If there are more elements starting at CTXT in inferior's module list,    store the next element in SO, advance CTXT to the next element, and return    1, else return 0.  */
end_comment

begin_function
specifier|static
name|int
name|read_map
parameter_list|(
name|struct
name|read_map_ctxt
modifier|*
name|ctxt
parameter_list|,
name|struct
name|so_list
modifier|*
name|so
parameter_list|)
block|{
name|ldr_module_info_t
name|minf
decl_stmt|;
name|ldr_region_info_t
name|rinf
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_LDR_ROUTINES
name|size_t
name|size
decl_stmt|;
name|ldr_region_t
name|i
decl_stmt|;
comment|/* Retrieve the next element.  */
if|if
condition|(
name|ldr_next_module
argument_list|(
name|ctxt
operator|->
name|proc
argument_list|,
operator|&
name|ctxt
operator|->
name|next
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ctxt
operator|->
name|next
operator|==
name|LDR_NULL_MODULE
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ldr_inq_module
argument_list|(
name|ctxt
operator|->
name|proc
argument_list|,
name|ctxt
operator|->
name|next
argument_list|,
operator|&
name|minf
argument_list|,
sizeof|sizeof
name|minf
argument_list|,
operator|&
name|size
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Initialize the module name and section count.  */
name|init_so
argument_list|(
name|so
argument_list|,
name|minf
operator|.
name|lmi_name
argument_list|,
literal|0
argument_list|,
name|minf
operator|.
name|lmi_nregion
argument_list|)
expr_stmt|;
comment|/* Retrieve section names and offsets.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|minf
operator|.
name|lmi_nregion
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ldr_inq_region
argument_list|(
name|ctxt
operator|->
name|proc
argument_list|,
name|ctxt
operator|->
name|next
argument_list|,
name|i
argument_list|,
operator|&
name|rinf
argument_list|,
sizeof|sizeof
name|rinf
argument_list|,
operator|&
name|size
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
name|init_sec
argument_list|(
name|so
argument_list|,
operator|(
name|int
operator|)
name|i
argument_list|,
literal|0
argument_list|,
name|xstrdup
argument_list|(
name|rinf
operator|.
name|lri_name
argument_list|)
argument_list|,
operator|(
name|CORE_ADDR
operator|)
name|rinf
operator|.
name|lri_vaddr
argument_list|,
operator|(
name|CORE_ADDR
operator|)
name|rinf
operator|.
name|lri_mapaddr
argument_list|)
expr_stmt|;
block|}
name|lm_secs_sort
argument_list|(
name|so
operator|->
name|lm_info
argument_list|)
expr_stmt|;
else|#
directive|else
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|errcode
decl_stmt|,
name|i
decl_stmt|;
comment|/* Retrieve the next element.  */
if|if
condition|(
operator|!
name|ctxt
operator|->
name|next
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|ctxt
operator|->
name|next
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|minf
argument_list|,
sizeof|sizeof
name|minf
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ctxt
operator|->
name|next
operator|==
name|ctxt
operator|->
name|tail
condition|)
name|ctxt
operator|->
name|next
operator|=
literal|0
expr_stmt|;
else|else
name|ctxt
operator|->
name|next
operator|=
name|minf
operator|.
name|next
expr_stmt|;
comment|/* Initialize the module name and section count.  */
name|target_read_string
argument_list|(
name|minf
operator|.
name|module_name
argument_list|,
operator|&
name|name
argument_list|,
name|PATH_MAX
argument_list|,
operator|&
name|errcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|init_so
argument_list|(
name|so
argument_list|,
name|name
argument_list|,
operator|!
name|minf
operator|.
name|modinfo_addr
argument_list|,
name|minf
operator|.
name|region_count
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/* Retrieve section names and offsets.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|minf
operator|.
name|region_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|target_read_memory
argument_list|(
name|minf
operator|.
name|regioninfo_addr
operator|+
name|i
operator|*
sizeof|sizeof
name|rinf
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|rinf
argument_list|,
sizeof|sizeof
name|rinf
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
name|init_sec
argument_list|(
name|so
argument_list|,
name|i
argument_list|,
name|rinf
operator|.
name|regionname_addr
argument_list|,
name|NULL
argument_list|,
name|rinf
operator|.
name|vaddr
argument_list|,
name|rinf
operator|.
name|mapaddr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !USE_LDR_ROUTINES */
return|return
literal|1
return|;
name|err
label|:
name|osf_free_so
argument_list|(
name|so
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Free resources allocated by open_map (CTXT).  */
end_comment

begin_function
specifier|static
name|void
name|close_map
parameter_list|(
name|struct
name|read_map_ctxt
modifier|*
name|ctxt
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_LDR_ROUTINES
name|ldr_xdetach
argument_list|(
name|ctxt
operator|->
name|proc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* target_so_ops callback.  Return a list of shared objects currently loaded    in the inferior.  */
end_comment

begin_function
specifier|static
name|struct
name|so_list
modifier|*
name|osf_current_sos
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|so_list
modifier|*
name|head
init|=
name|NULL
decl_stmt|,
modifier|*
name|tail
decl_stmt|,
modifier|*
name|newtail
decl_stmt|,
name|so
decl_stmt|;
name|struct
name|read_map_ctxt
name|ctxt
decl_stmt|;
name|int
name|skipped_main
decl_stmt|;
if|if
condition|(
operator|!
name|open_map
argument_list|(
operator|&
name|ctxt
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* Read subsequent elements.  */
for|for
control|(
name|skipped_main
operator|=
literal|0
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|read_map
argument_list|(
operator|&
name|ctxt
argument_list|,
operator|&
name|so
argument_list|)
condition|)
break|break;
comment|/* Skip the main program module, which is first in the list after          /sbin/loader.  */
if|if
condition|(
operator|!
name|so
operator|.
name|lm_info
operator|->
name|isloader
operator|&&
operator|!
name|skipped_main
condition|)
block|{
name|osf_free_so
argument_list|(
operator|&
name|so
argument_list|)
expr_stmt|;
name|skipped_main
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|newtail
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|newtail
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|head
condition|)
name|head
operator|=
name|newtail
expr_stmt|;
else|else
name|tail
operator|->
name|next
operator|=
name|newtail
expr_stmt|;
name|tail
operator|=
name|newtail
expr_stmt|;
name|memcpy
argument_list|(
name|tail
argument_list|,
operator|&
name|so
argument_list|,
sizeof|sizeof
name|so
argument_list|)
expr_stmt|;
name|tail
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
block|}
name|done
label|:
name|close_map
argument_list|(
operator|&
name|ctxt
argument_list|)
expr_stmt|;
return|return
name|head
return|;
block|}
end_function

begin_comment
comment|/* target_so_ops callback.  Attempt to locate and open the main symbol    file.  */
end_comment

begin_function
specifier|static
name|int
name|osf_open_symbol_file_object
parameter_list|(
name|void
modifier|*
name|from_ttyp
parameter_list|)
block|{
name|struct
name|read_map_ctxt
name|ctxt
decl_stmt|;
name|struct
name|so_list
name|so
decl_stmt|;
name|int
name|found
decl_stmt|;
if|if
condition|(
name|symfile_objfile
condition|)
if|if
condition|(
operator|!
name|query
argument_list|(
literal|"Attempt to reload symbols from process? "
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* The first module after /sbin/loader is the main program.  */
if|if
condition|(
operator|!
name|open_map
argument_list|(
operator|&
name|ctxt
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|found
operator|=
literal|0
init|;
operator|!
name|found
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|read_map
argument_list|(
operator|&
name|ctxt
argument_list|,
operator|&
name|so
argument_list|)
condition|)
break|break;
name|found
operator|=
operator|!
name|so
operator|.
name|lm_info
operator|->
name|isloader
expr_stmt|;
name|osf_free_so
argument_list|(
operator|&
name|so
argument_list|)
expr_stmt|;
block|}
name|close_map
argument_list|(
operator|&
name|ctxt
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
condition|)
name|symbol_file_add_main
argument_list|(
name|so
operator|.
name|so_name
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|from_ttyp
argument_list|)
expr_stmt|;
return|return
name|found
return|;
block|}
end_function

begin_comment
comment|/* target_so_ops callback.  Return whether PC is in the dynamic linker.  */
end_comment

begin_function
specifier|static
name|int
name|osf_in_dynsym_resolve_code
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
comment|/* This function currently always return False. This is a temporary      solution which only consequence is to introduce a minor incovenience      for the user: When stepping inside a subprogram located in a shared      library, gdb might stop inside the dynamic loader code instead of      inside the subprogram itself. See the explanations in infrun.c about      the IN_SOLIB_DYNSYM_RESOLVE_CODE macro for more details. */
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|target_so_ops
name|osf_so_ops
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_osf_solib
parameter_list|(
name|void
parameter_list|)
block|{
name|osf_so_ops
operator|.
name|relocate_section_addresses
operator|=
name|osf_relocate_section_addresses
expr_stmt|;
name|osf_so_ops
operator|.
name|free_so
operator|=
name|osf_free_so
expr_stmt|;
name|osf_so_ops
operator|.
name|clear_solib
operator|=
name|osf_clear_solib
expr_stmt|;
name|osf_so_ops
operator|.
name|solib_create_inferior_hook
operator|=
name|osf_solib_create_inferior_hook
expr_stmt|;
name|osf_so_ops
operator|.
name|special_symbol_handling
operator|=
name|osf_special_symbol_handling
expr_stmt|;
name|osf_so_ops
operator|.
name|current_sos
operator|=
name|osf_current_sos
expr_stmt|;
name|osf_so_ops
operator|.
name|open_symbol_file_object
operator|=
name|osf_open_symbol_file_object
expr_stmt|;
name|osf_so_ops
operator|.
name|in_dynsym_resolve_code
operator|=
name|osf_in_dynsym_resolve_code
expr_stmt|;
comment|/* FIXME: Don't do this here.  *_gdbarch_init() should set so_ops. */
name|current_target_so_ops
operator|=
operator|&
name|osf_so_ops
expr_stmt|;
block|}
end_function

end_unit

