begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Builtin frame register, for GDB, the GNU debugger.     Copyright 2002 Free Software Foundation, Inc.     Contributed by Red Hat.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"user-regs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_comment
comment|/* Types that describe the various builtin registers.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|builtin_type_frame_reg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Constructors for those types.  */
end_comment

begin_function
specifier|static
name|void
name|build_builtin_type_frame_reg
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* $frame.  */
if|if
condition|(
name|builtin_type_frame_reg
operator|==
name|NULL
condition|)
block|{
if|#
directive|if
literal|0
block|struct frame       { 	void *base;       };
endif|#
directive|endif
name|builtin_type_frame_reg
operator|=
name|init_composite_type
argument_list|(
literal|"frame"
argument_list|,
name|TYPE_CODE_STRUCT
argument_list|)
expr_stmt|;
name|append_composite_type_field
argument_list|(
name|builtin_type_frame_reg
argument_list|,
literal|"base"
argument_list|,
name|builtin_type_void_data_ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|value
modifier|*
name|value_of_builtin_frame_reg
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|val
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|build_builtin_type_frame_reg
argument_list|()
expr_stmt|;
name|val
operator|=
name|allocate_value
argument_list|(
name|builtin_type_frame_reg
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|val
argument_list|)
operator|=
name|not_lval
expr_stmt|;
name|buf
operator|=
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* frame.base.  */
if|if
condition|(
name|frame
operator|!=
name|NULL
condition|)
name|ADDRESS_TO_POINTER
argument_list|(
name|builtin_type_void_data_ptr
argument_list|,
name|buf
argument_list|,
name|get_frame_base
argument_list|(
name|frame
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|TYPE_LENGTH
argument_list|(
name|builtin_type_void_data_ptr
argument_list|)
expr_stmt|;
comment|/* frame.XXX.  */
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|value
modifier|*
name|value_of_builtin_frame_fp_reg
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
if|if
condition|(
name|DEPRECATED_FP_REGNUM
operator|>=
literal|0
condition|)
comment|/* NOTE: cagney/2003-04-24: Since the mere presence of "fp" in the        register name table overrides this built-in $fp register, there        is no real reason for this DEPRECATED_FP_REGNUM trickery here.        An architecture wanting to implement "$fp" as alias for a raw        register can do so by adding "fp" to register name table (mind        you, doing this is probably a dangerous thing).  */
return|return
name|value_of_register
argument_list|(
name|DEPRECATED_FP_REGNUM
argument_list|,
name|frame
argument_list|)
return|;
else|else
block|{
name|struct
name|value
modifier|*
name|val
init|=
name|allocate_value
argument_list|(
name|builtin_type_void_data_ptr
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
decl_stmt|;
if|if
condition|(
name|frame
operator|==
name|NULL
condition|)
name|memset
argument_list|(
name|buf
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|ADDRESS_TO_POINTER
argument_list|(
name|builtin_type_void_data_ptr
argument_list|,
name|buf
argument_list|,
name|get_frame_base_address
argument_list|(
name|frame
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|value
modifier|*
name|value_of_builtin_frame_pc_reg
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
if|if
condition|(
name|PC_REGNUM
operator|>=
literal|0
condition|)
return|return
name|value_of_register
argument_list|(
name|PC_REGNUM
argument_list|,
name|frame
argument_list|)
return|;
else|else
block|{
name|struct
name|value
modifier|*
name|val
init|=
name|allocate_value
argument_list|(
name|builtin_type_void_data_ptr
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|VALUE_CONTENTS_RAW
argument_list|(
name|val
argument_list|)
decl_stmt|;
if|if
condition|(
name|frame
operator|==
name|NULL
condition|)
name|memset
argument_list|(
name|buf
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|ADDRESS_TO_POINTER
argument_list|(
name|builtin_type_void_data_ptr
argument_list|,
name|buf
argument_list|,
name|get_frame_pc
argument_list|(
name|frame
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|value
modifier|*
name|value_of_builtin_frame_sp_reg
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SP_REGNUM
if|if
condition|(
name|SP_REGNUM
operator|>=
literal|0
condition|)
return|return
name|value_of_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|frame
argument_list|)
return|;
endif|#
directive|endif
name|error
argument_list|(
literal|"Standard register ``$sp'' is not available for this target"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|value
modifier|*
name|value_of_builtin_frame_ps_reg
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|PS_REGNUM
if|if
condition|(
name|PS_REGNUM
operator|>=
literal|0
condition|)
return|return
name|value_of_register
argument_list|(
name|PS_REGNUM
argument_list|,
name|frame
argument_list|)
return|;
endif|#
directive|endif
name|error
argument_list|(
literal|"Standard register ``$ps'' is not available for this target"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|initialize_file_ftype
name|_initialize_frame_reg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -Wmissing-prototypes */
end_comment

begin_function
name|void
name|_initialize_frame_reg
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* FIXME: cagney/2002-02-08: At present the local builtin types      can't be initialized using _initialize*() or gdbarch.  Due mainly      to non-multi-arch targets, GDB initializes things piece meal and,      as a consequence can leave these types NULL.  */
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_frame_reg
argument_list|)
expr_stmt|;
comment|/* Frame based $fp, $pc, $sp and $ps.  These only come into play      when the target does not define its own version of these      registers.  */
name|user_reg_add_builtin
argument_list|(
literal|"fp"
argument_list|,
name|value_of_builtin_frame_fp_reg
argument_list|)
expr_stmt|;
name|user_reg_add_builtin
argument_list|(
literal|"pc"
argument_list|,
name|value_of_builtin_frame_pc_reg
argument_list|)
expr_stmt|;
name|user_reg_add_builtin
argument_list|(
literal|"sp"
argument_list|,
name|value_of_builtin_frame_sp_reg
argument_list|)
expr_stmt|;
name|user_reg_add_builtin
argument_list|(
literal|"ps"
argument_list|,
name|value_of_builtin_frame_ps_reg
argument_list|)
expr_stmt|;
comment|/* NOTE: cagney/2002-04-05: For moment leave the $frame / $gdbframe      / $gdb.frame disabled.  It isn't yet clear which of the many      options is the best.  */
if|if
condition|(
literal|0
condition|)
name|user_reg_add_builtin
argument_list|(
literal|"frame"
argument_list|,
name|value_of_builtin_frame_reg
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

