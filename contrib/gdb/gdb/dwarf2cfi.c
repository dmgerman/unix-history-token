begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Stack unwinding code based on dwarf2 frame info for GDB, the GNU debugger.    Copyright 2001, 2002 Free Software Foundation, Inc.    Contributed by Jiri Smid, SuSE Labs.    Based on code written by Daniel Berlin (dan@dberlin.org).     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"elf/dwarf2.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2cfi.h"
end_include

begin_comment
comment|/* Common Information Entry - holds information that is shared among many    Frame Descriptors.  */
end_comment

begin_struct
struct|struct
name|cie_unit
block|{
comment|/* Offset of this unit in .debug_frame or .eh_frame.  */
name|ULONGEST
name|offset
decl_stmt|;
comment|/* A null-terminated string that identifies the augmentation to this CIE or      to the FDEs that use it.  */
name|char
modifier|*
name|augmentation
decl_stmt|;
comment|/* A constant that is factored out of all advance location instructions.  */
name|unsigned
name|int
name|code_align
decl_stmt|;
comment|/* A constant that is factored out of all offset instructions.  */
name|int
name|data_align
decl_stmt|;
comment|/* A constant that indicates which regiter represents the return address      of a function.  */
name|unsigned
name|char
name|ra
decl_stmt|;
comment|/* Indicates how addresses are encoded.  */
name|unsigned
name|char
name|addr_encoding
decl_stmt|;
comment|/* Pointer and length of the cie program.  */
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|int
name|data_length
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
comment|/* Next in chain.  */
name|struct
name|cie_unit
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Frame Description Entry.  */
end_comment

begin_struct
struct|struct
name|fde_unit
block|{
comment|/* Address of the first location associated with this entry.  */
name|CORE_ADDR
name|initial_location
decl_stmt|;
comment|/* Length of program section described by this entry.  */
name|CORE_ADDR
name|address_range
decl_stmt|;
comment|/* Pointer to asociated CIE.  */
name|struct
name|cie_unit
modifier|*
name|cie_ptr
decl_stmt|;
comment|/* Pointer and length of the cie program.  */
name|char
modifier|*
name|data
decl_stmt|;
name|unsigned
name|int
name|data_length
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|fde_array
block|{
name|struct
name|fde_unit
modifier|*
modifier|*
name|array
decl_stmt|;
name|int
name|elems
decl_stmt|;
name|int
name|array_size
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|context_reg
block|{
union|union
block|{
name|unsigned
name|int
name|reg
decl_stmt|;
name|long
name|offset
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
block|}
name|loc
union|;
enum|enum
block|{
name|REG_CTX_UNSAVED
block|,
name|REG_CTX_SAVED_OFFSET
block|,
name|REG_CTX_SAVED_REG
block|,
name|REG_CTX_SAVED_ADDR
block|,
name|REG_CTX_VALUE
block|,   }
name|how
enum|;
block|}
struct|;
end_struct

begin_comment
comment|/* This is the register and unwind state for a particular frame.  */
end_comment

begin_struct
struct|struct
name|context
block|{
name|struct
name|context_reg
modifier|*
name|reg
decl_stmt|;
name|CORE_ADDR
name|cfa
decl_stmt|;
name|CORE_ADDR
name|ra
decl_stmt|;
name|void
modifier|*
name|lsda
decl_stmt|;
name|int
name|args_size
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|frame_state_reg
block|{
union|union
block|{
name|unsigned
name|int
name|reg
decl_stmt|;
name|long
name|offset
decl_stmt|;
name|unsigned
name|char
modifier|*
name|exp
decl_stmt|;
block|}
name|loc
union|;
enum|enum
block|{
name|REG_UNSAVED
block|,
name|REG_SAVED_OFFSET
block|,
name|REG_SAVED_REG
block|,
name|REG_SAVED_EXP
block|,   }
name|how
enum|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|frame_state
block|{
comment|/* Each register save state can be described in terms of a CFA slot,      another register, or a location expression.  */
struct|struct
name|frame_state_regs
block|{
name|struct
name|frame_state_reg
modifier|*
name|reg
decl_stmt|;
comment|/* Used to implement DW_CFA_remember_state.  */
name|struct
name|frame_state_regs
modifier|*
name|prev
decl_stmt|;
block|}
name|regs
struct|;
comment|/* The CFA can be described in terms of a reg+offset or a      location expression.  */
name|long
name|cfa_offset
decl_stmt|;
name|int
name|cfa_reg
decl_stmt|;
name|unsigned
name|char
modifier|*
name|cfa_exp
decl_stmt|;
enum|enum
block|{
name|CFA_UNSET
block|,
name|CFA_REG_OFFSET
block|,
name|CFA_EXP
block|,   }
name|cfa_how
enum|;
comment|/* The PC described by the current frame state.  */
name|CORE_ADDR
name|pc
decl_stmt|;
comment|/* The information we care about from the CIE/FDE.  */
name|int
name|data_align
decl_stmt|;
name|unsigned
name|int
name|code_align
decl_stmt|;
name|unsigned
name|char
name|retaddr_column
decl_stmt|;
name|unsigned
name|char
name|addr_encoding
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|ptr_encoding
block|{
name|PE_absptr
init|=
name|DW_EH_PE_absptr
block|,
name|PE_pcrel
init|=
name|DW_EH_PE_pcrel
block|,
name|PE_textrel
init|=
name|DW_EH_PE_textrel
block|,
name|PE_datarel
init|=
name|DW_EH_PE_datarel
block|,
name|PE_funcrel
init|=
name|DW_EH_PE_funcrel
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|UNWIND_CONTEXT
parameter_list|(
name|fi
parameter_list|)
value|((struct context *) (fi->context))
end_define

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|struct
name|cie_unit
modifier|*
name|cie_chunks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|fde_array
name|fde_chunks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Obstack for allocating temporary storage used during unwind operations.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|unwind_tmp_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|file_ptr
name|dwarf_frame_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|int
name|dwarf_frame_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|file_ptr
name|dwarf_eh_frame_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|unsigned
name|int
name|dwarf_eh_frame_size
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function_decl
specifier|extern
name|char
modifier|*
name|dwarf2_read_section
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|file_ptr
name|offset
parameter_list|,
name|unsigned
name|int
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|fde_unit
modifier|*
name|fde_unit_alloc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|cie_unit
modifier|*
name|cie_unit_alloc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fde_chunks_need_space
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|context
modifier|*
name|context_alloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|frame_state
modifier|*
name|frame_state_alloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unwind_tmp_obstack_init
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unwind_tmp_obstack_free
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|context_cpy
parameter_list|(
name|struct
name|context
modifier|*
name|dst
parameter_list|,
name|struct
name|context
modifier|*
name|src
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|read_1u
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_1s
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|read_2u
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_2s
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|read_4u
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_4s
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ULONGEST
name|read_8u
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|LONGEST
name|read_8s
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ULONGEST
name|read_uleb128
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|LONGEST
name|read_sleb128
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|CORE_ADDR
name|read_pointer
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|CORE_ADDR
name|read_encoded_pointer
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
modifier|*
name|p
parameter_list|,
name|unsigned
name|char
name|encoding
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|ptr_encoding
name|pointer_encoding
parameter_list|(
name|unsigned
name|char
name|encoding
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|LONGEST
name|read_initial_length
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|bytes_read
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ULONGEST
name|read_length
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|bytes_read
parameter_list|,
name|int
name|dwarf64
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|is_cie
parameter_list|(
name|ULONGEST
name|cie_id
parameter_list|,
name|int
name|dwarf64
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|compare_fde_unit
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dwarf2_build_frame_info
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|execute_cfa_program
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|char
modifier|*
name|insn_ptr
parameter_list|,
name|char
modifier|*
name|insn_end
parameter_list|,
name|struct
name|context
modifier|*
name|context
parameter_list|,
name|struct
name|frame_state
modifier|*
name|fs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|fde_unit
modifier|*
name|get_fde_for_addr
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|frame_state_for
parameter_list|(
name|struct
name|context
modifier|*
name|context
parameter_list|,
name|struct
name|frame_state
modifier|*
name|fs
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|get_reg
parameter_list|(
name|char
modifier|*
name|reg
parameter_list|,
name|struct
name|context
modifier|*
name|context
parameter_list|,
name|int
name|regnum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|CORE_ADDR
name|execute_stack_op
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|char
modifier|*
name|op_ptr
parameter_list|,
name|char
modifier|*
name|op_end
parameter_list|,
name|struct
name|context
modifier|*
name|context
parameter_list|,
name|CORE_ADDR
name|initial
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|update_context
parameter_list|(
name|struct
name|context
modifier|*
name|context
parameter_list|,
name|struct
name|frame_state
modifier|*
name|fs
parameter_list|,
name|int
name|chain
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* Memory allocation functions.  */
end_comment

begin_function
specifier|static
name|struct
name|fde_unit
modifier|*
name|fde_unit_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|fde_unit
modifier|*
name|fde
decl_stmt|;
name|fde
operator|=
operator|(
expr|struct
name|fde_unit
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|fde_unit
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|fde
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fde_unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|fde
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|cie_unit
modifier|*
name|cie_unit_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cie_unit
modifier|*
name|cie
decl_stmt|;
name|cie
operator|=
operator|(
expr|struct
name|cie_unit
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cie_unit
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|cie
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cie_unit
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cie
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fde_chunks_need_space
parameter_list|()
block|{
if|if
condition|(
name|fde_chunks
operator|.
name|elems
operator|<
name|fde_chunks
operator|.
name|array_size
condition|)
return|return;
name|fde_chunks
operator|.
name|array_size
operator|=
name|fde_chunks
operator|.
name|array_size
condition|?
literal|2
operator|*
name|fde_chunks
operator|.
name|array_size
else|:
literal|1024
expr_stmt|;
name|fde_chunks
operator|.
name|array
operator|=
name|xrealloc
argument_list|(
name|fde_chunks
operator|.
name|array
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fde_unit
argument_list|)
operator|*
name|fde_chunks
operator|.
name|array_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Alocate a new `struct context' on temporary obstack.  */
end_comment

begin_function
specifier|static
name|struct
name|context
modifier|*
name|context_alloc
parameter_list|()
block|{
name|struct
name|context
modifier|*
name|context
decl_stmt|;
name|int
name|regs_size
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|context_reg
argument_list|)
operator|*
name|NUM_REGS
decl_stmt|;
name|context
operator|=
operator|(
expr|struct
name|context
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|unwind_tmp_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|context
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|context
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|->
name|reg
operator|=
operator|(
expr|struct
name|context_reg
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|unwind_tmp_obstack
argument_list|,
name|regs_size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|context
operator|->
name|reg
argument_list|,
literal|0
argument_list|,
name|regs_size
argument_list|)
expr_stmt|;
return|return
name|context
return|;
block|}
end_function

begin_comment
comment|/* Alocate a new `struct frame_state' on temporary obstack.  */
end_comment

begin_function
specifier|static
name|struct
name|frame_state
modifier|*
name|frame_state_alloc
parameter_list|()
block|{
name|struct
name|frame_state
modifier|*
name|fs
decl_stmt|;
name|int
name|regs_size
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|frame_state_reg
argument_list|)
operator|*
name|NUM_REGS
decl_stmt|;
name|fs
operator|=
operator|(
expr|struct
name|frame_state
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|unwind_tmp_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|frame_state
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|fs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|frame_state
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
operator|=
operator|(
expr|struct
name|frame_state_reg
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|unwind_tmp_obstack
argument_list|,
name|regs_size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|fs
operator|->
name|regs
operator|.
name|reg
argument_list|,
literal|0
argument_list|,
name|regs_size
argument_list|)
expr_stmt|;
return|return
name|fs
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|unwind_tmp_obstack_init
parameter_list|()
block|{
name|obstack_init
argument_list|(
operator|&
name|unwind_tmp_obstack
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|unwind_tmp_obstack_free
parameter_list|()
block|{
name|obstack_free
argument_list|(
operator|&
name|unwind_tmp_obstack
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|unwind_tmp_obstack_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|context_cpy
parameter_list|(
name|struct
name|context
modifier|*
name|dst
parameter_list|,
name|struct
name|context
modifier|*
name|src
parameter_list|)
block|{
name|int
name|regs_size
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|context_reg
argument_list|)
operator|*
name|NUM_REGS
decl_stmt|;
name|struct
name|context_reg
modifier|*
name|dreg
decl_stmt|;
comment|/* Structure dst contains a pointer to an array of    * registers of a given frame as well as src does. This    * array was already allocated before dst was passed to    * context_cpy but the pointer to it was overriden by    * '*dst = *src' and the array was lost. This led to the    * situation, that we've had a copy of src placed in dst,    * but both of them pointed to the same regs array and    * thus we've sometimes blindly rewritten it.  Now we save    * the pointer before copying src to dst, return it back    * after that and copy the registers into their new place    * finally.   ---   mludvig@suse.cz  */
name|dreg
operator|=
name|dst
operator|->
name|reg
expr_stmt|;
operator|*
name|dst
operator|=
operator|*
name|src
expr_stmt|;
name|dst
operator|->
name|reg
operator|=
name|dreg
expr_stmt|;
name|memcpy
argument_list|(
name|dst
operator|->
name|reg
argument_list|,
name|src
operator|->
name|reg
argument_list|,
name|regs_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|read_1u
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
modifier|*
name|p
parameter_list|)
block|{
name|unsigned
name|ret
decl_stmt|;
name|ret
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
operator|*
name|p
argument_list|)
expr_stmt|;
operator|(
operator|*
name|p
operator|)
operator|++
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_1s
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
modifier|*
name|p
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|bfd_get_signed_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
operator|*
name|p
argument_list|)
expr_stmt|;
operator|(
operator|*
name|p
operator|)
operator|++
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|read_2u
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
modifier|*
name|p
parameter_list|)
block|{
name|unsigned
name|ret
decl_stmt|;
name|ret
operator|=
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
operator|*
name|p
argument_list|)
expr_stmt|;
operator|(
operator|*
name|p
operator|)
operator|++
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_2s
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
modifier|*
name|p
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|bfd_get_signed_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
operator|*
name|p
argument_list|)
expr_stmt|;
operator|(
operator|*
name|p
operator|)
operator|+=
literal|2
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|read_4u
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
modifier|*
name|p
parameter_list|)
block|{
name|unsigned
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
operator|*
name|p
argument_list|)
expr_stmt|;
operator|(
operator|*
name|p
operator|)
operator|+=
literal|4
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_4s
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
modifier|*
name|p
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|bfd_get_signed_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
operator|*
name|p
argument_list|)
expr_stmt|;
operator|(
operator|*
name|p
operator|)
operator|+=
literal|4
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|ULONGEST
name|read_8u
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
modifier|*
name|p
parameter_list|)
block|{
name|ULONGEST
name|ret
decl_stmt|;
name|ret
operator|=
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
operator|*
name|p
argument_list|)
expr_stmt|;
operator|(
operator|*
name|p
operator|)
operator|+=
literal|8
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|LONGEST
name|read_8s
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
modifier|*
name|p
parameter_list|)
block|{
name|LONGEST
name|ret
decl_stmt|;
name|ret
operator|=
name|bfd_get_signed_64
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
operator|*
name|p
argument_list|)
expr_stmt|;
operator|(
operator|*
name|p
operator|)
operator|+=
literal|8
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|ULONGEST
name|read_uleb128
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
modifier|*
name|p
parameter_list|)
block|{
name|ULONGEST
name|ret
decl_stmt|;
name|int
name|i
decl_stmt|,
name|shift
decl_stmt|;
name|unsigned
name|char
name|byte
decl_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|shift
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|byte
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
operator|*
name|p
argument_list|)
expr_stmt|;
operator|(
operator|*
name|p
operator|)
operator|++
expr_stmt|;
name|ret
operator||=
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|byte
operator|&
literal|127
argument_list|)
operator|<<
name|shift
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|byte
operator|&
literal|128
operator|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|shift
operator|+=
literal|7
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|LONGEST
name|read_sleb128
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
modifier|*
name|p
parameter_list|)
block|{
name|LONGEST
name|ret
decl_stmt|;
name|int
name|i
decl_stmt|,
name|shift
decl_stmt|,
name|size
decl_stmt|,
name|num_read
decl_stmt|;
name|unsigned
name|char
name|byte
decl_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|shift
operator|=
literal|0
expr_stmt|;
name|size
operator|=
literal|32
expr_stmt|;
name|num_read
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|byte
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
operator|*
name|p
argument_list|)
expr_stmt|;
operator|(
operator|*
name|p
operator|)
operator|++
expr_stmt|;
name|ret
operator||=
operator|(
call|(
name|long
call|)
argument_list|(
name|byte
operator|&
literal|127
argument_list|)
operator|<<
name|shift
operator|)
expr_stmt|;
name|shift
operator|+=
literal|7
expr_stmt|;
if|if
condition|(
operator|(
name|byte
operator|&
literal|128
operator|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|shift
operator|<
name|size
operator|)
operator|&&
operator|(
name|byte
operator|&
literal|0x40
operator|)
condition|)
block|{
name|ret
operator||=
operator|-
operator|(
literal|1
operator|<<
name|shift
operator|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|read_pointer
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
modifier|*
name|p
parameter_list|)
block|{
switch|switch
condition|(
name|TARGET_ADDR_BIT
operator|/
name|TARGET_CHAR_BIT
condition|)
block|{
case|case
literal|4
case|:
return|return
name|read_4u
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|)
return|;
case|case
literal|8
case|:
return|return
name|read_8u
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|)
return|;
default|default:
name|error
argument_list|(
literal|"dwarf cfi error: unsupported target address length."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This functions only reads appropriate amount of data from *p   * and returns the resulting value. Calling function must handle  * different encoding possibilities itself!  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|read_encoded_pointer
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
modifier|*
name|p
parameter_list|,
name|unsigned
name|char
name|encoding
parameter_list|)
block|{
name|CORE_ADDR
name|ret
decl_stmt|;
switch|switch
condition|(
name|encoding
operator|&
literal|0x0f
condition|)
block|{
case|case
name|DW_EH_PE_absptr
case|:
name|ret
operator|=
name|read_pointer
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_EH_PE_uleb128
case|:
name|ret
operator|=
name|read_uleb128
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_EH_PE_sleb128
case|:
name|ret
operator|=
name|read_sleb128
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_EH_PE_udata2
case|:
name|ret
operator|=
name|read_2u
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_EH_PE_udata4
case|:
name|ret
operator|=
name|read_4u
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_EH_PE_udata8
case|:
name|ret
operator|=
name|read_8u
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_EH_PE_sdata2
case|:
name|ret
operator|=
name|read_2s
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_EH_PE_sdata4
case|:
name|ret
operator|=
name|read_4s
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_EH_PE_sdata8
case|:
name|ret
operator|=
name|read_8s
argument_list|(
name|abfd
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"read_encoded_pointer: unknown pointer encoding"
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Variable 'encoding' carries 3 different flags:  * - encoding& 0x0f : size of the address (handled in read_encoded_pointer())  * - encoding& 0x70 : type (absolute, relative, ...)  * - encoding& 0x80 : indirect flag (DW_EH_PE_indirect == 0x80).  */
end_comment

begin_function
name|enum
name|ptr_encoding
name|pointer_encoding
parameter_list|(
name|unsigned
name|char
name|encoding
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|encoding
operator|&
name|DW_EH_PE_indirect
condition|)
name|warning
argument_list|(
literal|"CFI: Unsupported pointer encoding: DW_EH_PE_indirect"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|encoding
operator|&
literal|0x70
condition|)
block|{
case|case
name|DW_EH_PE_absptr
case|:
case|case
name|DW_EH_PE_pcrel
case|:
case|case
name|DW_EH_PE_textrel
case|:
case|case
name|DW_EH_PE_datarel
case|:
case|case
name|DW_EH_PE_funcrel
case|:
name|ret
operator|=
name|encoding
operator|&
literal|0x70
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"CFI: unknown pointer encoding"
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|LONGEST
name|read_initial_length
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|bytes_read
parameter_list|)
block|{
name|LONGEST
name|ret
init|=
literal|0
decl_stmt|;
name|ret
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0xffffffff
condition|)
block|{
name|ret
operator|=
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
operator|+
literal|4
argument_list|)
expr_stmt|;
operator|*
name|bytes_read
operator|=
literal|12
expr_stmt|;
block|}
else|else
block|{
operator|*
name|bytes_read
operator|=
literal|4
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|ULONGEST
name|read_length
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
modifier|*
name|bytes_read
parameter_list|,
name|int
name|dwarf64
parameter_list|)
block|{
if|if
condition|(
name|dwarf64
condition|)
block|{
operator|*
name|bytes_read
operator|=
literal|8
expr_stmt|;
return|return
name|read_8u
argument_list|(
name|abfd
argument_list|,
operator|&
name|buf
argument_list|)
return|;
block|}
else|else
block|{
operator|*
name|bytes_read
operator|=
literal|4
expr_stmt|;
return|return
name|read_4u
argument_list|(
name|abfd
argument_list|,
operator|&
name|buf
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|execute_cfa_program
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|char
modifier|*
name|insn_ptr
parameter_list|,
name|char
modifier|*
name|insn_end
parameter_list|,
name|struct
name|context
modifier|*
name|context
parameter_list|,
name|struct
name|frame_state
modifier|*
name|fs
parameter_list|)
block|{
name|struct
name|frame_state_regs
modifier|*
name|unused_rs
init|=
name|NULL
decl_stmt|;
comment|/* Don't allow remember/restore between CIE and FDE programs.  */
name|fs
operator|->
name|regs
operator|.
name|prev
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|insn_ptr
operator|<
name|insn_end
operator|&&
name|fs
operator|->
name|pc
operator|<
name|context
operator|->
name|ra
condition|)
block|{
name|unsigned
name|char
name|insn
init|=
operator|*
name|insn_ptr
operator|++
decl_stmt|;
name|ULONGEST
name|reg
decl_stmt|,
name|uoffset
decl_stmt|;
name|LONGEST
name|offset
decl_stmt|;
if|if
condition|(
name|insn
operator|&
name|DW_CFA_advance_loc
condition|)
name|fs
operator|->
name|pc
operator|+=
operator|(
name|insn
operator|&
literal|0x3f
operator|)
operator|*
name|fs
operator|->
name|code_align
expr_stmt|;
elseif|else
if|if
condition|(
name|insn
operator|&
name|DW_CFA_offset
condition|)
block|{
name|reg
operator|=
name|insn
operator|&
literal|0x3f
expr_stmt|;
name|uoffset
operator|=
name|read_uleb128
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|insn_ptr
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|long
operator|)
name|uoffset
operator|*
name|fs
operator|->
name|data_align
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|how
operator|=
name|REG_SAVED_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|insn
operator|&
name|DW_CFA_restore
condition|)
block|{
name|reg
operator|=
name|insn
operator|&
literal|0x3f
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|how
operator|=
name|REG_UNSAVED
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|insn
condition|)
block|{
case|case
name|DW_CFA_set_loc
case|:
name|fs
operator|->
name|pc
operator|=
name|read_encoded_pointer
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|insn_ptr
argument_list|,
name|fs
operator|->
name|addr_encoding
argument_list|)
expr_stmt|;
if|if
condition|(
name|pointer_encoding
argument_list|(
name|fs
operator|->
name|addr_encoding
argument_list|)
operator|!=
name|PE_absptr
condition|)
name|warning
argument_list|(
literal|"CFI: DW_CFA_set_loc uses relative addressing"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_advance_loc1
case|:
name|fs
operator|->
name|pc
operator|+=
name|read_1u
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|insn_ptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_advance_loc2
case|:
name|fs
operator|->
name|pc
operator|+=
name|read_2u
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|insn_ptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_advance_loc4
case|:
name|fs
operator|->
name|pc
operator|+=
name|read_4u
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|insn_ptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_CFA_offset_extended
case|:
name|reg
operator|=
name|read_uleb128
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|insn_ptr
argument_list|)
expr_stmt|;
name|uoffset
operator|=
name|read_uleb128
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|insn_ptr
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|long
operator|)
name|uoffset
operator|*
name|fs
operator|->
name|data_align
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|how
operator|=
name|REG_SAVED_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
break|break;
case|case
name|DW_CFA_restore_extended
case|:
name|reg
operator|=
name|read_uleb128
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|insn_ptr
argument_list|)
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|how
operator|=
name|REG_UNSAVED
expr_stmt|;
break|break;
case|case
name|DW_CFA_undefined
case|:
case|case
name|DW_CFA_same_value
case|:
case|case
name|DW_CFA_nop
case|:
break|break;
case|case
name|DW_CFA_register
case|:
block|{
name|ULONGEST
name|reg2
decl_stmt|;
name|reg
operator|=
name|read_uleb128
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|insn_ptr
argument_list|)
expr_stmt|;
name|reg2
operator|=
name|read_uleb128
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|insn_ptr
argument_list|)
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|how
operator|=
name|REG_SAVED_REG
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|loc
operator|.
name|reg
operator|=
name|reg2
expr_stmt|;
block|}
break|break;
case|case
name|DW_CFA_remember_state
case|:
block|{
name|struct
name|frame_state_regs
modifier|*
name|new_rs
decl_stmt|;
if|if
condition|(
name|unused_rs
condition|)
block|{
name|new_rs
operator|=
name|unused_rs
expr_stmt|;
name|unused_rs
operator|=
name|unused_rs
operator|->
name|prev
expr_stmt|;
block|}
else|else
name|new_rs
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|frame_state_regs
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|new_rs
operator|=
name|fs
operator|->
name|regs
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|prev
operator|=
name|new_rs
expr_stmt|;
block|}
break|break;
case|case
name|DW_CFA_restore_state
case|:
block|{
name|struct
name|frame_state_regs
modifier|*
name|old_rs
init|=
name|fs
operator|->
name|regs
operator|.
name|prev
decl_stmt|;
name|fs
operator|->
name|regs
operator|=
operator|*
name|old_rs
expr_stmt|;
name|old_rs
operator|->
name|prev
operator|=
name|unused_rs
expr_stmt|;
name|unused_rs
operator|=
name|old_rs
expr_stmt|;
block|}
break|break;
case|case
name|DW_CFA_def_cfa
case|:
name|reg
operator|=
name|read_uleb128
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|insn_ptr
argument_list|)
expr_stmt|;
name|uoffset
operator|=
name|read_uleb128
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|insn_ptr
argument_list|)
expr_stmt|;
name|fs
operator|->
name|cfa_reg
operator|=
name|reg
expr_stmt|;
name|fs
operator|->
name|cfa_offset
operator|=
name|uoffset
expr_stmt|;
name|fs
operator|->
name|cfa_how
operator|=
name|CFA_REG_OFFSET
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_register
case|:
name|reg
operator|=
name|read_uleb128
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|insn_ptr
argument_list|)
expr_stmt|;
name|fs
operator|->
name|cfa_reg
operator|=
name|reg
expr_stmt|;
name|fs
operator|->
name|cfa_how
operator|=
name|CFA_REG_OFFSET
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_offset
case|:
name|uoffset
operator|=
name|read_uleb128
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|insn_ptr
argument_list|)
expr_stmt|;
name|fs
operator|->
name|cfa_offset
operator|=
name|uoffset
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_expression
case|:
name|uoffset
operator|=
name|read_uleb128
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|insn_ptr
argument_list|)
expr_stmt|;
name|fs
operator|->
name|cfa_exp
operator|=
name|insn_ptr
expr_stmt|;
name|fs
operator|->
name|cfa_how
operator|=
name|CFA_EXP
expr_stmt|;
name|insn_ptr
operator|+=
name|uoffset
expr_stmt|;
break|break;
case|case
name|DW_CFA_expression
case|:
name|reg
operator|=
name|read_uleb128
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|insn_ptr
argument_list|)
expr_stmt|;
name|uoffset
operator|=
name|read_uleb128
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|insn_ptr
argument_list|)
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|how
operator|=
name|REG_SAVED_EXP
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|loc
operator|.
name|exp
operator|=
name|insn_ptr
expr_stmt|;
name|insn_ptr
operator|+=
name|uoffset
expr_stmt|;
break|break;
comment|/* From the 2.1 draft.  */
case|case
name|DW_CFA_offset_extended_sf
case|:
name|reg
operator|=
name|read_uleb128
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|insn_ptr
argument_list|)
expr_stmt|;
name|offset
operator|=
name|read_sleb128
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|insn_ptr
argument_list|)
expr_stmt|;
name|offset
operator|*=
name|fs
operator|->
name|data_align
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|how
operator|=
name|REG_SAVED_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_sf
case|:
name|reg
operator|=
name|read_uleb128
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|insn_ptr
argument_list|)
expr_stmt|;
name|offset
operator|=
name|read_sleb128
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|insn_ptr
argument_list|)
expr_stmt|;
name|fs
operator|->
name|cfa_offset
operator|=
name|offset
expr_stmt|;
name|fs
operator|->
name|cfa_reg
operator|=
name|reg
expr_stmt|;
name|fs
operator|->
name|cfa_how
operator|=
name|CFA_REG_OFFSET
expr_stmt|;
break|break;
case|case
name|DW_CFA_def_cfa_offset_sf
case|:
name|uoffset
operator|=
name|read_uleb128
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|insn_ptr
argument_list|)
expr_stmt|;
name|fs
operator|->
name|cfa_offset
operator|=
name|uoffset
expr_stmt|;
comment|/* cfa_how deliberately not set.  */
break|break;
case|case
name|DW_CFA_GNU_window_save
case|:
comment|/* ??? Hardcoded for SPARC register window configuration.  */
for|for
control|(
name|reg
operator|=
literal|16
init|;
name|reg
operator|<
literal|32
condition|;
operator|++
name|reg
control|)
block|{
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|how
operator|=
name|REG_SAVED_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
operator|(
name|reg
operator|-
literal|16
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DW_CFA_GNU_args_size
case|:
name|uoffset
operator|=
name|read_uleb128
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|insn_ptr
argument_list|)
expr_stmt|;
name|context
operator|->
name|args_size
operator|=
name|uoffset
expr_stmt|;
break|break;
case|case
name|DW_CFA_GNU_negative_offset_extended
case|:
comment|/* Obsoleted by DW_CFA_offset_extended_sf, but used by 	       older PowerPC code.  */
name|reg
operator|=
name|read_uleb128
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|insn_ptr
argument_list|)
expr_stmt|;
name|uoffset
operator|=
name|read_uleb128
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|insn_ptr
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|long
operator|)
name|uoffset
operator|*
name|fs
operator|->
name|data_align
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|how
operator|=
name|REG_SAVED_OFFSET
expr_stmt|;
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|reg
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"dwarf cfi error: unknown cfa instruction %d."
argument_list|,
name|insn
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|fde_unit
modifier|*
name|get_fde_for_addr
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|size_t
name|lo
decl_stmt|,
name|hi
decl_stmt|;
name|struct
name|fde_unit
modifier|*
name|fde
init|=
name|NULL
decl_stmt|;
name|lo
operator|=
literal|0
expr_stmt|;
name|hi
operator|=
name|fde_chunks
operator|.
name|elems
expr_stmt|;
while|while
condition|(
name|lo
operator|<
name|hi
condition|)
block|{
name|size_t
name|i
init|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
decl_stmt|;
name|fde
operator|=
name|fde_chunks
operator|.
name|array
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|pc
operator|<
name|fde
operator|->
name|initial_location
condition|)
name|hi
operator|=
name|i
expr_stmt|;
elseif|else
if|if
condition|(
name|pc
operator|>=
name|fde
operator|->
name|initial_location
operator|+
name|fde
operator|->
name|address_range
condition|)
name|lo
operator|=
name|i
operator|+
literal|1
expr_stmt|;
else|else
return|return
name|fde
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|frame_state_for
parameter_list|(
name|struct
name|context
modifier|*
name|context
parameter_list|,
name|struct
name|frame_state
modifier|*
name|fs
parameter_list|)
block|{
name|struct
name|fde_unit
modifier|*
name|fde
decl_stmt|;
name|struct
name|cie_unit
modifier|*
name|cie
decl_stmt|;
name|context
operator|->
name|args_size
operator|=
literal|0
expr_stmt|;
name|context
operator|->
name|lsda
operator|=
literal|0
expr_stmt|;
name|fde
operator|=
name|get_fde_for_addr
argument_list|(
name|context
operator|->
name|ra
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fde
operator|==
name|NULL
condition|)
return|return;
name|fs
operator|->
name|pc
operator|=
name|fde
operator|->
name|initial_location
expr_stmt|;
if|if
condition|(
name|fde
operator|->
name|cie_ptr
condition|)
block|{
name|cie
operator|=
name|fde
operator|->
name|cie_ptr
expr_stmt|;
name|fs
operator|->
name|code_align
operator|=
name|cie
operator|->
name|code_align
expr_stmt|;
name|fs
operator|->
name|data_align
operator|=
name|cie
operator|->
name|data_align
expr_stmt|;
name|fs
operator|->
name|retaddr_column
operator|=
name|cie
operator|->
name|ra
expr_stmt|;
name|fs
operator|->
name|addr_encoding
operator|=
name|cie
operator|->
name|addr_encoding
expr_stmt|;
name|fs
operator|->
name|objfile
operator|=
name|cie
operator|->
name|objfile
expr_stmt|;
name|execute_cfa_program
argument_list|(
name|cie
operator|->
name|objfile
argument_list|,
name|cie
operator|->
name|data
argument_list|,
name|cie
operator|->
name|data
operator|+
name|cie
operator|->
name|data_length
argument_list|,
name|context
argument_list|,
name|fs
argument_list|)
expr_stmt|;
name|execute_cfa_program
argument_list|(
name|cie
operator|->
name|objfile
argument_list|,
name|fde
operator|->
name|data
argument_list|,
name|fde
operator|->
name|data
operator|+
name|fde
operator|->
name|data_length
argument_list|,
name|context
argument_list|,
name|fs
argument_list|)
expr_stmt|;
block|}
else|else
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"%s(): Internal error: fde->cie_ptr==NULL !"
argument_list|,
literal|"?func?"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_reg
parameter_list|(
name|char
modifier|*
name|reg
parameter_list|,
name|struct
name|context
modifier|*
name|context
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
switch|switch
condition|(
name|context
operator|->
name|reg
index|[
name|regnum
index|]
operator|.
name|how
condition|)
block|{
case|case
name|REG_CTX_UNSAVED
case|:
name|read_register_gen
argument_list|(
name|regnum
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_CTX_SAVED_OFFSET
case|:
name|target_read_memory
argument_list|(
name|context
operator|->
name|cfa
operator|+
name|context
operator|->
name|reg
index|[
name|regnum
index|]
operator|.
name|loc
operator|.
name|offset
argument_list|,
name|reg
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_CTX_SAVED_REG
case|:
name|read_register_gen
argument_list|(
name|context
operator|->
name|reg
index|[
name|regnum
index|]
operator|.
name|loc
operator|.
name|reg
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_CTX_SAVED_ADDR
case|:
name|target_read_memory
argument_list|(
name|context
operator|->
name|reg
index|[
name|regnum
index|]
operator|.
name|loc
operator|.
name|addr
argument_list|,
name|reg
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_CTX_VALUE
case|:
name|memcpy
argument_list|(
name|reg
argument_list|,
operator|&
name|context
operator|->
name|reg
index|[
name|regnum
index|]
operator|.
name|loc
operator|.
name|addr
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"get_reg: unknown register rule"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Decode a DW_OP stack program.  Return the top of stack.  Push INITIAL    onto the stack to start.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|execute_stack_op
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|char
modifier|*
name|op_ptr
parameter_list|,
name|char
modifier|*
name|op_end
parameter_list|,
name|struct
name|context
modifier|*
name|context
parameter_list|,
name|CORE_ADDR
name|initial
parameter_list|)
block|{
name|CORE_ADDR
name|stack
index|[
literal|64
index|]
decl_stmt|;
comment|/* ??? Assume this is enough. */
name|int
name|stack_elt
decl_stmt|;
name|stack
index|[
literal|0
index|]
operator|=
name|initial
expr_stmt|;
name|stack_elt
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|op_ptr
operator|<
name|op_end
condition|)
block|{
name|enum
name|dwarf_location_atom
name|op
init|=
operator|*
name|op_ptr
operator|++
decl_stmt|;
name|CORE_ADDR
name|result
decl_stmt|;
name|ULONGEST
name|reg
decl_stmt|;
name|LONGEST
name|offset
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|DW_OP_lit0
case|:
case|case
name|DW_OP_lit1
case|:
case|case
name|DW_OP_lit2
case|:
case|case
name|DW_OP_lit3
case|:
case|case
name|DW_OP_lit4
case|:
case|case
name|DW_OP_lit5
case|:
case|case
name|DW_OP_lit6
case|:
case|case
name|DW_OP_lit7
case|:
case|case
name|DW_OP_lit8
case|:
case|case
name|DW_OP_lit9
case|:
case|case
name|DW_OP_lit10
case|:
case|case
name|DW_OP_lit11
case|:
case|case
name|DW_OP_lit12
case|:
case|case
name|DW_OP_lit13
case|:
case|case
name|DW_OP_lit14
case|:
case|case
name|DW_OP_lit15
case|:
case|case
name|DW_OP_lit16
case|:
case|case
name|DW_OP_lit17
case|:
case|case
name|DW_OP_lit18
case|:
case|case
name|DW_OP_lit19
case|:
case|case
name|DW_OP_lit20
case|:
case|case
name|DW_OP_lit21
case|:
case|case
name|DW_OP_lit22
case|:
case|case
name|DW_OP_lit23
case|:
case|case
name|DW_OP_lit24
case|:
case|case
name|DW_OP_lit25
case|:
case|case
name|DW_OP_lit26
case|:
case|case
name|DW_OP_lit27
case|:
case|case
name|DW_OP_lit28
case|:
case|case
name|DW_OP_lit29
case|:
case|case
name|DW_OP_lit30
case|:
case|case
name|DW_OP_lit31
case|:
name|result
operator|=
name|op
operator|-
name|DW_OP_lit0
expr_stmt|;
break|break;
case|case
name|DW_OP_addr
case|:
name|result
operator|=
name|read_pointer
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|op_ptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_const1u
case|:
name|result
operator|=
name|read_1u
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|op_ptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_const1s
case|:
name|result
operator|=
name|read_1s
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|op_ptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_const2u
case|:
name|result
operator|=
name|read_2u
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|op_ptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_const2s
case|:
name|result
operator|=
name|read_2s
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|op_ptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_const4u
case|:
name|result
operator|=
name|read_4u
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|op_ptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_const4s
case|:
name|result
operator|=
name|read_4s
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|op_ptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_const8u
case|:
name|result
operator|=
name|read_8u
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|op_ptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_const8s
case|:
name|result
operator|=
name|read_8s
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|op_ptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_constu
case|:
name|result
operator|=
name|read_uleb128
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|op_ptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_consts
case|:
name|result
operator|=
name|read_sleb128
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|op_ptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_reg0
case|:
case|case
name|DW_OP_reg1
case|:
case|case
name|DW_OP_reg2
case|:
case|case
name|DW_OP_reg3
case|:
case|case
name|DW_OP_reg4
case|:
case|case
name|DW_OP_reg5
case|:
case|case
name|DW_OP_reg6
case|:
case|case
name|DW_OP_reg7
case|:
case|case
name|DW_OP_reg8
case|:
case|case
name|DW_OP_reg9
case|:
case|case
name|DW_OP_reg10
case|:
case|case
name|DW_OP_reg11
case|:
case|case
name|DW_OP_reg12
case|:
case|case
name|DW_OP_reg13
case|:
case|case
name|DW_OP_reg14
case|:
case|case
name|DW_OP_reg15
case|:
case|case
name|DW_OP_reg16
case|:
case|case
name|DW_OP_reg17
case|:
case|case
name|DW_OP_reg18
case|:
case|case
name|DW_OP_reg19
case|:
case|case
name|DW_OP_reg20
case|:
case|case
name|DW_OP_reg21
case|:
case|case
name|DW_OP_reg22
case|:
case|case
name|DW_OP_reg23
case|:
case|case
name|DW_OP_reg24
case|:
case|case
name|DW_OP_reg25
case|:
case|case
name|DW_OP_reg26
case|:
case|case
name|DW_OP_reg27
case|:
case|case
name|DW_OP_reg28
case|:
case|case
name|DW_OP_reg29
case|:
case|case
name|DW_OP_reg30
case|:
case|case
name|DW_OP_reg31
case|:
name|get_reg
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|result
argument_list|,
name|context
argument_list|,
name|op
operator|-
name|DW_OP_reg0
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_regx
case|:
name|reg
operator|=
name|read_uleb128
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|op_ptr
argument_list|)
expr_stmt|;
name|get_reg
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|result
argument_list|,
name|context
argument_list|,
name|reg
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_OP_breg0
case|:
case|case
name|DW_OP_breg1
case|:
case|case
name|DW_OP_breg2
case|:
case|case
name|DW_OP_breg3
case|:
case|case
name|DW_OP_breg4
case|:
case|case
name|DW_OP_breg5
case|:
case|case
name|DW_OP_breg6
case|:
case|case
name|DW_OP_breg7
case|:
case|case
name|DW_OP_breg8
case|:
case|case
name|DW_OP_breg9
case|:
case|case
name|DW_OP_breg10
case|:
case|case
name|DW_OP_breg11
case|:
case|case
name|DW_OP_breg12
case|:
case|case
name|DW_OP_breg13
case|:
case|case
name|DW_OP_breg14
case|:
case|case
name|DW_OP_breg15
case|:
case|case
name|DW_OP_breg16
case|:
case|case
name|DW_OP_breg17
case|:
case|case
name|DW_OP_breg18
case|:
case|case
name|DW_OP_breg19
case|:
case|case
name|DW_OP_breg20
case|:
case|case
name|DW_OP_breg21
case|:
case|case
name|DW_OP_breg22
case|:
case|case
name|DW_OP_breg23
case|:
case|case
name|DW_OP_breg24
case|:
case|case
name|DW_OP_breg25
case|:
case|case
name|DW_OP_breg26
case|:
case|case
name|DW_OP_breg27
case|:
case|case
name|DW_OP_breg28
case|:
case|case
name|DW_OP_breg29
case|:
case|case
name|DW_OP_breg30
case|:
case|case
name|DW_OP_breg31
case|:
name|offset
operator|=
name|read_sleb128
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|op_ptr
argument_list|)
expr_stmt|;
name|get_reg
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|result
argument_list|,
name|context
argument_list|,
name|op
operator|-
name|DW_OP_breg0
argument_list|)
expr_stmt|;
name|result
operator|+=
name|offset
expr_stmt|;
break|break;
case|case
name|DW_OP_bregx
case|:
name|reg
operator|=
name|read_uleb128
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|op_ptr
argument_list|)
expr_stmt|;
name|offset
operator|=
name|read_sleb128
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|op_ptr
argument_list|)
expr_stmt|;
name|get_reg
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|result
argument_list|,
name|context
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|result
operator|+=
name|offset
expr_stmt|;
break|break;
case|case
name|DW_OP_dup
case|:
if|if
condition|(
name|stack_elt
operator|<
literal|1
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"execute_stack_op error"
argument_list|)
expr_stmt|;
name|result
operator|=
name|stack
index|[
name|stack_elt
operator|-
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|DW_OP_drop
case|:
if|if
condition|(
operator|--
name|stack_elt
operator|<
literal|0
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"execute_stack_op error"
argument_list|)
expr_stmt|;
goto|goto
name|no_push
goto|;
case|case
name|DW_OP_pick
case|:
name|offset
operator|=
operator|*
name|op_ptr
operator|++
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|stack_elt
operator|-
literal|1
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"execute_stack_op error"
argument_list|)
expr_stmt|;
name|result
operator|=
name|stack
index|[
name|stack_elt
operator|-
literal|1
operator|-
name|offset
index|]
expr_stmt|;
break|break;
case|case
name|DW_OP_over
case|:
if|if
condition|(
name|stack_elt
operator|<
literal|2
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"execute_stack_op error"
argument_list|)
expr_stmt|;
name|result
operator|=
name|stack
index|[
name|stack_elt
operator|-
literal|2
index|]
expr_stmt|;
break|break;
case|case
name|DW_OP_rot
case|:
block|{
name|CORE_ADDR
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|t3
decl_stmt|;
if|if
condition|(
name|stack_elt
operator|<
literal|3
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"execute_stack_op error"
argument_list|)
expr_stmt|;
name|t1
operator|=
name|stack
index|[
name|stack_elt
operator|-
literal|1
index|]
expr_stmt|;
name|t2
operator|=
name|stack
index|[
name|stack_elt
operator|-
literal|2
index|]
expr_stmt|;
name|t3
operator|=
name|stack
index|[
name|stack_elt
operator|-
literal|3
index|]
expr_stmt|;
name|stack
index|[
name|stack_elt
operator|-
literal|1
index|]
operator|=
name|t2
expr_stmt|;
name|stack
index|[
name|stack_elt
operator|-
literal|2
index|]
operator|=
name|t3
expr_stmt|;
name|stack
index|[
name|stack_elt
operator|-
literal|3
index|]
operator|=
name|t1
expr_stmt|;
goto|goto
name|no_push
goto|;
block|}
case|case
name|DW_OP_deref
case|:
case|case
name|DW_OP_deref_size
case|:
case|case
name|DW_OP_abs
case|:
case|case
name|DW_OP_neg
case|:
case|case
name|DW_OP_not
case|:
case|case
name|DW_OP_plus_uconst
case|:
comment|/* Unary operations.  */
if|if
condition|(
operator|--
name|stack_elt
operator|<
literal|0
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"execute_stack_op error"
argument_list|)
expr_stmt|;
name|result
operator|=
name|stack
index|[
name|stack_elt
index|]
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|DW_OP_deref
case|:
block|{
name|char
modifier|*
name|ptr
init|=
operator|(
name|char
operator|*
operator|)
name|result
decl_stmt|;
name|result
operator|=
name|read_pointer
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|ptr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DW_OP_deref_size
case|:
block|{
name|char
modifier|*
name|ptr
init|=
operator|(
name|char
operator|*
operator|)
name|result
decl_stmt|;
switch|switch
condition|(
operator|*
name|op_ptr
operator|++
condition|)
block|{
case|case
literal|1
case|:
name|result
operator|=
name|read_1u
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|ptr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|result
operator|=
name|read_2u
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|ptr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|result
operator|=
name|read_4u
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|ptr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|result
operator|=
name|read_8u
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|ptr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"execute_stack_op error"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|DW_OP_abs
case|:
if|if
condition|(
name|result
operator|<
literal|0
condition|)
name|result
operator|=
operator|-
name|result
expr_stmt|;
break|break;
case|case
name|DW_OP_neg
case|:
name|result
operator|=
operator|-
name|result
expr_stmt|;
break|break;
case|case
name|DW_OP_not
case|:
name|result
operator|=
operator|~
name|result
expr_stmt|;
break|break;
case|case
name|DW_OP_plus_uconst
case|:
name|result
operator|+=
name|read_uleb128
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|op_ptr
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|DW_OP_and
case|:
case|case
name|DW_OP_div
case|:
case|case
name|DW_OP_minus
case|:
case|case
name|DW_OP_mod
case|:
case|case
name|DW_OP_mul
case|:
case|case
name|DW_OP_or
case|:
case|case
name|DW_OP_plus
case|:
case|case
name|DW_OP_le
case|:
case|case
name|DW_OP_ge
case|:
case|case
name|DW_OP_eq
case|:
case|case
name|DW_OP_lt
case|:
case|case
name|DW_OP_gt
case|:
case|case
name|DW_OP_ne
case|:
block|{
comment|/* Binary operations.  */
name|CORE_ADDR
name|first
decl_stmt|,
name|second
decl_stmt|;
if|if
condition|(
operator|(
name|stack_elt
operator|-=
literal|2
operator|)
operator|<
literal|0
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"execute_stack_op error"
argument_list|)
expr_stmt|;
name|second
operator|=
name|stack
index|[
name|stack_elt
index|]
expr_stmt|;
name|first
operator|=
name|stack
index|[
name|stack_elt
operator|+
literal|1
index|]
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|DW_OP_and
case|:
name|result
operator|=
name|second
operator|&
name|first
expr_stmt|;
break|break;
case|case
name|DW_OP_div
case|:
name|result
operator|=
operator|(
name|LONGEST
operator|)
name|second
operator|/
operator|(
name|LONGEST
operator|)
name|first
expr_stmt|;
break|break;
case|case
name|DW_OP_minus
case|:
name|result
operator|=
name|second
operator|-
name|first
expr_stmt|;
break|break;
case|case
name|DW_OP_mod
case|:
name|result
operator|=
operator|(
name|LONGEST
operator|)
name|second
operator|%
operator|(
name|LONGEST
operator|)
name|first
expr_stmt|;
break|break;
case|case
name|DW_OP_mul
case|:
name|result
operator|=
name|second
operator|*
name|first
expr_stmt|;
break|break;
case|case
name|DW_OP_or
case|:
name|result
operator|=
name|second
operator||
name|first
expr_stmt|;
break|break;
case|case
name|DW_OP_plus
case|:
name|result
operator|=
name|second
operator|+
name|first
expr_stmt|;
break|break;
case|case
name|DW_OP_shl
case|:
name|result
operator|=
name|second
operator|<<
name|first
expr_stmt|;
break|break;
case|case
name|DW_OP_shr
case|:
name|result
operator|=
name|second
operator|>>
name|first
expr_stmt|;
break|break;
case|case
name|DW_OP_shra
case|:
name|result
operator|=
operator|(
name|LONGEST
operator|)
name|second
operator|>>
name|first
expr_stmt|;
break|break;
case|case
name|DW_OP_xor
case|:
name|result
operator|=
name|second
operator|^
name|first
expr_stmt|;
break|break;
case|case
name|DW_OP_le
case|:
name|result
operator|=
operator|(
name|LONGEST
operator|)
name|first
operator|<=
operator|(
name|LONGEST
operator|)
name|second
expr_stmt|;
break|break;
case|case
name|DW_OP_ge
case|:
name|result
operator|=
operator|(
name|LONGEST
operator|)
name|first
operator|>=
operator|(
name|LONGEST
operator|)
name|second
expr_stmt|;
break|break;
case|case
name|DW_OP_eq
case|:
name|result
operator|=
operator|(
name|LONGEST
operator|)
name|first
operator|==
operator|(
name|LONGEST
operator|)
name|second
expr_stmt|;
break|break;
case|case
name|DW_OP_lt
case|:
name|result
operator|=
operator|(
name|LONGEST
operator|)
name|first
operator|<
operator|(
name|LONGEST
operator|)
name|second
expr_stmt|;
break|break;
case|case
name|DW_OP_gt
case|:
name|result
operator|=
operator|(
name|LONGEST
operator|)
name|first
operator|>
operator|(
name|LONGEST
operator|)
name|second
expr_stmt|;
break|break;
case|case
name|DW_OP_ne
case|:
name|result
operator|=
operator|(
name|LONGEST
operator|)
name|first
operator|!=
operator|(
name|LONGEST
operator|)
name|second
expr_stmt|;
break|break;
default|default:
comment|/* This label is here just to avoid warning.  */
break|break;
block|}
block|}
break|break;
case|case
name|DW_OP_skip
case|:
name|offset
operator|=
name|read_2s
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|op_ptr
argument_list|)
expr_stmt|;
name|op_ptr
operator|+=
name|offset
expr_stmt|;
goto|goto
name|no_push
goto|;
case|case
name|DW_OP_bra
case|:
if|if
condition|(
operator|--
name|stack_elt
operator|<
literal|0
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"execute_stack_op error"
argument_list|)
expr_stmt|;
name|offset
operator|=
name|read_2s
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|op_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack
index|[
name|stack_elt
index|]
operator|!=
literal|0
condition|)
name|op_ptr
operator|+=
name|offset
expr_stmt|;
goto|goto
name|no_push
goto|;
case|case
name|DW_OP_nop
case|:
goto|goto
name|no_push
goto|;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"execute_stack_op error"
argument_list|)
expr_stmt|;
block|}
comment|/* Most things push a result value.  */
if|if
condition|(
operator|(
name|size_t
operator|)
name|stack_elt
operator|>=
sizeof|sizeof
argument_list|(
name|stack
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|stack
argument_list|)
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"execute_stack_op error"
argument_list|)
expr_stmt|;
name|stack
index|[
operator|++
name|stack_elt
index|]
operator|=
name|result
expr_stmt|;
name|no_push
label|:
empty_stmt|;
block|}
comment|/* We were executing this program to get a value.  It should be      at top of stack.  */
if|if
condition|(
operator|--
name|stack_elt
operator|<
literal|0
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"execute_stack_op error"
argument_list|)
expr_stmt|;
return|return
name|stack
index|[
name|stack_elt
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|update_context
parameter_list|(
name|struct
name|context
modifier|*
name|context
parameter_list|,
name|struct
name|frame_state
modifier|*
name|fs
parameter_list|,
name|int
name|chain
parameter_list|)
block|{
name|struct
name|context
modifier|*
name|orig_context
decl_stmt|;
name|CORE_ADDR
name|cfa
decl_stmt|;
name|long
name|i
decl_stmt|;
name|unwind_tmp_obstack_init
argument_list|()
expr_stmt|;
name|orig_context
operator|=
name|context_alloc
argument_list|()
expr_stmt|;
name|context_cpy
argument_list|(
name|orig_context
argument_list|,
name|context
argument_list|)
expr_stmt|;
comment|/* Compute this frame's CFA.  */
switch|switch
condition|(
name|fs
operator|->
name|cfa_how
condition|)
block|{
case|case
name|CFA_REG_OFFSET
case|:
name|get_reg
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|cfa
argument_list|,
name|context
argument_list|,
name|fs
operator|->
name|cfa_reg
argument_list|)
expr_stmt|;
name|cfa
operator|+=
name|fs
operator|->
name|cfa_offset
expr_stmt|;
break|break;
case|case
name|CFA_EXP
case|:
comment|/* ??? No way of knowing what register number is the stack pointer          to do the same sort of handling as above.  Assume that if the          CFA calculation is so complicated as to require a stack program          that this will not be a problem.  */
block|{
name|char
modifier|*
name|exp
init|=
name|fs
operator|->
name|cfa_exp
decl_stmt|;
name|ULONGEST
name|len
decl_stmt|;
name|len
operator|=
name|read_uleb128
argument_list|(
name|fs
operator|->
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|exp
argument_list|)
expr_stmt|;
name|cfa
operator|=
operator|(
name|CORE_ADDR
operator|)
name|execute_stack_op
argument_list|(
name|fs
operator|->
name|objfile
argument_list|,
name|exp
argument_list|,
name|exp
operator|+
name|len
argument_list|,
name|context
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
name|context
operator|->
name|cfa
operator|=
name|cfa
expr_stmt|;
if|if
condition|(
operator|!
name|chain
condition|)
name|orig_context
operator|->
name|cfa
operator|=
name|cfa
expr_stmt|;
comment|/* Compute the addresses of all registers saved in this frame.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
condition|;
operator|++
name|i
control|)
switch|switch
condition|(
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
index|]
operator|.
name|how
condition|)
block|{
case|case
name|REG_UNSAVED
case|:
if|if
condition|(
name|i
operator|==
name|SP_REGNUM
condition|)
block|{
name|context
operator|->
name|reg
index|[
name|i
index|]
operator|.
name|how
operator|=
name|REG_CTX_VALUE
expr_stmt|;
name|context
operator|->
name|reg
index|[
name|i
index|]
operator|.
name|loc
operator|.
name|addr
operator|=
name|cfa
expr_stmt|;
block|}
else|else
name|context
operator|->
name|reg
index|[
name|i
index|]
operator|.
name|how
operator|=
name|REG_CTX_UNSAVED
expr_stmt|;
break|break;
case|case
name|REG_SAVED_OFFSET
case|:
name|context
operator|->
name|reg
index|[
name|i
index|]
operator|.
name|how
operator|=
name|REG_CTX_SAVED_OFFSET
expr_stmt|;
name|context
operator|->
name|reg
index|[
name|i
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
index|]
operator|.
name|loc
operator|.
name|offset
expr_stmt|;
break|break;
case|case
name|REG_SAVED_REG
case|:
switch|switch
condition|(
name|orig_context
operator|->
name|reg
index|[
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
index|]
operator|.
name|loc
operator|.
name|reg
index|]
operator|.
name|how
condition|)
block|{
case|case
name|REG_CTX_UNSAVED
case|:
name|context
operator|->
name|reg
index|[
name|i
index|]
operator|.
name|how
operator|=
name|REG_CTX_UNSAVED
expr_stmt|;
break|break;
case|case
name|REG_CTX_SAVED_OFFSET
case|:
name|context
operator|->
name|reg
index|[
name|i
index|]
operator|.
name|how
operator|=
name|REG_CTX_SAVED_OFFSET
expr_stmt|;
name|context
operator|->
name|reg
index|[
name|i
index|]
operator|.
name|loc
operator|.
name|offset
operator|=
name|orig_context
operator|->
name|cfa
operator|-
name|context
operator|->
name|cfa
operator|+
name|orig_context
operator|->
name|reg
index|[
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
index|]
operator|.
name|loc
operator|.
name|reg
index|]
operator|.
name|loc
operator|.
name|offset
expr_stmt|;
break|break;
case|case
name|REG_CTX_SAVED_REG
case|:
name|context
operator|->
name|reg
index|[
name|i
index|]
operator|.
name|how
operator|=
name|REG_CTX_SAVED_REG
expr_stmt|;
name|context
operator|->
name|reg
index|[
name|i
index|]
operator|.
name|loc
operator|.
name|reg
operator|=
name|orig_context
operator|->
name|reg
index|[
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
index|]
operator|.
name|loc
operator|.
name|reg
index|]
operator|.
name|loc
operator|.
name|reg
expr_stmt|;
break|break;
case|case
name|REG_CTX_SAVED_ADDR
case|:
name|context
operator|->
name|reg
index|[
name|i
index|]
operator|.
name|how
operator|=
name|REG_CTX_SAVED_ADDR
expr_stmt|;
name|context
operator|->
name|reg
index|[
name|i
index|]
operator|.
name|loc
operator|.
name|addr
operator|=
name|orig_context
operator|->
name|reg
index|[
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
index|]
operator|.
name|loc
operator|.
name|reg
index|]
operator|.
name|loc
operator|.
name|addr
expr_stmt|;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"%s: unknown register rule"
argument_list|,
literal|"?func?"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|REG_SAVED_EXP
case|:
block|{
name|char
modifier|*
name|exp
init|=
name|fs
operator|->
name|regs
operator|.
name|reg
index|[
name|i
index|]
operator|.
name|loc
operator|.
name|exp
decl_stmt|;
name|ULONGEST
name|len
decl_stmt|;
name|CORE_ADDR
name|val
decl_stmt|;
name|len
operator|=
name|read_uleb128
argument_list|(
name|fs
operator|->
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|exp
argument_list|)
expr_stmt|;
name|val
operator|=
name|execute_stack_op
argument_list|(
name|fs
operator|->
name|objfile
argument_list|,
name|exp
argument_list|,
name|exp
operator|+
name|len
argument_list|,
name|orig_context
argument_list|,
name|cfa
argument_list|)
expr_stmt|;
name|context
operator|->
name|reg
index|[
name|i
index|]
operator|.
name|how
operator|=
name|REG_CTX_SAVED_ADDR
expr_stmt|;
name|context
operator|->
name|reg
index|[
name|i
index|]
operator|.
name|loc
operator|.
name|addr
operator|=
name|val
expr_stmt|;
block|}
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"%s: unknown register rule"
argument_list|,
literal|"?func?"
argument_list|)
expr_stmt|;
block|}
name|get_reg
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|context
operator|->
name|ra
argument_list|,
name|context
argument_list|,
name|fs
operator|->
name|retaddr_column
argument_list|)
expr_stmt|;
name|unwind_tmp_obstack_free
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_cie
parameter_list|(
name|ULONGEST
name|cie_id
parameter_list|,
name|int
name|dwarf64
parameter_list|)
block|{
return|return
name|dwarf64
condition|?
operator|(
name|cie_id
operator|==
literal|0xffffffffffffffff
operator|)
else|:
operator|(
name|cie_id
operator|==
literal|0xffffffff
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|compare_fde_unit
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
name|struct
name|fde_unit
modifier|*
modifier|*
name|first
decl_stmt|,
modifier|*
modifier|*
name|second
decl_stmt|;
name|first
operator|=
operator|(
expr|struct
name|fde_unit
operator|*
operator|*
operator|)
name|a
expr_stmt|;
name|second
operator|=
operator|(
expr|struct
name|fde_unit
operator|*
operator|*
operator|)
name|b
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|first
operator|)
operator|->
name|initial_location
operator|>
operator|(
operator|*
name|second
operator|)
operator|->
name|initial_location
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
operator|(
operator|*
name|first
operator|)
operator|->
name|initial_location
operator|<
operator|(
operator|*
name|second
operator|)
operator|->
name|initial_location
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  Build the cie_chunks and fde_chunks tables from informations     found in .debug_frame and .eh_frame sections.  */
end_comment

begin_comment
comment|/* We can handle both of these sections almost in the same way, however there    are some exceptions:    - CIE ID is -1 in debug_frame, but 0 in eh_frame    - eh_frame may contain some more information that are used only by gcc       (eg. personality pointer, LSDA pointer, ...). Most of them we can ignore.    - In debug_frame FDE's item cie_id contains offset of it's parent CIE.      In eh_frame FDE's item cie_id is a relative pointer to the parent CIE.      Anyway we don't need to bother with this, because we are smart enough       to keep the pointer to the parent CIE of oncomming FDEs in 'last_cie'.    - Although debug_frame items can contain Augmentation as well as       eh_frame ones, I have never seen them non-empty. Thus only in eh_frame       we can encounter for example non-absolute pointers (Aug. 'R').                                                                 -- mludvig  */
end_comment

begin_function
specifier|static
name|void
name|parse_frame_info
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|file_ptr
name|frame_offset
parameter_list|,
name|unsigned
name|int
name|frame_size
parameter_list|,
name|int
name|eh_frame
parameter_list|)
block|{
name|bfd
modifier|*
name|abfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
name|asection
modifier|*
name|curr_section_ptr
decl_stmt|;
name|char
modifier|*
name|start
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|end
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|frame_buffer
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|curr_section_name
decl_stmt|,
modifier|*
name|aug_data
decl_stmt|;
name|struct
name|cie_unit
modifier|*
name|last_cie
init|=
name|NULL
decl_stmt|;
name|int
name|last_dup_fde
init|=
literal|0
decl_stmt|;
name|int
name|aug_len
decl_stmt|,
name|i
decl_stmt|;
name|CORE_ADDR
name|curr_section_vma
init|=
literal|0
decl_stmt|;
name|unwind_tmp_obstack_init
argument_list|()
expr_stmt|;
name|frame_buffer
operator|=
name|dwarf2_read_section
argument_list|(
name|objfile
argument_list|,
name|frame_offset
argument_list|,
name|frame_size
argument_list|)
expr_stmt|;
name|start
operator|=
name|frame_buffer
expr_stmt|;
name|end
operator|=
name|frame_buffer
operator|+
name|frame_size
expr_stmt|;
name|curr_section_name
operator|=
name|eh_frame
condition|?
literal|".eh_frame"
else|:
literal|".debug_frame"
expr_stmt|;
name|curr_section_ptr
operator|=
name|bfd_get_section_by_name
argument_list|(
name|abfd
argument_list|,
name|curr_section_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|curr_section_ptr
condition|)
name|curr_section_vma
operator|=
name|curr_section_ptr
operator|->
name|vma
expr_stmt|;
if|if
condition|(
name|start
condition|)
block|{
while|while
condition|(
name|start
operator|<
name|end
condition|)
block|{
name|unsigned
name|long
name|length
decl_stmt|;
name|ULONGEST
name|cie_id
decl_stmt|;
name|ULONGEST
name|unit_offset
init|=
name|start
operator|-
name|frame_buffer
decl_stmt|;
name|int
name|bytes_read
decl_stmt|,
name|dwarf64
decl_stmt|;
name|char
modifier|*
name|block_end
decl_stmt|;
name|length
operator|=
name|read_initial_length
argument_list|(
name|abfd
argument_list|,
name|start
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|start
operator|+=
name|bytes_read
expr_stmt|;
name|dwarf64
operator|=
operator|(
name|bytes_read
operator|==
literal|12
operator|)
expr_stmt|;
name|block_end
operator|=
name|start
operator|+
name|length
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
name|start
operator|=
name|block_end
expr_stmt|;
continue|continue;
block|}
name|cie_id
operator|=
name|read_length
argument_list|(
name|abfd
argument_list|,
name|start
argument_list|,
operator|&
name|bytes_read
argument_list|,
name|dwarf64
argument_list|)
expr_stmt|;
name|start
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
operator|(
name|eh_frame
operator|&&
name|cie_id
operator|==
literal|0
operator|)
operator|||
name|is_cie
argument_list|(
name|cie_id
argument_list|,
name|dwarf64
argument_list|)
condition|)
block|{
name|struct
name|cie_unit
modifier|*
name|cie
init|=
name|cie_unit_alloc
argument_list|()
decl_stmt|;
name|char
modifier|*
name|aug
decl_stmt|;
name|cie
operator|->
name|objfile
operator|=
name|objfile
expr_stmt|;
name|cie
operator|->
name|next
operator|=
name|cie_chunks
expr_stmt|;
name|cie_chunks
operator|=
name|cie
expr_stmt|;
name|cie
operator|->
name|objfile
operator|=
name|objfile
expr_stmt|;
name|cie
operator|->
name|offset
operator|=
name|unit_offset
expr_stmt|;
name|start
operator|++
expr_stmt|;
comment|/* version */
name|cie
operator|->
name|augmentation
operator|=
name|aug
operator|=
name|start
expr_stmt|;
while|while
condition|(
operator|*
name|start
operator|++
condition|)
empty_stmt|;
comment|/* Skips last NULL as well */
name|cie
operator|->
name|code_align
operator|=
name|read_uleb128
argument_list|(
name|abfd
argument_list|,
operator|&
name|start
argument_list|)
expr_stmt|;
name|cie
operator|->
name|data_align
operator|=
name|read_sleb128
argument_list|(
name|abfd
argument_list|,
operator|&
name|start
argument_list|)
expr_stmt|;
name|cie
operator|->
name|ra
operator|=
name|read_1u
argument_list|(
name|abfd
argument_list|,
operator|&
name|start
argument_list|)
expr_stmt|;
comment|/* Augmentation: 	         z      Indicates that a uleb128 is present to size the 	         augmentation section. 	         L      Indicates the encoding (and thus presence) of 	         an LSDA pointer in the FDE augmentation. 	         R      Indicates a non-default pointer encoding for 	         FDE code pointers. 	         P      Indicates the presence of an encoding + language 	         personality routine in the CIE augmentation.  	         [This info comes from GCC's dwarf2out.c] 	       */
if|if
condition|(
operator|*
name|aug
operator|==
literal|'z'
condition|)
block|{
name|aug_len
operator|=
name|read_uleb128
argument_list|(
name|abfd
argument_list|,
operator|&
name|start
argument_list|)
expr_stmt|;
name|aug_data
operator|=
name|start
expr_stmt|;
name|start
operator|+=
name|aug_len
expr_stmt|;
operator|++
name|aug
expr_stmt|;
block|}
name|cie
operator|->
name|data
operator|=
name|start
expr_stmt|;
name|cie
operator|->
name|data_length
operator|=
name|block_end
operator|-
name|cie
operator|->
name|data
expr_stmt|;
while|while
condition|(
operator|*
name|aug
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|aug
index|[
literal|0
index|]
operator|==
literal|'e'
operator|&&
name|aug
index|[
literal|1
index|]
operator|==
literal|'h'
condition|)
block|{
name|aug_data
operator|+=
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
expr_stmt|;
name|aug
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aug
index|[
literal|0
index|]
operator|==
literal|'R'
condition|)
name|cie
operator|->
name|addr_encoding
operator|=
operator|*
name|aug_data
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|aug
index|[
literal|0
index|]
operator|==
literal|'P'
condition|)
block|{
name|CORE_ADDR
name|pers_addr
decl_stmt|;
name|int
name|pers_addr_enc
decl_stmt|;
name|pers_addr_enc
operator|=
operator|*
name|aug_data
operator|++
expr_stmt|;
comment|/* We don't need pers_addr value and so we  		         don't care about it's encoding.  */
name|pers_addr
operator|=
name|read_encoded_pointer
argument_list|(
name|abfd
argument_list|,
operator|&
name|aug_data
argument_list|,
name|pers_addr_enc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|aug
index|[
literal|0
index|]
operator|==
literal|'L'
operator|&&
name|eh_frame
condition|)
block|{
name|int
name|lsda_addr_enc
decl_stmt|;
comment|/* Perhaps we should save this to CIE for later use? 		         Do we need it for something in GDB?  */
name|lsda_addr_enc
operator|=
operator|*
name|aug_data
operator|++
expr_stmt|;
block|}
else|else
name|warning
argument_list|(
literal|"CFI warning: unknown augmentation \"%c\""
literal|" in \"%s\" of\n"
literal|"\t%s"
argument_list|,
name|aug
index|[
literal|0
index|]
argument_list|,
name|curr_section_name
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
name|aug
operator|++
expr_stmt|;
block|}
name|last_cie
operator|=
name|cie
expr_stmt|;
block|}
else|else
block|{
name|struct
name|fde_unit
modifier|*
name|fde
decl_stmt|;
name|struct
name|cie_unit
modifier|*
name|cie
decl_stmt|;
name|int
name|dup
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|init_loc
decl_stmt|;
comment|/* We assume that debug_frame is in order  	         CIE,FDE,CIE,FDE,FDE,...  and thus the CIE for this FDE 	         should be stored in last_cie pointer. If not, we'll  	         try to find it by the older way.  */
if|if
condition|(
name|last_cie
condition|)
name|cie
operator|=
name|last_cie
expr_stmt|;
else|else
block|{
name|warning
argument_list|(
literal|"CFI: last_cie == NULL. "
literal|"Perhaps a malformed %s section in '%s'...?\n"
argument_list|,
name|curr_section_name
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
name|cie
operator|=
name|cie_chunks
expr_stmt|;
while|while
condition|(
name|cie
condition|)
block|{
if|if
condition|(
name|cie
operator|->
name|objfile
operator|==
name|objfile
condition|)
block|{
if|if
condition|(
name|eh_frame
operator|&&
operator|(
name|cie
operator|->
name|offset
operator|==
operator|(
name|unit_offset
operator|+
name|bytes_read
operator|-
name|cie_id
operator|)
operator|)
condition|)
break|break;
if|if
condition|(
operator|!
name|eh_frame
operator|&&
operator|(
name|cie
operator|->
name|offset
operator|==
name|cie_id
operator|)
condition|)
break|break;
block|}
name|cie
operator|=
name|cie
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cie
condition|)
name|error
argument_list|(
literal|"CFI: can't find CIE pointer"
argument_list|)
expr_stmt|;
block|}
name|init_loc
operator|=
name|read_encoded_pointer
argument_list|(
name|abfd
argument_list|,
operator|&
name|start
argument_list|,
name|cie
operator|->
name|addr_encoding
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pointer_encoding
argument_list|(
name|cie
operator|->
name|addr_encoding
argument_list|)
condition|)
block|{
case|case
name|PE_absptr
case|:
break|break;
case|case
name|PE_pcrel
case|:
comment|/* start-frame_buffer gives offset from  		     the beginning of actual section.  */
name|init_loc
operator|+=
name|curr_section_vma
operator|+
name|start
operator|-
name|frame_buffer
expr_stmt|;
break|break;
default|default:
name|warning
argument_list|(
literal|"CFI: Unsupported pointer encoding\n"
argument_list|)
expr_stmt|;
block|}
comment|/* For relocatable objects we must add an offset telling 	         where the section is actually mapped in the memory.  */
name|init_loc
operator|+=
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we have both .debug_frame and .eh_frame present in  	         a file, we must eliminate duplicate FDEs. For now we'll  	         run through all entries in fde_chunks and check it one  	         by one. Perhaps in the future we can implement a faster  	         searching algorithm.  */
comment|/* eh_frame==2 indicates, that this file has an already  	         parsed .debug_frame too. When eh_frame==1 it means, that no 	         .debug_frame is present and thus we don't need to check for 	         duplicities. eh_frame==0 means, that we parse .debug_frame 	         and don't need to care about duplicate FDEs, because 	         .debug_frame is parsed first.  */
if|if
condition|(
name|eh_frame
operator|==
literal|2
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|eh_frame
operator|==
literal|2
operator|&&
name|i
operator|<
name|fde_chunks
operator|.
name|elems
condition|;
name|i
operator|++
control|)
block|{
comment|/* We assume that FDEs in .debug_frame and .eh_frame  		       have the same order (if they are present, of course). 		       If we find a duplicate entry for one FDE and save 		       it's index to last_dup_fde it's very likely, that  		       we'll find an entry for the following FDE right after  		       the previous one. Thus in many cases we'll run this  		       loop only once.  */
name|last_dup_fde
operator|=
operator|(
name|last_dup_fde
operator|+
name|i
operator|)
operator|%
name|fde_chunks
operator|.
name|elems
expr_stmt|;
if|if
condition|(
name|fde_chunks
operator|.
name|array
index|[
name|last_dup_fde
index|]
operator|->
name|initial_location
operator|==
name|init_loc
condition|)
block|{
name|dup
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* Allocate a new entry only if this FDE isn't a duplicate of 	         something we have already seen.   */
if|if
condition|(
operator|!
name|dup
condition|)
block|{
name|fde_chunks_need_space
argument_list|()
expr_stmt|;
name|fde
operator|=
name|fde_unit_alloc
argument_list|()
expr_stmt|;
name|fde_chunks
operator|.
name|array
index|[
name|fde_chunks
operator|.
name|elems
operator|++
index|]
operator|=
name|fde
expr_stmt|;
name|fde
operator|->
name|initial_location
operator|=
name|init_loc
expr_stmt|;
name|fde
operator|->
name|address_range
operator|=
name|read_encoded_pointer
argument_list|(
name|abfd
argument_list|,
operator|&
name|start
argument_list|,
name|cie
operator|->
name|addr_encoding
argument_list|)
expr_stmt|;
name|fde
operator|->
name|cie_ptr
operator|=
name|cie
expr_stmt|;
comment|/* Here we intentionally ignore augmentation data 		     from FDE, because we don't need them.  */
if|if
condition|(
name|cie
operator|->
name|augmentation
index|[
literal|0
index|]
operator|==
literal|'z'
condition|)
name|start
operator|+=
name|read_uleb128
argument_list|(
name|abfd
argument_list|,
operator|&
name|start
argument_list|)
expr_stmt|;
name|fde
operator|->
name|data
operator|=
name|start
expr_stmt|;
name|fde
operator|->
name|data_length
operator|=
name|block_end
operator|-
name|start
expr_stmt|;
block|}
block|}
name|start
operator|=
name|block_end
expr_stmt|;
block|}
name|qsort
argument_list|(
name|fde_chunks
operator|.
name|array
argument_list|,
name|fde_chunks
operator|.
name|elems
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fde_unit
operator|*
argument_list|)
argument_list|,
name|compare_fde_unit
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* We must parse both .debug_frame section and .eh_frame because   * not all frames must be present in both of these sections. */
end_comment

begin_function
name|void
name|dwarf2_build_frame_info
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|int
name|after_debug_frame
init|=
literal|0
decl_stmt|;
comment|/* If we have .debug_frame then the parser is called with       eh_frame==0 for .debug_frame and eh_frame==2 for .eh_frame,       otherwise it's only called once for .eh_frame with argument       eh_frame==1.  */
if|if
condition|(
name|dwarf_frame_offset
condition|)
block|{
name|parse_frame_info
argument_list|(
name|objfile
argument_list|,
name|dwarf_frame_offset
argument_list|,
name|dwarf_frame_size
argument_list|,
literal|0
comment|/* = debug_frame */
argument_list|)
expr_stmt|;
name|after_debug_frame
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|dwarf_eh_frame_offset
condition|)
name|parse_frame_info
argument_list|(
name|objfile
argument_list|,
name|dwarf_eh_frame_offset
argument_list|,
name|dwarf_eh_frame_size
argument_list|,
literal|1
comment|/* = eh_frame */
operator|+
name|after_debug_frame
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the frame address.  */
end_comment

begin_function
name|CORE_ADDR
name|cfi_read_fp
parameter_list|()
block|{
name|struct
name|context
modifier|*
name|context
decl_stmt|;
name|struct
name|frame_state
modifier|*
name|fs
decl_stmt|;
name|CORE_ADDR
name|cfa
decl_stmt|;
name|unwind_tmp_obstack_init
argument_list|()
expr_stmt|;
name|context
operator|=
name|context_alloc
argument_list|()
expr_stmt|;
name|fs
operator|=
name|frame_state_alloc
argument_list|()
expr_stmt|;
name|context
operator|->
name|ra
operator|=
name|read_pc
argument_list|()
operator|+
literal|1
expr_stmt|;
name|frame_state_for
argument_list|(
name|context
argument_list|,
name|fs
argument_list|)
expr_stmt|;
name|update_context
argument_list|(
name|context
argument_list|,
name|fs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cfa
operator|=
name|context
operator|->
name|cfa
expr_stmt|;
name|unwind_tmp_obstack_free
argument_list|()
expr_stmt|;
return|return
name|cfa
return|;
block|}
end_function

begin_comment
comment|/* Store the frame address.  This function is not used.  */
end_comment

begin_function
name|void
name|cfi_write_fp
parameter_list|(
name|CORE_ADDR
name|val
parameter_list|)
block|{
name|struct
name|context
modifier|*
name|context
decl_stmt|;
name|struct
name|frame_state
modifier|*
name|fs
decl_stmt|;
name|unwind_tmp_obstack_init
argument_list|()
expr_stmt|;
name|context
operator|=
name|context_alloc
argument_list|()
expr_stmt|;
name|fs
operator|=
name|frame_state_alloc
argument_list|()
expr_stmt|;
name|context
operator|->
name|ra
operator|=
name|read_pc
argument_list|()
operator|+
literal|1
expr_stmt|;
name|frame_state_for
argument_list|(
name|context
argument_list|,
name|fs
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|cfa_how
operator|==
name|CFA_REG_OFFSET
condition|)
block|{
name|val
operator|-=
name|fs
operator|->
name|cfa_offset
expr_stmt|;
name|write_register_gen
argument_list|(
name|fs
operator|->
name|cfa_reg
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|val
argument_list|)
expr_stmt|;
block|}
else|else
name|warning
argument_list|(
literal|"Can't write fp."
argument_list|)
expr_stmt|;
name|unwind_tmp_obstack_free
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Restore the machine to the state it had before the current frame    was created.  */
end_comment

begin_function
name|void
name|cfi_pop_frame
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
name|char
name|regbuf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|int
name|regnum
decl_stmt|;
name|fi
operator|=
name|get_current_frame
argument_list|()
expr_stmt|;
for|for
control|(
name|regnum
operator|=
literal|0
init|;
name|regnum
operator|<
name|NUM_REGS
condition|;
name|regnum
operator|++
control|)
block|{
name|get_reg
argument_list|(
name|regbuf
argument_list|,
name|UNWIND_CONTEXT
argument_list|(
name|fi
argument_list|)
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
name|write_register_bytes
argument_list|(
name|REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
argument_list|,
name|regbuf
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|write_register
argument_list|(
name|PC_REGNUM
argument_list|,
name|UNWIND_CONTEXT
argument_list|(
name|fi
argument_list|)
operator|->
name|ra
argument_list|)
expr_stmt|;
name|flush_cached_frames
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determine the address of the calling function's frame.  */
end_comment

begin_function
name|CORE_ADDR
name|cfi_frame_chain
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
name|struct
name|context
modifier|*
name|context
decl_stmt|;
name|struct
name|frame_state
modifier|*
name|fs
decl_stmt|;
name|CORE_ADDR
name|cfa
decl_stmt|;
name|unwind_tmp_obstack_init
argument_list|()
expr_stmt|;
name|context
operator|=
name|context_alloc
argument_list|()
expr_stmt|;
name|fs
operator|=
name|frame_state_alloc
argument_list|()
expr_stmt|;
name|context_cpy
argument_list|(
name|context
argument_list|,
name|UNWIND_CONTEXT
argument_list|(
name|fi
argument_list|)
argument_list|)
expr_stmt|;
comment|/* outermost frame */
if|if
condition|(
name|context
operator|->
name|ra
operator|==
literal|0
condition|)
block|{
name|unwind_tmp_obstack_free
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
name|frame_state_for
argument_list|(
name|context
argument_list|,
name|fs
argument_list|)
expr_stmt|;
name|update_context
argument_list|(
name|context
argument_list|,
name|fs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cfa
operator|=
name|context
operator|->
name|cfa
expr_stmt|;
name|unwind_tmp_obstack_free
argument_list|()
expr_stmt|;
return|return
name|cfa
return|;
block|}
end_function

begin_comment
comment|/* Sets the pc of the frame.  */
end_comment

begin_function
name|void
name|cfi_init_frame_pc
parameter_list|(
name|int
name|fromleaf
parameter_list|,
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
if|if
condition|(
name|fi
operator|->
name|next
condition|)
name|get_reg
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|fi
operator|->
name|pc
operator|)
argument_list|,
name|UNWIND_CONTEXT
argument_list|(
name|fi
operator|->
name|next
argument_list|)
argument_list|,
name|PC_REGNUM
argument_list|)
expr_stmt|;
else|else
name|fi
operator|->
name|pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize unwind context informations of the frame.  */
end_comment

begin_function
name|void
name|cfi_init_extra_frame_info
parameter_list|(
name|int
name|fromleaf
parameter_list|,
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
name|struct
name|frame_state
modifier|*
name|fs
decl_stmt|;
name|unwind_tmp_obstack_init
argument_list|()
expr_stmt|;
name|fs
operator|=
name|frame_state_alloc
argument_list|()
expr_stmt|;
name|fi
operator|->
name|context
operator|=
name|frame_obstack_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|context
argument_list|)
argument_list|)
expr_stmt|;
name|UNWIND_CONTEXT
argument_list|(
name|fi
argument_list|)
operator|->
name|reg
operator|=
name|frame_obstack_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|context_reg
argument_list|)
operator|*
name|NUM_REGS
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|UNWIND_CONTEXT
argument_list|(
name|fi
argument_list|)
operator|->
name|reg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|context_reg
argument_list|)
operator|*
name|NUM_REGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|next
condition|)
block|{
name|context_cpy
argument_list|(
name|UNWIND_CONTEXT
argument_list|(
name|fi
argument_list|)
argument_list|,
name|UNWIND_CONTEXT
argument_list|(
name|fi
operator|->
name|next
argument_list|)
argument_list|)
expr_stmt|;
name|frame_state_for
argument_list|(
name|UNWIND_CONTEXT
argument_list|(
name|fi
argument_list|)
argument_list|,
name|fs
argument_list|)
expr_stmt|;
name|update_context
argument_list|(
name|UNWIND_CONTEXT
argument_list|(
name|fi
argument_list|)
argument_list|,
name|fs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|UNWIND_CONTEXT
argument_list|(
name|fi
argument_list|)
operator|->
name|ra
operator|=
name|fi
operator|->
name|pc
operator|+
literal|1
expr_stmt|;
name|frame_state_for
argument_list|(
name|UNWIND_CONTEXT
argument_list|(
name|fi
argument_list|)
argument_list|,
name|fs
argument_list|)
expr_stmt|;
name|update_context
argument_list|(
name|UNWIND_CONTEXT
argument_list|(
name|fi
argument_list|)
argument_list|,
name|fs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|unwind_tmp_obstack_free
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Obtain return address of the frame.  */
end_comment

begin_function
name|CORE_ADDR
name|cfi_get_ra
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
return|return
name|UNWIND_CONTEXT
argument_list|(
name|fi
argument_list|)
operator|->
name|ra
return|;
block|}
end_function

begin_comment
comment|/* Find register number REGNUM relative to FRAME and put its    (raw) contents in *RAW_BUFFER.  Set *OPTIMIZED if the variable    was optimized out (and thus can't be fetched).  If the variable    was fetched from memory, set *ADDRP to where it was fetched from,    otherwise it was fetched from a register.     The argument RAW_BUFFER must point to aligned memory.  */
end_comment

begin_function
name|void
name|cfi_get_saved_register
parameter_list|(
name|char
modifier|*
name|raw_buffer
parameter_list|,
name|int
modifier|*
name|optimized
parameter_list|,
name|CORE_ADDR
modifier|*
name|addrp
parameter_list|,
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|regnum
parameter_list|,
name|enum
name|lval_type
modifier|*
name|lval
parameter_list|)
block|{
if|if
condition|(
operator|!
name|target_has_registers
condition|)
name|error
argument_list|(
literal|"No registers."
argument_list|)
expr_stmt|;
comment|/* Normal systems don't optimize out things with register numbers.  */
if|if
condition|(
name|optimized
operator|!=
name|NULL
condition|)
operator|*
name|optimized
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|addrp
condition|)
comment|/* default assumption: not found in memory */
operator|*
name|addrp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|frame
operator|->
name|next
condition|)
block|{
name|read_register_gen
argument_list|(
name|regnum
argument_list|,
name|raw_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|lval
operator|!=
name|NULL
condition|)
operator|*
name|lval
operator|=
name|lval_register
expr_stmt|;
if|if
condition|(
name|addrp
operator|!=
name|NULL
condition|)
operator|*
name|addrp
operator|=
name|REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|frame
operator|=
name|frame
operator|->
name|next
expr_stmt|;
switch|switch
condition|(
name|UNWIND_CONTEXT
argument_list|(
name|frame
argument_list|)
operator|->
name|reg
index|[
name|regnum
index|]
operator|.
name|how
condition|)
block|{
case|case
name|REG_CTX_UNSAVED
case|:
name|read_register_gen
argument_list|(
name|regnum
argument_list|,
name|raw_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|lval
operator|!=
name|NULL
condition|)
operator|*
name|lval
operator|=
name|not_lval
expr_stmt|;
if|if
condition|(
name|optimized
operator|!=
name|NULL
condition|)
operator|*
name|optimized
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|REG_CTX_SAVED_OFFSET
case|:
name|target_read_memory
argument_list|(
name|UNWIND_CONTEXT
argument_list|(
name|frame
argument_list|)
operator|->
name|cfa
operator|+
name|UNWIND_CONTEXT
argument_list|(
name|frame
argument_list|)
operator|->
name|reg
index|[
name|regnum
index|]
operator|.
name|loc
operator|.
name|offset
argument_list|,
name|raw_buffer
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lval
operator|!=
name|NULL
condition|)
operator|*
name|lval
operator|=
name|lval_memory
expr_stmt|;
if|if
condition|(
name|addrp
operator|!=
name|NULL
condition|)
operator|*
name|addrp
operator|=
name|UNWIND_CONTEXT
argument_list|(
name|frame
argument_list|)
operator|->
name|cfa
operator|+
name|UNWIND_CONTEXT
argument_list|(
name|frame
argument_list|)
operator|->
name|reg
index|[
name|regnum
index|]
operator|.
name|loc
operator|.
name|offset
expr_stmt|;
break|break;
case|case
name|REG_CTX_SAVED_REG
case|:
name|read_register_gen
argument_list|(
name|UNWIND_CONTEXT
argument_list|(
name|frame
argument_list|)
operator|->
name|reg
index|[
name|regnum
index|]
operator|.
name|loc
operator|.
name|reg
argument_list|,
name|raw_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|lval
operator|!=
name|NULL
condition|)
operator|*
name|lval
operator|=
name|lval_register
expr_stmt|;
if|if
condition|(
name|addrp
operator|!=
name|NULL
condition|)
operator|*
name|addrp
operator|=
name|REGISTER_BYTE
argument_list|(
name|UNWIND_CONTEXT
argument_list|(
name|frame
argument_list|)
operator|->
name|reg
index|[
name|regnum
index|]
operator|.
name|loc
operator|.
name|reg
argument_list|)
expr_stmt|;
break|break;
case|case
name|REG_CTX_SAVED_ADDR
case|:
name|target_read_memory
argument_list|(
name|UNWIND_CONTEXT
argument_list|(
name|frame
argument_list|)
operator|->
name|reg
index|[
name|regnum
index|]
operator|.
name|loc
operator|.
name|addr
argument_list|,
name|raw_buffer
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lval
operator|!=
name|NULL
condition|)
operator|*
name|lval
operator|=
name|lval_memory
expr_stmt|;
if|if
condition|(
name|addrp
operator|!=
name|NULL
condition|)
operator|*
name|addrp
operator|=
name|UNWIND_CONTEXT
argument_list|(
name|frame
argument_list|)
operator|->
name|reg
index|[
name|regnum
index|]
operator|.
name|loc
operator|.
name|addr
expr_stmt|;
break|break;
case|case
name|REG_CTX_VALUE
case|:
name|memcpy
argument_list|(
name|raw_buffer
argument_list|,
operator|&
name|UNWIND_CONTEXT
argument_list|(
name|frame
argument_list|)
operator|->
name|reg
index|[
name|regnum
index|]
operator|.
name|loc
operator|.
name|addr
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lval
operator|!=
name|NULL
condition|)
operator|*
name|lval
operator|=
name|not_lval
expr_stmt|;
if|if
condition|(
name|optimized
operator|!=
name|NULL
condition|)
operator|*
name|optimized
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"cfi_get_saved_register: unknown register rule"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  Return the register that the function uses for a frame pointer,     plus any necessary offset to be applied to the register before     any frame pointer offsets.  */
end_comment

begin_function
name|void
name|cfi_virtual_frame_pointer
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|int
modifier|*
name|frame_reg
parameter_list|,
name|LONGEST
modifier|*
name|frame_offset
parameter_list|)
block|{
name|struct
name|context
modifier|*
name|context
decl_stmt|;
name|struct
name|frame_state
modifier|*
name|fs
decl_stmt|;
name|unwind_tmp_obstack_init
argument_list|()
expr_stmt|;
name|context
operator|=
name|context_alloc
argument_list|()
expr_stmt|;
name|fs
operator|=
name|frame_state_alloc
argument_list|()
expr_stmt|;
name|context
operator|->
name|ra
operator|=
name|read_pc
argument_list|()
operator|+
literal|1
expr_stmt|;
name|frame_state_for
argument_list|(
name|context
argument_list|,
name|fs
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|cfa_how
operator|==
name|CFA_REG_OFFSET
condition|)
block|{
operator|*
name|frame_reg
operator|=
name|fs
operator|->
name|cfa_reg
expr_stmt|;
operator|*
name|frame_offset
operator|=
name|fs
operator|->
name|cfa_offset
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"dwarf cfi error: CFA is not defined as CFA_REG_OFFSET"
argument_list|)
expr_stmt|;
name|unwind_tmp_obstack_free
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

