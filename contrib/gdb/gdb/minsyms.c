begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* GDB routines for manipulating the minimal symbol tables.    Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001    Free Software Foundation, Inc.    Contributed by Cygnus Support, using pieces from other GDB modules.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file contains support routines for creating, manipulating, and    destroying minimal symbol tables.     Minimal symbol tables are used to hold some very basic information about    all defined global symbols (text, data, bss, abs, etc).  The only two    required pieces of information are the symbol's name and the address    associated with that symbol.     In many cases, even if a file was compiled with no special options for    debugging at all, as long as was not stripped it will contain sufficient    information to build useful minimal symbol tables using this structure.     Even when a file contains enough debugging information to build a full    symbol table, these minimal symbols are still useful for quickly mapping    between names and addresses, and vice versa.  They are also sometimes used    to figure out what full symbol table entries need to be read in. */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"cp-abi.h"
end_include

begin_comment
comment|/* Accumulate the minimal symbols for each objfile in bunches of BUNCH_SIZE.    At the end, copy them all into one newly allocated location on an objfile's    symbol obstack.  */
end_comment

begin_define
define|#
directive|define
name|BUNCH_SIZE
value|127
end_define

begin_struct
struct|struct
name|msym_bunch
block|{
name|struct
name|msym_bunch
modifier|*
name|next
decl_stmt|;
name|struct
name|minimal_symbol
name|contents
index|[
name|BUNCH_SIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Bunch currently being filled up.    The next field points to chain of filled bunches.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|msym_bunch
modifier|*
name|msym_bunch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of slots filled in current bunch.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|msym_bunch_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Total number of minimal symbols recorded so far for the objfile.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|msym_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compute a hash code based using the same criteria as `strcmp_iw'.  */
end_comment

begin_function
name|unsigned
name|int
name|msymbol_hash_iw
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|unsigned
name|int
name|hash
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|string
operator|&&
operator|*
name|string
operator|!=
literal|'('
condition|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|string
argument_list|)
condition|)
operator|++
name|string
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|&&
operator|*
name|string
operator|!=
literal|'('
condition|)
block|{
name|hash
operator|=
name|hash
operator|*
literal|67
operator|+
operator|*
name|string
operator|-
literal|113
expr_stmt|;
operator|++
name|string
expr_stmt|;
block|}
block|}
return|return
name|hash
operator|%
name|MINIMAL_SYMBOL_HASH_SIZE
return|;
block|}
end_function

begin_comment
comment|/* Compute a hash code for a string.  */
end_comment

begin_function
name|unsigned
name|int
name|msymbol_hash
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|unsigned
name|int
name|hash
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
operator|*
name|string
condition|;
operator|++
name|string
control|)
name|hash
operator|=
name|hash
operator|*
literal|67
operator|+
operator|*
name|string
operator|-
literal|113
expr_stmt|;
return|return
name|hash
operator|%
name|MINIMAL_SYMBOL_HASH_SIZE
return|;
block|}
end_function

begin_comment
comment|/* Add the minimal symbol SYM to an objfile's minsym hash table, TABLE.  */
end_comment

begin_function
name|void
name|add_minsym_to_hash_table
parameter_list|(
name|struct
name|minimal_symbol
modifier|*
name|sym
parameter_list|,
name|struct
name|minimal_symbol
modifier|*
modifier|*
name|table
parameter_list|)
block|{
if|if
condition|(
name|sym
operator|->
name|hash_next
operator|==
name|NULL
condition|)
block|{
name|unsigned
name|int
name|hash
init|=
name|msymbol_hash
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
decl_stmt|;
name|sym
operator|->
name|hash_next
operator|=
name|table
index|[
name|hash
index|]
expr_stmt|;
name|table
index|[
name|hash
index|]
operator|=
name|sym
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add the minimal symbol SYM to an objfile's minsym demangled hash table,    TABLE.  */
end_comment

begin_function
specifier|static
name|void
name|add_minsym_to_demangled_hash_table
parameter_list|(
name|struct
name|minimal_symbol
modifier|*
name|sym
parameter_list|,
name|struct
name|minimal_symbol
modifier|*
modifier|*
name|table
parameter_list|)
block|{
if|if
condition|(
name|sym
operator|->
name|demangled_hash_next
operator|==
name|NULL
condition|)
block|{
name|unsigned
name|int
name|hash
init|=
name|msymbol_hash_iw
argument_list|(
name|SYMBOL_DEMANGLED_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
decl_stmt|;
name|sym
operator|->
name|demangled_hash_next
operator|=
name|table
index|[
name|hash
index|]
expr_stmt|;
name|table
index|[
name|hash
index|]
operator|=
name|sym
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Look through all the current minimal symbol tables and find the    first minimal symbol that matches NAME.  If OBJF is non-NULL, limit    the search to that objfile.  If SFILE is non-NULL, limit the search    to that source file.  Returns a pointer to the minimal symbol that    matches, or NULL if no match is found.     Note:  One instance where there may be duplicate minimal symbols with    the same name is when the symbol tables for a shared library and the    symbol tables for an executable contain global symbols with the same    names (the dynamic linker deals with the duplication). */
end_comment

begin_function
name|struct
name|minimal_symbol
modifier|*
name|lookup_minimal_symbol
parameter_list|(
specifier|register
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|sfile
parameter_list|,
name|struct
name|objfile
modifier|*
name|objf
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|found_symbol
init|=
name|NULL
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|found_file_symbol
init|=
name|NULL
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|trampoline_symbol
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|hash
init|=
name|msymbol_hash
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|dem_hash
init|=
name|msymbol_hash_iw
argument_list|(
name|name
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|SOFUN_ADDRESS_MAYBE_MISSING
if|if
condition|(
name|sfile
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|strrchr
argument_list|(
name|sfile
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|sfile
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|objfile
operator|=
name|object_files
init|;
name|objfile
operator|!=
name|NULL
operator|&&
name|found_symbol
operator|==
name|NULL
condition|;
name|objfile
operator|=
name|objfile
operator|->
name|next
control|)
block|{
if|if
condition|(
name|objf
operator|==
name|NULL
operator|||
name|objf
operator|==
name|objfile
condition|)
block|{
comment|/* Do two passes: the first over the ordinary hash table, 	     and the second over the demangled hash table.  */
name|int
name|pass
decl_stmt|;
for|for
control|(
name|pass
operator|=
literal|1
init|;
name|pass
operator|<=
literal|2
operator|&&
name|found_symbol
operator|==
name|NULL
condition|;
name|pass
operator|++
control|)
block|{
comment|/* Select hash list according to pass.  */
if|if
condition|(
name|pass
operator|==
literal|1
condition|)
name|msymbol
operator|=
name|objfile
operator|->
name|msymbol_hash
index|[
name|hash
index|]
expr_stmt|;
else|else
name|msymbol
operator|=
name|objfile
operator|->
name|msymbol_demangled_hash
index|[
name|dem_hash
index|]
expr_stmt|;
while|while
condition|(
name|msymbol
operator|!=
name|NULL
operator|&&
name|found_symbol
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|SYMBOL_MATCHES_NAME
argument_list|(
name|msymbol
argument_list|,
name|name
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
condition|)
block|{
case|case
name|mst_file_text
case|:
case|case
name|mst_file_data
case|:
case|case
name|mst_file_bss
case|:
ifdef|#
directive|ifdef
name|SOFUN_ADDRESS_MAYBE_MISSING
if|if
condition|(
name|sfile
operator|==
name|NULL
operator|||
name|STREQ
argument_list|(
name|msymbol
operator|->
name|filename
argument_list|,
name|sfile
argument_list|)
condition|)
name|found_file_symbol
operator|=
name|msymbol
expr_stmt|;
else|#
directive|else
comment|/* We have neither the ability nor the need to                            deal with the SFILE parameter.  If we find                            more than one symbol, just return the latest                            one (the user can't expect useful behavior in                            that case).  */
name|found_file_symbol
operator|=
name|msymbol
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|mst_solib_trampoline
case|:
comment|/* If a trampoline symbol is found, we prefer to                            keep looking for the *real* symbol. If the                            actual symbol is not found, then we'll use the                            trampoline entry. */
if|if
condition|(
name|trampoline_symbol
operator|==
name|NULL
condition|)
name|trampoline_symbol
operator|=
name|msymbol
expr_stmt|;
break|break;
case|case
name|mst_unknown
case|:
default|default:
name|found_symbol
operator|=
name|msymbol
expr_stmt|;
break|break;
block|}
block|}
comment|/* Find the next symbol on the hash chain.  */
if|if
condition|(
name|pass
operator|==
literal|1
condition|)
name|msymbol
operator|=
name|msymbol
operator|->
name|hash_next
expr_stmt|;
else|else
name|msymbol
operator|=
name|msymbol
operator|->
name|demangled_hash_next
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* External symbols are best.  */
if|if
condition|(
name|found_symbol
condition|)
return|return
name|found_symbol
return|;
comment|/* File-local symbols are next best.  */
if|if
condition|(
name|found_file_symbol
condition|)
return|return
name|found_file_symbol
return|;
comment|/* Symbols for shared library trampolines are next best.  */
if|if
condition|(
name|trampoline_symbol
condition|)
return|return
name|trampoline_symbol
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Look through all the current minimal symbol tables and find the    first minimal symbol that matches NAME and of text type.      If OBJF is non-NULL, limit    the search to that objfile.  If SFILE is non-NULL, limit the search    to that source file.  Returns a pointer to the minimal symbol that    matches, or NULL if no match is found.  */
end_comment

begin_function
name|struct
name|minimal_symbol
modifier|*
name|lookup_minimal_symbol_text
parameter_list|(
specifier|register
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|sfile
parameter_list|,
name|struct
name|objfile
modifier|*
name|objf
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|found_symbol
init|=
name|NULL
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|found_file_symbol
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|SOFUN_ADDRESS_MAYBE_MISSING
if|if
condition|(
name|sfile
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|strrchr
argument_list|(
name|sfile
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|sfile
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|objfile
operator|=
name|object_files
init|;
name|objfile
operator|!=
name|NULL
operator|&&
name|found_symbol
operator|==
name|NULL
condition|;
name|objfile
operator|=
name|objfile
operator|->
name|next
control|)
block|{
if|if
condition|(
name|objf
operator|==
name|NULL
operator|||
name|objf
operator|==
name|objfile
condition|)
block|{
for|for
control|(
name|msymbol
operator|=
name|objfile
operator|->
name|msymbols
init|;
name|msymbol
operator|!=
name|NULL
operator|&&
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
operator|!=
name|NULL
operator|&&
name|found_symbol
operator|==
name|NULL
condition|;
name|msymbol
operator|++
control|)
block|{
if|if
condition|(
name|SYMBOL_MATCHES_NAME
argument_list|(
name|msymbol
argument_list|,
name|name
argument_list|)
operator|&&
operator|(
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|==
name|mst_text
operator|||
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|==
name|mst_file_text
operator|)
condition|)
block|{
switch|switch
condition|(
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
condition|)
block|{
case|case
name|mst_file_text
case|:
ifdef|#
directive|ifdef
name|SOFUN_ADDRESS_MAYBE_MISSING
if|if
condition|(
name|sfile
operator|==
name|NULL
operator|||
name|STREQ
argument_list|(
name|msymbol
operator|->
name|filename
argument_list|,
name|sfile
argument_list|)
condition|)
name|found_file_symbol
operator|=
name|msymbol
expr_stmt|;
else|#
directive|else
comment|/* We have neither the ability nor the need to 		         deal with the SFILE parameter.  If we find 		         more than one symbol, just return the latest 		         one (the user can't expect useful behavior in 		         that case).  */
name|found_file_symbol
operator|=
name|msymbol
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
name|found_symbol
operator|=
name|msymbol
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
comment|/* External symbols are best.  */
if|if
condition|(
name|found_symbol
condition|)
return|return
name|found_symbol
return|;
comment|/* File-local symbols are next best.  */
if|if
condition|(
name|found_file_symbol
condition|)
return|return
name|found_file_symbol
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Look through all the current minimal symbol tables and find the    first minimal symbol that matches NAME and of solib trampoline type.      If OBJF is non-NULL, limit    the search to that objfile.  If SFILE is non-NULL, limit the search    to that source file.  Returns a pointer to the minimal symbol that    matches, or NULL if no match is found.  */
end_comment

begin_function
name|struct
name|minimal_symbol
modifier|*
name|lookup_minimal_symbol_solib_trampoline
parameter_list|(
specifier|register
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|sfile
parameter_list|,
name|struct
name|objfile
modifier|*
name|objf
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|found_symbol
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|SOFUN_ADDRESS_MAYBE_MISSING
if|if
condition|(
name|sfile
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|strrchr
argument_list|(
name|sfile
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|sfile
operator|=
name|p
operator|+
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|objfile
operator|=
name|object_files
init|;
name|objfile
operator|!=
name|NULL
operator|&&
name|found_symbol
operator|==
name|NULL
condition|;
name|objfile
operator|=
name|objfile
operator|->
name|next
control|)
block|{
if|if
condition|(
name|objf
operator|==
name|NULL
operator|||
name|objf
operator|==
name|objfile
condition|)
block|{
for|for
control|(
name|msymbol
operator|=
name|objfile
operator|->
name|msymbols
init|;
name|msymbol
operator|!=
name|NULL
operator|&&
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
operator|!=
name|NULL
operator|&&
name|found_symbol
operator|==
name|NULL
condition|;
name|msymbol
operator|++
control|)
block|{
if|if
condition|(
name|SYMBOL_MATCHES_NAME
argument_list|(
name|msymbol
argument_list|,
name|name
argument_list|)
operator|&&
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|==
name|mst_solib_trampoline
condition|)
return|return
name|msymbol
return|;
block|}
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Search through the minimal symbol table for each objfile and find    the symbol whose address is the largest address that is still less    than or equal to PC, and matches SECTION (if non-null).  Returns a    pointer to the minimal symbol if such a symbol is found, or NULL if    PC is not in a suitable range.  Note that we need to look through    ALL the minimal symbol tables before deciding on the symbol that    comes closest to the specified PC.  This is because objfiles can    overlap, for example objfile A has .text at 0x100 and .data at    0x40000 and objfile B has .text at 0x234 and .data at 0x40048.  */
end_comment

begin_function
name|struct
name|minimal_symbol
modifier|*
name|lookup_minimal_symbol_by_pc_section
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|asection
modifier|*
name|section
parameter_list|)
block|{
name|int
name|lo
decl_stmt|;
name|int
name|hi
decl_stmt|;
name|int
name|new
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|best_symbol
init|=
name|NULL
decl_stmt|;
comment|/* pc has to be in a known section. This ensures that anything beyond      the end of the last segment doesn't appear to be part of the last      function in the last segment.  */
if|if
condition|(
name|find_pc_section
argument_list|(
name|pc
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|objfile
operator|=
name|object_files
init|;
name|objfile
operator|!=
name|NULL
condition|;
name|objfile
operator|=
name|objfile
operator|->
name|next
control|)
block|{
comment|/* If this objfile has a minimal symbol table, go search it using          a binary search.  Note that a minimal symbol table always consists          of at least two symbols, a "real" symbol and the terminating          "null symbol".  If there are no real symbols, then there is no          minimal symbol table at all. */
if|if
condition|(
operator|(
name|msymbol
operator|=
name|objfile
operator|->
name|msymbols
operator|)
operator|!=
name|NULL
condition|)
block|{
name|lo
operator|=
literal|0
expr_stmt|;
name|hi
operator|=
name|objfile
operator|->
name|minimal_symbol_count
operator|-
literal|1
expr_stmt|;
comment|/* This code assumes that the minimal symbols are sorted by 	     ascending address values.  If the pc value is greater than or 	     equal to the first symbol's address, then some symbol in this 	     minimal symbol table is a suitable candidate for being the 	     "best" symbol.  This includes the last real symbol, for cases 	     where the pc value is larger than any address in this vector.  	     By iterating until the address associated with the current 	     hi index (the endpoint of the test interval) is less than 	     or equal to the desired pc value, we accomplish two things: 	     (1) the case where the pc value is larger than any minimal 	     symbol address is trivially solved, (2) the address associated 	     with the hi index is always the one we want when the interation 	     terminates.  In essence, we are iterating the test interval 	     down until the pc value is pushed out of it from the high end.  	     Warning: this code is trickier than it would appear at first. */
comment|/* Should also require that pc is<= end of objfile.  FIXME! */
if|if
condition|(
name|pc
operator|>=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
operator|&
name|msymbol
index|[
name|lo
index|]
argument_list|)
condition|)
block|{
while|while
condition|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
operator|&
name|msymbol
index|[
name|hi
index|]
argument_list|)
operator|>
name|pc
condition|)
block|{
comment|/* pc is still strictly less than highest address */
comment|/* Note "new" will always be>= lo */
name|new
operator|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
operator|&
name|msymbol
index|[
name|new
index|]
argument_list|)
operator|>=
name|pc
operator|)
operator|||
operator|(
name|lo
operator|==
name|new
operator|)
condition|)
block|{
name|hi
operator|=
name|new
expr_stmt|;
block|}
else|else
block|{
name|lo
operator|=
name|new
expr_stmt|;
block|}
block|}
comment|/* If we have multiple symbols at the same address, we want 	         hi to point to the last one.  That way we can find the 	         right symbol if it has an index greater than hi.  */
while|while
condition|(
name|hi
operator|<
name|objfile
operator|->
name|minimal_symbol_count
operator|-
literal|1
operator|&&
operator|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
operator|&
name|msymbol
index|[
name|hi
index|]
argument_list|)
operator|==
name|SYMBOL_VALUE_ADDRESS
argument_list|(
operator|&
name|msymbol
index|[
name|hi
operator|+
literal|1
index|]
argument_list|)
operator|)
condition|)
name|hi
operator|++
expr_stmt|;
comment|/* The minimal symbol indexed by hi now is the best one in this 	         objfile's minimal symbol table.  See if it is the best one 	         overall. */
comment|/* Skip any absolute symbols.  This is apparently what adb 	         and dbx do, and is needed for the CM-5.  There are two 	         known possible problems: (1) on ELF, apparently end, edata, 	         etc. are absolute.  Not sure ignoring them here is a big 	         deal, but if we want to use them, the fix would go in 	         elfread.c.  (2) I think shared library entry points on the 	         NeXT are absolute.  If we want special handling for this 	         it probably should be triggered by a special 	         mst_abs_or_lib or some such.  */
while|while
condition|(
name|hi
operator|>=
literal|0
operator|&&
name|msymbol
index|[
name|hi
index|]
operator|.
name|type
operator|==
name|mst_abs
condition|)
operator|--
name|hi
expr_stmt|;
comment|/* If "section" specified, skip any symbol from wrong section */
comment|/* This is the new code that distinguishes it from the old function */
if|if
condition|(
name|section
condition|)
while|while
condition|(
name|hi
operator|>=
literal|0
comment|/* Some types of debug info, such as COFF, 			  don't fill the bfd_section member, so don't 			  throw away symbols on those platforms.  */
operator|&&
name|SYMBOL_BFD_SECTION
argument_list|(
operator|&
name|msymbol
index|[
name|hi
index|]
argument_list|)
operator|!=
name|NULL
operator|&&
name|SYMBOL_BFD_SECTION
argument_list|(
operator|&
name|msymbol
index|[
name|hi
index|]
argument_list|)
operator|!=
name|section
condition|)
operator|--
name|hi
expr_stmt|;
if|if
condition|(
name|hi
operator|>=
literal|0
operator|&&
operator|(
operator|(
name|best_symbol
operator|==
name|NULL
operator|)
operator|||
operator|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|best_symbol
argument_list|)
operator|<
name|SYMBOL_VALUE_ADDRESS
argument_list|(
operator|&
name|msymbol
index|[
name|hi
index|]
argument_list|)
operator|)
operator|)
condition|)
block|{
name|best_symbol
operator|=
operator|&
name|msymbol
index|[
name|hi
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
operator|(
name|best_symbol
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Backward compatibility: search through the minimal symbol table     for a matching PC (no section given) */
end_comment

begin_function
name|struct
name|minimal_symbol
modifier|*
name|lookup_minimal_symbol_by_pc
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
return|return
name|lookup_minimal_symbol_by_pc_section
argument_list|(
name|pc
argument_list|,
name|find_pc_mapped_section
argument_list|(
name|pc
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SOFUN_ADDRESS_MAYBE_MISSING
end_ifdef

begin_function
name|CORE_ADDR
name|find_stab_function_addr
parameter_list|(
name|char
modifier|*
name|namestring
parameter_list|,
name|char
modifier|*
name|filename
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|msym
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|n
decl_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|namestring
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|p
operator|=
name|namestring
expr_stmt|;
name|n
operator|=
name|p
operator|-
name|namestring
expr_stmt|;
name|p
operator|=
name|alloca
argument_list|(
name|n
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|p
argument_list|,
name|namestring
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|p
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
name|msym
operator|=
name|lookup_minimal_symbol
argument_list|(
name|p
argument_list|,
name|filename
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|msym
operator|==
name|NULL
condition|)
block|{
comment|/* Sun Fortran appends an underscore to the minimal symbol name,          try again with an appended underscore if the minimal symbol          was not found.  */
name|p
index|[
name|n
index|]
operator|=
literal|'_'
expr_stmt|;
name|p
index|[
name|n
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|msym
operator|=
name|lookup_minimal_symbol
argument_list|(
name|p
argument_list|,
name|filename
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msym
operator|==
name|NULL
operator|&&
name|filename
operator|!=
name|NULL
condition|)
block|{
comment|/* Try again without the filename. */
name|p
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
name|msym
operator|=
name|lookup_minimal_symbol
argument_list|(
name|p
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msym
operator|==
name|NULL
operator|&&
name|filename
operator|!=
name|NULL
condition|)
block|{
comment|/* And try again for Sun Fortran, but without the filename. */
name|p
index|[
name|n
index|]
operator|=
literal|'_'
expr_stmt|;
name|p
index|[
name|n
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|msym
operator|=
name|lookup_minimal_symbol
argument_list|(
name|p
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
return|return
name|msym
operator|==
name|NULL
condition|?
literal|0
else|:
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msym
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SOFUN_ADDRESS_MAYBE_MISSING */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Return leading symbol character for a BFD. If BFD is NULL,    return the leading symbol character from the main objfile.  */
end_comment

begin_function_decl
specifier|static
name|int
name|get_symbol_leading_char
parameter_list|(
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|get_symbol_leading_char
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
if|if
condition|(
name|abfd
operator|!=
name|NULL
condition|)
return|return
name|bfd_get_symbol_leading_char
argument_list|(
name|abfd
argument_list|)
return|;
if|if
condition|(
name|symfile_objfile
operator|!=
name|NULL
operator|&&
name|symfile_objfile
operator|->
name|obfd
operator|!=
name|NULL
condition|)
return|return
name|bfd_get_symbol_leading_char
argument_list|(
name|symfile_objfile
operator|->
name|obfd
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Prepare to start collecting minimal symbols.  Note that presetting    msym_bunch_index to BUNCH_SIZE causes the first call to save a minimal    symbol to allocate the memory for the first bunch. */
end_comment

begin_function
name|void
name|init_minimal_symbol_collection
parameter_list|(
name|void
parameter_list|)
block|{
name|msym_count
operator|=
literal|0
expr_stmt|;
name|msym_bunch
operator|=
name|NULL
expr_stmt|;
name|msym_bunch_index
operator|=
name|BUNCH_SIZE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|prim_record_minimal_symbol
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|CORE_ADDR
name|address
parameter_list|,
name|enum
name|minimal_symbol_type
name|ms_type
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|int
name|section
decl_stmt|;
switch|switch
condition|(
name|ms_type
condition|)
block|{
case|case
name|mst_text
case|:
case|case
name|mst_file_text
case|:
case|case
name|mst_solib_trampoline
case|:
name|section
operator|=
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|mst_data
case|:
case|case
name|mst_file_data
case|:
name|section
operator|=
name|SECT_OFF_DATA
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|mst_bss
case|:
case|case
name|mst_file_bss
case|:
name|section
operator|=
name|SECT_OFF_BSS
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
break|break;
default|default:
name|section
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|prim_record_minimal_symbol_and_info
argument_list|(
name|name
argument_list|,
name|address
argument_list|,
name|ms_type
argument_list|,
name|NULL
argument_list|,
name|section
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record a minimal symbol in the msym bunches.  Returns the symbol    newly created.  */
end_comment

begin_function
name|struct
name|minimal_symbol
modifier|*
name|prim_record_minimal_symbol_and_info
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|CORE_ADDR
name|address
parameter_list|,
name|enum
name|minimal_symbol_type
name|ms_type
parameter_list|,
name|char
modifier|*
name|info
parameter_list|,
name|int
name|section
parameter_list|,
name|asection
modifier|*
name|bfd_section
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
specifier|register
name|struct
name|msym_bunch
modifier|*
name|new
decl_stmt|;
specifier|register
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
if|if
condition|(
name|ms_type
operator|==
name|mst_file_text
condition|)
block|{
comment|/* Don't put gcc_compiled, __gnu_compiled_cplus, and friends into          the minimal symbols, because if there is also another symbol          at the same address (e.g. the first function of the file),          lookup_minimal_symbol_by_pc would have no way of getting the          right one.  */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'g'
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|GCC_COMPILED_FLAG_SYMBOL
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
name|GCC2_COMPILED_FLAG_SYMBOL
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|{
specifier|const
name|char
modifier|*
name|tempstring
init|=
name|name
decl_stmt|;
if|if
condition|(
name|tempstring
index|[
literal|0
index|]
operator|==
name|get_symbol_leading_char
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
condition|)
operator|++
name|tempstring
expr_stmt|;
if|if
condition|(
name|STREQN
argument_list|(
name|tempstring
argument_list|,
literal|"__gnu_compiled"
argument_list|,
literal|14
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|msym_bunch_index
operator|==
name|BUNCH_SIZE
condition|)
block|{
name|new
operator|=
operator|(
expr|struct
name|msym_bunch
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|msym_bunch
argument_list|)
argument_list|)
expr_stmt|;
name|msym_bunch_index
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|msym_bunch
expr_stmt|;
name|msym_bunch
operator|=
name|new
expr_stmt|;
block|}
name|msymbol
operator|=
operator|&
name|msym_bunch
operator|->
name|contents
index|[
name|msym_bunch_index
index|]
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
operator|=
name|obsavestring
argument_list|(
operator|(
name|char
operator|*
operator|)
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
name|SYMBOL_INIT_LANGUAGE_SPECIFIC
argument_list|(
name|msymbol
argument_list|,
name|language_unknown
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
operator|=
name|address
expr_stmt|;
name|SYMBOL_SECTION
argument_list|(
name|msymbol
argument_list|)
operator|=
name|section
expr_stmt|;
name|SYMBOL_BFD_SECTION
argument_list|(
name|msymbol
argument_list|)
operator|=
name|bfd_section
expr_stmt|;
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|=
name|ms_type
expr_stmt|;
comment|/* FIXME:  This info, if it remains, needs its own field.  */
name|MSYMBOL_INFO
argument_list|(
name|msymbol
argument_list|)
operator|=
name|info
expr_stmt|;
comment|/* FIXME! */
comment|/* The hash pointers must be cleared! If they're not,      add_minsym_to_hash_table will NOT add this msymbol to the hash table. */
name|msymbol
operator|->
name|hash_next
operator|=
name|NULL
expr_stmt|;
name|msymbol
operator|->
name|demangled_hash_next
operator|=
name|NULL
expr_stmt|;
name|msym_bunch_index
operator|++
expr_stmt|;
name|msym_count
operator|++
expr_stmt|;
name|OBJSTAT
argument_list|(
name|objfile
argument_list|,
name|n_minsyms
operator|++
argument_list|)
expr_stmt|;
return|return
name|msymbol
return|;
block|}
end_function

begin_comment
comment|/* Compare two minimal symbols by address and return a signed result based    on unsigned comparisons, so that we sort into unsigned numeric order.      Within groups with the same address, sort by name.  */
end_comment

begin_function
specifier|static
name|int
name|compare_minimal_symbols
parameter_list|(
specifier|const
name|void
modifier|*
name|fn1p
parameter_list|,
specifier|const
name|void
modifier|*
name|fn2p
parameter_list|)
block|{
specifier|register
specifier|const
name|struct
name|minimal_symbol
modifier|*
name|fn1
decl_stmt|;
specifier|register
specifier|const
name|struct
name|minimal_symbol
modifier|*
name|fn2
decl_stmt|;
name|fn1
operator|=
operator|(
specifier|const
expr|struct
name|minimal_symbol
operator|*
operator|)
name|fn1p
expr_stmt|;
name|fn2
operator|=
operator|(
specifier|const
expr|struct
name|minimal_symbol
operator|*
operator|)
name|fn2p
expr_stmt|;
if|if
condition|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|fn1
argument_list|)
operator|<
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|fn2
argument_list|)
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* addr 1 is less than addr 2 */
block|}
elseif|else
if|if
condition|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|fn1
argument_list|)
operator|>
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|fn2
argument_list|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
comment|/* addr 1 is greater than addr 2 */
block|}
else|else
comment|/* addrs are equal: sort by name */
block|{
name|char
modifier|*
name|name1
init|=
name|SYMBOL_NAME
argument_list|(
name|fn1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name2
init|=
name|SYMBOL_NAME
argument_list|(
name|fn2
argument_list|)
decl_stmt|;
if|if
condition|(
name|name1
operator|&&
name|name2
condition|)
comment|/* both have names */
return|return
name|strcmp
argument_list|(
name|name1
argument_list|,
name|name2
argument_list|)
return|;
elseif|else
if|if
condition|(
name|name2
condition|)
return|return
literal|1
return|;
comment|/* fn1 has no name, so it is "less" */
elseif|else
if|if
condition|(
name|name1
condition|)
comment|/* fn2 has no name, so it is "less" */
return|return
operator|-
literal|1
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
comment|/* neither has a name, so they're equal. */
block|}
block|}
end_function

begin_comment
comment|/* Discard the currently collected minimal symbols, if any.  If we wish    to save them for later use, we must have already copied them somewhere    else before calling this function.     FIXME:  We could allocate the minimal symbol bunches on their own    obstack and then simply blow the obstack away when we are done with    it.  Is it worth the extra trouble though? */
end_comment

begin_function
specifier|static
name|void
name|do_discard_minimal_symbols_cleanup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
specifier|register
name|struct
name|msym_bunch
modifier|*
name|next
decl_stmt|;
while|while
condition|(
name|msym_bunch
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|msym_bunch
operator|->
name|next
expr_stmt|;
name|xfree
argument_list|(
name|msym_bunch
argument_list|)
expr_stmt|;
name|msym_bunch
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
name|struct
name|cleanup
modifier|*
name|make_cleanup_discard_minimal_symbols
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|make_cleanup
argument_list|(
name|do_discard_minimal_symbols_cleanup
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compact duplicate entries out of a minimal symbol table by walking    through the table and compacting out entries with duplicate addresses    and matching names.  Return the number of entries remaining.     On entry, the table resides between msymbol[0] and msymbol[mcount].    On exit, it resides between msymbol[0] and msymbol[result_count].     When files contain multiple sources of symbol information, it is    possible for the minimal symbol table to contain many duplicate entries.    As an example, SVR4 systems use ELF formatted object files, which    usually contain at least two different types of symbol tables (a    standard ELF one and a smaller dynamic linking table), as well as    DWARF debugging information for files compiled with -g.     Without compacting, the minimal symbol table for gdb itself contains    over a 1000 duplicates, about a third of the total table size.  Aside    from the potential trap of not noticing that two successive entries    identify the same location, this duplication impacts the time required    to linearly scan the table, which is done in a number of places.  So we    just do one linear scan here and toss out the duplicates.     Note that we are not concerned here about recovering the space that    is potentially freed up, because the strings themselves are allocated    on the symbol_obstack, and will get automatically freed when the symbol    table is freed.  The caller can free up the unused minimal symbols at    the end of the compacted region if their allocation strategy allows it.     Also note we only go up to the next to last entry within the loop    and then copy the last entry explicitly after the loop terminates.     Since the different sources of information for each symbol may    have different levels of "completeness", we may have duplicates    that have one entry with type "mst_unknown" and the other with a    known type.  So if the one we are leaving alone has type mst_unknown,    overwrite its type with the type from the one we are compacting out.  */
end_comment

begin_function
specifier|static
name|int
name|compact_minimal_symbols
parameter_list|(
name|struct
name|minimal_symbol
modifier|*
name|msymbol
parameter_list|,
name|int
name|mcount
parameter_list|,
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|copyfrom
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|copyto
decl_stmt|;
if|if
condition|(
name|mcount
operator|>
literal|0
condition|)
block|{
name|copyfrom
operator|=
name|copyto
operator|=
name|msymbol
expr_stmt|;
while|while
condition|(
name|copyfrom
operator|<
name|msymbol
operator|+
name|mcount
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|copyfrom
argument_list|)
operator|==
name|SYMBOL_VALUE_ADDRESS
argument_list|(
operator|(
name|copyfrom
operator|+
literal|1
operator|)
argument_list|)
operator|&&
operator|(
name|STREQ
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|copyfrom
argument_list|)
argument_list|,
name|SYMBOL_NAME
argument_list|(
operator|(
name|copyfrom
operator|+
literal|1
operator|)
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|MSYMBOL_TYPE
argument_list|(
operator|(
name|copyfrom
operator|+
literal|1
operator|)
argument_list|)
operator|==
name|mst_unknown
condition|)
block|{
name|MSYMBOL_TYPE
argument_list|(
operator|(
name|copyfrom
operator|+
literal|1
operator|)
argument_list|)
operator|=
name|MSYMBOL_TYPE
argument_list|(
name|copyfrom
argument_list|)
expr_stmt|;
block|}
name|copyfrom
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|copyto
operator|++
operator|=
operator|*
name|copyfrom
operator|++
expr_stmt|;
block|}
operator|*
name|copyto
operator|++
operator|=
operator|*
name|copyfrom
operator|++
expr_stmt|;
name|mcount
operator|=
name|copyto
operator|-
name|msymbol
expr_stmt|;
block|}
return|return
operator|(
name|mcount
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Build (or rebuild) the minimal symbol hash tables.  This is necessary    after compacting or sorting the table since the entries move around    thus causing the internal minimal_symbol pointers to become jumbled. */
end_comment

begin_function
specifier|static
name|void
name|build_minimal_symbol_hash_tables
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msym
decl_stmt|;
comment|/* Clear the hash tables. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MINIMAL_SYMBOL_HASH_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|objfile
operator|->
name|msymbol_hash
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|objfile
operator|->
name|msymbol_demangled_hash
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Now, (re)insert the actual entries. */
for|for
control|(
name|i
operator|=
name|objfile
operator|->
name|minimal_symbol_count
operator|,
name|msym
operator|=
name|objfile
operator|->
name|msymbols
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
operator|,
name|msym
operator|++
control|)
block|{
name|msym
operator|->
name|hash_next
operator|=
literal|0
expr_stmt|;
name|add_minsym_to_hash_table
argument_list|(
name|msym
argument_list|,
name|objfile
operator|->
name|msymbol_hash
argument_list|)
expr_stmt|;
name|msym
operator|->
name|demangled_hash_next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|SYMBOL_DEMANGLED_NAME
argument_list|(
name|msym
argument_list|)
operator|!=
name|NULL
condition|)
name|add_minsym_to_demangled_hash_table
argument_list|(
name|msym
argument_list|,
name|objfile
operator|->
name|msymbol_demangled_hash
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add the minimal symbols in the existing bunches to the objfile's official    minimal symbol table.  In most cases there is no minimal symbol table yet    for this objfile, and the existing bunches are used to create one.  Once    in a while (for shared libraries for example), we add symbols (e.g. common    symbols) to an existing objfile.     Because of the way minimal symbols are collected, we generally have no way    of knowing what source language applies to any particular minimal symbol.    Specifically, we have no way of knowing if the minimal symbol comes from a    C++ compilation unit or not.  So for the sake of supporting cached    demangled C++ names, we have no choice but to try and demangle each new one    that comes in.  If the demangling succeeds, then we assume it is a C++    symbol and set the symbol's language and demangled name fields    appropriately.  Note that in order to avoid unnecessary demanglings, and    allocating obstack space that subsequently can't be freed for the demangled    names, we mark all newly added symbols with language_auto.  After    compaction of the minimal symbols, we go back and scan the entire minimal    symbol table looking for these new symbols.  For each new symbol we attempt    to demangle it, and if successful, record it as a language_cplus symbol    and cache the demangled form on the symbol obstack.  Symbols which don't    demangle are marked as language_unknown symbols, which inhibits future    attempts to demangle them if we later add more minimal symbols. */
end_comment

begin_function
name|void
name|install_minimal_symbols
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
specifier|register
name|int
name|bindex
decl_stmt|;
specifier|register
name|int
name|mcount
decl_stmt|;
specifier|register
name|struct
name|msym_bunch
modifier|*
name|bunch
decl_stmt|;
specifier|register
name|struct
name|minimal_symbol
modifier|*
name|msymbols
decl_stmt|;
name|int
name|alloc_count
decl_stmt|;
specifier|register
name|char
name|leading_char
decl_stmt|;
if|if
condition|(
name|msym_count
operator|>
literal|0
condition|)
block|{
comment|/* Allocate enough space in the obstack, into which we will gather the          bunches of new and existing minimal symbols, sort them, and then          compact out the duplicate entries.  Once we have a final table,          we will give back the excess space.  */
name|alloc_count
operator|=
name|msym_count
operator|+
name|objfile
operator|->
name|minimal_symbol_count
operator|+
literal|1
expr_stmt|;
name|obstack_blank
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
name|alloc_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|minimal_symbol
argument_list|)
argument_list|)
expr_stmt|;
name|msymbols
operator|=
operator|(
expr|struct
name|minimal_symbol
operator|*
operator|)
name|obstack_base
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
comment|/* Copy in the existing minimal symbols, if there are any.  */
if|if
condition|(
name|objfile
operator|->
name|minimal_symbol_count
condition|)
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|msymbols
argument_list|,
operator|(
name|char
operator|*
operator|)
name|objfile
operator|->
name|msymbols
argument_list|,
name|objfile
operator|->
name|minimal_symbol_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|minimal_symbol
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Walk through the list of minimal symbol bunches, adding each symbol          to the new contiguous array of symbols.  Note that we start with the          current, possibly partially filled bunch (thus we use the current          msym_bunch_index for the first bunch we copy over), and thereafter          each bunch is full. */
name|mcount
operator|=
name|objfile
operator|->
name|minimal_symbol_count
expr_stmt|;
name|leading_char
operator|=
name|get_symbol_leading_char
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
expr_stmt|;
for|for
control|(
name|bunch
operator|=
name|msym_bunch
init|;
name|bunch
operator|!=
name|NULL
condition|;
name|bunch
operator|=
name|bunch
operator|->
name|next
control|)
block|{
for|for
control|(
name|bindex
operator|=
literal|0
init|;
name|bindex
operator|<
name|msym_bunch_index
condition|;
name|bindex
operator|++
operator|,
name|mcount
operator|++
control|)
block|{
name|msymbols
index|[
name|mcount
index|]
operator|=
name|bunch
operator|->
name|contents
index|[
name|bindex
index|]
expr_stmt|;
name|SYMBOL_LANGUAGE
argument_list|(
operator|&
name|msymbols
index|[
name|mcount
index|]
argument_list|)
operator|=
name|language_auto
expr_stmt|;
if|if
condition|(
name|SYMBOL_NAME
argument_list|(
operator|&
name|msymbols
index|[
name|mcount
index|]
argument_list|)
index|[
literal|0
index|]
operator|==
name|leading_char
condition|)
block|{
name|SYMBOL_NAME
argument_list|(
operator|&
name|msymbols
index|[
name|mcount
index|]
argument_list|)
operator|++
expr_stmt|;
block|}
block|}
name|msym_bunch_index
operator|=
name|BUNCH_SIZE
expr_stmt|;
block|}
comment|/* Sort the minimal symbols by address.  */
name|qsort
argument_list|(
name|msymbols
argument_list|,
name|mcount
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|minimal_symbol
argument_list|)
argument_list|,
name|compare_minimal_symbols
argument_list|)
expr_stmt|;
comment|/* Compact out any duplicates, and free up whatever space we are          no longer using.  */
name|mcount
operator|=
name|compact_minimal_symbols
argument_list|(
name|msymbols
argument_list|,
name|mcount
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|obstack_blank
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
operator|(
name|mcount
operator|+
literal|1
operator|-
name|alloc_count
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|minimal_symbol
argument_list|)
argument_list|)
expr_stmt|;
name|msymbols
operator|=
operator|(
expr|struct
name|minimal_symbol
operator|*
operator|)
name|obstack_finish
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
comment|/* We also terminate the minimal symbol table with a "null symbol",          which is *not* included in the size of the table.  This makes it          easier to find the end of the table when we are handed a pointer          to some symbol in the middle of it.  Zero out the fields in the          "null symbol" allocated at the end of the array.  Note that the          symbol count does *not* include this null symbol, which is why it          is indexed by mcount and not mcount-1. */
name|SYMBOL_NAME
argument_list|(
operator|&
name|msymbols
index|[
name|mcount
index|]
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|SYMBOL_VALUE_ADDRESS
argument_list|(
operator|&
name|msymbols
index|[
name|mcount
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
name|MSYMBOL_INFO
argument_list|(
operator|&
name|msymbols
index|[
name|mcount
index|]
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|MSYMBOL_TYPE
argument_list|(
operator|&
name|msymbols
index|[
name|mcount
index|]
argument_list|)
operator|=
name|mst_unknown
expr_stmt|;
name|SYMBOL_INIT_LANGUAGE_SPECIFIC
argument_list|(
operator|&
name|msymbols
index|[
name|mcount
index|]
argument_list|,
name|language_unknown
argument_list|)
expr_stmt|;
comment|/* Attach the minimal symbol table to the specified objfile.          The strings themselves are also located in the symbol_obstack          of this objfile.  */
name|objfile
operator|->
name|minimal_symbol_count
operator|=
name|mcount
expr_stmt|;
name|objfile
operator|->
name|msymbols
operator|=
name|msymbols
expr_stmt|;
comment|/* Try to guess the appropriate C++ ABI by looking at the names  	 of the minimal symbols in the table.  */
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mcount
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|SYMBOL_NAME
argument_list|(
operator|&
name|objfile
operator|->
name|msymbols
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'Z'
condition|)
block|{
name|switch_to_cp_abi
argument_list|(
literal|"gnu-v3"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Now walk through all the minimal symbols, selecting the newly added          ones and attempting to cache their C++ demangled names. */
for|for
control|(
init|;
name|mcount
operator|--
operator|>
literal|0
condition|;
name|msymbols
operator|++
control|)
name|SYMBOL_INIT_DEMANGLED_NAME
argument_list|(
name|msymbols
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
comment|/* Now build the hash tables; we can't do this incrementally          at an earlier point since we weren't finished with the obstack 	 yet.  (And if the msymbol obstack gets moved, all the internal 	 pointers to other msymbols need to be adjusted.) */
name|build_minimal_symbol_hash_tables
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Sort all the minimal symbols in OBJFILE.  */
end_comment

begin_function
name|void
name|msymbols_sort
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|)
block|{
name|qsort
argument_list|(
name|objfile
operator|->
name|msymbols
argument_list|,
name|objfile
operator|->
name|minimal_symbol_count
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|minimal_symbol
argument_list|)
argument_list|,
name|compare_minimal_symbols
argument_list|)
expr_stmt|;
name|build_minimal_symbol_hash_tables
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Check if PC is in a shared library trampoline code stub.    Return minimal symbol for the trampoline entry or NULL if PC is not    in a trampoline code stub.  */
end_comment

begin_function
name|struct
name|minimal_symbol
modifier|*
name|lookup_solib_trampoline_symbol_by_pc
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|msymbol
init|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|pc
argument_list|)
decl_stmt|;
if|if
condition|(
name|msymbol
operator|!=
name|NULL
operator|&&
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|==
name|mst_solib_trampoline
condition|)
return|return
name|msymbol
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* If PC is in a shared library trampoline code stub, return the    address of the `real' function belonging to the stub.    Return 0 if PC is not in a trampoline code stub or if the real    function is not found in the minimal symbol table.     We may fail to find the right function if a function with the    same name is defined in more than one shared library, but this    is considered bad programming style. We could return 0 if we find    a duplicate function in case this matters someday.  */
end_comment

begin_function
name|CORE_ADDR
name|find_solib_trampoline_target
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|tsymbol
init|=
name|lookup_solib_trampoline_symbol_by_pc
argument_list|(
name|pc
argument_list|)
decl_stmt|;
if|if
condition|(
name|tsymbol
operator|!=
name|NULL
condition|)
block|{
name|ALL_MSYMBOLS
argument_list|(
argument|objfile
argument_list|,
argument|msymbol
argument_list|)
block|{
if|if
condition|(
name|MSYMBOL_TYPE
argument_list|(
name|msymbol
argument_list|)
operator|==
name|mst_text
operator|&&
name|STREQ
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|tsymbol
argument_list|)
argument_list|)
condition|)
return|return
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

