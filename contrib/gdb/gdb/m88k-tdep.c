begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target-machine dependent code for Motorola 88000 series, for GDB.    Copyright 1988, 1990, 1991, 1994, 1995 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"setjmp.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_comment
comment|/* Size of an instruction */
end_comment

begin_define
define|#
directive|define
name|BYTES_PER_88K_INSN
value|4
end_define

begin_function_decl
name|void
name|frame_find_saved_regs
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Is this target an m88110?  Otherwise assume m88100.  This has    relevance for the ways in which we screw with instruction pointers.  */
end_comment

begin_decl_stmt
name|int
name|target_is_m88110
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given a GDB frame, determine the address of the calling function's frame.    This will be used to create a new GDB frame struct, and then    INIT_EXTRA_FRAME_INFO and INIT_FRAME_PC will be called for the new frame.     For us, the frame address is its stack pointer value, so we look up    the function prologue to determine the caller's sp value, and return it.  */
end_comment

begin_function
name|CORE_ADDR
name|frame_chain
parameter_list|(
name|thisframe
parameter_list|)
name|struct
name|frame_info
modifier|*
name|thisframe
decl_stmt|;
block|{
name|frame_find_saved_regs
argument_list|(
name|thisframe
argument_list|,
operator|(
expr|struct
name|frame_saved_regs
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTE:  this depends on frame_find_saved_regs returning the VALUE, not  	    the ADDRESS, of SP_REGNUM.  It also depends on the cache of 	    frame_find_saved_regs results.  */
if|if
condition|(
name|thisframe
operator|->
name|fsr
operator|->
name|regs
index|[
name|SP_REGNUM
index|]
condition|)
return|return
name|thisframe
operator|->
name|fsr
operator|->
name|regs
index|[
name|SP_REGNUM
index|]
return|;
else|else
return|return
name|thisframe
operator|->
name|frame
return|;
comment|/* Leaf fn -- next frame up has same SP. */
block|}
end_function

begin_function
name|int
name|frameless_function_invocation
parameter_list|(
name|frame
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
block|{
name|frame_find_saved_regs
argument_list|(
name|frame
argument_list|,
operator|(
expr|struct
name|frame_saved_regs
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTE:  this depends on frame_find_saved_regs returning the VALUE, not  	    the ADDRESS, of SP_REGNUM.  It also depends on the cache of 	    frame_find_saved_regs results.  */
if|if
condition|(
name|frame
operator|->
name|fsr
operator|->
name|regs
index|[
name|SP_REGNUM
index|]
condition|)
return|return
literal|0
return|;
comment|/* Frameful -- return addr saved somewhere */
else|else
return|return
literal|1
return|;
comment|/* Frameless -- no saved return address */
block|}
end_function

begin_function
name|void
name|init_extra_frame_info
parameter_list|(
name|fromleaf
parameter_list|,
name|frame
parameter_list|)
name|int
name|fromleaf
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
block|{
name|frame
operator|->
name|fsr
operator|=
literal|0
expr_stmt|;
comment|/* Not yet allocated */
name|frame
operator|->
name|args_pointer
operator|=
literal|0
expr_stmt|;
comment|/* Unknown */
name|frame
operator|->
name|locals_pointer
operator|=
literal|0
expr_stmt|;
comment|/* Unknown */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Examine an m88k function prologue, recording the addresses at which    registers are saved explicitly by the prologue code, and returning    the address of the first instruction after the prologue (but not    after the instruction at address LIMIT, as explained below).     LIMIT places an upper bound on addresses of the instructions to be    examined.  If the prologue code scan reaches LIMIT, the scan is    aborted and LIMIT is returned.  This is used, when examining the    prologue for the current frame, to keep examine_prologue () from    claiming that a given register has been saved when in fact the    instruction that saves it has not yet been executed.  LIMIT is used    at other times to stop the scan when we hit code after the true    function prologue (e.g. for the first source line) which might    otherwise be mistaken for function prologue.     The format of the function prologue matched by this routine is    derived from examination of the source to gcc 1.95, particularly    the routine output_prologue () in config/out-m88k.c.     subu r31,r31,n			# stack pointer update     (st rn,r31,offset)?			# save incoming regs    (st.d rn,r31,offset)?     (addu r30,r31,n)?			# frame pointer update     (pic sequence)?			# PIC code prologue     (or   rn,rm,0)?			# Move parameters to other regs */
end_comment

begin_comment
comment|/* Macros for extracting fields from instructions.  */
end_comment

begin_define
define|#
directive|define
name|BITMASK
parameter_list|(
name|pos
parameter_list|,
name|width
parameter_list|)
value|(((0x1<< (width)) - 1)<< (pos))
end_define

begin_define
define|#
directive|define
name|EXTRACT_FIELD
parameter_list|(
name|val
parameter_list|,
name|pos
parameter_list|,
name|width
parameter_list|)
value|((val)>> (pos)& BITMASK (0, width))
end_define

begin_define
define|#
directive|define
name|SUBU_OFFSET
parameter_list|(
name|x
parameter_list|)
value|((unsigned)(x& 0xFFFF))
end_define

begin_define
define|#
directive|define
name|ST_OFFSET
parameter_list|(
name|x
parameter_list|)
value|((unsigned)((x)& 0xFFFF))
end_define

begin_define
define|#
directive|define
name|ST_SRC
parameter_list|(
name|x
parameter_list|)
value|EXTRACT_FIELD ((x), 21, 5)
end_define

begin_define
define|#
directive|define
name|ADDU_OFFSET
parameter_list|(
name|x
parameter_list|)
value|((unsigned)(x& 0xFFFF))
end_define

begin_comment
comment|/*  * prologue_insn_tbl is a table of instructions which may comprise a  * function prologue.  Associated with each table entry (corresponding  * to a single instruction or group of instructions), is an action.  * This action is used by examine_prologue (below) to determine  * the state of certain machine registers and where the stack frame lives.  */
end_comment

begin_enum
enum|enum
name|prologue_insn_action
block|{
name|PIA_SKIP
block|,
comment|/* don't care what the instruction does */
name|PIA_NOTE_ST
block|,
comment|/* note register stored and where */
name|PIA_NOTE_STD
block|,
comment|/* note pair of registers stored and where */
name|PIA_NOTE_SP_ADJUSTMENT
block|,
comment|/* note stack pointer adjustment */
name|PIA_NOTE_FP_ASSIGNMENT
block|,
comment|/* note frame pointer assignment */
name|PIA_NOTE_PROLOGUE_END
block|,
comment|/* no more prologue */
block|}
enum|;
end_enum

begin_struct
struct|struct
name|prologue_insns
block|{
name|unsigned
name|long
name|insn
decl_stmt|;
name|unsigned
name|long
name|mask
decl_stmt|;
name|enum
name|prologue_insn_action
name|action
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|prologue_insns
name|prologue_insn_tbl
index|[]
init|=
block|{
comment|/* Various register move instructions */
block|{
literal|0x58000000
block|,
literal|0xf800ffff
block|,
name|PIA_SKIP
block|}
block|,
comment|/* or/or.u with immed of 0 */
block|{
literal|0xf4005800
block|,
literal|0xfc1fffe0
block|,
name|PIA_SKIP
block|}
block|,
comment|/* or rd, r0, rs */
block|{
literal|0xf4005800
block|,
literal|0xfc00ffff
block|,
name|PIA_SKIP
block|}
block|,
comment|/* or rd, rs, r0 */
comment|/* Stack pointer setup: "subu sp, sp, n" where n is a multiple of 8 */
block|{
literal|0x67ff0000
block|,
literal|0xffff0007
block|,
name|PIA_NOTE_SP_ADJUSTMENT
block|}
block|,
comment|/* Frame pointer assignment: "addu r30, r31, n" */
block|{
literal|0x63df0000
block|,
literal|0xffff0000
block|,
name|PIA_NOTE_FP_ASSIGNMENT
block|}
block|,
comment|/* Store to stack instructions; either "st rx, sp, n" or "st.d rx, sp, n" */
block|{
literal|0x241f0000
block|,
literal|0xfc1f0000
block|,
name|PIA_NOTE_ST
block|}
block|,
comment|/* st rx, sp, n */
block|{
literal|0x201f0000
block|,
literal|0xfc1f0000
block|,
name|PIA_NOTE_STD
block|}
block|,
comment|/* st.d rs, sp, n */
comment|/* Instructions needed for setting up r25 for pic code. */
block|{
literal|0x5f200000
block|,
literal|0xffff0000
block|,
name|PIA_SKIP
block|}
block|,
comment|/* or.u r25, r0, offset_high */
block|{
literal|0xcc000002
block|,
literal|0xffffffff
block|,
name|PIA_SKIP
block|}
block|,
comment|/* bsr.n Lab */
block|{
literal|0x5b390000
block|,
literal|0xffff0000
block|,
name|PIA_SKIP
block|}
block|,
comment|/* or r25, r25, offset_low */
block|{
literal|0xf7396001
block|,
literal|0xffffffff
block|,
name|PIA_SKIP
block|}
block|,
comment|/* Lab: addu r25, r25, r1 */
comment|/* Various branch or jump instructions which have a delay slot -- these      do not form part of the prologue, but the instruction in the delay      slot might be a store instruction which should be noted. */
block|{
literal|0xc4000000
block|,
literal|0xe4000000
block|,
name|PIA_NOTE_PROLOGUE_END
block|}
block|,
comment|/* br.n, bsr.n, bb0.n, or bb1.n */
block|{
literal|0xec000000
block|,
literal|0xfc000000
block|,
name|PIA_NOTE_PROLOGUE_END
block|}
block|,
comment|/* bcnd.n */
block|{
literal|0xf400c400
block|,
literal|0xfffff7e0
block|,
name|PIA_NOTE_PROLOGUE_END
block|}
comment|/* jmp.n or jsr.n */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Fetch the instruction at ADDR, returning 0 if ADDR is beyond LIM or    is not the address of a valid instruction, the address of the next    instruction beyond ADDR otherwise.  *PWORD1 receives the first word    of the instruction. */
end_comment

begin_define
define|#
directive|define
name|NEXT_PROLOGUE_INSN
parameter_list|(
name|addr
parameter_list|,
name|lim
parameter_list|,
name|pword1
parameter_list|)
define|\
value|(((addr)< (lim)) ? next_insn (addr, pword1) : 0)
end_define

begin_comment
comment|/* Read the m88k instruction at 'memaddr' and return the address of     the next instruction after that, or 0 if 'memaddr' is not the    address of a valid instruction.  The instruction    is stored at 'pword1'.  */
end_comment

begin_function
name|CORE_ADDR
name|next_insn
parameter_list|(
name|memaddr
parameter_list|,
name|pword1
parameter_list|)
name|unsigned
name|long
modifier|*
name|pword1
decl_stmt|;
name|CORE_ADDR
name|memaddr
decl_stmt|;
block|{
operator|*
name|pword1
operator|=
name|read_memory_integer
argument_list|(
name|memaddr
argument_list|,
name|BYTES_PER_88K_INSN
argument_list|)
expr_stmt|;
return|return
name|memaddr
operator|+
name|BYTES_PER_88K_INSN
return|;
block|}
end_function

begin_comment
comment|/* Read a register from frames called by us (or from the hardware regs).  */
end_comment

begin_function
specifier|static
name|int
name|read_next_frame_reg
parameter_list|(
name|frame
parameter_list|,
name|regno
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
name|int
name|regno
decl_stmt|;
block|{
for|for
control|(
init|;
name|frame
condition|;
name|frame
operator|=
name|frame
operator|->
name|next
control|)
block|{
if|if
condition|(
name|regno
operator|==
name|SP_REGNUM
condition|)
return|return
name|FRAME_FP
argument_list|(
name|frame
argument_list|)
return|;
elseif|else
if|if
condition|(
name|frame
operator|->
name|fsr
operator|->
name|regs
index|[
name|regno
index|]
condition|)
return|return
name|read_memory_integer
argument_list|(
name|frame
operator|->
name|fsr
operator|->
name|regs
index|[
name|regno
index|]
argument_list|,
literal|4
argument_list|)
return|;
block|}
return|return
name|read_register
argument_list|(
name|regno
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Examine the prologue of a function.  `ip' points to the first instruction.    `limit' is the limit of the prologue (e.g. the addr of the first     linenumber, or perhaps the program counter if we're stepping through).    `frame_sp' is the stack pointer value in use in this frame.      `fsr' is a pointer to a frame_saved_regs structure into which we put    info about the registers saved by this frame.      `fi' is a struct frame_info pointer; we fill in various fields in it    to reflect the offsets of the arg pointer and the locals pointer.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|examine_prologue
parameter_list|(
name|ip
parameter_list|,
name|limit
parameter_list|,
name|frame_sp
parameter_list|,
name|fsr
parameter_list|,
name|fi
parameter_list|)
specifier|register
name|CORE_ADDR
name|ip
decl_stmt|;
specifier|register
name|CORE_ADDR
name|limit
decl_stmt|;
name|CORE_ADDR
name|frame_sp
decl_stmt|;
name|struct
name|frame_saved_regs
modifier|*
name|fsr
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
block|{
specifier|register
name|CORE_ADDR
name|next_ip
decl_stmt|;
specifier|register
name|int
name|src
decl_stmt|;
name|unsigned
name|int
name|insn
decl_stmt|;
name|int
name|size
decl_stmt|,
name|offset
decl_stmt|;
name|char
name|must_adjust
index|[
literal|32
index|]
decl_stmt|;
comment|/* If set, must adjust offsets in fsr */
name|int
name|sp_offset
init|=
operator|-
literal|1
decl_stmt|;
comment|/* -1 means not set (valid must be mult of 8) */
name|int
name|fp_offset
init|=
operator|-
literal|1
decl_stmt|;
comment|/* -1 means not set */
name|CORE_ADDR
name|frame_fp
decl_stmt|;
name|CORE_ADDR
name|prologue_end
init|=
literal|0
decl_stmt|;
name|memset
argument_list|(
name|must_adjust
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|must_adjust
argument_list|)
argument_list|)
expr_stmt|;
name|next_ip
operator|=
name|NEXT_PROLOGUE_INSN
argument_list|(
name|ip
argument_list|,
name|limit
argument_list|,
operator|&
name|insn
argument_list|)
expr_stmt|;
while|while
condition|(
name|next_ip
condition|)
block|{
name|struct
name|prologue_insns
modifier|*
name|pip
decl_stmt|;
for|for
control|(
name|pip
operator|=
name|prologue_insn_tbl
init|;
operator|(
name|insn
operator|&
name|pip
operator|->
name|mask
operator|)
operator|!=
name|pip
operator|->
name|insn
condition|;
control|)
if|if
condition|(
operator|++
name|pip
operator|>=
name|prologue_insn_tbl
operator|+
sizeof|sizeof
name|prologue_insn_tbl
condition|)
goto|goto
name|end_of_prologue_found
goto|;
comment|/* not a prologue insn */
switch|switch
condition|(
name|pip
operator|->
name|action
condition|)
block|{
case|case
name|PIA_NOTE_ST
case|:
case|case
name|PIA_NOTE_STD
case|:
if|if
condition|(
name|sp_offset
operator|!=
operator|-
literal|1
condition|)
block|{
name|src
operator|=
name|ST_SRC
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|offset
operator|=
name|ST_OFFSET
argument_list|(
name|insn
argument_list|)
expr_stmt|;
name|must_adjust
index|[
name|src
index|]
operator|=
literal|1
expr_stmt|;
name|fsr
operator|->
name|regs
index|[
name|src
operator|++
index|]
operator|=
name|offset
expr_stmt|;
comment|/* Will be adjusted later */
if|if
condition|(
name|pip
operator|->
name|action
operator|==
name|PIA_NOTE_STD
operator|&&
name|src
operator|<
literal|32
condition|)
block|{
name|offset
operator|+=
literal|4
expr_stmt|;
name|must_adjust
index|[
name|src
index|]
operator|=
literal|1
expr_stmt|;
name|fsr
operator|->
name|regs
index|[
name|src
operator|++
index|]
operator|=
name|offset
expr_stmt|;
block|}
block|}
else|else
goto|goto
name|end_of_prologue_found
goto|;
break|break;
case|case
name|PIA_NOTE_SP_ADJUSTMENT
case|:
if|if
condition|(
name|sp_offset
operator|==
operator|-
literal|1
condition|)
name|sp_offset
operator|=
operator|-
name|SUBU_OFFSET
argument_list|(
name|insn
argument_list|)
expr_stmt|;
else|else
goto|goto
name|end_of_prologue_found
goto|;
break|break;
case|case
name|PIA_NOTE_FP_ASSIGNMENT
case|:
if|if
condition|(
name|fp_offset
operator|==
operator|-
literal|1
condition|)
name|fp_offset
operator|=
name|ADDU_OFFSET
argument_list|(
name|insn
argument_list|)
expr_stmt|;
else|else
goto|goto
name|end_of_prologue_found
goto|;
break|break;
case|case
name|PIA_NOTE_PROLOGUE_END
case|:
if|if
condition|(
operator|!
name|prologue_end
condition|)
name|prologue_end
operator|=
name|ip
expr_stmt|;
break|break;
case|case
name|PIA_SKIP
case|:
default|default :
comment|/* Do nothing */
break|break;
block|}
name|ip
operator|=
name|next_ip
expr_stmt|;
name|next_ip
operator|=
name|NEXT_PROLOGUE_INSN
argument_list|(
name|ip
argument_list|,
name|limit
argument_list|,
operator|&
name|insn
argument_list|)
expr_stmt|;
block|}
name|end_of_prologue_found
label|:
if|if
condition|(
name|prologue_end
condition|)
name|ip
operator|=
name|prologue_end
expr_stmt|;
comment|/* We're done with the prologue.  If we don't care about the stack      frame itself, just return.  (Note that fsr->regs has been trashed,      but the one caller who calls with fi==0 passes a dummy there.)  */
if|if
condition|(
name|fi
operator|==
literal|0
condition|)
return|return
name|ip
return|;
comment|/*      OK, now we have:       	sp_offset	original (before any alloca calls) displacement of SP 			(will be negative).  	fp_offset	displacement from original SP to the FP for this frame 			or -1.  	fsr->regs[0..31]	displacement from original SP to the stack 				location where reg[0..31] is stored.  	must_adjust[0..31]	set if corresponding offset was set.       If alloca has been called between the function prologue and the current      IP, then the current SP (frame_sp) will not be the original SP as set by      the function prologue.  If the current SP is not the original SP, then the      compiler will have allocated an FP for this frame, fp_offset will be set,      and we can use it to calculate the original SP.       Then, we figure out where the arguments and locals are, and relocate the      offsets in fsr->regs to absolute addresses.  */
if|if
condition|(
name|fp_offset
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* We have a frame pointer, so get it, and base our calc's on it.  */
name|frame_fp
operator|=
operator|(
name|CORE_ADDR
operator|)
name|read_next_frame_reg
argument_list|(
name|fi
operator|->
name|next
argument_list|,
name|ACTUAL_FP_REGNUM
argument_list|)
expr_stmt|;
name|frame_sp
operator|=
name|frame_fp
operator|-
name|fp_offset
expr_stmt|;
block|}
else|else
block|{
comment|/* We have no frame pointer, therefore frame_sp is still the same value        as set by prologue.  But where is the frame itself?  */
if|if
condition|(
name|must_adjust
index|[
name|SRP_REGNUM
index|]
condition|)
block|{
comment|/* Function header saved SRP (r1), the return address.  Frame starts 	 4 bytes down from where it was saved.  */
name|frame_fp
operator|=
name|frame_sp
operator|+
name|fsr
operator|->
name|regs
index|[
name|SRP_REGNUM
index|]
operator|-
literal|4
expr_stmt|;
name|fi
operator|->
name|locals_pointer
operator|=
name|frame_fp
expr_stmt|;
block|}
else|else
block|{
comment|/* Function header didn't save SRP (r1), so we are in a leaf fn or 	 are otherwise confused.  */
name|frame_fp
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* The locals are relative to the FP (whether it exists as an allocated      register, or just as an assumed offset from the SP) */
name|fi
operator|->
name|locals_pointer
operator|=
name|frame_fp
expr_stmt|;
comment|/* The arguments are just above the SP as it was before we adjusted it      on entry.  */
name|fi
operator|->
name|args_pointer
operator|=
name|frame_sp
operator|-
name|sp_offset
expr_stmt|;
comment|/* Now that we know the SP value used by the prologue, we know where      it saved all the registers.  */
for|for
control|(
name|src
operator|=
literal|0
init|;
name|src
operator|<
literal|32
condition|;
name|src
operator|++
control|)
if|if
condition|(
name|must_adjust
index|[
name|src
index|]
condition|)
name|fsr
operator|->
name|regs
index|[
name|src
index|]
operator|+=
name|frame_sp
expr_stmt|;
comment|/* The saved value of the SP is always known.  */
comment|/* (we hope...) */
if|if
condition|(
name|fsr
operator|->
name|regs
index|[
name|SP_REGNUM
index|]
operator|!=
literal|0
operator|&&
name|fsr
operator|->
name|regs
index|[
name|SP_REGNUM
index|]
operator|!=
name|frame_sp
operator|-
name|sp_offset
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Bad saved SP value %x != %x, offset %x!\n"
argument_list|,
name|fsr
operator|->
name|regs
index|[
name|SP_REGNUM
index|]
argument_list|,
name|frame_sp
operator|-
name|sp_offset
argument_list|,
name|sp_offset
argument_list|)
expr_stmt|;
name|fsr
operator|->
name|regs
index|[
name|SP_REGNUM
index|]
operator|=
name|frame_sp
operator|-
name|sp_offset
expr_stmt|;
return|return
operator|(
name|ip
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Given an ip value corresponding to the start of a function,    return the ip of the first instruction after the function     prologue.  */
end_comment

begin_function_decl
name|CORE_ADDR
name|skip_prologue
parameter_list|(
name|ip
parameter_list|)
function_decl|CORE_ADDR
parameter_list|(
name|ip
parameter_list|)
function_decl|;
end_function_decl

begin_block
block|{
name|struct
name|frame_saved_regs
name|saved_regs_dummy
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|CORE_ADDR
name|limit
decl_stmt|;
name|sal
operator|=
name|find_pc_line
argument_list|(
name|ip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|limit
operator|=
operator|(
name|sal
operator|.
name|end
operator|)
condition|?
name|sal
operator|.
name|end
else|:
literal|0xffffffff
expr_stmt|;
return|return
operator|(
name|examine_prologue
argument_list|(
name|ip
argument_list|,
name|limit
argument_list|,
operator|(
name|CORE_ADDR
operator|)
literal|0
argument_list|,
operator|&
name|saved_regs_dummy
argument_list|,
operator|(
expr|struct
name|frame_info
operator|*
operator|)
literal|0
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Put here the code to store, into a struct frame_saved_regs,    the addresses of the saved registers of frame described by FRAME_INFO.    This includes special registers such as pc and fp saved in special    ways in the stack frame.  sp is even more special:    the address we return for it IS the sp for the next frame.     We cache the result of doing this in the frame_cache_obstack, since    it is fairly expensive.  */
end_comment

begin_function
name|void
name|frame_find_saved_regs
parameter_list|(
name|fi
parameter_list|,
name|fsr
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|struct
name|frame_saved_regs
modifier|*
name|fsr
decl_stmt|;
block|{
specifier|register
name|struct
name|frame_saved_regs
modifier|*
name|cache_fsr
decl_stmt|;
specifier|extern
name|struct
name|obstack
name|frame_cache_obstack
decl_stmt|;
name|CORE_ADDR
name|ip
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|CORE_ADDR
name|limit
decl_stmt|;
if|if
condition|(
operator|!
name|fi
operator|->
name|fsr
condition|)
block|{
name|cache_fsr
operator|=
operator|(
expr|struct
name|frame_saved_regs
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|frame_cache_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|frame_saved_regs
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|cache_fsr
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|frame_saved_regs
argument_list|)
argument_list|)
expr_stmt|;
name|fi
operator|->
name|fsr
operator|=
name|cache_fsr
expr_stmt|;
comment|/* Find the start and end of the function prologue.  If the PC 	 is in the function prologue, we only consider the part that 	 has executed already.  In the case where the PC is not in 	 the function prologue, we set limit to two instructions beyond 	 where the prologue ends in case if any of the prologue instructions 	 were moved into a delay slot of a branch instruction. */
name|ip
operator|=
name|get_pc_function_start
argument_list|(
name|fi
operator|->
name|pc
argument_list|)
expr_stmt|;
name|sal
operator|=
name|find_pc_line
argument_list|(
name|ip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|limit
operator|=
operator|(
name|sal
operator|.
name|end
operator|&&
name|sal
operator|.
name|end
operator|<
name|fi
operator|->
name|pc
operator|)
condition|?
name|sal
operator|.
name|end
operator|+
literal|2
operator|*
name|BYTES_PER_88K_INSN
else|:
name|fi
operator|->
name|pc
expr_stmt|;
comment|/* This will fill in fields in *fi as well as in cache_fsr.  */
ifdef|#
directive|ifdef
name|SIGTRAMP_FRAME_FIXUP
if|if
condition|(
name|fi
operator|->
name|signal_handler_caller
condition|)
name|SIGTRAMP_FRAME_FIXUP
argument_list|(
name|fi
operator|->
name|frame
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|examine_prologue
argument_list|(
name|ip
argument_list|,
name|limit
argument_list|,
name|fi
operator|->
name|frame
argument_list|,
name|cache_fsr
argument_list|,
name|fi
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGTRAMP_SP_FIXUP
if|if
condition|(
name|fi
operator|->
name|signal_handler_caller
operator|&&
name|fi
operator|->
name|fsr
operator|->
name|regs
index|[
name|SP_REGNUM
index|]
condition|)
name|SIGTRAMP_SP_FIXUP
argument_list|(
name|fi
operator|->
name|fsr
operator|->
name|regs
index|[
name|SP_REGNUM
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|fsr
condition|)
operator|*
name|fsr
operator|=
operator|*
name|fi
operator|->
name|fsr
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the address of the locals block for the frame    described by FI.  Returns 0 if the address is unknown.    NOTE!  Frame locals are referred to by negative offsets from the    argument pointer, so this is the same as frame_args_address().  */
end_comment

begin_function
name|CORE_ADDR
name|frame_locals_address
parameter_list|(
name|fi
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
block|{
name|struct
name|frame_saved_regs
name|fsr
decl_stmt|;
if|if
condition|(
name|fi
operator|->
name|args_pointer
condition|)
comment|/* Cached value is likely there.  */
return|return
name|fi
operator|->
name|args_pointer
return|;
comment|/* Nope, generate it.  */
name|get_frame_saved_regs
argument_list|(
name|fi
argument_list|,
operator|&
name|fsr
argument_list|)
expr_stmt|;
return|return
name|fi
operator|->
name|args_pointer
return|;
block|}
end_function

begin_comment
comment|/* Return the address of the argument block for the frame    described by FI.  Returns 0 if the address is unknown.  */
end_comment

begin_function
name|CORE_ADDR
name|frame_args_address
parameter_list|(
name|fi
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
block|{
name|struct
name|frame_saved_regs
name|fsr
decl_stmt|;
if|if
condition|(
name|fi
operator|->
name|args_pointer
condition|)
comment|/* Cached value is likely there.  */
return|return
name|fi
operator|->
name|args_pointer
return|;
comment|/* Nope, generate it.  */
name|get_frame_saved_regs
argument_list|(
name|fi
argument_list|,
operator|&
name|fsr
argument_list|)
expr_stmt|;
return|return
name|fi
operator|->
name|args_pointer
return|;
block|}
end_function

begin_comment
comment|/* Return the saved PC from this frame.     If the frame has a memory copy of SRP_REGNUM, use that.  If not,    just use the register SRP_REGNUM itself.  */
end_comment

begin_function
name|CORE_ADDR
name|frame_saved_pc
parameter_list|(
name|frame
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
block|{
return|return
name|read_next_frame_reg
argument_list|(
name|frame
argument_list|,
name|SRP_REGNUM
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|DUMMY_FRAME_SIZE
value|192
end_define

begin_function
specifier|static
name|void
name|write_word
parameter_list|(
name|sp
parameter_list|,
name|word
parameter_list|)
name|CORE_ADDR
name|sp
decl_stmt|;
name|unsigned
name|LONGEST
name|word
decl_stmt|;
block|{
specifier|register
name|int
name|len
init|=
name|REGISTER_SIZE
decl_stmt|;
name|char
name|buffer
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|store_unsigned_integer
argument_list|(
name|buffer
argument_list|,
name|len
argument_list|,
name|word
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|sp
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|m88k_push_dummy_frame
parameter_list|()
block|{
specifier|register
name|CORE_ADDR
name|sp
init|=
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
decl_stmt|;
specifier|register
name|int
name|rn
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|sp
operator|-=
name|DUMMY_FRAME_SIZE
expr_stmt|;
comment|/* allocate a bunch of space */
for|for
control|(
name|rn
operator|=
literal|0
operator|,
name|offset
operator|=
literal|0
init|;
name|rn
operator|<=
name|SP_REGNUM
condition|;
name|rn
operator|++
operator|,
name|offset
operator|+=
literal|4
control|)
name|write_word
argument_list|(
name|sp
operator|+
name|offset
argument_list|,
name|read_register
argument_list|(
name|rn
argument_list|)
argument_list|)
expr_stmt|;
name|write_word
argument_list|(
name|sp
operator|+
name|offset
argument_list|,
name|read_register
argument_list|(
name|SXIP_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
name|write_word
argument_list|(
name|sp
operator|+
name|offset
argument_list|,
name|read_register
argument_list|(
name|SNIP_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
name|write_word
argument_list|(
name|sp
operator|+
name|offset
argument_list|,
name|read_register
argument_list|(
name|SFIP_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
name|write_word
argument_list|(
name|sp
operator|+
name|offset
argument_list|,
name|read_register
argument_list|(
name|PSR_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
name|write_word
argument_list|(
name|sp
operator|+
name|offset
argument_list|,
name|read_register
argument_list|(
name|FPSR_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
name|write_word
argument_list|(
name|sp
operator|+
name|offset
argument_list|,
name|read_register
argument_list|(
name|FPCR_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
name|write_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|ACTUAL_FP_REGNUM
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pop_frame
parameter_list|()
block|{
specifier|register
name|struct
name|frame_info
modifier|*
name|frame
init|=
name|get_current_frame
argument_list|()
decl_stmt|;
specifier|register
name|CORE_ADDR
name|fp
decl_stmt|;
specifier|register
name|int
name|regnum
decl_stmt|;
name|struct
name|frame_saved_regs
name|fsr
decl_stmt|;
name|fp
operator|=
name|FRAME_FP
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|get_frame_saved_regs
argument_list|(
name|frame
argument_list|,
operator|&
name|fsr
argument_list|)
expr_stmt|;
if|if
condition|(
name|PC_IN_CALL_DUMMY
argument_list|(
name|read_pc
argument_list|()
argument_list|,
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
argument_list|,
name|FRAME_FP
argument_list|(
name|fi
argument_list|)
argument_list|)
condition|)
block|{
comment|/* FIXME: I think get_frame_saved_regs should be handling this so 	 that we can deal with the saved registers properly (e.g. frame 	 1 is a call dummy, the user types "frame 2" and then "print $ps").  */
specifier|register
name|CORE_ADDR
name|sp
init|=
name|read_register
argument_list|(
name|ACTUAL_FP_REGNUM
argument_list|)
decl_stmt|;
name|int
name|offset
decl_stmt|;
for|for
control|(
name|regnum
operator|=
literal|0
operator|,
name|offset
operator|=
literal|0
init|;
name|regnum
operator|<=
name|SP_REGNUM
condition|;
name|regnum
operator|++
operator|,
name|offset
operator|+=
literal|4
control|)
operator|(
name|void
operator|)
name|write_register
argument_list|(
name|regnum
argument_list|,
name|read_memory_integer
argument_list|(
name|sp
operator|+
name|offset
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|SXIP_REGNUM
argument_list|,
name|read_memory_integer
argument_list|(
name|sp
operator|+
name|offset
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
name|write_register
argument_list|(
name|SNIP_REGNUM
argument_list|,
name|read_memory_integer
argument_list|(
name|sp
operator|+
name|offset
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
name|write_register
argument_list|(
name|SFIP_REGNUM
argument_list|,
name|read_memory_integer
argument_list|(
name|sp
operator|+
name|offset
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
name|write_register
argument_list|(
name|PSR_REGNUM
argument_list|,
name|read_memory_integer
argument_list|(
name|sp
operator|+
name|offset
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
name|write_register
argument_list|(
name|FPSR_REGNUM
argument_list|,
name|read_memory_integer
argument_list|(
name|sp
operator|+
name|offset
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
name|write_register
argument_list|(
name|FPCR_REGNUM
argument_list|,
name|read_memory_integer
argument_list|(
name|sp
operator|+
name|offset
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|regnum
operator|=
name|FP_REGNUM
init|;
name|regnum
operator|>
literal|0
condition|;
name|regnum
operator|--
control|)
if|if
condition|(
name|fsr
operator|.
name|regs
index|[
name|regnum
index|]
condition|)
name|write_register
argument_list|(
name|regnum
argument_list|,
name|read_memory_integer
argument_list|(
name|fsr
operator|.
name|regs
index|[
name|regnum
index|]
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|write_pc
argument_list|(
name|frame_saved_pc
argument_list|(
name|frame
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|reinit_frame_cache
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_m88k_tdep
parameter_list|()
block|{
name|tm_print_insn
operator|=
name|print_insn_m88k
expr_stmt|;
block|}
end_function

end_unit

