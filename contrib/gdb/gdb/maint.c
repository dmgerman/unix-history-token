begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Support for GDB maintenance commands.     Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1999, 2000, 2001,    2002, 2003, 2004 Free Software Foundation, Inc.     Written by Fred Fish at Cygnus Support.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_comment
comment|/* For language.h */
end_comment

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"cli/cli-decode.h"
end_include

begin_function_decl
specifier|extern
name|void
name|_initialize_maint_cmds
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|maintenance_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|maintenance_dump_me
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|maintenance_internal_error
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|maintenance_demangle
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|maintenance_time_display
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|maintenance_space_display
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|maintenance_info_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|maintenance_info_sections
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|maintenance_print_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|maintenance_do_deprecate
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Set this to the maximum number of seconds to wait instead of waiting forever    in target_wait().  If this timer times out, then it generates an error and    the command is aborted.  This replaces most of the need for timeouts in the    GDB test suite, and makes it possible to distinguish between a hung target    and one with slow communications.  */
end_comment

begin_decl_stmt
name|int
name|watchdog
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*     LOCAL FUNCTION     maintenance_command -- access the maintenance subcommands     SYNOPSIS     void maintenance_command (char *args, int from_tty)     DESCRIPTION   */
end_comment

begin_function
specifier|static
name|void
name|maintenance_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\"maintenance\" must be followed by the name of a maintenance command.\n"
argument_list|)
expr_stmt|;
name|help_list
argument_list|(
name|maintenancelist
argument_list|,
literal|"maintenance "
argument_list|,
operator|-
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_WIN32
end_ifndef

begin_function
specifier|static
name|void
name|maintenance_dump_me
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|query
argument_list|(
literal|"Should GDB dump core? "
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|__DJGPP__
comment|/* SIGQUIT by default is ignored, so use SIGABRT instead.  */
name|signal
argument_list|(
name|SIGABRT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGABRT
argument_list|)
expr_stmt|;
else|#
directive|else
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGQUIT
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Stimulate the internal error mechanism that GDB uses when an    internal problem is detected.  Allows testing of the mechanism.    Also useful when the user wants to drop a core file but not exit    GDB. */
end_comment

begin_function
specifier|static
name|void
name|maintenance_internal_error
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"%s"
argument_list|,
operator|(
name|args
operator|==
name|NULL
condition|?
literal|""
else|:
name|args
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stimulate the internal error mechanism that GDB uses when an    internal problem is detected.  Allows testing of the mechanism.    Also useful when the user wants to drop a core file but not exit    GDB. */
end_comment

begin_function
specifier|static
name|void
name|maintenance_internal_warning
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|internal_warning
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"%s"
argument_list|,
operator|(
name|args
operator|==
name|NULL
condition|?
literal|""
else|:
name|args
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Someday we should allow demangling for things other than just    explicit strings.  For example, we might want to be able to specify    the address of a string in either GDB's process space or the    debuggee's process space, and have gdb fetch and demangle that    string.  If we have a char* pointer "ptr" that points to a string,    we might want to be able to given just the name and have GDB    demangle and print what it points to, etc.  (FIXME) */
end_comment

begin_function
specifier|static
name|void
name|maintenance_demangle
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
modifier|*
name|demangled
decl_stmt|;
if|if
condition|(
name|args
operator|==
name|NULL
operator|||
operator|*
name|args
operator|==
literal|'\0'
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\"maintenance demangle\" takes an argument to demangle.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|demangled
operator|=
name|language_demangle
argument_list|(
name|current_language
argument_list|,
name|args
argument_list|,
name|DMGL_ANSI
operator||
name|DMGL_PARAMS
argument_list|)
expr_stmt|;
if|if
condition|(
name|demangled
operator|!=
name|NULL
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"%s\n"
argument_list|,
name|demangled
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|demangled
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_unfiltered
argument_list|(
literal|"Can't demangle \"%s\"\n"
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|maintenance_time_display
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
specifier|extern
name|int
name|display_time
decl_stmt|;
if|if
condition|(
name|args
operator|==
name|NULL
operator|||
operator|*
name|args
operator|==
literal|'\0'
condition|)
name|printf_unfiltered
argument_list|(
literal|"\"maintenance time\" takes a numeric argument.\n"
argument_list|)
expr_stmt|;
else|else
name|display_time
operator|=
name|strtol
argument_list|(
name|args
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|maintenance_space_display
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
specifier|extern
name|int
name|display_space
decl_stmt|;
if|if
condition|(
name|args
operator|==
name|NULL
operator|||
operator|*
name|args
operator|==
literal|'\0'
condition|)
name|printf_unfiltered
argument_list|(
literal|"\"maintenance space\" takes a numeric argument.\n"
argument_list|)
expr_stmt|;
else|else
name|display_space
operator|=
name|strtol
argument_list|(
name|args
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The "maintenance info" command is defined as a prefix, with    allow_unknown 0.  Therefore, its own definition is called only for    "maintenance info" with no args.  */
end_comment

begin_function
specifier|static
name|void
name|maintenance_info_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\"maintenance info\" must be followed by the name of an info command.\n"
argument_list|)
expr_stmt|;
name|help_list
argument_list|(
name|maintenanceinfolist
argument_list|,
literal|"maintenance info "
argument_list|,
operator|-
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mini tokenizing lexer for 'maint info sections' command.  */
end_comment

begin_function
specifier|static
name|int
name|match_substring
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
specifier|const
name|char
modifier|*
name|substr
parameter_list|)
block|{
name|int
name|substr_len
init|=
name|strlen
argument_list|(
name|substr
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|tok
decl_stmt|;
while|while
condition|(
operator|(
name|tok
operator|=
name|strstr
argument_list|(
name|string
argument_list|,
name|substr
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Got a partial match.  Is it a whole word? */
if|if
condition|(
name|tok
operator|==
name|string
operator|||
name|tok
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
operator|||
name|tok
index|[
operator|-
literal|1
index|]
operator|==
literal|'\t'
condition|)
block|{
comment|/* Token is delimited at the front... */
if|if
condition|(
name|tok
index|[
name|substr_len
index|]
operator|==
literal|' '
operator|||
name|tok
index|[
name|substr_len
index|]
operator|==
literal|'\t'
operator|||
name|tok
index|[
name|substr_len
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* Token is delimited at the rear.  Got a whole-word match.  */
return|return
literal|1
return|;
block|}
block|}
comment|/* Token didn't match as a whole word.  Advance and try again.  */
name|string
operator|=
name|tok
operator|+
literal|1
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|match_bfd_flags
parameter_list|(
name|char
modifier|*
name|string
parameter_list|,
name|flagword
name|flags
parameter_list|)
block|{
if|if
condition|(
name|flags
operator|&
name|SEC_ALLOC
condition|)
if|if
condition|(
name|match_substring
argument_list|(
name|string
argument_list|,
literal|"ALLOC"
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|flags
operator|&
name|SEC_LOAD
condition|)
if|if
condition|(
name|match_substring
argument_list|(
name|string
argument_list|,
literal|"LOAD"
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|flags
operator|&
name|SEC_RELOC
condition|)
if|if
condition|(
name|match_substring
argument_list|(
name|string
argument_list|,
literal|"RELOC"
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|flags
operator|&
name|SEC_READONLY
condition|)
if|if
condition|(
name|match_substring
argument_list|(
name|string
argument_list|,
literal|"READONLY"
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|flags
operator|&
name|SEC_CODE
condition|)
if|if
condition|(
name|match_substring
argument_list|(
name|string
argument_list|,
literal|"CODE"
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|flags
operator|&
name|SEC_DATA
condition|)
if|if
condition|(
name|match_substring
argument_list|(
name|string
argument_list|,
literal|"DATA"
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|flags
operator|&
name|SEC_ROM
condition|)
if|if
condition|(
name|match_substring
argument_list|(
name|string
argument_list|,
literal|"ROM"
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|flags
operator|&
name|SEC_CONSTRUCTOR
condition|)
if|if
condition|(
name|match_substring
argument_list|(
name|string
argument_list|,
literal|"CONSTRUCTOR"
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|flags
operator|&
name|SEC_HAS_CONTENTS
condition|)
if|if
condition|(
name|match_substring
argument_list|(
name|string
argument_list|,
literal|"HAS_CONTENTS"
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|flags
operator|&
name|SEC_NEVER_LOAD
condition|)
if|if
condition|(
name|match_substring
argument_list|(
name|string
argument_list|,
literal|"NEVER_LOAD"
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|flags
operator|&
name|SEC_COFF_SHARED_LIBRARY
condition|)
if|if
condition|(
name|match_substring
argument_list|(
name|string
argument_list|,
literal|"COFF_SHARED_LIBRARY"
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|flags
operator|&
name|SEC_IS_COMMON
condition|)
if|if
condition|(
name|match_substring
argument_list|(
name|string
argument_list|,
literal|"IS_COMMON"
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_bfd_flags
parameter_list|(
name|flagword
name|flags
parameter_list|)
block|{
if|if
condition|(
name|flags
operator|&
name|SEC_ALLOC
condition|)
name|printf_filtered
argument_list|(
literal|" ALLOC"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SEC_LOAD
condition|)
name|printf_filtered
argument_list|(
literal|" LOAD"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SEC_RELOC
condition|)
name|printf_filtered
argument_list|(
literal|" RELOC"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SEC_READONLY
condition|)
name|printf_filtered
argument_list|(
literal|" READONLY"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SEC_CODE
condition|)
name|printf_filtered
argument_list|(
literal|" CODE"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SEC_DATA
condition|)
name|printf_filtered
argument_list|(
literal|" DATA"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SEC_ROM
condition|)
name|printf_filtered
argument_list|(
literal|" ROM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SEC_CONSTRUCTOR
condition|)
name|printf_filtered
argument_list|(
literal|" CONSTRUCTOR"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SEC_HAS_CONTENTS
condition|)
name|printf_filtered
argument_list|(
literal|" HAS_CONTENTS"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SEC_NEVER_LOAD
condition|)
name|printf_filtered
argument_list|(
literal|" NEVER_LOAD"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SEC_COFF_SHARED_LIBRARY
condition|)
name|printf_filtered
argument_list|(
literal|" COFF_SHARED_LIBRARY"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SEC_IS_COMMON
condition|)
name|printf_filtered
argument_list|(
literal|" IS_COMMON"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|maint_print_section_info
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|flagword
name|flags
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|,
name|CORE_ADDR
name|endaddr
parameter_list|,
name|unsigned
name|long
name|filepos
parameter_list|)
block|{
comment|/* FIXME-32x64: Need print_address_numeric with field width.  */
name|printf_filtered
argument_list|(
literal|"    0x%s"
argument_list|,
name|paddr
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"->0x%s"
argument_list|,
name|paddr
argument_list|(
name|endaddr
argument_list|)
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" at %s"
argument_list|,
name|local_hex_string_custom
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|filepos
argument_list|,
literal|"08l"
argument_list|)
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|": %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|print_bfd_flags
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_bfd_section_info
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|asect
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|flagword
name|flags
init|=
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|bfd_section_name
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|)
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
operator|||
operator|*
operator|(
operator|(
name|char
operator|*
operator|)
name|arg
operator|)
operator|==
literal|'\0'
operator|||
name|match_substring
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|,
name|name
argument_list|)
operator|||
name|match_bfd_flags
argument_list|(
operator|(
name|char
operator|*
operator|)
name|arg
argument_list|,
name|flags
argument_list|)
condition|)
block|{
name|CORE_ADDR
name|addr
decl_stmt|,
name|endaddr
decl_stmt|;
name|addr
operator|=
name|bfd_section_vma
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|)
expr_stmt|;
name|endaddr
operator|=
name|addr
operator|+
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|)
expr_stmt|;
name|maint_print_section_info
argument_list|(
name|name
argument_list|,
name|flags
argument_list|,
name|addr
argument_list|,
name|endaddr
argument_list|,
name|asect
operator|->
name|filepos
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|print_objfile_section_info
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|struct
name|obj_section
modifier|*
name|asect
parameter_list|,
name|char
modifier|*
name|string
parameter_list|)
block|{
name|flagword
name|flags
init|=
name|bfd_get_section_flags
argument_list|(
name|abfd
argument_list|,
name|asect
operator|->
name|the_bfd_section
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|bfd_section_name
argument_list|(
name|abfd
argument_list|,
name|asect
operator|->
name|the_bfd_section
argument_list|)
decl_stmt|;
if|if
condition|(
name|string
operator|==
name|NULL
operator|||
operator|*
name|string
operator|==
literal|'\0'
operator|||
name|match_substring
argument_list|(
name|string
argument_list|,
name|name
argument_list|)
operator|||
name|match_bfd_flags
argument_list|(
name|string
argument_list|,
name|flags
argument_list|)
condition|)
block|{
name|maint_print_section_info
argument_list|(
name|name
argument_list|,
name|flags
argument_list|,
name|asect
operator|->
name|addr
argument_list|,
name|asect
operator|->
name|endaddr
argument_list|,
name|asect
operator|->
name|the_bfd_section
operator|->
name|filepos
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|maintenance_info_sections
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|exec_bfd
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Exec file:\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"    `%s', "
argument_list|,
name|bfd_get_filename
argument_list|(
name|exec_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"        "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"file type %s.\n"
argument_list|,
name|bfd_get_target
argument_list|(
name|exec_bfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|arg
operator|&&
operator|*
name|arg
operator|&&
name|match_substring
argument_list|(
name|arg
argument_list|,
literal|"ALLOBJ"
argument_list|)
condition|)
block|{
name|struct
name|objfile
modifier|*
name|ofile
decl_stmt|;
name|struct
name|obj_section
modifier|*
name|osect
decl_stmt|;
comment|/* Only this function cares about the 'ALLOBJ' argument;  	     if 'ALLOBJ' is the only argument, discard it rather than 	     passing it down to print_objfile_section_info (which  	     wouldn't know how to handle it).  */
if|if
condition|(
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"ALLOBJ"
argument_list|)
operator|==
literal|0
condition|)
name|arg
operator|=
name|NULL
expr_stmt|;
name|ALL_OBJFILES
argument_list|(
argument|ofile
argument_list|)
block|{
name|printf_filtered
argument_list|(
literal|"  Object file: %s\n"
argument_list|,
name|bfd_get_filename
argument_list|(
name|ofile
operator|->
name|obfd
argument_list|)
argument_list|)
expr_stmt|;
name|ALL_OBJFILE_OSECTIONS
argument_list|(
argument|ofile
argument_list|,
argument|osect
argument_list|)
block|{
name|print_objfile_section_info
argument_list|(
name|ofile
operator|->
name|obfd
argument_list|,
name|osect
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|bfd_map_over_sections
argument_list|(
name|exec_bfd
argument_list|,
name|print_bfd_section_info
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|core_bfd
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Core file:\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"    `%s', "
argument_list|,
name|bfd_get_filename
argument_list|(
name|core_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"        "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"file type %s.\n"
argument_list|,
name|bfd_get_target
argument_list|(
name|core_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|core_bfd
argument_list|,
name|print_bfd_section_info
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|maintenance_print_statistics
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|print_objfile_statistics
argument_list|()
expr_stmt|;
name|print_symbol_bcache_statistics
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|maintenance_print_architecture
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
name|gdbarch_dump
argument_list|(
name|current_gdbarch
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|ui_file
modifier|*
name|file
init|=
name|gdb_fopen
argument_list|(
name|args
argument_list|,
literal|"w"
argument_list|)
decl_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
name|perror_with_name
argument_list|(
literal|"maintenance print architecture"
argument_list|)
expr_stmt|;
name|gdbarch_dump
argument_list|(
name|current_gdbarch
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|ui_file_delete
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The "maintenance print" command is defined as a prefix, with    allow_unknown 0.  Therefore, its own definition is called only for    "maintenance print" with no args.  */
end_comment

begin_function
specifier|static
name|void
name|maintenance_print_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\"maintenance print\" must be followed by the name of a print command.\n"
argument_list|)
expr_stmt|;
name|help_list
argument_list|(
name|maintenanceprintlist
argument_list|,
literal|"maintenance print "
argument_list|,
operator|-
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The "maintenance translate-address" command converts a section and address    to a symbol.  This can be called in two ways:    maintenance translate-address<secname><addr>    or   maintenance translate-address<addr>  */
end_comment

begin_function
specifier|static
name|void
name|maintenance_translate_address
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|CORE_ADDR
name|address
decl_stmt|;
name|asection
modifier|*
name|sect
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
operator|||
operator|*
name|arg
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"requires argument (address or section + address)"
argument_list|)
expr_stmt|;
name|sect
operator|=
name|NULL
expr_stmt|;
name|p
operator|=
name|arg
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
comment|/* See if we have a valid section name */
while|while
condition|(
operator|*
name|p
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
comment|/* Find end of section name */
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\000'
condition|)
comment|/* End of command? */
name|error
argument_list|(
literal|"Need to specify<section-name> and<address>"
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\000'
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Skip whitespace */
name|ALL_OBJFILES
argument_list|(
argument|objfile
argument_list|)
block|{
name|sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|sect
operator|!=
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|sect
condition|)
name|error
argument_list|(
literal|"Unknown section %s."
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
name|address
operator|=
name|parse_and_eval_address
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|sect
condition|)
name|sym
operator|=
name|lookup_minimal_symbol_by_pc_section
argument_list|(
name|address
argument_list|,
name|sect
argument_list|)
expr_stmt|;
else|else
name|sym
operator|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
name|printf_filtered
argument_list|(
literal|"%s+%s\n"
argument_list|,
name|SYMBOL_PRINT_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|paddr_u
argument_list|(
name|address
operator|-
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sect
condition|)
name|printf_filtered
argument_list|(
literal|"no symbol at %s:0x%s\n"
argument_list|,
name|sect
operator|->
name|name
argument_list|,
name|paddr
argument_list|(
name|address
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"no symbol at 0x%s\n"
argument_list|,
name|paddr
argument_list|(
name|address
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* When a command is deprecated the user will be warned the first time    the command is used.  If possible, a replacement will be    offered. */
end_comment

begin_function
specifier|static
name|void
name|maintenance_deprecate
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|args
operator|==
name|NULL
operator|||
operator|*
name|args
operator|==
literal|'\0'
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\"maintenance deprecate\" takes an argument, \n\ the command you want to deprecate, and optionally the replacement command \n\ enclosed in quotes.\n"
argument_list|)
expr_stmt|;
block|}
name|maintenance_do_deprecate
argument_list|(
name|args
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|maintenance_undeprecate
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|args
operator|==
name|NULL
operator|||
operator|*
name|args
operator|==
literal|'\0'
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\"maintenance undeprecate\" takes an argument, \n\ the command you want to undeprecate.\n"
argument_list|)
expr_stmt|;
block|}
name|maintenance_do_deprecate
argument_list|(
name|args
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* You really shouldn't be using this. It is just for the testsuite.    Rather, you should use deprecate_cmd() when the command is created    in _initialize_blah().     This function deprecates a command and optionally assigns it a    replacement.  */
end_comment

begin_function
specifier|static
name|void
name|maintenance_do_deprecate
parameter_list|(
name|char
modifier|*
name|text
parameter_list|,
name|int
name|deprecate
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|alias
init|=
name|NULL
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|prefix_cmd
init|=
name|NULL
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|cmd
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|start_ptr
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|end_ptr
init|=
name|NULL
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|replacement
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|text
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|!
name|lookup_cmd_composition
argument_list|(
name|text
argument_list|,
operator|&
name|alias
argument_list|,
operator|&
name|prefix_cmd
argument_list|,
operator|&
name|cmd
argument_list|)
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Can't find command '%s' to deprecate.\n"
argument_list|,
name|text
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|deprecate
condition|)
block|{
comment|/* look for a replacement command */
name|start_ptr
operator|=
name|strchr
argument_list|(
name|text
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_ptr
operator|!=
name|NULL
condition|)
block|{
name|start_ptr
operator|++
expr_stmt|;
name|end_ptr
operator|=
name|strrchr
argument_list|(
name|start_ptr
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
if|if
condition|(
name|end_ptr
operator|!=
name|NULL
condition|)
block|{
name|len
operator|=
name|end_ptr
operator|-
name|start_ptr
expr_stmt|;
name|start_ptr
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|replacement
operator|=
name|xstrdup
argument_list|(
name|start_ptr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|start_ptr
operator|||
operator|!
name|end_ptr
condition|)
name|replacement
operator|=
name|NULL
expr_stmt|;
comment|/* If they used an alias, we only want to deprecate the alias.       Note the MALLOCED_REPLACEMENT test.  If the command's replacement      string was allocated at compile time we don't want to free the      memory. */
if|if
condition|(
name|alias
condition|)
block|{
if|if
condition|(
name|alias
operator|->
name|flags
operator|&
name|MALLOCED_REPLACEMENT
condition|)
name|xfree
argument_list|(
name|alias
operator|->
name|replacement
argument_list|)
expr_stmt|;
if|if
condition|(
name|deprecate
condition|)
name|alias
operator|->
name|flags
operator||=
operator|(
name|DEPRECATED_WARN_USER
operator||
name|CMD_DEPRECATED
operator|)
expr_stmt|;
else|else
name|alias
operator|->
name|flags
operator|&=
operator|~
operator|(
name|DEPRECATED_WARN_USER
operator||
name|CMD_DEPRECATED
operator|)
expr_stmt|;
name|alias
operator|->
name|replacement
operator|=
name|replacement
expr_stmt|;
name|alias
operator|->
name|flags
operator||=
name|MALLOCED_REPLACEMENT
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|cmd
condition|)
block|{
if|if
condition|(
name|cmd
operator|->
name|flags
operator|&
name|MALLOCED_REPLACEMENT
condition|)
name|xfree
argument_list|(
name|cmd
operator|->
name|replacement
argument_list|)
expr_stmt|;
if|if
condition|(
name|deprecate
condition|)
name|cmd
operator|->
name|flags
operator||=
operator|(
name|DEPRECATED_WARN_USER
operator||
name|CMD_DEPRECATED
operator|)
expr_stmt|;
else|else
name|cmd
operator|->
name|flags
operator|&=
operator|~
operator|(
name|DEPRECATED_WARN_USER
operator||
name|CMD_DEPRECATED
operator|)
expr_stmt|;
name|cmd
operator|->
name|replacement
operator|=
name|replacement
expr_stmt|;
name|cmd
operator|->
name|flags
operator||=
name|MALLOCED_REPLACEMENT
expr_stmt|;
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Maintenance set/show framework.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cmd_list_element
modifier|*
name|maintenance_set_cmdlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cmd_list_element
modifier|*
name|maintenance_show_cmdlist
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|maintenance_set_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\"maintenance set\" must be followed by the name of a set command.\n"
argument_list|)
expr_stmt|;
name|help_list
argument_list|(
name|maintenance_set_cmdlist
argument_list|,
literal|"maintenance set "
argument_list|,
operator|-
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|maintenance_show_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|cmd_show_list
argument_list|(
name|maintenance_show_cmdlist
argument_list|,
name|from_tty
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Profiling support.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|maintenance_profile_p
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_MONSTARTUP
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE__MCLEANUP
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE__ETEXT
end_ifdef

begin_decl_stmt
specifier|extern
name|char
name|_etext
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TEXTEND
value|&_etext
end_define

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|char
name|etext
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TEXTEND
value|&etext
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|profiling_state
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|mcleanup_wrapper
parameter_list|(
name|void
parameter_list|)
block|{
specifier|extern
name|void
name|_mcleanup
argument_list|(
name|void
argument_list|)
decl_stmt|;
if|if
condition|(
name|profiling_state
condition|)
name|_mcleanup
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|maintenance_set_profile_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
name|maintenance_profile_p
operator|==
name|profiling_state
condition|)
return|return;
name|profiling_state
operator|=
name|maintenance_profile_p
expr_stmt|;
if|if
condition|(
name|maintenance_profile_p
condition|)
block|{
specifier|static
name|int
name|profiling_initialized
decl_stmt|;
specifier|extern
name|void
name|monstartup
argument_list|(
name|unsigned
name|long
argument_list|,
name|unsigned
name|long
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|main
parameter_list|()
function_decl|;
if|if
condition|(
operator|!
name|profiling_initialized
condition|)
block|{
name|atexit
argument_list|(
name|mcleanup_wrapper
argument_list|)
expr_stmt|;
name|profiling_initialized
operator|=
literal|1
expr_stmt|;
block|}
comment|/* "main" is now always the first function in the text segment, so use 	 its address for monstartup.  */
name|monstartup
argument_list|(
operator|(
name|unsigned
name|long
operator|)
operator|&
expr|main
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|TEXTEND
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|extern
name|void
name|_mcleanup
argument_list|(
name|void
argument_list|)
decl_stmt|;
name|_mcleanup
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|void
name|maintenance_set_profile_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|error
argument_list|(
literal|"Profiling support is not available on this system."
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|_initialize_maint_cmds
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|tmpcmd
decl_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"maintenance"
argument_list|,
name|class_maintenance
argument_list|,
name|maintenance_command
argument_list|,
literal|"Commands for use by GDB maintainers.\n\ Includes commands to dump specific internal GDB structures in\n\ a human readable form, to cause GDB to deliberately dump core,\n\ to test internal functions such as the C++/ObjC demangler, etc."
argument_list|,
operator|&
name|maintenancelist
argument_list|,
literal|"maintenance "
argument_list|,
literal|0
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"mt"
argument_list|,
literal|"maintenance"
argument_list|,
name|class_maintenance
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"info"
argument_list|,
name|class_maintenance
argument_list|,
name|maintenance_info_command
argument_list|,
literal|"Commands for showing internal info about the program being debugged."
argument_list|,
operator|&
name|maintenanceinfolist
argument_list|,
literal|"maintenance info "
argument_list|,
literal|0
argument_list|,
operator|&
name|maintenancelist
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
literal|"i"
argument_list|,
literal|"info"
argument_list|,
name|class_maintenance
argument_list|,
literal|1
argument_list|,
operator|&
name|maintenancelist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"sections"
argument_list|,
name|class_maintenance
argument_list|,
name|maintenance_info_sections
argument_list|,
literal|"List the BFD sections of the exec and core files. \n\ Arguments may be any combination of:\n\ 	[one or more section names]\n\ 	ALLOC LOAD RELOC READONLY CODE DATA ROM CONSTRUCTOR\n\ 	HAS_CONTENTS NEVER_LOAD COFF_SHARED_LIBRARY IS_COMMON\n\ Sections matching any argument will be listed (no argument\n\ implies all sections).  In addition, the special argument\n\ 	ALLOBJ\n\ lists all sections from all object files, including shared libraries."
argument_list|,
operator|&
name|maintenanceinfolist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"print"
argument_list|,
name|class_maintenance
argument_list|,
name|maintenance_print_command
argument_list|,
literal|"Maintenance command for printing GDB internal state."
argument_list|,
operator|&
name|maintenanceprintlist
argument_list|,
literal|"maintenance print "
argument_list|,
literal|0
argument_list|,
operator|&
name|maintenancelist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"set"
argument_list|,
name|class_maintenance
argument_list|,
name|maintenance_set_cmd
argument_list|,
literal|"\ Set GDB internal variables used by the GDB maintainer.\n\ Configure variables internal to GDB that aid in GDB's maintenance"
argument_list|,
operator|&
name|maintenance_set_cmdlist
argument_list|,
literal|"maintenance set "
argument_list|,
literal|0
comment|/*allow-unknown*/
argument_list|,
operator|&
name|maintenancelist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"show"
argument_list|,
name|class_maintenance
argument_list|,
name|maintenance_show_cmd
argument_list|,
literal|"\ Show GDB internal variables used by the GDB maintainer.\n\ Configure variables internal to GDB that aid in GDB's maintenance"
argument_list|,
operator|&
name|maintenance_show_cmdlist
argument_list|,
literal|"maintenance show "
argument_list|,
literal|0
comment|/*allow-unknown*/
argument_list|,
operator|&
name|maintenancelist
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|_WIN32
name|add_cmd
argument_list|(
literal|"dump-me"
argument_list|,
name|class_maintenance
argument_list|,
name|maintenance_dump_me
argument_list|,
literal|"Get fatal error; make debugger dump its core.\n\ GDB sets its handling of SIGQUIT back to SIG_DFL and then sends\n\ itself a SIGQUIT signal."
argument_list|,
operator|&
name|maintenancelist
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|add_cmd
argument_list|(
literal|"internal-error"
argument_list|,
name|class_maintenance
argument_list|,
name|maintenance_internal_error
argument_list|,
literal|"Give GDB an internal error.\n\ Cause GDB to behave as if an internal error was detected."
argument_list|,
operator|&
name|maintenancelist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"internal-warning"
argument_list|,
name|class_maintenance
argument_list|,
name|maintenance_internal_warning
argument_list|,
literal|"Give GDB an internal warning.\n\ Cause GDB to behave as if an internal warning was reported."
argument_list|,
operator|&
name|maintenancelist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"demangle"
argument_list|,
name|class_maintenance
argument_list|,
name|maintenance_demangle
argument_list|,
literal|"Demangle a C++/ObjC mangled name.\n\ Call internal GDB demangler routine to demangle a C++ link name\n\ and prints the result."
argument_list|,
operator|&
name|maintenancelist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"time"
argument_list|,
name|class_maintenance
argument_list|,
name|maintenance_time_display
argument_list|,
literal|"Set the display of time usage.\n\ If nonzero, will cause the execution time for each command to be\n\ displayed, following the command's output."
argument_list|,
operator|&
name|maintenancelist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"space"
argument_list|,
name|class_maintenance
argument_list|,
name|maintenance_space_display
argument_list|,
literal|"Set the display of space usage.\n\ If nonzero, will cause the execution space for each command to be\n\ displayed, following the command's output."
argument_list|,
operator|&
name|maintenancelist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"type"
argument_list|,
name|class_maintenance
argument_list|,
name|maintenance_print_type
argument_list|,
literal|"Print a type chain for a given symbol.\n\ For each node in a type chain, print the raw data for each member of\n\ the type structure, and the interpretation of the data."
argument_list|,
operator|&
name|maintenanceprintlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"symbols"
argument_list|,
name|class_maintenance
argument_list|,
name|maintenance_print_symbols
argument_list|,
literal|"Print dump of current symbol definitions.\n\ Entries in the full symbol table are dumped to file OUTFILE.\n\ If a SOURCE file is specified, dump only that file's symbols."
argument_list|,
operator|&
name|maintenanceprintlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"msymbols"
argument_list|,
name|class_maintenance
argument_list|,
name|maintenance_print_msymbols
argument_list|,
literal|"Print dump of current minimal symbol definitions.\n\ Entries in the minimal symbol table are dumped to file OUTFILE.\n\ If a SOURCE file is specified, dump only that file's minimal symbols."
argument_list|,
operator|&
name|maintenanceprintlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"psymbols"
argument_list|,
name|class_maintenance
argument_list|,
name|maintenance_print_psymbols
argument_list|,
literal|"Print dump of current partial symbol definitions.\n\ Entries in the partial symbol table are dumped to file OUTFILE.\n\ If a SOURCE file is specified, dump only that file's partial symbols."
argument_list|,
operator|&
name|maintenanceprintlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"objfiles"
argument_list|,
name|class_maintenance
argument_list|,
name|maintenance_print_objfiles
argument_list|,
literal|"Print dump of current object file definitions."
argument_list|,
operator|&
name|maintenanceprintlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"symtabs"
argument_list|,
name|class_maintenance
argument_list|,
name|maintenance_info_symtabs
argument_list|,
literal|"List the full symbol tables for all object files.\n\ This does not include information about individual symbols, blocks, or\n\ linetables --- just the symbol table structures themselves.\n\ With an argument REGEXP, list the symbol tables whose names that match that."
argument_list|,
operator|&
name|maintenanceinfolist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"psymtabs"
argument_list|,
name|class_maintenance
argument_list|,
name|maintenance_info_psymtabs
argument_list|,
literal|"List the partial symbol tables for all object files.\n\ This does not include information about individual partial symbols,\n\ just the symbol table structures themselves."
argument_list|,
operator|&
name|maintenanceinfolist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"statistics"
argument_list|,
name|class_maintenance
argument_list|,
name|maintenance_print_statistics
argument_list|,
literal|"Print statistics about internal gdb state."
argument_list|,
operator|&
name|maintenanceprintlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"architecture"
argument_list|,
name|class_maintenance
argument_list|,
name|maintenance_print_architecture
argument_list|,
literal|"Print the internal architecture configuration.\ Takes an optional file parameter."
argument_list|,
operator|&
name|maintenanceprintlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"check-symtabs"
argument_list|,
name|class_maintenance
argument_list|,
name|maintenance_check_symtabs
argument_list|,
literal|"Check consistency of psymtabs and symtabs."
argument_list|,
operator|&
name|maintenancelist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"translate-address"
argument_list|,
name|class_maintenance
argument_list|,
name|maintenance_translate_address
argument_list|,
literal|"Translate a section name and address to a symbol."
argument_list|,
operator|&
name|maintenancelist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"deprecate"
argument_list|,
name|class_maintenance
argument_list|,
name|maintenance_deprecate
argument_list|,
literal|"Deprecate a command.  Note that this is just in here so the \n\ testsuite can check the comamnd deprecator. You probably shouldn't use this,\n\ rather you should use the C function deprecate_cmd().  If you decide you \n\ want to use it: maintenance deprecate 'commandname' \"replacement\". The \n\ replacement is optional."
argument_list|,
operator|&
name|maintenancelist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"undeprecate"
argument_list|,
name|class_maintenance
argument_list|,
name|maintenance_undeprecate
argument_list|,
literal|"Undeprecate a command.  Note that this is just in here so the \n\ testsuite can check the comamnd deprecator. You probably shouldn't use this,\n\ If you decide you want to use it: maintenance undeprecate 'commandname'"
argument_list|,
operator|&
name|maintenancelist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"watchdog"
argument_list|,
name|class_maintenance
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|watchdog
argument_list|,
literal|"Set watchdog timer.\n\ When non-zero, this timeout is used instead of waiting forever for a target to\n\ finish a low-level step or continue operation.  If the specified amount of time\n\ passes without a response from the target, an error occurs."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_setshow_boolean_cmd
argument_list|(
literal|"profile"
argument_list|,
name|class_maintenance
argument_list|,
operator|&
name|maintenance_profile_p
argument_list|,
literal|"Set internal profiling.\n"
literal|"When enabled GDB is profiled."
argument_list|,
literal|"Show internal profiling.\n"
argument_list|,
name|maintenance_set_profile_cmd
argument_list|,
name|NULL
argument_list|,
operator|&
name|maintenance_set_cmdlist
argument_list|,
operator|&
name|maintenance_show_cmdlist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

