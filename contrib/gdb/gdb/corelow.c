begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Core dump and executable file functions below target vector, for GDB.     Copyright 1986, 1987, 1989, 1991, 1992, 1993, 1994, 1995, 1996,    1997, 1998, 1999, 2000, 2001, 2003, 2004 Free Software Foundation,    Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"arch-utils.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_FILE_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_comment
comment|/* needed for F_OK and friends */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_comment
comment|/* required by inferior.h */
end_comment

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"gdbthread.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"regset.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"exec.h"
end_include

begin_include
include|#
directive|include
file|"readline/readline.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|O_BINARY
end_ifndef

begin_define
define|#
directive|define
name|O_BINARY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* List of all available core_fns.  On gdb startup, each core file register    reader calls add_core_fns() to register information on each core format it    is prepared to read. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|core_fns
modifier|*
name|core_file_fns
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The core_fns for a core file handler that is prepared to read the core    file currently open on core_bfd. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|core_fns
modifier|*
name|core_vec
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FIXME: kettenis/20031023: Eventually this variable should    disappear.  */
end_comment

begin_decl_stmt
name|struct
name|gdbarch
modifier|*
name|core_gdbarch
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|core_files_info
parameter_list|(
name|struct
name|target_ops
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SOLIB_ADD
end_ifdef

begin_function_decl
specifier|static
name|int
name|solib_add_stub
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|struct
name|core_fns
modifier|*
name|sniff_core_bfd
parameter_list|(
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gdb_check_format
parameter_list|(
name|bfd
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|core_open
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|core_detach
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|core_close
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|core_close_cleanup
parameter_list|(
name|void
modifier|*
name|ignore
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|get_core_registers
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_to_thread_list
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|asection
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ignore
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|core_file_thread_alive
parameter_list|(
name|ptid_t
name|tid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_core_ops
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|_initialize_corelow
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|target_ops
name|core_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Link a new core_fns into the global core_file_fns list.  Called on gdb    startup by the _initialize routine in each core file register reader, to    register information about each format the the reader is prepared to    handle. */
end_comment

begin_function
name|void
name|add_core_fns
parameter_list|(
name|struct
name|core_fns
modifier|*
name|cf
parameter_list|)
block|{
name|cf
operator|->
name|next
operator|=
name|core_file_fns
expr_stmt|;
name|core_file_fns
operator|=
name|cf
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The default function that core file handlers can use to examine a    core file BFD and decide whether or not to accept the job of    reading the core file. */
end_comment

begin_function
name|int
name|default_core_sniffer
parameter_list|(
name|struct
name|core_fns
modifier|*
name|our_fns
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
name|result
operator|=
operator|(
name|bfd_get_flavour
argument_list|(
name|abfd
argument_list|)
operator|==
name|our_fns
operator|->
name|core_flavour
operator|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Walk through the list of core functions to find a set that can    handle the core file open on ABFD.  Default to the first one in the    list if nothing matches.  Returns pointer to set that is    selected. */
end_comment

begin_function
specifier|static
name|struct
name|core_fns
modifier|*
name|sniff_core_bfd
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|core_fns
modifier|*
name|cf
decl_stmt|;
name|struct
name|core_fns
modifier|*
name|yummy
init|=
name|NULL
decl_stmt|;
name|int
name|matches
init|=
literal|0
decl_stmt|;
empty_stmt|;
comment|/* Don't sniff if we have support for register sets in CORE_GDBARCH.  */
if|if
condition|(
name|core_gdbarch
operator|&&
name|gdbarch_regset_from_core_section_p
argument_list|(
name|core_gdbarch
argument_list|)
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|cf
operator|=
name|core_file_fns
init|;
name|cf
operator|!=
name|NULL
condition|;
name|cf
operator|=
name|cf
operator|->
name|next
control|)
block|{
if|if
condition|(
name|cf
operator|->
name|core_sniffer
argument_list|(
name|cf
argument_list|,
name|abfd
argument_list|)
condition|)
block|{
name|yummy
operator|=
name|cf
expr_stmt|;
name|matches
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|matches
operator|>
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"\"%s\": ambiguous core format, %d handlers match"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|matches
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|matches
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"\"%s\": no core file handler recognizes format, using default"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yummy
operator|==
name|NULL
condition|)
block|{
name|yummy
operator|=
name|core_file_fns
expr_stmt|;
block|}
return|return
operator|(
name|yummy
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The default is to reject every core file format we see.  Either    BFD has to recognize it, or we have to provide a function in the    core file handler that recognizes it. */
end_comment

begin_function
name|int
name|default_check_format
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Attempt to recognize core file formats that BFD rejects. */
end_comment

begin_function
specifier|static
name|int
name|gdb_check_format
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|core_fns
modifier|*
name|cf
decl_stmt|;
for|for
control|(
name|cf
operator|=
name|core_file_fns
init|;
name|cf
operator|!=
name|NULL
condition|;
name|cf
operator|=
name|cf
operator|->
name|next
control|)
block|{
if|if
condition|(
name|cf
operator|->
name|check_format
argument_list|(
name|abfd
argument_list|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Discard all vestiges of any previous core file and mark data and stack    spaces as empty.  */
end_comment

begin_function
specifier|static
name|void
name|core_close
parameter_list|(
name|int
name|quitting
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|core_bfd
condition|)
block|{
name|inferior_ptid
operator|=
name|null_ptid
expr_stmt|;
comment|/* Avoid confusion from thread stuff */
comment|/* Clear out solib state while the bfd is still open. See          comments in clear_solib in solib.c. */
ifdef|#
directive|ifdef
name|CLEAR_SOLIB
name|CLEAR_SOLIB
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|name
operator|=
name|bfd_get_filename
argument_list|(
name|core_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_close
argument_list|(
name|core_bfd
argument_list|)
condition|)
name|warning
argument_list|(
literal|"cannot close \"%s\": %s"
argument_list|,
name|name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|core_bfd
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|core_ops
operator|.
name|to_sections
condition|)
block|{
name|xfree
argument_list|(
name|core_ops
operator|.
name|to_sections
argument_list|)
expr_stmt|;
name|core_ops
operator|.
name|to_sections
operator|=
name|NULL
expr_stmt|;
name|core_ops
operator|.
name|to_sections_end
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|core_vec
operator|=
name|NULL
expr_stmt|;
name|core_gdbarch
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|core_close_cleanup
parameter_list|(
name|void
modifier|*
name|ignore
parameter_list|)
block|{
name|core_close
argument_list|(
literal|0
comment|/*ignored*/
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SOLIB_ADD
end_ifdef

begin_comment
comment|/* Stub function for catch_errors around shared library hacking.  FROM_TTYP    is really an int * which points to from_tty.  */
end_comment

begin_function
specifier|static
name|int
name|solib_add_stub
parameter_list|(
name|void
modifier|*
name|from_ttyp
parameter_list|)
block|{
name|SOLIB_ADD
argument_list|(
name|NULL
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|from_ttyp
argument_list|,
operator|&
name|current_target
argument_list|,
name|auto_solib_add
argument_list|)
expr_stmt|;
name|re_enable_breakpoints_in_shlibs
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SOLIB_ADD */
end_comment

begin_comment
comment|/* Look for sections whose names start with `.reg/' so that we can extract the    list of threads in a core file.  */
end_comment

begin_function
specifier|static
name|void
name|add_to_thread_list
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|asect
parameter_list|,
name|void
modifier|*
name|reg_sect_arg
parameter_list|)
block|{
name|int
name|thread_id
decl_stmt|;
name|asection
modifier|*
name|reg_sect
init|=
operator|(
name|asection
operator|*
operator|)
name|reg_sect_arg
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|bfd_section_name
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|)
argument_list|,
literal|".reg/"
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|thread_id
operator|=
name|atoi
argument_list|(
name|bfd_section_name
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|add_thread
argument_list|(
name|pid_to_ptid
argument_list|(
name|thread_id
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Warning, Will Robinson, looking at BFD private data! */
if|if
condition|(
name|reg_sect
operator|!=
name|NULL
operator|&&
name|asect
operator|->
name|filepos
operator|==
name|reg_sect
operator|->
name|filepos
condition|)
comment|/* Did we find .reg? */
name|inferior_ptid
operator|=
name|pid_to_ptid
argument_list|(
name|thread_id
argument_list|)
expr_stmt|;
comment|/* Yes, make it current */
block|}
end_function

begin_comment
comment|/* This routine opens and sets up the core file bfd.  */
end_comment

begin_function
specifier|static
name|void
name|core_open
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|siggy
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
name|bfd
modifier|*
name|temp_bfd
decl_stmt|;
name|int
name|ontop
decl_stmt|;
name|int
name|scratch_chan
decl_stmt|;
name|target_preopen
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|filename
condition|)
block|{
name|error
argument_list|(
name|core_bfd
condition|?
literal|"No core file specified.  (Use `detach' to stop debugging a core file.)"
else|:
literal|"No core file specified."
argument_list|)
expr_stmt|;
block|}
name|filename
operator|=
name|tilde_expand
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
name|temp
operator|=
name|concat
argument_list|(
name|current_directory
argument_list|,
literal|"/"
argument_list|,
name|filename
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|filename
operator|=
name|temp
expr_stmt|;
block|}
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|scratch_chan
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_BINARY
operator||
operator|(
name|write_files
condition|?
name|O_RDWR
else|:
name|O_RDONLY
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|scratch_chan
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|temp_bfd
operator|=
name|bfd_fdopenr
argument_list|(
name|filename
argument_list|,
name|gnutarget
argument_list|,
name|scratch_chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp_bfd
operator|==
name|NULL
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|temp_bfd
argument_list|,
name|bfd_core
argument_list|)
operator|&&
operator|!
name|gdb_check_format
argument_list|(
name|temp_bfd
argument_list|)
condition|)
block|{
comment|/* Do it after the err msg */
comment|/* FIXME: should be checking for errors from bfd_close (for one thing,          on error it does not free all the storage associated with the          bfd).  */
name|make_cleanup_bfd_close
argument_list|(
name|temp_bfd
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"\"%s\" is not a core dump: %s"
argument_list|,
name|filename
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Looks semi-reasonable.  Toss the old core file and work on the new.  */
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
comment|/* Don't free filename any more */
name|unpush_target
argument_list|(
operator|&
name|core_ops
argument_list|)
expr_stmt|;
name|core_bfd
operator|=
name|temp_bfd
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|core_close_cleanup
argument_list|,
literal|0
comment|/*ignore*/
argument_list|)
expr_stmt|;
comment|/* FIXME: kettenis/20031023: This is very dangerous.  The      CORE_GDBARCH that results from this call may very well be      different from CURRENT_GDBARCH.  However, its methods may only      work if it is selected as the current architecture, because they      rely on swapped data (see gdbarch.c).  We should get rid of that      swapped data.  */
name|core_gdbarch
operator|=
name|gdbarch_from_bfd
argument_list|(
name|core_bfd
argument_list|)
expr_stmt|;
comment|/* Find a suitable core file handler to munch on core_bfd */
name|core_vec
operator|=
name|sniff_core_bfd
argument_list|(
name|core_bfd
argument_list|)
expr_stmt|;
name|validate_files
argument_list|()
expr_stmt|;
comment|/* Find the data section */
if|if
condition|(
name|build_section_table
argument_list|(
name|core_bfd
argument_list|,
operator|&
name|core_ops
operator|.
name|to_sections
argument_list|,
operator|&
name|core_ops
operator|.
name|to_sections_end
argument_list|)
condition|)
name|error
argument_list|(
literal|"\"%s\": Can't find sections: %s"
argument_list|,
name|bfd_get_filename
argument_list|(
name|core_bfd
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we have no exec file, try to set the architecture from the      core file.  We don't do this unconditionally since an exec file      typically contains more information that helps us determine the      architecture than a core file.  */
if|if
condition|(
operator|!
name|exec_bfd
condition|)
name|set_gdbarch_from_file
argument_list|(
name|core_bfd
argument_list|)
expr_stmt|;
name|ontop
operator|=
operator|!
name|push_target
argument_list|(
operator|&
name|core_ops
argument_list|)
expr_stmt|;
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
name|p
operator|=
name|bfd_core_file_failing_command
argument_list|(
name|core_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|printf_filtered
argument_list|(
literal|"Core was generated by `%s'.\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|siggy
operator|=
name|bfd_core_file_failing_signal
argument_list|(
name|core_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|siggy
operator|>
literal|0
condition|)
comment|/* NOTE: target_signal_from_host() converts a target signal value        into gdb's internal signal value.  Unfortunately gdb's internal        value is called ``target_signal'' and this function got the        name ..._from_host(). */
name|printf_filtered
argument_list|(
literal|"Program terminated with signal %d, %s.\n"
argument_list|,
name|siggy
argument_list|,
name|target_signal_to_string
argument_list|(
name|target_signal_from_host
argument_list|(
name|siggy
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Build up thread list from BFD sections. */
name|init_thread_list
argument_list|()
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|core_bfd
argument_list|,
name|add_to_thread_list
argument_list|,
name|bfd_get_section_by_name
argument_list|(
name|core_bfd
argument_list|,
literal|".reg"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ontop
condition|)
block|{
comment|/* Fetch all registers from core file.  */
name|target_fetch_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Add symbols and section mappings for any shared libraries.  */
ifdef|#
directive|ifdef
name|SOLIB_ADD
name|catch_errors
argument_list|(
name|solib_add_stub
argument_list|,
operator|&
name|from_tty
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Now, set up the frame cache, and print the top of stack.  */
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
expr_stmt|;
name|print_stack_frame
argument_list|(
name|deprecated_selected_frame
argument_list|,
name|frame_relative_level
argument_list|(
name|deprecated_selected_frame
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"you won't be able to access this core file until you terminate\n\ your %s; do ``info files''"
argument_list|,
name|target_longname
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|core_detach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|args
condition|)
name|error
argument_list|(
literal|"Too many arguments"
argument_list|)
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|core_ops
argument_list|)
expr_stmt|;
name|reinit_frame_cache
argument_list|()
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf_filtered
argument_list|(
literal|"No core file now.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Try to retrieve registers from a section in core_bfd, and supply    them to core_vec->core_read_registers, as the register set numbered    WHICH.     If inferior_ptid is zero, do the single-threaded thing: look for a    section named NAME.  If inferior_ptid is non-zero, do the    multi-threaded thing: look for a section named "NAME/PID", where    PID is the shortest ASCII decimal representation of inferior_ptid.     HUMAN_NAME is a human-readable name for the kind of registers the    NAME section contains, for use in error messages.     If REQUIRED is non-zero, print an error if the core file doesn't    have a section by the appropriate name.  Otherwise, just do nothing.  */
end_comment

begin_function
specifier|static
name|void
name|get_core_register_section
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|which
parameter_list|,
name|char
modifier|*
name|human_name
parameter_list|,
name|int
name|required
parameter_list|)
block|{
name|char
name|section_name
index|[
literal|100
index|]
decl_stmt|;
name|struct
name|bfd_section
modifier|*
name|section
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|char
modifier|*
name|contents
decl_stmt|;
if|if
condition|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
condition|)
name|sprintf
argument_list|(
name|section_name
argument_list|,
literal|"%s/%d"
argument_list|,
name|name
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|section_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|core_bfd
argument_list|,
name|section_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|section
condition|)
block|{
if|if
condition|(
name|required
condition|)
name|warning
argument_list|(
literal|"Couldn't find %s registers in core file.\n"
argument_list|,
name|human_name
argument_list|)
expr_stmt|;
return|return;
block|}
name|size
operator|=
name|bfd_section_size
argument_list|(
name|core_bfd
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|contents
operator|=
name|alloca
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|core_bfd
argument_list|,
name|section
argument_list|,
name|contents
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"Couldn't read %s registers from `%s' section in core file.\n"
argument_list|,
name|human_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|core_gdbarch
operator|&&
name|gdbarch_regset_from_core_section_p
argument_list|(
name|core_gdbarch
argument_list|)
condition|)
block|{
specifier|const
name|struct
name|regset
modifier|*
name|regset
decl_stmt|;
name|regset
operator|=
name|gdbarch_regset_from_core_section
argument_list|(
name|core_gdbarch
argument_list|,
name|name
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|regset
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|required
condition|)
name|warning
argument_list|(
literal|"Couldn't recognize %s registers in core file.\n"
argument_list|,
name|human_name
argument_list|)
expr_stmt|;
return|return;
block|}
name|regset
operator|->
name|supply_regset
argument_list|(
name|regset
argument_list|,
name|current_regcache
argument_list|,
operator|-
literal|1
argument_list|,
name|contents
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return;
block|}
name|gdb_assert
argument_list|(
name|core_vec
argument_list|)
expr_stmt|;
name|core_vec
operator|->
name|core_read_registers
argument_list|(
name|contents
argument_list|,
name|size
argument_list|,
name|which
argument_list|,
operator|(
operator|(
name|CORE_ADDR
operator|)
name|bfd_section_vma
argument_list|(
name|core_bfd
argument_list|,
name|section
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the registers out of a core file.  This is the machine-    independent part.  Fetch_core_registers is the machine-dependent    part, typically implemented in the xm-file for each architecture.  */
end_comment

begin_comment
comment|/* We just get all the registers, so we don't use regno.  */
end_comment

begin_function
specifier|static
name|void
name|get_core_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|core_gdbarch
operator|&&
name|gdbarch_regset_from_core_section_p
argument_list|(
name|core_gdbarch
argument_list|)
operator|)
operator|&&
operator|(
name|core_vec
operator|==
name|NULL
operator|||
name|core_vec
operator|->
name|core_read_registers
operator|==
name|NULL
operator|)
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Can't fetch registers from this type of core file\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|get_core_register_section
argument_list|(
literal|".reg"
argument_list|,
literal|0
argument_list|,
literal|"general-purpose"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|get_core_register_section
argument_list|(
literal|".reg2"
argument_list|,
literal|2
argument_list|,
literal|"floating-point"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|get_core_register_section
argument_list|(
literal|".reg-xfp"
argument_list|,
literal|3
argument_list|,
literal|"extended floating-point"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|deprecated_registers_fetched
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|core_files_info
parameter_list|(
name|struct
name|target_ops
modifier|*
name|t
parameter_list|)
block|{
name|print_section_info
argument_list|(
name|t
argument_list|,
name|core_bfd
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|LONGEST
name|core_xfer_partial
parameter_list|(
name|struct
name|target_ops
modifier|*
name|ops
parameter_list|,
name|enum
name|target_object
name|object
parameter_list|,
specifier|const
name|char
modifier|*
name|annex
parameter_list|,
name|void
modifier|*
name|readbuf
parameter_list|,
specifier|const
name|void
modifier|*
name|writebuf
parameter_list|,
name|ULONGEST
name|offset
parameter_list|,
name|LONGEST
name|len
parameter_list|)
block|{
switch|switch
condition|(
name|object
condition|)
block|{
case|case
name|TARGET_OBJECT_MEMORY
case|:
if|if
condition|(
name|readbuf
condition|)
return|return
call|(
modifier|*
name|ops
operator|->
name|to_xfer_memory
call|)
argument_list|(
name|offset
argument_list|,
name|readbuf
argument_list|,
name|len
argument_list|,
literal|0
comment|/*read*/
argument_list|,
name|NULL
argument_list|,
name|ops
argument_list|)
return|;
if|if
condition|(
name|writebuf
condition|)
return|return
call|(
modifier|*
name|ops
operator|->
name|to_xfer_memory
call|)
argument_list|(
name|offset
argument_list|,
name|writebuf
argument_list|,
name|len
argument_list|,
literal|1
comment|/*write*/
argument_list|,
name|NULL
argument_list|,
name|ops
argument_list|)
return|;
return|return
operator|-
literal|1
return|;
case|case
name|TARGET_OBJECT_AUXV
case|:
if|if
condition|(
name|readbuf
condition|)
block|{
comment|/* When the aux vector is stored in core file, BFD 	     represents this with a fake section called ".auxv".  */
name|struct
name|bfd_section
modifier|*
name|section
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|char
modifier|*
name|contents
decl_stmt|;
name|section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|core_bfd
argument_list|,
literal|".auxv"
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|size
operator|=
name|bfd_section_size
argument_list|(
name|core_bfd
argument_list|,
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|size
condition|)
return|return
literal|0
return|;
name|size
operator|-=
name|offset
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|len
condition|)
name|size
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
operator|!
name|bfd_get_section_contents
argument_list|(
name|core_bfd
argument_list|,
name|section
argument_list|,
name|readbuf
argument_list|,
operator|(
name|file_ptr
operator|)
name|offset
argument_list|,
name|size
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"Couldn't read NT_AUXV note in core file."
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|size
return|;
block|}
return|return
operator|-
literal|1
return|;
case|case
name|TARGET_OBJECT_DIRTY
case|:
block|{
name|ULONGEST
name|addr
decl_stmt|;
name|addr
operator|=
operator|*
operator|(
name|ULONGEST
operator|*
operator|)
name|annex
operator|+
name|offset
expr_stmt|;
if|if
condition|(
name|readbuf
condition|)
return|return
call|(
modifier|*
name|ops
operator|->
name|to_xfer_memory
call|)
argument_list|(
name|addr
argument_list|,
name|readbuf
argument_list|,
name|len
argument_list|,
literal|0
comment|/*read*/
argument_list|,
name|NULL
argument_list|,
name|ops
argument_list|)
return|;
if|if
condition|(
name|writebuf
condition|)
return|return
call|(
modifier|*
name|ops
operator|->
name|to_xfer_memory
call|)
argument_list|(
name|addr
argument_list|,
name|writebuf
argument_list|,
name|len
argument_list|,
literal|1
comment|/*write*/
argument_list|,
name|NULL
argument_list|,
name|ops
argument_list|)
return|;
return|return
operator|-
literal|1
return|;
block|}
default|default:
if|if
condition|(
name|ops
operator|->
name|beneath
operator|!=
name|NULL
condition|)
return|return
name|ops
operator|->
name|beneath
operator|->
name|to_xfer_partial
argument_list|(
name|ops
operator|->
name|beneath
argument_list|,
name|object
argument_list|,
name|annex
argument_list|,
name|readbuf
argument_list|,
name|writebuf
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
return|;
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If mourn is being called in all the right places, this could be say    `gdb internal error' (since generic_mourn calls breakpoint_init_inferior).  */
end_comment

begin_function
specifier|static
name|int
name|ignore
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|contents
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Okay, let's be honest: threads gleaned from a core file aren't    exactly lively, are they?  On the other hand, if we don't claim    that each& every one is alive, then we don't get any of them    to appear in an "info thread" command, which is quite a useful    behaviour.  */
end_comment

begin_function
specifier|static
name|int
name|core_file_thread_alive
parameter_list|(
name|ptid_t
name|tid
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Fill in core_ops with its defined operations and properties.  */
end_comment

begin_function
specifier|static
name|void
name|init_core_ops
parameter_list|(
name|void
parameter_list|)
block|{
name|core_ops
operator|.
name|to_shortname
operator|=
literal|"core"
expr_stmt|;
name|core_ops
operator|.
name|to_longname
operator|=
literal|"Local core dump file"
expr_stmt|;
name|core_ops
operator|.
name|to_doc
operator|=
literal|"Use a core file as a target.  Specify the filename of the core file."
expr_stmt|;
name|core_ops
operator|.
name|to_open
operator|=
name|core_open
expr_stmt|;
name|core_ops
operator|.
name|to_close
operator|=
name|core_close
expr_stmt|;
name|core_ops
operator|.
name|to_attach
operator|=
name|find_default_attach
expr_stmt|;
name|core_ops
operator|.
name|to_detach
operator|=
name|core_detach
expr_stmt|;
name|core_ops
operator|.
name|to_fetch_registers
operator|=
name|get_core_registers
expr_stmt|;
name|core_ops
operator|.
name|to_xfer_partial
operator|=
name|core_xfer_partial
expr_stmt|;
name|core_ops
operator|.
name|to_xfer_memory
operator|=
name|xfer_memory
expr_stmt|;
name|core_ops
operator|.
name|to_files_info
operator|=
name|core_files_info
expr_stmt|;
name|core_ops
operator|.
name|to_insert_breakpoint
operator|=
name|ignore
expr_stmt|;
name|core_ops
operator|.
name|to_remove_breakpoint
operator|=
name|ignore
expr_stmt|;
name|core_ops
operator|.
name|to_create_inferior
operator|=
name|find_default_create_inferior
expr_stmt|;
name|core_ops
operator|.
name|to_thread_alive
operator|=
name|core_file_thread_alive
expr_stmt|;
name|core_ops
operator|.
name|to_stratum
operator|=
name|core_stratum
expr_stmt|;
name|core_ops
operator|.
name|to_has_memory
operator|=
literal|1
expr_stmt|;
name|core_ops
operator|.
name|to_has_stack
operator|=
literal|1
expr_stmt|;
name|core_ops
operator|.
name|to_has_registers
operator|=
literal|1
expr_stmt|;
name|core_ops
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
block|}
end_function

begin_comment
comment|/* non-zero if we should not do the add_target call in    _initialize_corelow; not initialized (i.e., bss) so that    the target can initialize it (i.e., data) if appropriate.    This needs to be set at compile time because we don't know    for sure whether the target's initialize routine is called    before us or after us. */
end_comment

begin_decl_stmt
name|int
name|coreops_suppress_target
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_corelow
parameter_list|(
name|void
parameter_list|)
block|{
name|init_core_ops
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|coreops_suppress_target
condition|)
name|add_target
argument_list|(
operator|&
name|core_ops
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

