begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Core dump and executable file functions below target vector, for GDB.    Copyright 1986, 87, 89, 91, 92, 93, 94, 95, 96, 97, 1998    Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_comment
comment|/* required by inferior.h */
end_comment

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"gdbthread.h"
end_include

begin_comment
comment|/* List of all available core_fns.  On gdb startup, each core file register    reader calls add_core_fns() to register information on each core format it    is prepared to read. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|core_fns
modifier|*
name|core_file_fns
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|core_files_info
name|PARAMS
argument_list|(
operator|(
expr|struct
name|target_ops
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SOLIB_ADD
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|solib_add_stub
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|core_open
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|core_detach
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|core_close
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|get_core_registers
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_to_thread_list
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ignore
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|core_file_to_sym_file
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|core_file_thread_alive
name|PARAMS
argument_list|(
operator|(
name|int
name|tid
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_core_ops
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|_initialize_corelow
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|target_ops
name|core_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Link a new core_fns into the global core_file_fns list.  Called on gdb    startup by the _initialize routine in each core file register reader, to    register information about each format the the reader is prepared to    handle. */
end_comment

begin_function
name|void
name|add_core_fns
parameter_list|(
name|cf
parameter_list|)
name|struct
name|core_fns
modifier|*
name|cf
decl_stmt|;
block|{
name|cf
operator|->
name|next
operator|=
name|core_file_fns
expr_stmt|;
name|core_file_fns
operator|=
name|cf
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Discard all vestiges of any previous core file and mark data and stack    spaces as empty.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|core_close
parameter_list|(
name|quitting
parameter_list|)
name|int
name|quitting
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|core_bfd
condition|)
block|{
name|inferior_pid
operator|=
literal|0
expr_stmt|;
comment|/* Avoid confusion from thread stuff */
name|name
operator|=
name|bfd_get_filename
argument_list|(
name|core_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_close
argument_list|(
name|core_bfd
argument_list|)
condition|)
name|warning
argument_list|(
literal|"cannot close \"%s\": %s"
argument_list|,
name|name
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|core_bfd
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|CLEAR_SOLIB
name|CLEAR_SOLIB
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|core_ops
operator|.
name|to_sections
condition|)
block|{
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|core_ops
operator|.
name|to_sections
argument_list|)
expr_stmt|;
name|core_ops
operator|.
name|to_sections
operator|=
name|NULL
expr_stmt|;
name|core_ops
operator|.
name|to_sections_end
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SOLIB_ADD
end_ifdef

begin_comment
comment|/* Stub function for catch_errors around shared library hacking.  FROM_TTYP    is really an int * which points to from_tty.  */
end_comment

begin_function
specifier|static
name|int
name|solib_add_stub
parameter_list|(
name|from_ttyp
parameter_list|)
name|PTR
name|from_ttyp
decl_stmt|;
block|{
name|SOLIB_ADD
argument_list|(
name|NULL
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|from_ttyp
argument_list|,
operator|&
name|current_target
argument_list|)
expr_stmt|;
name|re_enable_breakpoints_in_shlibs
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SOLIB_ADD */
end_comment

begin_comment
comment|/* Look for sections whose names start with `.reg/' so that we can extract the    list of threads in a core file.  */
end_comment

begin_function
specifier|static
name|void
name|add_to_thread_list
parameter_list|(
name|abfd
parameter_list|,
name|asect
parameter_list|,
name|reg_sect_arg
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|asect
decl_stmt|;
name|PTR
name|reg_sect_arg
decl_stmt|;
block|{
name|int
name|thread_id
decl_stmt|;
name|asection
modifier|*
name|reg_sect
init|=
operator|(
name|asection
operator|*
operator|)
name|reg_sect_arg
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|bfd_section_name
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|)
argument_list|,
literal|".reg/"
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|thread_id
operator|=
name|atoi
argument_list|(
name|bfd_section_name
argument_list|(
name|abfd
argument_list|,
name|asect
argument_list|)
operator|+
literal|5
argument_list|)
expr_stmt|;
name|add_thread
argument_list|(
name|thread_id
argument_list|)
expr_stmt|;
comment|/* Warning, Will Robinson, looking at BFD private data! */
if|if
condition|(
name|reg_sect
operator|!=
name|NULL
operator|&&
name|asect
operator|->
name|filepos
operator|==
name|reg_sect
operator|->
name|filepos
condition|)
comment|/* Did we find .reg? */
name|inferior_pid
operator|=
name|thread_id
expr_stmt|;
comment|/* Yes, make it current */
block|}
end_function

begin_comment
comment|/* This routine opens and sets up the core file bfd.  */
end_comment

begin_function
specifier|static
name|void
name|core_open
parameter_list|(
name|filename
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|siggy
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
name|bfd
modifier|*
name|temp_bfd
decl_stmt|;
name|int
name|ontop
decl_stmt|;
name|int
name|scratch_chan
decl_stmt|;
name|target_preopen
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|filename
condition|)
block|{
name|error
argument_list|(
name|core_bfd
condition|?
literal|"No core file specified.  (Use `detach' to stop debugging a core file.)"
else|:
literal|"No core file specified."
argument_list|)
expr_stmt|;
block|}
name|filename
operator|=
name|tilde_expand
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|filename
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
name|temp
operator|=
name|concat
argument_list|(
name|current_directory
argument_list|,
literal|"/"
argument_list|,
name|filename
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|filename
operator|=
name|temp
expr_stmt|;
block|}
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|scratch_chan
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|write_files
condition|?
name|O_RDWR
else|:
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|scratch_chan
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|temp_bfd
operator|=
name|bfd_fdopenr
argument_list|(
name|filename
argument_list|,
name|gnutarget
argument_list|,
name|scratch_chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp_bfd
operator|==
name|NULL
condition|)
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|temp_bfd
argument_list|,
name|bfd_core
argument_list|)
condition|)
block|{
comment|/* Do it after the err msg */
comment|/* FIXME: should be checking for errors from bfd_close (for one thing, 	 on error it does not free all the storage associated with the 	 bfd).  */
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|bfd_close
argument_list|,
name|temp_bfd
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"\"%s\" is not a core dump: %s"
argument_list|,
name|filename
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Looks semi-reasonable.  Toss the old core file and work on the new.  */
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
comment|/* Don't free filename any more */
name|unpush_target
argument_list|(
operator|&
name|core_ops
argument_list|)
expr_stmt|;
name|core_bfd
operator|=
name|temp_bfd
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|core_close
argument_list|,
name|core_bfd
argument_list|)
expr_stmt|;
name|validate_files
argument_list|()
expr_stmt|;
comment|/* Find the data section */
if|if
condition|(
name|build_section_table
argument_list|(
name|core_bfd
argument_list|,
operator|&
name|core_ops
operator|.
name|to_sections
argument_list|,
operator|&
name|core_ops
operator|.
name|to_sections_end
argument_list|)
condition|)
name|error
argument_list|(
literal|"\"%s\": Can't find sections: %s"
argument_list|,
name|bfd_get_filename
argument_list|(
name|core_bfd
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ontop
operator|=
operator|!
name|push_target
argument_list|(
operator|&
name|core_ops
argument_list|)
expr_stmt|;
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
name|p
operator|=
name|bfd_core_file_failing_command
argument_list|(
name|core_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|printf_filtered
argument_list|(
literal|"Core was generated by `%s'.\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|siggy
operator|=
name|bfd_core_file_failing_signal
argument_list|(
name|core_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|siggy
operator|>
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|"Program terminated with signal %d, %s.\n"
argument_list|,
name|siggy
argument_list|,
name|safe_strsignal
argument_list|(
name|siggy
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Build up thread list from BFD sections. */
name|init_thread_list
argument_list|()
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|core_bfd
argument_list|,
name|add_to_thread_list
argument_list|,
name|bfd_get_section_by_name
argument_list|(
name|core_bfd
argument_list|,
literal|".reg"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ontop
condition|)
block|{
comment|/* Fetch all registers from core file.  */
name|target_fetch_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Add symbols and section mappings for any shared libraries.  */
ifdef|#
directive|ifdef
name|SOLIB_ADD
name|catch_errors
argument_list|(
name|solib_add_stub
argument_list|,
operator|&
name|from_tty
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Now, set up the frame cache, and print the top of stack.  */
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|print_stack_frame
argument_list|(
name|selected_frame
argument_list|,
name|selected_frame_level
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"you won't be able to access this core file until you terminate\n\ your %s; do ``info files''"
argument_list|,
name|target_longname
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|core_detach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|args
condition|)
name|error
argument_list|(
literal|"Too many arguments"
argument_list|)
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|core_ops
argument_list|)
expr_stmt|;
name|reinit_frame_cache
argument_list|()
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf_filtered
argument_list|(
literal|"No core file now.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get the registers out of a core file.  This is the machine-    independent part.  Fetch_core_registers is the machine-dependent    part, typically implemented in the xm-file for each architecture.  */
end_comment

begin_comment
comment|/* We just get all the registers, so we don't use regno.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|get_core_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|sec_ptr
name|reg_sec
decl_stmt|;
name|unsigned
name|size
decl_stmt|;
name|char
modifier|*
name|the_regs
decl_stmt|;
name|char
name|secname
index|[
literal|30
index|]
decl_stmt|;
name|enum
name|bfd_flavour
name|our_flavour
init|=
name|bfd_get_flavour
argument_list|(
name|core_bfd
argument_list|)
decl_stmt|;
name|struct
name|core_fns
modifier|*
name|cf
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|core_file_fns
operator|==
name|NULL
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Can't fetch registers from this type of core file\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Thread support.  If inferior_pid is non-zero, then we have found a core      file with threads (or multiple processes).  In that case, we need to      use the appropriate register section, else we just use `.reg'. */
comment|/* XXX - same thing needs to be done for floating-point (.reg2) sections. */
if|if
condition|(
name|inferior_pid
condition|)
name|sprintf
argument_list|(
name|secname
argument_list|,
literal|".reg/%d"
argument_list|,
name|inferior_pid
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|secname
argument_list|,
literal|".reg"
argument_list|)
expr_stmt|;
name|reg_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|core_bfd
argument_list|,
name|secname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reg_sec
condition|)
goto|goto
name|cant
goto|;
name|size
operator|=
name|bfd_section_size
argument_list|(
name|core_bfd
argument_list|,
name|reg_sec
argument_list|)
expr_stmt|;
name|the_regs
operator|=
name|alloca
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|/* Look for the core functions that match this flavor.  Default to the      first one if nothing matches. */
for|for
control|(
name|cf
operator|=
name|core_file_fns
init|;
name|cf
operator|!=
name|NULL
condition|;
name|cf
operator|=
name|cf
operator|->
name|next
control|)
block|{
if|if
condition|(
name|our_flavour
operator|==
name|cf
operator|->
name|core_flavour
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|cf
operator|==
name|NULL
condition|)
block|{
name|cf
operator|=
name|core_file_fns
expr_stmt|;
block|}
if|if
condition|(
name|cf
operator|!=
name|NULL
operator|&&
name|bfd_get_section_contents
argument_list|(
name|core_bfd
argument_list|,
name|reg_sec
argument_list|,
name|the_regs
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|size
argument_list|)
operator|&&
name|cf
operator|->
name|core_read_registers
operator|!=
name|NULL
condition|)
block|{
operator|(
name|cf
operator|->
name|core_read_registers
argument_list|(
name|the_regs
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
operator|(
name|unsigned
operator|)
name|bfd_section_vma
argument_list|(
name|abfd
argument_list|,
name|reg_sec
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|cant
label|:
name|fprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Couldn't fetch registers from core file: %s\n"
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now do it again for the float registers, if they exist.  */
name|reg_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|core_bfd
argument_list|,
literal|".reg2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_sec
condition|)
block|{
name|size
operator|=
name|bfd_section_size
argument_list|(
name|core_bfd
argument_list|,
name|reg_sec
argument_list|)
expr_stmt|;
name|the_regs
operator|=
name|alloca
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|cf
operator|!=
name|NULL
operator|&&
name|bfd_get_section_contents
argument_list|(
name|core_bfd
argument_list|,
name|reg_sec
argument_list|,
name|the_regs
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|size
argument_list|)
operator|&&
name|cf
operator|->
name|core_read_registers
operator|!=
name|NULL
condition|)
block|{
operator|(
name|cf
operator|->
name|core_read_registers
argument_list|(
name|the_regs
argument_list|,
name|size
argument_list|,
literal|2
argument_list|,
operator|(
name|unsigned
operator|)
name|bfd_section_vma
argument_list|(
name|abfd
argument_list|,
name|reg_sec
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Couldn't fetch register set 2 from core file: %s\n"
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|registers_fetched
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|core_file_to_sym_file
parameter_list|(
name|core
parameter_list|)
name|char
modifier|*
name|core
decl_stmt|;
block|{
name|CONST
name|char
modifier|*
name|failing_command
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
name|bfd
modifier|*
name|temp_bfd
decl_stmt|;
name|int
name|scratch_chan
decl_stmt|;
if|if
condition|(
operator|!
name|core
condition|)
name|error
argument_list|(
literal|"No core file specified."
argument_list|)
expr_stmt|;
name|core
operator|=
name|tilde_expand
argument_list|(
name|core
argument_list|)
expr_stmt|;
if|if
condition|(
name|core
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
name|temp
operator|=
name|concat
argument_list|(
name|current_directory
argument_list|,
literal|"/"
argument_list|,
name|core
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|core
operator|=
name|temp
expr_stmt|;
block|}
name|scratch_chan
operator|=
name|open
argument_list|(
name|core
argument_list|,
name|write_files
condition|?
name|O_RDWR
else|:
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|scratch_chan
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
name|core
argument_list|)
expr_stmt|;
name|temp_bfd
operator|=
name|bfd_fdopenr
argument_list|(
name|core
argument_list|,
name|gnutarget
argument_list|,
name|scratch_chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp_bfd
operator|==
name|NULL
condition|)
name|perror_with_name
argument_list|(
name|core
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|temp_bfd
argument_list|,
name|bfd_core
argument_list|)
condition|)
block|{
comment|/* Do it after the err msg */
comment|/* FIXME: should be checking for errors from bfd_close (for one thing, 	 on error it does not free all the storage associated with the 	 bfd).  */
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|bfd_close
argument_list|,
name|temp_bfd
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"\"%s\" is not a core dump: %s"
argument_list|,
name|core
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Find the data section */
if|if
condition|(
name|build_section_table
argument_list|(
name|temp_bfd
argument_list|,
operator|&
name|core_ops
operator|.
name|to_sections
argument_list|,
operator|&
name|core_ops
operator|.
name|to_sections_end
argument_list|)
condition|)
name|error
argument_list|(
literal|"\"%s\": Can't find sections: %s"
argument_list|,
name|bfd_get_filename
argument_list|(
name|temp_bfd
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|failing_command
operator|=
name|bfd_core_file_failing_command
argument_list|(
name|temp_bfd
argument_list|)
expr_stmt|;
name|bfd_close
argument_list|(
name|temp_bfd
argument_list|)
expr_stmt|;
comment|/* If we found a filename, remember that it is probably saved      relative to the executable that created it.  If working directory      isn't there now, we may not be able to find the executable.  Rather      than trying to be sauve about finding it, just check if the file      exists where we are now.  If not, then punt and tell our client      we couldn't find the sym file.      */
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|failing_command
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|access
argument_list|(
name|p
argument_list|,
name|F_OK
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|p
operator|=
name|NULL
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|core_files_info
parameter_list|(
name|t
parameter_list|)
name|struct
name|target_ops
modifier|*
name|t
decl_stmt|;
block|{
name|print_section_info
argument_list|(
name|t
argument_list|,
name|core_bfd
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If mourn is being called in all the right places, this could be say    `gdb internal error' (since generic_mourn calls breakpoint_init_inferior).  */
end_comment

begin_function
specifier|static
name|int
name|ignore
parameter_list|(
name|addr
parameter_list|,
name|contents
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|contents
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Okay, let's be honest: threads gleaned from a core file aren't    exactly lively, are they?  On the other hand, if we don't claim    that each& every one is alive, then we don't get any of them    to appear in an "info thread" command, which is quite a useful    behaviour.    */
end_comment

begin_function
specifier|static
name|int
name|core_file_thread_alive
parameter_list|(
name|tid
parameter_list|)
name|int
name|tid
decl_stmt|;
block|{
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Fill in core_ops with its defined operations and properties.  */
end_comment

begin_function
specifier|static
name|void
name|init_core_ops
parameter_list|()
block|{
name|core_ops
operator|.
name|to_shortname
operator|=
literal|"core"
expr_stmt|;
name|core_ops
operator|.
name|to_longname
operator|=
literal|"Local core dump file"
expr_stmt|;
name|core_ops
operator|.
name|to_doc
operator|=
literal|"Use a core file as a target.  Specify the filename of the core file."
expr_stmt|;
name|core_ops
operator|.
name|to_open
operator|=
name|core_open
expr_stmt|;
name|core_ops
operator|.
name|to_close
operator|=
name|core_close
expr_stmt|;
name|core_ops
operator|.
name|to_attach
operator|=
name|find_default_attach
expr_stmt|;
name|core_ops
operator|.
name|to_require_attach
operator|=
name|find_default_require_attach
expr_stmt|;
name|core_ops
operator|.
name|to_detach
operator|=
name|core_detach
expr_stmt|;
name|core_ops
operator|.
name|to_require_detach
operator|=
name|find_default_require_detach
expr_stmt|;
name|core_ops
operator|.
name|to_fetch_registers
operator|=
name|get_core_registers
expr_stmt|;
name|core_ops
operator|.
name|to_xfer_memory
operator|=
name|xfer_memory
expr_stmt|;
name|core_ops
operator|.
name|to_files_info
operator|=
name|core_files_info
expr_stmt|;
name|core_ops
operator|.
name|to_insert_breakpoint
operator|=
name|ignore
expr_stmt|;
name|core_ops
operator|.
name|to_remove_breakpoint
operator|=
name|ignore
expr_stmt|;
name|core_ops
operator|.
name|to_create_inferior
operator|=
name|find_default_create_inferior
expr_stmt|;
name|core_ops
operator|.
name|to_clone_and_follow_inferior
operator|=
name|find_default_clone_and_follow_inferior
expr_stmt|;
name|core_ops
operator|.
name|to_thread_alive
operator|=
name|core_file_thread_alive
expr_stmt|;
name|core_ops
operator|.
name|to_core_file_to_sym_file
operator|=
name|core_file_to_sym_file
expr_stmt|;
name|core_ops
operator|.
name|to_stratum
operator|=
name|core_stratum
expr_stmt|;
name|core_ops
operator|.
name|to_has_memory
operator|=
literal|1
expr_stmt|;
name|core_ops
operator|.
name|to_has_stack
operator|=
literal|1
expr_stmt|;
name|core_ops
operator|.
name|to_has_registers
operator|=
literal|1
expr_stmt|;
name|core_ops
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
block|}
end_function

begin_comment
comment|/* non-zero if we should not do the add_target call in    _initialize_corelow; not initialized (i.e., bss) so that    the target can initialize it (i.e., data) if appropriate.    This needs to be set at compile time because we don't know    for sure whether the target's initialize routine is called    before us or after us. */
end_comment

begin_decl_stmt
name|int
name|coreops_suppress_target
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_corelow
parameter_list|()
block|{
name|init_core_ops
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|coreops_suppress_target
condition|)
name|add_target
argument_list|(
operator|&
name|core_ops
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

