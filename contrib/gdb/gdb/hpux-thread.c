begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Low level interface for debugging HPUX/DCE threads for GDB, the GNU debugger.    Copyright 1996, 1999 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This module implements a sort of half target that sits between the    machine-independent parts of GDB and the ptrace interface (infptrace.c) to    provide access to the HPUX user-mode thread implementation.     HPUX threads are true user-mode threads, which are invoked via the cma_*    and pthread_* (DCE and Posix respectivly) interfaces.  These are mostly    implemented in user-space, with all thread context kept in various    structures that live in the user's heap.  For the most part, the kernel has    no knowlege of these threads.     */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_define
define|#
directive|define
name|_CMA_NOWRAPPERS_
end_define

begin_include
include|#
directive|include
file|<cma_tcb_defs.h>
end_include

begin_include
include|#
directive|include
file|<cma_deb_core.h>
end_include

begin_include
include|#
directive|include
file|"gdbthread.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|child_suppress_run
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|child_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* target vector for inftarg.c */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|_initialize_hpux_thread
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|string_map
block|{
name|int
name|num
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|hpux_thread_active
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|main_pid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Real process ID */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|P_cma__g_known_threads
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|P_cma__g_current_thread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cleanup
modifier|*
name|save_inferior_pid
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|restore_inferior_pid
name|PARAMS
argument_list|(
operator|(
name|int
name|pid
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|hpux_thread_resume
name|PARAMS
argument_list|(
operator|(
name|int
name|pid
operator|,
name|int
name|step
operator|,
expr|enum
name|target_signal
name|signo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_hpux_thread_ops
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|target_ops
name|hpux_thread_ops
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*  LOCAL FUNCTION  	save_inferior_pid - Save inferior_pid on the cleanup list 	restore_inferior_pid - Restore inferior_pid from the cleanup list  SYNOPSIS  	struct cleanup *save_inferior_pid () 	void restore_inferior_pid (int pid)  DESCRIPTION  	These two functions act in unison to restore inferior_pid in 	case of an error.  NOTES  	inferior_pid is a global variable that needs to be changed by many of 	these routines before calling functions in procfs.c.  In order to 	guarantee that inferior_pid gets restored (in case of errors), you 	need to call save_inferior_pid before changing it.  At the end of the 	function, you should invoke do_cleanups to restore it.   */
end_comment

begin_function
specifier|static
name|struct
name|cleanup
modifier|*
name|save_inferior_pid
parameter_list|()
block|{
return|return
name|make_cleanup
argument_list|(
name|restore_inferior_pid
argument_list|,
name|inferior_pid
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|restore_inferior_pid
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|inferior_pid
operator|=
name|pid
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|find_active_thread
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cached_thread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cached_active_thread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cma__t_int_tcb
name|cached_tcb
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|find_active_thread
parameter_list|()
block|{
specifier|static
name|cma__t_int_tcb
name|tcb
decl_stmt|;
name|CORE_ADDR
name|tcb_ptr
decl_stmt|;
if|if
condition|(
name|cached_active_thread
operator|!=
literal|0
condition|)
return|return
name|cached_active_thread
return|;
name|read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|P_cma__g_current_thread
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tcb_ptr
argument_list|,
sizeof|sizeof
name|tcb_ptr
argument_list|)
expr_stmt|;
name|read_memory
argument_list|(
name|tcb_ptr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|tcb
argument_list|,
sizeof|sizeof
name|tcb
argument_list|)
expr_stmt|;
return|return
operator|(
name|cma_thread_get_unique
argument_list|(
operator|&
name|tcb
operator|.
name|prolog
operator|.
name|client_thread
argument_list|)
operator|<<
literal|16
operator|)
operator||
name|main_pid
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|cma__t_int_tcb
modifier|*
name|find_tcb
name|PARAMS
argument_list|(
operator|(
name|int
name|thread
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|cma__t_int_tcb
modifier|*
name|find_tcb
parameter_list|(
name|thread
parameter_list|)
name|int
name|thread
decl_stmt|;
block|{
name|cma__t_known_object
name|queue_header
decl_stmt|;
name|cma__t_queue
modifier|*
name|queue_ptr
decl_stmt|;
if|if
condition|(
name|thread
operator|==
name|cached_thread
condition|)
return|return
operator|&
name|cached_tcb
return|;
name|read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|P_cma__g_known_threads
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|queue_header
argument_list|,
sizeof|sizeof
name|queue_header
argument_list|)
expr_stmt|;
for|for
control|(
name|queue_ptr
operator|=
name|queue_header
operator|.
name|queue
operator|.
name|flink
init|;
name|queue_ptr
operator|!=
operator|(
name|cma__t_queue
operator|*
operator|)
name|P_cma__g_known_threads
condition|;
name|queue_ptr
operator|=
name|cached_tcb
operator|.
name|threads
operator|.
name|flink
control|)
block|{
name|cma__t_int_tcb
modifier|*
name|tcb_ptr
decl_stmt|;
name|tcb_ptr
operator|=
name|cma__base
argument_list|(
name|queue_ptr
argument_list|,
name|threads
argument_list|,
name|cma__t_int_tcb
argument_list|)
expr_stmt|;
name|read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|tcb_ptr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|cached_tcb
argument_list|,
sizeof|sizeof
name|cached_tcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|cached_tcb
operator|.
name|header
operator|.
name|type
operator|==
name|cma__c_obj_tcb
condition|)
if|if
condition|(
name|cma_thread_get_unique
argument_list|(
operator|&
name|cached_tcb
operator|.
name|prolog
operator|.
name|client_thread
argument_list|)
operator|==
name|thread
operator|>>
literal|16
condition|)
block|{
name|cached_thread
operator|=
name|thread
expr_stmt|;
return|return
operator|&
name|cached_tcb
return|;
block|}
block|}
name|error
argument_list|(
literal|"Can't find TCB %d,%d"
argument_list|,
name|thread
operator|>>
literal|16
argument_list|,
name|thread
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Most target vector functions from here on actually just pass through to    inftarg.c, as they don't need to do anything specific for threads.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|hpux_thread_open
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|child_ops
operator|.
name|to_open
argument_list|(
name|arg
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Attach to process PID, then initialize for debugging it    and wait for the trace-trap that results from attaching.  */
end_comment

begin_function
specifier|static
name|void
name|hpux_thread_attach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|child_ops
operator|.
name|to_attach
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
comment|/* XXX - might want to iterate over all the threads and register them. */
block|}
end_function

begin_comment
comment|/* Take a program previously attached to and detaches it.    The program resumes execution and will no longer stop    on signals, etc.  We'd better not have left any breakpoints    in the program or it'll die when it hits one.  For this    to work, it may be necessary for the process to have been    previously attached.  It *might* work if the program was    started via the normal ptrace (PTRACE_TRACEME).  */
end_comment

begin_function
specifier|static
name|void
name|hpux_thread_detach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|child_ops
operator|.
name|to_detach
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Resume execution of process PID.  If STEP is nozero, then    just single step it.  If SIGNAL is nonzero, restart it with that    signal activated.  We may have to convert pid from a thread-id to an LWP id    for procfs.  */
end_comment

begin_function
specifier|static
name|void
name|hpux_thread_resume
parameter_list|(
name|pid
parameter_list|,
name|step
parameter_list|,
name|signo
parameter_list|)
name|int
name|pid
decl_stmt|;
name|int
name|step
decl_stmt|;
name|enum
name|target_signal
name|signo
decl_stmt|;
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|old_chain
operator|=
name|save_inferior_pid
argument_list|()
expr_stmt|;
name|pid
operator|=
name|inferior_pid
operator|=
name|main_pid
expr_stmt|;
if|#
directive|if
literal|0
block|if (pid != -1)     {       pid = thread_to_lwp (pid, -2);       if (pid == -2)
comment|/* Inactive thread */
block|error ("This version of Solaris can't start inactive threads.");     }
endif|#
directive|endif
name|child_ops
operator|.
name|to_resume
argument_list|(
name|pid
argument_list|,
name|step
argument_list|,
name|signo
argument_list|)
expr_stmt|;
name|cached_thread
operator|=
literal|0
expr_stmt|;
name|cached_active_thread
operator|=
literal|0
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wait for any threads to stop.  We may have to convert PID from a thread id    to a LWP id, and vice versa on the way out.  */
end_comment

begin_function
specifier|static
name|int
name|hpux_thread_wait
parameter_list|(
name|pid
parameter_list|,
name|ourstatus
parameter_list|)
name|int
name|pid
decl_stmt|;
name|struct
name|target_waitstatus
modifier|*
name|ourstatus
decl_stmt|;
block|{
name|int
name|rtnval
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|old_chain
operator|=
name|save_inferior_pid
argument_list|()
expr_stmt|;
name|inferior_pid
operator|=
name|main_pid
expr_stmt|;
if|if
condition|(
name|pid
operator|!=
operator|-
literal|1
condition|)
name|pid
operator|=
name|main_pid
expr_stmt|;
name|rtnval
operator|=
name|child_ops
operator|.
name|to_wait
argument_list|(
name|pid
argument_list|,
name|ourstatus
argument_list|)
expr_stmt|;
name|rtnval
operator|=
name|find_active_thread
argument_list|()
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|rtnval
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|regmap
index|[
name|NUM_REGS
index|]
init|=
block|{
operator|-
literal|2
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
literal|4
block|,
literal|8
block|,
literal|12
block|,
literal|16
block|,
literal|20
block|,
literal|24
block|,
comment|/* flags, r1 -> r9 */
literal|28
block|,
literal|32
block|,
literal|36
block|,
literal|40
block|,
literal|44
block|,
literal|48
block|,
literal|52
block|,
literal|56
block|,
literal|60
block|,
operator|-
literal|1
block|,
comment|/* r10 -> r19 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* r20 -> r29 */
comment|/* r30, r31, sar, pcoqh, pcsqh, pcoqt, pcsqt, eiem, iir, isr */
operator|-
literal|2
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|2
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* ior, ipsw, goto, sr4, sr0, sr1, sr2, sr3, sr5, sr6 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* sr7, cr0, cr8, cr9, ccr, cr12, cr13, cr24, cr25, cr26 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* mpsfu_high, mpsfu_low, mpsfu_ovflo, pad */
literal|144
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* fpsr, fpe1 -> fpe7 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* fr4 -> fr7 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* fr8 -> fr11 */
literal|136
block|,
operator|-
literal|1
block|,
literal|128
block|,
operator|-
literal|1
block|,
literal|120
block|,
operator|-
literal|1
block|,
literal|112
block|,
operator|-
literal|1
block|,
comment|/* fr12 -> fr15 */
literal|104
block|,
operator|-
literal|1
block|,
literal|96
block|,
operator|-
literal|1
block|,
literal|88
block|,
operator|-
literal|1
block|,
literal|80
block|,
operator|-
literal|1
block|,
comment|/* fr16 -> fr19 */
literal|72
block|,
operator|-
literal|1
block|,
literal|64
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* fr20 -> fr23 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* fr24 -> fr27 */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* fr28 -> fr31 */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|hpux_thread_fetch_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|cma__t_int_tcb
name|tcb
decl_stmt|,
modifier|*
name|tcb_ptr
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|first_regno
decl_stmt|,
name|last_regno
decl_stmt|;
name|tcb_ptr
operator|=
name|find_tcb
argument_list|(
name|inferior_pid
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|save_inferior_pid
argument_list|()
expr_stmt|;
name|inferior_pid
operator|=
name|main_pid
expr_stmt|;
if|if
condition|(
name|tcb_ptr
operator|->
name|state
operator|==
name|cma__c_state_running
condition|)
block|{
name|child_ops
operator|.
name|to_fetch_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
name|first_regno
operator|=
literal|0
expr_stmt|;
name|last_regno
operator|=
name|NUM_REGS
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|first_regno
operator|=
name|regno
expr_stmt|;
name|last_regno
operator|=
name|regno
expr_stmt|;
block|}
for|for
control|(
name|regno
operator|=
name|first_regno
init|;
name|regno
operator|<=
name|last_regno
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
name|regmap
index|[
name|regno
index|]
operator|==
operator|-
literal|1
condition|)
name|child_ops
operator|.
name|to_fetch_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
else|else
block|{
name|unsigned
name|char
name|buf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|CORE_ADDR
name|sp
decl_stmt|;
name|sp
operator|=
operator|(
name|CORE_ADDR
operator|)
name|tcb_ptr
operator|->
name|static_ctx
operator|.
name|sp
operator|-
literal|160
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|FLAGS_REGNUM
condition|)
comment|/* Flags must be 0 to avoid bogus value for SS_INSYSCALL */
name|memset
argument_list|(
name|buf
argument_list|,
literal|'\000'
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|SP_REGNUM
condition|)
name|store_address
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|sp
argument_list|,
name|sp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|PC_REGNUM
condition|)
name|read_memory
argument_list|(
name|sp
operator|-
literal|20
argument_list|,
name|buf
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|read_memory
argument_list|(
name|sp
operator|+
name|regmap
index|[
name|regno
index|]
argument_list|,
name|buf
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpux_thread_store_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|cma__t_int_tcb
name|tcb
decl_stmt|,
modifier|*
name|tcb_ptr
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|first_regno
decl_stmt|,
name|last_regno
decl_stmt|;
name|tcb_ptr
operator|=
name|find_tcb
argument_list|(
name|inferior_pid
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|save_inferior_pid
argument_list|()
expr_stmt|;
name|inferior_pid
operator|=
name|main_pid
expr_stmt|;
if|if
condition|(
name|tcb_ptr
operator|->
name|state
operator|==
name|cma__c_state_running
condition|)
block|{
name|child_ops
operator|.
name|to_store_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
name|first_regno
operator|=
literal|0
expr_stmt|;
name|last_regno
operator|=
name|NUM_REGS
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|first_regno
operator|=
name|regno
expr_stmt|;
name|last_regno
operator|=
name|regno
expr_stmt|;
block|}
for|for
control|(
name|regno
operator|=
name|first_regno
init|;
name|regno
operator|<=
name|last_regno
condition|;
name|regno
operator|++
control|)
block|{
if|if
condition|(
name|regmap
index|[
name|regno
index|]
operator|==
operator|-
literal|1
condition|)
name|child_ops
operator|.
name|to_store_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
else|else
block|{
name|unsigned
name|char
name|buf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|CORE_ADDR
name|sp
decl_stmt|;
name|sp
operator|=
operator|(
name|CORE_ADDR
operator|)
name|tcb_ptr
operator|->
name|static_ctx
operator|.
name|sp
operator|-
literal|160
expr_stmt|;
if|if
condition|(
name|regno
operator|==
name|FLAGS_REGNUM
condition|)
name|child_ops
operator|.
name|to_store_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
comment|/* Let lower layer handle this... */
elseif|else
if|if
condition|(
name|regno
operator|==
name|SP_REGNUM
condition|)
block|{
name|write_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
operator|&
name|tcb_ptr
operator|->
name|static_ctx
operator|.
name|sp
argument_list|,
name|registers
operator|+
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|tcb_ptr
operator|->
name|static_ctx
operator|.
name|sp
operator|=
operator|(
name|cma__t_hppa_regs
operator|*
operator|)
operator|(
name|extract_address
argument_list|(
name|registers
operator|+
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|)
operator|+
literal|160
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|regno
operator|==
name|PC_REGNUM
condition|)
name|write_memory
argument_list|(
name|sp
operator|-
literal|20
argument_list|,
name|registers
operator|+
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|write_memory
argument_list|(
name|sp
operator|+
name|regmap
index|[
name|regno
index|]
argument_list|,
name|registers
operator|+
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get ready to modify the registers array.  On machines which store    individual registers, this doesn't need to do anything.  On machines    which store all the registers in one fell swoop, this makes sure    that registers contains all the registers from the program being    debugged.  */
end_comment

begin_function
specifier|static
name|void
name|hpux_thread_prepare_to_store
parameter_list|()
block|{
name|child_ops
operator|.
name|to_prepare_to_store
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|hpux_thread_xfer_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|dowrite
parameter_list|,
name|target
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|dowrite
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
comment|/* ignored */
block|{
name|int
name|retval
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|old_chain
operator|=
name|save_inferior_pid
argument_list|()
expr_stmt|;
name|inferior_pid
operator|=
name|main_pid
expr_stmt|;
name|retval
operator|=
name|child_ops
operator|.
name|to_xfer_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|,
name|dowrite
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Print status information about what we're accessing.  */
end_comment

begin_function
specifier|static
name|void
name|hpux_thread_files_info
parameter_list|(
name|ignore
parameter_list|)
name|struct
name|target_ops
modifier|*
name|ignore
decl_stmt|;
block|{
name|child_ops
operator|.
name|to_files_info
argument_list|(
name|ignore
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpux_thread_kill_inferior
parameter_list|()
block|{
name|child_ops
operator|.
name|to_kill
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpux_thread_notice_signals
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|child_ops
operator|.
name|to_notice_signals
argument_list|(
name|pid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fork an inferior process, and start debugging it with /proc.  */
end_comment

begin_function
specifier|static
name|void
name|hpux_thread_create_inferior
parameter_list|(
name|exec_file
parameter_list|,
name|allargs
parameter_list|,
name|env
parameter_list|)
name|char
modifier|*
name|exec_file
decl_stmt|;
name|char
modifier|*
name|allargs
decl_stmt|;
name|char
modifier|*
modifier|*
name|env
decl_stmt|;
block|{
name|child_ops
operator|.
name|to_create_inferior
argument_list|(
name|exec_file
argument_list|,
name|allargs
argument_list|,
name|env
argument_list|)
expr_stmt|;
if|if
condition|(
name|hpux_thread_active
condition|)
block|{
name|main_pid
operator|=
name|inferior_pid
expr_stmt|;
name|push_target
argument_list|(
operator|&
name|hpux_thread_ops
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
name|find_active_thread
argument_list|()
expr_stmt|;
name|add_thread
argument_list|(
name|inferior_pid
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This routine is called whenever a new symbol table is read in, or when all    symbol tables are removed.  libthread_db can only be initialized when it    finds the right variables in libthread.so.  Since it's a shared library,    those variables don't show up until the library gets mapped and the symbol    table is read in.  */
end_comment

begin_function
name|void
name|hpux_thread_new_objfile
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|minimal_symbol
modifier|*
name|ms
decl_stmt|;
if|if
condition|(
operator|!
name|objfile
condition|)
block|{
name|hpux_thread_active
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|ms
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"cma__g_known_threads"
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ms
condition|)
return|return;
name|P_cma__g_known_threads
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|ms
argument_list|)
expr_stmt|;
name|ms
operator|=
name|lookup_minimal_symbol
argument_list|(
literal|"cma__g_current_thread"
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ms
condition|)
return|return;
name|P_cma__g_current_thread
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|ms
argument_list|)
expr_stmt|;
name|hpux_thread_active
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clean up after the inferior dies.  */
end_comment

begin_function
specifier|static
name|void
name|hpux_thread_mourn_inferior
parameter_list|()
block|{
name|child_ops
operator|.
name|to_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Mark our target-struct as eligible for stray "run" and "attach" commands.  */
end_comment

begin_function
specifier|static
name|int
name|hpux_thread_can_run
parameter_list|()
block|{
return|return
name|child_suppress_run
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hpux_thread_alive
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hpux_thread_stop
parameter_list|()
block|{
name|child_ops
operator|.
name|to_stop
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert a pid to printable form. */
end_comment

begin_function
name|char
modifier|*
name|hpux_pid_to_str
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Thread %d"
argument_list|,
name|pid
operator|>>
literal|16
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|init_hpux_thread_ops
parameter_list|()
block|{
name|hpux_thread_ops
operator|.
name|to_shortname
operator|=
literal|"hpux-threads"
expr_stmt|;
name|hpux_thread_ops
operator|.
name|to_longname
operator|=
literal|"HPUX threads and pthread."
expr_stmt|;
name|hpux_thread_ops
operator|.
name|to_doc
operator|=
literal|"HPUX threads and pthread support."
expr_stmt|;
name|hpux_thread_ops
operator|.
name|to_open
operator|=
name|hpux_thread_open
expr_stmt|;
name|hpux_thread_ops
operator|.
name|to_attach
operator|=
name|hpux_thread_attach
expr_stmt|;
name|hpux_thread_ops
operator|.
name|to_detach
operator|=
name|hpux_thread_detach
expr_stmt|;
name|hpux_thread_ops
operator|.
name|to_resume
operator|=
name|hpux_thread_resume
expr_stmt|;
name|hpux_thread_ops
operator|.
name|to_wait
operator|=
name|hpux_thread_wait
expr_stmt|;
name|hpux_thread_ops
operator|.
name|to_fetch_registers
operator|=
name|hpux_thread_fetch_registers
expr_stmt|;
name|hpux_thread_ops
operator|.
name|to_store_registers
operator|=
name|hpux_thread_store_registers
expr_stmt|;
name|hpux_thread_ops
operator|.
name|to_prepare_to_store
operator|=
name|hpux_thread_prepare_to_store
expr_stmt|;
name|hpux_thread_ops
operator|.
name|to_xfer_memory
operator|=
name|hpux_thread_xfer_memory
expr_stmt|;
name|hpux_thread_ops
operator|.
name|to_files_info
operator|=
name|hpux_thread_files_info
expr_stmt|;
name|hpux_thread_ops
operator|.
name|to_insert_breakpoint
operator|=
name|memory_insert_breakpoint
expr_stmt|;
name|hpux_thread_ops
operator|.
name|to_remove_breakpoint
operator|=
name|memory_remove_breakpoint
expr_stmt|;
name|hpux_thread_ops
operator|.
name|to_terminal_init
operator|=
name|terminal_init_inferior
expr_stmt|;
name|hpux_thread_ops
operator|.
name|to_terminal_inferior
operator|=
name|terminal_inferior
expr_stmt|;
name|hpux_thread_ops
operator|.
name|to_terminal_ours_for_output
operator|=
name|terminal_ours_for_output
expr_stmt|;
name|hpux_thread_ops
operator|.
name|to_terminal_ours
operator|=
name|terminal_ours
expr_stmt|;
name|hpux_thread_ops
operator|.
name|to_terminal_info
operator|=
name|child_terminal_info
expr_stmt|;
name|hpux_thread_ops
operator|.
name|to_kill
operator|=
name|hpux_thread_kill_inferior
expr_stmt|;
name|hpux_thread_ops
operator|.
name|to_create_inferior
operator|=
name|hpux_thread_create_inferior
expr_stmt|;
name|hpux_thread_ops
operator|.
name|to_mourn_inferior
operator|=
name|hpux_thread_mourn_inferior
expr_stmt|;
name|hpux_thread_ops
operator|.
name|to_can_run
operator|=
name|hpux_thread_can_run
expr_stmt|;
name|hpux_thread_ops
operator|.
name|to_notice_signals
operator|=
name|hpux_thread_notice_signals
expr_stmt|;
name|hpux_thread_ops
operator|.
name|to_thread_alive
operator|=
name|hpux_thread_thread_alive
expr_stmt|;
name|hpux_thread_ops
operator|.
name|to_stop
operator|=
name|hpux_thread_stop
expr_stmt|;
name|hpux_thread_ops
operator|.
name|to_stratum
operator|=
name|process_stratum
expr_stmt|;
name|hpux_thread_ops
operator|.
name|to_has_all_memory
operator|=
literal|1
expr_stmt|;
name|hpux_thread_ops
operator|.
name|to_has_memory
operator|=
literal|1
expr_stmt|;
name|hpux_thread_ops
operator|.
name|to_has_stack
operator|=
literal|1
expr_stmt|;
name|hpux_thread_ops
operator|.
name|to_has_registers
operator|=
literal|1
expr_stmt|;
name|hpux_thread_ops
operator|.
name|to_has_execution
operator|=
literal|1
expr_stmt|;
name|hpux_thread_ops
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_hpux_thread
parameter_list|()
block|{
name|init_hpux_thread_ops
argument_list|()
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|hpux_thread_ops
argument_list|)
expr_stmt|;
name|child_suppress_run
operator|=
literal|1
expr_stmt|;
block|}
end_function

end_unit

