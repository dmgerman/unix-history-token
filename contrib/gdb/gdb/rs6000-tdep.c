begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target-dependent code for GDB, the GNU debugger.     Copyright 1986, 1987, 1989, 1991, 1992, 1993, 1994, 1995, 1996,    1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software    Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"arch-utils.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"doublest.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"parser-defs.h"
end_include

begin_include
include|#
directive|include
file|"osabi.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_comment
comment|/* for bfd_default_set_arch_mach */
end_comment

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_comment
comment|/* for libcoff.h */
end_comment

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_comment
comment|/* for xcoff_data */
end_comment

begin_include
include|#
directive|include
file|"coff/xcoff.h"
end_include

begin_include
include|#
directive|include
file|"libxcoff.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"solib-svr4.h"
end_include

begin_include
include|#
directive|include
file|"ppc-tdep.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_comment
comment|/* If the kernel has to deliver a signal, it pushes a sigcontext    structure on the stack and then calls the signal handler, passing    the address of the sigcontext in an argument register. Usually    the signal handler doesn't save this register, so we have to    access the sigcontext structure via an offset from the signal handler    frame.    The following constants were determined by experimentation on AIX 3.2.  */
end_comment

begin_define
define|#
directive|define
name|SIG_FRAME_PC_OFFSET
value|96
end_define

begin_define
define|#
directive|define
name|SIG_FRAME_LR_OFFSET
value|108
end_define

begin_define
define|#
directive|define
name|SIG_FRAME_FP_OFFSET
value|284
end_define

begin_comment
comment|/* To be used by skip_prologue. */
end_comment

begin_struct
struct|struct
name|rs6000_framedata
block|{
name|int
name|offset
decl_stmt|;
comment|/* total size of frame --- the distance 				   by which we decrement sp to allocate 				   the frame */
name|int
name|saved_gpr
decl_stmt|;
comment|/* smallest # of saved gpr */
name|int
name|saved_fpr
decl_stmt|;
comment|/* smallest # of saved fpr */
name|int
name|saved_vr
decl_stmt|;
comment|/* smallest # of saved vr */
name|int
name|saved_ev
decl_stmt|;
comment|/* smallest # of saved ev */
name|int
name|alloca_reg
decl_stmt|;
comment|/* alloca register number (frame ptr) */
name|char
name|frameless
decl_stmt|;
comment|/* true if frameless functions. */
name|char
name|nosavedpc
decl_stmt|;
comment|/* true if pc not saved. */
name|int
name|gpr_offset
decl_stmt|;
comment|/* offset of saved gprs from prev sp */
name|int
name|fpr_offset
decl_stmt|;
comment|/* offset of saved fprs from prev sp */
name|int
name|vr_offset
decl_stmt|;
comment|/* offset of saved vrs from prev sp */
name|int
name|ev_offset
decl_stmt|;
comment|/* offset of saved evs from prev sp */
name|int
name|lr_offset
decl_stmt|;
comment|/* offset of saved lr */
name|int
name|cr_offset
decl_stmt|;
comment|/* offset of saved cr */
name|int
name|vrsave_offset
decl_stmt|;
comment|/* offset of saved vrsave register */
block|}
struct|;
end_struct

begin_comment
comment|/* Description of a single register. */
end_comment

begin_struct
struct|struct
name|reg
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of register */
name|unsigned
name|char
name|sz32
decl_stmt|;
comment|/* size on 32-bit arch, 0 if nonextant */
name|unsigned
name|char
name|sz64
decl_stmt|;
comment|/* size on 64-bit arch, 0 if nonextant */
name|unsigned
name|char
name|fpr
decl_stmt|;
comment|/* whether register is floating-point */
name|unsigned
name|char
name|pseudo
decl_stmt|;
comment|/* whether register is pseudo */
block|}
struct|;
end_struct

begin_comment
comment|/* Breakpoint shadows for the single step instructions will be kept here. */
end_comment

begin_struct
specifier|static
struct|struct
name|sstep_breaks
block|{
comment|/* Address, or 0 if this is not in use.  */
name|CORE_ADDR
name|address
decl_stmt|;
comment|/* Shadow contents.  */
name|char
name|data
index|[
literal|4
index|]
decl_stmt|;
block|}
name|stepBreaks
index|[
literal|2
index|]
struct|;
end_struct

begin_comment
comment|/* Hook for determining the TOC address when calling functions in the    inferior under AIX. The initialization code in rs6000-nat.c sets    this hook to point to find_toc_address.  */
end_comment

begin_function_decl
name|CORE_ADDR
function_decl|(
modifier|*
name|rs6000_find_toc_address_hook
function_decl|)
parameter_list|(
name|CORE_ADDR
parameter_list|)
init|=
name|NULL
function_decl|;
end_function_decl

begin_comment
comment|/* Hook to set the current architecture when starting a child process.     rs6000-nat.c sets this. */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|rs6000_set_host_arch_hook
function_decl|)
parameter_list|(
name|int
parameter_list|)
init|=
name|NULL
function_decl|;
end_function_decl

begin_comment
comment|/* Static function prototypes */
end_comment

begin_function_decl
specifier|static
name|CORE_ADDR
name|branch_dest
parameter_list|(
name|int
name|opcode
parameter_list|,
name|int
name|instr
parameter_list|,
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
name|safety
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|CORE_ADDR
name|skip_prologue
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|CORE_ADDR
parameter_list|,
name|struct
name|rs6000_framedata
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|frame_get_saved_regs
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|,
name|struct
name|rs6000_framedata
modifier|*
name|fdatap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|CORE_ADDR
name|frame_initial_stack_address
parameter_list|(
name|struct
name|frame_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Is REGNO an AltiVec register?  Return 1 if so, 0 otherwise.  */
end_comment

begin_function
name|int
name|altivec_register_p
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
if|if
condition|(
name|tdep
operator|->
name|ppc_vr0_regnum
operator|<
literal|0
operator|||
name|tdep
operator|->
name|ppc_vrsave_regnum
operator|<
literal|0
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|(
name|regno
operator|>=
name|tdep
operator|->
name|ppc_vr0_regnum
operator|&&
name|regno
operator|<=
name|tdep
operator|->
name|ppc_vrsave_regnum
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Use the architectures FP registers?  */
end_comment

begin_function
name|int
name|ppc_floating_point_unit_p
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|)
block|{
specifier|const
name|struct
name|bfd_arch_info
modifier|*
name|info
init|=
name|gdbarch_bfd_arch_info
argument_list|(
name|gdbarch
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|arch
operator|==
name|bfd_arch_powerpc
condition|)
return|return
operator|(
name|info
operator|->
name|mach
operator|!=
name|bfd_mach_ppc_e500
operator|)
return|;
if|if
condition|(
name|info
operator|->
name|arch
operator|==
name|bfd_arch_rs6000
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Read a LEN-byte address from debugged memory address MEMADDR. */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|read_memory_addr
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
return|return
name|read_memory_unsigned_integer
argument_list|(
name|memaddr
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|rs6000_skip_prologue
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|struct
name|rs6000_framedata
name|frame
decl_stmt|;
name|pc
operator|=
name|skip_prologue
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
operator|&
name|frame
argument_list|)
expr_stmt|;
return|return
name|pc
return|;
block|}
end_function

begin_comment
comment|/* Fill in fi->saved_regs */
end_comment

begin_struct
struct|struct
name|frame_extra_info
block|{
comment|/* Functions calling alloca() change the value of the stack      pointer. We need to use initial stack pointer (which is saved in      r31 by gcc) in such cases. If a compiler emits traceback table,      then we should use the alloca register specified in traceback      table. FIXME. */
name|CORE_ADDR
name|initial_sp
decl_stmt|;
comment|/* initial stack pointer. */
block|}
struct|;
end_struct

begin_function
name|void
name|rs6000_init_extra_frame_info
parameter_list|(
name|int
name|fromleaf
parameter_list|,
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
name|struct
name|frame_extra_info
modifier|*
name|extra_info
init|=
name|frame_extra_info_zalloc
argument_list|(
name|fi
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|frame_extra_info
argument_list|)
argument_list|)
decl_stmt|;
name|extra_info
operator|->
name|initial_sp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|get_next_frame
argument_list|(
name|fi
argument_list|)
operator|!=
name|NULL
operator|&&
name|get_frame_pc
argument_list|(
name|fi
argument_list|)
operator|<
name|TEXT_SEGMENT_BASE
condition|)
comment|/* We're in get_prev_frame */
comment|/* and this is a special signal frame.  */
comment|/* (fi->pc will be some low address in the kernel, */
comment|/*  to which the signal handler returns).  */
name|deprecated_set_frame_type
argument_list|(
name|fi
argument_list|,
name|SIGTRAMP_FRAME
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Put here the code to store, into a struct frame_saved_regs,    the addresses of the saved registers of frame described by FRAME_INFO.    This includes special registers such as pc and fp saved in special    ways in the stack frame.  sp is even more special:    the address we return for it IS the sp for the next frame.  */
end_comment

begin_comment
comment|/* In this implementation for RS/6000, we do *not* save sp. I am    not sure if it will be needed. The following function takes care of gpr's    and fpr's only. */
end_comment

begin_function
name|void
name|rs6000_frame_init_saved_regs
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
name|frame_get_saved_regs
argument_list|(
name|fi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|rs6000_frame_args_address
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
name|struct
name|frame_extra_info
modifier|*
name|extra_info
init|=
name|get_frame_extra_info
argument_list|(
name|fi
argument_list|)
decl_stmt|;
if|if
condition|(
name|extra_info
operator|->
name|initial_sp
operator|!=
literal|0
condition|)
return|return
name|extra_info
operator|->
name|initial_sp
return|;
else|else
return|return
name|frame_initial_stack_address
argument_list|(
name|fi
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Immediately after a function call, return the saved pc.    Can't go through the frames for this because on some machines    the new frame is not set up until the new function executes    some instructions.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|rs6000_saved_pc_after_call
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
return|return
name|read_register
argument_list|(
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|ppc_lr_regnum
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get the ith function argument for the current function.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|rs6000_fetch_pointer_argument
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|argi
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
name|get_frame_register
argument_list|(
name|frame
argument_list|,
literal|3
operator|+
name|argi
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* Calculate the destination of a branch/jump.  Return -1 if not a branch.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|branch_dest
parameter_list|(
name|int
name|opcode
parameter_list|,
name|int
name|instr
parameter_list|,
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
name|safety
parameter_list|)
block|{
name|CORE_ADDR
name|dest
decl_stmt|;
name|int
name|immediate
decl_stmt|;
name|int
name|absolute
decl_stmt|;
name|int
name|ext_op
decl_stmt|;
name|absolute
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|instr
operator|>>
literal|1
operator|)
operator|&
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
literal|18
case|:
name|immediate
operator|=
operator|(
operator|(
name|instr
operator|&
operator|~
literal|3
operator|)
operator|<<
literal|6
operator|)
operator|>>
literal|6
expr_stmt|;
comment|/* br unconditional */
if|if
condition|(
name|absolute
condition|)
name|dest
operator|=
name|immediate
expr_stmt|;
else|else
name|dest
operator|=
name|pc
operator|+
name|immediate
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|immediate
operator|=
operator|(
operator|(
name|instr
operator|&
operator|~
literal|3
operator|)
operator|<<
literal|16
operator|)
operator|>>
literal|16
expr_stmt|;
comment|/* br conditional */
if|if
condition|(
name|absolute
condition|)
name|dest
operator|=
name|immediate
expr_stmt|;
else|else
name|dest
operator|=
name|pc
operator|+
name|immediate
expr_stmt|;
break|break;
case|case
literal|19
case|:
name|ext_op
operator|=
operator|(
name|instr
operator|>>
literal|1
operator|)
operator|&
literal|0x3ff
expr_stmt|;
if|if
condition|(
name|ext_op
operator|==
literal|16
condition|)
comment|/* br conditional register */
block|{
name|dest
operator|=
name|read_register
argument_list|(
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|ppc_lr_regnum
argument_list|)
operator|&
operator|~
literal|3
expr_stmt|;
comment|/* If we are about to return from a signal handler, dest is 	     something like 0x3c90.  The current frame is a signal handler 	     caller frame, upon completion of the sigreturn system call 	     execution will return to the saved PC in the frame.  */
if|if
condition|(
name|dest
operator|<
name|TEXT_SEGMENT_BASE
condition|)
block|{
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|fi
operator|=
name|get_current_frame
argument_list|()
expr_stmt|;
if|if
condition|(
name|fi
operator|!=
name|NULL
condition|)
name|dest
operator|=
name|read_memory_addr
argument_list|(
name|get_frame_base
argument_list|(
name|fi
argument_list|)
operator|+
name|SIG_FRAME_PC_OFFSET
argument_list|,
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|wordsize
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ext_op
operator|==
literal|528
condition|)
comment|/* br cond to count reg */
block|{
name|dest
operator|=
name|read_register
argument_list|(
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|ppc_ctr_regnum
argument_list|)
operator|&
operator|~
literal|3
expr_stmt|;
comment|/* If we are about to execute a system call, dest is something 	     like 0x22fc or 0x3b00.  Upon completion the system call 	     will return to the address in the link register.  */
if|if
condition|(
name|dest
operator|<
name|TEXT_SEGMENT_BASE
condition|)
name|dest
operator|=
name|read_register
argument_list|(
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|ppc_lr_regnum
argument_list|)
operator|&
operator|~
literal|3
expr_stmt|;
block|}
else|else
return|return
operator|-
literal|1
return|;
break|break;
default|default:
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|(
name|dest
operator|<
name|TEXT_SEGMENT_BASE
operator|)
condition|?
name|safety
else|:
name|dest
return|;
block|}
end_function

begin_comment
comment|/* Sequence of bytes for breakpoint instruction.  */
end_comment

begin_function
specifier|const
specifier|static
name|unsigned
name|char
modifier|*
name|rs6000_breakpoint_from_pc
parameter_list|(
name|CORE_ADDR
modifier|*
name|bp_addr
parameter_list|,
name|int
modifier|*
name|bp_size
parameter_list|)
block|{
specifier|static
name|unsigned
name|char
name|big_breakpoint
index|[]
init|=
block|{
literal|0x7d
block|,
literal|0x82
block|,
literal|0x10
block|,
literal|0x08
block|}
decl_stmt|;
specifier|static
name|unsigned
name|char
name|little_breakpoint
index|[]
init|=
block|{
literal|0x08
block|,
literal|0x10
block|,
literal|0x82
block|,
literal|0x7d
block|}
decl_stmt|;
operator|*
name|bp_size
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|)
return|return
name|big_breakpoint
return|;
else|else
return|return
name|little_breakpoint
return|;
block|}
end_function

begin_comment
comment|/* AIX does not support PT_STEP. Simulate it. */
end_comment

begin_function
name|void
name|rs6000_software_single_step
parameter_list|(
name|enum
name|target_signal
name|signal
parameter_list|,
name|int
name|insert_breakpoints_p
parameter_list|)
block|{
name|CORE_ADDR
name|dummy
decl_stmt|;
name|int
name|breakp_sz
decl_stmt|;
specifier|const
name|char
modifier|*
name|breakp
init|=
name|rs6000_breakpoint_from_pc
argument_list|(
operator|&
name|dummy
argument_list|,
operator|&
name|breakp_sz
argument_list|)
decl_stmt|;
name|int
name|ii
decl_stmt|,
name|insn
decl_stmt|;
name|CORE_ADDR
name|loc
decl_stmt|;
name|CORE_ADDR
name|breaks
index|[
literal|2
index|]
decl_stmt|;
name|int
name|opcode
decl_stmt|;
if|if
condition|(
name|insert_breakpoints_p
condition|)
block|{
name|loc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
name|insn
operator|=
name|read_memory_integer
argument_list|(
name|loc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|breaks
index|[
literal|0
index|]
operator|=
name|loc
operator|+
name|breakp_sz
expr_stmt|;
name|opcode
operator|=
name|insn
operator|>>
literal|26
expr_stmt|;
name|breaks
index|[
literal|1
index|]
operator|=
name|branch_dest
argument_list|(
name|opcode
argument_list|,
name|insn
argument_list|,
name|loc
argument_list|,
name|breaks
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Don't put two breakpoints on the same address. */
if|if
condition|(
name|breaks
index|[
literal|1
index|]
operator|==
name|breaks
index|[
literal|0
index|]
condition|)
name|breaks
index|[
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|stepBreaks
index|[
literal|1
index|]
operator|.
name|address
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
literal|2
condition|;
operator|++
name|ii
control|)
block|{
comment|/* ignore invalid breakpoint. */
if|if
condition|(
name|breaks
index|[
name|ii
index|]
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|target_insert_breakpoint
argument_list|(
name|breaks
index|[
name|ii
index|]
argument_list|,
name|stepBreaks
index|[
name|ii
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
name|stepBreaks
index|[
name|ii
index|]
operator|.
name|address
operator|=
name|breaks
index|[
name|ii
index|]
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* remove step breakpoints. */
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
literal|2
condition|;
operator|++
name|ii
control|)
if|if
condition|(
name|stepBreaks
index|[
name|ii
index|]
operator|.
name|address
operator|!=
literal|0
condition|)
name|target_remove_breakpoint
argument_list|(
name|stepBreaks
index|[
name|ii
index|]
operator|.
name|address
argument_list|,
name|stepBreaks
index|[
name|ii
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* FIXME, don't ignore errors! */
comment|/* What errors?  {read,write}_memory call error().  */
block|}
end_function

begin_comment
comment|/* return pc value after skipping a function prologue and also return    information about a function frame.     in struct rs6000_framedata fdata:    - frameless is TRUE, if function does not have a frame.    - nosavedpc is TRUE, if function does not save %pc value in its frame.    - offset is the initial size of this stack frame --- the amount by    which we decrement the sp to allocate the frame.    - saved_gpr is the number of the first saved gpr.    - saved_fpr is the number of the first saved fpr.    - saved_vr is the number of the first saved vr.    - saved_ev is the number of the first saved ev.    - alloca_reg is the number of the register used for alloca() handling.    Otherwise -1.    - gpr_offset is the offset of the first saved gpr from the previous frame.    - fpr_offset is the offset of the first saved fpr from the previous frame.    - vr_offset is the offset of the first saved vr from the previous frame.    - ev_offset is the offset of the first saved ev from the previous frame.    - lr_offset is the offset of the saved lr    - cr_offset is the offset of the saved cr    - vrsave_offset is the offset of the saved vrsave register  */
end_comment

begin_define
define|#
directive|define
name|SIGNED_SHORT
parameter_list|(
name|x
parameter_list|)
define|\
value|((sizeof (short) == 2)						\    ? ((int)(short)(x))							\    : ((int)((((x)& 0xffff) ^ 0x8000) - 0x8000)))
end_define

begin_define
define|#
directive|define
name|GET_SRC_REG
parameter_list|(
name|x
parameter_list|)
value|(((x)>> 21)& 0x1f)
end_define

begin_comment
comment|/* Limit the number of skipped non-prologue instructions, as the examining    of the prologue is expensive.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|max_skip_non_prologue_insns
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given PC representing the starting address of a function, and    LIM_PC which is the (sloppy) limit to which to scan when looking    for a prologue, attempt to further refine this limit by using    the line data in the symbol table.  If successful, a better guess    on where the prologue ends is returned, otherwise the previous    value of lim_pc is returned.  */
end_comment

begin_comment
comment|/* FIXME: cagney/2004-02-14: This function and logic have largely been    superseded by skip_prologue_using_sal.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|refine_prologue_limit
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
name|lim_pc
parameter_list|)
block|{
name|struct
name|symtab_and_line
name|prologue_sal
decl_stmt|;
name|prologue_sal
operator|=
name|find_pc_line
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|prologue_sal
operator|.
name|line
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|CORE_ADDR
name|addr
init|=
name|prologue_sal
operator|.
name|end
decl_stmt|;
comment|/* Handle the case in which compiler's optimizer/scheduler          has moved instructions into the prologue.  We scan ahead 	 in the function looking for address ranges whose corresponding 	 line number is less than or equal to the first one that we 	 found for the function.  (It can be less than when the 	 scheduler puts a body instruction before the first prologue 	 instruction.)  */
for|for
control|(
name|i
operator|=
literal|2
operator|*
name|max_skip_non_prologue_insns
init|;
name|i
operator|>
literal|0
operator|&&
operator|(
name|lim_pc
operator|==
literal|0
operator|||
name|addr
operator|<
name|lim_pc
operator|)
condition|;
name|i
operator|--
control|)
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|sal
operator|=
name|find_pc_line
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|line
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|sal
operator|.
name|line
operator|<=
name|prologue_sal
operator|.
name|line
operator|&&
name|sal
operator|.
name|symtab
operator|==
name|prologue_sal
operator|.
name|symtab
condition|)
block|{
name|prologue_sal
operator|=
name|sal
expr_stmt|;
block|}
name|addr
operator|=
name|sal
operator|.
name|end
expr_stmt|;
block|}
if|if
condition|(
name|lim_pc
operator|==
literal|0
operator|||
name|prologue_sal
operator|.
name|end
operator|<
name|lim_pc
condition|)
name|lim_pc
operator|=
name|prologue_sal
operator|.
name|end
expr_stmt|;
block|}
return|return
name|lim_pc
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|skip_prologue
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
name|lim_pc
parameter_list|,
name|struct
name|rs6000_framedata
modifier|*
name|fdata
parameter_list|)
block|{
name|CORE_ADDR
name|orig_pc
init|=
name|pc
decl_stmt|;
name|CORE_ADDR
name|last_prologue_pc
init|=
name|pc
decl_stmt|;
name|CORE_ADDR
name|li_found_pc
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|unsigned
name|long
name|op
decl_stmt|;
name|long
name|offset
init|=
literal|0
decl_stmt|;
name|long
name|vr_saved_offset
init|=
literal|0
decl_stmt|;
name|int
name|lr_reg
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|cr_reg
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|vr_reg
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|ev_reg
init|=
operator|-
literal|1
decl_stmt|;
name|long
name|ev_offset
init|=
literal|0
decl_stmt|;
name|int
name|vrsave_reg
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|int
name|framep
init|=
literal|0
decl_stmt|;
name|int
name|minimal_toc_loaded
init|=
literal|0
decl_stmt|;
name|int
name|prev_insn_was_prologue_insn
init|=
literal|1
decl_stmt|;
name|int
name|num_skip_non_prologue_insns
init|=
literal|0
decl_stmt|;
specifier|const
name|struct
name|bfd_arch_info
modifier|*
name|arch_info
init|=
name|gdbarch_bfd_arch_info
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
comment|/* Attempt to find the end of the prologue when no limit is specified.      Note that refine_prologue_limit() has been written so that it may      be used to "refine" the limits of non-zero PC values too, but this      is only safe if we 1) trust the line information provided by the      compiler and 2) iterate enough to actually find the end of the      prologue.              It may become a good idea at some point (for both performance and      accuracy) to unconditionally call refine_prologue_limit().  But,      until we can make a clear determination that this is beneficial,      we'll play it safe and only use it to obtain a limit when none      has been specified.  */
if|if
condition|(
name|lim_pc
operator|==
literal|0
condition|)
name|lim_pc
operator|=
name|refine_prologue_limit
argument_list|(
name|pc
argument_list|,
name|lim_pc
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|fdata
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rs6000_framedata
argument_list|)
argument_list|)
expr_stmt|;
name|fdata
operator|->
name|saved_gpr
operator|=
operator|-
literal|1
expr_stmt|;
name|fdata
operator|->
name|saved_fpr
operator|=
operator|-
literal|1
expr_stmt|;
name|fdata
operator|->
name|saved_vr
operator|=
operator|-
literal|1
expr_stmt|;
name|fdata
operator|->
name|saved_ev
operator|=
operator|-
literal|1
expr_stmt|;
name|fdata
operator|->
name|alloca_reg
operator|=
operator|-
literal|1
expr_stmt|;
name|fdata
operator|->
name|frameless
operator|=
literal|1
expr_stmt|;
name|fdata
operator|->
name|nosavedpc
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
name|pc
operator|+=
literal|4
control|)
block|{
comment|/* Sometimes it isn't clear if an instruction is a prologue          instruction or not.  When we encounter one of these ambiguous 	 cases, we'll set prev_insn_was_prologue_insn to 0 (false). 	 Otherwise, we'll assume that it really is a prologue instruction. */
if|if
condition|(
name|prev_insn_was_prologue_insn
condition|)
name|last_prologue_pc
operator|=
name|pc
expr_stmt|;
comment|/* Stop scanning if we've hit the limit.  */
if|if
condition|(
name|lim_pc
operator|!=
literal|0
operator|&&
name|pc
operator|>=
name|lim_pc
condition|)
break|break;
name|prev_insn_was_prologue_insn
operator|=
literal|1
expr_stmt|;
comment|/* Fetch the instruction and convert it to an integer.  */
if|if
condition|(
name|target_read_memory
argument_list|(
name|pc
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
condition|)
break|break;
name|op
operator|=
name|extract_signed_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|op
operator|&
literal|0xfc1fffff
operator|)
operator|==
literal|0x7c0802a6
condition|)
block|{
comment|/* mflr Rx */
name|lr_reg
operator|=
operator|(
name|op
operator|&
literal|0x03e00000
operator|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|op
operator|&
literal|0xfc1fffff
operator|)
operator|==
literal|0x7c000026
condition|)
block|{
comment|/* mfcr Rx */
name|cr_reg
operator|=
operator|(
name|op
operator|&
literal|0x03e00000
operator|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|op
operator|&
literal|0xfc1f0000
operator|)
operator|==
literal|0xd8010000
condition|)
block|{
comment|/* stfd Rx,NUM(r1) */
name|reg
operator|=
name|GET_SRC_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdata
operator|->
name|saved_fpr
operator|==
operator|-
literal|1
operator|||
name|fdata
operator|->
name|saved_fpr
operator|>
name|reg
condition|)
block|{
name|fdata
operator|->
name|saved_fpr
operator|=
name|reg
expr_stmt|;
name|fdata
operator|->
name|fpr_offset
operator|=
name|SIGNED_SHORT
argument_list|(
name|op
argument_list|)
operator|+
name|offset
expr_stmt|;
block|}
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|op
operator|&
literal|0xfc1f0000
operator|)
operator|==
literal|0xbc010000
operator|)
operator|||
comment|/* stm Rx, NUM(r1) */
operator|(
operator|(
operator|(
name|op
operator|&
literal|0xfc1f0000
operator|)
operator|==
literal|0x90010000
operator|||
comment|/* st rx,NUM(r1) */
operator|(
name|op
operator|&
literal|0xfc1f0003
operator|)
operator|==
literal|0xf8010000
operator|)
operator|&&
comment|/* std rx,NUM(r1) */
operator|(
name|op
operator|&
literal|0x03e00000
operator|)
operator|>=
literal|0x01a00000
operator|)
condition|)
comment|/* rx>= r13 */
block|{
name|reg
operator|=
name|GET_SRC_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdata
operator|->
name|saved_gpr
operator|==
operator|-
literal|1
operator|||
name|fdata
operator|->
name|saved_gpr
operator|>
name|reg
condition|)
block|{
name|fdata
operator|->
name|saved_gpr
operator|=
name|reg
expr_stmt|;
if|if
condition|(
operator|(
name|op
operator|&
literal|0xfc1f0003
operator|)
operator|==
literal|0xf8010000
condition|)
name|op
operator|&=
operator|~
literal|3UL
expr_stmt|;
name|fdata
operator|->
name|gpr_offset
operator|=
name|SIGNED_SHORT
argument_list|(
name|op
argument_list|)
operator|+
name|offset
expr_stmt|;
block|}
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|op
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0x60000000
condition|)
block|{
comment|/* nop */
comment|/* Allow nops in the prologue, but do not consider them to 	     be part of the prologue unless followed by other prologue 	     instructions. */
name|prev_insn_was_prologue_insn
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|op
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0x3c000000
condition|)
block|{
comment|/* addis 0,0,NUM, used 				   for>= 32k frames */
name|fdata
operator|->
name|offset
operator|=
operator|(
name|op
operator|&
literal|0x0000ffff
operator|)
operator|<<
literal|16
expr_stmt|;
name|fdata
operator|->
name|frameless
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|op
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0x60000000
condition|)
block|{
comment|/* ori 0,0,NUM, 2nd ha 				   lf of>= 32k frames */
name|fdata
operator|->
name|offset
operator||=
operator|(
name|op
operator|&
literal|0x0000ffff
operator|)
expr_stmt|;
name|fdata
operator|->
name|frameless
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|lr_reg
operator|!=
operator|-
literal|1
operator|&&
comment|/* std Rx, NUM(r1) || stdu Rx, NUM(r1) */
operator|(
operator|(
operator|(
name|op
operator|&
literal|0xffff0000
operator|)
operator|==
operator|(
name|lr_reg
operator||
literal|0xf8010000
operator|)
operator|)
operator|||
comment|/* stw Rx, NUM(r1) */
operator|(
operator|(
name|op
operator|&
literal|0xffff0000
operator|)
operator|==
operator|(
name|lr_reg
operator||
literal|0x90010000
operator|)
operator|)
operator|||
comment|/* stwu Rx, NUM(r1) */
operator|(
operator|(
name|op
operator|&
literal|0xffff0000
operator|)
operator|==
operator|(
name|lr_reg
operator||
literal|0x94010000
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* where Rx == lr */
name|fdata
operator|->
name|lr_offset
operator|=
name|offset
expr_stmt|;
name|fdata
operator|->
name|nosavedpc
operator|=
literal|0
expr_stmt|;
name|lr_reg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|op
operator|&
literal|0xfc000003
operator|)
operator|==
literal|0xf8000000
operator|||
comment|/* std */
operator|(
name|op
operator|&
literal|0xfc000000
operator|)
operator|==
literal|0x90000000
condition|)
comment|/* stw */
block|{
comment|/* Does not update r1, so add displacement to lr_offset.  */
name|fdata
operator|->
name|lr_offset
operator|+=
name|SIGNED_SHORT
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
elseif|else
if|if
condition|(
name|cr_reg
operator|!=
operator|-
literal|1
operator|&&
comment|/* std Rx, NUM(r1) || stdu Rx, NUM(r1) */
operator|(
operator|(
operator|(
name|op
operator|&
literal|0xffff0000
operator|)
operator|==
operator|(
name|cr_reg
operator||
literal|0xf8010000
operator|)
operator|)
operator|||
comment|/* stw Rx, NUM(r1) */
operator|(
operator|(
name|op
operator|&
literal|0xffff0000
operator|)
operator|==
operator|(
name|cr_reg
operator||
literal|0x90010000
operator|)
operator|)
operator|||
comment|/* stwu Rx, NUM(r1) */
operator|(
operator|(
name|op
operator|&
literal|0xffff0000
operator|)
operator|==
operator|(
name|cr_reg
operator||
literal|0x94010000
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* where Rx == cr */
name|fdata
operator|->
name|cr_offset
operator|=
name|offset
expr_stmt|;
name|cr_reg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|op
operator|&
literal|0xfc000003
operator|)
operator|==
literal|0xf8000000
operator|||
operator|(
name|op
operator|&
literal|0xfc000000
operator|)
operator|==
literal|0x90000000
condition|)
block|{
comment|/* Does not update r1, so add displacement to cr_offset.  */
name|fdata
operator|->
name|cr_offset
operator|+=
name|SIGNED_SHORT
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
literal|0x48000005
condition|)
block|{
comment|/* bl .+4 used in  				   -mrelocatable */
continue|continue;
block|}
elseif|else
if|if
condition|(
name|op
operator|==
literal|0x48000004
condition|)
block|{
comment|/* b .+4 (xlc) */
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|op
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0x3fc00000
operator|||
comment|/* addis 30,0,foo@ha, used 						      in V.4 -mminimal-toc */
operator|(
name|op
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0x3bde0000
condition|)
block|{
comment|/* addi 30,30,foo@l */
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|op
operator|&
literal|0xfc000001
operator|)
operator|==
literal|0x48000001
condition|)
block|{
comment|/* bl foo,  				   to save fprs??? */
name|fdata
operator|->
name|frameless
operator|=
literal|0
expr_stmt|;
comment|/* Don't skip over the subroutine call if it is not within 	     the first three instructions of the prologue.  */
if|if
condition|(
operator|(
name|pc
operator|-
name|orig_pc
operator|)
operator|>
literal|8
condition|)
break|break;
name|op
operator|=
name|read_memory_integer
argument_list|(
name|pc
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* At this point, make sure this is not a trampoline 	     function (a function that simply calls another functions, 	     and nothing else).  If the next is not a nop, this branch 	     was part of the function prologue. */
if|if
condition|(
name|op
operator|==
literal|0x4def7b82
operator|||
name|op
operator|==
literal|0
condition|)
comment|/* crorc 15, 15, 15 */
break|break;
comment|/* don't skip over  				   this branch */
continue|continue;
block|}
comment|/* update stack pointer */
elseif|else
if|if
condition|(
operator|(
name|op
operator|&
literal|0xfc1f0000
operator|)
operator|==
literal|0x94010000
condition|)
block|{
comment|/* stu rX,NUM(r1) ||  stwu rX,NUM(r1) */
name|fdata
operator|->
name|frameless
operator|=
literal|0
expr_stmt|;
name|fdata
operator|->
name|offset
operator|=
name|SIGNED_SHORT
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|offset
operator|=
name|fdata
operator|->
name|offset
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|op
operator|&
literal|0xfc1f016a
operator|)
operator|==
literal|0x7c01016e
condition|)
block|{
comment|/* stwux rX,r1,rY */
comment|/* no way to figure out what r1 is going to be */
name|fdata
operator|->
name|frameless
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
name|fdata
operator|->
name|offset
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|op
operator|&
literal|0xfc1f0003
operator|)
operator|==
literal|0xf8010001
condition|)
block|{
comment|/* stdu rX,NUM(r1) */
name|fdata
operator|->
name|frameless
operator|=
literal|0
expr_stmt|;
name|fdata
operator|->
name|offset
operator|=
name|SIGNED_SHORT
argument_list|(
name|op
operator|&
operator|~
literal|3UL
argument_list|)
expr_stmt|;
name|offset
operator|=
name|fdata
operator|->
name|offset
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|op
operator|&
literal|0xfc1f016a
operator|)
operator|==
literal|0x7c01016a
condition|)
block|{
comment|/* stdux rX,r1,rY */
comment|/* no way to figure out what r1 is going to be */
name|fdata
operator|->
name|frameless
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
name|fdata
operator|->
name|offset
expr_stmt|;
continue|continue;
block|}
comment|/* Load up minimal toc pointer */
elseif|else
if|if
condition|(
operator|(
operator|(
name|op
operator|>>
literal|22
operator|)
operator|==
literal|0x20f
operator|||
comment|/* l r31,... or l r30,... */
operator|(
name|op
operator|>>
literal|22
operator|)
operator|==
literal|0x3af
operator|)
comment|/* ld r31,... or ld r30,... */
operator|&&
operator|!
name|minimal_toc_loaded
condition|)
block|{
name|minimal_toc_loaded
operator|=
literal|1
expr_stmt|;
continue|continue;
comment|/* move parameters from argument registers to local variable              registers */
block|}
elseif|else
if|if
condition|(
operator|(
name|op
operator|&
literal|0xfc0007fe
operator|)
operator|==
literal|0x7c000378
operator|&&
comment|/* mr(.)  Rx,Ry */
operator|(
operator|(
operator|(
name|op
operator|>>
literal|21
operator|)
operator|&
literal|31
operator|)
operator|>=
literal|3
operator|)
operator|&&
comment|/* R3>= Ry>= R10 */
operator|(
operator|(
operator|(
name|op
operator|>>
literal|21
operator|)
operator|&
literal|31
operator|)
operator|<=
literal|10
operator|)
operator|&&
operator|(
call|(
name|long
call|)
argument_list|(
operator|(
name|op
operator|>>
literal|16
operator|)
operator|&
literal|31
argument_list|)
operator|>=
name|fdata
operator|->
name|saved_gpr
operator|)
condition|)
comment|/* Rx: local var reg */
block|{
continue|continue;
comment|/* store parameters in stack */
block|}
elseif|else
if|if
condition|(
operator|(
name|op
operator|&
literal|0xfc1f0003
operator|)
operator|==
literal|0xf8010000
operator|||
comment|/* std rx,NUM(r1) */
operator|(
name|op
operator|&
literal|0xfc1f0000
operator|)
operator|==
literal|0xd8010000
operator|||
comment|/* stfd Rx,NUM(r1) */
operator|(
name|op
operator|&
literal|0xfc1f0000
operator|)
operator|==
literal|0xfc010000
condition|)
comment|/* frsp, fp?,NUM(r1) */
block|{
continue|continue;
comment|/* store parameters in stack via frame pointer */
block|}
elseif|else
if|if
condition|(
name|framep
operator|&&
operator|(
operator|(
name|op
operator|&
literal|0xfc1f0000
operator|)
operator|==
literal|0x901f0000
operator|||
comment|/* st rx,NUM(r1) */
operator|(
name|op
operator|&
literal|0xfc1f0000
operator|)
operator|==
literal|0xd81f0000
operator|||
comment|/* stfd Rx,NUM(r1) */
operator|(
name|op
operator|&
literal|0xfc1f0000
operator|)
operator|==
literal|0xfc1f0000
operator|)
condition|)
block|{
comment|/* frsp, fp?,NUM(r1) */
continue|continue;
comment|/* Set up frame pointer */
block|}
elseif|else
if|if
condition|(
name|op
operator|==
literal|0x603f0000
comment|/* oril r31, r1, 0x0 */
operator|||
name|op
operator|==
literal|0x7c3f0b78
condition|)
block|{
comment|/* mr r31, r1 */
name|fdata
operator|->
name|frameless
operator|=
literal|0
expr_stmt|;
name|framep
operator|=
literal|1
expr_stmt|;
name|fdata
operator|->
name|alloca_reg
operator|=
operator|(
name|tdep
operator|->
name|ppc_gp0_regnum
operator|+
literal|31
operator|)
expr_stmt|;
continue|continue;
comment|/* Another way to set up the frame pointer.  */
block|}
elseif|else
if|if
condition|(
operator|(
name|op
operator|&
literal|0xfc1fffff
operator|)
operator|==
literal|0x38010000
condition|)
block|{
comment|/* addi rX, r1, 0x0 */
name|fdata
operator|->
name|frameless
operator|=
literal|0
expr_stmt|;
name|framep
operator|=
literal|1
expr_stmt|;
name|fdata
operator|->
name|alloca_reg
operator|=
operator|(
name|tdep
operator|->
name|ppc_gp0_regnum
operator|+
operator|(
operator|(
name|op
operator|&
operator|~
literal|0x38010000
operator|)
operator|>>
literal|21
operator|)
operator|)
expr_stmt|;
continue|continue;
block|}
comment|/* AltiVec related instructions.  */
comment|/* Store the vrsave register (spr 256) in another register for 	 later manipulation, or load a register into the vrsave 	 register.  2 instructions are used: mfvrsave and 	 mtvrsave.  They are shorthand notation for mfspr Rn, SPR256 	 and mtspr SPR256, Rn.  */
comment|/* mfspr Rn SPR256 == 011111 nnnnn 0000001000 01010100110 	 mtspr SPR256 Rn == 011111 nnnnn 0000001000 01110100110  */
elseif|else
if|if
condition|(
operator|(
name|op
operator|&
literal|0xfc1fffff
operator|)
operator|==
literal|0x7c0042a6
condition|)
comment|/* mfvrsave Rn */
block|{
name|vrsave_reg
operator|=
name|GET_SRC_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|op
operator|&
literal|0xfc1fffff
operator|)
operator|==
literal|0x7c0043a6
condition|)
comment|/* mtvrsave Rn */
block|{
continue|continue;
block|}
comment|/* Store the register where vrsave was saved to onto the stack:          rS is the register where vrsave was stored in a previous 	 instruction.  */
comment|/* 100100 sssss 00001 dddddddd dddddddd */
elseif|else
if|if
condition|(
operator|(
name|op
operator|&
literal|0xfc1f0000
operator|)
operator|==
literal|0x90010000
condition|)
comment|/* stw rS, d(r1) */
block|{
if|if
condition|(
name|vrsave_reg
operator|==
name|GET_SRC_REG
argument_list|(
name|op
argument_list|)
condition|)
block|{
name|fdata
operator|->
name|vrsave_offset
operator|=
name|SIGNED_SHORT
argument_list|(
name|op
argument_list|)
operator|+
name|offset
expr_stmt|;
name|vrsave_reg
operator|=
operator|-
literal|1
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* Compute the new value of vrsave, by modifying the register          where vrsave was saved to.  */
elseif|else
if|if
condition|(
operator|(
operator|(
name|op
operator|&
literal|0xfc000000
operator|)
operator|==
literal|0x64000000
operator|)
comment|/* oris Ra, Rs, UIMM */
operator|||
operator|(
operator|(
name|op
operator|&
literal|0xfc000000
operator|)
operator|==
literal|0x60000000
operator|)
condition|)
comment|/* ori Ra, Rs, UIMM */
block|{
continue|continue;
block|}
comment|/* li r0, SIMM (short for addi r0, 0, SIMM).  This is the first 	 in a pair of insns to save the vector registers on the 	 stack.  */
comment|/* 001110 00000 00000 iiii iiii iiii iiii  */
comment|/* 001110 01110 00000 iiii iiii iiii iiii  */
elseif|else
if|if
condition|(
operator|(
name|op
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0x38000000
comment|/* li r0, SIMM */
operator|||
operator|(
name|op
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0x39c00000
condition|)
comment|/* li r14, SIMM */
block|{
name|li_found_pc
operator|=
name|pc
expr_stmt|;
name|vr_saved_offset
operator|=
name|SIGNED_SHORT
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
comment|/* Store vector register S at (r31+r0) aligned to 16 bytes.  */
comment|/* 011111 sssss 11111 00000 00111001110 */
elseif|else
if|if
condition|(
operator|(
name|op
operator|&
literal|0xfc1fffff
operator|)
operator|==
literal|0x7c1f01ce
condition|)
comment|/* stvx Vs, R31, R0 */
block|{
if|if
condition|(
name|pc
operator|==
operator|(
name|li_found_pc
operator|+
literal|4
operator|)
condition|)
block|{
name|vr_reg
operator|=
name|GET_SRC_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|/* If this is the first vector reg to be saved, or if 		 it has a lower number than others previously seen, 		 reupdate the frame info.  */
if|if
condition|(
name|fdata
operator|->
name|saved_vr
operator|==
operator|-
literal|1
operator|||
name|fdata
operator|->
name|saved_vr
operator|>
name|vr_reg
condition|)
block|{
name|fdata
operator|->
name|saved_vr
operator|=
name|vr_reg
expr_stmt|;
name|fdata
operator|->
name|vr_offset
operator|=
name|vr_saved_offset
operator|+
name|offset
expr_stmt|;
block|}
name|vr_saved_offset
operator|=
operator|-
literal|1
expr_stmt|;
name|vr_reg
operator|=
operator|-
literal|1
expr_stmt|;
name|li_found_pc
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* End AltiVec related instructions.  */
comment|/* Start BookE related instructions.  */
comment|/* Store gen register S at (r31+uimm).          Any register less than r13 is volatile, so we don't care.  */
comment|/* 000100 sssss 11111 iiiii 01100100001 */
elseif|else
if|if
condition|(
name|arch_info
operator|->
name|mach
operator|==
name|bfd_mach_ppc_e500
operator|&&
operator|(
name|op
operator|&
literal|0xfc1f07ff
operator|)
operator|==
literal|0x101f0321
condition|)
comment|/* evstdd Rs,uimm(R31) */
block|{
if|if
condition|(
operator|(
name|op
operator|&
literal|0x03e00000
operator|)
operator|>=
literal|0x01a00000
condition|)
comment|/* Rs>= r13 */
block|{
name|unsigned
name|int
name|imm
decl_stmt|;
name|ev_reg
operator|=
name|GET_SRC_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|imm
operator|=
operator|(
name|op
operator|>>
literal|11
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|ev_offset
operator|=
name|imm
operator|*
literal|8
expr_stmt|;
comment|/* If this is the first vector reg to be saved, or if 		 it has a lower number than others previously seen, 		 reupdate the frame info.  */
if|if
condition|(
name|fdata
operator|->
name|saved_ev
operator|==
operator|-
literal|1
operator|||
name|fdata
operator|->
name|saved_ev
operator|>
name|ev_reg
condition|)
block|{
name|fdata
operator|->
name|saved_ev
operator|=
name|ev_reg
expr_stmt|;
name|fdata
operator|->
name|ev_offset
operator|=
name|ev_offset
operator|+
name|offset
expr_stmt|;
block|}
block|}
continue|continue;
block|}
comment|/* Store gen register rS at (r1+rB).  */
comment|/* 000100 sssss 00001 bbbbb 01100100000 */
elseif|else
if|if
condition|(
name|arch_info
operator|->
name|mach
operator|==
name|bfd_mach_ppc_e500
operator|&&
operator|(
name|op
operator|&
literal|0xffe007ff
operator|)
operator|==
literal|0x13e00320
condition|)
comment|/* evstddx RS,R1,Rb */
block|{
if|if
condition|(
name|pc
operator|==
operator|(
name|li_found_pc
operator|+
literal|4
operator|)
condition|)
block|{
name|ev_reg
operator|=
name|GET_SRC_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|/* If this is the first vector reg to be saved, or if                  it has a lower number than others previously seen,                  reupdate the frame info.  */
comment|/* We know the contents of rB from the previous instruction.  */
if|if
condition|(
name|fdata
operator|->
name|saved_ev
operator|==
operator|-
literal|1
operator|||
name|fdata
operator|->
name|saved_ev
operator|>
name|ev_reg
condition|)
block|{
name|fdata
operator|->
name|saved_ev
operator|=
name|ev_reg
expr_stmt|;
name|fdata
operator|->
name|ev_offset
operator|=
name|vr_saved_offset
operator|+
name|offset
expr_stmt|;
block|}
name|vr_saved_offset
operator|=
operator|-
literal|1
expr_stmt|;
name|ev_reg
operator|=
operator|-
literal|1
expr_stmt|;
name|li_found_pc
operator|=
literal|0
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* Store gen register r31 at (rA+uimm).  */
comment|/* 000100 11111 aaaaa iiiii 01100100001 */
elseif|else
if|if
condition|(
name|arch_info
operator|->
name|mach
operator|==
name|bfd_mach_ppc_e500
operator|&&
operator|(
name|op
operator|&
literal|0xffe007ff
operator|)
operator|==
literal|0x13e00321
condition|)
comment|/* evstdd R31,Ra,UIMM */
block|{
comment|/* Wwe know that the source register is 31 already, but              it can't hurt to compute it.  */
name|ev_reg
operator|=
name|GET_SRC_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|ev_offset
operator|=
operator|(
operator|(
name|op
operator|>>
literal|11
operator|)
operator|&
literal|0x1f
operator|)
operator|*
literal|8
expr_stmt|;
comment|/* If this is the first vector reg to be saved, or if 	     it has a lower number than others previously seen, 	     reupdate the frame info.  */
if|if
condition|(
name|fdata
operator|->
name|saved_ev
operator|==
operator|-
literal|1
operator|||
name|fdata
operator|->
name|saved_ev
operator|>
name|ev_reg
condition|)
block|{
name|fdata
operator|->
name|saved_ev
operator|=
name|ev_reg
expr_stmt|;
name|fdata
operator|->
name|ev_offset
operator|=
name|ev_offset
operator|+
name|offset
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* Store gen register S at (r31+r0).          Store param on stack when offset from SP bigger than 4 bytes.  */
comment|/* 000100 sssss 11111 00000 01100100000 */
elseif|else
if|if
condition|(
name|arch_info
operator|->
name|mach
operator|==
name|bfd_mach_ppc_e500
operator|&&
operator|(
name|op
operator|&
literal|0xfc1fffff
operator|)
operator|==
literal|0x101f0320
condition|)
comment|/* evstddx Rs,R31,R0 */
block|{
if|if
condition|(
name|pc
operator|==
operator|(
name|li_found_pc
operator|+
literal|4
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|op
operator|&
literal|0x03e00000
operator|)
operator|>=
literal|0x01a00000
condition|)
block|{
name|ev_reg
operator|=
name|GET_SRC_REG
argument_list|(
name|op
argument_list|)
expr_stmt|;
comment|/* If this is the first vector reg to be saved, or if 		     it has a lower number than others previously seen, 		     reupdate the frame info.  */
comment|/* We know the contents of r0 from the previous                      instruction.  */
if|if
condition|(
name|fdata
operator|->
name|saved_ev
operator|==
operator|-
literal|1
operator|||
name|fdata
operator|->
name|saved_ev
operator|>
name|ev_reg
condition|)
block|{
name|fdata
operator|->
name|saved_ev
operator|=
name|ev_reg
expr_stmt|;
name|fdata
operator|->
name|ev_offset
operator|=
name|vr_saved_offset
operator|+
name|offset
expr_stmt|;
block|}
name|ev_reg
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|vr_saved_offset
operator|=
operator|-
literal|1
expr_stmt|;
name|li_found_pc
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* End BookE related instructions.  */
else|else
block|{
comment|/* Not a recognized prologue instruction. 	     Handle optimizer code motions into the prologue by continuing 	     the search if we have no valid frame yet or if the return 	     address is not yet saved in the frame.  */
if|if
condition|(
name|fdata
operator|->
name|frameless
operator|==
literal|0
operator|&&
operator|(
name|lr_reg
operator|==
operator|-
literal|1
operator|||
name|fdata
operator|->
name|nosavedpc
operator|==
literal|0
operator|)
condition|)
break|break;
if|if
condition|(
name|op
operator|==
literal|0x4e800020
comment|/* blr */
operator|||
name|op
operator|==
literal|0x4e800420
condition|)
comment|/* bctr */
comment|/* Do not scan past epilogue in frameless functions or 	       trampolines.  */
break|break;
if|if
condition|(
operator|(
name|op
operator|&
literal|0xf4000000
operator|)
operator|==
literal|0x40000000
condition|)
comment|/* bxx */
comment|/* Never skip branches.  */
break|break;
if|if
condition|(
name|num_skip_non_prologue_insns
operator|++
operator|>
name|max_skip_non_prologue_insns
condition|)
comment|/* Do not scan too many insns, scanning insns is expensive with 	       remote targets.  */
break|break;
comment|/* Continue scanning.  */
name|prev_insn_was_prologue_insn
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
block|}
if|#
directive|if
literal|0
comment|/* I have problems with skipping over __main() that I need to address  * sometime. Previously, I used to use misc_function_vector which  * didn't work as well as I wanted to be.  -MGO */
comment|/* If the first thing after skipping a prolog is a branch to a function,      this might be a call to an initializer in main(), introduced by gcc2.      We'd like to skip over it as well.  Fortunately, xlc does some extra      work before calling a function right after a prologue, thus we can      single out such gcc2 behaviour.  */
block|if ((op& 0xfc000001) == 0x48000001)     {
comment|/* bl foo, an initializer function? */
block|op = read_memory_integer (pc + 4, 4);        if (op == 0x4def7b82) 	{
comment|/* cror 0xf, 0xf, 0xf (nop) */
comment|/* Check and see if we are in main.  If so, skip over this 	     initializer function as well.  */
block|tmp = find_pc_misc_function (pc); 	  if (tmp>= 0&& strcmp (misc_function_vector[tmp].name, main_name ()) == 0) 	    return pc + 8; 	}     }
endif|#
directive|endif
comment|/* 0 */
name|fdata
operator|->
name|offset
operator|=
operator|-
name|fdata
operator|->
name|offset
expr_stmt|;
return|return
name|last_prologue_pc
return|;
block|}
end_function

begin_comment
comment|/*************************************************************************   Support for creating pushing a dummy frame into the stack, and popping   frames, etc.  *************************************************************************/
end_comment

begin_comment
comment|/* Pop the innermost frame, go back to the caller.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_pop_frame
parameter_list|(
name|void
parameter_list|)
block|{
name|CORE_ADDR
name|pc
decl_stmt|,
name|lr
decl_stmt|,
name|sp
decl_stmt|,
name|prev_sp
decl_stmt|,
name|addr
decl_stmt|;
comment|/* %pc, %lr, %sp */
name|struct
name|rs6000_framedata
name|fdata
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|frame
init|=
name|get_current_frame
argument_list|()
decl_stmt|;
name|int
name|ii
decl_stmt|,
name|wordsize
decl_stmt|;
name|pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
name|sp
operator|=
name|get_frame_base
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEPRECATED_PC_IN_CALL_DUMMY
argument_list|(
name|get_frame_pc
argument_list|(
name|frame
argument_list|)
argument_list|,
name|get_frame_base
argument_list|(
name|frame
argument_list|)
argument_list|,
name|get_frame_base
argument_list|(
name|frame
argument_list|)
argument_list|)
condition|)
block|{
name|generic_pop_dummy_frame
argument_list|()
expr_stmt|;
name|flush_cached_frames
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* Make sure that all registers are valid.  */
name|deprecated_read_register_bytes
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
name|DEPRECATED_REGISTER_BYTES
argument_list|)
expr_stmt|;
comment|/* Figure out previous %pc value.  If the function is frameless, it is       still in the link register, otherwise walk the frames and retrieve the      saved %pc value in the previous frame.  */
name|addr
operator|=
name|get_frame_func
argument_list|(
name|frame
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|skip_prologue
argument_list|(
name|addr
argument_list|,
name|get_frame_pc
argument_list|(
name|frame
argument_list|)
argument_list|,
operator|&
name|fdata
argument_list|)
expr_stmt|;
name|wordsize
operator|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|wordsize
expr_stmt|;
if|if
condition|(
name|fdata
operator|.
name|frameless
condition|)
name|prev_sp
operator|=
name|sp
expr_stmt|;
else|else
name|prev_sp
operator|=
name|read_memory_addr
argument_list|(
name|sp
argument_list|,
name|wordsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdata
operator|.
name|lr_offset
operator|==
literal|0
condition|)
name|lr
operator|=
name|read_register
argument_list|(
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|ppc_lr_regnum
argument_list|)
expr_stmt|;
else|else
name|lr
operator|=
name|read_memory_addr
argument_list|(
name|prev_sp
operator|+
name|fdata
operator|.
name|lr_offset
argument_list|,
name|wordsize
argument_list|)
expr_stmt|;
comment|/* reset %pc value. */
name|write_register
argument_list|(
name|PC_REGNUM
argument_list|,
name|lr
argument_list|)
expr_stmt|;
comment|/* reset register values if any was saved earlier.  */
if|if
condition|(
name|fdata
operator|.
name|saved_gpr
operator|!=
operator|-
literal|1
condition|)
block|{
name|addr
operator|=
name|prev_sp
operator|+
name|fdata
operator|.
name|gpr_offset
expr_stmt|;
for|for
control|(
name|ii
operator|=
name|fdata
operator|.
name|saved_gpr
init|;
name|ii
operator|<=
literal|31
condition|;
operator|++
name|ii
control|)
block|{
name|read_memory
argument_list|(
name|addr
argument_list|,
operator|&
name|deprecated_registers
index|[
name|DEPRECATED_REGISTER_BYTE
argument_list|(
name|ii
argument_list|)
index|]
argument_list|,
name|wordsize
argument_list|)
expr_stmt|;
name|addr
operator|+=
name|wordsize
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fdata
operator|.
name|saved_fpr
operator|!=
operator|-
literal|1
condition|)
block|{
name|addr
operator|=
name|prev_sp
operator|+
name|fdata
operator|.
name|fpr_offset
expr_stmt|;
for|for
control|(
name|ii
operator|=
name|fdata
operator|.
name|saved_fpr
init|;
name|ii
operator|<=
literal|31
condition|;
operator|++
name|ii
control|)
block|{
name|read_memory
argument_list|(
name|addr
argument_list|,
operator|&
name|deprecated_registers
index|[
name|DEPRECATED_REGISTER_BYTE
argument_list|(
name|ii
operator|+
name|FP0_REGNUM
argument_list|)
index|]
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|addr
operator|+=
literal|8
expr_stmt|;
block|}
block|}
name|write_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|prev_sp
argument_list|)
expr_stmt|;
name|target_store_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|flush_cached_frames
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* All the ABI's require 16 byte alignment.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|rs6000_frame_align
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|)
block|{
return|return
operator|(
name|addr
operator|&
operator|-
literal|16
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Pass the arguments in either registers, or in the stack. In RS/6000,    the first eight words of the argument list (that might be less than    eight parameters if some parameters occupy more than one word) are    passed in r3..r10 registers.  float and double parameters are    passed in fpr's, in addition to that.  Rest of the parameters if any    are passed in user stack.  There might be cases in which half of the    parameter is copied into registers, the other half is pushed into    stack.     Stack must be aligned on 64-bit boundaries when synthesizing    function calls.     If the function is returning a structure, then the return address is passed    in r3, then the first 7 words of the parameters can be passed in registers,    starting from r4.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|rs6000_push_dummy_call
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|CORE_ADDR
name|func_addr
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|CORE_ADDR
name|bp_addr
parameter_list|,
name|int
name|nargs
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|args
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|,
name|int
name|struct_return
parameter_list|,
name|CORE_ADDR
name|struct_addr
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
name|int
name|ii
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
name|int
name|argno
decl_stmt|;
comment|/* current argument number */
name|int
name|argbytes
decl_stmt|;
comment|/* current argument byte */
name|char
name|tmp_buffer
index|[
literal|50
index|]
decl_stmt|;
name|int
name|f_argno
init|=
literal|0
decl_stmt|;
comment|/* current floating point argno */
name|int
name|wordsize
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|wordsize
decl_stmt|;
name|struct
name|value
modifier|*
name|arg
init|=
literal|0
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|CORE_ADDR
name|saved_sp
decl_stmt|;
comment|/* The first eight words of ther arguments are passed in registers.      Copy them appropriately.  */
name|ii
operator|=
literal|0
expr_stmt|;
comment|/* If the function is returning a `struct', then the first word      (which will be passed in r3) is used for struct return address.      In that case we should advance one word and start from r4      register to copy parameters.  */
if|if
condition|(
name|struct_return
condition|)
block|{
name|regcache_raw_write_unsigned
argument_list|(
name|regcache
argument_list|,
name|tdep
operator|->
name|ppc_gp0_regnum
operator|+
literal|3
argument_list|,
name|struct_addr
argument_list|)
expr_stmt|;
name|ii
operator|++
expr_stmt|;
block|}
comment|/*     effectively indirect call... gcc does...     return_val example( float, int);     eabi:     float in fp0, int in r3    offset of stack on overflow 8/16    for varargs, must go by type.    power open:    float in r3&r4, int in r5    offset of stack on overflow different     both:     return in r3 or f0.  If no float, must study how gcc emulates floats;    pay attention to arg promotion.      User may have to cast\args to handle promotion correctly     since gdb won't know if prototype supplied or not.  */
for|for
control|(
name|argno
operator|=
literal|0
operator|,
name|argbytes
operator|=
literal|0
init|;
name|argno
operator|<
name|nargs
operator|&&
name|ii
operator|<
literal|8
condition|;
operator|++
name|ii
control|)
block|{
name|int
name|reg_size
init|=
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|ii
operator|+
literal|3
argument_list|)
decl_stmt|;
name|arg
operator|=
name|args
index|[
name|argno
index|]
expr_stmt|;
name|type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FLT
condition|)
block|{
comment|/* Floating point arguments are passed in fpr's, as well as gpr's. 	     There are 13 fpr's reserved for passing parameters. At this point 	     there is no way we would run out of them.  */
if|if
condition|(
name|len
operator|>
literal|8
condition|)
name|printf_unfiltered
argument_list|(
literal|"Fatal Error: a floating point parameter #%d with a size> 8 is found!\n"
argument_list|,
name|argno
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|deprecated_registers
index|[
name|DEPRECATED_REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
operator|+
literal|1
operator|+
name|f_argno
argument_list|)
index|]
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|++
name|f_argno
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
name|reg_size
condition|)
block|{
comment|/* Argument takes more than one register.  */
while|while
condition|(
name|argbytes
operator|<
name|len
condition|)
block|{
name|memset
argument_list|(
operator|&
name|deprecated_registers
index|[
name|DEPRECATED_REGISTER_BYTE
argument_list|(
name|ii
operator|+
literal|3
argument_list|)
index|]
argument_list|,
literal|0
argument_list|,
name|reg_size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|deprecated_registers
index|[
name|DEPRECATED_REGISTER_BYTE
argument_list|(
name|ii
operator|+
literal|3
argument_list|)
index|]
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
operator|)
operator|+
name|argbytes
argument_list|,
operator|(
name|len
operator|-
name|argbytes
operator|)
operator|>
name|reg_size
condition|?
name|reg_size
else|:
name|len
operator|-
name|argbytes
argument_list|)
expr_stmt|;
operator|++
name|ii
operator|,
name|argbytes
operator|+=
name|reg_size
expr_stmt|;
if|if
condition|(
name|ii
operator|>=
literal|8
condition|)
goto|goto
name|ran_out_of_registers_for_arguments
goto|;
block|}
name|argbytes
operator|=
literal|0
expr_stmt|;
operator|--
name|ii
expr_stmt|;
block|}
else|else
block|{
comment|/* Argument can fit in one register.  No problem.  */
name|int
name|adj
init|=
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|?
name|reg_size
operator|-
name|len
else|:
literal|0
decl_stmt|;
name|memset
argument_list|(
operator|&
name|deprecated_registers
index|[
name|DEPRECATED_REGISTER_BYTE
argument_list|(
name|ii
operator|+
literal|3
argument_list|)
index|]
argument_list|,
literal|0
argument_list|,
name|reg_size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|deprecated_registers
index|[
name|DEPRECATED_REGISTER_BYTE
argument_list|(
name|ii
operator|+
literal|3
argument_list|)
index|]
operator|+
name|adj
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
operator|++
name|argno
expr_stmt|;
block|}
name|ran_out_of_registers_for_arguments
label|:
name|saved_sp
operator|=
name|read_sp
argument_list|()
expr_stmt|;
comment|/* Location for 8 parameters are always reserved.  */
name|sp
operator|-=
name|wordsize
operator|*
literal|8
expr_stmt|;
comment|/* Another six words for back chain, TOC register, link register, etc.  */
name|sp
operator|-=
name|wordsize
operator|*
literal|6
expr_stmt|;
comment|/* Stack pointer must be quadword aligned.  */
name|sp
operator|&=
operator|-
literal|16
expr_stmt|;
comment|/* If there are more arguments, allocate space for them in       the stack, then push them starting from the ninth one.  */
if|if
condition|(
operator|(
name|argno
operator|<
name|nargs
operator|)
operator|||
name|argbytes
condition|)
block|{
name|int
name|space
init|=
literal|0
decl_stmt|,
name|jj
decl_stmt|;
if|if
condition|(
name|argbytes
condition|)
block|{
name|space
operator|+=
operator|(
operator|(
name|len
operator|-
name|argbytes
operator|+
literal|3
operator|)
operator|&
operator|-
literal|4
operator|)
expr_stmt|;
name|jj
operator|=
name|argno
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|jj
operator|=
name|argno
expr_stmt|;
for|for
control|(
init|;
name|jj
operator|<
name|nargs
condition|;
operator|++
name|jj
control|)
block|{
name|struct
name|value
modifier|*
name|val
init|=
name|args
index|[
name|jj
index|]
decl_stmt|;
name|space
operator|+=
operator|(
operator|(
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|)
operator|+
literal|3
operator|)
operator|&
operator|-
literal|4
expr_stmt|;
block|}
comment|/* Add location required for the rest of the parameters.  */
name|space
operator|=
operator|(
name|space
operator|+
literal|15
operator|)
operator|&
operator|-
literal|16
expr_stmt|;
name|sp
operator|-=
name|space
expr_stmt|;
comment|/* This is another instance we need to be concerned about          securing our stack space. If we write anything underneath %sp          (r1), we might conflict with the kernel who thinks he is free          to use this area.  So, update %sp first before doing anything          else.  */
name|regcache_raw_write_signed
argument_list|(
name|regcache
argument_list|,
name|SP_REGNUM
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/* If the last argument copied into the registers didn't fit there           completely, push the rest of it into stack.  */
if|if
condition|(
name|argbytes
condition|)
block|{
name|write_memory
argument_list|(
name|sp
operator|+
literal|24
operator|+
operator|(
name|ii
operator|*
literal|4
operator|)
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
operator|)
operator|+
name|argbytes
argument_list|,
name|len
operator|-
name|argbytes
argument_list|)
expr_stmt|;
operator|++
name|argno
expr_stmt|;
name|ii
operator|+=
operator|(
operator|(
name|len
operator|-
name|argbytes
operator|+
literal|3
operator|)
operator|&
operator|-
literal|4
operator|)
operator|/
literal|4
expr_stmt|;
block|}
comment|/* Push the rest of the arguments into stack.  */
for|for
control|(
init|;
name|argno
operator|<
name|nargs
condition|;
operator|++
name|argno
control|)
block|{
name|arg
operator|=
name|args
index|[
name|argno
index|]
expr_stmt|;
name|type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Float types should be passed in fpr's, as well as in the              stack.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FLT
operator|&&
name|f_argno
operator|<
literal|13
condition|)
block|{
if|if
condition|(
name|len
operator|>
literal|8
condition|)
name|printf_unfiltered
argument_list|(
literal|"Fatal Error: a floating point parameter #%d with a size> 8 is found!\n"
argument_list|,
name|argno
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|deprecated_registers
index|[
name|DEPRECATED_REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
operator|+
literal|1
operator|+
name|f_argno
argument_list|)
index|]
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|++
name|f_argno
expr_stmt|;
block|}
name|write_memory
argument_list|(
name|sp
operator|+
literal|24
operator|+
operator|(
name|ii
operator|*
literal|4
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ii
operator|+=
operator|(
operator|(
name|len
operator|+
literal|3
operator|)
operator|&
operator|-
literal|4
operator|)
operator|/
literal|4
expr_stmt|;
block|}
block|}
comment|/* Set the stack pointer.  According to the ABI, the SP is meant to      be set _before_ the corresponding stack space is used.  On AIX,      this even applies when the target has been completely stopped!      Not doing this can lead to conflicts with the kernel which thinks      that it still has control over this not-yet-allocated stack      region.  */
name|regcache_raw_write_signed
argument_list|(
name|regcache
argument_list|,
name|SP_REGNUM
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/* Set back chain properly.  */
name|store_unsigned_integer
argument_list|(
name|tmp_buffer
argument_list|,
literal|4
argument_list|,
name|saved_sp
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|sp
argument_list|,
name|tmp_buffer
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Point the inferior function call's return address at the dummy's      breakpoint.  */
name|regcache_raw_write_signed
argument_list|(
name|regcache
argument_list|,
name|tdep
operator|->
name|ppc_lr_regnum
argument_list|,
name|bp_addr
argument_list|)
expr_stmt|;
comment|/* Set the TOC register, get the value from the objfile reader      which, in turn, gets it from the VMAP table.  */
if|if
condition|(
name|rs6000_find_toc_address_hook
operator|!=
name|NULL
condition|)
block|{
name|CORE_ADDR
name|tocvalue
init|=
call|(
modifier|*
name|rs6000_find_toc_address_hook
call|)
argument_list|(
name|func_addr
argument_list|)
decl_stmt|;
name|regcache_raw_write_signed
argument_list|(
name|regcache
argument_list|,
name|tdep
operator|->
name|ppc_toc_regnum
argument_list|,
name|tocvalue
argument_list|)
expr_stmt|;
block|}
name|target_store_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_comment
comment|/* PowerOpen always puts structures in memory.  Vectors, which were    added later, do get returned in a register though.  */
end_comment

begin_function
specifier|static
name|int
name|rs6000_use_struct_convention
parameter_list|(
name|int
name|gcc_p
parameter_list|,
name|struct
name|type
modifier|*
name|value_type
parameter_list|)
block|{
if|if
condition|(
operator|(
name|TYPE_LENGTH
argument_list|(
name|value_type
argument_list|)
operator|==
literal|16
operator|||
name|TYPE_LENGTH
argument_list|(
name|value_type
argument_list|)
operator|==
literal|8
operator|)
operator|&&
name|TYPE_VECTOR
argument_list|(
name|value_type
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rs6000_extract_return_value
parameter_list|(
name|struct
name|type
modifier|*
name|valtype
parameter_list|,
name|char
modifier|*
name|regbuf
parameter_list|,
name|char
modifier|*
name|valbuf
parameter_list|)
block|{
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|TYPE_CODE_FLT
condition|)
block|{
name|double
name|dd
decl_stmt|;
name|float
name|ff
decl_stmt|;
comment|/* floats and doubles are returned in fpr1. fpr's have a size of 8 bytes.          We need to truncate the return value into float size (4 byte) if          necessary.  */
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
operator|>
literal|4
condition|)
comment|/* this is a double */
name|memcpy
argument_list|(
name|valbuf
argument_list|,
operator|&
name|regbuf
index|[
name|DEPRECATED_REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
operator|+
literal|1
argument_list|)
index|]
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* float */
name|memcpy
argument_list|(
operator|&
name|dd
argument_list|,
operator|&
name|regbuf
index|[
name|DEPRECATED_REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
operator|+
literal|1
argument_list|)
index|]
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|ff
operator|=
operator|(
name|float
operator|)
name|dd
expr_stmt|;
name|memcpy
argument_list|(
name|valbuf
argument_list|,
operator|&
name|ff
argument_list|,
sizeof|sizeof
argument_list|(
name|float
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|valtype
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
operator|&&
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
operator|==
literal|16
operator|&&
name|TYPE_VECTOR
argument_list|(
name|valtype
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|valbuf
argument_list|,
name|regbuf
operator|+
name|DEPRECATED_REGISTER_BYTE
argument_list|(
name|tdep
operator|->
name|ppc_vr0_regnum
operator|+
literal|2
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* return value is copied starting from r3. */
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
operator|&&
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
operator|<
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
literal|3
argument_list|)
condition|)
name|offset
operator|=
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
literal|3
argument_list|)
operator|-
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|valbuf
argument_list|,
name|regbuf
operator|+
name|DEPRECATED_REGISTER_BYTE
argument_list|(
literal|3
argument_list|)
operator|+
name|offset
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return whether handle_inferior_event() should proceed through code    starting at PC in function NAME when stepping.     The AIX -bbigtoc linker option generates functions @FIX0, @FIX1, etc. to    handle memory references that are too distant to fit in instructions    generated by the compiler.  For example, if 'foo' in the following    instruction:       lwz r9,foo(r2)     is greater than 32767, the linker might replace the lwz with a branch to    somewhere in @FIX1 that does the load in 2 instructions and then branches    back to where execution should continue.     GDB should silently step over @FIX code, just like AIX dbx does.    Unfortunately, the linker uses the "b" instruction for the branches,    meaning that the link register doesn't get set.  Therefore, GDB's usual    step_over_function() mechanism won't work.     Instead, use the IN_SOLIB_RETURN_TRAMPOLINE and SKIP_TRAMPOLINE_CODE hooks    in handle_inferior_event() to skip past @FIX code.  */
end_comment

begin_function
name|int
name|rs6000_in_solib_return_trampoline
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|name
operator|&&
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"@FIX"
argument_list|,
literal|4
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Skip code that the user doesn't want to see when stepping:     1. Indirect function calls use a piece of trampoline code to do context    switching, i.e. to set the new TOC table.  Skip such code if we are on    its first instruction (as when we have single-stepped to here).     2. Skip shared library trampoline code (which is different from    indirect function call trampolines).     3. Skip bigtoc fixup code.     Result is desired PC to step until, or NULL if we are not in    code that should be skipped.  */
end_comment

begin_function
name|CORE_ADDR
name|rs6000_skip_trampoline_code
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|unsigned
name|int
name|ii
decl_stmt|,
name|op
decl_stmt|;
name|int
name|rel
decl_stmt|;
name|CORE_ADDR
name|solib_target_pc
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
specifier|static
name|unsigned
name|trampoline_code
index|[]
init|=
block|{
literal|0x800b0000
block|,
comment|/*     l   r0,0x0(r11)  */
literal|0x90410014
block|,
comment|/*    st   r2,0x14(r1)  */
literal|0x7c0903a6
block|,
comment|/* mtctr   r0           */
literal|0x804b0004
block|,
comment|/*     l   r2,0x4(r11)  */
literal|0x816b0008
block|,
comment|/*     l  r11,0x8(r11)  */
literal|0x4e800420
block|,
comment|/*  bctr                */
literal|0x4e800020
block|,
comment|/*    br                */
literal|0
block|}
decl_stmt|;
comment|/* Check for bigtoc fixup code.  */
name|msymbol
operator|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
operator|&&
name|rs6000_in_solib_return_trampoline
argument_list|(
name|pc
argument_list|,
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|msymbol
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Double-check that the third instruction from PC is relative "b".  */
name|op
operator|=
name|read_memory_integer
argument_list|(
name|pc
operator|+
literal|8
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|op
operator|&
literal|0xfc000003
operator|)
operator|==
literal|0x48000000
condition|)
block|{
comment|/* Extract bits 6-29 as a signed 24-bit relative word address and 	     add it to the containing PC.  */
name|rel
operator|=
operator|(
call|(
name|int
call|)
argument_list|(
name|op
operator|<<
literal|6
argument_list|)
operator|>>
literal|6
operator|)
expr_stmt|;
return|return
name|pc
operator|+
literal|8
operator|+
name|rel
return|;
block|}
block|}
comment|/* If pc is in a shared library trampoline, return its target.  */
name|solib_target_pc
operator|=
name|find_solib_trampoline_target
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|solib_target_pc
condition|)
return|return
name|solib_target_pc
return|;
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|trampoline_code
index|[
name|ii
index|]
condition|;
operator|++
name|ii
control|)
block|{
name|op
operator|=
name|read_memory_integer
argument_list|(
name|pc
operator|+
operator|(
name|ii
operator|*
literal|4
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|!=
name|trampoline_code
index|[
name|ii
index|]
condition|)
return|return
literal|0
return|;
block|}
name|ii
operator|=
name|read_register
argument_list|(
literal|11
argument_list|)
expr_stmt|;
comment|/* r11 holds destination addr   */
name|pc
operator|=
name|read_memory_addr
argument_list|(
name|ii
argument_list|,
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|wordsize
argument_list|)
expr_stmt|;
comment|/* (r11) value */
return|return
name|pc
return|;
block|}
end_function

begin_comment
comment|/* Determines whether the function FI has a frame on the stack or not.  */
end_comment

begin_function
name|int
name|rs6000_frameless_function_invocation
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
name|CORE_ADDR
name|func_start
decl_stmt|;
name|struct
name|rs6000_framedata
name|fdata
decl_stmt|;
comment|/* Don't even think about framelessness except on the innermost frame      or if the function was interrupted by a signal.  */
if|if
condition|(
name|get_next_frame
argument_list|(
name|fi
argument_list|)
operator|!=
name|NULL
operator|&&
operator|!
operator|(
name|get_frame_type
argument_list|(
name|get_next_frame
argument_list|(
name|fi
argument_list|)
argument_list|)
operator|==
name|SIGTRAMP_FRAME
operator|)
condition|)
return|return
literal|0
return|;
name|func_start
operator|=
name|get_frame_func
argument_list|(
name|fi
argument_list|)
expr_stmt|;
comment|/* If we failed to find the start of the function, it is a mistake      to inspect the instructions.  */
if|if
condition|(
operator|!
name|func_start
condition|)
block|{
comment|/* A frame with a zero PC is usually created by dereferencing a NULL          function pointer, normally causing an immediate core dump of the          inferior.  Mark function as frameless, as the inferior has no chance          of setting up a stack frame.  */
if|if
condition|(
name|get_frame_pc
argument_list|(
name|fi
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
operator|(
name|void
operator|)
name|skip_prologue
argument_list|(
name|func_start
argument_list|,
name|get_frame_pc
argument_list|(
name|fi
argument_list|)
argument_list|,
operator|&
name|fdata
argument_list|)
expr_stmt|;
return|return
name|fdata
operator|.
name|frameless
return|;
block|}
end_function

begin_comment
comment|/* Return the PC saved in a frame.  */
end_comment

begin_function
name|CORE_ADDR
name|rs6000_frame_saved_pc
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
name|CORE_ADDR
name|func_start
decl_stmt|;
name|struct
name|rs6000_framedata
name|fdata
decl_stmt|;
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
name|int
name|wordsize
init|=
name|tdep
operator|->
name|wordsize
decl_stmt|;
if|if
condition|(
operator|(
name|get_frame_type
argument_list|(
name|fi
argument_list|)
operator|==
name|SIGTRAMP_FRAME
operator|)
condition|)
return|return
name|read_memory_addr
argument_list|(
name|get_frame_base
argument_list|(
name|fi
argument_list|)
operator|+
name|SIG_FRAME_PC_OFFSET
argument_list|,
name|wordsize
argument_list|)
return|;
if|if
condition|(
name|DEPRECATED_PC_IN_CALL_DUMMY
argument_list|(
name|get_frame_pc
argument_list|(
name|fi
argument_list|)
argument_list|,
name|get_frame_base
argument_list|(
name|fi
argument_list|)
argument_list|,
name|get_frame_base
argument_list|(
name|fi
argument_list|)
argument_list|)
condition|)
return|return
name|deprecated_read_register_dummy
argument_list|(
name|get_frame_pc
argument_list|(
name|fi
argument_list|)
argument_list|,
name|get_frame_base
argument_list|(
name|fi
argument_list|)
argument_list|,
name|PC_REGNUM
argument_list|)
return|;
name|func_start
operator|=
name|get_frame_func
argument_list|(
name|fi
argument_list|)
expr_stmt|;
comment|/* If we failed to find the start of the function, it is a mistake      to inspect the instructions.  */
if|if
condition|(
operator|!
name|func_start
condition|)
return|return
literal|0
return|;
operator|(
name|void
operator|)
name|skip_prologue
argument_list|(
name|func_start
argument_list|,
name|get_frame_pc
argument_list|(
name|fi
argument_list|)
argument_list|,
operator|&
name|fdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|fdata
operator|.
name|lr_offset
operator|==
literal|0
operator|&&
name|get_next_frame
argument_list|(
name|fi
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|get_frame_type
argument_list|(
name|get_next_frame
argument_list|(
name|fi
argument_list|)
argument_list|)
operator|==
name|SIGTRAMP_FRAME
operator|)
condition|)
return|return
name|read_memory_addr
argument_list|(
operator|(
name|get_frame_base
argument_list|(
name|get_next_frame
argument_list|(
name|fi
argument_list|)
argument_list|)
operator|+
name|SIG_FRAME_LR_OFFSET
operator|)
argument_list|,
name|wordsize
argument_list|)
return|;
elseif|else
if|if
condition|(
name|DEPRECATED_PC_IN_CALL_DUMMY
argument_list|(
name|get_frame_pc
argument_list|(
name|get_next_frame
argument_list|(
name|fi
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
comment|/* The link register wasn't saved by this frame and the next            (inner, newer) frame is a dummy.  Get the link register            value by unwinding it from that [dummy] frame.  */
block|{
name|ULONGEST
name|lr
decl_stmt|;
name|frame_unwind_unsigned_register
argument_list|(
name|get_next_frame
argument_list|(
name|fi
argument_list|)
argument_list|,
name|tdep
operator|->
name|ppc_lr_regnum
argument_list|,
operator|&
name|lr
argument_list|)
expr_stmt|;
return|return
name|lr
return|;
block|}
else|else
return|return
name|read_memory_addr
argument_list|(
name|DEPRECATED_FRAME_CHAIN
argument_list|(
name|fi
argument_list|)
operator|+
name|tdep
operator|->
name|lr_frame_offset
argument_list|,
name|wordsize
argument_list|)
return|;
block|}
if|if
condition|(
name|fdata
operator|.
name|lr_offset
operator|==
literal|0
condition|)
return|return
name|read_register
argument_list|(
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|ppc_lr_regnum
argument_list|)
return|;
return|return
name|read_memory_addr
argument_list|(
name|DEPRECATED_FRAME_CHAIN
argument_list|(
name|fi
argument_list|)
operator|+
name|fdata
operator|.
name|lr_offset
argument_list|,
name|wordsize
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If saved registers of frame FI are not known yet, read and cache them.&FDATAP contains rs6000_framedata; TDATAP can be NULL,    in which case the framedata are read.  */
end_comment

begin_function
specifier|static
name|void
name|frame_get_saved_regs
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|,
name|struct
name|rs6000_framedata
modifier|*
name|fdatap
parameter_list|)
block|{
name|CORE_ADDR
name|frame_addr
decl_stmt|;
name|struct
name|rs6000_framedata
name|work_fdata
decl_stmt|;
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
name|int
name|wordsize
init|=
name|tdep
operator|->
name|wordsize
decl_stmt|;
if|if
condition|(
name|deprecated_get_frame_saved_regs
argument_list|(
name|fi
argument_list|)
condition|)
return|return;
if|if
condition|(
name|fdatap
operator|==
name|NULL
condition|)
block|{
name|fdatap
operator|=
operator|&
name|work_fdata
expr_stmt|;
operator|(
name|void
operator|)
name|skip_prologue
argument_list|(
name|get_frame_func
argument_list|(
name|fi
argument_list|)
argument_list|,
name|get_frame_pc
argument_list|(
name|fi
argument_list|)
argument_list|,
name|fdatap
argument_list|)
expr_stmt|;
block|}
name|frame_saved_regs_zalloc
argument_list|(
name|fi
argument_list|)
expr_stmt|;
comment|/* If there were any saved registers, figure out parent's stack      pointer.  */
comment|/* The following is true only if the frame doesn't have a call to      alloca(), FIXME.  */
if|if
condition|(
name|fdatap
operator|->
name|saved_fpr
operator|==
literal|0
operator|&&
name|fdatap
operator|->
name|saved_gpr
operator|==
literal|0
operator|&&
name|fdatap
operator|->
name|saved_vr
operator|==
literal|0
operator|&&
name|fdatap
operator|->
name|saved_ev
operator|==
literal|0
operator|&&
name|fdatap
operator|->
name|lr_offset
operator|==
literal|0
operator|&&
name|fdatap
operator|->
name|cr_offset
operator|==
literal|0
operator|&&
name|fdatap
operator|->
name|vr_offset
operator|==
literal|0
operator|&&
name|fdatap
operator|->
name|ev_offset
operator|==
literal|0
condition|)
name|frame_addr
operator|=
literal|0
expr_stmt|;
else|else
comment|/* NOTE: cagney/2002-04-14: The ->frame points to the inner-most        address of the current frame.  Things might be easier if the        ->frame pointed to the outer-most address of the frame.  In the        mean time, the address of the prev frame is used as the base        address of this frame.  */
name|frame_addr
operator|=
name|DEPRECATED_FRAME_CHAIN
argument_list|(
name|fi
argument_list|)
expr_stmt|;
comment|/* if != -1, fdatap->saved_fpr is the smallest number of saved_fpr.      All fpr's from saved_fpr to fp31 are saved.  */
if|if
condition|(
name|fdatap
operator|->
name|saved_fpr
operator|>=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|CORE_ADDR
name|fpr_addr
init|=
name|frame_addr
operator|+
name|fdatap
operator|->
name|fpr_offset
decl_stmt|;
for|for
control|(
name|i
operator|=
name|fdatap
operator|->
name|saved_fpr
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|deprecated_get_frame_saved_regs
argument_list|(
name|fi
argument_list|)
index|[
name|FP0_REGNUM
operator|+
name|i
index|]
operator|=
name|fpr_addr
expr_stmt|;
name|fpr_addr
operator|+=
literal|8
expr_stmt|;
block|}
block|}
comment|/* if != -1, fdatap->saved_gpr is the smallest number of saved_gpr.      All gpr's from saved_gpr to gpr31 are saved.  */
if|if
condition|(
name|fdatap
operator|->
name|saved_gpr
operator|>=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|CORE_ADDR
name|gpr_addr
init|=
name|frame_addr
operator|+
name|fdatap
operator|->
name|gpr_offset
decl_stmt|;
for|for
control|(
name|i
operator|=
name|fdatap
operator|->
name|saved_gpr
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|deprecated_get_frame_saved_regs
argument_list|(
name|fi
argument_list|)
index|[
name|tdep
operator|->
name|ppc_gp0_regnum
operator|+
name|i
index|]
operator|=
name|gpr_addr
expr_stmt|;
name|gpr_addr
operator|+=
name|wordsize
expr_stmt|;
block|}
block|}
comment|/* if != -1, fdatap->saved_vr is the smallest number of saved_vr.      All vr's from saved_vr to vr31 are saved.  */
if|if
condition|(
name|tdep
operator|->
name|ppc_vr0_regnum
operator|!=
operator|-
literal|1
operator|&&
name|tdep
operator|->
name|ppc_vrsave_regnum
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|fdatap
operator|->
name|saved_vr
operator|>=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|CORE_ADDR
name|vr_addr
init|=
name|frame_addr
operator|+
name|fdatap
operator|->
name|vr_offset
decl_stmt|;
for|for
control|(
name|i
operator|=
name|fdatap
operator|->
name|saved_vr
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|deprecated_get_frame_saved_regs
argument_list|(
name|fi
argument_list|)
index|[
name|tdep
operator|->
name|ppc_vr0_regnum
operator|+
name|i
index|]
operator|=
name|vr_addr
expr_stmt|;
name|vr_addr
operator|+=
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|tdep
operator|->
name|ppc_vr0_regnum
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* if != -1, fdatap->saved_ev is the smallest number of saved_ev. 	All vr's from saved_ev to ev31 are saved. ?????	*/
if|if
condition|(
name|tdep
operator|->
name|ppc_ev0_regnum
operator|!=
operator|-
literal|1
operator|&&
name|tdep
operator|->
name|ppc_ev31_regnum
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|fdatap
operator|->
name|saved_ev
operator|>=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|CORE_ADDR
name|ev_addr
init|=
name|frame_addr
operator|+
name|fdatap
operator|->
name|ev_offset
decl_stmt|;
for|for
control|(
name|i
operator|=
name|fdatap
operator|->
name|saved_ev
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|deprecated_get_frame_saved_regs
argument_list|(
name|fi
argument_list|)
index|[
name|tdep
operator|->
name|ppc_ev0_regnum
operator|+
name|i
index|]
operator|=
name|ev_addr
expr_stmt|;
name|deprecated_get_frame_saved_regs
argument_list|(
name|fi
argument_list|)
index|[
name|tdep
operator|->
name|ppc_gp0_regnum
operator|+
name|i
index|]
operator|=
name|ev_addr
operator|+
literal|4
expr_stmt|;
name|ev_addr
operator|+=
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|tdep
operator|->
name|ppc_ev0_regnum
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* If != 0, fdatap->cr_offset is the offset from the frame that holds      the CR.  */
if|if
condition|(
name|fdatap
operator|->
name|cr_offset
operator|!=
literal|0
condition|)
name|deprecated_get_frame_saved_regs
argument_list|(
name|fi
argument_list|)
index|[
name|tdep
operator|->
name|ppc_cr_regnum
index|]
operator|=
name|frame_addr
operator|+
name|fdatap
operator|->
name|cr_offset
expr_stmt|;
comment|/* If != 0, fdatap->lr_offset is the offset from the frame that holds      the LR.  */
if|if
condition|(
name|fdatap
operator|->
name|lr_offset
operator|!=
literal|0
condition|)
name|deprecated_get_frame_saved_regs
argument_list|(
name|fi
argument_list|)
index|[
name|tdep
operator|->
name|ppc_lr_regnum
index|]
operator|=
name|frame_addr
operator|+
name|fdatap
operator|->
name|lr_offset
expr_stmt|;
comment|/* If != 0, fdatap->vrsave_offset is the offset from the frame that holds      the VRSAVE.  */
if|if
condition|(
name|fdatap
operator|->
name|vrsave_offset
operator|!=
literal|0
condition|)
name|deprecated_get_frame_saved_regs
argument_list|(
name|fi
argument_list|)
index|[
name|tdep
operator|->
name|ppc_vrsave_regnum
index|]
operator|=
name|frame_addr
operator|+
name|fdatap
operator|->
name|vrsave_offset
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the address of a frame. This is the inital %sp value when the frame    was first allocated.  For functions calling alloca(), it might be saved in    an alloca register.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|frame_initial_stack_address
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
name|CORE_ADDR
name|tmpaddr
decl_stmt|;
name|struct
name|rs6000_framedata
name|fdata
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|callee_fi
decl_stmt|;
comment|/* If the initial stack pointer (frame address) of this frame is known,      just return it.  */
if|if
condition|(
name|get_frame_extra_info
argument_list|(
name|fi
argument_list|)
operator|->
name|initial_sp
condition|)
return|return
name|get_frame_extra_info
argument_list|(
name|fi
argument_list|)
operator|->
name|initial_sp
return|;
comment|/* Find out if this function is using an alloca register.  */
operator|(
name|void
operator|)
name|skip_prologue
argument_list|(
name|get_frame_func
argument_list|(
name|fi
argument_list|)
argument_list|,
name|get_frame_pc
argument_list|(
name|fi
argument_list|)
argument_list|,
operator|&
name|fdata
argument_list|)
expr_stmt|;
comment|/* If saved registers of this frame are not known yet, read and      cache them.  */
if|if
condition|(
operator|!
name|deprecated_get_frame_saved_regs
argument_list|(
name|fi
argument_list|)
condition|)
name|frame_get_saved_regs
argument_list|(
name|fi
argument_list|,
operator|&
name|fdata
argument_list|)
expr_stmt|;
comment|/* If no alloca register used, then fi->frame is the value of the %sp for      this frame, and it is good enough.  */
if|if
condition|(
name|fdata
operator|.
name|alloca_reg
operator|<
literal|0
condition|)
block|{
name|get_frame_extra_info
argument_list|(
name|fi
argument_list|)
operator|->
name|initial_sp
operator|=
name|get_frame_base
argument_list|(
name|fi
argument_list|)
expr_stmt|;
return|return
name|get_frame_extra_info
argument_list|(
name|fi
argument_list|)
operator|->
name|initial_sp
return|;
block|}
comment|/* There is an alloca register, use its value, in the current frame,      as the initial stack pointer.  */
block|{
name|char
name|tmpbuf
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
if|if
condition|(
name|frame_register_read
argument_list|(
name|fi
argument_list|,
name|fdata
operator|.
name|alloca_reg
argument_list|,
name|tmpbuf
argument_list|)
condition|)
block|{
name|get_frame_extra_info
argument_list|(
name|fi
argument_list|)
operator|->
name|initial_sp
operator|=
name|extract_unsigned_integer
argument_list|(
name|tmpbuf
argument_list|,
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|fdata
operator|.
name|alloca_reg
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* NOTE: cagney/2002-04-17: At present the only time          frame_register_read will fail is when the register isn't          available.  If that does happen, use the frame.  */
name|get_frame_extra_info
argument_list|(
name|fi
argument_list|)
operator|->
name|initial_sp
operator|=
name|get_frame_base
argument_list|(
name|fi
argument_list|)
expr_stmt|;
block|}
return|return
name|get_frame_extra_info
argument_list|(
name|fi
argument_list|)
operator|->
name|initial_sp
return|;
block|}
end_function

begin_comment
comment|/* Describe the pointer in each stack frame to the previous stack frame    (its caller).  */
end_comment

begin_comment
comment|/* DEPRECATED_FRAME_CHAIN takes a frame's nominal address and produces    the frame's chain-pointer.  */
end_comment

begin_comment
comment|/* In the case of the RS/6000, the frame's nominal address    is the address of a 4-byte word containing the calling frame's address.  */
end_comment

begin_function
name|CORE_ADDR
name|rs6000_frame_chain
parameter_list|(
name|struct
name|frame_info
modifier|*
name|thisframe
parameter_list|)
block|{
name|CORE_ADDR
name|fp
decl_stmt|,
name|fpp
decl_stmt|,
name|lr
decl_stmt|;
name|int
name|wordsize
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|wordsize
decl_stmt|;
if|if
condition|(
name|DEPRECATED_PC_IN_CALL_DUMMY
argument_list|(
name|get_frame_pc
argument_list|(
name|thisframe
argument_list|)
argument_list|,
name|get_frame_base
argument_list|(
name|thisframe
argument_list|)
argument_list|,
name|get_frame_base
argument_list|(
name|thisframe
argument_list|)
argument_list|)
condition|)
comment|/* A dummy frame always correctly chains back to the previous        frame.  */
return|return
name|read_memory_addr
argument_list|(
name|get_frame_base
argument_list|(
name|thisframe
argument_list|)
argument_list|,
name|wordsize
argument_list|)
return|;
if|if
condition|(
name|deprecated_inside_entry_file
argument_list|(
name|get_frame_pc
argument_list|(
name|thisframe
argument_list|)
argument_list|)
operator|||
name|get_frame_pc
argument_list|(
name|thisframe
argument_list|)
operator|==
name|entry_point_address
argument_list|()
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|get_frame_type
argument_list|(
name|thisframe
argument_list|)
operator|==
name|SIGTRAMP_FRAME
operator|)
condition|)
name|fp
operator|=
name|read_memory_addr
argument_list|(
name|get_frame_base
argument_list|(
name|thisframe
argument_list|)
operator|+
name|SIG_FRAME_FP_OFFSET
argument_list|,
name|wordsize
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|get_next_frame
argument_list|(
name|thisframe
argument_list|)
operator|!=
name|NULL
operator|&&
operator|(
name|get_frame_type
argument_list|(
name|get_next_frame
argument_list|(
name|thisframe
argument_list|)
argument_list|)
operator|==
name|SIGTRAMP_FRAME
operator|)
operator|&&
operator|(
name|DEPRECATED_FRAMELESS_FUNCTION_INVOCATION_P
argument_list|()
operator|&&
name|DEPRECATED_FRAMELESS_FUNCTION_INVOCATION
argument_list|(
name|thisframe
argument_list|)
operator|)
condition|)
comment|/* A frameless function interrupted by a signal did not change the        frame pointer.  */
name|fp
operator|=
name|get_frame_base
argument_list|(
name|thisframe
argument_list|)
expr_stmt|;
else|else
name|fp
operator|=
name|read_memory_addr
argument_list|(
name|get_frame_base
argument_list|(
name|thisframe
argument_list|)
argument_list|,
name|wordsize
argument_list|)
expr_stmt|;
return|return
name|fp
return|;
block|}
end_function

begin_comment
comment|/* Return the size of register REG when words are WORDSIZE bytes long.  If REG    isn't available with that word size, return 0.  */
end_comment

begin_function
specifier|static
name|int
name|regsize
parameter_list|(
specifier|const
name|struct
name|reg
modifier|*
name|reg
parameter_list|,
name|int
name|wordsize
parameter_list|)
block|{
return|return
name|wordsize
operator|==
literal|8
condition|?
name|reg
operator|->
name|sz64
else|:
name|reg
operator|->
name|sz32
return|;
block|}
end_function

begin_comment
comment|/* Return the name of register number N, or null if no such register exists    in the current architecture.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|rs6000_register_name
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|reg
modifier|*
name|reg
init|=
name|tdep
operator|->
name|regs
operator|+
name|n
decl_stmt|;
if|if
condition|(
operator|!
name|regsize
argument_list|(
name|reg
argument_list|,
name|tdep
operator|->
name|wordsize
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|reg
operator|->
name|name
return|;
block|}
end_function

begin_comment
comment|/* Index within `registers' of the first byte of the space for    register N.  */
end_comment

begin_function
specifier|static
name|int
name|rs6000_register_byte
parameter_list|(
name|int
name|n
parameter_list|)
block|{
return|return
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|regoff
index|[
name|n
index|]
return|;
block|}
end_function

begin_comment
comment|/* Return the number of bytes of storage in the actual machine representation    for register N if that register is available, else return 0.  */
end_comment

begin_function
specifier|static
name|int
name|rs6000_register_raw_size
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|reg
modifier|*
name|reg
init|=
name|tdep
operator|->
name|regs
operator|+
name|n
decl_stmt|;
return|return
name|regsize
argument_list|(
name|reg
argument_list|,
name|tdep
operator|->
name|wordsize
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the GDB type object for the "standard" data type    of data in register N.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|rs6000_register_virtual_type
parameter_list|(
name|int
name|n
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|reg
modifier|*
name|reg
init|=
name|tdep
operator|->
name|regs
operator|+
name|n
decl_stmt|;
if|if
condition|(
name|reg
operator|->
name|fpr
condition|)
return|return
name|builtin_type_double
return|;
else|else
block|{
name|int
name|size
init|=
name|regsize
argument_list|(
name|reg
argument_list|,
name|tdep
operator|->
name|wordsize
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|0
case|:
return|return
name|builtin_type_int0
return|;
case|case
literal|4
case|:
return|return
name|builtin_type_int32
return|;
case|case
literal|8
case|:
if|if
condition|(
name|tdep
operator|->
name|ppc_ev0_regnum
operator|<=
name|n
operator|&&
name|n
operator|<=
name|tdep
operator|->
name|ppc_ev31_regnum
condition|)
return|return
name|builtin_type_vec64
return|;
else|else
return|return
name|builtin_type_int64
return|;
break|break;
case|case
literal|16
case|:
return|return
name|builtin_type_vec128
return|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Register %d size %d unknown"
argument_list|,
name|n
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return whether register N requires conversion when moving from raw format    to virtual format.     The register format for RS/6000 floating point registers is always    double, we need a conversion if the memory format is float.  */
end_comment

begin_function
specifier|static
name|int
name|rs6000_register_convertible
parameter_list|(
name|int
name|n
parameter_list|)
block|{
specifier|const
name|struct
name|reg
modifier|*
name|reg
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|regs
operator|+
name|n
decl_stmt|;
return|return
name|reg
operator|->
name|fpr
return|;
block|}
end_function

begin_comment
comment|/* Convert data from raw format for register N in buffer FROM    to virtual format with type TYPE in buffer TO.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_register_convert_to_virtual
parameter_list|(
name|int
name|n
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|from
parameter_list|,
name|char
modifier|*
name|to
parameter_list|)
block|{
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|!=
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|n
argument_list|)
condition|)
block|{
name|double
name|val
init|=
name|deprecated_extract_floating
argument_list|(
name|from
argument_list|,
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|n
argument_list|)
argument_list|)
decl_stmt|;
name|deprecated_store_floating
argument_list|(
name|to
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert data from virtual format with type TYPE in buffer FROM    to raw format for register N in buffer TO.  */
end_comment

begin_function
specifier|static
name|void
name|rs6000_register_convert_to_raw
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|n
parameter_list|,
specifier|const
name|char
modifier|*
name|from
parameter_list|,
name|char
modifier|*
name|to
parameter_list|)
block|{
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|!=
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|n
argument_list|)
condition|)
block|{
name|double
name|val
init|=
name|deprecated_extract_floating
argument_list|(
name|from
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|deprecated_store_floating
argument_list|(
name|to
argument_list|,
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|n
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|e500_pseudo_register_read
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|reg_nr
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|)
block|{
name|int
name|base_regnum
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|char
name|temp_buffer
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|gdbarch
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg_nr
operator|>=
name|tdep
operator|->
name|ppc_gp0_regnum
operator|&&
name|reg_nr
operator|<=
name|tdep
operator|->
name|ppc_gplast_regnum
condition|)
block|{
name|base_regnum
operator|=
name|reg_nr
operator|-
name|tdep
operator|->
name|ppc_gp0_regnum
operator|+
name|tdep
operator|->
name|ppc_ev0_regnum
expr_stmt|;
comment|/* Build the value in the provided buffer.  */
comment|/* Read the raw register of which this one is the lower portion.  */
name|regcache_raw_read
argument_list|(
name|regcache
argument_list|,
name|base_regnum
argument_list|,
name|temp_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|)
name|offset
operator|=
literal|4
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buffer
argument_list|,
name|temp_buffer
operator|+
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|e500_pseudo_register_write
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|reg_nr
parameter_list|,
specifier|const
name|void
modifier|*
name|buffer
parameter_list|)
block|{
name|int
name|base_regnum
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|char
name|temp_buffer
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|gdbarch
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg_nr
operator|>=
name|tdep
operator|->
name|ppc_gp0_regnum
operator|&&
name|reg_nr
operator|<=
name|tdep
operator|->
name|ppc_gplast_regnum
condition|)
block|{
name|base_regnum
operator|=
name|reg_nr
operator|-
name|tdep
operator|->
name|ppc_gp0_regnum
operator|+
name|tdep
operator|->
name|ppc_ev0_regnum
expr_stmt|;
comment|/* reg_nr is 32 bit here, and base_regnum is 64 bits.  */
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|)
name|offset
operator|=
literal|4
expr_stmt|;
comment|/* Let's read the value of the base register into a temporary 	 buffer, so that overwriting the last four bytes with the new 	 value of the pseudo will leave the upper 4 bytes unchanged.  */
name|regcache_raw_read
argument_list|(
name|regcache
argument_list|,
name|base_regnum
argument_list|,
name|temp_buffer
argument_list|)
expr_stmt|;
comment|/* Write as an 8 byte quantity.  */
name|memcpy
argument_list|(
name|temp_buffer
operator|+
name|offset
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buffer
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|regcache_raw_write
argument_list|(
name|regcache
argument_list|,
name|base_regnum
argument_list|,
name|temp_buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Convert a dwarf2 register number to a gdb REGNUM.  */
end_comment

begin_function
specifier|static
name|int
name|e500_dwarf2_reg_to_regnum
parameter_list|(
name|int
name|num
parameter_list|)
block|{
name|int
name|regnum
decl_stmt|;
if|if
condition|(
literal|0
operator|<=
name|num
operator|&&
name|num
operator|<=
literal|31
condition|)
return|return
name|num
operator|+
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|ppc_gp0_regnum
return|;
else|else
return|return
name|num
return|;
block|}
end_function

begin_comment
comment|/* Convert a dbx stab register number (from `r' declaration) to a gdb    REGNUM.  */
end_comment

begin_function
specifier|static
name|int
name|rs6000_stab_reg_to_regnum
parameter_list|(
name|int
name|num
parameter_list|)
block|{
name|int
name|regnum
decl_stmt|;
switch|switch
condition|(
name|num
condition|)
block|{
case|case
literal|64
case|:
name|regnum
operator|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|ppc_mq_regnum
expr_stmt|;
break|break;
case|case
literal|65
case|:
name|regnum
operator|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|ppc_lr_regnum
expr_stmt|;
break|break;
case|case
literal|66
case|:
name|regnum
operator|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|ppc_ctr_regnum
expr_stmt|;
break|break;
case|case
literal|76
case|:
name|regnum
operator|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|ppc_xer_regnum
expr_stmt|;
break|break;
default|default:
name|regnum
operator|=
name|num
expr_stmt|;
break|break;
block|}
return|return
name|regnum
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rs6000_store_return_value
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|valbuf
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FLT
condition|)
comment|/* Floating point values are returned starting from FPR1 and up.        Say a double_double_double type could be returned in        FPR1/FPR2/FPR3 triple.  */
name|deprecated_write_register_bytes
argument_list|(
name|DEPRECATED_REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
operator|+
literal|1
argument_list|)
argument_list|,
name|valbuf
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
condition|)
block|{
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|==
literal|16
operator|&&
name|TYPE_VECTOR
argument_list|(
name|type
argument_list|)
condition|)
name|deprecated_write_register_bytes
argument_list|(
name|DEPRECATED_REGISTER_BYTE
argument_list|(
name|tdep
operator|->
name|ppc_vr0_regnum
operator|+
literal|2
argument_list|)
argument_list|,
name|valbuf
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Everything else is returned in GPR3 and up.  */
name|deprecated_write_register_bytes
argument_list|(
name|DEPRECATED_REGISTER_BYTE
argument_list|(
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|ppc_gp0_regnum
operator|+
literal|3
argument_list|)
argument_list|,
name|valbuf
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Extract from an array REGBUF containing the (raw) register state    the address in which a function should return its structure value,    as a CORE_ADDR (or an expression that can be used as one).  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|rs6000_extract_struct_value_address
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|)
block|{
comment|/* FIXME: cagney/2002-09-26: PR gdb/724: When making an inferior      function call GDB knows the address of the struct return value      and hence, should not need to call this function.  Unfortunately,      the current call_function_by_hand() code only saves the most      recent struct address leading to occasional calls.  The code      should instead maintain a stack of such addresses (in the dummy      frame object).  */
comment|/* NOTE: cagney/2002-09-26: Return 0 which indicates that we've      really got no idea where the return value is being stored.  While      r3, on function entry, contained the address it will have since      been reused (scratch) and hence wouldn't be valid */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Hook called when a new child process is started.  */
end_comment

begin_function
name|void
name|rs6000_create_inferior
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
if|if
condition|(
name|rs6000_set_host_arch_hook
condition|)
name|rs6000_set_host_arch_hook
argument_list|(
name|pid
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Support for CONVERT_FROM_FUNC_PTR_ADDR (ARCH, ADDR, TARG).     Usually a function pointer's representation is simply the address    of the function. On the RS/6000 however, a function pointer is    represented by a pointer to a TOC entry. This TOC entry contains    three words, the first word is the address of the function, the    second word is the TOC pointer (r2), and the third word is the    static chain value.  Throughout GDB it is currently assumed that a    function pointer contains the address of the function, which is not    easy to fix.  In addition, the conversion of a function address to    a function pointer would require allocation of a TOC entry in the    inferior's memory space, with all its drawbacks.  To be able to    call C++ virtual methods in the inferior (which are called via    function pointers), find_function_addr uses this function to get the    function address from a function pointer.  */
end_comment

begin_comment
comment|/* Return real function address if ADDR (a function pointer) is in the data    space and is therefore a special function pointer.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|rs6000_convert_from_func_ptr_addr
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|,
name|struct
name|target_ops
modifier|*
name|targ
parameter_list|)
block|{
name|struct
name|obj_section
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|find_pc_section
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|&&
name|s
operator|->
name|the_bfd_section
operator|->
name|flags
operator|&
name|SEC_CODE
condition|)
return|return
name|addr
return|;
comment|/* ADDR is in the data space, so it's a special function pointer. */
return|return
name|read_memory_addr
argument_list|(
name|addr
argument_list|,
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|wordsize
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Handling the various POWER/PowerPC variants.  */
end_comment

begin_comment
comment|/* The arrays here called registers_MUMBLE hold information about available    registers.     For each family of PPC variants, I've tried to isolate out the    common registers and put them up front, so that as long as you get    the general family right, GDB will correctly identify the registers    common to that family.  The common register sets are:     For the 60x family: hid0 hid1 iabr dabr pir     For the 505 and 860 family: eie eid nri     For the 403 and 403GC: icdbdr esr dear evpr cdbcr tsr tcr pit tbhi    tblo srr2 srr3 dbsr dbcr iac1 iac2 dac1 dac2 dccr iccr pbl1    pbu1 pbl2 pbu2     Most of these register groups aren't anything formal.  I arrived at    them by looking at the registers that occurred in more than one    processor.        Note: kevinb/2002-04-30: Support for the fpscr register was added    during April, 2002.  Slot 70 is being used for PowerPC and slot 71    for Power.  For PowerPC, slot 70 was unused and was already in the    PPC_UISA_SPRS which is ideally where fpscr should go.  For Power,    slot 70 was being used for "mq", so the next available slot (71)    was chosen.  It would have been nice to be able to make the    register numbers the same across processor cores, but this wasn't    possible without either 1) renumbering some registers for some    processors or 2) assigning fpscr to a really high slot that's    larger than any current register number.  Doing (1) is bad because    existing stubs would break.  Doing (2) is undesirable because it    would introduce a really large gap between fpscr and the rest of    the registers for most processors.  */
end_comment

begin_comment
comment|/* Convenience macros for populating register arrays.  */
end_comment

begin_comment
comment|/* Within another macro, convert S to a string.  */
end_comment

begin_define
define|#
directive|define
name|STR
parameter_list|(
name|s
parameter_list|)
value|#s
end_define

begin_comment
comment|/* Return a struct reg defining register NAME that's 32 bits on 32-bit systems    and 64 bits on 64-bit systems.  */
end_comment

begin_define
define|#
directive|define
name|R
parameter_list|(
name|name
parameter_list|)
value|{ STR(name), 4, 8, 0, 0 }
end_define

begin_comment
comment|/* Return a struct reg defining register NAME that's 32 bits on all    systems.  */
end_comment

begin_define
define|#
directive|define
name|R4
parameter_list|(
name|name
parameter_list|)
value|{ STR(name), 4, 4, 0, 0 }
end_define

begin_comment
comment|/* Return a struct reg defining register NAME that's 64 bits on all    systems.  */
end_comment

begin_define
define|#
directive|define
name|R8
parameter_list|(
name|name
parameter_list|)
value|{ STR(name), 8, 8, 0, 0 }
end_define

begin_comment
comment|/* Return a struct reg defining register NAME that's 128 bits on all    systems.  */
end_comment

begin_define
define|#
directive|define
name|R16
parameter_list|(
name|name
parameter_list|)
value|{ STR(name), 16, 16, 0, 0 }
end_define

begin_comment
comment|/* Return a struct reg defining floating-point register NAME.  */
end_comment

begin_define
define|#
directive|define
name|F
parameter_list|(
name|name
parameter_list|)
value|{ STR(name), 8, 8, 1, 0 }
end_define

begin_comment
comment|/* Return a struct reg defining a pseudo register NAME.  */
end_comment

begin_define
define|#
directive|define
name|P
parameter_list|(
name|name
parameter_list|)
value|{ STR(name), 4, 8, 0, 1}
end_define

begin_comment
comment|/* Return a struct reg defining register NAME that's 32 bits on 32-bit    systems and that doesn't exist on 64-bit systems.  */
end_comment

begin_define
define|#
directive|define
name|R32
parameter_list|(
name|name
parameter_list|)
value|{ STR(name), 4, 0, 0, 0 }
end_define

begin_comment
comment|/* Return a struct reg defining register NAME that's 64 bits on 64-bit    systems and that doesn't exist on 32-bit systems.  */
end_comment

begin_define
define|#
directive|define
name|R64
parameter_list|(
name|name
parameter_list|)
value|{ STR(name), 0, 8, 0, 0 }
end_define

begin_comment
comment|/* Return a struct reg placeholder for a register that doesn't exist.  */
end_comment

begin_define
define|#
directive|define
name|R0
value|{ 0, 0, 0, 0, 0 }
end_define

begin_comment
comment|/* UISA registers common across all architectures, including POWER.  */
end_comment

begin_define
define|#
directive|define
name|COMMON_UISA_REGS
define|\
comment|/*  0 */
value|R(r0), R(r1), R(r2), R(r3), R(r4), R(r5), R(r6), R(r7),  \
comment|/*  8 */
value|R(r8), R(r9), R(r10),R(r11),R(r12),R(r13),R(r14),R(r15), \
comment|/* 16 */
value|R(r16),R(r17),R(r18),R(r19),R(r20),R(r21),R(r22),R(r23), \
comment|/* 24 */
value|R(r24),R(r25),R(r26),R(r27),R(r28),R(r29),R(r30),R(r31), \
comment|/* 32 */
value|F(f0), F(f1), F(f2), F(f3), F(f4), F(f5), F(f6), F(f7),  \
comment|/* 40 */
value|F(f8), F(f9), F(f10),F(f11),F(f12),F(f13),F(f14),F(f15), \
comment|/* 48 */
value|F(f16),F(f17),F(f18),F(f19),F(f20),F(f21),F(f22),F(f23), \
comment|/* 56 */
value|F(f24),F(f25),F(f26),F(f27),F(f28),F(f29),F(f30),F(f31), \
comment|/* 64 */
value|R(pc), R(ps)
end_define

begin_define
define|#
directive|define
name|COMMON_UISA_NOFP_REGS
define|\
comment|/*  0 */
value|R(r0), R(r1), R(r2), R(r3), R(r4), R(r5), R(r6), R(r7),  \
comment|/*  8 */
value|R(r8), R(r9), R(r10),R(r11),R(r12),R(r13),R(r14),R(r15), \
comment|/* 16 */
value|R(r16),R(r17),R(r18),R(r19),R(r20),R(r21),R(r22),R(r23), \
comment|/* 24 */
value|R(r24),R(r25),R(r26),R(r27),R(r28),R(r29),R(r30),R(r31), \
comment|/* 32 */
value|R0,    R0,    R0,    R0,    R0,    R0,    R0,    R0,     \
comment|/* 40 */
value|R0,    R0,    R0,    R0,    R0,    R0,    R0,    R0,     \
comment|/* 48 */
value|R0,    R0,    R0,    R0,    R0,    R0,    R0,    R0,     \
comment|/* 56 */
value|R0,    R0,    R0,    R0,    R0,    R0,    R0,    R0,     \
comment|/* 64 */
value|R(pc), R(ps)
end_define

begin_comment
comment|/* UISA-level SPRs for PowerPC.  */
end_comment

begin_define
define|#
directive|define
name|PPC_UISA_SPRS
define|\
comment|/* 66 */
value|R4(cr),  R(lr), R(ctr), R4(xer), R4(fpscr)
end_define

begin_comment
comment|/* UISA-level SPRs for PowerPC without floating point support.  */
end_comment

begin_define
define|#
directive|define
name|PPC_UISA_NOFP_SPRS
define|\
comment|/* 66 */
value|R4(cr),  R(lr), R(ctr), R4(xer), R0
end_define

begin_comment
comment|/* Segment registers, for PowerPC.  */
end_comment

begin_define
define|#
directive|define
name|PPC_SEGMENT_REGS
define|\
comment|/* 71 */
value|R32(sr0),  R32(sr1),  R32(sr2),  R32(sr3),  \
comment|/* 75 */
value|R32(sr4),  R32(sr5),  R32(sr6),  R32(sr7),  \
comment|/* 79 */
value|R32(sr8),  R32(sr9),  R32(sr10), R32(sr11), \
comment|/* 83 */
value|R32(sr12), R32(sr13), R32(sr14), R32(sr15)
end_define

begin_comment
comment|/* OEA SPRs for PowerPC.  */
end_comment

begin_define
define|#
directive|define
name|PPC_OEA_SPRS
define|\
comment|/*  87 */
value|R4(pvr), \
comment|/*  88 */
value|R(ibat0u), R(ibat0l), R(ibat1u), R(ibat1l), \
comment|/*  92 */
value|R(ibat2u), R(ibat2l), R(ibat3u), R(ibat3l), \
comment|/*  96 */
value|R(dbat0u), R(dbat0l), R(dbat1u), R(dbat1l), \
comment|/* 100 */
value|R(dbat2u), R(dbat2l), R(dbat3u), R(dbat3l), \
comment|/* 104 */
value|R(sdr1),   R64(asr),  R(dar),    R4(dsisr), \
comment|/* 108 */
value|R(sprg0),  R(sprg1),  R(sprg2),  R(sprg3),  \
comment|/* 112 */
value|R(srr0),   R(srr1),   R(tbl),    R(tbu),    \
comment|/* 116 */
value|R4(dec),   R(dabr),   R4(ear)
end_define

begin_comment
comment|/* AltiVec registers.  */
end_comment

begin_define
define|#
directive|define
name|PPC_ALTIVEC_REGS
define|\
comment|/*119*/
value|R16(vr0), R16(vr1), R16(vr2), R16(vr3), R16(vr4), R16(vr5), R16(vr6), R16(vr7),  \
comment|/*127*/
value|R16(vr8), R16(vr9), R16(vr10),R16(vr11),R16(vr12),R16(vr13),R16(vr14),R16(vr15), \
comment|/*135*/
value|R16(vr16),R16(vr17),R16(vr18),R16(vr19),R16(vr20),R16(vr21),R16(vr22),R16(vr23), \
comment|/*143*/
value|R16(vr24),R16(vr25),R16(vr26),R16(vr27),R16(vr28),R16(vr29),R16(vr30),R16(vr31), \
comment|/*151*/
value|R4(vscr), R4(vrsave)
end_define

begin_comment
comment|/* Vectors of hi-lo general purpose registers.  */
end_comment

begin_define
define|#
directive|define
name|PPC_EV_REGS
define|\
comment|/* 0*/
value|R8(ev0), R8(ev1), R8(ev2), R8(ev3), R8(ev4), R8(ev5), R8(ev6), R8(ev7),  \
comment|/* 8*/
value|R8(ev8), R8(ev9), R8(ev10),R8(ev11),R8(ev12),R8(ev13),R8(ev14),R8(ev15), \
comment|/*16*/
value|R8(ev16),R8(ev17),R8(ev18),R8(ev19),R8(ev20),R8(ev21),R8(ev22),R8(ev23), \
comment|/*24*/
value|R8(ev24),R8(ev25),R8(ev26),R8(ev27),R8(ev28),R8(ev29),R8(ev30),R8(ev31)
end_define

begin_comment
comment|/* Lower half of the EV registers.  */
end_comment

begin_define
define|#
directive|define
name|PPC_GPRS_PSEUDO_REGS
define|\
comment|/*  0 */
value|P(r0), P(r1), P(r2), P(r3), P(r4), P(r5), P(r6), P(r7),  \
comment|/*  8 */
value|P(r8), P(r9), P(r10),P(r11),P(r12),P(r13),P(r14),P(r15), \
comment|/* 16 */
value|P(r16),P(r17),P(r18),P(r19),P(r20),P(r21),P(r22),P(r23), \
comment|/* 24 */
value|P(r24),P(r25),P(r26),P(r27),P(r28),P(r29),P(r30),P(r31)
end_define

begin_comment
comment|/* IBM POWER (pre-PowerPC) architecture, user-level view.  We only cover    user-level SPR's.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg
name|registers_power
index|[]
init|=
block|{
name|COMMON_UISA_REGS
block|,
comment|/* 66 */
name|R4
argument_list|(
name|cnd
argument_list|)
block|,
name|R
argument_list|(
name|lr
argument_list|)
block|,
name|R
argument_list|(
name|cnt
argument_list|)
block|,
name|R4
argument_list|(
name|xer
argument_list|)
block|,
name|R4
argument_list|(
name|mq
argument_list|)
block|,
comment|/* 71 */
name|R4
argument_list|(
argument|fpscr
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PowerPC UISA - a PPC processor as viewed by user-level code.  A UISA-only    view of the PowerPC.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg
name|registers_powerpc
index|[]
init|=
block|{
name|COMMON_UISA_REGS
block|,
name|PPC_UISA_SPRS
block|,
name|PPC_ALTIVEC_REGS
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PowerPC UISA - a PPC processor as viewed by user-level    code, but without floating point registers.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg
name|registers_powerpc_nofp
index|[]
init|=
block|{
name|COMMON_UISA_NOFP_REGS
block|,
name|PPC_UISA_SPRS
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* IBM PowerPC 403.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg
name|registers_403
index|[]
init|=
block|{
name|COMMON_UISA_REGS
block|,
name|PPC_UISA_SPRS
block|,
name|PPC_SEGMENT_REGS
block|,
name|PPC_OEA_SPRS
block|,
comment|/* 119 */
name|R
argument_list|(
name|icdbdr
argument_list|)
block|,
name|R
argument_list|(
name|esr
argument_list|)
block|,
name|R
argument_list|(
name|dear
argument_list|)
block|,
name|R
argument_list|(
name|evpr
argument_list|)
block|,
comment|/* 123 */
name|R
argument_list|(
name|cdbcr
argument_list|)
block|,
name|R
argument_list|(
name|tsr
argument_list|)
block|,
name|R
argument_list|(
name|tcr
argument_list|)
block|,
name|R
argument_list|(
name|pit
argument_list|)
block|,
comment|/* 127 */
name|R
argument_list|(
name|tbhi
argument_list|)
block|,
name|R
argument_list|(
name|tblo
argument_list|)
block|,
name|R
argument_list|(
name|srr2
argument_list|)
block|,
name|R
argument_list|(
name|srr3
argument_list|)
block|,
comment|/* 131 */
name|R
argument_list|(
name|dbsr
argument_list|)
block|,
name|R
argument_list|(
name|dbcr
argument_list|)
block|,
name|R
argument_list|(
name|iac1
argument_list|)
block|,
name|R
argument_list|(
name|iac2
argument_list|)
block|,
comment|/* 135 */
name|R
argument_list|(
name|dac1
argument_list|)
block|,
name|R
argument_list|(
name|dac2
argument_list|)
block|,
name|R
argument_list|(
name|dccr
argument_list|)
block|,
name|R
argument_list|(
name|iccr
argument_list|)
block|,
comment|/* 139 */
name|R
argument_list|(
name|pbl1
argument_list|)
block|,
name|R
argument_list|(
name|pbu1
argument_list|)
block|,
name|R
argument_list|(
name|pbl2
argument_list|)
block|,
name|R
argument_list|(
argument|pbu2
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* IBM PowerPC 403GC.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg
name|registers_403GC
index|[]
init|=
block|{
name|COMMON_UISA_REGS
block|,
name|PPC_UISA_SPRS
block|,
name|PPC_SEGMENT_REGS
block|,
name|PPC_OEA_SPRS
block|,
comment|/* 119 */
name|R
argument_list|(
name|icdbdr
argument_list|)
block|,
name|R
argument_list|(
name|esr
argument_list|)
block|,
name|R
argument_list|(
name|dear
argument_list|)
block|,
name|R
argument_list|(
name|evpr
argument_list|)
block|,
comment|/* 123 */
name|R
argument_list|(
name|cdbcr
argument_list|)
block|,
name|R
argument_list|(
name|tsr
argument_list|)
block|,
name|R
argument_list|(
name|tcr
argument_list|)
block|,
name|R
argument_list|(
name|pit
argument_list|)
block|,
comment|/* 127 */
name|R
argument_list|(
name|tbhi
argument_list|)
block|,
name|R
argument_list|(
name|tblo
argument_list|)
block|,
name|R
argument_list|(
name|srr2
argument_list|)
block|,
name|R
argument_list|(
name|srr3
argument_list|)
block|,
comment|/* 131 */
name|R
argument_list|(
name|dbsr
argument_list|)
block|,
name|R
argument_list|(
name|dbcr
argument_list|)
block|,
name|R
argument_list|(
name|iac1
argument_list|)
block|,
name|R
argument_list|(
name|iac2
argument_list|)
block|,
comment|/* 135 */
name|R
argument_list|(
name|dac1
argument_list|)
block|,
name|R
argument_list|(
name|dac2
argument_list|)
block|,
name|R
argument_list|(
name|dccr
argument_list|)
block|,
name|R
argument_list|(
name|iccr
argument_list|)
block|,
comment|/* 139 */
name|R
argument_list|(
name|pbl1
argument_list|)
block|,
name|R
argument_list|(
name|pbu1
argument_list|)
block|,
name|R
argument_list|(
name|pbl2
argument_list|)
block|,
name|R
argument_list|(
name|pbu2
argument_list|)
block|,
comment|/* 143 */
name|R
argument_list|(
name|zpr
argument_list|)
block|,
name|R
argument_list|(
name|pid
argument_list|)
block|,
name|R
argument_list|(
name|sgr
argument_list|)
block|,
name|R
argument_list|(
name|dcwr
argument_list|)
block|,
comment|/* 147 */
name|R
argument_list|(
name|tbhu
argument_list|)
block|,
name|R
argument_list|(
argument|tblu
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Motorola PowerPC 505.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg
name|registers_505
index|[]
init|=
block|{
name|COMMON_UISA_REGS
block|,
name|PPC_UISA_SPRS
block|,
name|PPC_SEGMENT_REGS
block|,
name|PPC_OEA_SPRS
block|,
comment|/* 119 */
name|R
argument_list|(
name|eie
argument_list|)
block|,
name|R
argument_list|(
name|eid
argument_list|)
block|,
name|R
argument_list|(
argument|nri
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Motorola PowerPC 860 or 850.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg
name|registers_860
index|[]
init|=
block|{
name|COMMON_UISA_REGS
block|,
name|PPC_UISA_SPRS
block|,
name|PPC_SEGMENT_REGS
block|,
name|PPC_OEA_SPRS
block|,
comment|/* 119 */
name|R
argument_list|(
name|eie
argument_list|)
block|,
name|R
argument_list|(
name|eid
argument_list|)
block|,
name|R
argument_list|(
name|nri
argument_list|)
block|,
name|R
argument_list|(
name|cmpa
argument_list|)
block|,
comment|/* 123 */
name|R
argument_list|(
name|cmpb
argument_list|)
block|,
name|R
argument_list|(
name|cmpc
argument_list|)
block|,
name|R
argument_list|(
name|cmpd
argument_list|)
block|,
name|R
argument_list|(
name|icr
argument_list|)
block|,
comment|/* 127 */
name|R
argument_list|(
name|der
argument_list|)
block|,
name|R
argument_list|(
name|counta
argument_list|)
block|,
name|R
argument_list|(
name|countb
argument_list|)
block|,
name|R
argument_list|(
name|cmpe
argument_list|)
block|,
comment|/* 131 */
name|R
argument_list|(
name|cmpf
argument_list|)
block|,
name|R
argument_list|(
name|cmpg
argument_list|)
block|,
name|R
argument_list|(
name|cmph
argument_list|)
block|,
name|R
argument_list|(
name|lctrl1
argument_list|)
block|,
comment|/* 135 */
name|R
argument_list|(
name|lctrl2
argument_list|)
block|,
name|R
argument_list|(
name|ictrl
argument_list|)
block|,
name|R
argument_list|(
name|bar
argument_list|)
block|,
name|R
argument_list|(
name|ic_cst
argument_list|)
block|,
comment|/* 139 */
name|R
argument_list|(
name|ic_adr
argument_list|)
block|,
name|R
argument_list|(
name|ic_dat
argument_list|)
block|,
name|R
argument_list|(
name|dc_cst
argument_list|)
block|,
name|R
argument_list|(
name|dc_adr
argument_list|)
block|,
comment|/* 143 */
name|R
argument_list|(
name|dc_dat
argument_list|)
block|,
name|R
argument_list|(
name|dpdr
argument_list|)
block|,
name|R
argument_list|(
name|dpir
argument_list|)
block|,
name|R
argument_list|(
name|immr
argument_list|)
block|,
comment|/* 147 */
name|R
argument_list|(
name|mi_ctr
argument_list|)
block|,
name|R
argument_list|(
name|mi_ap
argument_list|)
block|,
name|R
argument_list|(
name|mi_epn
argument_list|)
block|,
name|R
argument_list|(
name|mi_twc
argument_list|)
block|,
comment|/* 151 */
name|R
argument_list|(
name|mi_rpn
argument_list|)
block|,
name|R
argument_list|(
name|md_ctr
argument_list|)
block|,
name|R
argument_list|(
name|m_casid
argument_list|)
block|,
name|R
argument_list|(
name|md_ap
argument_list|)
block|,
comment|/* 155 */
name|R
argument_list|(
name|md_epn
argument_list|)
block|,
name|R
argument_list|(
name|md_twb
argument_list|)
block|,
name|R
argument_list|(
name|md_twc
argument_list|)
block|,
name|R
argument_list|(
name|md_rpn
argument_list|)
block|,
comment|/* 159 */
name|R
argument_list|(
name|m_tw
argument_list|)
block|,
name|R
argument_list|(
name|mi_dbcam
argument_list|)
block|,
name|R
argument_list|(
name|mi_dbram0
argument_list|)
block|,
name|R
argument_list|(
name|mi_dbram1
argument_list|)
block|,
comment|/* 163 */
name|R
argument_list|(
name|md_dbcam
argument_list|)
block|,
name|R
argument_list|(
name|md_dbram0
argument_list|)
block|,
name|R
argument_list|(
argument|md_dbram1
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Motorola PowerPC 601.  Note that the 601 has different register numbers    for reading and writing RTCU and RTCL.  However, how one reads and writes a    register is the stub's problem.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg
name|registers_601
index|[]
init|=
block|{
name|COMMON_UISA_REGS
block|,
name|PPC_UISA_SPRS
block|,
name|PPC_SEGMENT_REGS
block|,
name|PPC_OEA_SPRS
block|,
comment|/* 119 */
name|R
argument_list|(
name|hid0
argument_list|)
block|,
name|R
argument_list|(
name|hid1
argument_list|)
block|,
name|R
argument_list|(
name|iabr
argument_list|)
block|,
name|R
argument_list|(
name|dabr
argument_list|)
block|,
comment|/* 123 */
name|R
argument_list|(
name|pir
argument_list|)
block|,
name|R
argument_list|(
name|mq
argument_list|)
block|,
name|R
argument_list|(
name|rtcu
argument_list|)
block|,
name|R
argument_list|(
argument|rtcl
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Motorola PowerPC 602.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg
name|registers_602
index|[]
init|=
block|{
name|COMMON_UISA_REGS
block|,
name|PPC_UISA_SPRS
block|,
name|PPC_SEGMENT_REGS
block|,
name|PPC_OEA_SPRS
block|,
comment|/* 119 */
name|R
argument_list|(
name|hid0
argument_list|)
block|,
name|R
argument_list|(
name|hid1
argument_list|)
block|,
name|R
argument_list|(
name|iabr
argument_list|)
block|,
name|R0
block|,
comment|/* 123 */
name|R0
block|,
name|R
argument_list|(
name|tcr
argument_list|)
block|,
name|R
argument_list|(
name|ibr
argument_list|)
block|,
name|R
argument_list|(
name|esassr
argument_list|)
block|,
comment|/* 127 */
name|R
argument_list|(
name|sebr
argument_list|)
block|,
name|R
argument_list|(
name|ser
argument_list|)
block|,
name|R
argument_list|(
name|sp
argument_list|)
block|,
name|R
argument_list|(
argument|lt
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Motorola/IBM PowerPC 603 or 603e.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg
name|registers_603
index|[]
init|=
block|{
name|COMMON_UISA_REGS
block|,
name|PPC_UISA_SPRS
block|,
name|PPC_SEGMENT_REGS
block|,
name|PPC_OEA_SPRS
block|,
comment|/* 119 */
name|R
argument_list|(
name|hid0
argument_list|)
block|,
name|R
argument_list|(
name|hid1
argument_list|)
block|,
name|R
argument_list|(
name|iabr
argument_list|)
block|,
name|R0
block|,
comment|/* 123 */
name|R0
block|,
name|R
argument_list|(
name|dmiss
argument_list|)
block|,
name|R
argument_list|(
name|dcmp
argument_list|)
block|,
name|R
argument_list|(
name|hash1
argument_list|)
block|,
comment|/* 127 */
name|R
argument_list|(
name|hash2
argument_list|)
block|,
name|R
argument_list|(
name|imiss
argument_list|)
block|,
name|R
argument_list|(
name|icmp
argument_list|)
block|,
name|R
argument_list|(
argument|rpa
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Motorola PowerPC 604 or 604e.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg
name|registers_604
index|[]
init|=
block|{
name|COMMON_UISA_REGS
block|,
name|PPC_UISA_SPRS
block|,
name|PPC_SEGMENT_REGS
block|,
name|PPC_OEA_SPRS
block|,
comment|/* 119 */
name|R
argument_list|(
name|hid0
argument_list|)
block|,
name|R
argument_list|(
name|hid1
argument_list|)
block|,
name|R
argument_list|(
name|iabr
argument_list|)
block|,
name|R
argument_list|(
name|dabr
argument_list|)
block|,
comment|/* 123 */
name|R
argument_list|(
name|pir
argument_list|)
block|,
name|R
argument_list|(
name|mmcr0
argument_list|)
block|,
name|R
argument_list|(
name|pmc1
argument_list|)
block|,
name|R
argument_list|(
name|pmc2
argument_list|)
block|,
comment|/* 127 */
name|R
argument_list|(
name|sia
argument_list|)
block|,
name|R
argument_list|(
argument|sda
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Motorola/IBM PowerPC 750 or 740.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg
name|registers_750
index|[]
init|=
block|{
name|COMMON_UISA_REGS
block|,
name|PPC_UISA_SPRS
block|,
name|PPC_SEGMENT_REGS
block|,
name|PPC_OEA_SPRS
block|,
comment|/* 119 */
name|R
argument_list|(
name|hid0
argument_list|)
block|,
name|R
argument_list|(
name|hid1
argument_list|)
block|,
name|R
argument_list|(
name|iabr
argument_list|)
block|,
name|R
argument_list|(
name|dabr
argument_list|)
block|,
comment|/* 123 */
name|R0
block|,
name|R
argument_list|(
name|ummcr0
argument_list|)
block|,
name|R
argument_list|(
name|upmc1
argument_list|)
block|,
name|R
argument_list|(
name|upmc2
argument_list|)
block|,
comment|/* 127 */
name|R
argument_list|(
name|usia
argument_list|)
block|,
name|R
argument_list|(
name|ummcr1
argument_list|)
block|,
name|R
argument_list|(
name|upmc3
argument_list|)
block|,
name|R
argument_list|(
name|upmc4
argument_list|)
block|,
comment|/* 131 */
name|R
argument_list|(
name|mmcr0
argument_list|)
block|,
name|R
argument_list|(
name|pmc1
argument_list|)
block|,
name|R
argument_list|(
name|pmc2
argument_list|)
block|,
name|R
argument_list|(
name|sia
argument_list|)
block|,
comment|/* 135 */
name|R
argument_list|(
name|mmcr1
argument_list|)
block|,
name|R
argument_list|(
name|pmc3
argument_list|)
block|,
name|R
argument_list|(
name|pmc4
argument_list|)
block|,
name|R
argument_list|(
name|l2cr
argument_list|)
block|,
comment|/* 139 */
name|R
argument_list|(
name|ictc
argument_list|)
block|,
name|R
argument_list|(
name|thrm1
argument_list|)
block|,
name|R
argument_list|(
name|thrm2
argument_list|)
block|,
name|R
argument_list|(
argument|thrm3
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Motorola PowerPC 7400.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg
name|registers_7400
index|[]
init|=
block|{
comment|/* gpr0-gpr31, fpr0-fpr31 */
name|COMMON_UISA_REGS
block|,
comment|/* ctr, xre, lr, cr */
name|PPC_UISA_SPRS
block|,
comment|/* sr0-sr15 */
name|PPC_SEGMENT_REGS
block|,
name|PPC_OEA_SPRS
block|,
comment|/* vr0-vr31, vrsave, vscr */
name|PPC_ALTIVEC_REGS
comment|/* FIXME? Add more registers? */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Motorola e500.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|reg
name|registers_e500
index|[]
init|=
block|{
name|R
argument_list|(
name|pc
argument_list|)
block|,
name|R
argument_list|(
name|ps
argument_list|)
block|,
comment|/* cr, lr, ctr, xer, "" */
name|PPC_UISA_NOFP_SPRS
block|,
comment|/* 7...38 */
name|PPC_EV_REGS
block|,
name|R8
argument_list|(
name|acc
argument_list|)
block|,
name|R
argument_list|(
name|spefscr
argument_list|)
block|,
comment|/* NOTE: Add new registers here the end of the raw register      list and just before the first pseudo register.  */
comment|/* 39...70 */
name|PPC_GPRS_PSEUDO_REGS
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Information about a particular processor variant.  */
end_comment

begin_struct
struct|struct
name|variant
block|{
comment|/* Name of this variant.  */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* English description of the variant.  */
name|char
modifier|*
name|description
decl_stmt|;
comment|/* bfd_arch_info.arch corresponding to variant.  */
name|enum
name|bfd_architecture
name|arch
decl_stmt|;
comment|/* bfd_arch_info.mach corresponding to variant.  */
name|unsigned
name|long
name|mach
decl_stmt|;
comment|/* Number of real registers.  */
name|int
name|nregs
decl_stmt|;
comment|/* Number of pseudo registers.  */
name|int
name|npregs
decl_stmt|;
comment|/* Number of total registers (the sum of nregs and npregs).  */
name|int
name|num_tot_regs
decl_stmt|;
comment|/* Table of register names; registers[R] is the name of the register        number R.  */
specifier|const
name|struct
name|reg
modifier|*
name|regs
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|tot_num_registers
parameter_list|(
name|list
parameter_list|)
value|(sizeof (list) / sizeof((list)[0]))
end_define

begin_function
specifier|static
name|int
name|num_registers
parameter_list|(
specifier|const
name|struct
name|reg
modifier|*
name|reg_list
parameter_list|,
name|int
name|num_tot_regs
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|nregs
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_tot_regs
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|reg_list
index|[
name|i
index|]
operator|.
name|pseudo
condition|)
name|nregs
operator|++
expr_stmt|;
return|return
name|nregs
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|num_pseudo_registers
parameter_list|(
specifier|const
name|struct
name|reg
modifier|*
name|reg_list
parameter_list|,
name|int
name|num_tot_regs
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|npregs
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_tot_regs
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|reg_list
index|[
name|i
index|]
operator|.
name|pseudo
condition|)
name|npregs
operator|++
expr_stmt|;
return|return
name|npregs
return|;
block|}
end_function

begin_comment
comment|/* Information in this table comes from the following web sites:    IBM:       http://www.chips.ibm.com:80/products/embedded/    Motorola:  http://www.mot.com/SPS/PowerPC/     I'm sure I've got some of the variant descriptions not quite right.    Please report any inaccuracies you find to GDB's maintainer.     If you add entries to this table, please be sure to allow the new    value as an argument to the --with-cpu flag, in configure.in.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|variant
name|variants
index|[]
init|=
block|{
block|{
literal|"powerpc"
block|,
literal|"PowerPC user-level"
block|,
name|bfd_arch_powerpc
block|,
name|bfd_mach_ppc
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|tot_num_registers
argument_list|(
name|registers_powerpc
argument_list|)
block|,
name|registers_powerpc
block|}
block|,
block|{
literal|"power"
block|,
literal|"POWER user-level"
block|,
name|bfd_arch_rs6000
block|,
name|bfd_mach_rs6k
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|tot_num_registers
argument_list|(
name|registers_power
argument_list|)
block|,
name|registers_power
block|}
block|,
block|{
literal|"403"
block|,
literal|"IBM PowerPC 403"
block|,
name|bfd_arch_powerpc
block|,
name|bfd_mach_ppc_403
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|tot_num_registers
argument_list|(
name|registers_403
argument_list|)
block|,
name|registers_403
block|}
block|,
block|{
literal|"601"
block|,
literal|"Motorola PowerPC 601"
block|,
name|bfd_arch_powerpc
block|,
name|bfd_mach_ppc_601
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|tot_num_registers
argument_list|(
name|registers_601
argument_list|)
block|,
name|registers_601
block|}
block|,
block|{
literal|"602"
block|,
literal|"Motorola PowerPC 602"
block|,
name|bfd_arch_powerpc
block|,
name|bfd_mach_ppc_602
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|tot_num_registers
argument_list|(
name|registers_602
argument_list|)
block|,
name|registers_602
block|}
block|,
block|{
literal|"603"
block|,
literal|"Motorola/IBM PowerPC 603 or 603e"
block|,
name|bfd_arch_powerpc
block|,
name|bfd_mach_ppc_603
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|tot_num_registers
argument_list|(
name|registers_603
argument_list|)
block|,
name|registers_603
block|}
block|,
block|{
literal|"604"
block|,
literal|"Motorola PowerPC 604 or 604e"
block|,
name|bfd_arch_powerpc
block|,
literal|604
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|tot_num_registers
argument_list|(
name|registers_604
argument_list|)
block|,
name|registers_604
block|}
block|,
block|{
literal|"403GC"
block|,
literal|"IBM PowerPC 403GC"
block|,
name|bfd_arch_powerpc
block|,
name|bfd_mach_ppc_403gc
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|tot_num_registers
argument_list|(
name|registers_403GC
argument_list|)
block|,
name|registers_403GC
block|}
block|,
block|{
literal|"505"
block|,
literal|"Motorola PowerPC 505"
block|,
name|bfd_arch_powerpc
block|,
name|bfd_mach_ppc_505
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|tot_num_registers
argument_list|(
name|registers_505
argument_list|)
block|,
name|registers_505
block|}
block|,
block|{
literal|"860"
block|,
literal|"Motorola PowerPC 860 or 850"
block|,
name|bfd_arch_powerpc
block|,
name|bfd_mach_ppc_860
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|tot_num_registers
argument_list|(
name|registers_860
argument_list|)
block|,
name|registers_860
block|}
block|,
block|{
literal|"750"
block|,
literal|"Motorola/IBM PowerPC 750 or 740"
block|,
name|bfd_arch_powerpc
block|,
name|bfd_mach_ppc_750
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|tot_num_registers
argument_list|(
name|registers_750
argument_list|)
block|,
name|registers_750
block|}
block|,
block|{
literal|"7400"
block|,
literal|"Motorola/IBM PowerPC 7400 (G4)"
block|,
name|bfd_arch_powerpc
block|,
name|bfd_mach_ppc_7400
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|tot_num_registers
argument_list|(
name|registers_7400
argument_list|)
block|,
name|registers_7400
block|}
block|,
block|{
literal|"e500"
block|,
literal|"Motorola PowerPC e500"
block|,
name|bfd_arch_powerpc
block|,
name|bfd_mach_ppc_e500
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|tot_num_registers
argument_list|(
name|registers_e500
argument_list|)
block|,
name|registers_e500
block|}
block|,
comment|/* 64-bit */
block|{
literal|"powerpc64"
block|,
literal|"PowerPC 64-bit user-level"
block|,
name|bfd_arch_powerpc
block|,
name|bfd_mach_ppc64
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|tot_num_registers
argument_list|(
name|registers_powerpc
argument_list|)
block|,
name|registers_powerpc
block|}
block|,
block|{
literal|"620"
block|,
literal|"Motorola PowerPC 620"
block|,
name|bfd_arch_powerpc
block|,
name|bfd_mach_ppc_620
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|tot_num_registers
argument_list|(
name|registers_powerpc
argument_list|)
block|,
name|registers_powerpc
block|}
block|,
block|{
literal|"630"
block|,
literal|"Motorola PowerPC 630"
block|,
name|bfd_arch_powerpc
block|,
name|bfd_mach_ppc_630
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|tot_num_registers
argument_list|(
name|registers_powerpc
argument_list|)
block|,
name|registers_powerpc
block|}
block|,
block|{
literal|"a35"
block|,
literal|"PowerPC A35"
block|,
name|bfd_arch_powerpc
block|,
name|bfd_mach_ppc_a35
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|tot_num_registers
argument_list|(
name|registers_powerpc
argument_list|)
block|,
name|registers_powerpc
block|}
block|,
block|{
literal|"rs64ii"
block|,
literal|"PowerPC rs64ii"
block|,
name|bfd_arch_powerpc
block|,
name|bfd_mach_ppc_rs64ii
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|tot_num_registers
argument_list|(
name|registers_powerpc
argument_list|)
block|,
name|registers_powerpc
block|}
block|,
block|{
literal|"rs64iii"
block|,
literal|"PowerPC rs64iii"
block|,
name|bfd_arch_powerpc
block|,
name|bfd_mach_ppc_rs64iii
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|tot_num_registers
argument_list|(
name|registers_powerpc
argument_list|)
block|,
name|registers_powerpc
block|}
block|,
comment|/* FIXME: I haven't checked the register sets of the following.  */
block|{
literal|"rs1"
block|,
literal|"IBM POWER RS1"
block|,
name|bfd_arch_rs6000
block|,
name|bfd_mach_rs6k_rs1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|tot_num_registers
argument_list|(
name|registers_power
argument_list|)
block|,
name|registers_power
block|}
block|,
block|{
literal|"rsc"
block|,
literal|"IBM POWER RSC"
block|,
name|bfd_arch_rs6000
block|,
name|bfd_mach_rs6k_rsc
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|tot_num_registers
argument_list|(
name|registers_power
argument_list|)
block|,
name|registers_power
block|}
block|,
block|{
literal|"rs2"
block|,
literal|"IBM POWER RS2"
block|,
name|bfd_arch_rs6000
block|,
name|bfd_mach_rs6k_rs2
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|tot_num_registers
argument_list|(
name|registers_power
argument_list|)
block|,
name|registers_power
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize the number of registers and pseudo registers in each variant.  */
end_comment

begin_function
specifier|static
name|void
name|init_variants
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|variant
modifier|*
name|v
decl_stmt|;
for|for
control|(
name|v
operator|=
name|variants
init|;
name|v
operator|->
name|name
condition|;
name|v
operator|++
control|)
block|{
if|if
condition|(
name|v
operator|->
name|nregs
operator|==
operator|-
literal|1
condition|)
name|v
operator|->
name|nregs
operator|=
name|num_registers
argument_list|(
name|v
operator|->
name|regs
argument_list|,
name|v
operator|->
name|num_tot_regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|npregs
operator|==
operator|-
literal|1
condition|)
name|v
operator|->
name|npregs
operator|=
name|num_pseudo_registers
argument_list|(
name|v
operator|->
name|regs
argument_list|,
name|v
operator|->
name|num_tot_regs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the variant corresponding to architecture ARCH and machine number    MACH.  If no such variant exists, return null.  */
end_comment

begin_function
specifier|static
specifier|const
name|struct
name|variant
modifier|*
name|find_variant_by_arch
parameter_list|(
name|enum
name|bfd_architecture
name|arch
parameter_list|,
name|unsigned
name|long
name|mach
parameter_list|)
block|{
specifier|const
name|struct
name|variant
modifier|*
name|v
decl_stmt|;
for|for
control|(
name|v
operator|=
name|variants
init|;
name|v
operator|->
name|name
condition|;
name|v
operator|++
control|)
if|if
condition|(
name|arch
operator|==
name|v
operator|->
name|arch
operator|&&
name|mach
operator|==
name|v
operator|->
name|mach
condition|)
return|return
name|v
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gdb_print_insn_powerpc
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|)
return|return
name|print_insn_big_powerpc
argument_list|(
name|memaddr
argument_list|,
name|info
argument_list|)
return|;
else|else
return|return
name|print_insn_little_powerpc
argument_list|(
name|memaddr
argument_list|,
name|info
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize the current architecture based on INFO.  If possible, re-use an    architecture from ARCHES, which is a list of architectures already created    during this debugging session.     Called e.g. at program startup, when reading a core file, and when reading    a binary file.  */
end_comment

begin_function
specifier|static
name|struct
name|gdbarch
modifier|*
name|rs6000_gdbarch_init
parameter_list|(
name|struct
name|gdbarch_info
name|info
parameter_list|,
name|struct
name|gdbarch_list
modifier|*
name|arches
parameter_list|)
block|{
name|struct
name|gdbarch
modifier|*
name|gdbarch
decl_stmt|;
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
decl_stmt|;
name|int
name|wordsize
decl_stmt|,
name|from_xcoff_exec
decl_stmt|,
name|from_elf_exec
decl_stmt|,
name|power
decl_stmt|,
name|i
decl_stmt|,
name|off
decl_stmt|;
name|struct
name|reg
modifier|*
name|regs
decl_stmt|;
specifier|const
name|struct
name|variant
modifier|*
name|v
decl_stmt|;
name|enum
name|bfd_architecture
name|arch
decl_stmt|;
name|unsigned
name|long
name|mach
decl_stmt|;
name|bfd
name|abfd
decl_stmt|;
name|int
name|sysv_abi
decl_stmt|;
name|asection
modifier|*
name|sect
decl_stmt|;
name|from_xcoff_exec
operator|=
name|info
operator|.
name|abfd
operator|&&
name|info
operator|.
name|abfd
operator|->
name|format
operator|==
name|bfd_object
operator|&&
name|bfd_get_flavour
argument_list|(
name|info
operator|.
name|abfd
argument_list|)
operator|==
name|bfd_target_xcoff_flavour
expr_stmt|;
name|from_elf_exec
operator|=
name|info
operator|.
name|abfd
operator|&&
name|info
operator|.
name|abfd
operator|->
name|format
operator|==
name|bfd_object
operator|&&
name|bfd_get_flavour
argument_list|(
name|info
operator|.
name|abfd
argument_list|)
operator|==
name|bfd_target_elf_flavour
expr_stmt|;
name|sysv_abi
operator|=
name|info
operator|.
name|abfd
operator|&&
name|bfd_get_flavour
argument_list|(
name|info
operator|.
name|abfd
argument_list|)
operator|==
name|bfd_target_elf_flavour
expr_stmt|;
comment|/* Check word size.  If INFO is from a binary file, infer it from      that, else choose a likely default.  */
if|if
condition|(
name|from_xcoff_exec
condition|)
block|{
if|if
condition|(
name|bfd_xcoff_is_xcoff64
argument_list|(
name|info
operator|.
name|abfd
argument_list|)
condition|)
name|wordsize
operator|=
literal|8
expr_stmt|;
else|else
name|wordsize
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|from_elf_exec
condition|)
block|{
if|if
condition|(
name|elf_elfheader
argument_list|(
name|info
operator|.
name|abfd
argument_list|)
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
operator|==
name|ELFCLASS64
condition|)
name|wordsize
operator|=
literal|8
expr_stmt|;
else|else
name|wordsize
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|info
operator|.
name|bfd_arch_info
operator|!=
name|NULL
operator|&&
name|info
operator|.
name|bfd_arch_info
operator|->
name|bits_per_word
operator|!=
literal|0
condition|)
name|wordsize
operator|=
name|info
operator|.
name|bfd_arch_info
operator|->
name|bits_per_word
operator|/
name|info
operator|.
name|bfd_arch_info
operator|->
name|bits_per_byte
expr_stmt|;
else|else
name|wordsize
operator|=
literal|4
expr_stmt|;
block|}
comment|/* Find a candidate among extant architectures.  */
for|for
control|(
name|arches
operator|=
name|gdbarch_list_lookup_by_info
argument_list|(
name|arches
argument_list|,
operator|&
name|info
argument_list|)
init|;
name|arches
operator|!=
name|NULL
condition|;
name|arches
operator|=
name|gdbarch_list_lookup_by_info
argument_list|(
name|arches
operator|->
name|next
argument_list|,
operator|&
name|info
argument_list|)
control|)
block|{
comment|/* Word size in the various PowerPC bfd_arch_info structs isn't          meaningful, because 64-bit CPUs can run in 32-bit mode.  So, perform          separate word size check.  */
name|tdep
operator|=
name|gdbarch_tdep
argument_list|(
name|arches
operator|->
name|gdbarch
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdep
operator|&&
name|tdep
operator|->
name|wordsize
operator|==
name|wordsize
condition|)
return|return
name|arches
operator|->
name|gdbarch
return|;
block|}
comment|/* None found, create a new architecture from INFO, whose bfd_arch_info      validity depends on the source:        - executable		useless        - rs6000_host_arch()	good        - core file		good        - "set arch"		trust blindly        - GDB startup		useless but harmless */
if|if
condition|(
operator|!
name|from_xcoff_exec
condition|)
block|{
name|arch
operator|=
name|info
operator|.
name|bfd_arch_info
operator|->
name|arch
expr_stmt|;
name|mach
operator|=
name|info
operator|.
name|bfd_arch_info
operator|->
name|mach
expr_stmt|;
block|}
else|else
block|{
name|arch
operator|=
name|bfd_arch_powerpc
expr_stmt|;
name|bfd_default_set_arch_mach
argument_list|(
operator|&
name|abfd
argument_list|,
name|arch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|info
operator|.
name|bfd_arch_info
operator|=
name|bfd_get_arch_info
argument_list|(
operator|&
name|abfd
argument_list|)
expr_stmt|;
name|mach
operator|=
name|info
operator|.
name|bfd_arch_info
operator|->
name|mach
expr_stmt|;
block|}
name|tdep
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|gdbarch_tdep
argument_list|)
argument_list|)
expr_stmt|;
name|tdep
operator|->
name|wordsize
operator|=
name|wordsize
expr_stmt|;
comment|/* For e500 executables, the apuinfo section is of help here.  Such      section contains the identifier and revision number of each      Application-specific Processing Unit that is present on the      chip.  The content of the section is determined by the assembler      which looks at each instruction and determines which unit (and      which version of it) can execute it. In our case we just look for      the existance of the section.  */
if|if
condition|(
name|info
operator|.
name|abfd
condition|)
block|{
name|sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|info
operator|.
name|abfd
argument_list|,
literal|".PPC.EMB.apuinfo"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sect
condition|)
block|{
name|arch
operator|=
name|info
operator|.
name|bfd_arch_info
operator|->
name|arch
expr_stmt|;
name|mach
operator|=
name|bfd_mach_ppc_e500
expr_stmt|;
name|bfd_default_set_arch_mach
argument_list|(
operator|&
name|abfd
argument_list|,
name|arch
argument_list|,
name|mach
argument_list|)
expr_stmt|;
name|info
operator|.
name|bfd_arch_info
operator|=
name|bfd_get_arch_info
argument_list|(
operator|&
name|abfd
argument_list|)
expr_stmt|;
block|}
block|}
name|gdbarch
operator|=
name|gdbarch_alloc
argument_list|(
operator|&
name|info
argument_list|,
name|tdep
argument_list|)
expr_stmt|;
name|power
operator|=
name|arch
operator|==
name|bfd_arch_rs6000
expr_stmt|;
comment|/* Initialize the number of real and pseudo registers in each variant.  */
name|init_variants
argument_list|()
expr_stmt|;
comment|/* Choose variant.  */
name|v
operator|=
name|find_variant_by_arch
argument_list|(
name|arch
argument_list|,
name|mach
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|v
condition|)
return|return
name|NULL
return|;
name|tdep
operator|->
name|regs
operator|=
name|v
operator|->
name|regs
expr_stmt|;
name|tdep
operator|->
name|ppc_gp0_regnum
operator|=
literal|0
expr_stmt|;
name|tdep
operator|->
name|ppc_gplast_regnum
operator|=
literal|31
expr_stmt|;
name|tdep
operator|->
name|ppc_toc_regnum
operator|=
literal|2
expr_stmt|;
name|tdep
operator|->
name|ppc_ps_regnum
operator|=
literal|65
expr_stmt|;
name|tdep
operator|->
name|ppc_cr_regnum
operator|=
literal|66
expr_stmt|;
name|tdep
operator|->
name|ppc_lr_regnum
operator|=
literal|67
expr_stmt|;
name|tdep
operator|->
name|ppc_ctr_regnum
operator|=
literal|68
expr_stmt|;
name|tdep
operator|->
name|ppc_xer_regnum
operator|=
literal|69
expr_stmt|;
if|if
condition|(
name|v
operator|->
name|mach
operator|==
name|bfd_mach_ppc_601
condition|)
name|tdep
operator|->
name|ppc_mq_regnum
operator|=
literal|124
expr_stmt|;
elseif|else
if|if
condition|(
name|power
condition|)
name|tdep
operator|->
name|ppc_mq_regnum
operator|=
literal|70
expr_stmt|;
else|else
name|tdep
operator|->
name|ppc_mq_regnum
operator|=
operator|-
literal|1
expr_stmt|;
name|tdep
operator|->
name|ppc_fpscr_regnum
operator|=
name|power
condition|?
literal|71
else|:
literal|70
expr_stmt|;
name|set_gdbarch_pc_regnum
argument_list|(
name|gdbarch
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|set_gdbarch_sp_regnum
argument_list|(
name|gdbarch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_gdbarch_deprecated_fp_regnum
argument_list|(
name|gdbarch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysv_abi
operator|&&
name|wordsize
operator|==
literal|8
condition|)
name|set_gdbarch_return_value
argument_list|(
name|gdbarch
argument_list|,
name|ppc64_sysv_abi_return_value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sysv_abi
operator|&&
name|wordsize
operator|==
literal|4
condition|)
name|set_gdbarch_return_value
argument_list|(
name|gdbarch
argument_list|,
name|ppc_sysv_abi_return_value
argument_list|)
expr_stmt|;
else|else
block|{
name|set_gdbarch_deprecated_extract_return_value
argument_list|(
name|gdbarch
argument_list|,
name|rs6000_extract_return_value
argument_list|)
expr_stmt|;
name|set_gdbarch_deprecated_store_return_value
argument_list|(
name|gdbarch
argument_list|,
name|rs6000_store_return_value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|v
operator|->
name|arch
operator|==
name|bfd_arch_powerpc
condition|)
switch|switch
condition|(
name|v
operator|->
name|mach
condition|)
block|{
case|case
name|bfd_mach_ppc
case|:
name|tdep
operator|->
name|ppc_vr0_regnum
operator|=
literal|71
expr_stmt|;
name|tdep
operator|->
name|ppc_vrsave_regnum
operator|=
literal|104
expr_stmt|;
name|tdep
operator|->
name|ppc_ev0_regnum
operator|=
operator|-
literal|1
expr_stmt|;
name|tdep
operator|->
name|ppc_ev31_regnum
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|bfd_mach_ppc_7400
case|:
name|tdep
operator|->
name|ppc_vr0_regnum
operator|=
literal|119
expr_stmt|;
name|tdep
operator|->
name|ppc_vrsave_regnum
operator|=
literal|152
expr_stmt|;
name|tdep
operator|->
name|ppc_ev0_regnum
operator|=
operator|-
literal|1
expr_stmt|;
name|tdep
operator|->
name|ppc_ev31_regnum
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|bfd_mach_ppc_e500
case|:
name|tdep
operator|->
name|ppc_gp0_regnum
operator|=
literal|41
expr_stmt|;
name|tdep
operator|->
name|ppc_gplast_regnum
operator|=
name|tdep
operator|->
name|ppc_gp0_regnum
operator|+
literal|32
operator|-
literal|1
expr_stmt|;
name|tdep
operator|->
name|ppc_toc_regnum
operator|=
operator|-
literal|1
expr_stmt|;
name|tdep
operator|->
name|ppc_ps_regnum
operator|=
literal|1
expr_stmt|;
name|tdep
operator|->
name|ppc_cr_regnum
operator|=
literal|2
expr_stmt|;
name|tdep
operator|->
name|ppc_lr_regnum
operator|=
literal|3
expr_stmt|;
name|tdep
operator|->
name|ppc_ctr_regnum
operator|=
literal|4
expr_stmt|;
name|tdep
operator|->
name|ppc_xer_regnum
operator|=
literal|5
expr_stmt|;
name|tdep
operator|->
name|ppc_ev0_regnum
operator|=
literal|7
expr_stmt|;
name|tdep
operator|->
name|ppc_ev31_regnum
operator|=
literal|38
expr_stmt|;
name|set_gdbarch_pc_regnum
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_gdbarch_sp_regnum
argument_list|(
name|gdbarch
argument_list|,
name|tdep
operator|->
name|ppc_gp0_regnum
operator|+
literal|1
argument_list|)
expr_stmt|;
name|set_gdbarch_deprecated_fp_regnum
argument_list|(
name|gdbarch
argument_list|,
name|tdep
operator|->
name|ppc_gp0_regnum
operator|+
literal|1
argument_list|)
expr_stmt|;
name|set_gdbarch_dwarf2_reg_to_regnum
argument_list|(
name|gdbarch
argument_list|,
name|e500_dwarf2_reg_to_regnum
argument_list|)
expr_stmt|;
name|set_gdbarch_pseudo_register_read
argument_list|(
name|gdbarch
argument_list|,
name|e500_pseudo_register_read
argument_list|)
expr_stmt|;
name|set_gdbarch_pseudo_register_write
argument_list|(
name|gdbarch
argument_list|,
name|e500_pseudo_register_write
argument_list|)
expr_stmt|;
break|break;
default|default:
name|tdep
operator|->
name|ppc_vr0_regnum
operator|=
operator|-
literal|1
expr_stmt|;
name|tdep
operator|->
name|ppc_vrsave_regnum
operator|=
operator|-
literal|1
expr_stmt|;
name|tdep
operator|->
name|ppc_ev0_regnum
operator|=
operator|-
literal|1
expr_stmt|;
name|tdep
operator|->
name|ppc_ev31_regnum
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Sanity check on registers.  */
name|gdb_assert
argument_list|(
name|strcmp
argument_list|(
name|tdep
operator|->
name|regs
index|[
name|tdep
operator|->
name|ppc_gp0_regnum
index|]
operator|.
name|name
argument_list|,
literal|"r0"
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Set lr_frame_offset.  */
if|if
condition|(
name|wordsize
operator|==
literal|8
condition|)
name|tdep
operator|->
name|lr_frame_offset
operator|=
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
name|sysv_abi
condition|)
name|tdep
operator|->
name|lr_frame_offset
operator|=
literal|4
expr_stmt|;
else|else
name|tdep
operator|->
name|lr_frame_offset
operator|=
literal|8
expr_stmt|;
comment|/* Calculate byte offsets in raw register array.  */
name|tdep
operator|->
name|regoff
operator|=
name|xmalloc
argument_list|(
name|v
operator|->
name|num_tot_regs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|off
operator|=
literal|0
init|;
name|i
operator|<
name|v
operator|->
name|num_tot_regs
condition|;
name|i
operator|++
control|)
block|{
name|tdep
operator|->
name|regoff
index|[
name|i
index|]
operator|=
name|off
expr_stmt|;
name|off
operator|+=
name|regsize
argument_list|(
name|v
operator|->
name|regs
operator|+
name|i
argument_list|,
name|wordsize
argument_list|)
expr_stmt|;
block|}
comment|/* Select instruction printer.  */
if|if
condition|(
name|arch
operator|==
name|power
condition|)
name|set_gdbarch_print_insn
argument_list|(
name|gdbarch
argument_list|,
name|print_insn_rs6000
argument_list|)
expr_stmt|;
else|else
name|set_gdbarch_print_insn
argument_list|(
name|gdbarch
argument_list|,
name|gdb_print_insn_powerpc
argument_list|)
expr_stmt|;
name|set_gdbarch_write_pc
argument_list|(
name|gdbarch
argument_list|,
name|generic_target_write_pc
argument_list|)
expr_stmt|;
name|set_gdbarch_num_regs
argument_list|(
name|gdbarch
argument_list|,
name|v
operator|->
name|nregs
argument_list|)
expr_stmt|;
name|set_gdbarch_num_pseudo_regs
argument_list|(
name|gdbarch
argument_list|,
name|v
operator|->
name|npregs
argument_list|)
expr_stmt|;
name|set_gdbarch_register_name
argument_list|(
name|gdbarch
argument_list|,
name|rs6000_register_name
argument_list|)
expr_stmt|;
name|set_gdbarch_deprecated_register_size
argument_list|(
name|gdbarch
argument_list|,
name|wordsize
argument_list|)
expr_stmt|;
name|set_gdbarch_deprecated_register_bytes
argument_list|(
name|gdbarch
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|set_gdbarch_deprecated_register_byte
argument_list|(
name|gdbarch
argument_list|,
name|rs6000_register_byte
argument_list|)
expr_stmt|;
name|set_gdbarch_deprecated_register_raw_size
argument_list|(
name|gdbarch
argument_list|,
name|rs6000_register_raw_size
argument_list|)
expr_stmt|;
name|set_gdbarch_deprecated_register_virtual_type
argument_list|(
name|gdbarch
argument_list|,
name|rs6000_register_virtual_type
argument_list|)
expr_stmt|;
name|set_gdbarch_ptr_bit
argument_list|(
name|gdbarch
argument_list|,
name|wordsize
operator|*
name|TARGET_CHAR_BIT
argument_list|)
expr_stmt|;
name|set_gdbarch_short_bit
argument_list|(
name|gdbarch
argument_list|,
literal|2
operator|*
name|TARGET_CHAR_BIT
argument_list|)
expr_stmt|;
name|set_gdbarch_int_bit
argument_list|(
name|gdbarch
argument_list|,
literal|4
operator|*
name|TARGET_CHAR_BIT
argument_list|)
expr_stmt|;
name|set_gdbarch_long_bit
argument_list|(
name|gdbarch
argument_list|,
name|wordsize
operator|*
name|TARGET_CHAR_BIT
argument_list|)
expr_stmt|;
name|set_gdbarch_long_long_bit
argument_list|(
name|gdbarch
argument_list|,
literal|8
operator|*
name|TARGET_CHAR_BIT
argument_list|)
expr_stmt|;
name|set_gdbarch_float_bit
argument_list|(
name|gdbarch
argument_list|,
literal|4
operator|*
name|TARGET_CHAR_BIT
argument_list|)
expr_stmt|;
name|set_gdbarch_double_bit
argument_list|(
name|gdbarch
argument_list|,
literal|8
operator|*
name|TARGET_CHAR_BIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysv_abi
condition|)
name|set_gdbarch_long_double_bit
argument_list|(
name|gdbarch
argument_list|,
literal|16
operator|*
name|TARGET_CHAR_BIT
argument_list|)
expr_stmt|;
else|else
name|set_gdbarch_long_double_bit
argument_list|(
name|gdbarch
argument_list|,
literal|8
operator|*
name|TARGET_CHAR_BIT
argument_list|)
expr_stmt|;
name|set_gdbarch_char_signed
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_align
argument_list|(
name|gdbarch
argument_list|,
name|rs6000_frame_align
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysv_abi
operator|&&
name|wordsize
operator|==
literal|8
condition|)
comment|/* PPC64 SYSV.  */
name|set_gdbarch_frame_red_zone_size
argument_list|(
name|gdbarch
argument_list|,
literal|288
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|sysv_abi
operator|&&
name|wordsize
operator|==
literal|4
condition|)
comment|/* PowerOpen / AIX 32 bit.  The saved area or red zone consists of        19 4 byte GPRS + 18 8 byte FPRs giving a total of 220 bytes.        Problem is, 220 isn't frame (16 byte) aligned.  Round it up to        224.  */
name|set_gdbarch_frame_red_zone_size
argument_list|(
name|gdbarch
argument_list|,
literal|224
argument_list|)
expr_stmt|;
name|set_gdbarch_deprecated_save_dummy_frame_tos
argument_list|(
name|gdbarch
argument_list|,
name|generic_save_dummy_frame_tos
argument_list|)
expr_stmt|;
name|set_gdbarch_believe_pcc_promotion
argument_list|(
name|gdbarch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_gdbarch_deprecated_register_convertible
argument_list|(
name|gdbarch
argument_list|,
name|rs6000_register_convertible
argument_list|)
expr_stmt|;
name|set_gdbarch_deprecated_register_convert_to_virtual
argument_list|(
name|gdbarch
argument_list|,
name|rs6000_register_convert_to_virtual
argument_list|)
expr_stmt|;
name|set_gdbarch_deprecated_register_convert_to_raw
argument_list|(
name|gdbarch
argument_list|,
name|rs6000_register_convert_to_raw
argument_list|)
expr_stmt|;
name|set_gdbarch_stab_reg_to_regnum
argument_list|(
name|gdbarch
argument_list|,
name|rs6000_stab_reg_to_regnum
argument_list|)
expr_stmt|;
comment|/* Note: kevinb/2002-04-12: I'm not convinced that rs6000_push_arguments()      is correct for the SysV ABI when the wordsize is 8, but I'm also      fairly certain that ppc_sysv_abi_push_arguments() will give even      worse results since it only works for 32-bit code.  So, for the moment,      we're better off calling rs6000_push_arguments() since it works for      64-bit code.  At some point in the future, this matter needs to be      revisited.  */
if|if
condition|(
name|sysv_abi
operator|&&
name|wordsize
operator|==
literal|4
condition|)
name|set_gdbarch_push_dummy_call
argument_list|(
name|gdbarch
argument_list|,
name|ppc_sysv_abi_push_dummy_call
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|sysv_abi
operator|&&
name|wordsize
operator|==
literal|8
condition|)
name|set_gdbarch_push_dummy_call
argument_list|(
name|gdbarch
argument_list|,
name|ppc64_sysv_abi_push_dummy_call
argument_list|)
expr_stmt|;
else|else
name|set_gdbarch_push_dummy_call
argument_list|(
name|gdbarch
argument_list|,
name|rs6000_push_dummy_call
argument_list|)
expr_stmt|;
name|set_gdbarch_deprecated_extract_struct_value_address
argument_list|(
name|gdbarch
argument_list|,
name|rs6000_extract_struct_value_address
argument_list|)
expr_stmt|;
name|set_gdbarch_deprecated_pop_frame
argument_list|(
name|gdbarch
argument_list|,
name|rs6000_pop_frame
argument_list|)
expr_stmt|;
name|set_gdbarch_skip_prologue
argument_list|(
name|gdbarch
argument_list|,
name|rs6000_skip_prologue
argument_list|)
expr_stmt|;
name|set_gdbarch_inner_than
argument_list|(
name|gdbarch
argument_list|,
name|core_addr_lessthan
argument_list|)
expr_stmt|;
name|set_gdbarch_breakpoint_from_pc
argument_list|(
name|gdbarch
argument_list|,
name|rs6000_breakpoint_from_pc
argument_list|)
expr_stmt|;
comment|/* Handle the 64-bit SVR4 minimal-symbol convention of using "FN"      for the descriptor and ".FN" for the entry-point -- a user      specifying "break FN" will unexpectedly end up with a breakpoint      on the descriptor and not the function.  This architecture method      transforms any breakpoints on descriptors into breakpoints on the      corresponding entry point.  */
if|if
condition|(
name|sysv_abi
operator|&&
name|wordsize
operator|==
literal|8
condition|)
name|set_gdbarch_adjust_breakpoint_address
argument_list|(
name|gdbarch
argument_list|,
name|ppc64_sysv_abi_adjust_breakpoint_address
argument_list|)
expr_stmt|;
comment|/* Not sure on this. FIXMEmgo */
name|set_gdbarch_frame_args_skip
argument_list|(
name|gdbarch
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sysv_abi
condition|)
name|set_gdbarch_use_struct_convention
argument_list|(
name|gdbarch
argument_list|,
name|rs6000_use_struct_convention
argument_list|)
expr_stmt|;
name|set_gdbarch_deprecated_frameless_function_invocation
argument_list|(
name|gdbarch
argument_list|,
name|rs6000_frameless_function_invocation
argument_list|)
expr_stmt|;
name|set_gdbarch_deprecated_frame_chain
argument_list|(
name|gdbarch
argument_list|,
name|rs6000_frame_chain
argument_list|)
expr_stmt|;
name|set_gdbarch_deprecated_frame_saved_pc
argument_list|(
name|gdbarch
argument_list|,
name|rs6000_frame_saved_pc
argument_list|)
expr_stmt|;
name|set_gdbarch_deprecated_frame_init_saved_regs
argument_list|(
name|gdbarch
argument_list|,
name|rs6000_frame_init_saved_regs
argument_list|)
expr_stmt|;
name|set_gdbarch_deprecated_init_extra_frame_info
argument_list|(
name|gdbarch
argument_list|,
name|rs6000_init_extra_frame_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sysv_abi
condition|)
block|{
comment|/* Handle RS/6000 function pointers (which are really function          descriptors).  */
name|set_gdbarch_convert_from_func_ptr_addr
argument_list|(
name|gdbarch
argument_list|,
name|rs6000_convert_from_func_ptr_addr
argument_list|)
expr_stmt|;
block|}
name|set_gdbarch_deprecated_frame_args_address
argument_list|(
name|gdbarch
argument_list|,
name|rs6000_frame_args_address
argument_list|)
expr_stmt|;
name|set_gdbarch_deprecated_frame_locals_address
argument_list|(
name|gdbarch
argument_list|,
name|rs6000_frame_args_address
argument_list|)
expr_stmt|;
name|set_gdbarch_deprecated_saved_pc_after_call
argument_list|(
name|gdbarch
argument_list|,
name|rs6000_saved_pc_after_call
argument_list|)
expr_stmt|;
comment|/* Helpers for function argument information.  */
name|set_gdbarch_fetch_pointer_argument
argument_list|(
name|gdbarch
argument_list|,
name|rs6000_fetch_pointer_argument
argument_list|)
expr_stmt|;
comment|/* Hook in ABI-specific overrides, if they have been registered.  */
name|gdbarch_init_osabi
argument_list|(
name|info
argument_list|,
name|gdbarch
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_xcoff_exec
condition|)
block|{
comment|/* NOTE: jimix/2003-06-09: This test should really check for 	 GDB_OSABI_AIX when that is defined and becomes 	 available. (Actually, once things are properly split apart, 	 the test goes away.) */
comment|/* RS6000/AIX does not support PT_STEP.  Has to be simulated.  */
name|set_gdbarch_software_single_step
argument_list|(
name|gdbarch
argument_list|,
name|rs6000_software_single_step
argument_list|)
expr_stmt|;
block|}
return|return
name|gdbarch
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rs6000_dump_tdep
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|current_gdbarch
parameter_list|,
name|struct
name|ui_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
if|if
condition|(
name|tdep
operator|==
name|NULL
condition|)
return|return;
comment|/* FIXME: Dump gdbarch_tdep.  */
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|cmd_list_element
modifier|*
name|info_powerpc_cmdlist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|rs6000_info_powerpc_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|help_list
argument_list|(
name|info_powerpc_cmdlist
argument_list|,
literal|"info powerpc "
argument_list|,
name|class_info
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialization code.  */
end_comment

begin_decl_stmt
specifier|extern
name|initialize_file_ftype
name|_initialize_rs6000_tdep
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -Wmissing-prototypes */
end_comment

begin_function
name|void
name|_initialize_rs6000_tdep
parameter_list|(
name|void
parameter_list|)
block|{
name|gdbarch_register
argument_list|(
name|bfd_arch_rs6000
argument_list|,
name|rs6000_gdbarch_init
argument_list|,
name|rs6000_dump_tdep
argument_list|)
expr_stmt|;
name|gdbarch_register
argument_list|(
name|bfd_arch_powerpc
argument_list|,
name|rs6000_gdbarch_init
argument_list|,
name|rs6000_dump_tdep
argument_list|)
expr_stmt|;
comment|/* Add root prefix command for "info powerpc" commands */
name|add_prefix_cmd
argument_list|(
literal|"powerpc"
argument_list|,
name|class_info
argument_list|,
name|rs6000_info_powerpc_command
argument_list|,
literal|"Various POWERPC info specific commands."
argument_list|,
operator|&
name|info_powerpc_cmdlist
argument_list|,
literal|"info powerpc "
argument_list|,
literal|0
argument_list|,
operator|&
name|infolist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

