begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Common target dependent code for GDB on ARM systems.    Copyright 1988, 1989, 1991, 1992, 1993, 1995, 1996, 1998, 1999, 2000,    2001, 2002, 2003, 2004 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/* XXX for isupper () */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_comment
comment|/* For register styles. */
end_comment

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"doublest.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"arch-utils.h"
end_include

begin_include
include|#
directive|include
file|"osabi.h"
end_include

begin_include
include|#
directive|include
file|"frame-unwind.h"
end_include

begin_include
include|#
directive|include
file|"frame-base.h"
end_include

begin_include
include|#
directive|include
file|"trad-frame.h"
end_include

begin_include
include|#
directive|include
file|"arm-tdep.h"
end_include

begin_include
include|#
directive|include
file|"gdb/sim-arm.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"elf/arm.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|arm_debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Each OS has a different mechanism for accessing the various    registers stored in the sigcontext structure.     SIGCONTEXT_REGISTER_ADDRESS should be defined to the name (or    function pointer) which may be used to determine the addresses    of the various saved registers in the sigcontext structure.     For the ARM target, there are three parameters to this function.     The first is the pc value of the frame under consideration, the    second the stack pointer of this frame, and the last is the    register number to fetch.       If the tm.h file does not define this macro, then it's assumed that    no mechanism is needed and we define SIGCONTEXT_REGISTER_ADDRESS to    be 0.         When it comes time to multi-arching this code, see the identically    named machinery in ia64-tdep.c for an example of how it could be    done.  It should not be necessary to modify the code below where    this macro is used.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SIGCONTEXT_REGISTER_ADDRESS
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|SIGCONTEXT_REGISTER_ADDRESS_P
end_ifndef

begin_define
define|#
directive|define
name|SIGCONTEXT_REGISTER_ADDRESS_P
parameter_list|()
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SIGCONTEXT_REGISTER_ADDRESS
parameter_list|(
name|SP
parameter_list|,
name|PC
parameter_list|,
name|REG
parameter_list|)
value|0
end_define

begin_define
define|#
directive|define
name|SIGCONTEXT_REGISTER_ADDRESS_P
parameter_list|()
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Macros for setting and testing a bit in a minimal symbol that marks    it as Thumb function.  The MSB of the minimal symbol's "info" field    is used for this purpose.     MSYMBOL_SET_SPECIAL	Actually sets the "special" bit.    MSYMBOL_IS_SPECIAL   Tests the "special" bit in a minimal symbol.  */
end_comment

begin_define
define|#
directive|define
name|MSYMBOL_SET_SPECIAL
parameter_list|(
name|msym
parameter_list|)
define|\
value|MSYMBOL_INFO (msym) = (char *) (((long) MSYMBOL_INFO (msym))	\ 					| 0x80000000)
end_define

begin_define
define|#
directive|define
name|MSYMBOL_IS_SPECIAL
parameter_list|(
name|msym
parameter_list|)
define|\
value|(((long) MSYMBOL_INFO (msym)& 0x80000000) != 0)
end_define

begin_comment
comment|/* The list of available "set arm ..." and "show arm ..." commands.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cmd_list_element
modifier|*
name|setarmcmdlist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cmd_list_element
modifier|*
name|showarmcmdlist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The type of floating-point to use.  Keep this in sync with enum    arm_float_model, and the help string in _initialize_arm_tdep.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|fp_model_strings
index|[]
init|=
block|{
literal|"auto"
block|,
literal|"softfpa"
block|,
literal|"fpa"
block|,
literal|"softvfp"
block|,
literal|"vfp"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A variable that can be configured by the user.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|arm_float_model
name|arm_fp_model
init|=
name|ARM_FLOAT_AUTO
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|current_fp_model
init|=
literal|"auto"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of different reg name sets (options).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_disassembly_options
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We have more registers than the disassembler as gdb can print the value    of special registers as well.    The general register names are overwritten by whatever is being used by    the disassembler at the moment. We also adjust the case of cpsr and fps.  */
end_comment

begin_comment
comment|/* Initial value: Register names used in ARM's ISA documentation.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|arm_register_name_strings
index|[]
init|=
block|{
literal|"r0"
block|,
literal|"r1"
block|,
literal|"r2"
block|,
literal|"r3"
block|,
comment|/*  0  1  2  3 */
literal|"r4"
block|,
literal|"r5"
block|,
literal|"r6"
block|,
literal|"r7"
block|,
comment|/*  4  5  6  7 */
literal|"r8"
block|,
literal|"r9"
block|,
literal|"r10"
block|,
literal|"r11"
block|,
comment|/*  8  9 10 11 */
literal|"r12"
block|,
literal|"sp"
block|,
literal|"lr"
block|,
literal|"pc"
block|,
comment|/* 12 13 14 15 */
literal|"f0"
block|,
literal|"f1"
block|,
literal|"f2"
block|,
literal|"f3"
block|,
comment|/* 16 17 18 19 */
literal|"f4"
block|,
literal|"f5"
block|,
literal|"f6"
block|,
literal|"f7"
block|,
comment|/* 20 21 22 23 */
literal|"fps"
block|,
literal|"cpsr"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 24 25       */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|arm_register_names
init|=
name|arm_register_name_strings
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Valid register name styles.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|valid_disassembly_styles
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Disassembly style to use. Default to "std" register names.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|disassembly_style
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index to that option in the opcodes table.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|current_option
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is used to keep the bfd arch_info in sync with the disassembly    style.  */
end_comment

begin_function_decl
specifier|static
name|void
name|set_disassembly_style_sfunc
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_disassembly_style
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|convert_from_extended
parameter_list|(
specifier|const
name|struct
name|floatformat
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|convert_to_extended
parameter_list|(
specifier|const
name|struct
name|floatformat
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|arm_prologue_cache
block|{
comment|/* The stack pointer at the time this frame was created; i.e. the      caller's stack pointer when this function was called.  It is used      to identify this frame.  */
name|CORE_ADDR
name|prev_sp
decl_stmt|;
comment|/* The frame base for this frame is just prev_sp + frame offset -      frame size.  FRAMESIZE is the size of this stack frame, and      FRAMEOFFSET if the initial offset from the stack pointer (this      frame's stack pointer, not PREV_SP) to the frame base.  */
name|int
name|framesize
decl_stmt|;
name|int
name|frameoffset
decl_stmt|;
comment|/* The register used to hold the frame pointer for this frame.  */
name|int
name|framereg
decl_stmt|;
comment|/* Saved register offsets.  */
name|struct
name|trad_frame_saved_reg
modifier|*
name|saved_regs
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Addresses for calling Thumb functions have the bit 0 set.    Here are some macros to test, set, or clear bit 0 of addresses.  */
end_comment

begin_define
define|#
directive|define
name|IS_THUMB_ADDR
parameter_list|(
name|addr
parameter_list|)
value|((addr)& 1)
end_define

begin_define
define|#
directive|define
name|MAKE_THUMB_ADDR
parameter_list|(
name|addr
parameter_list|)
value|((addr) | 1)
end_define

begin_define
define|#
directive|define
name|UNMAKE_THUMB_ADDR
parameter_list|(
name|addr
parameter_list|)
value|((addr)& ~1)
end_define

begin_comment
comment|/* Set to true if the 32-bit mode is in use.  */
end_comment

begin_decl_stmt
name|int
name|arm_apcs_32
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Determine if the program counter specified in MEMADDR is in a Thumb    function.  */
end_comment

begin_function
name|int
name|arm_pc_is_thumb
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|sym
decl_stmt|;
comment|/* If bit 0 of the address is set, assume this is a Thumb address.  */
if|if
condition|(
name|IS_THUMB_ADDR
argument_list|(
name|memaddr
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Thumb functions have a "special" bit set in minimal symbols.  */
name|sym
operator|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|memaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
return|return
operator|(
name|MSYMBOL_IS_SPECIAL
argument_list|(
name|sym
argument_list|)
operator|)
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Remove useless bits from addresses in a running program.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|arm_addr_bits_remove
parameter_list|(
name|CORE_ADDR
name|val
parameter_list|)
block|{
if|if
condition|(
name|arm_apcs_32
condition|)
return|return
operator|(
name|val
operator|&
operator|(
name|arm_pc_is_thumb
argument_list|(
name|val
argument_list|)
condition|?
literal|0xfffffffe
else|:
literal|0xfffffffc
operator|)
operator|)
return|;
else|else
return|return
operator|(
name|val
operator|&
literal|0x03fffffc
operator|)
return|;
block|}
end_function

begin_comment
comment|/* When reading symbols, we need to zap the low bit of the address,    which may be set to 1 for Thumb functions.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|arm_smash_text_address
parameter_list|(
name|CORE_ADDR
name|val
parameter_list|)
block|{
return|return
name|val
operator|&
operator|~
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Immediately after a function call, return the saved pc.  Can't    always go through the frames for this because on some machines the    new frame is not set up until the new function executes some    instructions.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|arm_saved_pc_after_call
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
return|return
name|ADDR_BITS_REMOVE
argument_list|(
name|read_register
argument_list|(
name|ARM_LR_REGNUM
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Determine whether the function invocation represented by FI has a    frame on the stack associated with it.  If it does return zero,    otherwise return 1.  */
end_comment

begin_function
specifier|static
name|int
name|arm_frameless_function_invocation
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
name|CORE_ADDR
name|func_start
decl_stmt|,
name|after_prologue
decl_stmt|;
name|int
name|frameless
decl_stmt|;
comment|/* Sometimes we have functions that do a little setup (like saving the      vN registers with the stmdb instruction, but DO NOT set up a frame.      The symbol table will report this as a prologue.  However, it is      important not to try to parse these partial frames as frames, or we      will get really confused.       So I will demand 3 instructions between the start& end of the      prologue before I call it a real prologue, i.e. at least 	mov ip, sp, 	stmdb sp!, {} 	sub sp, ip, #4.  */
name|func_start
operator|=
operator|(
name|get_frame_func
argument_list|(
name|fi
argument_list|)
operator|+
name|FUNCTION_START_OFFSET
operator|)
expr_stmt|;
name|after_prologue
operator|=
name|SKIP_PROLOGUE
argument_list|(
name|func_start
argument_list|)
expr_stmt|;
comment|/* There are some frameless functions whose first two instructions      follow the standard APCS form, in which case after_prologue will      be func_start + 8.  */
name|frameless
operator|=
operator|(
name|after_prologue
operator|<
name|func_start
operator|+
literal|12
operator|)
expr_stmt|;
return|return
name|frameless
return|;
block|}
end_function

begin_comment
comment|/* A typical Thumb prologue looks like this:    push    {r7, lr}    add     sp, sp, #-28    add     r7, sp, #12    Sometimes the latter instruction may be replaced by:    mov     r7, sp        or like this:    push    {r7, lr}    mov     r7, sp    sub	   sp, #12        or, on tpcs, like this:    sub     sp,#16    push    {r7, lr}    (many instructions)    mov     r7, sp    sub	   sp, #12     There is always one instruction of three classes:    1 - push    2 - setting of r7    3 - adjusting of sp        When we have found at least one of each class we are done with the prolog.    Note that the "sub sp, #NN" before the push does not count.    */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|thumb_skip_prologue
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
name|func_end
parameter_list|)
block|{
name|CORE_ADDR
name|current_pc
decl_stmt|;
comment|/* findmask:      bit 0 - push { rlist }      bit 1 - mov r7, sp  OR  add r7, sp, #imm  (setting of r7)      bit 2 - sub sp, #simm  OR  add sp, #simm  (adjusting of sp)   */
name|int
name|findmask
init|=
literal|0
decl_stmt|;
for|for
control|(
name|current_pc
operator|=
name|pc
init|;
name|current_pc
operator|+
literal|2
operator|<
name|func_end
operator|&&
name|current_pc
operator|<
name|pc
operator|+
literal|40
condition|;
name|current_pc
operator|+=
literal|2
control|)
block|{
name|unsigned
name|short
name|insn
init|=
name|read_memory_unsigned_integer
argument_list|(
name|current_pc
argument_list|,
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xfe00
operator|)
operator|==
literal|0xb400
condition|)
comment|/* push { rlist } */
block|{
name|findmask
operator||=
literal|1
expr_stmt|;
comment|/* push found */
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xff00
operator|)
operator|==
literal|0xb000
condition|)
comment|/* add sp, #simm  OR   						   sub sp, #simm */
block|{
if|if
condition|(
operator|(
name|findmask
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
comment|/* before push ? */
continue|continue;
else|else
name|findmask
operator||=
literal|4
expr_stmt|;
comment|/* add/sub sp found */
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xff00
operator|)
operator|==
literal|0xaf00
condition|)
comment|/* add r7, sp, #imm */
block|{
name|findmask
operator||=
literal|2
expr_stmt|;
comment|/* setting of r7 found */
block|}
elseif|else
if|if
condition|(
name|insn
operator|==
literal|0x466f
condition|)
comment|/* mov r7, sp */
block|{
name|findmask
operator||=
literal|2
expr_stmt|;
comment|/* setting of r7 found */
block|}
elseif|else
if|if
condition|(
name|findmask
operator|==
operator|(
literal|4
operator|+
literal|2
operator|+
literal|1
operator|)
condition|)
block|{
comment|/* We have found one of each type of prologue instruction */
break|break;
block|}
else|else
comment|/* Something in the prolog that we don't care about or some 	   instruction from outside the prolog scheduled here for 	   optimization.  */
continue|continue;
block|}
return|return
name|current_pc
return|;
block|}
end_function

begin_comment
comment|/* Advance the PC across any function entry prologue instructions to    reach some "real" code.     The APCS (ARM Procedure Call Standard) defines the following    prologue:     mov          ip, sp    [stmfd       sp!, {a1,a2,a3,a4}]    stmfd        sp!, {...,fp,ip,lr,pc}    [stfe        f7, [sp, #-12]!]    [stfe        f6, [sp, #-12]!]    [stfe        f5, [sp, #-12]!]    [stfe        f4, [sp, #-12]!]    sub fp, ip, #nn @@ nn == 20 or 4 depending on second insn */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|arm_skip_prologue
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|unsigned
name|long
name|inst
decl_stmt|;
name|CORE_ADDR
name|skip_pc
decl_stmt|;
name|CORE_ADDR
name|func_addr
decl_stmt|,
name|func_end
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|func_name
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
comment|/* If we're in a dummy frame, don't even try to skip the prologue.  */
if|if
condition|(
name|DEPRECATED_PC_IN_CALL_DUMMY
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|pc
return|;
comment|/* See what the symbol table says.  */
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
operator|&
name|func_name
argument_list|,
operator|&
name|func_addr
argument_list|,
operator|&
name|func_end
argument_list|)
condition|)
block|{
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
comment|/* Found a function.  */
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|func_name
argument_list|,
name|NULL
argument_list|,
name|VAR_DOMAIN
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|&&
name|SYMBOL_LANGUAGE
argument_list|(
name|sym
argument_list|)
operator|!=
name|language_asm
condition|)
block|{
comment|/* Don't use this trick for assembly source files.  */
name|sal
operator|=
name|find_pc_line
argument_list|(
name|func_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sal
operator|.
name|line
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|sal
operator|.
name|end
operator|<
name|func_end
operator|)
condition|)
return|return
name|sal
operator|.
name|end
return|;
block|}
block|}
comment|/* Check if this is Thumb code.  */
if|if
condition|(
name|arm_pc_is_thumb
argument_list|(
name|pc
argument_list|)
condition|)
return|return
name|thumb_skip_prologue
argument_list|(
name|pc
argument_list|,
name|func_end
argument_list|)
return|;
comment|/* Can't find the prologue end in the symbol table, try it the hard way      by disassembling the instructions.  */
comment|/* Like arm_scan_prologue, stop no later than pc + 64. */
if|if
condition|(
name|func_end
operator|==
literal|0
operator|||
name|func_end
operator|>
name|pc
operator|+
literal|64
condition|)
name|func_end
operator|=
name|pc
operator|+
literal|64
expr_stmt|;
for|for
control|(
name|skip_pc
operator|=
name|pc
init|;
name|skip_pc
operator|<
name|func_end
condition|;
name|skip_pc
operator|+=
literal|4
control|)
block|{
name|inst
operator|=
name|read_memory_integer
argument_list|(
name|skip_pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* "mov ip, sp" is no longer a required part of the prologue.  */
if|if
condition|(
name|inst
operator|==
literal|0xe1a0c00d
condition|)
comment|/* mov ip, sp */
continue|continue;
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xfffff000
operator|)
operator|==
literal|0xe28dc000
condition|)
comment|/* add ip, sp #n */
continue|continue;
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xfffff000
operator|)
operator|==
literal|0xe24dc000
condition|)
comment|/* sub ip, sp #n */
continue|continue;
comment|/* Some prologues begin with "str lr, [sp, #-4]!".  */
if|if
condition|(
name|inst
operator|==
literal|0xe52de004
condition|)
comment|/* str lr, [sp, #-4]! */
continue|continue;
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xfffffff0
operator|)
operator|==
literal|0xe92d0000
condition|)
comment|/* stmfd sp!,{a1,a2,a3,a4} */
continue|continue;
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xfffff800
operator|)
operator|==
literal|0xe92dd800
condition|)
comment|/* stmfd sp!,{fp,ip,lr,pc} */
continue|continue;
comment|/* Any insns after this point may float into the code, if it makes 	 for better instruction scheduling, so we skip them only if we 	 find them, but still consider the function to be frame-ful.  */
comment|/* We may have either one sfmfd instruction here, or several stfe 	 insns, depending on the version of floating point code we 	 support.  */
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xffbf0fff
operator|)
operator|==
literal|0xec2d0200
condition|)
comment|/* sfmfd fn,<cnt>, [sp]! */
continue|continue;
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xffff8fff
operator|)
operator|==
literal|0xed6d0103
condition|)
comment|/* stfe fn, [sp, #-12]! */
continue|continue;
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xfffff000
operator|)
operator|==
literal|0xe24cb000
condition|)
comment|/* sub fp, ip, #nn */
continue|continue;
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xfffff000
operator|)
operator|==
literal|0xe24dd000
condition|)
comment|/* sub sp, sp, #nn */
continue|continue;
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xffffc000
operator|)
operator|==
literal|0xe54b0000
operator|||
comment|/* strb r(0123),[r11,#-nn] */
operator|(
name|inst
operator|&
literal|0xffffc0f0
operator|)
operator|==
literal|0xe14b00b0
operator|||
comment|/* strh r(0123),[r11,#-nn] */
operator|(
name|inst
operator|&
literal|0xffffc000
operator|)
operator|==
literal|0xe50b0000
condition|)
comment|/* str  r(0123),[r11,#-nn] */
continue|continue;
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xffffc000
operator|)
operator|==
literal|0xe5cd0000
operator|||
comment|/* strb r(0123),[sp,#nn] */
operator|(
name|inst
operator|&
literal|0xffffc0f0
operator|)
operator|==
literal|0xe1cd00b0
operator|||
comment|/* strh r(0123),[sp,#nn] */
operator|(
name|inst
operator|&
literal|0xffffc000
operator|)
operator|==
literal|0xe58d0000
condition|)
comment|/* str  r(0123),[sp,#nn] */
continue|continue;
comment|/* Un-recognized instruction; stop scanning.  */
break|break;
block|}
return|return
name|skip_pc
return|;
comment|/* End of prologue */
block|}
end_function

begin_comment
comment|/* *INDENT-OFF* */
end_comment

begin_comment
comment|/* Function: thumb_scan_prologue (helper function for arm_scan_prologue)    This function decodes a Thumb function prologue to determine:      1) the size of the stack frame      2) which registers are saved on it      3) the offsets of saved regs      4) the offset from the stack pointer to the frame pointer     A typical Thumb function prologue would create this stack frame    (offsets relative to FP)      old SP ->	24  stack parameters 		20  LR 		16  R7      R7 ->       0  local variables (16 bytes)      SP ->     -12  additional stack space (12 bytes)    The frame size would thus be 36 bytes, and the frame offset would be    12 bytes.  The frame register is R7.         The comments for thumb_skip_prolog() describe the algorithm we use    to detect the end of the prolog.  */
end_comment

begin_comment
comment|/* *INDENT-ON* */
end_comment

begin_function
specifier|static
name|void
name|thumb_scan_prologue
parameter_list|(
name|CORE_ADDR
name|prev_pc
parameter_list|,
name|struct
name|arm_prologue_cache
modifier|*
name|cache
parameter_list|)
block|{
name|CORE_ADDR
name|prologue_start
decl_stmt|;
name|CORE_ADDR
name|prologue_end
decl_stmt|;
name|CORE_ADDR
name|current_pc
decl_stmt|;
comment|/* Which register has been copied to register n?  */
name|int
name|saved_reg
index|[
literal|16
index|]
decl_stmt|;
comment|/* findmask:      bit 0 - push { rlist }      bit 1 - mov r7, sp  OR  add r7, sp, #imm  (setting of r7)      bit 2 - sub sp, #simm  OR  add sp, #simm  (adjusting of sp)   */
name|int
name|findmask
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|prev_pc
argument_list|,
name|NULL
argument_list|,
operator|&
name|prologue_start
argument_list|,
operator|&
name|prologue_end
argument_list|)
condition|)
block|{
name|struct
name|symtab_and_line
name|sal
init|=
name|find_pc_line
argument_list|(
name|prologue_start
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|sal
operator|.
name|line
operator|==
literal|0
condition|)
comment|/* no line info, use current PC  */
name|prologue_end
operator|=
name|prev_pc
expr_stmt|;
elseif|else
if|if
condition|(
name|sal
operator|.
name|end
operator|<
name|prologue_end
condition|)
comment|/* next line begins after fn end */
name|prologue_end
operator|=
name|sal
operator|.
name|end
expr_stmt|;
comment|/* (probably means no prologue)  */
block|}
else|else
comment|/* We're in the boondocks: allow for         16 pushes, an add, and "mv fp,sp".  */
name|prologue_end
operator|=
name|prologue_start
operator|+
literal|40
expr_stmt|;
name|prologue_end
operator|=
name|min
argument_list|(
name|prologue_end
argument_list|,
name|prev_pc
argument_list|)
expr_stmt|;
comment|/* Initialize the saved register map.  When register H is copied to      register L, we will put H in saved_reg[L].  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|saved_reg
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
comment|/* Search the prologue looking for instructions that set up the      frame pointer, adjust the stack pointer, and save registers.      Do this until all basic prolog instructions are found.  */
name|cache
operator|->
name|framesize
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|current_pc
operator|=
name|prologue_start
init|;
operator|(
name|current_pc
operator|<
name|prologue_end
operator|)
operator|&&
operator|(
operator|(
name|findmask
operator|&
literal|7
operator|)
operator|!=
literal|7
operator|)
condition|;
name|current_pc
operator|+=
literal|2
control|)
block|{
name|unsigned
name|short
name|insn
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|insn
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|current_pc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xfe00
operator|)
operator|==
literal|0xb400
condition|)
comment|/* push { rlist } */
block|{
name|int
name|mask
decl_stmt|;
name|findmask
operator||=
literal|1
expr_stmt|;
comment|/* push found */
comment|/* Bits 0-7 contain a mask for registers R0-R7.  Bit 8 says 	     whether to save LR (R14).  */
name|mask
operator|=
operator|(
name|insn
operator|&
literal|0xff
operator|)
operator||
operator|(
operator|(
name|insn
operator|&
literal|0x100
operator|)
operator|<<
literal|6
operator|)
expr_stmt|;
comment|/* Calculate offsets of saved R0-R7 and LR.  */
for|for
control|(
name|regno
operator|=
name|ARM_LR_REGNUM
init|;
name|regno
operator|>=
literal|0
condition|;
name|regno
operator|--
control|)
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|regno
operator|)
condition|)
block|{
name|cache
operator|->
name|framesize
operator|+=
literal|4
expr_stmt|;
name|cache
operator|->
name|saved_regs
index|[
name|saved_reg
index|[
name|regno
index|]
index|]
operator|.
name|addr
operator|=
operator|-
name|cache
operator|->
name|framesize
expr_stmt|;
comment|/* Reset saved register map.  */
name|saved_reg
index|[
name|regno
index|]
operator|=
name|regno
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xff00
operator|)
operator|==
literal|0xb000
condition|)
comment|/* add sp, #simm  OR   						   sub sp, #simm */
block|{
if|if
condition|(
operator|(
name|findmask
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
comment|/* before push?  */
continue|continue;
else|else
name|findmask
operator||=
literal|4
expr_stmt|;
comment|/* add/sub sp found */
name|offset
operator|=
operator|(
name|insn
operator|&
literal|0x7f
operator|)
operator|<<
literal|2
expr_stmt|;
comment|/* get scaled offset */
if|if
condition|(
name|insn
operator|&
literal|0x80
condition|)
comment|/* is it signed? (==subtracting) */
block|{
name|cache
operator|->
name|frameoffset
operator|+=
name|offset
expr_stmt|;
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
block|}
name|cache
operator|->
name|framesize
operator|-=
name|offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xff00
operator|)
operator|==
literal|0xaf00
condition|)
comment|/* add r7, sp, #imm */
block|{
name|findmask
operator||=
literal|2
expr_stmt|;
comment|/* setting of r7 found */
name|cache
operator|->
name|framereg
operator|=
name|THUMB_FP_REGNUM
expr_stmt|;
comment|/* get scaled offset */
name|cache
operator|->
name|frameoffset
operator|=
operator|(
name|insn
operator|&
literal|0xff
operator|)
operator|<<
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|insn
operator|==
literal|0x466f
condition|)
comment|/* mov r7, sp */
block|{
name|findmask
operator||=
literal|2
expr_stmt|;
comment|/* setting of r7 found */
name|cache
operator|->
name|framereg
operator|=
name|THUMB_FP_REGNUM
expr_stmt|;
name|cache
operator|->
name|frameoffset
operator|=
literal|0
expr_stmt|;
name|saved_reg
index|[
name|THUMB_FP_REGNUM
index|]
operator|=
name|ARM_SP_REGNUM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xffc0
operator|)
operator|==
literal|0x4640
condition|)
comment|/* mov r0-r7, r8-r15 */
block|{
name|int
name|lo_reg
init|=
name|insn
operator|&
literal|7
decl_stmt|;
comment|/* dest.  register (r0-r7) */
name|int
name|hi_reg
init|=
operator|(
operator|(
name|insn
operator|>>
literal|3
operator|)
operator|&
literal|7
operator|)
operator|+
literal|8
decl_stmt|;
comment|/* source register (r8-15) */
name|saved_reg
index|[
name|lo_reg
index|]
operator|=
name|hi_reg
expr_stmt|;
comment|/* remember hi reg was saved */
block|}
else|else
comment|/* Something in the prolog that we don't care about or some 	   instruction from outside the prolog scheduled here for 	   optimization.  */
continue|continue;
block|}
block|}
end_function

begin_comment
comment|/* This function decodes an ARM function prologue to determine:    1) the size of the stack frame    2) which registers are saved on it    3) the offsets of saved regs    4) the offset from the stack pointer to the frame pointer    This information is stored in the "extra" fields of the frame_info.     There are two basic forms for the ARM prologue.  The fixed argument    function call will look like:     mov    ip, sp    stmfd  sp!, {fp, ip, lr, pc}    sub    fp, ip, #4    [sub sp, sp, #4]     Which would create this stack frame (offsets relative to FP):    IP ->   4    (caller's stack)    FP ->   0    PC (points to address of stmfd instruction + 8 in callee)    -4   LR (return address in caller)    -8   IP (copy of caller's SP)    -12  FP (caller's FP)    SP -> -28    Local variables     The frame size would thus be 32 bytes, and the frame offset would be    28 bytes.  The stmfd call can also save any of the vN registers it    plans to use, which increases the frame size accordingly.     Note: The stored PC is 8 off of the STMFD instruction that stored it    because the ARM Store instructions always store PC + 8 when you read    the PC register.     A variable argument function call will look like:     mov    ip, sp    stmfd  sp!, {a1, a2, a3, a4}    stmfd  sp!, {fp, ip, lr, pc}    sub    fp, ip, #20     Which would create this stack frame (offsets relative to FP):    IP ->  20    (caller's stack)    16  A4    12  A3    8  A2    4  A1    FP ->   0    PC (points to address of stmfd instruction + 8 in callee)    -4   LR (return address in caller)    -8   IP (copy of caller's SP)    -12  FP (caller's FP)    SP -> -28    Local variables     The frame size would thus be 48 bytes, and the frame offset would be    28 bytes.     There is another potential complication, which is that the optimizer    will try to separate the store of fp in the "stmfd" instruction from    the "sub fp, ip, #NN" instruction.  Almost anything can be there, so    we just key on the stmfd, and then scan for the "sub fp, ip, #NN"...     Also, note, the original version of the ARM toolchain claimed that there    should be an     instruction at the end of the prologue.  I have never seen GCC produce    this, and the ARM docs don't mention it.  We still test for it below in    case it happens...   */
end_comment

begin_function
specifier|static
name|void
name|arm_scan_prologue
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|struct
name|arm_prologue_cache
modifier|*
name|cache
parameter_list|)
block|{
name|int
name|regno
decl_stmt|,
name|sp_offset
decl_stmt|,
name|fp_offset
decl_stmt|,
name|ip_offset
decl_stmt|;
name|CORE_ADDR
name|prologue_start
decl_stmt|,
name|prologue_end
decl_stmt|,
name|current_pc
decl_stmt|;
name|CORE_ADDR
name|prev_pc
init|=
name|frame_pc_unwind
argument_list|(
name|next_frame
argument_list|)
decl_stmt|;
comment|/* Assume there is no frame until proven otherwise.  */
name|cache
operator|->
name|framereg
operator|=
name|ARM_SP_REGNUM
expr_stmt|;
name|cache
operator|->
name|framesize
operator|=
literal|0
expr_stmt|;
name|cache
operator|->
name|frameoffset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|frame_tdep_pc_fixup
condition|)
name|frame_tdep_pc_fixup
argument_list|(
operator|&
name|prev_pc
argument_list|)
expr_stmt|;
comment|/* Check for Thumb prologue.  */
if|if
condition|(
name|arm_pc_is_thumb
argument_list|(
name|prev_pc
argument_list|)
condition|)
block|{
name|thumb_scan_prologue
argument_list|(
name|prev_pc
argument_list|,
name|cache
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Find the function prologue.  If we can't find the function in      the symbol table, peek in the stack frame to find the PC.  */
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|prev_pc
argument_list|,
name|NULL
argument_list|,
operator|&
name|prologue_start
argument_list|,
operator|&
name|prologue_end
argument_list|)
condition|)
block|{
comment|/* One way to find the end of the prologue (which works well          for unoptimized code) is to do the following:  	    struct symtab_and_line sal = find_pc_line (prologue_start, 0);  	    if (sal.line == 0) 	      prologue_end = prev_pc; 	    else if (sal.end< prologue_end) 	      prologue_end = sal.end;  	 This mechanism is very accurate so long as the optimizer 	 doesn't move any instructions from the function body into the 	 prologue.  If this happens, sal.end will be the last 	 instruction in the first hunk of prologue code just before 	 the first instruction that the scheduler has moved from 	 the body to the prologue.  	 In order to make sure that we scan all of the prologue 	 instructions, we use a slightly less accurate mechanism which 	 may scan more than necessary.  To help compensate for this 	 lack of accuracy, the prologue scanning loop below contains 	 several clauses which'll cause the loop to terminate early if 	 an implausible prologue instruction is encountered.   	  	 The expression 	  	      prologue_start + 64 	     	 is a suitable endpoint since it accounts for the largest 	 possible prologue plus up to five instructions inserted by 	 the scheduler.  */
if|if
condition|(
name|prologue_end
operator|>
name|prologue_start
operator|+
literal|64
condition|)
block|{
name|prologue_end
operator|=
name|prologue_start
operator|+
literal|64
expr_stmt|;
comment|/* See above.  */
block|}
block|}
else|else
block|{
comment|/* We have no symbol information.  Our only option is to assume this 	 function has a standard stack frame and the normal frame register. 	 Then, we can find the value of our frame pointer on entrance to 	 the callee (or at the present moment if this is the innermost frame). 	 The value stored there should be the address of the stmfd + 8.  */
name|CORE_ADDR
name|frame_loc
decl_stmt|;
name|LONGEST
name|return_value
decl_stmt|;
name|frame_loc
operator|=
name|frame_unwind_register_unsigned
argument_list|(
name|next_frame
argument_list|,
name|ARM_FP_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|safe_read_memory_integer
argument_list|(
name|frame_loc
argument_list|,
literal|4
argument_list|,
operator|&
name|return_value
argument_list|)
condition|)
return|return;
else|else
block|{
name|prologue_start
operator|=
name|ADDR_BITS_REMOVE
argument_list|(
name|return_value
argument_list|)
operator|-
literal|8
expr_stmt|;
name|prologue_end
operator|=
name|prologue_start
operator|+
literal|64
expr_stmt|;
comment|/* See above.  */
block|}
block|}
if|if
condition|(
name|prev_pc
operator|<
name|prologue_end
condition|)
name|prologue_end
operator|=
name|prev_pc
expr_stmt|;
comment|/* Now search the prologue looking for instructions that set up the      frame pointer, adjust the stack pointer, and save registers.       Be careful, however, and if it doesn't look like a prologue,      don't try to scan it.  If, for instance, a frameless function      begins with stmfd sp!, then we will tell ourselves there is      a frame, which will confuse stack traceback, as well as "finish"       and other operations that rely on a knowledge of the stack      traceback.       In the APCS, the prologue should start with  "mov ip, sp" so      if we don't see this as the first insn, we will stop.         [Note: This doesn't seem to be true any longer, so it's now an      optional part of the prologue.  - Kevin Buettner, 2001-11-20]       [Note further: The "mov ip,sp" only seems to be missing in      frameless functions at optimization level "-O2" or above,      in which case it is often (but not always) replaced by      "str lr, [sp, #-4]!".  - Michael Snyder, 2002-04-23]  */
name|sp_offset
operator|=
name|fp_offset
operator|=
name|ip_offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|current_pc
operator|=
name|prologue_start
init|;
name|current_pc
operator|<
name|prologue_end
condition|;
name|current_pc
operator|+=
literal|4
control|)
block|{
name|unsigned
name|int
name|insn
init|=
name|read_memory_unsigned_integer
argument_list|(
name|current_pc
argument_list|,
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
name|insn
operator|==
literal|0xe1a0c00d
condition|)
comment|/* mov ip, sp */
block|{
name|ip_offset
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xfffff000
operator|)
operator|==
literal|0xe28dc000
condition|)
comment|/* add ip, sp #n */
block|{
name|unsigned
name|imm
init|=
name|insn
operator|&
literal|0xff
decl_stmt|;
comment|/* immediate value */
name|unsigned
name|rot
init|=
operator|(
name|insn
operator|&
literal|0xf00
operator|)
operator|>>
literal|7
decl_stmt|;
comment|/* rotate amount */
name|imm
operator|=
operator|(
name|imm
operator|>>
name|rot
operator|)
operator||
operator|(
name|imm
operator|<<
operator|(
literal|32
operator|-
name|rot
operator|)
operator|)
expr_stmt|;
name|ip_offset
operator|=
name|imm
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xfffff000
operator|)
operator|==
literal|0xe24dc000
condition|)
comment|/* sub ip, sp #n */
block|{
name|unsigned
name|imm
init|=
name|insn
operator|&
literal|0xff
decl_stmt|;
comment|/* immediate value */
name|unsigned
name|rot
init|=
operator|(
name|insn
operator|&
literal|0xf00
operator|)
operator|>>
literal|7
decl_stmt|;
comment|/* rotate amount */
name|imm
operator|=
operator|(
name|imm
operator|>>
name|rot
operator|)
operator||
operator|(
name|imm
operator|<<
operator|(
literal|32
operator|-
name|rot
operator|)
operator|)
expr_stmt|;
name|ip_offset
operator|=
operator|-
name|imm
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|insn
operator|==
literal|0xe52de004
condition|)
comment|/* str lr, [sp, #-4]! */
block|{
name|sp_offset
operator|-=
literal|4
expr_stmt|;
name|cache
operator|->
name|saved_regs
index|[
name|ARM_LR_REGNUM
index|]
operator|.
name|addr
operator|=
name|sp_offset
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0xe92d0000
condition|)
comment|/* stmfd sp!, {..., fp, ip, lr, pc} 	   or 	   stmfd sp!, {a1, a2, a3, a4}  */
block|{
name|int
name|mask
init|=
name|insn
operator|&
literal|0xffff
decl_stmt|;
comment|/* Calculate offsets of saved registers.  */
for|for
control|(
name|regno
operator|=
name|ARM_PC_REGNUM
init|;
name|regno
operator|>=
literal|0
condition|;
name|regno
operator|--
control|)
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|regno
operator|)
condition|)
block|{
name|sp_offset
operator|-=
literal|4
expr_stmt|;
name|cache
operator|->
name|saved_regs
index|[
name|regno
index|]
operator|.
name|addr
operator|=
name|sp_offset
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xffffc000
operator|)
operator|==
literal|0xe54b0000
operator|||
comment|/* strb rx,[r11,#-n] */
operator|(
name|insn
operator|&
literal|0xffffc0f0
operator|)
operator|==
literal|0xe14b00b0
operator|||
comment|/* strh rx,[r11,#-n] */
operator|(
name|insn
operator|&
literal|0xffffc000
operator|)
operator|==
literal|0xe50b0000
condition|)
comment|/* str  rx,[r11,#-n] */
block|{
comment|/* No need to add this to saved_regs -- it's just an arg reg.  */
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xffffc000
operator|)
operator|==
literal|0xe5cd0000
operator|||
comment|/* strb rx,[sp,#n] */
operator|(
name|insn
operator|&
literal|0xffffc0f0
operator|)
operator|==
literal|0xe1cd00b0
operator|||
comment|/* strh rx,[sp,#n] */
operator|(
name|insn
operator|&
literal|0xffffc000
operator|)
operator|==
literal|0xe58d0000
condition|)
comment|/* str  rx,[sp,#n] */
block|{
comment|/* No need to add this to saved_regs -- it's just an arg reg.  */
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xfffff000
operator|)
operator|==
literal|0xe24cb000
condition|)
comment|/* sub fp, ip #n */
block|{
name|unsigned
name|imm
init|=
name|insn
operator|&
literal|0xff
decl_stmt|;
comment|/* immediate value */
name|unsigned
name|rot
init|=
operator|(
name|insn
operator|&
literal|0xf00
operator|)
operator|>>
literal|7
decl_stmt|;
comment|/* rotate amount */
name|imm
operator|=
operator|(
name|imm
operator|>>
name|rot
operator|)
operator||
operator|(
name|imm
operator|<<
operator|(
literal|32
operator|-
name|rot
operator|)
operator|)
expr_stmt|;
name|fp_offset
operator|=
operator|-
name|imm
operator|+
name|ip_offset
expr_stmt|;
name|cache
operator|->
name|framereg
operator|=
name|ARM_FP_REGNUM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xfffff000
operator|)
operator|==
literal|0xe24dd000
condition|)
comment|/* sub sp, sp #n */
block|{
name|unsigned
name|imm
init|=
name|insn
operator|&
literal|0xff
decl_stmt|;
comment|/* immediate value */
name|unsigned
name|rot
init|=
operator|(
name|insn
operator|&
literal|0xf00
operator|)
operator|>>
literal|7
decl_stmt|;
comment|/* rotate amount */
name|imm
operator|=
operator|(
name|imm
operator|>>
name|rot
operator|)
operator||
operator|(
name|imm
operator|<<
operator|(
literal|32
operator|-
name|rot
operator|)
operator|)
expr_stmt|;
name|sp_offset
operator|-=
name|imm
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xffff7fff
operator|)
operator|==
literal|0xed6d0103
condition|)
comment|/* stfe f?, [sp, -#c]! */
block|{
name|sp_offset
operator|-=
literal|12
expr_stmt|;
name|regno
operator|=
name|ARM_F0_REGNUM
operator|+
operator|(
operator|(
name|insn
operator|>>
literal|12
operator|)
operator|&
literal|0x07
operator|)
expr_stmt|;
name|cache
operator|->
name|saved_regs
index|[
name|regno
index|]
operator|.
name|addr
operator|=
name|sp_offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xffbf0fff
operator|)
operator|==
literal|0xec2d0200
condition|)
comment|/* sfmfd f0, 4, [sp!] */
block|{
name|int
name|n_saved_fp_regs
decl_stmt|;
name|unsigned
name|int
name|fp_start_reg
decl_stmt|,
name|fp_bound_reg
decl_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
literal|0x800
operator|)
operator|==
literal|0x800
condition|)
comment|/* N0 is set */
block|{
if|if
condition|(
operator|(
name|insn
operator|&
literal|0x40000
operator|)
operator|==
literal|0x40000
condition|)
comment|/* N1 is set */
name|n_saved_fp_regs
operator|=
literal|3
expr_stmt|;
else|else
name|n_saved_fp_regs
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|insn
operator|&
literal|0x40000
operator|)
operator|==
literal|0x40000
condition|)
comment|/* N1 is set */
name|n_saved_fp_regs
operator|=
literal|2
expr_stmt|;
else|else
name|n_saved_fp_regs
operator|=
literal|4
expr_stmt|;
block|}
name|fp_start_reg
operator|=
name|ARM_F0_REGNUM
operator|+
operator|(
operator|(
name|insn
operator|>>
literal|12
operator|)
operator|&
literal|0x7
operator|)
expr_stmt|;
name|fp_bound_reg
operator|=
name|fp_start_reg
operator|+
name|n_saved_fp_regs
expr_stmt|;
for|for
control|(
init|;
name|fp_start_reg
operator|<
name|fp_bound_reg
condition|;
name|fp_start_reg
operator|++
control|)
block|{
name|sp_offset
operator|-=
literal|12
expr_stmt|;
name|cache
operator|->
name|saved_regs
index|[
name|fp_start_reg
operator|++
index|]
operator|.
name|addr
operator|=
name|sp_offset
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xf0000000
operator|)
operator|!=
literal|0xe0000000
condition|)
break|break;
comment|/* Condition not true, exit early */
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xfe200000
operator|)
operator|==
literal|0xe8200000
condition|)
comment|/* ldm? */
break|break;
comment|/* Don't scan past a block load */
else|else
comment|/* The optimizer might shove anything into the prologue, 	   so we just skip what we don't recognize.  */
continue|continue;
block|}
comment|/* The frame size is just the negative of the offset (from the      original SP) of the last thing thing we pushed on the stack.       The frame offset is [new FP] - [new SP].  */
name|cache
operator|->
name|framesize
operator|=
operator|-
name|sp_offset
expr_stmt|;
if|if
condition|(
name|cache
operator|->
name|framereg
operator|==
name|ARM_FP_REGNUM
condition|)
name|cache
operator|->
name|frameoffset
operator|=
name|fp_offset
operator|-
name|sp_offset
expr_stmt|;
else|else
name|cache
operator|->
name|frameoffset
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|arm_prologue_cache
modifier|*
name|arm_make_prologue_cache
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|struct
name|arm_prologue_cache
modifier|*
name|cache
decl_stmt|;
name|CORE_ADDR
name|unwound_fp
decl_stmt|;
name|cache
operator|=
name|frame_obstack_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|arm_prologue_cache
argument_list|)
argument_list|)
expr_stmt|;
name|cache
operator|->
name|saved_regs
operator|=
name|trad_frame_alloc_saved_regs
argument_list|(
name|next_frame
argument_list|)
expr_stmt|;
name|arm_scan_prologue
argument_list|(
name|next_frame
argument_list|,
name|cache
argument_list|)
expr_stmt|;
name|unwound_fp
operator|=
name|frame_unwind_register_unsigned
argument_list|(
name|next_frame
argument_list|,
name|cache
operator|->
name|framereg
argument_list|)
expr_stmt|;
if|if
condition|(
name|unwound_fp
operator|==
literal|0
condition|)
return|return
name|cache
return|;
name|cache
operator|->
name|prev_sp
operator|=
name|unwound_fp
operator|+
name|cache
operator|->
name|framesize
operator|-
name|cache
operator|->
name|frameoffset
expr_stmt|;
comment|/* Calculate actual addresses of saved registers using offsets      determined by arm_scan_prologue.  */
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<
name|NUM_REGS
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|trad_frame_addr_p
argument_list|(
name|cache
operator|->
name|saved_regs
argument_list|,
name|reg
argument_list|)
condition|)
name|cache
operator|->
name|saved_regs
index|[
name|reg
index|]
operator|.
name|addr
operator|+=
name|cache
operator|->
name|prev_sp
expr_stmt|;
return|return
name|cache
return|;
block|}
end_function

begin_comment
comment|/* Our frame ID for a normal frame is the current function's starting PC    and the caller's SP when we were called.  */
end_comment

begin_function
specifier|static
name|void
name|arm_prologue_this_id
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|,
name|struct
name|frame_id
modifier|*
name|this_id
parameter_list|)
block|{
name|struct
name|arm_prologue_cache
modifier|*
name|cache
decl_stmt|;
name|struct
name|frame_id
name|id
decl_stmt|;
name|CORE_ADDR
name|func
decl_stmt|;
if|if
condition|(
operator|*
name|this_cache
operator|==
name|NULL
condition|)
operator|*
name|this_cache
operator|=
name|arm_make_prologue_cache
argument_list|(
name|next_frame
argument_list|)
expr_stmt|;
name|cache
operator|=
operator|*
name|this_cache
expr_stmt|;
name|func
operator|=
name|frame_func_unwind
argument_list|(
name|next_frame
argument_list|)
expr_stmt|;
comment|/* This is meant to halt the backtrace at "_start".  Make sure we      don't halt it at a generic dummy frame. */
if|if
condition|(
name|func
operator|<=
name|LOWEST_PC
condition|)
return|return;
comment|/* If we've hit a wall, stop.  */
if|if
condition|(
name|cache
operator|->
name|prev_sp
operator|==
literal|0
condition|)
return|return;
name|id
operator|=
name|frame_id_build
argument_list|(
name|cache
operator|->
name|prev_sp
argument_list|,
name|func
argument_list|)
expr_stmt|;
comment|/* Check that we're not going round in circles with the same frame      ID (but avoid applying the test to sentinel frames which do go      round in circles).  */
if|if
condition|(
name|frame_relative_level
argument_list|(
name|next_frame
argument_list|)
operator|>=
literal|0
operator|&&
name|get_frame_type
argument_list|(
name|next_frame
argument_list|)
operator|==
name|NORMAL_FRAME
operator|&&
name|frame_id_eq
argument_list|(
name|get_frame_id
argument_list|(
name|next_frame
argument_list|)
argument_list|,
name|id
argument_list|)
condition|)
return|return;
operator|*
name|this_id
operator|=
name|id
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_prologue_prev_register
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|,
name|int
name|prev_regnum
parameter_list|,
name|int
modifier|*
name|optimized
parameter_list|,
name|enum
name|lval_type
modifier|*
name|lvalp
parameter_list|,
name|CORE_ADDR
modifier|*
name|addrp
parameter_list|,
name|int
modifier|*
name|realnump
parameter_list|,
name|void
modifier|*
name|valuep
parameter_list|)
block|{
name|struct
name|arm_prologue_cache
modifier|*
name|cache
decl_stmt|;
if|if
condition|(
operator|*
name|this_cache
operator|==
name|NULL
condition|)
operator|*
name|this_cache
operator|=
name|arm_make_prologue_cache
argument_list|(
name|next_frame
argument_list|)
expr_stmt|;
name|cache
operator|=
operator|*
name|this_cache
expr_stmt|;
comment|/* If we are asked to unwind the PC, then we need to return the LR      instead.  The saved value of PC points into this frame's      prologue, not the next frame's resume location.  */
if|if
condition|(
name|prev_regnum
operator|==
name|ARM_PC_REGNUM
condition|)
name|prev_regnum
operator|=
name|ARM_LR_REGNUM
expr_stmt|;
comment|/* SP is generally not saved to the stack, but this frame is      identified by NEXT_FRAME's stack pointer at the time of the call.      The value was already reconstructed into PREV_SP.  */
if|if
condition|(
name|prev_regnum
operator|==
name|ARM_SP_REGNUM
condition|)
block|{
operator|*
name|lvalp
operator|=
name|not_lval
expr_stmt|;
if|if
condition|(
name|valuep
condition|)
name|store_unsigned_integer
argument_list|(
name|valuep
argument_list|,
literal|4
argument_list|,
name|cache
operator|->
name|prev_sp
argument_list|)
expr_stmt|;
return|return;
block|}
name|trad_frame_prev_register
argument_list|(
name|next_frame
argument_list|,
name|cache
operator|->
name|saved_regs
argument_list|,
name|prev_regnum
argument_list|,
name|optimized
argument_list|,
name|lvalp
argument_list|,
name|addrp
argument_list|,
name|realnump
argument_list|,
name|valuep
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|frame_unwind
name|arm_prologue_unwind
init|=
block|{
name|NORMAL_FRAME
block|,
name|arm_prologue_this_id
block|,
name|arm_prologue_prev_register
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|struct
name|frame_unwind
modifier|*
name|arm_prologue_unwind_sniffer
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
return|return
operator|&
name|arm_prologue_unwind
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|arm_normal_frame_base
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|)
block|{
name|struct
name|arm_prologue_cache
modifier|*
name|cache
decl_stmt|;
if|if
condition|(
operator|*
name|this_cache
operator|==
name|NULL
condition|)
operator|*
name|this_cache
operator|=
name|arm_make_prologue_cache
argument_list|(
name|next_frame
argument_list|)
expr_stmt|;
name|cache
operator|=
operator|*
name|this_cache
expr_stmt|;
return|return
name|cache
operator|->
name|prev_sp
operator|+
name|cache
operator|->
name|frameoffset
operator|-
name|cache
operator|->
name|framesize
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|frame_base
name|arm_normal_base
init|=
block|{
operator|&
name|arm_prologue_unwind
block|,
name|arm_normal_frame_base
block|,
name|arm_normal_frame_base
block|,
name|arm_normal_frame_base
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|arm_prologue_cache
modifier|*
name|arm_make_sigtramp_cache
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
name|struct
name|arm_prologue_cache
modifier|*
name|cache
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|cache
operator|=
name|frame_obstack_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|arm_prologue_cache
argument_list|)
argument_list|)
expr_stmt|;
name|cache
operator|->
name|prev_sp
operator|=
name|frame_unwind_register_unsigned
argument_list|(
name|next_frame
argument_list|,
name|ARM_SP_REGNUM
argument_list|)
expr_stmt|;
name|cache
operator|->
name|saved_regs
operator|=
name|trad_frame_alloc_saved_regs
argument_list|(
name|next_frame
argument_list|)
expr_stmt|;
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<
name|NUM_REGS
condition|;
name|reg
operator|++
control|)
name|cache
operator|->
name|saved_regs
index|[
name|reg
index|]
operator|.
name|addr
operator|=
name|SIGCONTEXT_REGISTER_ADDRESS
argument_list|(
name|cache
operator|->
name|prev_sp
argument_list|,
name|frame_pc_unwind
argument_list|(
name|next_frame
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* FIXME: What about thumb mode?  */
name|cache
operator|->
name|framereg
operator|=
name|ARM_SP_REGNUM
expr_stmt|;
name|cache
operator|->
name|prev_sp
operator|=
name|read_memory_integer
argument_list|(
name|cache
operator|->
name|saved_regs
index|[
name|cache
operator|->
name|framereg
index|]
operator|.
name|addr
argument_list|,
name|register_size
argument_list|(
name|current_gdbarch
argument_list|,
name|cache
operator|->
name|framereg
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|cache
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_sigtramp_this_id
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|,
name|struct
name|frame_id
modifier|*
name|this_id
parameter_list|)
block|{
name|struct
name|arm_prologue_cache
modifier|*
name|cache
decl_stmt|;
if|if
condition|(
operator|*
name|this_cache
operator|==
name|NULL
condition|)
operator|*
name|this_cache
operator|=
name|arm_make_sigtramp_cache
argument_list|(
name|next_frame
argument_list|)
expr_stmt|;
name|cache
operator|=
operator|*
name|this_cache
expr_stmt|;
comment|/* FIXME drow/2003-07-07: This isn't right if we single-step within      the sigtramp frame; the PC should be the beginning of the trampoline.  */
operator|*
name|this_id
operator|=
name|frame_id_build
argument_list|(
name|cache
operator|->
name|prev_sp
argument_list|,
name|frame_pc_unwind
argument_list|(
name|next_frame
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_sigtramp_prev_register
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|,
name|int
name|prev_regnum
parameter_list|,
name|int
modifier|*
name|optimized
parameter_list|,
name|enum
name|lval_type
modifier|*
name|lvalp
parameter_list|,
name|CORE_ADDR
modifier|*
name|addrp
parameter_list|,
name|int
modifier|*
name|realnump
parameter_list|,
name|void
modifier|*
name|valuep
parameter_list|)
block|{
name|struct
name|arm_prologue_cache
modifier|*
name|cache
decl_stmt|;
if|if
condition|(
operator|*
name|this_cache
operator|==
name|NULL
condition|)
operator|*
name|this_cache
operator|=
name|arm_make_sigtramp_cache
argument_list|(
name|next_frame
argument_list|)
expr_stmt|;
name|cache
operator|=
operator|*
name|this_cache
expr_stmt|;
name|trad_frame_prev_register
argument_list|(
name|next_frame
argument_list|,
name|cache
operator|->
name|saved_regs
argument_list|,
name|prev_regnum
argument_list|,
name|optimized
argument_list|,
name|lvalp
argument_list|,
name|addrp
argument_list|,
name|realnump
argument_list|,
name|valuep
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|frame_unwind
name|arm_sigtramp_unwind
init|=
block|{
name|SIGTRAMP_FRAME
block|,
name|arm_sigtramp_this_id
block|,
name|arm_sigtramp_prev_register
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|struct
name|frame_unwind
modifier|*
name|arm_sigtramp_unwind_sniffer
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
comment|/* Note: If an ARM PC_IN_SIGTRAMP method ever needs to compare      against the name of the function, the code below will have to be      changed to first fetch the name of the function and then pass      this name to PC_IN_SIGTRAMP.  */
if|if
condition|(
name|SIGCONTEXT_REGISTER_ADDRESS_P
argument_list|()
operator|&&
name|PC_IN_SIGTRAMP
argument_list|(
name|frame_pc_unwind
argument_list|(
name|next_frame
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
condition|)
return|return
operator|&
name|arm_sigtramp_unwind
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Assuming NEXT_FRAME->prev is a dummy, return the frame ID of that    dummy frame.  The frame ID's base needs to match the TOS value    saved by save_dummy_frame_tos() and returned from    arm_push_dummy_call, and the PC needs to match the dummy frame's    breakpoint.  */
end_comment

begin_function
specifier|static
name|struct
name|frame_id
name|arm_unwind_dummy_id
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
return|return
name|frame_id_build
argument_list|(
name|frame_unwind_register_unsigned
argument_list|(
name|next_frame
argument_list|,
name|ARM_SP_REGNUM
argument_list|)
argument_list|,
name|frame_pc_unwind
argument_list|(
name|next_frame
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given THIS_FRAME, find the previous frame's resume PC (which will    be used to construct the previous frame's ID, after looking up the    containing function).  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|arm_unwind_pc
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|frame_info
modifier|*
name|this_frame
parameter_list|)
block|{
name|CORE_ADDR
name|pc
decl_stmt|;
name|pc
operator|=
name|frame_unwind_register_unsigned
argument_list|(
name|this_frame
argument_list|,
name|ARM_PC_REGNUM
argument_list|)
expr_stmt|;
return|return
name|IS_THUMB_ADDR
argument_list|(
name|pc
argument_list|)
condition|?
name|UNMAKE_THUMB_ADDR
argument_list|(
name|pc
argument_list|)
else|:
name|pc
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|arm_unwind_sp
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|frame_info
modifier|*
name|this_frame
parameter_list|)
block|{
return|return
name|frame_unwind_register_unsigned
argument_list|(
name|this_frame
argument_list|,
name|ARM_SP_REGNUM
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* DEPRECATED_CALL_DUMMY_WORDS:    This sequence of words is the instructions     mov  lr,pc    mov  pc,r4    illegal     Note this is 12 bytes.  */
end_comment

begin_decl_stmt
specifier|static
name|LONGEST
name|arm_call_dummy_words
index|[]
init|=
block|{
literal|0xe1a0e00f
block|,
literal|0xe1a0f004
block|,
literal|0xe7ffdefe
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* When arguments must be pushed onto the stack, they go on in reverse    order.  The code below implements a FILO (stack) to do this.  */
end_comment

begin_struct
struct|struct
name|stack_item
block|{
name|int
name|len
decl_stmt|;
name|struct
name|stack_item
modifier|*
name|prev
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|struct
name|stack_item
modifier|*
name|push_stack_item
parameter_list|(
name|struct
name|stack_item
modifier|*
name|prev
parameter_list|,
name|void
modifier|*
name|contents
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|stack_item
modifier|*
name|si
decl_stmt|;
name|si
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|stack_item
argument_list|)
argument_list|)
expr_stmt|;
name|si
operator|->
name|data
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|si
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|si
operator|->
name|prev
operator|=
name|prev
expr_stmt|;
name|memcpy
argument_list|(
name|si
operator|->
name|data
argument_list|,
name|contents
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|si
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|stack_item
modifier|*
name|pop_stack_item
parameter_list|(
name|struct
name|stack_item
modifier|*
name|si
parameter_list|)
block|{
name|struct
name|stack_item
modifier|*
name|dead
init|=
name|si
decl_stmt|;
name|si
operator|=
name|si
operator|->
name|prev
expr_stmt|;
name|xfree
argument_list|(
name|dead
operator|->
name|data
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|dead
argument_list|)
expr_stmt|;
return|return
name|si
return|;
block|}
end_function

begin_comment
comment|/* We currently only support passing parameters in integer registers.  This    conforms with GCC's default model.  Several other variants exist and    we should probably support some of them based on the selected ABI.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|arm_push_dummy_call
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|CORE_ADDR
name|func_addr
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|CORE_ADDR
name|bp_addr
parameter_list|,
name|int
name|nargs
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|args
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|,
name|int
name|struct_return
parameter_list|,
name|CORE_ADDR
name|struct_addr
parameter_list|)
block|{
name|int
name|argnum
decl_stmt|;
name|int
name|argreg
decl_stmt|;
name|int
name|nstack
decl_stmt|;
name|struct
name|stack_item
modifier|*
name|si
init|=
name|NULL
decl_stmt|;
comment|/* Set the return address.  For the ARM, the return breakpoint is      always at BP_ADDR.  */
comment|/* XXX Fix for Thumb.  */
name|regcache_cooked_write_unsigned
argument_list|(
name|regcache
argument_list|,
name|ARM_LR_REGNUM
argument_list|,
name|bp_addr
argument_list|)
expr_stmt|;
comment|/* Walk through the list of args and determine how large a temporary      stack is required.  Need to take care here as structs may be      passed on the stack, and we have to to push them.  */
name|nstack
operator|=
literal|0
expr_stmt|;
name|argreg
operator|=
name|ARM_A1_REGNUM
expr_stmt|;
name|nstack
operator|=
literal|0
expr_stmt|;
comment|/* Some platforms require a double-word aligned stack.  Make sure sp      is correctly aligned before we start.  We always do this even if      it isn't really needed -- it can never hurt things.  */
name|sp
operator|&=
operator|~
call|(
name|CORE_ADDR
call|)
argument_list|(
literal|2
operator|*
name|DEPRECATED_REGISTER_SIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* The struct_return pointer occupies the first parameter      passing register.  */
if|if
condition|(
name|struct_return
condition|)
block|{
if|if
condition|(
name|arm_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"struct return in %s = 0x%s\n"
argument_list|,
name|REGISTER_NAME
argument_list|(
name|argreg
argument_list|)
argument_list|,
name|paddr
argument_list|(
name|struct_addr
argument_list|)
argument_list|)
expr_stmt|;
name|regcache_cooked_write_unsigned
argument_list|(
name|regcache
argument_list|,
name|argreg
argument_list|,
name|struct_addr
argument_list|)
expr_stmt|;
name|argreg
operator|++
expr_stmt|;
block|}
for|for
control|(
name|argnum
operator|=
literal|0
init|;
name|argnum
operator|<
name|nargs
condition|;
name|argnum
operator|++
control|)
block|{
name|int
name|len
decl_stmt|;
name|struct
name|type
modifier|*
name|arg_type
decl_stmt|;
name|struct
name|type
modifier|*
name|target_type
decl_stmt|;
name|enum
name|type_code
name|typecode
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|arg_type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|args
index|[
name|argnum
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|arg_type
argument_list|)
expr_stmt|;
name|target_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|arg_type
argument_list|)
expr_stmt|;
name|typecode
operator|=
name|TYPE_CODE
argument_list|(
name|arg_type
argument_list|)
expr_stmt|;
name|val
operator|=
name|VALUE_CONTENTS
argument_list|(
name|args
index|[
name|argnum
index|]
argument_list|)
expr_stmt|;
comment|/* If the argument is a pointer to a function, and it is a 	 Thumb function, create a LOCAL copy of the value and set 	 the THUMB bit in it.  */
if|if
condition|(
name|TYPE_CODE_PTR
operator|==
name|typecode
operator|&&
name|target_type
operator|!=
name|NULL
operator|&&
name|TYPE_CODE_FUNC
operator|==
name|TYPE_CODE
argument_list|(
name|target_type
argument_list|)
condition|)
block|{
name|CORE_ADDR
name|regval
init|=
name|extract_unsigned_integer
argument_list|(
name|val
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|arm_pc_is_thumb
argument_list|(
name|regval
argument_list|)
condition|)
block|{
name|val
operator|=
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|val
argument_list|,
name|len
argument_list|,
name|MAKE_THUMB_ADDR
argument_list|(
name|regval
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Copy the argument to general registers or the stack in 	 register-sized pieces.  Large arguments are split between 	 registers and stack.  */
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|int
name|partial_len
init|=
name|len
operator|<
name|DEPRECATED_REGISTER_SIZE
condition|?
name|len
else|:
name|DEPRECATED_REGISTER_SIZE
decl_stmt|;
if|if
condition|(
name|argreg
operator|<=
name|ARM_LAST_ARG_REGNUM
condition|)
block|{
comment|/* The argument is being passed in a general purpose 		 register.  */
name|CORE_ADDR
name|regval
init|=
name|extract_unsigned_integer
argument_list|(
name|val
argument_list|,
name|partial_len
argument_list|)
decl_stmt|;
if|if
condition|(
name|arm_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"arg %d in %s = 0x%s\n"
argument_list|,
name|argnum
argument_list|,
name|REGISTER_NAME
argument_list|(
name|argreg
argument_list|)
argument_list|,
name|phex
argument_list|(
name|regval
argument_list|,
name|DEPRECATED_REGISTER_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|regcache_cooked_write_unsigned
argument_list|(
name|regcache
argument_list|,
name|argreg
argument_list|,
name|regval
argument_list|)
expr_stmt|;
name|argreg
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* Push the arguments onto the stack.  */
if|if
condition|(
name|arm_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"arg %d @ sp + %d\n"
argument_list|,
name|argnum
argument_list|,
name|nstack
argument_list|)
expr_stmt|;
name|si
operator|=
name|push_stack_item
argument_list|(
name|si
argument_list|,
name|val
argument_list|,
name|DEPRECATED_REGISTER_SIZE
argument_list|)
expr_stmt|;
name|nstack
operator|+=
name|DEPRECATED_REGISTER_SIZE
expr_stmt|;
block|}
name|len
operator|-=
name|partial_len
expr_stmt|;
name|val
operator|+=
name|partial_len
expr_stmt|;
block|}
block|}
comment|/* If we have an odd number of words to push, then decrement the stack      by one word now, so first stack argument will be dword aligned.  */
if|if
condition|(
name|nstack
operator|&
literal|4
condition|)
name|sp
operator|-=
literal|4
expr_stmt|;
while|while
condition|(
name|si
condition|)
block|{
name|sp
operator|-=
name|si
operator|->
name|len
expr_stmt|;
name|write_memory
argument_list|(
name|sp
argument_list|,
name|si
operator|->
name|data
argument_list|,
name|si
operator|->
name|len
argument_list|)
expr_stmt|;
name|si
operator|=
name|pop_stack_item
argument_list|(
name|si
argument_list|)
expr_stmt|;
block|}
comment|/* Finally, update teh SP register.  */
name|regcache_cooked_write_unsigned
argument_list|(
name|regcache
argument_list|,
name|ARM_SP_REGNUM
argument_list|,
name|sp
argument_list|)
expr_stmt|;
return|return
name|sp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_fpu_flags
parameter_list|(
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|flags
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
condition|)
name|fputs
argument_list|(
literal|"IVO "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
condition|)
name|fputs
argument_list|(
literal|"DVZ "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
literal|1
operator|<<
literal|2
operator|)
condition|)
name|fputs
argument_list|(
literal|"OFL "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
literal|1
operator|<<
literal|3
operator|)
condition|)
name|fputs
argument_list|(
literal|"UFL "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
literal|1
operator|<<
literal|4
operator|)
condition|)
name|fputs
argument_list|(
literal|"INX "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print interesting information about the floating point processor    (if present) or emulator.  */
end_comment

begin_function
specifier|static
name|void
name|arm_print_float_info
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|ui_file
modifier|*
name|file
parameter_list|,
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
specifier|const
name|char
modifier|*
name|args
parameter_list|)
block|{
name|unsigned
name|long
name|status
init|=
name|read_register
argument_list|(
name|ARM_FPS_REGNUM
argument_list|)
decl_stmt|;
name|int
name|type
decl_stmt|;
name|type
operator|=
operator|(
name|status
operator|>>
literal|24
operator|)
operator|&
literal|127
expr_stmt|;
name|printf
argument_list|(
literal|"%s FPU type %d\n"
argument_list|,
operator|(
name|status
operator|&
operator|(
literal|1
operator|<<
literal|31
operator|)
operator|)
condition|?
literal|"Hardware"
else|:
literal|"Software"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"mask: "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|print_fpu_flags
argument_list|(
name|status
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"flags: "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|print_fpu_flags
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the GDB type object for the "standard" data type of data in    register N.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|arm_register_type
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
if|if
condition|(
name|regnum
operator|>=
name|ARM_F0_REGNUM
operator|&&
name|regnum
operator|<
name|ARM_F0_REGNUM
operator|+
name|NUM_FREGS
condition|)
block|{
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|)
return|return
name|builtin_type_arm_ext_big
return|;
else|else
return|return
name|builtin_type_arm_ext_littlebyte_bigword
return|;
block|}
else|else
return|return
name|builtin_type_int32
return|;
block|}
end_function

begin_comment
comment|/* Index within `registers' of the first byte of the space for    register N.  */
end_comment

begin_function
specifier|static
name|int
name|arm_register_byte
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
if|if
condition|(
name|regnum
operator|<
name|ARM_F0_REGNUM
condition|)
return|return
name|regnum
operator|*
name|INT_REGISTER_SIZE
return|;
elseif|else
if|if
condition|(
name|regnum
operator|<
name|ARM_PS_REGNUM
condition|)
return|return
operator|(
name|NUM_GREGS
operator|*
name|INT_REGISTER_SIZE
operator|+
operator|(
name|regnum
operator|-
name|ARM_F0_REGNUM
operator|)
operator|*
name|FP_REGISTER_SIZE
operator|)
return|;
else|else
return|return
operator|(
name|NUM_GREGS
operator|*
name|INT_REGISTER_SIZE
operator|+
name|NUM_FREGS
operator|*
name|FP_REGISTER_SIZE
operator|+
operator|(
name|regnum
operator|-
name|ARM_FPS_REGNUM
operator|)
operator|*
name|STATUS_REGISTER_SIZE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Map GDB internal REGNUM onto the Arm simulator register numbers.  */
end_comment

begin_function
specifier|static
name|int
name|arm_register_sim_regno
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
name|int
name|reg
init|=
name|regnum
decl_stmt|;
name|gdb_assert
argument_list|(
name|reg
operator|>=
literal|0
operator|&&
name|reg
operator|<
name|NUM_REGS
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|<
name|NUM_GREGS
condition|)
return|return
name|SIM_ARM_R0_REGNUM
operator|+
name|reg
return|;
name|reg
operator|-=
name|NUM_GREGS
expr_stmt|;
if|if
condition|(
name|reg
operator|<
name|NUM_FREGS
condition|)
return|return
name|SIM_ARM_FP0_REGNUM
operator|+
name|reg
return|;
name|reg
operator|-=
name|NUM_FREGS
expr_stmt|;
if|if
condition|(
name|reg
operator|<
name|NUM_SREGS
condition|)
return|return
name|SIM_ARM_FPS_REGNUM
operator|+
name|reg
return|;
name|reg
operator|-=
name|NUM_SREGS
expr_stmt|;
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Bad REGNUM %d"
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* NOTE: cagney/2001-08-20: Both convert_from_extended() and    convert_to_extended() use floatformat_arm_ext_littlebyte_bigword.    It is thought that this is is the floating-point register format on    little-endian systems.  */
end_comment

begin_function
specifier|static
name|void
name|convert_from_extended
parameter_list|(
specifier|const
name|struct
name|floatformat
modifier|*
name|fmt
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|void
modifier|*
name|dbl
parameter_list|)
block|{
name|DOUBLEST
name|d
decl_stmt|;
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|)
name|floatformat_to_doublest
argument_list|(
operator|&
name|floatformat_arm_ext_big
argument_list|,
name|ptr
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
else|else
name|floatformat_to_doublest
argument_list|(
operator|&
name|floatformat_arm_ext_littlebyte_bigword
argument_list|,
name|ptr
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
name|floatformat_from_doublest
argument_list|(
name|fmt
argument_list|,
operator|&
name|d
argument_list|,
name|dbl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|convert_to_extended
parameter_list|(
specifier|const
name|struct
name|floatformat
modifier|*
name|fmt
parameter_list|,
name|void
modifier|*
name|dbl
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|DOUBLEST
name|d
decl_stmt|;
name|floatformat_to_doublest
argument_list|(
name|fmt
argument_list|,
name|ptr
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|)
name|floatformat_from_doublest
argument_list|(
operator|&
name|floatformat_arm_ext_big
argument_list|,
operator|&
name|d
argument_list|,
name|dbl
argument_list|)
expr_stmt|;
else|else
name|floatformat_from_doublest
argument_list|(
operator|&
name|floatformat_arm_ext_littlebyte_bigword
argument_list|,
operator|&
name|d
argument_list|,
name|dbl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|condition_true
parameter_list|(
name|unsigned
name|long
name|cond
parameter_list|,
name|unsigned
name|long
name|status_reg
parameter_list|)
block|{
if|if
condition|(
name|cond
operator|==
name|INST_AL
operator|||
name|cond
operator|==
name|INST_NV
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|cond
condition|)
block|{
case|case
name|INST_EQ
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_Z
operator|)
operator|!=
literal|0
operator|)
return|;
case|case
name|INST_NE
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_Z
operator|)
operator|==
literal|0
operator|)
return|;
case|case
name|INST_CS
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_C
operator|)
operator|!=
literal|0
operator|)
return|;
case|case
name|INST_CC
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_C
operator|)
operator|==
literal|0
operator|)
return|;
case|case
name|INST_MI
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_N
operator|)
operator|!=
literal|0
operator|)
return|;
case|case
name|INST_PL
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_N
operator|)
operator|==
literal|0
operator|)
return|;
case|case
name|INST_VS
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_V
operator|)
operator|!=
literal|0
operator|)
return|;
case|case
name|INST_VC
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_V
operator|)
operator|==
literal|0
operator|)
return|;
case|case
name|INST_HI
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
operator|(
name|FLAG_C
operator||
name|FLAG_Z
operator|)
operator|)
operator|==
name|FLAG_C
operator|)
return|;
case|case
name|INST_LS
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
operator|(
name|FLAG_C
operator||
name|FLAG_Z
operator|)
operator|)
operator|!=
name|FLAG_C
operator|)
return|;
case|case
name|INST_GE
case|:
return|return
operator|(
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_N
operator|)
operator|==
literal|0
operator|)
operator|==
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_V
operator|)
operator|==
literal|0
operator|)
operator|)
return|;
case|case
name|INST_LT
case|:
return|return
operator|(
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_N
operator|)
operator|==
literal|0
operator|)
operator|!=
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_V
operator|)
operator|==
literal|0
operator|)
operator|)
return|;
case|case
name|INST_GT
case|:
return|return
operator|(
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_Z
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_N
operator|)
operator|==
literal|0
operator|)
operator|==
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_V
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
return|;
case|case
name|INST_LE
case|:
return|return
operator|(
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_Z
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_N
operator|)
operator|==
literal|0
operator|)
operator|!=
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_V
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Support routines for single stepping.  Calculate the next PC value.  */
end_comment

begin_define
define|#
directive|define
name|submask
parameter_list|(
name|x
parameter_list|)
value|((1L<< ((x) + 1)) - 1)
end_define

begin_define
define|#
directive|define
name|bit
parameter_list|(
name|obj
parameter_list|,
name|st
parameter_list|)
value|(((obj)>> (st))& 1)
end_define

begin_define
define|#
directive|define
name|bits
parameter_list|(
name|obj
parameter_list|,
name|st
parameter_list|,
name|fn
parameter_list|)
value|(((obj)>> (st))& submask ((fn) - (st)))
end_define

begin_define
define|#
directive|define
name|sbits
parameter_list|(
name|obj
parameter_list|,
name|st
parameter_list|,
name|fn
parameter_list|)
define|\
value|((long) (bits(obj,st,fn) | ((long) bit(obj,fn) * ~ submask (fn - st))))
end_define

begin_define
define|#
directive|define
name|BranchDest
parameter_list|(
name|addr
parameter_list|,
name|instr
parameter_list|)
define|\
value|((CORE_ADDR) (((long) (addr)) + 8 + (sbits (instr, 0, 23)<< 2)))
end_define

begin_define
define|#
directive|define
name|ARM_PC_32
value|1
end_define

begin_function
specifier|static
name|unsigned
name|long
name|shifted_reg_val
parameter_list|(
name|unsigned
name|long
name|inst
parameter_list|,
name|int
name|carry
parameter_list|,
name|unsigned
name|long
name|pc_val
parameter_list|,
name|unsigned
name|long
name|status_reg
parameter_list|)
block|{
name|unsigned
name|long
name|res
decl_stmt|,
name|shift
decl_stmt|;
name|int
name|rm
init|=
name|bits
argument_list|(
name|inst
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|shifttype
init|=
name|bits
argument_list|(
name|inst
argument_list|,
literal|5
argument_list|,
literal|6
argument_list|)
decl_stmt|;
if|if
condition|(
name|bit
argument_list|(
name|inst
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|int
name|rs
init|=
name|bits
argument_list|(
name|inst
argument_list|,
literal|8
argument_list|,
literal|11
argument_list|)
decl_stmt|;
name|shift
operator|=
operator|(
name|rs
operator|==
literal|15
condition|?
name|pc_val
operator|+
literal|8
else|:
name|read_register
argument_list|(
name|rs
argument_list|)
operator|)
operator|&
literal|0xFF
expr_stmt|;
block|}
else|else
name|shift
operator|=
name|bits
argument_list|(
name|inst
argument_list|,
literal|7
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|res
operator|=
operator|(
name|rm
operator|==
literal|15
condition|?
operator|(
operator|(
name|pc_val
operator||
operator|(
name|ARM_PC_32
condition|?
literal|0
else|:
name|status_reg
operator|)
operator|)
operator|+
operator|(
name|bit
argument_list|(
name|inst
argument_list|,
literal|4
argument_list|)
condition|?
literal|12
else|:
literal|8
operator|)
operator|)
else|:
name|read_register
argument_list|(
name|rm
argument_list|)
operator|)
expr_stmt|;
switch|switch
condition|(
name|shifttype
condition|)
block|{
case|case
literal|0
case|:
comment|/* LSL */
name|res
operator|=
name|shift
operator|>=
literal|32
condition|?
literal|0
else|:
name|res
operator|<<
name|shift
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* LSR */
name|res
operator|=
name|shift
operator|>=
literal|32
condition|?
literal|0
else|:
name|res
operator|>>
name|shift
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* ASR */
if|if
condition|(
name|shift
operator|>=
literal|32
condition|)
name|shift
operator|=
literal|31
expr_stmt|;
name|res
operator|=
operator|(
operator|(
name|res
operator|&
literal|0x80000000L
operator|)
condition|?
operator|~
operator|(
operator|(
operator|~
name|res
operator|)
operator|>>
name|shift
operator|)
else|:
name|res
operator|>>
name|shift
operator|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* ROR/RRX */
name|shift
operator|&=
literal|31
expr_stmt|;
if|if
condition|(
name|shift
operator|==
literal|0
condition|)
name|res
operator|=
operator|(
name|res
operator|>>
literal|1
operator|)
operator||
operator|(
name|carry
condition|?
literal|0x80000000L
else|:
literal|0
operator|)
expr_stmt|;
else|else
name|res
operator|=
operator|(
name|res
operator|>>
name|shift
operator|)
operator||
operator|(
name|res
operator|<<
operator|(
literal|32
operator|-
name|shift
operator|)
operator|)
expr_stmt|;
break|break;
block|}
return|return
name|res
operator|&
literal|0xffffffff
return|;
block|}
end_function

begin_comment
comment|/* Return number of 1-bits in VAL.  */
end_comment

begin_function
specifier|static
name|int
name|bitcount
parameter_list|(
name|unsigned
name|long
name|val
parameter_list|)
block|{
name|int
name|nbits
decl_stmt|;
for|for
control|(
name|nbits
operator|=
literal|0
init|;
name|val
operator|!=
literal|0
condition|;
name|nbits
operator|++
control|)
name|val
operator|&=
name|val
operator|-
literal|1
expr_stmt|;
comment|/* delete rightmost 1-bit in val */
return|return
name|nbits
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|thumb_get_next_pc
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|unsigned
name|long
name|pc_val
init|=
operator|(
operator|(
name|unsigned
name|long
operator|)
name|pc
operator|)
operator|+
literal|4
decl_stmt|;
comment|/* PC after prefetch */
name|unsigned
name|short
name|inst1
init|=
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|nextpc
init|=
name|pc
operator|+
literal|2
decl_stmt|;
comment|/* default is next instruction */
name|unsigned
name|long
name|offset
decl_stmt|;
if|if
condition|(
operator|(
name|inst1
operator|&
literal|0xff00
operator|)
operator|==
literal|0xbd00
condition|)
comment|/* pop {rlist, pc} */
block|{
name|CORE_ADDR
name|sp
decl_stmt|;
comment|/* Fetch the saved PC from the stack.  It's stored above          all of the other registers.  */
name|offset
operator|=
name|bitcount
argument_list|(
name|bits
argument_list|(
name|inst1
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|)
argument_list|)
operator|*
name|DEPRECATED_REGISTER_SIZE
expr_stmt|;
name|sp
operator|=
name|read_register
argument_list|(
name|ARM_SP_REGNUM
argument_list|)
expr_stmt|;
name|nextpc
operator|=
operator|(
name|CORE_ADDR
operator|)
name|read_memory_integer
argument_list|(
name|sp
operator|+
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|nextpc
operator|=
name|ADDR_BITS_REMOVE
argument_list|(
name|nextpc
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextpc
operator|==
name|pc
condition|)
name|error
argument_list|(
literal|"Infinite loop detected"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|inst1
operator|&
literal|0xf000
operator|)
operator|==
literal|0xd000
condition|)
comment|/* conditional branch */
block|{
name|unsigned
name|long
name|status
init|=
name|read_register
argument_list|(
name|ARM_PS_REGNUM
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|cond
init|=
name|bits
argument_list|(
name|inst1
argument_list|,
literal|8
argument_list|,
literal|11
argument_list|)
decl_stmt|;
if|if
condition|(
name|cond
operator|!=
literal|0x0f
operator|&&
name|condition_true
argument_list|(
name|cond
argument_list|,
name|status
argument_list|)
condition|)
comment|/* 0x0f = SWI */
name|nextpc
operator|=
name|pc_val
operator|+
operator|(
name|sbits
argument_list|(
name|inst1
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|)
operator|<<
literal|1
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|inst1
operator|&
literal|0xf800
operator|)
operator|==
literal|0xe000
condition|)
comment|/* unconditional branch */
block|{
name|nextpc
operator|=
name|pc_val
operator|+
operator|(
name|sbits
argument_list|(
name|inst1
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
operator|<<
literal|1
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|inst1
operator|&
literal|0xf800
operator|)
operator|==
literal|0xf000
condition|)
comment|/* long branch with link, and blx */
block|{
name|unsigned
name|short
name|inst2
init|=
name|read_memory_integer
argument_list|(
name|pc
operator|+
literal|2
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|offset
operator|=
operator|(
name|sbits
argument_list|(
name|inst1
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
operator|<<
literal|12
operator|)
operator|+
operator|(
name|bits
argument_list|(
name|inst2
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
operator|<<
literal|1
operator|)
expr_stmt|;
name|nextpc
operator|=
name|pc_val
operator|+
name|offset
expr_stmt|;
comment|/* For BLX make sure to clear the low bits.  */
if|if
condition|(
name|bits
argument_list|(
name|inst2
argument_list|,
literal|11
argument_list|,
literal|12
argument_list|)
operator|==
literal|1
condition|)
name|nextpc
operator|=
name|nextpc
operator|&
literal|0xfffffffc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|inst1
operator|&
literal|0xff00
operator|)
operator|==
literal|0x4700
condition|)
comment|/* bx REG, blx REG */
block|{
if|if
condition|(
name|bits
argument_list|(
name|inst1
argument_list|,
literal|3
argument_list|,
literal|6
argument_list|)
operator|==
literal|0x0f
condition|)
name|nextpc
operator|=
name|pc_val
expr_stmt|;
else|else
name|nextpc
operator|=
name|read_register
argument_list|(
name|bits
argument_list|(
name|inst1
argument_list|,
literal|3
argument_list|,
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|nextpc
operator|=
name|ADDR_BITS_REMOVE
argument_list|(
name|nextpc
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextpc
operator|==
name|pc
condition|)
name|error
argument_list|(
literal|"Infinite loop detected"
argument_list|)
expr_stmt|;
block|}
return|return
name|nextpc
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|arm_get_next_pc
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|unsigned
name|long
name|pc_val
decl_stmt|;
name|unsigned
name|long
name|this_instr
decl_stmt|;
name|unsigned
name|long
name|status
decl_stmt|;
name|CORE_ADDR
name|nextpc
decl_stmt|;
if|if
condition|(
name|arm_pc_is_thumb
argument_list|(
name|pc
argument_list|)
condition|)
return|return
name|thumb_get_next_pc
argument_list|(
name|pc
argument_list|)
return|;
name|pc_val
operator|=
operator|(
name|unsigned
name|long
operator|)
name|pc
expr_stmt|;
name|this_instr
operator|=
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|status
operator|=
name|read_register
argument_list|(
name|ARM_PS_REGNUM
argument_list|)
expr_stmt|;
name|nextpc
operator|=
call|(
name|CORE_ADDR
call|)
argument_list|(
name|pc_val
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* Default case */
if|if
condition|(
name|condition_true
argument_list|(
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|28
argument_list|,
literal|31
argument_list|)
argument_list|,
name|status
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|24
argument_list|,
literal|27
argument_list|)
condition|)
block|{
case|case
literal|0x0
case|:
case|case
literal|0x1
case|:
comment|/* data processing */
case|case
literal|0x2
case|:
case|case
literal|0x3
case|:
block|{
name|unsigned
name|long
name|operand1
decl_stmt|,
name|operand2
decl_stmt|,
name|result
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|rn
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|12
argument_list|,
literal|15
argument_list|)
operator|!=
literal|15
condition|)
break|break;
if|if
condition|(
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|22
argument_list|,
literal|25
argument_list|)
operator|==
literal|0
operator|&&
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|4
argument_list|,
literal|7
argument_list|)
operator|==
literal|9
condition|)
comment|/* multiply */
name|error
argument_list|(
literal|"Illegal update to pc in instruction"
argument_list|)
expr_stmt|;
comment|/* BX<reg>, BLX<reg> */
if|if
condition|(
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|4
argument_list|,
literal|28
argument_list|)
operator|==
literal|0x12fff1
operator|||
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|4
argument_list|,
literal|28
argument_list|)
operator|==
literal|0x12fff3
condition|)
block|{
name|rn
operator|=
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
name|rn
operator|==
literal|15
operator|)
condition|?
name|pc_val
operator|+
literal|8
else|:
name|read_register
argument_list|(
name|rn
argument_list|)
expr_stmt|;
name|nextpc
operator|=
operator|(
name|CORE_ADDR
operator|)
name|ADDR_BITS_REMOVE
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextpc
operator|==
name|pc
condition|)
name|error
argument_list|(
literal|"Infinite loop detected"
argument_list|)
expr_stmt|;
return|return
name|nextpc
return|;
block|}
comment|/* Multiply into PC */
name|c
operator|=
operator|(
name|status
operator|&
name|FLAG_C
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|rn
operator|=
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|16
argument_list|,
literal|19
argument_list|)
expr_stmt|;
name|operand1
operator|=
operator|(
name|rn
operator|==
literal|15
operator|)
condition|?
name|pc_val
operator|+
literal|8
else|:
name|read_register
argument_list|(
name|rn
argument_list|)
expr_stmt|;
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|25
argument_list|)
condition|)
block|{
name|unsigned
name|long
name|immval
init|=
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|rotate
init|=
literal|2
operator|*
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|8
argument_list|,
literal|11
argument_list|)
decl_stmt|;
name|operand2
operator|=
operator|(
operator|(
name|immval
operator|>>
name|rotate
operator|)
operator||
operator|(
name|immval
operator|<<
operator|(
literal|32
operator|-
name|rotate
operator|)
operator|)
operator|)
operator|&
literal|0xffffffff
expr_stmt|;
block|}
else|else
comment|/* operand 2 is a shifted register */
name|operand2
operator|=
name|shifted_reg_val
argument_list|(
name|this_instr
argument_list|,
name|c
argument_list|,
name|pc_val
argument_list|,
name|status
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|21
argument_list|,
literal|24
argument_list|)
condition|)
block|{
case|case
literal|0x0
case|:
comment|/*and */
name|result
operator|=
name|operand1
operator|&
name|operand2
expr_stmt|;
break|break;
case|case
literal|0x1
case|:
comment|/*eor */
name|result
operator|=
name|operand1
operator|^
name|operand2
expr_stmt|;
break|break;
case|case
literal|0x2
case|:
comment|/*sub */
name|result
operator|=
name|operand1
operator|-
name|operand2
expr_stmt|;
break|break;
case|case
literal|0x3
case|:
comment|/*rsb */
name|result
operator|=
name|operand2
operator|-
name|operand1
expr_stmt|;
break|break;
case|case
literal|0x4
case|:
comment|/*add */
name|result
operator|=
name|operand1
operator|+
name|operand2
expr_stmt|;
break|break;
case|case
literal|0x5
case|:
comment|/*adc */
name|result
operator|=
name|operand1
operator|+
name|operand2
operator|+
name|c
expr_stmt|;
break|break;
case|case
literal|0x6
case|:
comment|/*sbc */
name|result
operator|=
name|operand1
operator|-
name|operand2
operator|+
name|c
expr_stmt|;
break|break;
case|case
literal|0x7
case|:
comment|/*rsc */
name|result
operator|=
name|operand2
operator|-
name|operand1
operator|+
name|c
expr_stmt|;
break|break;
case|case
literal|0x8
case|:
case|case
literal|0x9
case|:
case|case
literal|0xa
case|:
case|case
literal|0xb
case|:
comment|/* tst, teq, cmp, cmn */
name|result
operator|=
operator|(
name|unsigned
name|long
operator|)
name|nextpc
expr_stmt|;
break|break;
case|case
literal|0xc
case|:
comment|/*orr */
name|result
operator|=
name|operand1
operator||
name|operand2
expr_stmt|;
break|break;
case|case
literal|0xd
case|:
comment|/*mov */
comment|/* Always step into a function.  */
name|result
operator|=
name|operand2
expr_stmt|;
break|break;
case|case
literal|0xe
case|:
comment|/*bic */
name|result
operator|=
name|operand1
operator|&
operator|~
name|operand2
expr_stmt|;
break|break;
case|case
literal|0xf
case|:
comment|/*mvn */
name|result
operator|=
operator|~
name|operand2
expr_stmt|;
break|break;
block|}
name|nextpc
operator|=
operator|(
name|CORE_ADDR
operator|)
name|ADDR_BITS_REMOVE
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextpc
operator|==
name|pc
condition|)
name|error
argument_list|(
literal|"Infinite loop detected"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|0x4
case|:
case|case
literal|0x5
case|:
comment|/* data transfer */
case|case
literal|0x6
case|:
case|case
literal|0x7
case|:
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|20
argument_list|)
condition|)
block|{
comment|/* load */
if|if
condition|(
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|12
argument_list|,
literal|15
argument_list|)
operator|==
literal|15
condition|)
block|{
comment|/* rd == pc */
name|unsigned
name|long
name|rn
decl_stmt|;
name|unsigned
name|long
name|base
decl_stmt|;
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|22
argument_list|)
condition|)
name|error
argument_list|(
literal|"Illegal update to pc in instruction"
argument_list|)
expr_stmt|;
comment|/* byte write to PC */
name|rn
operator|=
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|16
argument_list|,
literal|19
argument_list|)
expr_stmt|;
name|base
operator|=
operator|(
name|rn
operator|==
literal|15
operator|)
condition|?
name|pc_val
operator|+
literal|8
else|:
name|read_register
argument_list|(
name|rn
argument_list|)
expr_stmt|;
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|24
argument_list|)
condition|)
block|{
comment|/* pre-indexed */
name|int
name|c
init|=
operator|(
name|status
operator|&
name|FLAG_C
operator|)
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|unsigned
name|long
name|offset
init|=
operator|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|25
argument_list|)
condition|?
name|shifted_reg_val
argument_list|(
name|this_instr
argument_list|,
name|c
argument_list|,
name|pc_val
argument_list|,
name|status
argument_list|)
else|:
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|0
argument_list|,
literal|11
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|23
argument_list|)
condition|)
name|base
operator|+=
name|offset
expr_stmt|;
else|else
name|base
operator|-=
name|offset
expr_stmt|;
block|}
name|nextpc
operator|=
operator|(
name|CORE_ADDR
operator|)
name|read_memory_integer
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|base
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|nextpc
operator|=
name|ADDR_BITS_REMOVE
argument_list|(
name|nextpc
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextpc
operator|==
name|pc
condition|)
name|error
argument_list|(
literal|"Infinite loop detected"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|0x8
case|:
case|case
literal|0x9
case|:
comment|/* block transfer */
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|20
argument_list|)
condition|)
block|{
comment|/* LDM */
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|15
argument_list|)
condition|)
block|{
comment|/* loading pc */
name|int
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|23
argument_list|)
condition|)
block|{
comment|/* up */
name|unsigned
name|long
name|reglist
init|=
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|0
argument_list|,
literal|14
argument_list|)
decl_stmt|;
name|offset
operator|=
name|bitcount
argument_list|(
name|reglist
argument_list|)
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|24
argument_list|)
condition|)
comment|/* pre */
name|offset
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|24
argument_list|)
condition|)
name|offset
operator|=
operator|-
literal|4
expr_stmt|;
block|{
name|unsigned
name|long
name|rn_val
init|=
name|read_register
argument_list|(
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|16
argument_list|,
literal|19
argument_list|)
argument_list|)
decl_stmt|;
name|nextpc
operator|=
operator|(
name|CORE_ADDR
operator|)
name|read_memory_integer
argument_list|(
call|(
name|CORE_ADDR
call|)
argument_list|(
name|rn_val
operator|+
name|offset
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|nextpc
operator|=
name|ADDR_BITS_REMOVE
argument_list|(
name|nextpc
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextpc
operator|==
name|pc
condition|)
name|error
argument_list|(
literal|"Infinite loop detected"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|0xb
case|:
comment|/* branch& link */
case|case
literal|0xa
case|:
comment|/* branch */
block|{
name|nextpc
operator|=
name|BranchDest
argument_list|(
name|pc
argument_list|,
name|this_instr
argument_list|)
expr_stmt|;
comment|/* BLX */
if|if
condition|(
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|28
argument_list|,
literal|31
argument_list|)
operator|==
name|INST_NV
condition|)
name|nextpc
operator||=
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|24
argument_list|)
operator|<<
literal|1
expr_stmt|;
name|nextpc
operator|=
name|ADDR_BITS_REMOVE
argument_list|(
name|nextpc
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextpc
operator|==
name|pc
condition|)
name|error
argument_list|(
literal|"Infinite loop detected"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|0xc
case|:
case|case
literal|0xd
case|:
case|case
literal|0xe
case|:
comment|/* coproc ops */
case|case
literal|0xf
case|:
comment|/* SWI */
break|break;
default|default:
name|fprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Bad bit-field extraction\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|pc
operator|)
return|;
block|}
block|}
return|return
name|nextpc
return|;
block|}
end_function

begin_comment
comment|/* single_step() is called just before we want to resume the inferior,    if we want to single-step it but there is no hardware or kernel    single-step support.  We find the target of the coming instruction    and breakpoint it.     single_step() is also called just after the inferior stops.  If we    had set up a simulated single-step, we undo our damage.  */
end_comment

begin_function
specifier|static
name|void
name|arm_software_single_step
parameter_list|(
name|enum
name|target_signal
name|sig
parameter_list|,
name|int
name|insert_bpt
parameter_list|)
block|{
specifier|static
name|int
name|next_pc
decl_stmt|;
comment|/* State between setting and unsetting.  */
specifier|static
name|char
name|break_mem
index|[
name|BREAKPOINT_MAX
index|]
decl_stmt|;
comment|/* Temporary storage for mem@bpt */
if|if
condition|(
name|insert_bpt
condition|)
block|{
name|next_pc
operator|=
name|arm_get_next_pc
argument_list|(
name|read_register
argument_list|(
name|ARM_PC_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|target_insert_breakpoint
argument_list|(
name|next_pc
argument_list|,
name|break_mem
argument_list|)
expr_stmt|;
block|}
else|else
name|target_remove_breakpoint
argument_list|(
name|next_pc
argument_list|,
name|break_mem
argument_list|)
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|"bfd-in2.h"
end_include

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_function
specifier|static
name|int
name|gdb_print_insn_arm
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
name|arm_pc_is_thumb
argument_list|(
name|memaddr
argument_list|)
condition|)
block|{
specifier|static
name|asymbol
modifier|*
name|asym
decl_stmt|;
specifier|static
name|combined_entry_type
name|ce
decl_stmt|;
specifier|static
name|struct
name|coff_symbol_struct
name|csym
decl_stmt|;
specifier|static
name|struct
name|bfd
name|fake_bfd
decl_stmt|;
specifier|static
name|bfd_target
name|fake_target
decl_stmt|;
if|if
condition|(
name|csym
operator|.
name|native
operator|==
name|NULL
condition|)
block|{
comment|/* Create a fake symbol vector containing a Thumb symbol. 	     This is solely so that the code in print_insn_little_arm()  	     and print_insn_big_arm() in opcodes/arm-dis.c will detect 	     the presence of a Thumb symbol and switch to decoding 	     Thumb instructions.  */
name|fake_target
operator|.
name|flavour
operator|=
name|bfd_target_coff_flavour
expr_stmt|;
name|fake_bfd
operator|.
name|xvec
operator|=
operator|&
name|fake_target
expr_stmt|;
name|ce
operator|.
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|=
name|C_THUMBEXTFUNC
expr_stmt|;
name|csym
operator|.
name|native
operator|=
operator|&
name|ce
expr_stmt|;
name|csym
operator|.
name|symbol
operator|.
name|the_bfd
operator|=
operator|&
name|fake_bfd
expr_stmt|;
name|csym
operator|.
name|symbol
operator|.
name|name
operator|=
literal|"fake"
expr_stmt|;
name|asym
operator|=
operator|(
name|asymbol
operator|*
operator|)
operator|&
name|csym
expr_stmt|;
block|}
name|memaddr
operator|=
name|UNMAKE_THUMB_ADDR
argument_list|(
name|memaddr
argument_list|)
expr_stmt|;
name|info
operator|->
name|symbols
operator|=
operator|&
name|asym
expr_stmt|;
block|}
else|else
name|info
operator|->
name|symbols
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|)
return|return
name|print_insn_big_arm
argument_list|(
name|memaddr
argument_list|,
name|info
argument_list|)
return|;
else|else
return|return
name|print_insn_little_arm
argument_list|(
name|memaddr
argument_list|,
name|info
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The following define instruction sequences that will cause ARM    cpu's to take an undefined instruction trap.  These are used to    signal a breakpoint to GDB.        The newer ARMv4T cpu's are capable of operating in ARM or Thumb    modes.  A different instruction is required for each mode.  The ARM    cpu's can also be big or little endian.  Thus four different    instructions are needed to support all cases.        Note: ARMv4 defines several new instructions that will take the    undefined instruction trap.  ARM7TDMI is nominally ARMv4T, but does    not in fact add the new instructions.  The new undefined    instructions in ARMv4 are all instructions that had no defined    behaviour in earlier chips.  There is no guarantee that they will    raise an exception, but may be treated as NOP's.  In practice, it    may only safe to rely on instructions matching:        3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1     1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0    C C C C 0 1 1 x x x x x x x x x x x x x x x x x x x x 1 x x x x        Even this may only true if the condition predicate is true. The    following use a condition predicate of ALWAYS so it is always TRUE.        There are other ways of forcing a breakpoint.  GNU/Linux, RISC iX,    and NetBSD all use a software interrupt rather than an undefined    instruction to force a trap.  This can be handled by by the    abi-specific code during establishment of the gdbarch vector.  */
end_comment

begin_comment
comment|/* NOTE rearnsha 2002-02-18: for now we allow a non-multi-arch gdb to    override these definitions.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ARM_LE_BREAKPOINT
end_ifndef

begin_define
define|#
directive|define
name|ARM_LE_BREAKPOINT
value|{0xFE,0xDE,0xFF,0xE7}
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ARM_BE_BREAKPOINT
end_ifndef

begin_define
define|#
directive|define
name|ARM_BE_BREAKPOINT
value|{0xE7,0xFF,0xDE,0xFE}
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|THUMB_LE_BREAKPOINT
end_ifndef

begin_define
define|#
directive|define
name|THUMB_LE_BREAKPOINT
value|{0xfe,0xdf}
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|THUMB_BE_BREAKPOINT
end_ifndef

begin_define
define|#
directive|define
name|THUMB_BE_BREAKPOINT
value|{0xdf,0xfe}
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
name|arm_default_arm_le_breakpoint
index|[]
init|=
name|ARM_LE_BREAKPOINT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|arm_default_arm_be_breakpoint
index|[]
init|=
name|ARM_BE_BREAKPOINT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|arm_default_thumb_le_breakpoint
index|[]
init|=
name|THUMB_LE_BREAKPOINT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|arm_default_thumb_be_breakpoint
index|[]
init|=
name|THUMB_BE_BREAKPOINT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Determine the type and size of breakpoint to insert at PCPTR.  Uses    the program counter value to determine whether a 16-bit or 32-bit    breakpoint should be used.  It returns a pointer to a string of    bytes that encode a breakpoint instruction, stores the length of    the string to *lenptr, and adjusts the program counter (if    necessary) to point to the actual memory location where the    breakpoint should be inserted.  */
end_comment

begin_comment
comment|/* XXX ??? from old tm-arm.h: if we're using RDP, then we're inserting    breakpoints and storing their handles instread of what was in    memory.  It is nice that this is the same size as a handle -    otherwise remote-rdp will have to change.  */
end_comment

begin_function
specifier|static
specifier|const
name|unsigned
name|char
modifier|*
name|arm_breakpoint_from_pc
parameter_list|(
name|CORE_ADDR
modifier|*
name|pcptr
parameter_list|,
name|int
modifier|*
name|lenptr
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
if|if
condition|(
name|arm_pc_is_thumb
argument_list|(
operator|*
name|pcptr
argument_list|)
condition|)
block|{
operator|*
name|pcptr
operator|=
name|UNMAKE_THUMB_ADDR
argument_list|(
operator|*
name|pcptr
argument_list|)
expr_stmt|;
operator|*
name|lenptr
operator|=
name|tdep
operator|->
name|thumb_breakpoint_size
expr_stmt|;
return|return
name|tdep
operator|->
name|thumb_breakpoint
return|;
block|}
else|else
block|{
operator|*
name|lenptr
operator|=
name|tdep
operator|->
name|arm_breakpoint_size
expr_stmt|;
return|return
name|tdep
operator|->
name|arm_breakpoint
return|;
block|}
block|}
end_function

begin_comment
comment|/* Extract from an array REGBUF containing the (raw) register state a    function return value of type TYPE, and copy that, in virtual    format, into VALBUF.  */
end_comment

begin_function
specifier|static
name|void
name|arm_extract_return_value
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|regcache
modifier|*
name|regs
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|)
block|{
name|bfd_byte
modifier|*
name|valbuf
init|=
name|dst
decl_stmt|;
if|if
condition|(
name|TYPE_CODE_FLT
operator|==
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|arm_get_fp_model
argument_list|(
name|current_gdbarch
argument_list|)
condition|)
block|{
case|case
name|ARM_FLOAT_FPA
case|:
block|{
comment|/* The value is in register F0 in internal format.  We need to 	       extract the raw value and then convert it to the desired 	       internal type.  */
name|bfd_byte
name|tmpbuf
index|[
name|FP_REGISTER_SIZE
index|]
decl_stmt|;
name|regcache_cooked_read
argument_list|(
name|regs
argument_list|,
name|ARM_F0_REGNUM
argument_list|,
name|tmpbuf
argument_list|)
expr_stmt|;
name|convert_from_extended
argument_list|(
name|floatformat_from_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|tmpbuf
argument_list|,
name|valbuf
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ARM_FLOAT_SOFT_FPA
case|:
case|case
name|ARM_FLOAT_SOFT_VFP
case|:
name|regcache_cooked_read
argument_list|(
name|regs
argument_list|,
name|ARM_A1_REGNUM
argument_list|,
name|valbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|>
literal|4
condition|)
name|regcache_cooked_read
argument_list|(
name|regs
argument_list|,
name|ARM_A1_REGNUM
operator|+
literal|1
argument_list|,
name|valbuf
operator|+
name|INT_REGISTER_SIZE
argument_list|)
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"arm_extract_return_value: Floating point model not supported"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_CHAR
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_BOOL
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_REF
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ENUM
condition|)
block|{
comment|/* If the the type is a plain integer, then the access is 	 straight-forward.  Otherwise we have to play around a bit more.  */
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|regno
init|=
name|ARM_A1_REGNUM
decl_stmt|;
name|ULONGEST
name|tmp
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* By using store_unsigned_integer we avoid having to do 	     anything special for small big-endian values.  */
name|regcache_cooked_read_unsigned
argument_list|(
name|regs
argument_list|,
name|regno
operator|++
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|valbuf
argument_list|,
operator|(
name|len
operator|>
name|INT_REGISTER_SIZE
condition|?
name|INT_REGISTER_SIZE
else|:
name|len
operator|)
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|len
operator|-=
name|INT_REGISTER_SIZE
expr_stmt|;
name|valbuf
operator|+=
name|INT_REGISTER_SIZE
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* For a structure or union the behaviour is as if the value had          been stored to word-aligned memory and then loaded into           registers with 32-bit load instruction(s).  */
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|regno
init|=
name|ARM_A1_REGNUM
decl_stmt|;
name|bfd_byte
name|tmpbuf
index|[
name|INT_REGISTER_SIZE
index|]
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|regcache_cooked_read
argument_list|(
name|regs
argument_list|,
name|regno
operator|++
argument_list|,
name|tmpbuf
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|valbuf
argument_list|,
name|tmpbuf
argument_list|,
name|len
operator|>
name|INT_REGISTER_SIZE
condition|?
name|INT_REGISTER_SIZE
else|:
name|len
argument_list|)
expr_stmt|;
name|len
operator|-=
name|INT_REGISTER_SIZE
expr_stmt|;
name|valbuf
operator|+=
name|INT_REGISTER_SIZE
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Extract from an array REGBUF containing the (raw) register state    the address in which a function should return its structure value.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|arm_extract_struct_value_address
parameter_list|(
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|)
block|{
name|ULONGEST
name|ret
decl_stmt|;
name|regcache_cooked_read_unsigned
argument_list|(
name|regcache
argument_list|,
name|ARM_A1_REGNUM
argument_list|,
operator|&
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Will a function return an aggregate type in memory or in a    register?  Return 0 if an aggregate type can be returned in a    register, 1 if it must be returned in memory.  */
end_comment

begin_function
specifier|static
name|int
name|arm_use_struct_convention
parameter_list|(
name|int
name|gcc_p
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|int
name|nRc
decl_stmt|;
name|enum
name|type_code
name|code
decl_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* In the ARM ABI, "integer" like aggregate types are returned in      registers.  For an aggregate type to be integer like, its size      must be less than or equal to DEPRECATED_REGISTER_SIZE and the      offset of each addressable subfield must be zero.  Note that bit      fields are not addressable, and all addressable subfields of      unions always start at offset zero.       This function is based on the behaviour of GCC 2.95.1.      See: gcc/arm.c: arm_return_in_memory() for details.       Note: All versions of GCC before GCC 2.95.2 do not set up the      parameters correctly for a function returning the following      structure: struct { float f;}; This should be returned in memory,      not a register.  Richard Earnshaw sent me a patch, but I do not      know of any way to detect if a function like the above has been      compiled with the correct calling convention.  */
comment|/* All aggregate types that won't fit in a register must be returned      in memory.  */
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|>
name|DEPRECATED_REGISTER_SIZE
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|/* The only aggregate types that can be returned in a register are      structs and unions.  Arrays must be returned in memory.  */
name|code
operator|=
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_CODE_STRUCT
operator|!=
name|code
operator|)
operator|&&
operator|(
name|TYPE_CODE_UNION
operator|!=
name|code
operator|)
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|/* Assume all other aggregate types can be returned in a register.      Run a check for structures, unions and arrays.  */
name|nRc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_CODE_STRUCT
operator|==
name|code
operator|)
operator|||
operator|(
name|TYPE_CODE_UNION
operator|==
name|code
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Need to check if this struct/union is "integer" like.  For          this to be true, its size must be less than or equal to          DEPRECATED_REGISTER_SIZE and the offset of each addressable          subfield must be zero.  Note that bit fields are not          addressable, and unions always start at offset zero.  If any          of the subfields is a floating point type, the struct/union          cannot be an integer type.  */
comment|/* For each field in the object, check:          1) Is it FP? --> yes, nRc = 1;          2) Is it addressable (bitpos != 0) and          not packed (bitsize == 0)?          --> yes, nRc = 1          */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|enum
name|type_code
name|field_type_code
decl_stmt|;
name|field_type_code
operator|=
name|TYPE_CODE
argument_list|(
name|check_typedef
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Is it a floating point type field?  */
if|if
condition|(
name|field_type_code
operator|==
name|TYPE_CODE_FLT
condition|)
block|{
name|nRc
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* If bitpos != 0, then we have to care about it.  */
if|if
condition|(
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Bitfields are not addressable.  If the field bitsize is  	         zero, then the field is not packed.  Hence it cannot be 	         a bitfield or any other packed type.  */
if|if
condition|(
name|TYPE_FIELD_BITSIZE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|==
literal|0
condition|)
block|{
name|nRc
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
return|return
name|nRc
return|;
block|}
end_function

begin_comment
comment|/* Write into appropriate registers a function return value of type    TYPE, given in virtual format.  */
end_comment

begin_function
specifier|static
name|void
name|arm_store_return_value
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|regcache
modifier|*
name|regs
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|)
block|{
specifier|const
name|bfd_byte
modifier|*
name|valbuf
init|=
name|src
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FLT
condition|)
block|{
name|char
name|buf
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
switch|switch
condition|(
name|arm_get_fp_model
argument_list|(
name|current_gdbarch
argument_list|)
condition|)
block|{
case|case
name|ARM_FLOAT_FPA
case|:
name|convert_to_extended
argument_list|(
name|floatformat_from_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|buf
argument_list|,
name|valbuf
argument_list|)
expr_stmt|;
name|regcache_cooked_write
argument_list|(
name|regs
argument_list|,
name|ARM_F0_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARM_FLOAT_SOFT_FPA
case|:
case|case
name|ARM_FLOAT_SOFT_VFP
case|:
name|regcache_cooked_write
argument_list|(
name|regs
argument_list|,
name|ARM_A1_REGNUM
argument_list|,
name|valbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|>
literal|4
condition|)
name|regcache_cooked_write
argument_list|(
name|regs
argument_list|,
name|ARM_A1_REGNUM
operator|+
literal|1
argument_list|,
name|valbuf
operator|+
name|INT_REGISTER_SIZE
argument_list|)
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"arm_store_return_value: Floating point model not supported"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_CHAR
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_BOOL
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_REF
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ENUM
condition|)
block|{
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|<=
literal|4
condition|)
block|{
comment|/* Values of one word or less are zero/sign-extended and 	     returned in r0.  */
name|bfd_byte
name|tmpbuf
index|[
name|INT_REGISTER_SIZE
index|]
decl_stmt|;
name|LONGEST
name|val
init|=
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valbuf
argument_list|)
decl_stmt|;
name|store_signed_integer
argument_list|(
name|tmpbuf
argument_list|,
name|INT_REGISTER_SIZE
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|regcache_cooked_write
argument_list|(
name|regs
argument_list|,
name|ARM_A1_REGNUM
argument_list|,
name|tmpbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Integral values greater than one word are stored in consecutive 	     registers starting with r0.  This will always be a multiple of 	     the regiser size.  */
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|regno
init|=
name|ARM_A1_REGNUM
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|regcache_cooked_write
argument_list|(
name|regs
argument_list|,
name|regno
operator|++
argument_list|,
name|valbuf
argument_list|)
expr_stmt|;
name|len
operator|-=
name|INT_REGISTER_SIZE
expr_stmt|;
name|valbuf
operator|+=
name|INT_REGISTER_SIZE
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* For a structure or union the behaviour is as if the value had          been stored to word-aligned memory and then loaded into           registers with 32-bit load instruction(s).  */
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|regno
init|=
name|ARM_A1_REGNUM
decl_stmt|;
name|bfd_byte
name|tmpbuf
index|[
name|INT_REGISTER_SIZE
index|]
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|tmpbuf
argument_list|,
name|valbuf
argument_list|,
name|len
operator|>
name|INT_REGISTER_SIZE
condition|?
name|INT_REGISTER_SIZE
else|:
name|len
argument_list|)
expr_stmt|;
name|regcache_cooked_write
argument_list|(
name|regs
argument_list|,
name|regno
operator|++
argument_list|,
name|tmpbuf
argument_list|)
expr_stmt|;
name|len
operator|-=
name|INT_REGISTER_SIZE
expr_stmt|;
name|valbuf
operator|+=
name|INT_REGISTER_SIZE
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|arm_get_longjmp_target
parameter_list|(
name|CORE_ADDR
modifier|*
name|pc
parameter_list|)
block|{
name|CORE_ADDR
name|jb_addr
decl_stmt|;
name|char
name|buf
index|[
name|INT_REGISTER_SIZE
index|]
decl_stmt|;
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
name|jb_addr
operator|=
name|read_register
argument_list|(
name|ARM_A1_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|jb_addr
operator|+
name|tdep
operator|->
name|jb_pc
operator|*
name|tdep
operator|->
name|jb_elt_size
argument_list|,
name|buf
argument_list|,
name|INT_REGISTER_SIZE
argument_list|)
condition|)
return|return
literal|0
return|;
operator|*
name|pc
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|INT_REGISTER_SIZE
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if the PC is inside a thumb call thunk.  */
end_comment

begin_function
name|int
name|arm_in_call_stub
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|CORE_ADDR
name|start_addr
decl_stmt|;
comment|/* Find the starting address of the function containing the PC.  If      the caller didn't give us a name, look it up at the same time.  */
if|if
condition|(
literal|0
operator|==
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
name|name
condition|?
name|NULL
else|:
operator|&
name|name
argument_list|,
operator|&
name|start_addr
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_call_via_r"
argument_list|,
literal|11
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If PC is in a Thumb call or return stub, return the address of the    target PC, which is in a register.  The thunk functions are called    _called_via_xx, where x is the register name.  The possible names    are r0-r9, sl, fp, ip, sp, and lr.  */
end_comment

begin_function
name|CORE_ADDR
name|arm_skip_stub
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|CORE_ADDR
name|start_addr
decl_stmt|;
comment|/* Find the starting address and name of the function containing the PC.  */
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|start_addr
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Call thunks always start with "_call_via_".  */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_call_via_"
argument_list|,
literal|10
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Use the name suffix to determine which register contains the          target PC.  */
specifier|static
name|char
modifier|*
name|table
index|[
literal|15
index|]
init|=
block|{
literal|"r0"
block|,
literal|"r1"
block|,
literal|"r2"
block|,
literal|"r3"
block|,
literal|"r4"
block|,
literal|"r5"
block|,
literal|"r6"
block|,
literal|"r7"
block|,
literal|"r8"
block|,
literal|"r9"
block|,
literal|"sl"
block|,
literal|"fp"
block|,
literal|"ip"
block|,
literal|"sp"
block|,
literal|"lr"
block|}
decl_stmt|;
name|int
name|regno
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<=
literal|14
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|name
index|[
literal|10
index|]
argument_list|,
name|table
index|[
name|regno
index|]
argument_list|)
operator|==
literal|0
condition|)
return|return
name|read_register
argument_list|(
name|regno
argument_list|)
return|;
block|}
return|return
literal|0
return|;
comment|/* not a stub */
block|}
end_function

begin_function
specifier|static
name|void
name|set_arm_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\"set arm\" must be followed by an apporpriate subcommand.\n"
argument_list|)
expr_stmt|;
name|help_list
argument_list|(
name|setarmcmdlist
argument_list|,
literal|"set arm "
argument_list|,
name|all_commands
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_arm_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|cmd_show_list
argument_list|(
name|showarmcmdlist
argument_list|,
name|from_tty
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|enum
name|arm_float_model
name|arm_get_fp_model
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|)
block|{
if|if
condition|(
name|arm_fp_model
operator|==
name|ARM_FLOAT_AUTO
condition|)
return|return
name|gdbarch_tdep
argument_list|(
name|gdbarch
argument_list|)
operator|->
name|fp_model
return|;
return|return
name|arm_fp_model
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_set_fp
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|)
block|{
name|enum
name|arm_float_model
name|fp_model
init|=
name|arm_get_fp_model
argument_list|(
name|gdbarch
argument_list|)
decl_stmt|;
if|if
condition|(
name|gdbarch_byte_order
argument_list|(
name|gdbarch
argument_list|)
operator|==
name|BFD_ENDIAN_LITTLE
operator|&&
operator|(
name|fp_model
operator|==
name|ARM_FLOAT_SOFT_FPA
operator|||
name|fp_model
operator|==
name|ARM_FLOAT_FPA
operator|)
condition|)
block|{
name|set_gdbarch_double_format
argument_list|(
name|gdbarch
argument_list|,
operator|&
name|floatformat_ieee_double_littlebyte_bigword
argument_list|)
expr_stmt|;
name|set_gdbarch_long_double_format
argument_list|(
name|gdbarch
argument_list|,
operator|&
name|floatformat_ieee_double_littlebyte_bigword
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|set_gdbarch_double_format
argument_list|(
name|gdbarch
argument_list|,
operator|&
name|floatformat_ieee_double_little
argument_list|)
expr_stmt|;
name|set_gdbarch_long_double_format
argument_list|(
name|gdbarch
argument_list|,
operator|&
name|floatformat_ieee_double_little
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|set_fp_model_sfunc
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|enum
name|arm_float_model
name|fp_model
decl_stmt|;
for|for
control|(
name|fp_model
operator|=
name|ARM_FLOAT_AUTO
init|;
name|fp_model
operator|!=
name|ARM_FLOAT_LAST
condition|;
name|fp_model
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|current_fp_model
argument_list|,
name|fp_model_strings
index|[
name|fp_model
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|arm_fp_model
operator|=
name|fp_model
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fp_model
operator|==
name|ARM_FLOAT_LAST
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Invalid fp model accepted: %s."
argument_list|,
name|current_fp_model
argument_list|)
expr_stmt|;
if|if
condition|(
name|gdbarch_bfd_arch_info
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|arch
operator|==
name|bfd_arch_arm
condition|)
name|arm_set_fp
argument_list|(
name|current_gdbarch
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_fp_model
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
if|if
condition|(
name|arm_fp_model
operator|==
name|ARM_FLOAT_AUTO
operator|&&
name|gdbarch_bfd_arch_info
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|arch
operator|==
name|bfd_arch_arm
condition|)
name|printf_filtered
argument_list|(
literal|"  - the default for the current ABI is \"%s\".\n"
argument_list|,
name|fp_model_strings
index|[
name|tdep
operator|->
name|fp_model
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If the user changes the register disassembly style used for info    register and other commands, we have to also switch the style used    in opcodes for disassembly output.  This function is run in the "set    arm disassembly" command, and does that.  */
end_comment

begin_function
specifier|static
name|void
name|set_disassembly_style_sfunc
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|set_disassembly_style
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the ARM register name corresponding to register I.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|arm_register_name
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|arm_register_names
index|[
name|i
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_disassembly_style
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|setname
decl_stmt|,
modifier|*
name|setdesc
decl_stmt|,
modifier|*
modifier|*
name|regnames
decl_stmt|;
name|int
name|numregs
decl_stmt|,
name|j
decl_stmt|;
comment|/* Find the style that the user wants in the opcodes table.  */
name|int
name|current
init|=
literal|0
decl_stmt|;
name|numregs
operator|=
name|get_arm_regnames
argument_list|(
name|current
argument_list|,
operator|&
name|setname
argument_list|,
operator|&
name|setdesc
argument_list|,
operator|&
name|regnames
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|disassembly_style
operator|!=
name|setname
operator|)
operator|&&
operator|(
name|current
operator|<
name|num_disassembly_options
operator|)
condition|)
name|get_arm_regnames
argument_list|(
operator|++
name|current
argument_list|,
operator|&
name|setname
argument_list|,
operator|&
name|setdesc
argument_list|,
operator|&
name|regnames
argument_list|)
expr_stmt|;
name|current_option
operator|=
name|current
expr_stmt|;
comment|/* Fill our copy.  */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|numregs
condition|;
name|j
operator|++
control|)
name|arm_register_names
index|[
name|j
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|regnames
index|[
name|j
index|]
expr_stmt|;
comment|/* Adjust case.  */
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|regnames
index|[
name|ARM_PC_REGNUM
index|]
argument_list|)
condition|)
block|{
name|arm_register_names
index|[
name|ARM_FPS_REGNUM
index|]
operator|=
literal|"FPS"
expr_stmt|;
name|arm_register_names
index|[
name|ARM_PS_REGNUM
index|]
operator|=
literal|"CPSR"
expr_stmt|;
block|}
else|else
block|{
name|arm_register_names
index|[
name|ARM_FPS_REGNUM
index|]
operator|=
literal|"fps"
expr_stmt|;
name|arm_register_names
index|[
name|ARM_PS_REGNUM
index|]
operator|=
literal|"cpsr"
expr_stmt|;
block|}
comment|/* Synchronize the disassembler.  */
name|set_arm_regname_option
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* arm_othernames implements the "othernames" command.  This is deprecated    by the "set arm disassembly" command.  */
end_comment

begin_function
specifier|static
name|void
name|arm_othernames
parameter_list|(
name|char
modifier|*
name|names
parameter_list|,
name|int
name|n
parameter_list|)
block|{
comment|/* Circle through the various flavors.  */
name|current_option
operator|=
operator|(
name|current_option
operator|+
literal|1
operator|)
operator|%
name|num_disassembly_options
expr_stmt|;
name|disassembly_style
operator|=
name|valid_disassembly_styles
index|[
name|current_option
index|]
expr_stmt|;
name|set_disassembly_style
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Test whether the coff symbol specific value corresponds to a Thumb    function.  */
end_comment

begin_function
specifier|static
name|int
name|coff_sym_is_thumb
parameter_list|(
name|int
name|val
parameter_list|)
block|{
return|return
operator|(
name|val
operator|==
name|C_THUMBEXT
operator|||
name|val
operator|==
name|C_THUMBSTAT
operator|||
name|val
operator|==
name|C_THUMBEXTFUNC
operator|||
name|val
operator|==
name|C_THUMBSTATFUNC
operator|||
name|val
operator|==
name|C_THUMBLABEL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* arm_coff_make_msymbol_special()    arm_elf_make_msymbol_special()        These functions test whether the COFF or ELF symbol corresponds to    an address in thumb code, and set a "special" bit in a minimal    symbol to indicate that it does.  */
end_comment

begin_function
specifier|static
name|void
name|arm_elf_make_msymbol_special
parameter_list|(
name|asymbol
modifier|*
name|sym
parameter_list|,
name|struct
name|minimal_symbol
modifier|*
name|msym
parameter_list|)
block|{
comment|/* Thumb symbols are of type STT_LOPROC, (synonymous with      STT_ARM_TFUNC).  */
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
operator|(
operator|(
name|elf_symbol_type
operator|*
operator|)
name|sym
operator|)
operator|->
name|internal_elf_sym
operator|.
name|st_info
argument_list|)
operator|==
name|STT_LOPROC
condition|)
name|MSYMBOL_SET_SPECIAL
argument_list|(
name|msym
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_coff_make_msymbol_special
parameter_list|(
name|int
name|val
parameter_list|,
name|struct
name|minimal_symbol
modifier|*
name|msym
parameter_list|)
block|{
if|if
condition|(
name|coff_sym_is_thumb
argument_list|(
name|val
argument_list|)
condition|)
name|MSYMBOL_SET_SPECIAL
argument_list|(
name|msym
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_write_pc
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|ptid_t
name|ptid
parameter_list|)
block|{
name|write_register_pid
argument_list|(
name|ARM_PC_REGNUM
argument_list|,
name|pc
argument_list|,
name|ptid
argument_list|)
expr_stmt|;
comment|/* If necessary, set the T bit.  */
if|if
condition|(
name|arm_apcs_32
condition|)
block|{
name|CORE_ADDR
name|val
init|=
name|read_register_pid
argument_list|(
name|ARM_PS_REGNUM
argument_list|,
name|ptid
argument_list|)
decl_stmt|;
if|if
condition|(
name|arm_pc_is_thumb
argument_list|(
name|pc
argument_list|)
condition|)
name|write_register_pid
argument_list|(
name|ARM_PS_REGNUM
argument_list|,
name|val
operator||
literal|0x20
argument_list|,
name|ptid
argument_list|)
expr_stmt|;
else|else
name|write_register_pid
argument_list|(
name|ARM_PS_REGNUM
argument_list|,
name|val
operator|&
operator|~
operator|(
name|CORE_ADDR
operator|)
literal|0x20
argument_list|,
name|ptid
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|enum
name|gdb_osabi
name|arm_elf_osabi_sniffer
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|unsigned
name|int
name|elfosabi
decl_stmt|,
name|eflags
decl_stmt|;
name|enum
name|gdb_osabi
name|osabi
init|=
name|GDB_OSABI_UNKNOWN
decl_stmt|;
name|elfosabi
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_ident
index|[
name|EI_OSABI
index|]
expr_stmt|;
switch|switch
condition|(
name|elfosabi
condition|)
block|{
case|case
name|ELFOSABI_NONE
case|:
comment|/* When elfosabi is ELFOSABI_NONE (0), then the ELF structures in the 	 file are conforming to the base specification for that machine  	 (there are no OS-specific extensions).  In order to determine the  	 real OS in use we must look for OS notes that have been added.  */
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|generic_elf_osabi_sniff_abi_tag_sections
argument_list|,
operator|&
name|osabi
argument_list|)
expr_stmt|;
if|if
condition|(
name|osabi
operator|==
name|GDB_OSABI_UNKNOWN
condition|)
block|{
comment|/* Existing ARM tools don't set this field, so look at the EI_FLAGS 	     field for more information.  */
name|eflags
operator|=
name|EF_ARM_EABI_VERSION
argument_list|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|eflags
condition|)
block|{
case|case
name|EF_ARM_EABI_VER1
case|:
name|osabi
operator|=
name|GDB_OSABI_ARM_EABI_V1
expr_stmt|;
break|break;
case|case
name|EF_ARM_EABI_VER2
case|:
name|osabi
operator|=
name|GDB_OSABI_ARM_EABI_V2
expr_stmt|;
break|break;
case|case
name|EF_ARM_EABI_VER3
case|:
case|case
name|EF_ARM_EABI_VER4
case|:
case|case
name|EF_ARM_EABI_VER5
case|:
comment|/* 	       * GDB does not support these EABI versions. Fallback 	       * to the highest known to make the KGDB working with 	       * kernel ELF image. 	       */
name|osabi
operator|=
name|GDB_OSABI_ARM_EABI_V2
expr_stmt|;
name|printf
argument_list|(
literal|"\n%s:%d "
literal|"arm_elf_osabi_sniffer: Unsupported ARM EABI "
literal|"version 0x%x, falling back to 0x%x\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|eflags
argument_list|,
name|EF_ARM_EABI_VER2
argument_list|)
expr_stmt|;
break|break;
case|case
name|EF_ARM_EABI_UNKNOWN
case|:
comment|/* Assume GNU tools.  */
name|osabi
operator|=
name|GDB_OSABI_ARM_APCS
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"arm_elf_osabi_sniffer: Unknown ARM EABI "
literal|"version 0x%x"
argument_list|,
name|eflags
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ELFOSABI_ARM
case|:
comment|/* GNU tools use this value.  Check note sections in this case, 	 as well.  */
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|generic_elf_osabi_sniff_abi_tag_sections
argument_list|,
operator|&
name|osabi
argument_list|)
expr_stmt|;
if|if
condition|(
name|osabi
operator|==
name|GDB_OSABI_UNKNOWN
condition|)
block|{
comment|/* Assume APCS ABI.  */
name|osabi
operator|=
name|GDB_OSABI_ARM_APCS
expr_stmt|;
block|}
break|break;
case|case
name|ELFOSABI_FREEBSD
case|:
name|osabi
operator|=
name|GDB_OSABI_FREEBSD_ELF
expr_stmt|;
break|break;
case|case
name|ELFOSABI_NETBSD
case|:
name|osabi
operator|=
name|GDB_OSABI_NETBSD_ELF
expr_stmt|;
break|break;
case|case
name|ELFOSABI_LINUX
case|:
name|osabi
operator|=
name|GDB_OSABI_LINUX
expr_stmt|;
break|break;
block|}
return|return
name|osabi
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Initialize the current architecture based on INFO.  If possible,    re-use an architecture from ARCHES, which is a list of    architectures already created during this debugging session.     Called e.g. at program startup, when reading a core file, and when    reading a binary file.  */
end_comment

begin_function
specifier|static
name|struct
name|gdbarch
modifier|*
name|arm_gdbarch_init
parameter_list|(
name|struct
name|gdbarch_info
name|info
parameter_list|,
name|struct
name|gdbarch_list
modifier|*
name|arches
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
decl_stmt|;
name|struct
name|gdbarch
modifier|*
name|gdbarch
decl_stmt|;
comment|/* Try to deterimine the ABI of the object we are loading.  */
if|if
condition|(
name|info
operator|.
name|abfd
operator|!=
name|NULL
operator|&&
name|info
operator|.
name|osabi
operator|==
name|GDB_OSABI_UNKNOWN
condition|)
block|{
switch|switch
condition|(
name|bfd_get_flavour
argument_list|(
name|info
operator|.
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_target_aout_flavour
case|:
comment|/* Assume it's an old APCS-style ABI.  */
name|info
operator|.
name|osabi
operator|=
name|GDB_OSABI_ARM_APCS
expr_stmt|;
break|break;
case|case
name|bfd_target_coff_flavour
case|:
comment|/* Assume it's an old APCS-style ABI.  */
comment|/* XXX WinCE?  */
name|info
operator|.
name|osabi
operator|=
name|GDB_OSABI_ARM_APCS
expr_stmt|;
break|break;
default|default:
comment|/* Leave it as "unknown".  */
break|break;
block|}
block|}
comment|/* If there is already a candidate, use it.  */
name|arches
operator|=
name|gdbarch_list_lookup_by_info
argument_list|(
name|arches
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|arches
operator|!=
name|NULL
condition|)
return|return
name|arches
operator|->
name|gdbarch
return|;
name|tdep
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|gdbarch_tdep
argument_list|)
argument_list|)
expr_stmt|;
name|gdbarch
operator|=
name|gdbarch_alloc
argument_list|(
operator|&
name|info
argument_list|,
name|tdep
argument_list|)
expr_stmt|;
comment|/* We used to default to FPA for generic ARM, but almost nobody uses that      now, and we now provide a way for the user to force the model.  So       default to the most useful variant.  */
name|tdep
operator|->
name|fp_model
operator|=
name|ARM_FLOAT_SOFT_FPA
expr_stmt|;
comment|/* Breakpoints.  */
switch|switch
condition|(
name|info
operator|.
name|byte_order
condition|)
block|{
case|case
name|BFD_ENDIAN_BIG
case|:
name|tdep
operator|->
name|arm_breakpoint
operator|=
name|arm_default_arm_be_breakpoint
expr_stmt|;
name|tdep
operator|->
name|arm_breakpoint_size
operator|=
sizeof|sizeof
argument_list|(
name|arm_default_arm_be_breakpoint
argument_list|)
expr_stmt|;
name|tdep
operator|->
name|thumb_breakpoint
operator|=
name|arm_default_thumb_be_breakpoint
expr_stmt|;
name|tdep
operator|->
name|thumb_breakpoint_size
operator|=
sizeof|sizeof
argument_list|(
name|arm_default_thumb_be_breakpoint
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_ENDIAN_LITTLE
case|:
name|tdep
operator|->
name|arm_breakpoint
operator|=
name|arm_default_arm_le_breakpoint
expr_stmt|;
name|tdep
operator|->
name|arm_breakpoint_size
operator|=
sizeof|sizeof
argument_list|(
name|arm_default_arm_le_breakpoint
argument_list|)
expr_stmt|;
name|tdep
operator|->
name|thumb_breakpoint
operator|=
name|arm_default_thumb_le_breakpoint
expr_stmt|;
name|tdep
operator|->
name|thumb_breakpoint_size
operator|=
sizeof|sizeof
argument_list|(
name|arm_default_thumb_le_breakpoint
argument_list|)
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"arm_gdbarch_init: bad byte order for float format"
argument_list|)
expr_stmt|;
block|}
comment|/* On ARM targets char defaults to unsigned.  */
name|set_gdbarch_char_signed
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* This should be low enough for everything.  */
name|tdep
operator|->
name|lowest_pc
operator|=
literal|0x20
expr_stmt|;
name|tdep
operator|->
name|jb_pc
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Longjump support not enabled by default.  */
name|set_gdbarch_deprecated_call_dummy_words
argument_list|(
name|gdbarch
argument_list|,
name|arm_call_dummy_words
argument_list|)
expr_stmt|;
name|set_gdbarch_deprecated_sizeof_call_dummy_words
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_gdbarch_push_dummy_call
argument_list|(
name|gdbarch
argument_list|,
name|arm_push_dummy_call
argument_list|)
expr_stmt|;
name|set_gdbarch_write_pc
argument_list|(
name|gdbarch
argument_list|,
name|arm_write_pc
argument_list|)
expr_stmt|;
comment|/* Frame handling.  */
name|set_gdbarch_unwind_dummy_id
argument_list|(
name|gdbarch
argument_list|,
name|arm_unwind_dummy_id
argument_list|)
expr_stmt|;
name|set_gdbarch_unwind_pc
argument_list|(
name|gdbarch
argument_list|,
name|arm_unwind_pc
argument_list|)
expr_stmt|;
name|set_gdbarch_unwind_sp
argument_list|(
name|gdbarch
argument_list|,
name|arm_unwind_sp
argument_list|)
expr_stmt|;
name|set_gdbarch_deprecated_frameless_function_invocation
argument_list|(
name|gdbarch
argument_list|,
name|arm_frameless_function_invocation
argument_list|)
expr_stmt|;
name|frame_base_set_default
argument_list|(
name|gdbarch
argument_list|,
operator|&
name|arm_normal_base
argument_list|)
expr_stmt|;
comment|/* Address manipulation.  */
name|set_gdbarch_smash_text_address
argument_list|(
name|gdbarch
argument_list|,
name|arm_smash_text_address
argument_list|)
expr_stmt|;
name|set_gdbarch_addr_bits_remove
argument_list|(
name|gdbarch
argument_list|,
name|arm_addr_bits_remove
argument_list|)
expr_stmt|;
comment|/* Advance PC across function entry code.  */
name|set_gdbarch_skip_prologue
argument_list|(
name|gdbarch
argument_list|,
name|arm_skip_prologue
argument_list|)
expr_stmt|;
comment|/* Get the PC when a frame might not be available.  */
name|set_gdbarch_deprecated_saved_pc_after_call
argument_list|(
name|gdbarch
argument_list|,
name|arm_saved_pc_after_call
argument_list|)
expr_stmt|;
comment|/* The stack grows downward.  */
name|set_gdbarch_inner_than
argument_list|(
name|gdbarch
argument_list|,
name|core_addr_lessthan
argument_list|)
expr_stmt|;
comment|/* Breakpoint manipulation.  */
name|set_gdbarch_breakpoint_from_pc
argument_list|(
name|gdbarch
argument_list|,
name|arm_breakpoint_from_pc
argument_list|)
expr_stmt|;
comment|/* Information about registers, etc.  */
name|set_gdbarch_print_float_info
argument_list|(
name|gdbarch
argument_list|,
name|arm_print_float_info
argument_list|)
expr_stmt|;
name|set_gdbarch_deprecated_fp_regnum
argument_list|(
name|gdbarch
argument_list|,
name|ARM_FP_REGNUM
argument_list|)
expr_stmt|;
comment|/* ??? */
name|set_gdbarch_sp_regnum
argument_list|(
name|gdbarch
argument_list|,
name|ARM_SP_REGNUM
argument_list|)
expr_stmt|;
name|set_gdbarch_pc_regnum
argument_list|(
name|gdbarch
argument_list|,
name|ARM_PC_REGNUM
argument_list|)
expr_stmt|;
name|set_gdbarch_deprecated_register_byte
argument_list|(
name|gdbarch
argument_list|,
name|arm_register_byte
argument_list|)
expr_stmt|;
name|set_gdbarch_deprecated_register_bytes
argument_list|(
name|gdbarch
argument_list|,
operator|(
name|NUM_GREGS
operator|*
name|INT_REGISTER_SIZE
operator|+
name|NUM_FREGS
operator|*
name|FP_REGISTER_SIZE
operator|+
name|NUM_SREGS
operator|*
name|STATUS_REGISTER_SIZE
operator|)
argument_list|)
expr_stmt|;
name|set_gdbarch_num_regs
argument_list|(
name|gdbarch
argument_list|,
name|NUM_GREGS
operator|+
name|NUM_FREGS
operator|+
name|NUM_SREGS
argument_list|)
expr_stmt|;
name|set_gdbarch_register_type
argument_list|(
name|gdbarch
argument_list|,
name|arm_register_type
argument_list|)
expr_stmt|;
comment|/* Internal<-> external register number maps.  */
name|set_gdbarch_register_sim_regno
argument_list|(
name|gdbarch
argument_list|,
name|arm_register_sim_regno
argument_list|)
expr_stmt|;
comment|/* Integer registers are 4 bytes.  */
name|set_gdbarch_deprecated_register_size
argument_list|(
name|gdbarch
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|set_gdbarch_register_name
argument_list|(
name|gdbarch
argument_list|,
name|arm_register_name
argument_list|)
expr_stmt|;
comment|/* Returning results.  */
name|set_gdbarch_extract_return_value
argument_list|(
name|gdbarch
argument_list|,
name|arm_extract_return_value
argument_list|)
expr_stmt|;
name|set_gdbarch_store_return_value
argument_list|(
name|gdbarch
argument_list|,
name|arm_store_return_value
argument_list|)
expr_stmt|;
name|set_gdbarch_use_struct_convention
argument_list|(
name|gdbarch
argument_list|,
name|arm_use_struct_convention
argument_list|)
expr_stmt|;
name|set_gdbarch_deprecated_extract_struct_value_address
argument_list|(
name|gdbarch
argument_list|,
name|arm_extract_struct_value_address
argument_list|)
expr_stmt|;
comment|/* Single stepping.  */
comment|/* XXX For an RDI target we should ask the target if it can single-step.  */
name|set_gdbarch_software_single_step
argument_list|(
name|gdbarch
argument_list|,
name|arm_software_single_step
argument_list|)
expr_stmt|;
comment|/* Disassembly.  */
name|set_gdbarch_print_insn
argument_list|(
name|gdbarch
argument_list|,
name|gdb_print_insn_arm
argument_list|)
expr_stmt|;
comment|/* Minsymbol frobbing.  */
name|set_gdbarch_elf_make_msymbol_special
argument_list|(
name|gdbarch
argument_list|,
name|arm_elf_make_msymbol_special
argument_list|)
expr_stmt|;
name|set_gdbarch_coff_make_msymbol_special
argument_list|(
name|gdbarch
argument_list|,
name|arm_coff_make_msymbol_special
argument_list|)
expr_stmt|;
comment|/* Hook in the ABI-specific overrides, if they have been registered.  */
name|gdbarch_init_osabi
argument_list|(
name|info
argument_list|,
name|gdbarch
argument_list|)
expr_stmt|;
comment|/* Add some default predicates.  */
name|frame_unwind_append_sniffer
argument_list|(
name|gdbarch
argument_list|,
name|arm_sigtramp_unwind_sniffer
argument_list|)
expr_stmt|;
name|frame_unwind_append_sniffer
argument_list|(
name|gdbarch
argument_list|,
name|arm_prologue_unwind_sniffer
argument_list|)
expr_stmt|;
comment|/* Now we have tuned the configuration, set a few final things,      based on what the OS ABI has told us.  */
if|if
condition|(
name|tdep
operator|->
name|jb_pc
operator|>=
literal|0
condition|)
name|set_gdbarch_get_longjmp_target
argument_list|(
name|gdbarch
argument_list|,
name|arm_get_longjmp_target
argument_list|)
expr_stmt|;
comment|/* Floating point sizes and format.  */
switch|switch
condition|(
name|info
operator|.
name|byte_order
condition|)
block|{
case|case
name|BFD_ENDIAN_BIG
case|:
name|set_gdbarch_float_format
argument_list|(
name|gdbarch
argument_list|,
operator|&
name|floatformat_ieee_single_big
argument_list|)
expr_stmt|;
name|set_gdbarch_double_format
argument_list|(
name|gdbarch
argument_list|,
operator|&
name|floatformat_ieee_double_big
argument_list|)
expr_stmt|;
name|set_gdbarch_long_double_format
argument_list|(
name|gdbarch
argument_list|,
operator|&
name|floatformat_ieee_double_big
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_ENDIAN_LITTLE
case|:
name|set_gdbarch_float_format
argument_list|(
name|gdbarch
argument_list|,
operator|&
name|floatformat_ieee_single_little
argument_list|)
expr_stmt|;
name|arm_set_fp
argument_list|(
name|gdbarch
argument_list|)
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"arm_gdbarch_init: bad byte order for float format"
argument_list|)
expr_stmt|;
block|}
return|return
name|gdbarch
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_dump_tdep
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|current_gdbarch
parameter_list|,
name|struct
name|ui_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
if|if
condition|(
name|tdep
operator|==
name|NULL
condition|)
return|return;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"arm_dump_tdep: Lowest pc = 0x%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|tdep
operator|->
name|lowest_pc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_init_abi_eabi_v1
parameter_list|(
name|struct
name|gdbarch_info
name|info
parameter_list|,
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|)
block|{
comment|/* Place-holder.  */
block|}
end_function

begin_function
specifier|static
name|void
name|arm_init_abi_eabi_v2
parameter_list|(
name|struct
name|gdbarch_info
name|info
parameter_list|,
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|)
block|{
comment|/* Place-holder.  */
block|}
end_function

begin_function
specifier|static
name|void
name|arm_init_abi_apcs
parameter_list|(
name|struct
name|gdbarch_info
name|info
parameter_list|,
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|)
block|{
comment|/* Place-holder.  */
block|}
end_function

begin_decl_stmt
specifier|extern
name|initialize_file_ftype
name|_initialize_arm_tdep
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -Wmissing-prototypes */
end_comment

begin_function
name|void
name|_initialize_arm_tdep
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ui_file
modifier|*
name|stb
decl_stmt|;
name|long
name|length
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|new_set
decl_stmt|,
modifier|*
name|new_show
decl_stmt|;
specifier|const
name|char
modifier|*
name|setname
decl_stmt|;
specifier|const
name|char
modifier|*
name|setdesc
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|regnames
decl_stmt|;
name|int
name|numregs
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|static
name|char
modifier|*
name|helptext
decl_stmt|;
name|gdbarch_register
argument_list|(
name|bfd_arch_arm
argument_list|,
name|arm_gdbarch_init
argument_list|,
name|arm_dump_tdep
argument_list|)
expr_stmt|;
comment|/* Register an ELF OS ABI sniffer for ARM binaries.  */
name|gdbarch_register_osabi_sniffer
argument_list|(
name|bfd_arch_arm
argument_list|,
name|bfd_target_elf_flavour
argument_list|,
name|arm_elf_osabi_sniffer
argument_list|)
expr_stmt|;
comment|/* Register some ABI variants for embedded systems.  */
name|gdbarch_register_osabi
argument_list|(
name|bfd_arch_arm
argument_list|,
literal|0
argument_list|,
name|GDB_OSABI_ARM_EABI_V1
argument_list|,
name|arm_init_abi_eabi_v1
argument_list|)
expr_stmt|;
name|gdbarch_register_osabi
argument_list|(
name|bfd_arch_arm
argument_list|,
literal|0
argument_list|,
name|GDB_OSABI_ARM_EABI_V2
argument_list|,
name|arm_init_abi_eabi_v2
argument_list|)
expr_stmt|;
name|gdbarch_register_osabi
argument_list|(
name|bfd_arch_arm
argument_list|,
literal|0
argument_list|,
name|GDB_OSABI_ARM_APCS
argument_list|,
name|arm_init_abi_apcs
argument_list|)
expr_stmt|;
comment|/* Get the number of possible sets of register names defined in opcodes.  */
name|num_disassembly_options
operator|=
name|get_arm_regname_num_options
argument_list|()
expr_stmt|;
comment|/* Add root prefix command for all "set arm"/"show arm" commands.  */
name|add_prefix_cmd
argument_list|(
literal|"arm"
argument_list|,
name|no_class
argument_list|,
name|set_arm_command
argument_list|,
literal|"Various ARM-specific commands."
argument_list|,
operator|&
name|setarmcmdlist
argument_list|,
literal|"set arm "
argument_list|,
literal|0
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"arm"
argument_list|,
name|no_class
argument_list|,
name|show_arm_command
argument_list|,
literal|"Various ARM-specific commands."
argument_list|,
operator|&
name|showarmcmdlist
argument_list|,
literal|"show arm "
argument_list|,
literal|0
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
comment|/* Sync the opcode insn printer with our register viewer.  */
name|parse_arm_disassembler_option
argument_list|(
literal|"reg-names-std"
argument_list|)
expr_stmt|;
comment|/* Begin creating the help text.  */
name|stb
operator|=
name|mem_fileopen
argument_list|()
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|stb
argument_list|,
literal|"Set the disassembly style.\n"
literal|"The valid values are:\n"
argument_list|)
expr_stmt|;
comment|/* Initialize the array that will be passed to add_set_enum_cmd().  */
name|valid_disassembly_styles
operator|=
name|xmalloc
argument_list|(
operator|(
name|num_disassembly_options
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_disassembly_options
condition|;
name|i
operator|++
control|)
block|{
name|numregs
operator|=
name|get_arm_regnames
argument_list|(
name|i
argument_list|,
operator|&
name|setname
argument_list|,
operator|&
name|setdesc
argument_list|,
operator|&
name|regnames
argument_list|)
expr_stmt|;
name|valid_disassembly_styles
index|[
name|i
index|]
operator|=
name|setname
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|stb
argument_list|,
literal|"%s - %s\n"
argument_list|,
name|setname
argument_list|,
name|setdesc
argument_list|)
expr_stmt|;
comment|/* Copy the default names (if found) and synchronize disassembler.  */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|setname
argument_list|,
literal|"std"
argument_list|)
condition|)
block|{
name|disassembly_style
operator|=
name|setname
expr_stmt|;
name|current_option
operator|=
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|numregs
condition|;
name|j
operator|++
control|)
name|arm_register_names
index|[
name|j
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|regnames
index|[
name|j
index|]
expr_stmt|;
name|set_arm_regname_option
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Mark the end of valid options.  */
name|valid_disassembly_styles
index|[
name|num_disassembly_options
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Finish the creation of the help text.  */
name|fprintf_unfiltered
argument_list|(
name|stb
argument_list|,
literal|"The default is \"std\"."
argument_list|)
expr_stmt|;
name|helptext
operator|=
name|ui_file_xstrdup
argument_list|(
name|stb
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|ui_file_delete
argument_list|(
name|stb
argument_list|)
expr_stmt|;
comment|/* Add the deprecated disassembly-flavor command.  */
name|new_set
operator|=
name|add_set_enum_cmd
argument_list|(
literal|"disassembly-flavor"
argument_list|,
name|no_class
argument_list|,
name|valid_disassembly_styles
argument_list|,
operator|&
name|disassembly_style
argument_list|,
name|helptext
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|set_cmd_sfunc
argument_list|(
name|new_set
argument_list|,
name|set_disassembly_style_sfunc
argument_list|)
expr_stmt|;
name|deprecate_cmd
argument_list|(
name|new_set
argument_list|,
literal|"set arm disassembly"
argument_list|)
expr_stmt|;
name|deprecate_cmd
argument_list|(
name|add_show_from_set
argument_list|(
name|new_set
argument_list|,
operator|&
name|showlist
argument_list|)
argument_list|,
literal|"show arm disassembly"
argument_list|)
expr_stmt|;
comment|/* And now add the new interface.  */
name|new_set
operator|=
name|add_set_enum_cmd
argument_list|(
literal|"disassembler"
argument_list|,
name|no_class
argument_list|,
name|valid_disassembly_styles
argument_list|,
operator|&
name|disassembly_style
argument_list|,
name|helptext
argument_list|,
operator|&
name|setarmcmdlist
argument_list|)
expr_stmt|;
name|set_cmd_sfunc
argument_list|(
name|new_set
argument_list|,
name|set_disassembly_style_sfunc
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|new_set
argument_list|,
operator|&
name|showarmcmdlist
argument_list|)
expr_stmt|;
name|add_setshow_cmd_full
argument_list|(
literal|"apcs32"
argument_list|,
name|no_class
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|arm_apcs_32
argument_list|,
literal|"Set usage of ARM 32-bit mode."
argument_list|,
literal|"Show usage of ARM 32-bit mode."
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|setlist
argument_list|,
operator|&
name|showlist
argument_list|,
operator|&
name|new_set
argument_list|,
operator|&
name|new_show
argument_list|)
expr_stmt|;
name|deprecate_cmd
argument_list|(
name|new_set
argument_list|,
literal|"set arm apcs32"
argument_list|)
expr_stmt|;
name|deprecate_cmd
argument_list|(
name|new_show
argument_list|,
literal|"show arm apcs32"
argument_list|)
expr_stmt|;
name|add_setshow_boolean_cmd
argument_list|(
literal|"apcs32"
argument_list|,
name|no_class
argument_list|,
operator|&
name|arm_apcs_32
argument_list|,
literal|"Set usage of ARM 32-bit mode.  "
literal|"When off, a 26-bit PC will be used."
argument_list|,
literal|"Show usage of ARM 32-bit mode.  "
literal|"When off, a 26-bit PC will be used."
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|setarmcmdlist
argument_list|,
operator|&
name|showarmcmdlist
argument_list|)
expr_stmt|;
comment|/* Add a command to allow the user to force the FPU model.  */
name|new_set
operator|=
name|add_set_enum_cmd
argument_list|(
literal|"fpu"
argument_list|,
name|no_class
argument_list|,
name|fp_model_strings
argument_list|,
operator|&
name|current_fp_model
argument_list|,
literal|"Set the floating point type.\n"
literal|"auto - Determine the FP typefrom the OS-ABI.\n"
literal|"softfpa - Software FP, mixed-endian doubles on little-endian ARMs.\n"
literal|"fpa - FPA co-processor (GCC compiled).\n"
literal|"softvfp - Software FP with pure-endian doubles.\n"
literal|"vfp - VFP co-processor."
argument_list|,
operator|&
name|setarmcmdlist
argument_list|)
expr_stmt|;
name|set_cmd_sfunc
argument_list|(
name|new_set
argument_list|,
name|set_fp_model_sfunc
argument_list|)
expr_stmt|;
name|set_cmd_sfunc
argument_list|(
name|add_show_from_set
argument_list|(
name|new_set
argument_list|,
operator|&
name|showarmcmdlist
argument_list|)
argument_list|,
name|show_fp_model
argument_list|)
expr_stmt|;
comment|/* Add the deprecated "othernames" command.  */
name|deprecate_cmd
argument_list|(
name|add_com
argument_list|(
literal|"othernames"
argument_list|,
name|class_obscure
argument_list|,
name|arm_othernames
argument_list|,
literal|"Switch to the next set of register names."
argument_list|)
argument_list|,
literal|"set arm disassembly"
argument_list|)
expr_stmt|;
comment|/* Debugging flag.  */
name|add_setshow_boolean_cmd
argument_list|(
literal|"arm"
argument_list|,
name|class_maintenance
argument_list|,
operator|&
name|arm_debug
argument_list|,
literal|"Set ARM debugging.  "
literal|"When on, arm-specific debugging is enabled."
argument_list|,
literal|"Show ARM debugging.  "
literal|"When on, arm-specific debugging is enabled."
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|setdebuglist
argument_list|,
operator|&
name|showdebuglist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

