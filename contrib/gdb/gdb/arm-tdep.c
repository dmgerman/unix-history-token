begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Common target dependent code for GDB on ARM systems.    Copyright 1988, 1989, 1991, 1992, 1993, 1995, 1996, 1998, 1999, 2000,    2001, 2002 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/* XXX for isupper () */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_comment
comment|/* For register flavors. */
end_comment

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"doublest.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"arch-utils.h"
end_include

begin_include
include|#
directive|include
file|"solib-svr4.h"
end_include

begin_include
include|#
directive|include
file|"arm-tdep.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"elf/arm.h"
end_include

begin_comment
comment|/* Each OS has a different mechanism for accessing the various    registers stored in the sigcontext structure.     SIGCONTEXT_REGISTER_ADDRESS should be defined to the name (or    function pointer) which may be used to determine the addresses    of the various saved registers in the sigcontext structure.     For the ARM target, there are three parameters to this function.     The first is the pc value of the frame under consideration, the    second the stack pointer of this frame, and the last is the    register number to fetch.       If the tm.h file does not define this macro, then it's assumed that    no mechanism is needed and we define SIGCONTEXT_REGISTER_ADDRESS to    be 0.         When it comes time to multi-arching this code, see the identically    named machinery in ia64-tdep.c for an example of how it could be    done.  It should not be necessary to modify the code below where    this macro is used.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SIGCONTEXT_REGISTER_ADDRESS
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|SIGCONTEXT_REGISTER_ADDRESS_P
end_ifndef

begin_define
define|#
directive|define
name|SIGCONTEXT_REGISTER_ADDRESS_P
parameter_list|()
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SIGCONTEXT_REGISTER_ADDRESS
parameter_list|(
name|SP
parameter_list|,
name|PC
parameter_list|,
name|REG
parameter_list|)
value|0
end_define

begin_define
define|#
directive|define
name|SIGCONTEXT_REGISTER_ADDRESS_P
parameter_list|()
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Macros for setting and testing a bit in a minimal symbol that marks    it as Thumb function.  The MSB of the minimal symbol's "info" field    is used for this purpose. This field is already being used to store    the symbol size, so the assumption is that the symbol size cannot    exceed 2^31.     MSYMBOL_SET_SPECIAL	Actually sets the "special" bit.    MSYMBOL_IS_SPECIAL   Tests the "special" bit in a minimal symbol.    MSYMBOL_SIZE         Returns the size of the minimal symbol,    			i.e. the "info" field with the "special" bit    			masked out.  */
end_comment

begin_define
define|#
directive|define
name|MSYMBOL_SET_SPECIAL
parameter_list|(
name|msym
parameter_list|)
define|\
value|MSYMBOL_INFO (msym) = (char *) (((long) MSYMBOL_INFO (msym))	\ 					| 0x80000000)
end_define

begin_define
define|#
directive|define
name|MSYMBOL_IS_SPECIAL
parameter_list|(
name|msym
parameter_list|)
define|\
value|(((long) MSYMBOL_INFO (msym)& 0x80000000) != 0)
end_define

begin_define
define|#
directive|define
name|MSYMBOL_SIZE
parameter_list|(
name|msym
parameter_list|)
define|\
value|((long) MSYMBOL_INFO (msym)& 0x7fffffff)
end_define

begin_comment
comment|/* This table matches the indicees assigned to enum arm_abi.  Keep    them in sync.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|arm_abi_names
index|[]
init|=
block|{
literal|"<unknown>"
block|,
literal|"ARM EABI (version 1)"
block|,
literal|"ARM EABI (version 2)"
block|,
literal|"GNU/Linux"
block|,
literal|"NetBSD (a.out)"
block|,
literal|"NetBSD (ELF)"
block|,
literal|"APCS"
block|,
literal|"FreeBSD"
block|,
literal|"Windows CE"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of different reg name sets (options). */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_flavor_options
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We have more registers than the disassembler as gdb can print the value    of special registers as well.    The general register names are overwritten by whatever is being used by    the disassembler at the moment. We also adjust the case of cpsr and fps. */
end_comment

begin_comment
comment|/* Initial value: Register names used in ARM's ISA documentation. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|arm_register_name_strings
index|[]
init|=
block|{
literal|"r0"
block|,
literal|"r1"
block|,
literal|"r2"
block|,
literal|"r3"
block|,
comment|/*  0  1  2  3 */
literal|"r4"
block|,
literal|"r5"
block|,
literal|"r6"
block|,
literal|"r7"
block|,
comment|/*  4  5  6  7 */
literal|"r8"
block|,
literal|"r9"
block|,
literal|"r10"
block|,
literal|"r11"
block|,
comment|/*  8  9 10 11 */
literal|"r12"
block|,
literal|"sp"
block|,
literal|"lr"
block|,
literal|"pc"
block|,
comment|/* 12 13 14 15 */
literal|"f0"
block|,
literal|"f1"
block|,
literal|"f2"
block|,
literal|"f3"
block|,
comment|/* 16 17 18 19 */
literal|"f4"
block|,
literal|"f5"
block|,
literal|"f6"
block|,
literal|"f7"
block|,
comment|/* 20 21 22 23 */
literal|"fps"
block|,
literal|"cpsr"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 24 25       */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|arm_register_names
init|=
name|arm_register_name_strings
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Valid register name flavors.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
modifier|*
name|valid_flavors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Disassembly flavor to use. Default to "std" register names. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|disassembly_flavor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|current_option
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index to that option in the opcodes table. */
end_comment

begin_comment
comment|/* This is used to keep the bfd arch_info in sync with the disassembly    flavor.  */
end_comment

begin_function_decl
specifier|static
name|void
name|set_disassembly_flavor_sfunc
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_disassembly_flavor
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|convert_from_extended
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|void
modifier|*
name|dbl
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Define other aspects of the stack frame.  We keep the offsets of    all saved registers, 'cause we need 'em a lot!  We also keep the    current size of the stack frame, and the offset of the frame    pointer from the stack pointer (for frameless functions, and when    we're still in the prologue of a function with a frame) */
end_comment

begin_struct
struct|struct
name|frame_extra_info
block|{
name|int
name|framesize
decl_stmt|;
name|int
name|frameoffset
decl_stmt|;
name|int
name|framereg
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Addresses for calling Thumb functions have the bit 0 set.    Here are some macros to test, set, or clear bit 0 of addresses.  */
end_comment

begin_define
define|#
directive|define
name|IS_THUMB_ADDR
parameter_list|(
name|addr
parameter_list|)
value|((addr)& 1)
end_define

begin_define
define|#
directive|define
name|MAKE_THUMB_ADDR
parameter_list|(
name|addr
parameter_list|)
value|((addr) | 1)
end_define

begin_define
define|#
directive|define
name|UNMAKE_THUMB_ADDR
parameter_list|(
name|addr
parameter_list|)
value|((addr)& ~1)
end_define

begin_function
specifier|static
name|int
name|arm_frame_chain_valid
parameter_list|(
name|CORE_ADDR
name|chain
parameter_list|,
name|struct
name|frame_info
modifier|*
name|thisframe
parameter_list|)
block|{
return|return
operator|(
name|chain
operator|!=
literal|0
operator|&&
operator|(
name|FRAME_SAVED_PC
argument_list|(
name|thisframe
argument_list|)
operator|>=
name|LOWEST_PC
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Set to true if the 32-bit mode is in use. */
end_comment

begin_decl_stmt
name|int
name|arm_apcs_32
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag set by arm_fix_call_dummy that tells whether the target    function is a Thumb function.  This flag is checked by    arm_push_arguments.  FIXME: Change the PUSH_ARGUMENTS macro (and    its use in valops.c) to pass the function address as an additional    parameter.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|target_is_thumb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag set by arm_fix_call_dummy that tells whether the calling    function is a Thumb function.  This flag is checked by    arm_pc_is_thumb and arm_call_dummy_breakpoint_offset.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|caller_is_thumb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Determine if the program counter specified in MEMADDR is in a Thumb    function.  */
end_comment

begin_function
name|int
name|arm_pc_is_thumb
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|sym
decl_stmt|;
comment|/* If bit 0 of the address is set, assume this is a Thumb address.  */
if|if
condition|(
name|IS_THUMB_ADDR
argument_list|(
name|memaddr
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Thumb functions have a "special" bit set in minimal symbols.  */
name|sym
operator|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|memaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
return|return
operator|(
name|MSYMBOL_IS_SPECIAL
argument_list|(
name|sym
argument_list|)
operator|)
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Determine if the program counter specified in MEMADDR is in a call    dummy being called from a Thumb function.  */
end_comment

begin_function
name|int
name|arm_pc_is_thumb_dummy
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|)
block|{
name|CORE_ADDR
name|sp
init|=
name|read_sp
argument_list|()
decl_stmt|;
comment|/* FIXME: Until we switch for the new call dummy macros, this heuristic      is the best we can do.  We are trying to determine if the pc is on      the stack, which (hopefully) will only happen in a call dummy.      We hope the current stack pointer is not so far alway from the dummy      frame location (true if we have not pushed large data structures or      gone too many levels deep) and that our 1024 is not enough to consider      code regions as part of the stack (true for most practical purposes) */
if|if
condition|(
name|PC_IN_CALL_DUMMY
argument_list|(
name|memaddr
argument_list|,
name|sp
argument_list|,
name|sp
operator|+
literal|1024
argument_list|)
condition|)
return|return
name|caller_is_thumb
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Remove useless bits from addresses in a running program.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|arm_addr_bits_remove
parameter_list|(
name|CORE_ADDR
name|val
parameter_list|)
block|{
if|if
condition|(
name|arm_pc_is_thumb
argument_list|(
name|val
argument_list|)
condition|)
return|return
operator|(
name|val
operator|&
operator|(
name|arm_apcs_32
condition|?
literal|0xfffffffe
else|:
literal|0x03fffffe
operator|)
operator|)
return|;
else|else
return|return
operator|(
name|val
operator|&
operator|(
name|arm_apcs_32
condition|?
literal|0xfffffffc
else|:
literal|0x03fffffc
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* When reading symbols, we need to zap the low bit of the address,    which may be set to 1 for Thumb functions.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|arm_smash_text_address
parameter_list|(
name|CORE_ADDR
name|val
parameter_list|)
block|{
return|return
name|val
operator|&
operator|~
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Immediately after a function call, return the saved pc.  Can't    always go through the frames for this because on some machines the    new frame is not set up until the new function executes some    instructions.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|arm_saved_pc_after_call
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
return|return
name|ADDR_BITS_REMOVE
argument_list|(
name|read_register
argument_list|(
name|ARM_LR_REGNUM
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Determine whether the function invocation represented by FI has a    frame on the stack associated with it.  If it does return zero,    otherwise return 1.  */
end_comment

begin_function
specifier|static
name|int
name|arm_frameless_function_invocation
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
name|CORE_ADDR
name|func_start
decl_stmt|,
name|after_prologue
decl_stmt|;
name|int
name|frameless
decl_stmt|;
comment|/* Sometimes we have functions that do a little setup (like saving the      vN registers with the stmdb instruction, but DO NOT set up a frame.      The symbol table will report this as a prologue.  However, it is      important not to try to parse these partial frames as frames, or we      will get really confused.       So I will demand 3 instructions between the start& end of the      prologue before I call it a real prologue, i.e. at least 	mov ip, sp, 	stmdb sp!, {} 	sub sp, ip, #4.  */
name|func_start
operator|=
operator|(
name|get_pc_function_start
argument_list|(
operator|(
name|fi
operator|)
operator|->
name|pc
argument_list|)
operator|+
name|FUNCTION_START_OFFSET
operator|)
expr_stmt|;
name|after_prologue
operator|=
name|SKIP_PROLOGUE
argument_list|(
name|func_start
argument_list|)
expr_stmt|;
comment|/* There are some frameless functions whose first two instructions      follow the standard APCS form, in which case after_prologue will      be func_start + 8. */
name|frameless
operator|=
operator|(
name|after_prologue
operator|<
name|func_start
operator|+
literal|12
operator|)
expr_stmt|;
return|return
name|frameless
return|;
block|}
end_function

begin_comment
comment|/* The address of the arguments in the frame.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|arm_frame_args_address
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
return|return
name|fi
operator|->
name|frame
return|;
block|}
end_function

begin_comment
comment|/* The address of the local variables in the frame.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|arm_frame_locals_address
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
return|return
name|fi
operator|->
name|frame
return|;
block|}
end_function

begin_comment
comment|/* The number of arguments being passed in the frame.  */
end_comment

begin_function
specifier|static
name|int
name|arm_frame_num_args
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
comment|/* We have no way of knowing.  */
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* A typical Thumb prologue looks like this:    push    {r7, lr}    add     sp, sp, #-28    add     r7, sp, #12    Sometimes the latter instruction may be replaced by:    mov     r7, sp        or like this:    push    {r7, lr}    mov     r7, sp    sub	   sp, #12        or, on tpcs, like this:    sub     sp,#16    push    {r7, lr}    (many instructions)    mov     r7, sp    sub	   sp, #12     There is always one instruction of three classes:    1 - push    2 - setting of r7    3 - adjusting of sp        When we have found at least one of each class we are done with the prolog.    Note that the "sub sp, #NN" before the push does not count.    */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|thumb_skip_prologue
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
name|func_end
parameter_list|)
block|{
name|CORE_ADDR
name|current_pc
decl_stmt|;
name|int
name|findmask
init|=
literal|0
decl_stmt|;
comment|/* findmask:       			   bit 0 - push { rlist } 			   bit 1 - mov r7, sp  OR  add r7, sp, #imm  (setting of r7)       			   bit 2 - sub sp, #simm  OR  add sp, #simm  (adjusting of sp) 			*/
for|for
control|(
name|current_pc
operator|=
name|pc
init|;
name|current_pc
operator|+
literal|2
operator|<
name|func_end
operator|&&
name|current_pc
operator|<
name|pc
operator|+
literal|40
condition|;
name|current_pc
operator|+=
literal|2
control|)
block|{
name|unsigned
name|short
name|insn
init|=
name|read_memory_unsigned_integer
argument_list|(
name|current_pc
argument_list|,
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xfe00
operator|)
operator|==
literal|0xb400
condition|)
comment|/* push { rlist } */
block|{
name|findmask
operator||=
literal|1
expr_stmt|;
comment|/* push found */
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xff00
operator|)
operator|==
literal|0xb000
condition|)
comment|/* add sp, #simm  OR  sub sp, #simm */
block|{
if|if
condition|(
operator|(
name|findmask
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
comment|/* before push ? */
continue|continue;
else|else
name|findmask
operator||=
literal|4
expr_stmt|;
comment|/* add/sub sp found */
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xff00
operator|)
operator|==
literal|0xaf00
condition|)
comment|/* add r7, sp, #imm */
block|{
name|findmask
operator||=
literal|2
expr_stmt|;
comment|/* setting of r7 found */
block|}
elseif|else
if|if
condition|(
name|insn
operator|==
literal|0x466f
condition|)
comment|/* mov r7, sp */
block|{
name|findmask
operator||=
literal|2
expr_stmt|;
comment|/* setting of r7 found */
block|}
elseif|else
if|if
condition|(
name|findmask
operator|==
operator|(
literal|4
operator|+
literal|2
operator|+
literal|1
operator|)
condition|)
block|{
break|break;
comment|/* We have found one of each type of prologue instruction */
block|}
else|else
continue|continue;
comment|/* something in the prolog that we don't care about or some 	  		   instruction from outside the prolog scheduled here for optimization */
block|}
return|return
name|current_pc
return|;
block|}
end_function

begin_comment
comment|/* Advance the PC across any function entry prologue instructions to reach    some "real" code.     The APCS (ARM Procedure Call Standard) defines the following    prologue:     mov          ip, sp    [stmfd       sp!, {a1,a2,a3,a4}]    stmfd        sp!, {...,fp,ip,lr,pc}    [stfe        f7, [sp, #-12]!]    [stfe        f6, [sp, #-12]!]    [stfe        f5, [sp, #-12]!]    [stfe        f4, [sp, #-12]!]    sub fp, ip, #nn @@ nn == 20 or 4 depending on second insn */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|arm_skip_prologue
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|unsigned
name|long
name|inst
decl_stmt|;
name|CORE_ADDR
name|skip_pc
decl_stmt|;
name|CORE_ADDR
name|func_addr
decl_stmt|,
name|func_end
decl_stmt|;
name|char
modifier|*
name|func_name
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
comment|/* See what the symbol table says.  */
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
operator|&
name|func_name
argument_list|,
operator|&
name|func_addr
argument_list|,
operator|&
name|func_end
argument_list|)
condition|)
block|{
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
comment|/* Found a function.  */
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|func_name
argument_list|,
name|NULL
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|&&
name|SYMBOL_LANGUAGE
argument_list|(
name|sym
argument_list|)
operator|!=
name|language_asm
condition|)
block|{
comment|/* Don't use this trick for assembly source files. */
name|sal
operator|=
name|find_pc_line
argument_list|(
name|func_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sal
operator|.
name|line
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|sal
operator|.
name|end
operator|<
name|func_end
operator|)
condition|)
return|return
name|sal
operator|.
name|end
return|;
block|}
block|}
comment|/* Check if this is Thumb code.  */
if|if
condition|(
name|arm_pc_is_thumb
argument_list|(
name|pc
argument_list|)
condition|)
return|return
name|thumb_skip_prologue
argument_list|(
name|pc
argument_list|,
name|func_end
argument_list|)
return|;
comment|/* Can't find the prologue end in the symbol table, try it the hard way      by disassembling the instructions. */
name|skip_pc
operator|=
name|pc
expr_stmt|;
name|inst
operator|=
name|read_memory_integer
argument_list|(
name|skip_pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst
operator|!=
literal|0xe1a0c00d
condition|)
comment|/* mov ip, sp */
return|return
name|pc
return|;
name|skip_pc
operator|+=
literal|4
expr_stmt|;
name|inst
operator|=
name|read_memory_integer
argument_list|(
name|skip_pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xfffffff0
operator|)
operator|==
literal|0xe92d0000
condition|)
comment|/* stmfd sp!,{a1,a2,a3,a4}  */
block|{
name|skip_pc
operator|+=
literal|4
expr_stmt|;
name|inst
operator|=
name|read_memory_integer
argument_list|(
name|skip_pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xfffff800
operator|)
operator|!=
literal|0xe92dd800
condition|)
comment|/* stmfd sp!,{...,fp,ip,lr,pc} */
return|return
name|pc
return|;
name|skip_pc
operator|+=
literal|4
expr_stmt|;
name|inst
operator|=
name|read_memory_integer
argument_list|(
name|skip_pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Any insns after this point may float into the code, if it makes      for better instruction scheduling, so we skip them only if we      find them, but still consdier the function to be frame-ful.  */
comment|/* We may have either one sfmfd instruction here, or several stfe      insns, depending on the version of floating point code we      support.  */
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xffbf0fff
operator|)
operator|==
literal|0xec2d0200
condition|)
comment|/* sfmfd fn,<cnt>, [sp]! */
block|{
name|skip_pc
operator|+=
literal|4
expr_stmt|;
name|inst
operator|=
name|read_memory_integer
argument_list|(
name|skip_pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|(
name|inst
operator|&
literal|0xffff8fff
operator|)
operator|==
literal|0xed6d0103
condition|)
comment|/* stfe fn, [sp, #-12]! */
block|{
name|skip_pc
operator|+=
literal|4
expr_stmt|;
name|inst
operator|=
name|read_memory_integer
argument_list|(
name|skip_pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xfffff000
operator|)
operator|==
literal|0xe24cb000
condition|)
comment|/* sub fp, ip, #nn */
name|skip_pc
operator|+=
literal|4
expr_stmt|;
return|return
name|skip_pc
return|;
block|}
end_function

begin_comment
comment|/* *INDENT-OFF* */
end_comment

begin_comment
comment|/* Function: thumb_scan_prologue (helper function for arm_scan_prologue)    This function decodes a Thumb function prologue to determine:      1) the size of the stack frame      2) which registers are saved on it      3) the offsets of saved regs      4) the offset from the stack pointer to the frame pointer    This information is stored in the "extra" fields of the frame_info.     A typical Thumb function prologue would create this stack frame    (offsets relative to FP)      old SP ->	24  stack parameters 		20  LR 		16  R7      R7 ->       0  local variables (16 bytes)      SP ->     -12  additional stack space (12 bytes)    The frame size would thus be 36 bytes, and the frame offset would be    12 bytes.  The frame register is R7.         The comments for thumb_skip_prolog() describe the algorithm we use to detect    the end of the prolog */
end_comment

begin_comment
comment|/* *INDENT-ON* */
end_comment

begin_function
specifier|static
name|void
name|thumb_scan_prologue
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
name|CORE_ADDR
name|prologue_start
decl_stmt|;
name|CORE_ADDR
name|prologue_end
decl_stmt|;
name|CORE_ADDR
name|current_pc
decl_stmt|;
name|int
name|saved_reg
index|[
literal|16
index|]
decl_stmt|;
comment|/* which register has been copied to register n? */
name|int
name|findmask
init|=
literal|0
decl_stmt|;
comment|/* findmask:       			   bit 0 - push { rlist } 			   bit 1 - mov r7, sp  OR  add r7, sp, #imm  (setting of r7)       			   bit 2 - sub sp, #simm  OR  add sp, #simm  (adjusting of sp) 			*/
name|int
name|i
decl_stmt|;
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
name|NULL
argument_list|,
operator|&
name|prologue_start
argument_list|,
operator|&
name|prologue_end
argument_list|)
condition|)
block|{
name|struct
name|symtab_and_line
name|sal
init|=
name|find_pc_line
argument_list|(
name|prologue_start
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|sal
operator|.
name|line
operator|==
literal|0
condition|)
comment|/* no line info, use current PC */
name|prologue_end
operator|=
name|fi
operator|->
name|pc
expr_stmt|;
elseif|else
if|if
condition|(
name|sal
operator|.
name|end
operator|<
name|prologue_end
condition|)
comment|/* next line begins after fn end */
name|prologue_end
operator|=
name|sal
operator|.
name|end
expr_stmt|;
comment|/* (probably means no prologue)  */
block|}
else|else
name|prologue_end
operator|=
name|prologue_start
operator|+
literal|40
expr_stmt|;
comment|/* We're in the boondocks: allow for */
comment|/* 16 pushes, an add, and "mv fp,sp" */
name|prologue_end
operator|=
name|min
argument_list|(
name|prologue_end
argument_list|,
name|fi
operator|->
name|pc
argument_list|)
expr_stmt|;
comment|/* Initialize the saved register map.  When register H is copied to      register L, we will put H in saved_reg[L].  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|saved_reg
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
comment|/* Search the prologue looking for instructions that set up the      frame pointer, adjust the stack pointer, and save registers.      Do this until all basic prolog instructions are found.  */
name|fi
operator|->
name|extra_info
operator|->
name|framesize
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|current_pc
operator|=
name|prologue_start
init|;
operator|(
name|current_pc
operator|<
name|prologue_end
operator|)
operator|&&
operator|(
operator|(
name|findmask
operator|&
literal|7
operator|)
operator|!=
literal|7
operator|)
condition|;
name|current_pc
operator|+=
literal|2
control|)
block|{
name|unsigned
name|short
name|insn
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|insn
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|current_pc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xfe00
operator|)
operator|==
literal|0xb400
condition|)
comment|/* push { rlist } */
block|{
name|int
name|mask
decl_stmt|;
name|findmask
operator||=
literal|1
expr_stmt|;
comment|/* push found */
comment|/* Bits 0-7 contain a mask for registers R0-R7.  Bit 8 says 	     whether to save LR (R14).  */
name|mask
operator|=
operator|(
name|insn
operator|&
literal|0xff
operator|)
operator||
operator|(
operator|(
name|insn
operator|&
literal|0x100
operator|)
operator|<<
literal|6
operator|)
expr_stmt|;
comment|/* Calculate offsets of saved R0-R7 and LR. */
for|for
control|(
name|regno
operator|=
name|ARM_LR_REGNUM
init|;
name|regno
operator|>=
literal|0
condition|;
name|regno
operator|--
control|)
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|regno
operator|)
condition|)
block|{
name|fi
operator|->
name|extra_info
operator|->
name|framesize
operator|+=
literal|4
expr_stmt|;
name|fi
operator|->
name|saved_regs
index|[
name|saved_reg
index|[
name|regno
index|]
index|]
operator|=
operator|-
operator|(
name|fi
operator|->
name|extra_info
operator|->
name|framesize
operator|)
expr_stmt|;
name|saved_reg
index|[
name|regno
index|]
operator|=
name|regno
expr_stmt|;
comment|/* reset saved register map */
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xff00
operator|)
operator|==
literal|0xb000
condition|)
comment|/* add sp, #simm  OR  sub sp, #simm */
block|{
if|if
condition|(
operator|(
name|findmask
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
comment|/* before push ? */
continue|continue;
else|else
name|findmask
operator||=
literal|4
expr_stmt|;
comment|/* add/sub sp found */
name|offset
operator|=
operator|(
name|insn
operator|&
literal|0x7f
operator|)
operator|<<
literal|2
expr_stmt|;
comment|/* get scaled offset */
if|if
condition|(
name|insn
operator|&
literal|0x80
condition|)
comment|/* is it signed? (==subtracting) */
block|{
name|fi
operator|->
name|extra_info
operator|->
name|frameoffset
operator|+=
name|offset
expr_stmt|;
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
block|}
name|fi
operator|->
name|extra_info
operator|->
name|framesize
operator|-=
name|offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xff00
operator|)
operator|==
literal|0xaf00
condition|)
comment|/* add r7, sp, #imm */
block|{
name|findmask
operator||=
literal|2
expr_stmt|;
comment|/* setting of r7 found */
name|fi
operator|->
name|extra_info
operator|->
name|framereg
operator|=
name|THUMB_FP_REGNUM
expr_stmt|;
comment|/* get scaled offset */
name|fi
operator|->
name|extra_info
operator|->
name|frameoffset
operator|=
operator|(
name|insn
operator|&
literal|0xff
operator|)
operator|<<
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|insn
operator|==
literal|0x466f
condition|)
comment|/* mov r7, sp */
block|{
name|findmask
operator||=
literal|2
expr_stmt|;
comment|/* setting of r7 found */
name|fi
operator|->
name|extra_info
operator|->
name|framereg
operator|=
name|THUMB_FP_REGNUM
expr_stmt|;
name|fi
operator|->
name|extra_info
operator|->
name|frameoffset
operator|=
literal|0
expr_stmt|;
name|saved_reg
index|[
name|THUMB_FP_REGNUM
index|]
operator|=
name|ARM_SP_REGNUM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xffc0
operator|)
operator|==
literal|0x4640
condition|)
comment|/* mov r0-r7, r8-r15 */
block|{
name|int
name|lo_reg
init|=
name|insn
operator|&
literal|7
decl_stmt|;
comment|/* dest. register (r0-r7) */
name|int
name|hi_reg
init|=
operator|(
operator|(
name|insn
operator|>>
literal|3
operator|)
operator|&
literal|7
operator|)
operator|+
literal|8
decl_stmt|;
comment|/* source register (r8-15) */
name|saved_reg
index|[
name|lo_reg
index|]
operator|=
name|hi_reg
expr_stmt|;
comment|/* remember hi reg was saved */
block|}
else|else
continue|continue;
comment|/* something in the prolog that we don't care about or some 	  		   instruction from outside the prolog scheduled here for optimization */
block|}
block|}
end_function

begin_comment
comment|/* Check if prologue for this frame's PC has already been scanned.  If    it has, copy the relevant information about that prologue and    return non-zero.  Otherwise do not copy anything and return zero.     The information saved in the cache includes:    * the frame register number;    * the size of the stack frame;    * the offsets of saved regs (relative to the old SP); and    * the offset from the stack pointer to the frame pointer     The cache contains only one entry, since this is adequate for the    typical sequence of prologue scan requests we get.  When performing    a backtrace, GDB will usually ask to scan the same function twice    in a row (once to get the frame chain, and once to fill in the    extra frame information).  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|frame_info
name|prologue_cache
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|check_prologue_cache
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|fi
operator|->
name|pc
operator|==
name|prologue_cache
operator|.
name|pc
condition|)
block|{
name|fi
operator|->
name|extra_info
operator|->
name|framereg
operator|=
name|prologue_cache
operator|.
name|extra_info
operator|->
name|framereg
expr_stmt|;
name|fi
operator|->
name|extra_info
operator|->
name|framesize
operator|=
name|prologue_cache
operator|.
name|extra_info
operator|->
name|framesize
expr_stmt|;
name|fi
operator|->
name|extra_info
operator|->
name|frameoffset
operator|=
name|prologue_cache
operator|.
name|extra_info
operator|->
name|frameoffset
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
condition|;
name|i
operator|++
control|)
name|fi
operator|->
name|saved_regs
index|[
name|i
index|]
operator|=
name|prologue_cache
operator|.
name|saved_regs
index|[
name|i
index|]
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Copy the prologue information from fi to the prologue cache.  */
end_comment

begin_function
specifier|static
name|void
name|save_prologue_cache
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|prologue_cache
operator|.
name|pc
operator|=
name|fi
operator|->
name|pc
expr_stmt|;
name|prologue_cache
operator|.
name|extra_info
operator|->
name|framereg
operator|=
name|fi
operator|->
name|extra_info
operator|->
name|framereg
expr_stmt|;
name|prologue_cache
operator|.
name|extra_info
operator|->
name|framesize
operator|=
name|fi
operator|->
name|extra_info
operator|->
name|framesize
expr_stmt|;
name|prologue_cache
operator|.
name|extra_info
operator|->
name|frameoffset
operator|=
name|fi
operator|->
name|extra_info
operator|->
name|frameoffset
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
condition|;
name|i
operator|++
control|)
name|prologue_cache
operator|.
name|saved_regs
index|[
name|i
index|]
operator|=
name|fi
operator|->
name|saved_regs
index|[
name|i
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function decodes an ARM function prologue to determine:    1) the size of the stack frame    2) which registers are saved on it    3) the offsets of saved regs    4) the offset from the stack pointer to the frame pointer    This information is stored in the "extra" fields of the frame_info.     There are two basic forms for the ARM prologue.  The fixed argument    function call will look like:     mov    ip, sp    stmfd  sp!, {fp, ip, lr, pc}    sub    fp, ip, #4    [sub sp, sp, #4]     Which would create this stack frame (offsets relative to FP):    IP ->   4    (caller's stack)    FP ->   0    PC (points to address of stmfd instruction + 8 in callee)    -4   LR (return address in caller)    -8   IP (copy of caller's SP)    -12  FP (caller's FP)    SP -> -28    Local variables     The frame size would thus be 32 bytes, and the frame offset would be    28 bytes.  The stmfd call can also save any of the vN registers it    plans to use, which increases the frame size accordingly.     Note: The stored PC is 8 off of the STMFD instruction that stored it    because the ARM Store instructions always store PC + 8 when you read    the PC register.     A variable argument function call will look like:     mov    ip, sp    stmfd  sp!, {a1, a2, a3, a4}    stmfd  sp!, {fp, ip, lr, pc}    sub    fp, ip, #20     Which would create this stack frame (offsets relative to FP):    IP ->  20    (caller's stack)    16  A4    12  A3    8  A2    4  A1    FP ->   0    PC (points to address of stmfd instruction + 8 in callee)    -4   LR (return address in caller)    -8   IP (copy of caller's SP)    -12  FP (caller's FP)    SP -> -28    Local variables     The frame size would thus be 48 bytes, and the frame offset would be    28 bytes.     There is another potential complication, which is that the optimizer    will try to separate the store of fp in the "stmfd" instruction from    the "sub fp, ip, #NN" instruction.  Almost anything can be there, so    we just key on the stmfd, and then scan for the "sub fp, ip, #NN"...     Also, note, the original version of the ARM toolchain claimed that there    should be an     instruction at the end of the prologue.  I have never seen GCC produce    this, and the ARM docs don't mention it.  We still test for it below in    case it happens...   */
end_comment

begin_function
specifier|static
name|void
name|arm_scan_prologue
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
name|int
name|regno
decl_stmt|,
name|sp_offset
decl_stmt|,
name|fp_offset
decl_stmt|;
name|LONGEST
name|return_value
decl_stmt|;
name|CORE_ADDR
name|prologue_start
decl_stmt|,
name|prologue_end
decl_stmt|,
name|current_pc
decl_stmt|;
comment|/* Check if this function is already in the cache of frame information. */
if|if
condition|(
name|check_prologue_cache
argument_list|(
name|fi
argument_list|)
condition|)
return|return;
comment|/* Assume there is no frame until proven otherwise.  */
name|fi
operator|->
name|extra_info
operator|->
name|framereg
operator|=
name|ARM_SP_REGNUM
expr_stmt|;
name|fi
operator|->
name|extra_info
operator|->
name|framesize
operator|=
literal|0
expr_stmt|;
name|fi
operator|->
name|extra_info
operator|->
name|frameoffset
operator|=
literal|0
expr_stmt|;
comment|/* Check for Thumb prologue.  */
if|if
condition|(
name|arm_pc_is_thumb
argument_list|(
name|fi
operator|->
name|pc
argument_list|)
condition|)
block|{
name|thumb_scan_prologue
argument_list|(
name|fi
argument_list|)
expr_stmt|;
name|save_prologue_cache
argument_list|(
name|fi
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Find the function prologue.  If we can't find the function in      the symbol table, peek in the stack frame to find the PC.  */
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
name|NULL
argument_list|,
operator|&
name|prologue_start
argument_list|,
operator|&
name|prologue_end
argument_list|)
condition|)
block|{
comment|/* One way to find the end of the prologue (which works well          for unoptimized code) is to do the following:  	    struct symtab_and_line sal = find_pc_line (prologue_start, 0);  	    if (sal.line == 0) 	      prologue_end = fi->pc; 	    else if (sal.end< prologue_end) 	      prologue_end = sal.end;  	 This mechanism is very accurate so long as the optimizer 	 doesn't move any instructions from the function body into the 	 prologue.  If this happens, sal.end will be the last 	 instruction in the first hunk of prologue code just before 	 the first instruction that the scheduler has moved from 	 the body to the prologue.  	 In order to make sure that we scan all of the prologue 	 instructions, we use a slightly less accurate mechanism which 	 may scan more than necessary.  To help compensate for this 	 lack of accuracy, the prologue scanning loop below contains 	 several clauses which'll cause the loop to terminate early if 	 an implausible prologue instruction is encountered.   	  	 The expression 	  	      prologue_start + 64 	     	 is a suitable endpoint since it accounts for the largest 	 possible prologue plus up to five instructions inserted by 	 the scheduler. */
if|if
condition|(
name|prologue_end
operator|>
name|prologue_start
operator|+
literal|64
condition|)
block|{
name|prologue_end
operator|=
name|prologue_start
operator|+
literal|64
expr_stmt|;
comment|/* See above. */
block|}
block|}
else|else
block|{
comment|/* Get address of the stmfd in the prologue of the callee; the saved          PC is the address of the stmfd + 8.  */
if|if
condition|(
operator|!
name|safe_read_memory_integer
argument_list|(
name|fi
operator|->
name|frame
argument_list|,
literal|4
argument_list|,
operator|&
name|return_value
argument_list|)
condition|)
return|return;
else|else
block|{
name|prologue_start
operator|=
name|ADDR_BITS_REMOVE
argument_list|(
name|return_value
argument_list|)
operator|-
literal|8
expr_stmt|;
name|prologue_end
operator|=
name|prologue_start
operator|+
literal|64
expr_stmt|;
comment|/* See above. */
block|}
block|}
comment|/* Now search the prologue looking for instructions that set up the      frame pointer, adjust the stack pointer, and save registers.       Be careful, however, and if it doesn't look like a prologue,      don't try to scan it.  If, for instance, a frameless function      begins with stmfd sp!, then we will tell ourselves there is      a frame, which will confuse stack traceback, as well ad"finish"       and other operations that rely on a knowledge of the stack      traceback.       In the APCS, the prologue should start with  "mov ip, sp" so      if we don't see this as the first insn, we will stop.  [Note:      This doesn't seem to be true any longer, so it's now an optional      part of the prologue.  - Kevin Buettner, 2001-11-20]  */
name|sp_offset
operator|=
name|fp_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|read_memory_unsigned_integer
argument_list|(
name|prologue_start
argument_list|,
literal|4
argument_list|)
operator|==
literal|0xe1a0c00d
condition|)
comment|/* mov ip, sp */
name|current_pc
operator|=
name|prologue_start
operator|+
literal|4
expr_stmt|;
else|else
name|current_pc
operator|=
name|prologue_start
expr_stmt|;
for|for
control|(
init|;
name|current_pc
operator|<
name|prologue_end
condition|;
name|current_pc
operator|+=
literal|4
control|)
block|{
name|unsigned
name|int
name|insn
init|=
name|read_memory_unsigned_integer
argument_list|(
name|current_pc
argument_list|,
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0xe92d0000
condition|)
comment|/* stmfd sp!, {..., fp, ip, lr, pc} 	   or 	   stmfd sp!, {a1, a2, a3, a4}  */
block|{
name|int
name|mask
init|=
name|insn
operator|&
literal|0xffff
decl_stmt|;
comment|/* Calculate offsets of saved registers. */
for|for
control|(
name|regno
operator|=
name|ARM_PC_REGNUM
init|;
name|regno
operator|>=
literal|0
condition|;
name|regno
operator|--
control|)
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|regno
operator|)
condition|)
block|{
name|sp_offset
operator|-=
literal|4
expr_stmt|;
name|fi
operator|->
name|saved_regs
index|[
name|regno
index|]
operator|=
name|sp_offset
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xfffff000
operator|)
operator|==
literal|0xe24cb000
condition|)
comment|/* sub fp, ip #n */
block|{
name|unsigned
name|imm
init|=
name|insn
operator|&
literal|0xff
decl_stmt|;
comment|/* immediate value */
name|unsigned
name|rot
init|=
operator|(
name|insn
operator|&
literal|0xf00
operator|)
operator|>>
literal|7
decl_stmt|;
comment|/* rotate amount */
name|imm
operator|=
operator|(
name|imm
operator|>>
name|rot
operator|)
operator||
operator|(
name|imm
operator|<<
operator|(
literal|32
operator|-
name|rot
operator|)
operator|)
expr_stmt|;
name|fp_offset
operator|=
operator|-
name|imm
expr_stmt|;
name|fi
operator|->
name|extra_info
operator|->
name|framereg
operator|=
name|ARM_FP_REGNUM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xfffff000
operator|)
operator|==
literal|0xe24dd000
condition|)
comment|/* sub sp, sp #n */
block|{
name|unsigned
name|imm
init|=
name|insn
operator|&
literal|0xff
decl_stmt|;
comment|/* immediate value */
name|unsigned
name|rot
init|=
operator|(
name|insn
operator|&
literal|0xf00
operator|)
operator|>>
literal|7
decl_stmt|;
comment|/* rotate amount */
name|imm
operator|=
operator|(
name|imm
operator|>>
name|rot
operator|)
operator||
operator|(
name|imm
operator|<<
operator|(
literal|32
operator|-
name|rot
operator|)
operator|)
expr_stmt|;
name|sp_offset
operator|-=
name|imm
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xffff7fff
operator|)
operator|==
literal|0xed6d0103
condition|)
comment|/* stfe f?, [sp, -#c]! */
block|{
name|sp_offset
operator|-=
literal|12
expr_stmt|;
name|regno
operator|=
name|ARM_F0_REGNUM
operator|+
operator|(
operator|(
name|insn
operator|>>
literal|12
operator|)
operator|&
literal|0x07
operator|)
expr_stmt|;
name|fi
operator|->
name|saved_regs
index|[
name|regno
index|]
operator|=
name|sp_offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xffbf0fff
operator|)
operator|==
literal|0xec2d0200
condition|)
comment|/* sfmfd f0, 4, [sp!] */
block|{
name|int
name|n_saved_fp_regs
decl_stmt|;
name|unsigned
name|int
name|fp_start_reg
decl_stmt|,
name|fp_bound_reg
decl_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
literal|0x800
operator|)
operator|==
literal|0x800
condition|)
comment|/* N0 is set */
block|{
if|if
condition|(
operator|(
name|insn
operator|&
literal|0x40000
operator|)
operator|==
literal|0x40000
condition|)
comment|/* N1 is set */
name|n_saved_fp_regs
operator|=
literal|3
expr_stmt|;
else|else
name|n_saved_fp_regs
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|insn
operator|&
literal|0x40000
operator|)
operator|==
literal|0x40000
condition|)
comment|/* N1 is set */
name|n_saved_fp_regs
operator|=
literal|2
expr_stmt|;
else|else
name|n_saved_fp_regs
operator|=
literal|4
expr_stmt|;
block|}
name|fp_start_reg
operator|=
name|ARM_F0_REGNUM
operator|+
operator|(
operator|(
name|insn
operator|>>
literal|12
operator|)
operator|&
literal|0x7
operator|)
expr_stmt|;
name|fp_bound_reg
operator|=
name|fp_start_reg
operator|+
name|n_saved_fp_regs
expr_stmt|;
for|for
control|(
init|;
name|fp_start_reg
operator|<
name|fp_bound_reg
condition|;
name|fp_start_reg
operator|++
control|)
block|{
name|sp_offset
operator|-=
literal|12
expr_stmt|;
name|fi
operator|->
name|saved_regs
index|[
name|fp_start_reg
operator|++
index|]
operator|=
name|sp_offset
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xf0000000
operator|)
operator|!=
literal|0xe0000000
condition|)
break|break;
comment|/* Condition not true, exit early */
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xfe200000
operator|)
operator|==
literal|0xe8200000
condition|)
comment|/* ldm? */
break|break;
comment|/* Don't scan past a block load */
else|else
comment|/* The optimizer might shove anything into the prologue, 	   so we just skip what we don't recognize. */
continue|continue;
block|}
comment|/* The frame size is just the negative of the offset (from the original SP)      of the last thing thing we pushed on the stack.  The frame offset is      [new FP] - [new SP].  */
name|fi
operator|->
name|extra_info
operator|->
name|framesize
operator|=
operator|-
name|sp_offset
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|extra_info
operator|->
name|framereg
operator|==
name|ARM_FP_REGNUM
condition|)
name|fi
operator|->
name|extra_info
operator|->
name|frameoffset
operator|=
name|fp_offset
operator|-
name|sp_offset
expr_stmt|;
else|else
name|fi
operator|->
name|extra_info
operator|->
name|frameoffset
operator|=
literal|0
expr_stmt|;
name|save_prologue_cache
argument_list|(
name|fi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find REGNUM on the stack.  Otherwise, it's in an active register.    One thing we might want to do here is to check REGNUM against the    clobber mask, and somehow flag it as invalid if it isn't saved on    the stack somewhere.  This would provide a graceful failure mode    when trying to get the value of caller-saves registers for an inner    frame.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|arm_find_callers_reg
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
for|for
control|(
init|;
name|fi
condition|;
name|fi
operator|=
name|fi
operator|->
name|next
control|)
if|#
directive|if
literal|0
comment|/* FIXME: enable this code if we convert to new call dummy scheme.  */
for|if (PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))       return generic_read_register_dummy (fi->pc, fi->frame, regnum);     else
endif|#
directive|endif
if|if
condition|(
name|fi
operator|->
name|saved_regs
index|[
name|regnum
index|]
operator|!=
literal|0
condition|)
return|return
name|read_memory_integer
argument_list|(
name|fi
operator|->
name|saved_regs
index|[
name|regnum
index|]
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
return|;
return|return
name|read_register
argument_list|(
name|regnum
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Function: frame_chain Given a GDB frame, determine the address of    the calling function's frame.  This will be used to create a new    GDB frame struct, and then INIT_EXTRA_FRAME_INFO and INIT_FRAME_PC    will be called for the new frame.  For ARM, we save the frame size    when we initialize the frame_info.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|arm_frame_chain
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
if|#
directive|if
literal|0
comment|/* FIXME: enable this code if we convert to new call dummy scheme.  */
block|CORE_ADDR fn_start, callers_pc, fp;
comment|/* is this a dummy frame? */
block|if (PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))     return fi->frame;
comment|/* dummy frame same as caller's frame */
comment|/* is caller-of-this a dummy frame? */
block|callers_pc = FRAME_SAVED_PC (fi);
comment|/* find out who called us: */
block|fp = arm_find_callers_reg (fi, ARM_FP_REGNUM);   if (PC_IN_CALL_DUMMY (callers_pc, fp, fp))     return fp;
comment|/* dummy frame's frame may bear no relation to ours */
block|if (find_pc_partial_function (fi->pc, 0,&fn_start, 0))     if (fn_start == entry_point_address ())       return 0;
comment|/* in _start fn, don't chain further */
endif|#
directive|endif
name|CORE_ADDR
name|caller_pc
decl_stmt|,
name|fn_start
decl_stmt|;
name|int
name|framereg
init|=
name|fi
operator|->
name|extra_info
operator|->
name|framereg
decl_stmt|;
if|if
condition|(
name|fi
operator|->
name|pc
operator|<
name|LOWEST_PC
condition|)
return|return
literal|0
return|;
comment|/* If the caller is the startup code, we're at the end of the chain.  */
name|caller_pc
operator|=
name|FRAME_SAVED_PC
argument_list|(
name|fi
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|caller_pc
argument_list|,
literal|0
argument_list|,
operator|&
name|fn_start
argument_list|,
literal|0
argument_list|)
condition|)
if|if
condition|(
name|fn_start
operator|==
name|entry_point_address
argument_list|()
condition|)
return|return
literal|0
return|;
comment|/* If the caller is Thumb and the caller is ARM, or vice versa,      the frame register of the caller is different from ours.      So we must scan the prologue of the caller to determine its      frame register number. */
comment|/* XXX Fixme, we should try to do this without creating a temporary      caller_fi.  */
if|if
condition|(
name|arm_pc_is_thumb
argument_list|(
name|caller_pc
argument_list|)
operator|!=
name|arm_pc_is_thumb
argument_list|(
name|fi
operator|->
name|pc
argument_list|)
condition|)
block|{
name|struct
name|frame_info
name|caller_fi
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
comment|/* Create a temporary frame suitable for scanning the caller's 	 prologue.  (Ugh.)  */
name|memset
argument_list|(
operator|&
name|caller_fi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|caller_fi
argument_list|)
argument_list|)
expr_stmt|;
name|caller_fi
operator|.
name|extra_info
operator|=
operator|(
expr|struct
name|frame_extra_info
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|frame_extra_info
argument_list|)
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|caller_fi
operator|.
name|extra_info
argument_list|)
expr_stmt|;
name|caller_fi
operator|.
name|saved_regs
operator|=
operator|(
name|CORE_ADDR
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|SIZEOF_FRAME_SAVED_REGS
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|caller_fi
operator|.
name|saved_regs
argument_list|)
expr_stmt|;
comment|/* Now, scan the prologue and obtain the frame register.  */
name|caller_fi
operator|.
name|pc
operator|=
name|caller_pc
expr_stmt|;
name|arm_scan_prologue
argument_list|(
operator|&
name|caller_fi
argument_list|)
expr_stmt|;
name|framereg
operator|=
name|caller_fi
operator|.
name|extra_info
operator|->
name|framereg
expr_stmt|;
comment|/* Deallocate the storage associated with the temporary frame 	 created above.  */
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
comment|/* If the caller used a frame register, return its value.      Otherwise, return the caller's stack pointer.  */
if|if
condition|(
name|framereg
operator|==
name|ARM_FP_REGNUM
operator|||
name|framereg
operator|==
name|THUMB_FP_REGNUM
condition|)
return|return
name|arm_find_callers_reg
argument_list|(
name|fi
argument_list|,
name|framereg
argument_list|)
return|;
else|else
return|return
name|fi
operator|->
name|frame
operator|+
name|fi
operator|->
name|extra_info
operator|->
name|framesize
return|;
block|}
end_function

begin_comment
comment|/* This function actually figures out the frame address for a given pc    and sp.  This is tricky because we sometimes don't use an explicit    frame pointer, and the previous stack pointer isn't necessarily    recorded on the stack.  The only reliable way to get this info is    to examine the prologue.  FROMLEAF is a little confusing, it means    this is the next frame up the chain AFTER a frameless function.  If    this is true, then the frame value for this frame is still in the    fp register.  */
end_comment

begin_function
specifier|static
name|void
name|arm_init_extra_frame_info
parameter_list|(
name|int
name|fromleaf
parameter_list|,
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
name|CORE_ADDR
name|sp
decl_stmt|;
if|if
condition|(
name|fi
operator|->
name|saved_regs
operator|==
name|NULL
condition|)
name|frame_saved_regs_zalloc
argument_list|(
name|fi
argument_list|)
expr_stmt|;
name|fi
operator|->
name|extra_info
operator|=
operator|(
expr|struct
name|frame_extra_info
operator|*
operator|)
name|frame_obstack_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|frame_extra_info
argument_list|)
argument_list|)
expr_stmt|;
name|fi
operator|->
name|extra_info
operator|->
name|framesize
operator|=
literal|0
expr_stmt|;
name|fi
operator|->
name|extra_info
operator|->
name|frameoffset
operator|=
literal|0
expr_stmt|;
name|fi
operator|->
name|extra_info
operator|->
name|framereg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fi
operator|->
name|next
condition|)
name|fi
operator|->
name|pc
operator|=
name|FRAME_SAVED_PC
argument_list|(
name|fi
operator|->
name|next
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|fi
operator|->
name|saved_regs
argument_list|,
literal|'\000'
argument_list|,
sizeof|sizeof
name|fi
operator|->
name|saved_regs
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* FIXME: enable this code if we convert to new call dummy scheme.  */
block|if (PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))     {
comment|/* We need to setup fi->frame here because run_stack_dummy gets it wrong          by assuming it's always FP.  */
block|fi->frame = generic_read_register_dummy (fi->pc, fi->frame, 					       ARM_SP_REGNUM);       fi->extra_info->framesize = 0;       fi->extra_info->frameoffset = 0;       return;     }   else
endif|#
directive|endif
comment|/* Compute stack pointer for this frame.  We use this value for both the      sigtramp and call dummy cases.  */
if|if
condition|(
operator|!
name|fi
operator|->
name|next
condition|)
name|sp
operator|=
name|read_sp
argument_list|()
expr_stmt|;
else|else
name|sp
operator|=
operator|(
name|fi
operator|->
name|next
operator|->
name|frame
operator|-
name|fi
operator|->
name|next
operator|->
name|extra_info
operator|->
name|frameoffset
operator|+
name|fi
operator|->
name|next
operator|->
name|extra_info
operator|->
name|framesize
operator|)
expr_stmt|;
comment|/* Determine whether or not we're in a sigtramp frame.       Unfortunately, it isn't sufficient to test      fi->signal_handler_caller because this value is sometimes set      after invoking INIT_EXTRA_FRAME_INFO.  So we test *both*      fi->signal_handler_caller and IN_SIGTRAMP to determine if we need      to use the sigcontext addresses for the saved registers.       Note: If an ARM IN_SIGTRAMP method ever needs to compare against      the name of the function, the code below will have to be changed      to first fetch the name of the function and then pass this name      to IN_SIGTRAMP.  */
if|if
condition|(
name|SIGCONTEXT_REGISTER_ADDRESS_P
argument_list|()
operator|&&
operator|(
name|fi
operator|->
name|signal_handler_caller
operator|||
name|IN_SIGTRAMP
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
operator|)
condition|)
block|{
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<
name|NUM_REGS
condition|;
name|reg
operator|++
control|)
name|fi
operator|->
name|saved_regs
index|[
name|reg
index|]
operator|=
name|SIGCONTEXT_REGISTER_ADDRESS
argument_list|(
name|sp
argument_list|,
name|fi
operator|->
name|pc
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* FIXME: What about thumb mode? */
name|fi
operator|->
name|extra_info
operator|->
name|framereg
operator|=
name|ARM_SP_REGNUM
expr_stmt|;
name|fi
operator|->
name|frame
operator|=
name|read_memory_integer
argument_list|(
name|fi
operator|->
name|saved_regs
index|[
name|fi
operator|->
name|extra_info
operator|->
name|framereg
index|]
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|fi
operator|->
name|extra_info
operator|->
name|framereg
argument_list|)
argument_list|)
expr_stmt|;
name|fi
operator|->
name|extra_info
operator|->
name|framesize
operator|=
literal|0
expr_stmt|;
name|fi
operator|->
name|extra_info
operator|->
name|frameoffset
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PC_IN_CALL_DUMMY
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
name|sp
argument_list|,
name|fi
operator|->
name|frame
argument_list|)
condition|)
block|{
name|CORE_ADDR
name|rp
decl_stmt|;
name|CORE_ADDR
name|callers_sp
decl_stmt|;
comment|/* Set rp point at the high end of the saved registers.  */
name|rp
operator|=
name|fi
operator|->
name|frame
operator|-
name|REGISTER_SIZE
expr_stmt|;
comment|/* Fill in addresses of saved registers.  */
name|fi
operator|->
name|saved_regs
index|[
name|ARM_PS_REGNUM
index|]
operator|=
name|rp
expr_stmt|;
name|rp
operator|-=
name|REGISTER_RAW_SIZE
argument_list|(
name|ARM_PS_REGNUM
argument_list|)
expr_stmt|;
for|for
control|(
name|reg
operator|=
name|ARM_PC_REGNUM
init|;
name|reg
operator|>=
literal|0
condition|;
name|reg
operator|--
control|)
block|{
name|fi
operator|->
name|saved_regs
index|[
name|reg
index|]
operator|=
name|rp
expr_stmt|;
name|rp
operator|-=
name|REGISTER_RAW_SIZE
argument_list|(
name|reg
argument_list|)
expr_stmt|;
block|}
name|callers_sp
operator|=
name|read_memory_integer
argument_list|(
name|fi
operator|->
name|saved_regs
index|[
name|ARM_SP_REGNUM
index|]
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|ARM_SP_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|fi
operator|->
name|extra_info
operator|->
name|framereg
operator|=
name|ARM_FP_REGNUM
expr_stmt|;
name|fi
operator|->
name|extra_info
operator|->
name|framesize
operator|=
name|callers_sp
operator|-
name|sp
expr_stmt|;
name|fi
operator|->
name|extra_info
operator|->
name|frameoffset
operator|=
name|fi
operator|->
name|frame
operator|-
name|sp
expr_stmt|;
block|}
else|else
block|{
name|arm_scan_prologue
argument_list|(
name|fi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fi
operator|->
name|next
condition|)
comment|/* this is the innermost frame? */
name|fi
operator|->
name|frame
operator|=
name|read_register
argument_list|(
name|fi
operator|->
name|extra_info
operator|->
name|framereg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fi
operator|->
name|extra_info
operator|->
name|framereg
operator|==
name|ARM_FP_REGNUM
operator|||
name|fi
operator|->
name|extra_info
operator|->
name|framereg
operator|==
name|THUMB_FP_REGNUM
condition|)
block|{
comment|/* not the innermost frame */
comment|/* If we have an FP, the callee saved it. */
if|if
condition|(
name|fi
operator|->
name|next
operator|->
name|saved_regs
index|[
name|fi
operator|->
name|extra_info
operator|->
name|framereg
index|]
operator|!=
literal|0
condition|)
name|fi
operator|->
name|frame
operator|=
name|read_memory_integer
argument_list|(
name|fi
operator|->
name|next
operator|->
name|saved_regs
index|[
name|fi
operator|->
name|extra_info
operator|->
name|framereg
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fromleaf
condition|)
comment|/* If we were called by a frameless fn.  then our frame is 	       still in the frame pointer register on the board... */
name|fi
operator|->
name|frame
operator|=
name|read_fp
argument_list|()
expr_stmt|;
block|}
comment|/* Calculate actual addresses of saved registers using offsets          determined by arm_scan_prologue.  */
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<
name|NUM_REGS
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|fi
operator|->
name|saved_regs
index|[
name|reg
index|]
operator|!=
literal|0
condition|)
name|fi
operator|->
name|saved_regs
index|[
name|reg
index|]
operator|+=
operator|(
name|fi
operator|->
name|frame
operator|+
name|fi
operator|->
name|extra_info
operator|->
name|framesize
operator|-
name|fi
operator|->
name|extra_info
operator|->
name|frameoffset
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Find the caller of this frame.  We do this by seeing if ARM_LR_REGNUM    is saved in the stack anywhere, otherwise we get it from the    registers.     The old definition of this function was a macro:    #define FRAME_SAVED_PC(FRAME) \    ADDR_BITS_REMOVE (read_memory_integer ((FRAME)->frame - 4, 4)) */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|arm_frame_saved_pc
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
if|#
directive|if
literal|0
comment|/* FIXME: enable this code if we convert to new call dummy scheme.  */
block|if (PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))     return generic_read_register_dummy (fi->pc, fi->frame, ARM_PC_REGNUM);   else
endif|#
directive|endif
if|if
condition|(
name|PC_IN_CALL_DUMMY
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
name|fi
operator|->
name|frame
operator|-
name|fi
operator|->
name|extra_info
operator|->
name|frameoffset
argument_list|,
name|fi
operator|->
name|frame
argument_list|)
condition|)
block|{
return|return
name|read_memory_integer
argument_list|(
name|fi
operator|->
name|saved_regs
index|[
name|ARM_PC_REGNUM
index|]
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|ARM_PC_REGNUM
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|CORE_ADDR
name|pc
init|=
name|arm_find_callers_reg
argument_list|(
name|fi
argument_list|,
name|ARM_LR_REGNUM
argument_list|)
decl_stmt|;
return|return
name|IS_THUMB_ADDR
argument_list|(
name|pc
argument_list|)
condition|?
name|UNMAKE_THUMB_ADDR
argument_list|(
name|pc
argument_list|)
else|:
name|pc
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return the frame address.  On ARM, it is R11; on Thumb it is R7.    Examine the Program Status Register to decide which state we're in.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|arm_read_fp
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|read_register
argument_list|(
name|ARM_PS_REGNUM
argument_list|)
operator|&
literal|0x20
condition|)
comment|/* Bit 5 is Thumb state bit */
return|return
name|read_register
argument_list|(
name|THUMB_FP_REGNUM
argument_list|)
return|;
comment|/* R7 if Thumb */
else|else
return|return
name|read_register
argument_list|(
name|ARM_FP_REGNUM
argument_list|)
return|;
comment|/* R11 if ARM */
block|}
end_function

begin_comment
comment|/* Store into a struct frame_saved_regs the addresses of the saved    registers of frame described by FRAME_INFO.  This includes special    registers such as PC and FP saved in special ways in the stack    frame.  SP is even more special: the address we return for it IS    the sp for the next frame.  */
end_comment

begin_function
specifier|static
name|void
name|arm_frame_init_saved_regs
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fip
parameter_list|)
block|{
if|if
condition|(
name|fip
operator|->
name|saved_regs
condition|)
return|return;
name|arm_init_extra_frame_info
argument_list|(
literal|0
argument_list|,
name|fip
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Push an empty stack frame, to record the current PC, etc.  */
end_comment

begin_function
specifier|static
name|void
name|arm_push_dummy_frame
parameter_list|(
name|void
parameter_list|)
block|{
name|CORE_ADDR
name|old_sp
init|=
name|read_register
argument_list|(
name|ARM_SP_REGNUM
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|sp
init|=
name|old_sp
decl_stmt|;
name|CORE_ADDR
name|fp
decl_stmt|,
name|prologue_start
decl_stmt|;
name|int
name|regnum
decl_stmt|;
comment|/* Push the two dummy prologue instructions in reverse order,      so that they'll be in the correct low-to-high order in memory.  */
comment|/* sub     fp, ip, #4 */
name|sp
operator|=
name|push_word
argument_list|(
name|sp
argument_list|,
literal|0xe24cb004
argument_list|)
expr_stmt|;
comment|/*  stmdb   sp!, {r0-r10, fp, ip, lr, pc} */
name|prologue_start
operator|=
name|sp
operator|=
name|push_word
argument_list|(
name|sp
argument_list|,
literal|0xe92ddfff
argument_list|)
expr_stmt|;
comment|/* Push a pointer to the dummy prologue + 12, because when stm      instruction stores the PC, it stores the address of the stm      instruction itself plus 12.  */
name|fp
operator|=
name|sp
operator|=
name|push_word
argument_list|(
name|sp
argument_list|,
name|prologue_start
operator|+
literal|12
argument_list|)
expr_stmt|;
comment|/* Push the processor status.  */
name|sp
operator|=
name|push_word
argument_list|(
name|sp
argument_list|,
name|read_register
argument_list|(
name|ARM_PS_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Push all 16 registers starting with r15.  */
for|for
control|(
name|regnum
operator|=
name|ARM_PC_REGNUM
init|;
name|regnum
operator|>=
literal|0
condition|;
name|regnum
operator|--
control|)
name|sp
operator|=
name|push_word
argument_list|(
name|sp
argument_list|,
name|read_register
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Update fp (for both Thumb and ARM) and sp.  */
name|write_register
argument_list|(
name|ARM_FP_REGNUM
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|THUMB_FP_REGNUM
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|ARM_SP_REGNUM
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* CALL_DUMMY_WORDS:    This sequence of words is the instructions     mov  lr,pc    mov  pc,r4    illegal     Note this is 12 bytes.  */
end_comment

begin_decl_stmt
specifier|static
name|LONGEST
name|arm_call_dummy_words
index|[]
init|=
block|{
literal|0xe1a0e00f
block|,
literal|0xe1a0f004
block|,
literal|0xe7ffdefe
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Adjust the call_dummy_breakpoint_offset for the bp_call_dummy    breakpoint to the proper address in the call dummy, so that    `finish' after a stop in a call dummy works.     FIXME rearnsha 2002-02018: Tweeking current_gdbarch is not an    optimal solution, but the call to arm_fix_call_dummy is immediately    followed by a call to run_stack_dummy, which is the only function    where call_dummy_breakpoint_offset is actually used.  */
end_comment

begin_function
specifier|static
name|void
name|arm_set_call_dummy_breakpoint_offset
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|caller_is_thumb
condition|)
name|set_gdbarch_call_dummy_breakpoint_offset
argument_list|(
name|current_gdbarch
argument_list|,
literal|4
argument_list|)
expr_stmt|;
else|else
name|set_gdbarch_call_dummy_breakpoint_offset
argument_list|(
name|current_gdbarch
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fix up the call dummy, based on whether the processor is currently    in Thumb or ARM mode, and whether the target function is Thumb or    ARM.  There are three different situations requiring three    different dummies:     * ARM calling ARM: uses the call dummy in tm-arm.h, which has already    been copied into the dummy parameter to this function.    * ARM calling Thumb: uses the call dummy in tm-arm.h, but with the    "mov pc,r4" instruction patched to be a "bx r4" instead.    * Thumb calling anything: uses the Thumb dummy defined below, which    works for calling both ARM and Thumb functions.     All three call dummies expect to receive the target function    address in R4, with the low bit set if it's a Thumb function.  */
end_comment

begin_function
specifier|static
name|void
name|arm_fix_call_dummy
parameter_list|(
name|char
modifier|*
name|dummy
parameter_list|,
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
name|fun
parameter_list|,
name|int
name|nargs
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|args
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|gcc_p
parameter_list|)
block|{
specifier|static
name|short
name|thumb_dummy
index|[
literal|4
index|]
init|=
block|{
literal|0xf000
block|,
literal|0xf801
block|,
comment|/*        bl      label */
literal|0xdf18
block|,
comment|/*        swi     24 */
literal|0x4720
block|,
comment|/* label: bx      r4 */
block|}
decl_stmt|;
specifier|static
name|unsigned
name|long
name|arm_bx_r4
init|=
literal|0xe12fff14
decl_stmt|;
comment|/* bx r4 instruction */
comment|/* Set flag indicating whether the current PC is in a Thumb function. */
name|caller_is_thumb
operator|=
name|arm_pc_is_thumb
argument_list|(
name|read_pc
argument_list|()
argument_list|)
expr_stmt|;
name|arm_set_call_dummy_breakpoint_offset
argument_list|()
expr_stmt|;
comment|/* If the target function is Thumb, set the low bit of the function      address.  And if the CPU is currently in ARM mode, patch the      second instruction of call dummy to use a BX instruction to      switch to Thumb mode.  */
name|target_is_thumb
operator|=
name|arm_pc_is_thumb
argument_list|(
name|fun
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_is_thumb
condition|)
block|{
name|fun
operator||=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|caller_is_thumb
condition|)
name|store_unsigned_integer
argument_list|(
name|dummy
operator|+
literal|4
argument_list|,
sizeof|sizeof
argument_list|(
name|arm_bx_r4
argument_list|)
argument_list|,
name|arm_bx_r4
argument_list|)
expr_stmt|;
block|}
comment|/* If the CPU is currently in Thumb mode, use the Thumb call dummy      instead of the ARM one that's already been copied.  This will      work for both Thumb and ARM target functions.  */
if|if
condition|(
name|caller_is_thumb
condition|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|dummy
decl_stmt|;
name|int
name|len
init|=
sizeof|sizeof
argument_list|(
name|thumb_dummy
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|thumb_dummy
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|store_unsigned_integer
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|thumb_dummy
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|thumb_dummy
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|thumb_dummy
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Put the target address in r4; the call dummy will copy this to      the PC. */
name|write_register
argument_list|(
literal|4
argument_list|,
name|fun
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Note: ScottB     This function does not support passing parameters using the FPA    variant of the APCS.  It passes any floating point arguments in the    general registers and/or on the stack.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|arm_push_arguments
parameter_list|(
name|int
name|nargs
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|args
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|,
name|int
name|struct_return
parameter_list|,
name|CORE_ADDR
name|struct_addr
parameter_list|)
block|{
name|char
modifier|*
name|fp
decl_stmt|;
name|int
name|argnum
decl_stmt|,
name|argreg
decl_stmt|,
name|nstack_size
decl_stmt|;
comment|/* Walk through the list of args and determine how large a temporary      stack is required.  Need to take care here as structs may be      passed on the stack, and we have to to push them.  */
name|nstack_size
operator|=
operator|-
literal|4
operator|*
name|REGISTER_SIZE
expr_stmt|;
comment|/* Some arguments go into A1-A4.  */
if|if
condition|(
name|struct_return
condition|)
comment|/* The struct address goes in A1.  */
name|nstack_size
operator|+=
name|REGISTER_SIZE
expr_stmt|;
comment|/* Walk through the arguments and add their size to nstack_size.  */
for|for
control|(
name|argnum
operator|=
literal|0
init|;
name|argnum
operator|<
name|nargs
condition|;
name|argnum
operator|++
control|)
block|{
name|int
name|len
decl_stmt|;
name|struct
name|type
modifier|*
name|arg_type
decl_stmt|;
name|arg_type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|args
index|[
name|argnum
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|arg_type
argument_list|)
expr_stmt|;
name|nstack_size
operator|+=
name|len
expr_stmt|;
block|}
comment|/* Allocate room on the stack, and initialize our stack frame      pointer.  */
name|fp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|nstack_size
operator|>
literal|0
condition|)
block|{
name|sp
operator|-=
name|nstack_size
expr_stmt|;
name|fp
operator|=
operator|(
name|char
operator|*
operator|)
name|sp
expr_stmt|;
block|}
comment|/* Initialize the integer argument register pointer.  */
name|argreg
operator|=
name|ARM_A1_REGNUM
expr_stmt|;
comment|/* The struct_return pointer occupies the first parameter passing      register.  */
if|if
condition|(
name|struct_return
condition|)
name|write_register
argument_list|(
name|argreg
operator|++
argument_list|,
name|struct_addr
argument_list|)
expr_stmt|;
comment|/* Process arguments from left to right.  Store as many as allowed      in the parameter passing registers (A1-A4), and save the rest on      the temporary stack.  */
for|for
control|(
name|argnum
operator|=
literal|0
init|;
name|argnum
operator|<
name|nargs
condition|;
name|argnum
operator|++
control|)
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|CORE_ADDR
name|regval
decl_stmt|;
name|enum
name|type_code
name|typecode
decl_stmt|;
name|struct
name|type
modifier|*
name|arg_type
decl_stmt|,
modifier|*
name|target_type
decl_stmt|;
name|arg_type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|args
index|[
name|argnum
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|target_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|arg_type
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|arg_type
argument_list|)
expr_stmt|;
name|typecode
operator|=
name|TYPE_CODE
argument_list|(
name|arg_type
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|char
operator|*
operator|)
name|VALUE_CONTENTS
argument_list|(
name|args
index|[
name|argnum
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* I don't know why this code was disable. The only logical use          for a function pointer is to call that function, so setting          the mode bit is perfectly fine. FN */
comment|/* If the argument is a pointer to a function, and it is a Thumb          function, set the low bit of the pointer.  */
if|if
condition|(
name|TYPE_CODE_PTR
operator|==
name|typecode
operator|&&
name|NULL
operator|!=
name|target_type
operator|&&
name|TYPE_CODE_FUNC
operator|==
name|TYPE_CODE
argument_list|(
name|target_type
argument_list|)
condition|)
block|{
name|CORE_ADDR
name|regval
init|=
name|extract_address
argument_list|(
name|val
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|arm_pc_is_thumb
argument_list|(
name|regval
argument_list|)
condition|)
name|store_address
argument_list|(
name|val
argument_list|,
name|len
argument_list|,
name|MAKE_THUMB_ADDR
argument_list|(
name|regval
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Copy the argument to general registers or the stack in          register-sized pieces.  Large arguments are split between          registers and stack.  */
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|int
name|partial_len
init|=
name|len
operator|<
name|REGISTER_SIZE
condition|?
name|len
else|:
name|REGISTER_SIZE
decl_stmt|;
if|if
condition|(
name|argreg
operator|<=
name|ARM_LAST_ARG_REGNUM
condition|)
block|{
comment|/* It's an argument being passed in a general register.  */
name|regval
operator|=
name|extract_address
argument_list|(
name|val
argument_list|,
name|partial_len
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|argreg
operator|++
argument_list|,
name|regval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Push the arguments onto the stack.  */
name|write_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|fp
argument_list|,
name|val
argument_list|,
name|REGISTER_SIZE
argument_list|)
expr_stmt|;
name|fp
operator|+=
name|REGISTER_SIZE
expr_stmt|;
block|}
name|len
operator|-=
name|partial_len
expr_stmt|;
name|val
operator|+=
name|partial_len
expr_stmt|;
block|}
block|}
comment|/* Return adjusted stack pointer.  */
return|return
name|sp
return|;
block|}
end_function

begin_comment
comment|/* Pop the current frame.  So long as the frame info has been initialized    properly (see arm_init_extra_frame_info), this code works for dummy frames    as well as regular frames.  I.e, there's no need to have a special case    for dummy frames.  */
end_comment

begin_function
specifier|static
name|void
name|arm_pop_frame
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|regnum
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|frame
init|=
name|get_current_frame
argument_list|()
decl_stmt|;
name|CORE_ADDR
name|old_SP
init|=
operator|(
name|frame
operator|->
name|frame
operator|-
name|frame
operator|->
name|extra_info
operator|->
name|frameoffset
operator|+
name|frame
operator|->
name|extra_info
operator|->
name|framesize
operator|)
decl_stmt|;
for|for
control|(
name|regnum
operator|=
literal|0
init|;
name|regnum
operator|<
name|NUM_REGS
condition|;
name|regnum
operator|++
control|)
if|if
condition|(
name|frame
operator|->
name|saved_regs
index|[
name|regnum
index|]
operator|!=
literal|0
condition|)
name|write_register
argument_list|(
name|regnum
argument_list|,
name|read_memory_integer
argument_list|(
name|frame
operator|->
name|saved_regs
index|[
name|regnum
index|]
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|ARM_PC_REGNUM
argument_list|,
name|FRAME_SAVED_PC
argument_list|(
name|frame
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|ARM_SP_REGNUM
argument_list|,
name|old_SP
argument_list|)
expr_stmt|;
name|flush_cached_frames
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_fpu_flags
parameter_list|(
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|flags
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
condition|)
name|fputs
argument_list|(
literal|"IVO "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
condition|)
name|fputs
argument_list|(
literal|"DVZ "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
literal|1
operator|<<
literal|2
operator|)
condition|)
name|fputs
argument_list|(
literal|"OFL "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
literal|1
operator|<<
literal|3
operator|)
condition|)
name|fputs
argument_list|(
literal|"UFL "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
literal|1
operator|<<
literal|4
operator|)
condition|)
name|fputs
argument_list|(
literal|"INX "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print interesting information about the floating point processor    (if present) or emulator.  */
end_comment

begin_function
specifier|static
name|void
name|arm_print_float_info
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|unsigned
name|long
name|status
init|=
name|read_register
argument_list|(
name|ARM_FPS_REGNUM
argument_list|)
decl_stmt|;
name|int
name|type
decl_stmt|;
name|type
operator|=
operator|(
name|status
operator|>>
literal|24
operator|)
operator|&
literal|127
expr_stmt|;
name|printf
argument_list|(
literal|"%s FPU type %d\n"
argument_list|,
operator|(
name|status
operator|&
operator|(
literal|1
operator|<<
literal|31
operator|)
operator|)
condition|?
literal|"Hardware"
else|:
literal|"Software"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"mask: "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|print_fpu_flags
argument_list|(
name|status
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"flags: "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|print_fpu_flags
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the GDB type object for the "standard" data type of data in    register N.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|arm_register_type
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
if|if
condition|(
name|regnum
operator|>=
name|ARM_F0_REGNUM
operator|&&
name|regnum
operator|<
name|ARM_F0_REGNUM
operator|+
name|NUM_FREGS
condition|)
block|{
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|)
return|return
name|builtin_type_arm_ext_big
return|;
else|else
return|return
name|builtin_type_arm_ext_littlebyte_bigword
return|;
block|}
else|else
return|return
name|builtin_type_int32
return|;
block|}
end_function

begin_comment
comment|/* Index within `registers' of the first byte of the space for    register N.  */
end_comment

begin_function
specifier|static
name|int
name|arm_register_byte
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
if|if
condition|(
name|regnum
operator|<
name|ARM_F0_REGNUM
condition|)
return|return
name|regnum
operator|*
name|INT_REGISTER_RAW_SIZE
return|;
elseif|else
if|if
condition|(
name|regnum
operator|<
name|ARM_PS_REGNUM
condition|)
return|return
operator|(
name|NUM_GREGS
operator|*
name|INT_REGISTER_RAW_SIZE
operator|+
operator|(
name|regnum
operator|-
name|ARM_F0_REGNUM
operator|)
operator|*
name|FP_REGISTER_RAW_SIZE
operator|)
return|;
else|else
return|return
operator|(
name|NUM_GREGS
operator|*
name|INT_REGISTER_RAW_SIZE
operator|+
name|NUM_FREGS
operator|*
name|FP_REGISTER_RAW_SIZE
operator|+
operator|(
name|regnum
operator|-
name|ARM_FPS_REGNUM
operator|)
operator|*
name|STATUS_REGISTER_SIZE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Number of bytes of storage in the actual machine representation for    register N.  All registers are 4 bytes, except fp0 - fp7, which are    12 bytes in length.  */
end_comment

begin_function
specifier|static
name|int
name|arm_register_raw_size
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
if|if
condition|(
name|regnum
operator|<
name|ARM_F0_REGNUM
condition|)
return|return
name|INT_REGISTER_RAW_SIZE
return|;
elseif|else
if|if
condition|(
name|regnum
operator|<
name|ARM_FPS_REGNUM
condition|)
return|return
name|FP_REGISTER_RAW_SIZE
return|;
else|else
return|return
name|STATUS_REGISTER_SIZE
return|;
block|}
end_function

begin_comment
comment|/* Number of bytes of storage in a program's representation    for register N.  */
end_comment

begin_function
specifier|static
name|int
name|arm_register_virtual_size
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
if|if
condition|(
name|regnum
operator|<
name|ARM_F0_REGNUM
condition|)
return|return
name|INT_REGISTER_VIRTUAL_SIZE
return|;
elseif|else
if|if
condition|(
name|regnum
operator|<
name|ARM_FPS_REGNUM
condition|)
return|return
name|FP_REGISTER_VIRTUAL_SIZE
return|;
else|else
return|return
name|STATUS_REGISTER_SIZE
return|;
block|}
end_function

begin_comment
comment|/* NOTE: cagney/2001-08-20: Both convert_from_extended() and    convert_to_extended() use floatformat_arm_ext_littlebyte_bigword.    It is thought that this is is the floating-point register format on    little-endian systems.  */
end_comment

begin_function
specifier|static
name|void
name|convert_from_extended
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|void
modifier|*
name|dbl
parameter_list|)
block|{
name|DOUBLEST
name|d
decl_stmt|;
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|)
name|floatformat_to_doublest
argument_list|(
operator|&
name|floatformat_arm_ext_big
argument_list|,
name|ptr
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
else|else
name|floatformat_to_doublest
argument_list|(
operator|&
name|floatformat_arm_ext_littlebyte_bigword
argument_list|,
name|ptr
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
name|floatformat_from_doublest
argument_list|(
name|TARGET_DOUBLE_FORMAT
argument_list|,
operator|&
name|d
argument_list|,
name|dbl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|convert_to_extended
parameter_list|(
name|void
modifier|*
name|dbl
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|DOUBLEST
name|d
decl_stmt|;
name|floatformat_to_doublest
argument_list|(
name|TARGET_DOUBLE_FORMAT
argument_list|,
name|ptr
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|)
name|floatformat_from_doublest
argument_list|(
operator|&
name|floatformat_arm_ext_big
argument_list|,
operator|&
name|d
argument_list|,
name|dbl
argument_list|)
expr_stmt|;
else|else
name|floatformat_from_doublest
argument_list|(
operator|&
name|floatformat_arm_ext_littlebyte_bigword
argument_list|,
operator|&
name|d
argument_list|,
name|dbl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|condition_true
parameter_list|(
name|unsigned
name|long
name|cond
parameter_list|,
name|unsigned
name|long
name|status_reg
parameter_list|)
block|{
if|if
condition|(
name|cond
operator|==
name|INST_AL
operator|||
name|cond
operator|==
name|INST_NV
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|cond
condition|)
block|{
case|case
name|INST_EQ
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_Z
operator|)
operator|!=
literal|0
operator|)
return|;
case|case
name|INST_NE
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_Z
operator|)
operator|==
literal|0
operator|)
return|;
case|case
name|INST_CS
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_C
operator|)
operator|!=
literal|0
operator|)
return|;
case|case
name|INST_CC
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_C
operator|)
operator|==
literal|0
operator|)
return|;
case|case
name|INST_MI
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_N
operator|)
operator|!=
literal|0
operator|)
return|;
case|case
name|INST_PL
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_N
operator|)
operator|==
literal|0
operator|)
return|;
case|case
name|INST_VS
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_V
operator|)
operator|!=
literal|0
operator|)
return|;
case|case
name|INST_VC
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_V
operator|)
operator|==
literal|0
operator|)
return|;
case|case
name|INST_HI
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
operator|(
name|FLAG_C
operator||
name|FLAG_Z
operator|)
operator|)
operator|==
name|FLAG_C
operator|)
return|;
case|case
name|INST_LS
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
operator|(
name|FLAG_C
operator||
name|FLAG_Z
operator|)
operator|)
operator|!=
name|FLAG_C
operator|)
return|;
case|case
name|INST_GE
case|:
return|return
operator|(
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_N
operator|)
operator|==
literal|0
operator|)
operator|==
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_V
operator|)
operator|==
literal|0
operator|)
operator|)
return|;
case|case
name|INST_LT
case|:
return|return
operator|(
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_N
operator|)
operator|==
literal|0
operator|)
operator|!=
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_V
operator|)
operator|==
literal|0
operator|)
operator|)
return|;
case|case
name|INST_GT
case|:
return|return
operator|(
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_Z
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_N
operator|)
operator|==
literal|0
operator|)
operator|==
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_V
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
return|;
case|case
name|INST_LE
case|:
return|return
operator|(
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_Z
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_N
operator|)
operator|==
literal|0
operator|)
operator|!=
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_V
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Support routines for single stepping.  Calculate the next PC value.  */
end_comment

begin_define
define|#
directive|define
name|submask
parameter_list|(
name|x
parameter_list|)
value|((1L<< ((x) + 1)) - 1)
end_define

begin_define
define|#
directive|define
name|bit
parameter_list|(
name|obj
parameter_list|,
name|st
parameter_list|)
value|(((obj)>> (st))& 1)
end_define

begin_define
define|#
directive|define
name|bits
parameter_list|(
name|obj
parameter_list|,
name|st
parameter_list|,
name|fn
parameter_list|)
value|(((obj)>> (st))& submask ((fn) - (st)))
end_define

begin_define
define|#
directive|define
name|sbits
parameter_list|(
name|obj
parameter_list|,
name|st
parameter_list|,
name|fn
parameter_list|)
define|\
value|((long) (bits(obj,st,fn) | ((long) bit(obj,fn) * ~ submask (fn - st))))
end_define

begin_define
define|#
directive|define
name|BranchDest
parameter_list|(
name|addr
parameter_list|,
name|instr
parameter_list|)
define|\
value|((CORE_ADDR) (((long) (addr)) + 8 + (sbits (instr, 0, 23)<< 2)))
end_define

begin_define
define|#
directive|define
name|ARM_PC_32
value|1
end_define

begin_function
specifier|static
name|unsigned
name|long
name|shifted_reg_val
parameter_list|(
name|unsigned
name|long
name|inst
parameter_list|,
name|int
name|carry
parameter_list|,
name|unsigned
name|long
name|pc_val
parameter_list|,
name|unsigned
name|long
name|status_reg
parameter_list|)
block|{
name|unsigned
name|long
name|res
decl_stmt|,
name|shift
decl_stmt|;
name|int
name|rm
init|=
name|bits
argument_list|(
name|inst
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|shifttype
init|=
name|bits
argument_list|(
name|inst
argument_list|,
literal|5
argument_list|,
literal|6
argument_list|)
decl_stmt|;
if|if
condition|(
name|bit
argument_list|(
name|inst
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|int
name|rs
init|=
name|bits
argument_list|(
name|inst
argument_list|,
literal|8
argument_list|,
literal|11
argument_list|)
decl_stmt|;
name|shift
operator|=
operator|(
name|rs
operator|==
literal|15
condition|?
name|pc_val
operator|+
literal|8
else|:
name|read_register
argument_list|(
name|rs
argument_list|)
operator|)
operator|&
literal|0xFF
expr_stmt|;
block|}
else|else
name|shift
operator|=
name|bits
argument_list|(
name|inst
argument_list|,
literal|7
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|res
operator|=
operator|(
name|rm
operator|==
literal|15
condition|?
operator|(
operator|(
name|pc_val
operator||
operator|(
name|ARM_PC_32
condition|?
literal|0
else|:
name|status_reg
operator|)
operator|)
operator|+
operator|(
name|bit
argument_list|(
name|inst
argument_list|,
literal|4
argument_list|)
condition|?
literal|12
else|:
literal|8
operator|)
operator|)
else|:
name|read_register
argument_list|(
name|rm
argument_list|)
operator|)
expr_stmt|;
switch|switch
condition|(
name|shifttype
condition|)
block|{
case|case
literal|0
case|:
comment|/* LSL */
name|res
operator|=
name|shift
operator|>=
literal|32
condition|?
literal|0
else|:
name|res
operator|<<
name|shift
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* LSR */
name|res
operator|=
name|shift
operator|>=
literal|32
condition|?
literal|0
else|:
name|res
operator|>>
name|shift
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* ASR */
if|if
condition|(
name|shift
operator|>=
literal|32
condition|)
name|shift
operator|=
literal|31
expr_stmt|;
name|res
operator|=
operator|(
operator|(
name|res
operator|&
literal|0x80000000L
operator|)
condition|?
operator|~
operator|(
operator|(
operator|~
name|res
operator|)
operator|>>
name|shift
operator|)
else|:
name|res
operator|>>
name|shift
operator|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* ROR/RRX */
name|shift
operator|&=
literal|31
expr_stmt|;
if|if
condition|(
name|shift
operator|==
literal|0
condition|)
name|res
operator|=
operator|(
name|res
operator|>>
literal|1
operator|)
operator||
operator|(
name|carry
condition|?
literal|0x80000000L
else|:
literal|0
operator|)
expr_stmt|;
else|else
name|res
operator|=
operator|(
name|res
operator|>>
name|shift
operator|)
operator||
operator|(
name|res
operator|<<
operator|(
literal|32
operator|-
name|shift
operator|)
operator|)
expr_stmt|;
break|break;
block|}
return|return
name|res
operator|&
literal|0xffffffff
return|;
block|}
end_function

begin_comment
comment|/* Return number of 1-bits in VAL.  */
end_comment

begin_function
specifier|static
name|int
name|bitcount
parameter_list|(
name|unsigned
name|long
name|val
parameter_list|)
block|{
name|int
name|nbits
decl_stmt|;
for|for
control|(
name|nbits
operator|=
literal|0
init|;
name|val
operator|!=
literal|0
condition|;
name|nbits
operator|++
control|)
name|val
operator|&=
name|val
operator|-
literal|1
expr_stmt|;
comment|/* delete rightmost 1-bit in val */
return|return
name|nbits
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|thumb_get_next_pc
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|unsigned
name|long
name|pc_val
init|=
operator|(
operator|(
name|unsigned
name|long
operator|)
name|pc
operator|)
operator|+
literal|4
decl_stmt|;
comment|/* PC after prefetch */
name|unsigned
name|short
name|inst1
init|=
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|nextpc
init|=
name|pc
operator|+
literal|2
decl_stmt|;
comment|/* default is next instruction */
name|unsigned
name|long
name|offset
decl_stmt|;
if|if
condition|(
operator|(
name|inst1
operator|&
literal|0xff00
operator|)
operator|==
literal|0xbd00
condition|)
comment|/* pop {rlist, pc} */
block|{
name|CORE_ADDR
name|sp
decl_stmt|;
comment|/* Fetch the saved PC from the stack.  It's stored above          all of the other registers.  */
name|offset
operator|=
name|bitcount
argument_list|(
name|bits
argument_list|(
name|inst1
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|)
argument_list|)
operator|*
name|REGISTER_SIZE
expr_stmt|;
name|sp
operator|=
name|read_register
argument_list|(
name|ARM_SP_REGNUM
argument_list|)
expr_stmt|;
name|nextpc
operator|=
operator|(
name|CORE_ADDR
operator|)
name|read_memory_integer
argument_list|(
name|sp
operator|+
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|nextpc
operator|=
name|ADDR_BITS_REMOVE
argument_list|(
name|nextpc
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextpc
operator|==
name|pc
condition|)
name|error
argument_list|(
literal|"Infinite loop detected"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|inst1
operator|&
literal|0xf000
operator|)
operator|==
literal|0xd000
condition|)
comment|/* conditional branch */
block|{
name|unsigned
name|long
name|status
init|=
name|read_register
argument_list|(
name|ARM_PS_REGNUM
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|cond
init|=
name|bits
argument_list|(
name|inst1
argument_list|,
literal|8
argument_list|,
literal|11
argument_list|)
decl_stmt|;
if|if
condition|(
name|cond
operator|!=
literal|0x0f
operator|&&
name|condition_true
argument_list|(
name|cond
argument_list|,
name|status
argument_list|)
condition|)
comment|/* 0x0f = SWI */
name|nextpc
operator|=
name|pc_val
operator|+
operator|(
name|sbits
argument_list|(
name|inst1
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|)
operator|<<
literal|1
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|inst1
operator|&
literal|0xf800
operator|)
operator|==
literal|0xe000
condition|)
comment|/* unconditional branch */
block|{
name|nextpc
operator|=
name|pc_val
operator|+
operator|(
name|sbits
argument_list|(
name|inst1
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
operator|<<
literal|1
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|inst1
operator|&
literal|0xf800
operator|)
operator|==
literal|0xf000
condition|)
comment|/* long branch with link */
block|{
name|unsigned
name|short
name|inst2
init|=
name|read_memory_integer
argument_list|(
name|pc
operator|+
literal|2
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|offset
operator|=
operator|(
name|sbits
argument_list|(
name|inst1
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
operator|<<
literal|12
operator|)
operator|+
operator|(
name|bits
argument_list|(
name|inst2
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
operator|<<
literal|1
operator|)
expr_stmt|;
name|nextpc
operator|=
name|pc_val
operator|+
name|offset
expr_stmt|;
block|}
return|return
name|nextpc
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|arm_get_next_pc
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|unsigned
name|long
name|pc_val
decl_stmt|;
name|unsigned
name|long
name|this_instr
decl_stmt|;
name|unsigned
name|long
name|status
decl_stmt|;
name|CORE_ADDR
name|nextpc
decl_stmt|;
if|if
condition|(
name|arm_pc_is_thumb
argument_list|(
name|pc
argument_list|)
condition|)
return|return
name|thumb_get_next_pc
argument_list|(
name|pc
argument_list|)
return|;
name|pc_val
operator|=
operator|(
name|unsigned
name|long
operator|)
name|pc
expr_stmt|;
name|this_instr
operator|=
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|status
operator|=
name|read_register
argument_list|(
name|ARM_PS_REGNUM
argument_list|)
expr_stmt|;
name|nextpc
operator|=
call|(
name|CORE_ADDR
call|)
argument_list|(
name|pc_val
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* Default case */
if|if
condition|(
name|condition_true
argument_list|(
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|28
argument_list|,
literal|31
argument_list|)
argument_list|,
name|status
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|24
argument_list|,
literal|27
argument_list|)
condition|)
block|{
case|case
literal|0x0
case|:
case|case
literal|0x1
case|:
comment|/* data processing */
case|case
literal|0x2
case|:
case|case
literal|0x3
case|:
block|{
name|unsigned
name|long
name|operand1
decl_stmt|,
name|operand2
decl_stmt|,
name|result
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|rn
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|12
argument_list|,
literal|15
argument_list|)
operator|!=
literal|15
condition|)
break|break;
if|if
condition|(
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|22
argument_list|,
literal|25
argument_list|)
operator|==
literal|0
operator|&&
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|4
argument_list|,
literal|7
argument_list|)
operator|==
literal|9
condition|)
comment|/* multiply */
name|error
argument_list|(
literal|"Illegal update to pc in instruction"
argument_list|)
expr_stmt|;
comment|/* Multiply into PC */
name|c
operator|=
operator|(
name|status
operator|&
name|FLAG_C
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|rn
operator|=
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|16
argument_list|,
literal|19
argument_list|)
expr_stmt|;
name|operand1
operator|=
operator|(
name|rn
operator|==
literal|15
operator|)
condition|?
name|pc_val
operator|+
literal|8
else|:
name|read_register
argument_list|(
name|rn
argument_list|)
expr_stmt|;
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|25
argument_list|)
condition|)
block|{
name|unsigned
name|long
name|immval
init|=
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|rotate
init|=
literal|2
operator|*
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|8
argument_list|,
literal|11
argument_list|)
decl_stmt|;
name|operand2
operator|=
operator|(
operator|(
name|immval
operator|>>
name|rotate
operator|)
operator||
operator|(
name|immval
operator|<<
operator|(
literal|32
operator|-
name|rotate
operator|)
operator|)
operator|)
operator|&
literal|0xffffffff
expr_stmt|;
block|}
else|else
comment|/* operand 2 is a shifted register */
name|operand2
operator|=
name|shifted_reg_val
argument_list|(
name|this_instr
argument_list|,
name|c
argument_list|,
name|pc_val
argument_list|,
name|status
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|21
argument_list|,
literal|24
argument_list|)
condition|)
block|{
case|case
literal|0x0
case|:
comment|/*and */
name|result
operator|=
name|operand1
operator|&
name|operand2
expr_stmt|;
break|break;
case|case
literal|0x1
case|:
comment|/*eor */
name|result
operator|=
name|operand1
operator|^
name|operand2
expr_stmt|;
break|break;
case|case
literal|0x2
case|:
comment|/*sub */
name|result
operator|=
name|operand1
operator|-
name|operand2
expr_stmt|;
break|break;
case|case
literal|0x3
case|:
comment|/*rsb */
name|result
operator|=
name|operand2
operator|-
name|operand1
expr_stmt|;
break|break;
case|case
literal|0x4
case|:
comment|/*add */
name|result
operator|=
name|operand1
operator|+
name|operand2
expr_stmt|;
break|break;
case|case
literal|0x5
case|:
comment|/*adc */
name|result
operator|=
name|operand1
operator|+
name|operand2
operator|+
name|c
expr_stmt|;
break|break;
case|case
literal|0x6
case|:
comment|/*sbc */
name|result
operator|=
name|operand1
operator|-
name|operand2
operator|+
name|c
expr_stmt|;
break|break;
case|case
literal|0x7
case|:
comment|/*rsc */
name|result
operator|=
name|operand2
operator|-
name|operand1
operator|+
name|c
expr_stmt|;
break|break;
case|case
literal|0x8
case|:
case|case
literal|0x9
case|:
case|case
literal|0xa
case|:
case|case
literal|0xb
case|:
comment|/* tst, teq, cmp, cmn */
name|result
operator|=
operator|(
name|unsigned
name|long
operator|)
name|nextpc
expr_stmt|;
break|break;
case|case
literal|0xc
case|:
comment|/*orr */
name|result
operator|=
name|operand1
operator||
name|operand2
expr_stmt|;
break|break;
case|case
literal|0xd
case|:
comment|/*mov */
comment|/* Always step into a function.  */
name|result
operator|=
name|operand2
expr_stmt|;
break|break;
case|case
literal|0xe
case|:
comment|/*bic */
name|result
operator|=
name|operand1
operator|&
operator|~
name|operand2
expr_stmt|;
break|break;
case|case
literal|0xf
case|:
comment|/*mvn */
name|result
operator|=
operator|~
name|operand2
expr_stmt|;
break|break;
block|}
name|nextpc
operator|=
operator|(
name|CORE_ADDR
operator|)
name|ADDR_BITS_REMOVE
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextpc
operator|==
name|pc
condition|)
name|error
argument_list|(
literal|"Infinite loop detected"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|0x4
case|:
case|case
literal|0x5
case|:
comment|/* data transfer */
case|case
literal|0x6
case|:
case|case
literal|0x7
case|:
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|20
argument_list|)
condition|)
block|{
comment|/* load */
if|if
condition|(
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|12
argument_list|,
literal|15
argument_list|)
operator|==
literal|15
condition|)
block|{
comment|/* rd == pc */
name|unsigned
name|long
name|rn
decl_stmt|;
name|unsigned
name|long
name|base
decl_stmt|;
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|22
argument_list|)
condition|)
name|error
argument_list|(
literal|"Illegal update to pc in instruction"
argument_list|)
expr_stmt|;
comment|/* byte write to PC */
name|rn
operator|=
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|16
argument_list|,
literal|19
argument_list|)
expr_stmt|;
name|base
operator|=
operator|(
name|rn
operator|==
literal|15
operator|)
condition|?
name|pc_val
operator|+
literal|8
else|:
name|read_register
argument_list|(
name|rn
argument_list|)
expr_stmt|;
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|24
argument_list|)
condition|)
block|{
comment|/* pre-indexed */
name|int
name|c
init|=
operator|(
name|status
operator|&
name|FLAG_C
operator|)
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|unsigned
name|long
name|offset
init|=
operator|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|25
argument_list|)
condition|?
name|shifted_reg_val
argument_list|(
name|this_instr
argument_list|,
name|c
argument_list|,
name|pc_val
argument_list|,
name|status
argument_list|)
else|:
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|0
argument_list|,
literal|11
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|23
argument_list|)
condition|)
name|base
operator|+=
name|offset
expr_stmt|;
else|else
name|base
operator|-=
name|offset
expr_stmt|;
block|}
name|nextpc
operator|=
operator|(
name|CORE_ADDR
operator|)
name|read_memory_integer
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|base
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|nextpc
operator|=
name|ADDR_BITS_REMOVE
argument_list|(
name|nextpc
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextpc
operator|==
name|pc
condition|)
name|error
argument_list|(
literal|"Infinite loop detected"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|0x8
case|:
case|case
literal|0x9
case|:
comment|/* block transfer */
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|20
argument_list|)
condition|)
block|{
comment|/* LDM */
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|15
argument_list|)
condition|)
block|{
comment|/* loading pc */
name|int
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|23
argument_list|)
condition|)
block|{
comment|/* up */
name|unsigned
name|long
name|reglist
init|=
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|0
argument_list|,
literal|14
argument_list|)
decl_stmt|;
name|offset
operator|=
name|bitcount
argument_list|(
name|reglist
argument_list|)
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|24
argument_list|)
condition|)
comment|/* pre */
name|offset
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|24
argument_list|)
condition|)
name|offset
operator|=
operator|-
literal|4
expr_stmt|;
block|{
name|unsigned
name|long
name|rn_val
init|=
name|read_register
argument_list|(
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|16
argument_list|,
literal|19
argument_list|)
argument_list|)
decl_stmt|;
name|nextpc
operator|=
operator|(
name|CORE_ADDR
operator|)
name|read_memory_integer
argument_list|(
call|(
name|CORE_ADDR
call|)
argument_list|(
name|rn_val
operator|+
name|offset
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|nextpc
operator|=
name|ADDR_BITS_REMOVE
argument_list|(
name|nextpc
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextpc
operator|==
name|pc
condition|)
name|error
argument_list|(
literal|"Infinite loop detected"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|0xb
case|:
comment|/* branch& link */
case|case
literal|0xa
case|:
comment|/* branch */
block|{
name|nextpc
operator|=
name|BranchDest
argument_list|(
name|pc
argument_list|,
name|this_instr
argument_list|)
expr_stmt|;
name|nextpc
operator|=
name|ADDR_BITS_REMOVE
argument_list|(
name|nextpc
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextpc
operator|==
name|pc
condition|)
name|error
argument_list|(
literal|"Infinite loop detected"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|0xc
case|:
case|case
literal|0xd
case|:
case|case
literal|0xe
case|:
comment|/* coproc ops */
case|case
literal|0xf
case|:
comment|/* SWI */
break|break;
default|default:
name|fprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Bad bit-field extraction\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|pc
operator|)
return|;
block|}
block|}
return|return
name|nextpc
return|;
block|}
end_function

begin_comment
comment|/* single_step() is called just before we want to resume the inferior,    if we want to single-step it but there is no hardware or kernel    single-step support.  We find the target of the coming instruction    and breakpoint it.     single_step is also called just after the inferior stops.  If we had    set up a simulated single-step, we undo our damage.  */
end_comment

begin_function
specifier|static
name|void
name|arm_software_single_step
parameter_list|(
name|enum
name|target_signal
name|sig
parameter_list|,
name|int
name|insert_bpt
parameter_list|)
block|{
specifier|static
name|int
name|next_pc
decl_stmt|;
comment|/* State between setting and unsetting. */
specifier|static
name|char
name|break_mem
index|[
name|BREAKPOINT_MAX
index|]
decl_stmt|;
comment|/* Temporary storage for mem@bpt */
if|if
condition|(
name|insert_bpt
condition|)
block|{
name|next_pc
operator|=
name|arm_get_next_pc
argument_list|(
name|read_register
argument_list|(
name|ARM_PC_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|target_insert_breakpoint
argument_list|(
name|next_pc
argument_list|,
name|break_mem
argument_list|)
expr_stmt|;
block|}
else|else
name|target_remove_breakpoint
argument_list|(
name|next_pc
argument_list|,
name|break_mem
argument_list|)
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|"bfd-in2.h"
end_include

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_function
specifier|static
name|int
name|gdb_print_insn_arm
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
name|arm_pc_is_thumb
argument_list|(
name|memaddr
argument_list|)
condition|)
block|{
specifier|static
name|asymbol
modifier|*
name|asym
decl_stmt|;
specifier|static
name|combined_entry_type
name|ce
decl_stmt|;
specifier|static
name|struct
name|coff_symbol_struct
name|csym
decl_stmt|;
specifier|static
name|struct
name|_bfd
name|fake_bfd
decl_stmt|;
specifier|static
name|bfd_target
name|fake_target
decl_stmt|;
if|if
condition|(
name|csym
operator|.
name|native
operator|==
name|NULL
condition|)
block|{
comment|/* Create a fake symbol vector containing a Thumb symbol.  This is 	     solely so that the code in print_insn_little_arm() and 	     print_insn_big_arm() in opcodes/arm-dis.c will detect the presence 	     of a Thumb symbol and switch to decoding Thumb instructions.  */
name|fake_target
operator|.
name|flavour
operator|=
name|bfd_target_coff_flavour
expr_stmt|;
name|fake_bfd
operator|.
name|xvec
operator|=
operator|&
name|fake_target
expr_stmt|;
name|ce
operator|.
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|=
name|C_THUMBEXTFUNC
expr_stmt|;
name|csym
operator|.
name|native
operator|=
operator|&
name|ce
expr_stmt|;
name|csym
operator|.
name|symbol
operator|.
name|the_bfd
operator|=
operator|&
name|fake_bfd
expr_stmt|;
name|csym
operator|.
name|symbol
operator|.
name|name
operator|=
literal|"fake"
expr_stmt|;
name|asym
operator|=
operator|(
name|asymbol
operator|*
operator|)
operator|&
name|csym
expr_stmt|;
block|}
name|memaddr
operator|=
name|UNMAKE_THUMB_ADDR
argument_list|(
name|memaddr
argument_list|)
expr_stmt|;
name|info
operator|->
name|symbols
operator|=
operator|&
name|asym
expr_stmt|;
block|}
else|else
name|info
operator|->
name|symbols
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|)
return|return
name|print_insn_big_arm
argument_list|(
name|memaddr
argument_list|,
name|info
argument_list|)
return|;
else|else
return|return
name|print_insn_little_arm
argument_list|(
name|memaddr
argument_list|,
name|info
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The following define instruction sequences that will cause ARM    cpu's to take an undefined instruction trap.  These are used to    signal a breakpoint to GDB.        The newer ARMv4T cpu's are capable of operating in ARM or Thumb    modes.  A different instruction is required for each mode.  The ARM    cpu's can also be big or little endian.  Thus four different    instructions are needed to support all cases.        Note: ARMv4 defines several new instructions that will take the    undefined instruction trap.  ARM7TDMI is nominally ARMv4T, but does    not in fact add the new instructions.  The new undefined    instructions in ARMv4 are all instructions that had no defined    behaviour in earlier chips.  There is no guarantee that they will    raise an exception, but may be treated as NOP's.  In practice, it    may only safe to rely on instructions matching:        3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1     1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0    C C C C 0 1 1 x x x x x x x x x x x x x x x x x x x x 1 x x x x        Even this may only true if the condition predicate is true. The    following use a condition predicate of ALWAYS so it is always TRUE.        There are other ways of forcing a breakpoint.  GNU/Linux, RISC iX,    and NetBSD all use a software interrupt rather than an undefined    instruction to force a trap.  This can be handled by by the    abi-specific code during establishment of the gdbarch vector.  */
end_comment

begin_comment
comment|/* NOTE rearnsha 2002-02-18: for now we allow a non-multi-arch gdb to    override these definitions.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ARM_LE_BREAKPOINT
end_ifndef

begin_define
define|#
directive|define
name|ARM_LE_BREAKPOINT
value|{0xFE,0xDE,0xFF,0xE7}
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ARM_BE_BREAKPOINT
end_ifndef

begin_define
define|#
directive|define
name|ARM_BE_BREAKPOINT
value|{0xE7,0xFF,0xDE,0xFE}
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|THUMB_LE_BREAKPOINT
end_ifndef

begin_define
define|#
directive|define
name|THUMB_LE_BREAKPOINT
value|{0xfe,0xdf}
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|THUMB_BE_BREAKPOINT
end_ifndef

begin_define
define|#
directive|define
name|THUMB_BE_BREAKPOINT
value|{0xdf,0xfe}
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
name|arm_default_arm_le_breakpoint
index|[]
init|=
name|ARM_LE_BREAKPOINT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|arm_default_arm_be_breakpoint
index|[]
init|=
name|ARM_BE_BREAKPOINT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|arm_default_thumb_le_breakpoint
index|[]
init|=
name|THUMB_LE_BREAKPOINT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|arm_default_thumb_be_breakpoint
index|[]
init|=
name|THUMB_BE_BREAKPOINT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Determine the type and size of breakpoint to insert at PCPTR.  Uses    the program counter value to determine whether a 16-bit or 32-bit    breakpoint should be used.  It returns a pointer to a string of    bytes that encode a breakpoint instruction, stores the length of    the string to *lenptr, and adjusts the program counter (if    necessary) to point to the actual memory location where the    breakpoint should be inserted.  */
end_comment

begin_comment
comment|/* XXX ??? from old tm-arm.h: if we're using RDP, then we're inserting    breakpoints and storing their handles instread of what was in    memory.  It is nice that this is the same size as a handle -    otherwise remote-rdp will have to change. */
end_comment

begin_function
name|unsigned
name|char
modifier|*
name|arm_breakpoint_from_pc
parameter_list|(
name|CORE_ADDR
modifier|*
name|pcptr
parameter_list|,
name|int
modifier|*
name|lenptr
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
if|if
condition|(
name|arm_pc_is_thumb
argument_list|(
operator|*
name|pcptr
argument_list|)
operator|||
name|arm_pc_is_thumb_dummy
argument_list|(
operator|*
name|pcptr
argument_list|)
condition|)
block|{
operator|*
name|pcptr
operator|=
name|UNMAKE_THUMB_ADDR
argument_list|(
operator|*
name|pcptr
argument_list|)
expr_stmt|;
operator|*
name|lenptr
operator|=
name|tdep
operator|->
name|thumb_breakpoint_size
expr_stmt|;
return|return
name|tdep
operator|->
name|thumb_breakpoint
return|;
block|}
else|else
block|{
operator|*
name|lenptr
operator|=
name|tdep
operator|->
name|arm_breakpoint_size
expr_stmt|;
return|return
name|tdep
operator|->
name|arm_breakpoint
return|;
block|}
block|}
end_function

begin_comment
comment|/* Extract from an array REGBUF containing the (raw) register state a    function return value of type TYPE, and copy that, in virtual    format, into VALBUF.  */
end_comment

begin_function
specifier|static
name|void
name|arm_extract_return_value
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
name|regbuf
index|[
name|REGISTER_BYTES
index|]
parameter_list|,
name|char
modifier|*
name|valbuf
parameter_list|)
block|{
if|if
condition|(
name|TYPE_CODE_FLT
operator|==
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|tdep
operator|->
name|fp_model
condition|)
block|{
case|case
name|ARM_FLOAT_FPA
case|:
name|convert_from_extended
argument_list|(
operator|&
name|regbuf
index|[
name|REGISTER_BYTE
argument_list|(
name|ARM_F0_REGNUM
argument_list|)
index|]
argument_list|,
name|valbuf
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARM_FLOAT_SOFT
case|:
case|case
name|ARM_FLOAT_SOFT_VFP
case|:
name|memcpy
argument_list|(
name|valbuf
argument_list|,
operator|&
name|regbuf
index|[
name|REGISTER_BYTE
argument_list|(
name|ARM_A1_REGNUM
argument_list|)
index|]
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"arm_extract_return_value: Floating point model not supported"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
name|memcpy
argument_list|(
name|valbuf
argument_list|,
operator|&
name|regbuf
index|[
name|REGISTER_BYTE
argument_list|(
name|ARM_A1_REGNUM
argument_list|)
index|]
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Extract from an array REGBUF containing the (raw) register state    the address in which a function should return its structure value.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|arm_extract_struct_value_address
parameter_list|(
name|char
modifier|*
name|regbuf
parameter_list|)
block|{
return|return
name|extract_address
argument_list|(
name|regbuf
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|ARM_A1_REGNUM
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Will a function return an aggregate type in memory or in a    register?  Return 0 if an aggregate type can be returned in a    register, 1 if it must be returned in memory.  */
end_comment

begin_function
specifier|static
name|int
name|arm_use_struct_convention
parameter_list|(
name|int
name|gcc_p
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|int
name|nRc
decl_stmt|;
specifier|register
name|enum
name|type_code
name|code
decl_stmt|;
comment|/* In the ARM ABI, "integer" like aggregate types are returned in      registers.  For an aggregate type to be integer like, its size      must be less than or equal to REGISTER_SIZE and the offset of      each addressable subfield must be zero.  Note that bit fields are      not addressable, and all addressable subfields of unions always      start at offset zero.       This function is based on the behaviour of GCC 2.95.1.      See: gcc/arm.c: arm_return_in_memory() for details.       Note: All versions of GCC before GCC 2.95.2 do not set up the      parameters correctly for a function returning the following      structure: struct { float f;}; This should be returned in memory,      not a register.  Richard Earnshaw sent me a patch, but I do not      know of any way to detect if a function like the above has been      compiled with the correct calling convention.  */
comment|/* All aggregate types that won't fit in a register must be returned      in memory.  */
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|>
name|REGISTER_SIZE
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|/* The only aggregate types that can be returned in a register are      structs and unions.  Arrays must be returned in memory.  */
name|code
operator|=
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_CODE_STRUCT
operator|!=
name|code
operator|)
operator|&&
operator|(
name|TYPE_CODE_UNION
operator|!=
name|code
operator|)
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|/* Assume all other aggregate types can be returned in a register.      Run a check for structures, unions and arrays.  */
name|nRc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_CODE_STRUCT
operator|==
name|code
operator|)
operator|||
operator|(
name|TYPE_CODE_UNION
operator|==
name|code
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Need to check if this struct/union is "integer" like.  For          this to be true, its size must be less than or equal to          REGISTER_SIZE and the offset of each addressable subfield          must be zero.  Note that bit fields are not addressable, and          unions always start at offset zero.  If any of the subfields          is a floating point type, the struct/union cannot be an          integer type.  */
comment|/* For each field in the object, check:          1) Is it FP? --> yes, nRc = 1;          2) Is it addressable (bitpos != 0) and          not packed (bitsize == 0)?          --> yes, nRc = 1          */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|enum
name|type_code
name|field_type_code
decl_stmt|;
name|field_type_code
operator|=
name|TYPE_CODE
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Is it a floating point type field?  */
if|if
condition|(
name|field_type_code
operator|==
name|TYPE_CODE_FLT
condition|)
block|{
name|nRc
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* If bitpos != 0, then we have to care about it.  */
if|if
condition|(
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Bitfields are not addressable.  If the field bitsize is  	         zero, then the field is not packed.  Hence it cannot be 	         a bitfield or any other packed type.  */
if|if
condition|(
name|TYPE_FIELD_BITSIZE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|==
literal|0
condition|)
block|{
name|nRc
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
return|return
name|nRc
return|;
block|}
end_function

begin_comment
comment|/* Write into appropriate registers a function return value of type    TYPE, given in virtual format.  */
end_comment

begin_function
specifier|static
name|void
name|arm_store_return_value
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|valbuf
parameter_list|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FLT
condition|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
switch|switch
condition|(
name|tdep
operator|->
name|fp_model
condition|)
block|{
case|case
name|ARM_FLOAT_FPA
case|:
name|convert_to_extended
argument_list|(
name|valbuf
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|write_register_bytes
argument_list|(
name|REGISTER_BYTE
argument_list|(
name|ARM_F0_REGNUM
argument_list|)
argument_list|,
name|buf
argument_list|,
name|MAX_REGISTER_RAW_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARM_FLOAT_SOFT
case|:
case|case
name|ARM_FLOAT_SOFT_VFP
case|:
name|write_register_bytes
argument_list|(
name|ARM_A1_REGNUM
argument_list|,
name|valbuf
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"arm_store_return_value: Floating point model not supported"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
name|write_register_bytes
argument_list|(
name|ARM_A1_REGNUM
argument_list|,
name|valbuf
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store the address of the place in which to copy the structure the    subroutine will return.  This is called from call_function. */
end_comment

begin_function
specifier|static
name|void
name|arm_store_struct_return
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|)
block|{
name|write_register
argument_list|(
name|ARM_A1_REGNUM
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|arm_get_longjmp_target
parameter_list|(
name|CORE_ADDR
modifier|*
name|pc
parameter_list|)
block|{
name|CORE_ADDR
name|jb_addr
decl_stmt|;
name|char
name|buf
index|[
name|INT_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
name|jb_addr
operator|=
name|read_register
argument_list|(
name|ARM_A1_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|jb_addr
operator|+
name|tdep
operator|->
name|jb_pc
operator|*
name|tdep
operator|->
name|jb_elt_size
argument_list|,
name|buf
argument_list|,
name|INT_REGISTER_RAW_SIZE
argument_list|)
condition|)
return|return
literal|0
return|;
operator|*
name|pc
operator|=
name|extract_address
argument_list|(
name|buf
argument_list|,
name|INT_REGISTER_RAW_SIZE
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if the PC is inside a thumb call thunk.  */
end_comment

begin_function
name|int
name|arm_in_call_stub
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|CORE_ADDR
name|start_addr
decl_stmt|;
comment|/* Find the starting address of the function containing the PC.  If      the caller didn't give us a name, look it up at the same time.  */
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
name|name
condition|?
name|NULL
else|:
operator|&
name|name
argument_list|,
operator|&
name|start_addr
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_call_via_r"
argument_list|,
literal|11
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If PC is in a Thumb call or return stub, return the address of the    target PC, which is in a register.  The thunk functions are called    _called_via_xx, where x is the register name.  The possible names    are r0-r9, sl, fp, ip, sp, and lr.  */
end_comment

begin_function
name|CORE_ADDR
name|arm_skip_stub
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|CORE_ADDR
name|start_addr
decl_stmt|;
comment|/* Find the starting address and name of the function containing the PC.  */
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|start_addr
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Call thunks always start with "_call_via_".  */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_call_via_"
argument_list|,
literal|10
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Use the name suffix to determine which register contains the          target PC.  */
specifier|static
name|char
modifier|*
name|table
index|[
literal|15
index|]
init|=
block|{
literal|"r0"
block|,
literal|"r1"
block|,
literal|"r2"
block|,
literal|"r3"
block|,
literal|"r4"
block|,
literal|"r5"
block|,
literal|"r6"
block|,
literal|"r7"
block|,
literal|"r8"
block|,
literal|"r9"
block|,
literal|"sl"
block|,
literal|"fp"
block|,
literal|"ip"
block|,
literal|"sp"
block|,
literal|"lr"
block|}
decl_stmt|;
name|int
name|regno
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<=
literal|14
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|name
index|[
literal|10
index|]
argument_list|,
name|table
index|[
name|regno
index|]
argument_list|)
operator|==
literal|0
condition|)
return|return
name|read_register
argument_list|(
name|regno
argument_list|)
return|;
block|}
return|return
literal|0
return|;
comment|/* not a stub */
block|}
end_function

begin_comment
comment|/* If the user changes the register disassembly flavor used for info register    and other commands, we have to also switch the flavor used in opcodes    for disassembly output.    This function is run in the set disassembly_flavor command, and does that. */
end_comment

begin_function
specifier|static
name|void
name|set_disassembly_flavor_sfunc
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|set_disassembly_flavor
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the ARM register name corresponding to register I.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|arm_register_name
parameter_list|(
name|int
name|i
parameter_list|)
block|{
return|return
name|arm_register_names
index|[
name|i
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_disassembly_flavor
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|setname
decl_stmt|,
modifier|*
name|setdesc
decl_stmt|,
modifier|*
modifier|*
name|regnames
decl_stmt|;
name|int
name|numregs
decl_stmt|,
name|j
decl_stmt|;
comment|/* Find the flavor that the user wants in the opcodes table. */
name|int
name|current
init|=
literal|0
decl_stmt|;
name|numregs
operator|=
name|get_arm_regnames
argument_list|(
name|current
argument_list|,
operator|&
name|setname
argument_list|,
operator|&
name|setdesc
argument_list|,
operator|&
name|regnames
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|disassembly_flavor
operator|!=
name|setname
operator|)
operator|&&
operator|(
name|current
operator|<
name|num_flavor_options
operator|)
condition|)
name|get_arm_regnames
argument_list|(
operator|++
name|current
argument_list|,
operator|&
name|setname
argument_list|,
operator|&
name|setdesc
argument_list|,
operator|&
name|regnames
argument_list|)
expr_stmt|;
name|current_option
operator|=
name|current
expr_stmt|;
comment|/* Fill our copy. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|numregs
condition|;
name|j
operator|++
control|)
name|arm_register_names
index|[
name|j
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|regnames
index|[
name|j
index|]
expr_stmt|;
comment|/* Adjust case. */
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|regnames
index|[
name|ARM_PC_REGNUM
index|]
argument_list|)
condition|)
block|{
name|arm_register_names
index|[
name|ARM_FPS_REGNUM
index|]
operator|=
literal|"FPS"
expr_stmt|;
name|arm_register_names
index|[
name|ARM_PS_REGNUM
index|]
operator|=
literal|"CPSR"
expr_stmt|;
block|}
else|else
block|{
name|arm_register_names
index|[
name|ARM_FPS_REGNUM
index|]
operator|=
literal|"fps"
expr_stmt|;
name|arm_register_names
index|[
name|ARM_PS_REGNUM
index|]
operator|=
literal|"cpsr"
expr_stmt|;
block|}
comment|/* Synchronize the disassembler. */
name|set_arm_regname_option
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* arm_othernames implements the "othernames" command.  This is kind    of hacky, and I prefer the set-show disassembly-flavor which is    also used for the x86 gdb.  I will keep this around, however, in    case anyone is actually using it. */
end_comment

begin_function
specifier|static
name|void
name|arm_othernames
parameter_list|(
name|char
modifier|*
name|names
parameter_list|,
name|int
name|n
parameter_list|)
block|{
comment|/* Circle through the various flavors. */
name|current_option
operator|=
operator|(
name|current_option
operator|+
literal|1
operator|)
operator|%
name|num_flavor_options
expr_stmt|;
name|disassembly_flavor
operator|=
name|valid_flavors
index|[
name|current_option
index|]
expr_stmt|;
name|set_disassembly_flavor
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fetch, and possibly build, an appropriate link_map_offsets structure    for ARM linux targets using the struct offsets defined in<link.h>.    Note, however, that link.h is not actually referred to in this file.    Instead, the relevant structs offsets were obtained from examining    link.h.  (We can't refer to link.h from this file because the host    system won't necessarily have it, or if it does, the structs which    it defines will refer to the host system, not the target.)  */
end_comment

begin_function
name|struct
name|link_map_offsets
modifier|*
name|arm_linux_svr4_fetch_link_map_offsets
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|struct
name|link_map_offsets
name|lmo
decl_stmt|;
specifier|static
name|struct
name|link_map_offsets
modifier|*
name|lmp
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|lmp
operator|==
literal|0
condition|)
block|{
name|lmp
operator|=
operator|&
name|lmo
expr_stmt|;
name|lmo
operator|.
name|r_debug_size
operator|=
literal|8
expr_stmt|;
comment|/* Actual size is 20, but this is all we                                    need. */
name|lmo
operator|.
name|r_map_offset
operator|=
literal|4
expr_stmt|;
name|lmo
operator|.
name|r_map_size
operator|=
literal|4
expr_stmt|;
name|lmo
operator|.
name|link_map_size
operator|=
literal|20
expr_stmt|;
comment|/* Actual size is 552, but this is all we                                    need. */
name|lmo
operator|.
name|l_addr_offset
operator|=
literal|0
expr_stmt|;
name|lmo
operator|.
name|l_addr_size
operator|=
literal|4
expr_stmt|;
name|lmo
operator|.
name|l_name_offset
operator|=
literal|4
expr_stmt|;
name|lmo
operator|.
name|l_name_size
operator|=
literal|4
expr_stmt|;
name|lmo
operator|.
name|l_next_offset
operator|=
literal|12
expr_stmt|;
name|lmo
operator|.
name|l_next_size
operator|=
literal|4
expr_stmt|;
name|lmo
operator|.
name|l_prev_offset
operator|=
literal|16
expr_stmt|;
name|lmo
operator|.
name|l_prev_size
operator|=
literal|4
expr_stmt|;
block|}
return|return
name|lmp
return|;
block|}
end_function

begin_comment
comment|/* Test whether the coff symbol specific value corresponds to a Thumb    function.  */
end_comment

begin_function
specifier|static
name|int
name|coff_sym_is_thumb
parameter_list|(
name|int
name|val
parameter_list|)
block|{
return|return
operator|(
name|val
operator|==
name|C_THUMBEXT
operator|||
name|val
operator|==
name|C_THUMBSTAT
operator|||
name|val
operator|==
name|C_THUMBEXTFUNC
operator|||
name|val
operator|==
name|C_THUMBSTATFUNC
operator|||
name|val
operator|==
name|C_THUMBLABEL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* arm_coff_make_msymbol_special()    arm_elf_make_msymbol_special()        These functions test whether the COFF or ELF symbol corresponds to    an address in thumb code, and set a "special" bit in a minimal    symbol to indicate that it does.  */
end_comment

begin_function
specifier|static
name|void
name|arm_elf_make_msymbol_special
parameter_list|(
name|asymbol
modifier|*
name|sym
parameter_list|,
name|struct
name|minimal_symbol
modifier|*
name|msym
parameter_list|)
block|{
comment|/* Thumb symbols are of type STT_LOPROC, (synonymous with      STT_ARM_TFUNC).  */
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
operator|(
operator|(
name|elf_symbol_type
operator|*
operator|)
name|sym
operator|)
operator|->
name|internal_elf_sym
operator|.
name|st_info
argument_list|)
operator|==
name|STT_LOPROC
condition|)
name|MSYMBOL_SET_SPECIAL
argument_list|(
name|msym
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_coff_make_msymbol_special
parameter_list|(
name|int
name|val
parameter_list|,
name|struct
name|minimal_symbol
modifier|*
name|msym
parameter_list|)
block|{
if|if
condition|(
name|coff_sym_is_thumb
argument_list|(
name|val
argument_list|)
condition|)
name|MSYMBOL_SET_SPECIAL
argument_list|(
name|msym
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|process_note_abi_tag_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sect
parameter_list|,
name|void
modifier|*
name|obj
parameter_list|)
block|{
name|enum
name|arm_abi
modifier|*
name|os_ident_ptr
init|=
name|obj
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|sectsize
decl_stmt|;
name|name
operator|=
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
expr_stmt|;
name|sectsize
operator|=
name|bfd_section_size
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".note.ABI-tag"
argument_list|)
operator|==
literal|0
operator|&&
name|sectsize
operator|>
literal|0
condition|)
block|{
name|unsigned
name|int
name|name_length
decl_stmt|,
name|data_length
decl_stmt|,
name|note_type
decl_stmt|;
name|char
modifier|*
name|note
decl_stmt|;
comment|/* If the section is larger than this, it's probably not what we are 	 looking for.  */
if|if
condition|(
name|sectsize
operator|>
literal|128
condition|)
name|sectsize
operator|=
literal|128
expr_stmt|;
name|note
operator|=
name|alloca
argument_list|(
name|sectsize
argument_list|)
expr_stmt|;
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|,
name|note
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|sectsize
argument_list|)
expr_stmt|;
name|name_length
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|data_length
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|note
operator|+
literal|4
argument_list|)
expr_stmt|;
name|note_type
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|note
operator|+
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|name_length
operator|==
literal|4
operator|&&
name|data_length
operator|==
literal|16
operator|&&
name|note_type
operator|==
literal|1
operator|&&
name|strcmp
argument_list|(
name|note
operator|+
literal|12
argument_list|,
literal|"GNU"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|os_number
init|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|note
operator|+
literal|16
argument_list|)
decl_stmt|;
comment|/* The case numbers are from abi-tags in glibc.  */
switch|switch
condition|(
name|os_number
condition|)
block|{
case|case
literal|0
case|:
operator|*
name|os_ident_ptr
operator|=
name|ARM_ABI_LINUX
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"process_note_abi_sections: Hurd objects not supported"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"process_note_abi_sections: Solaris objects not supported"
argument_list|)
expr_stmt|;
break|break;
default|default :
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"process_note_abi_sections: unknown OS number %d"
argument_list|,
name|os_number
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* NetBSD uses a similar trick.  */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".note.netbsd.ident"
argument_list|)
operator|==
literal|0
operator|&&
name|sectsize
operator|>
literal|0
condition|)
block|{
name|unsigned
name|int
name|name_length
decl_stmt|,
name|desc_length
decl_stmt|,
name|note_type
decl_stmt|;
name|char
modifier|*
name|note
decl_stmt|;
comment|/* If the section is larger than this, it's probably not what we are 	 looking for.  */
if|if
condition|(
name|sectsize
operator|>
literal|128
condition|)
name|sectsize
operator|=
literal|128
expr_stmt|;
name|note
operator|=
name|alloca
argument_list|(
name|sectsize
argument_list|)
expr_stmt|;
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|,
name|note
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
operator|(
name|bfd_size_type
operator|)
name|sectsize
argument_list|)
expr_stmt|;
name|name_length
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|note
argument_list|)
expr_stmt|;
name|desc_length
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|note
operator|+
literal|4
argument_list|)
expr_stmt|;
name|note_type
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
name|note
operator|+
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|name_length
operator|==
literal|7
operator|&&
name|desc_length
operator|==
literal|4
operator|&&
name|note_type
operator|==
literal|1
operator|&&
name|strcmp
argument_list|(
name|note
operator|+
literal|12
argument_list|,
literal|"NetBSD"
argument_list|)
operator|==
literal|0
condition|)
comment|/* XXX Should we check the version here? 	   Probably not necessary yet.  */
operator|*
name|os_ident_ptr
operator|=
name|ARM_ABI_NETBSD_ELF
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return one of the ELFOSABI_ constants for BFDs representing ELF    executables.  If it's not an ELF executable or if the OS/ABI couldn't    be determined, simply return -1.  */
end_comment

begin_function
specifier|static
name|int
name|get_elfosabi
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|int
name|elfosabi
decl_stmt|;
name|enum
name|arm_abi
name|arm_abi
init|=
name|ARM_ABI_UNKNOWN
decl_stmt|;
name|elfosabi
operator|=
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_ident
index|[
name|EI_OSABI
index|]
expr_stmt|;
comment|/* When elfosabi is 0 (ELFOSABI_NONE), this is supposed to indicate      that we're on a SYSV system.  However, GNU/Linux uses a note section      to record OS/ABI info, but leaves e_ident[EI_OSABI] zero.  So we      have to check the note sections too.       GNU/ARM tools set the EI_OSABI field to ELFOSABI_ARM, so handle that      as well.  */
if|if
condition|(
name|elfosabi
operator|==
literal|0
operator|||
name|elfosabi
operator|==
name|ELFOSABI_ARM
condition|)
block|{
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|process_note_abi_tag_sections
argument_list|,
operator|&
name|arm_abi
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arm_abi
operator|!=
name|ARM_ABI_UNKNOWN
condition|)
return|return
name|arm_abi
return|;
switch|switch
condition|(
name|elfosabi
condition|)
block|{
case|case
name|ELFOSABI_NONE
case|:
comment|/* Existing ARM Tools don't set this field, so look at the EI_FLAGS 	 field for more information.  */
switch|switch
condition|(
name|EF_ARM_EABI_VERSION
argument_list|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
argument_list|)
condition|)
block|{
case|case
name|EF_ARM_EABI_VER1
case|:
return|return
name|ARM_ABI_EABI_V1
return|;
case|case
name|EF_ARM_EABI_VER2
case|:
return|return
name|ARM_ABI_EABI_V2
return|;
case|case
name|EF_ARM_EABI_UNKNOWN
case|:
comment|/* Assume GNU tools.  */
return|return
name|ARM_ABI_APCS
return|;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"get_elfosabi: Unknown ARM EABI version 0x%lx"
argument_list|,
name|EF_ARM_EABI_VERSION
argument_list|(
name|elf_elfheader
argument_list|(
name|abfd
argument_list|)
operator|->
name|e_flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ELFOSABI_NETBSD
case|:
return|return
name|ARM_ABI_NETBSD_ELF
return|;
case|case
name|ELFOSABI_FREEBSD
case|:
return|return
name|ARM_ABI_FREEBSD
return|;
case|case
name|ELFOSABI_LINUX
case|:
return|return
name|ARM_ABI_LINUX
return|;
case|case
name|ELFOSABI_ARM
case|:
comment|/* Assume GNU tools with the old APCS abi.  */
return|return
name|ARM_ABI_APCS
return|;
default|default:
block|}
return|return
name|ARM_ABI_UNKNOWN
return|;
block|}
end_function

begin_struct
struct|struct
name|arm_abi_handler
block|{
name|struct
name|arm_abi_handler
modifier|*
name|next
decl_stmt|;
name|enum
name|arm_abi
name|abi
decl_stmt|;
name|void
function_decl|(
modifier|*
name|init_abi
function_decl|)
parameter_list|(
name|struct
name|gdbarch_info
parameter_list|,
name|struct
name|gdbarch
modifier|*
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|arm_abi_handler
modifier|*
name|arm_abi_handler_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|arm_gdbarch_register_os_abi
parameter_list|(
name|enum
name|arm_abi
name|abi
parameter_list|,
name|void
function_decl|(
modifier|*
name|init_abi
function_decl|)
parameter_list|(
name|struct
name|gdbarch_info
parameter_list|,
name|struct
name|gdbarch
modifier|*
parameter_list|)
parameter_list|)
block|{
name|struct
name|arm_abi_handler
modifier|*
modifier|*
name|handler_p
decl_stmt|;
for|for
control|(
name|handler_p
operator|=
operator|&
name|arm_abi_handler_list
init|;
operator|*
name|handler_p
operator|!=
name|NULL
condition|;
name|handler_p
operator|=
operator|&
operator|(
operator|*
name|handler_p
operator|)
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|handler_p
operator|)
operator|->
name|abi
operator|==
name|abi
condition|)
block|{
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"arm_gdbarch_register_os_abi: A handler for this ABI variant (%d)"
literal|" has already been registered"
argument_list|,
operator|(
name|int
operator|)
name|abi
argument_list|)
expr_stmt|;
comment|/* If user wants to continue, override previous definition.  */
operator|(
operator|*
name|handler_p
operator|)
operator|->
name|init_abi
operator|=
name|init_abi
expr_stmt|;
return|return;
block|}
block|}
operator|(
operator|*
name|handler_p
operator|)
operator|=
operator|(
expr|struct
name|arm_abi_handler
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|arm_abi_handler
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|handler_p
operator|)
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|handler_p
operator|)
operator|->
name|abi
operator|=
name|abi
expr_stmt|;
operator|(
operator|*
name|handler_p
operator|)
operator|->
name|init_abi
operator|=
name|init_abi
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the current architecture based on INFO.  If possible, re-use an    architecture from ARCHES, which is a list of architectures already created    during this debugging session.     Called e.g. at program startup, when reading a core file, and when reading    a binary file.  */
end_comment

begin_function
specifier|static
name|struct
name|gdbarch
modifier|*
name|arm_gdbarch_init
parameter_list|(
name|struct
name|gdbarch_info
name|info
parameter_list|,
name|struct
name|gdbarch_list
modifier|*
name|arches
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
decl_stmt|;
name|struct
name|gdbarch
modifier|*
name|gdbarch
decl_stmt|;
name|enum
name|arm_abi
name|arm_abi
init|=
name|ARM_ABI_UNKNOWN
decl_stmt|;
name|struct
name|arm_abi_handler
modifier|*
name|abi_handler
decl_stmt|;
comment|/* Try to deterimine the ABI of the object we are loading.  */
if|if
condition|(
name|info
operator|.
name|abfd
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|bfd_get_flavour
argument_list|(
name|info
operator|.
name|abfd
argument_list|)
condition|)
block|{
case|case
name|bfd_target_elf_flavour
case|:
name|arm_abi
operator|=
name|get_elfosabi
argument_list|(
name|info
operator|.
name|abfd
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_target_aout_flavour
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|bfd_get_target
argument_list|(
name|info
operator|.
name|abfd
argument_list|)
argument_list|,
literal|"a.out-arm-netbsd"
argument_list|)
operator|==
literal|0
condition|)
name|arm_abi
operator|=
name|ARM_ABI_NETBSD_AOUT
expr_stmt|;
else|else
comment|/* Assume it's an old APCS-style ABI.  */
name|arm_abi
operator|=
name|ARM_ABI_APCS
expr_stmt|;
break|break;
case|case
name|bfd_target_coff_flavour
case|:
comment|/* Assume it's an old APCS-style ABI.  */
comment|/* XXX WinCE?  */
name|arm_abi
operator|=
name|ARM_ABI_APCS
expr_stmt|;
break|break;
default|default:
comment|/* Not sure what to do here, leave the ABI as unknown.  */
break|break;
block|}
block|}
comment|/* Find a candidate among extant architectures.  */
for|for
control|(
name|arches
operator|=
name|gdbarch_list_lookup_by_info
argument_list|(
name|arches
argument_list|,
operator|&
name|info
argument_list|)
init|;
name|arches
operator|!=
name|NULL
condition|;
name|arches
operator|=
name|gdbarch_list_lookup_by_info
argument_list|(
name|arches
operator|->
name|next
argument_list|,
operator|&
name|info
argument_list|)
control|)
block|{
comment|/* Make sure the ABI selection matches.  */
name|tdep
operator|=
name|gdbarch_tdep
argument_list|(
name|arches
operator|->
name|gdbarch
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdep
operator|&&
name|tdep
operator|->
name|arm_abi
operator|==
name|arm_abi
condition|)
return|return
name|arches
operator|->
name|gdbarch
return|;
block|}
name|tdep
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|gdbarch_tdep
argument_list|)
argument_list|)
expr_stmt|;
name|gdbarch
operator|=
name|gdbarch_alloc
argument_list|(
operator|&
name|info
argument_list|,
name|tdep
argument_list|)
expr_stmt|;
name|tdep
operator|->
name|arm_abi
operator|=
name|arm_abi
expr_stmt|;
if|if
condition|(
name|arm_abi
operator|<
name|ARM_ABI_INVALID
condition|)
name|tdep
operator|->
name|abi_name
operator|=
name|arm_abi_names
index|[
name|arm_abi
index|]
expr_stmt|;
else|else
block|{
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Invalid setting of arm_abi %d"
argument_list|,
operator|(
name|int
operator|)
name|arm_abi
argument_list|)
expr_stmt|;
name|tdep
operator|->
name|abi_name
operator|=
literal|"<invalid>"
expr_stmt|;
block|}
comment|/* This is the way it has always defaulted.  */
name|tdep
operator|->
name|fp_model
operator|=
name|ARM_FLOAT_FPA
expr_stmt|;
comment|/* Breakpoints.  */
switch|switch
condition|(
name|info
operator|.
name|byte_order
condition|)
block|{
case|case
name|BFD_ENDIAN_BIG
case|:
name|tdep
operator|->
name|arm_breakpoint
operator|=
name|arm_default_arm_be_breakpoint
expr_stmt|;
name|tdep
operator|->
name|arm_breakpoint_size
operator|=
sizeof|sizeof
argument_list|(
name|arm_default_arm_be_breakpoint
argument_list|)
expr_stmt|;
name|tdep
operator|->
name|thumb_breakpoint
operator|=
name|arm_default_thumb_be_breakpoint
expr_stmt|;
name|tdep
operator|->
name|thumb_breakpoint_size
operator|=
sizeof|sizeof
argument_list|(
name|arm_default_thumb_be_breakpoint
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_ENDIAN_LITTLE
case|:
name|tdep
operator|->
name|arm_breakpoint
operator|=
name|arm_default_arm_le_breakpoint
expr_stmt|;
name|tdep
operator|->
name|arm_breakpoint_size
operator|=
sizeof|sizeof
argument_list|(
name|arm_default_arm_le_breakpoint
argument_list|)
expr_stmt|;
name|tdep
operator|->
name|thumb_breakpoint
operator|=
name|arm_default_thumb_le_breakpoint
expr_stmt|;
name|tdep
operator|->
name|thumb_breakpoint_size
operator|=
sizeof|sizeof
argument_list|(
name|arm_default_thumb_le_breakpoint
argument_list|)
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"arm_gdbarch_init: bad byte order for float format"
argument_list|)
expr_stmt|;
block|}
comment|/* On ARM targets char defaults to unsigned.  */
name|set_gdbarch_char_signed
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* This should be low enough for everything.  */
name|tdep
operator|->
name|lowest_pc
operator|=
literal|0x20
expr_stmt|;
name|tdep
operator|->
name|jb_pc
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Longjump support not enabled by default.  */
name|set_gdbarch_use_generic_dummy_frames
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Call dummy code.  */
name|set_gdbarch_call_dummy_location
argument_list|(
name|gdbarch
argument_list|,
name|ON_STACK
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_breakpoint_offset_p
argument_list|(
name|gdbarch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* We have to give this a value now, even though we will re-set it       during each call to arm_fix_call_dummy.  */
name|set_gdbarch_call_dummy_breakpoint_offset
argument_list|(
name|gdbarch
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_p
argument_list|(
name|gdbarch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_stack_adjust_p
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_words
argument_list|(
name|gdbarch
argument_list|,
name|arm_call_dummy_words
argument_list|)
expr_stmt|;
name|set_gdbarch_sizeof_call_dummy_words
argument_list|(
name|gdbarch
argument_list|,
sizeof|sizeof
argument_list|(
name|arm_call_dummy_words
argument_list|)
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_start_offset
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_length
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_gdbarch_fix_call_dummy
argument_list|(
name|gdbarch
argument_list|,
name|arm_fix_call_dummy
argument_list|)
expr_stmt|;
name|set_gdbarch_pc_in_call_dummy
argument_list|(
name|gdbarch
argument_list|,
name|pc_in_call_dummy_on_stack
argument_list|)
expr_stmt|;
name|set_gdbarch_get_saved_register
argument_list|(
name|gdbarch
argument_list|,
name|generic_get_saved_register
argument_list|)
expr_stmt|;
name|set_gdbarch_push_arguments
argument_list|(
name|gdbarch
argument_list|,
name|arm_push_arguments
argument_list|)
expr_stmt|;
name|set_gdbarch_coerce_float_to_double
argument_list|(
name|gdbarch
argument_list|,
name|standard_coerce_float_to_double
argument_list|)
expr_stmt|;
comment|/* Frame handling.  */
name|set_gdbarch_frame_chain_valid
argument_list|(
name|gdbarch
argument_list|,
name|arm_frame_chain_valid
argument_list|)
expr_stmt|;
name|set_gdbarch_init_extra_frame_info
argument_list|(
name|gdbarch
argument_list|,
name|arm_init_extra_frame_info
argument_list|)
expr_stmt|;
name|set_gdbarch_read_fp
argument_list|(
name|gdbarch
argument_list|,
name|arm_read_fp
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_chain
argument_list|(
name|gdbarch
argument_list|,
name|arm_frame_chain
argument_list|)
expr_stmt|;
name|set_gdbarch_frameless_function_invocation
argument_list|(
name|gdbarch
argument_list|,
name|arm_frameless_function_invocation
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_saved_pc
argument_list|(
name|gdbarch
argument_list|,
name|arm_frame_saved_pc
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_args_address
argument_list|(
name|gdbarch
argument_list|,
name|arm_frame_args_address
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_locals_address
argument_list|(
name|gdbarch
argument_list|,
name|arm_frame_locals_address
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_num_args
argument_list|(
name|gdbarch
argument_list|,
name|arm_frame_num_args
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_args_skip
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_init_saved_regs
argument_list|(
name|gdbarch
argument_list|,
name|arm_frame_init_saved_regs
argument_list|)
expr_stmt|;
name|set_gdbarch_push_dummy_frame
argument_list|(
name|gdbarch
argument_list|,
name|arm_push_dummy_frame
argument_list|)
expr_stmt|;
name|set_gdbarch_pop_frame
argument_list|(
name|gdbarch
argument_list|,
name|arm_pop_frame
argument_list|)
expr_stmt|;
comment|/* Address manipulation.  */
name|set_gdbarch_smash_text_address
argument_list|(
name|gdbarch
argument_list|,
name|arm_smash_text_address
argument_list|)
expr_stmt|;
name|set_gdbarch_addr_bits_remove
argument_list|(
name|gdbarch
argument_list|,
name|arm_addr_bits_remove
argument_list|)
expr_stmt|;
comment|/* Offset from address of function to start of its code.  */
name|set_gdbarch_function_start_offset
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Advance PC across function entry code.  */
name|set_gdbarch_skip_prologue
argument_list|(
name|gdbarch
argument_list|,
name|arm_skip_prologue
argument_list|)
expr_stmt|;
comment|/* Get the PC when a frame might not be available.  */
name|set_gdbarch_saved_pc_after_call
argument_list|(
name|gdbarch
argument_list|,
name|arm_saved_pc_after_call
argument_list|)
expr_stmt|;
comment|/* The stack grows downward.  */
name|set_gdbarch_inner_than
argument_list|(
name|gdbarch
argument_list|,
name|core_addr_lessthan
argument_list|)
expr_stmt|;
comment|/* Breakpoint manipulation.  */
name|set_gdbarch_breakpoint_from_pc
argument_list|(
name|gdbarch
argument_list|,
name|arm_breakpoint_from_pc
argument_list|)
expr_stmt|;
name|set_gdbarch_decr_pc_after_break
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Information about registers, etc.  */
name|set_gdbarch_print_float_info
argument_list|(
name|gdbarch
argument_list|,
name|arm_print_float_info
argument_list|)
expr_stmt|;
name|set_gdbarch_fp_regnum
argument_list|(
name|gdbarch
argument_list|,
name|ARM_FP_REGNUM
argument_list|)
expr_stmt|;
comment|/* ??? */
name|set_gdbarch_sp_regnum
argument_list|(
name|gdbarch
argument_list|,
name|ARM_SP_REGNUM
argument_list|)
expr_stmt|;
name|set_gdbarch_pc_regnum
argument_list|(
name|gdbarch
argument_list|,
name|ARM_PC_REGNUM
argument_list|)
expr_stmt|;
name|set_gdbarch_register_byte
argument_list|(
name|gdbarch
argument_list|,
name|arm_register_byte
argument_list|)
expr_stmt|;
name|set_gdbarch_register_bytes
argument_list|(
name|gdbarch
argument_list|,
operator|(
name|NUM_GREGS
operator|*
name|INT_REGISTER_RAW_SIZE
operator|+
name|NUM_FREGS
operator|*
name|FP_REGISTER_RAW_SIZE
operator|+
name|NUM_SREGS
operator|*
name|STATUS_REGISTER_SIZE
operator|)
argument_list|)
expr_stmt|;
name|set_gdbarch_num_regs
argument_list|(
name|gdbarch
argument_list|,
name|NUM_GREGS
operator|+
name|NUM_FREGS
operator|+
name|NUM_SREGS
argument_list|)
expr_stmt|;
name|set_gdbarch_register_raw_size
argument_list|(
name|gdbarch
argument_list|,
name|arm_register_raw_size
argument_list|)
expr_stmt|;
name|set_gdbarch_register_virtual_size
argument_list|(
name|gdbarch
argument_list|,
name|arm_register_virtual_size
argument_list|)
expr_stmt|;
name|set_gdbarch_max_register_raw_size
argument_list|(
name|gdbarch
argument_list|,
name|FP_REGISTER_RAW_SIZE
argument_list|)
expr_stmt|;
name|set_gdbarch_max_register_virtual_size
argument_list|(
name|gdbarch
argument_list|,
name|FP_REGISTER_VIRTUAL_SIZE
argument_list|)
expr_stmt|;
name|set_gdbarch_register_virtual_type
argument_list|(
name|gdbarch
argument_list|,
name|arm_register_type
argument_list|)
expr_stmt|;
comment|/* Integer registers are 4 bytes.  */
name|set_gdbarch_register_size
argument_list|(
name|gdbarch
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|set_gdbarch_register_name
argument_list|(
name|gdbarch
argument_list|,
name|arm_register_name
argument_list|)
expr_stmt|;
comment|/* Returning results.  */
name|set_gdbarch_extract_return_value
argument_list|(
name|gdbarch
argument_list|,
name|arm_extract_return_value
argument_list|)
expr_stmt|;
name|set_gdbarch_store_return_value
argument_list|(
name|gdbarch
argument_list|,
name|arm_store_return_value
argument_list|)
expr_stmt|;
name|set_gdbarch_store_struct_return
argument_list|(
name|gdbarch
argument_list|,
name|arm_store_struct_return
argument_list|)
expr_stmt|;
name|set_gdbarch_use_struct_convention
argument_list|(
name|gdbarch
argument_list|,
name|arm_use_struct_convention
argument_list|)
expr_stmt|;
name|set_gdbarch_extract_struct_value_address
argument_list|(
name|gdbarch
argument_list|,
name|arm_extract_struct_value_address
argument_list|)
expr_stmt|;
comment|/* Single stepping.  */
comment|/* XXX For an RDI target we should ask the target if it can single-step.  */
name|set_gdbarch_software_single_step
argument_list|(
name|gdbarch
argument_list|,
name|arm_software_single_step
argument_list|)
expr_stmt|;
comment|/* Minsymbol frobbing.  */
name|set_gdbarch_elf_make_msymbol_special
argument_list|(
name|gdbarch
argument_list|,
name|arm_elf_make_msymbol_special
argument_list|)
expr_stmt|;
name|set_gdbarch_coff_make_msymbol_special
argument_list|(
name|gdbarch
argument_list|,
name|arm_coff_make_msymbol_special
argument_list|)
expr_stmt|;
comment|/* Hook in the ABI-specific overrides, if they have been registered.  */
if|if
condition|(
name|arm_abi
operator|==
name|ARM_ABI_UNKNOWN
condition|)
block|{
comment|/* Don't complain about not knowing the ABI variant if we don't  	 have an inferior.  */
if|if
condition|(
name|info
operator|.
name|abfd
condition|)
name|fprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"GDB doesn't recognize the ABI of the inferior.  "
literal|"Attempting to continue with the default ARM settings"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|abi_handler
operator|=
name|arm_abi_handler_list
init|;
name|abi_handler
operator|!=
name|NULL
condition|;
name|abi_handler
operator|=
name|abi_handler
operator|->
name|next
control|)
if|if
condition|(
name|abi_handler
operator|->
name|abi
operator|==
name|arm_abi
condition|)
break|break;
if|if
condition|(
name|abi_handler
condition|)
name|abi_handler
operator|->
name|init_abi
argument_list|(
name|info
argument_list|,
name|gdbarch
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* We assume that if GDB_MULTI_ARCH is less than  	     GDB_MULTI_ARCH_TM that an ABI variant can be supported by 	     overriding definitions in this file.  */
if|if
condition|(
name|GDB_MULTI_ARCH
operator|>
name|GDB_MULTI_ARCH_PARTIAL
condition|)
name|fprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"A handler for the ABI variant \"%s\" is not built into this "
literal|"configuration of GDB.  "
literal|"Attempting to continue with the default ARM settings"
argument_list|,
name|arm_abi_names
index|[
name|arm_abi
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now we have tuned the configuration, set a few final things,      based on what the OS ABI has told us.  */
if|if
condition|(
name|tdep
operator|->
name|jb_pc
operator|>=
literal|0
condition|)
name|set_gdbarch_get_longjmp_target
argument_list|(
name|gdbarch
argument_list|,
name|arm_get_longjmp_target
argument_list|)
expr_stmt|;
comment|/* Floating point sizes and format.  */
switch|switch
condition|(
name|info
operator|.
name|byte_order
condition|)
block|{
case|case
name|BFD_ENDIAN_BIG
case|:
name|set_gdbarch_float_format
argument_list|(
name|gdbarch
argument_list|,
operator|&
name|floatformat_ieee_single_big
argument_list|)
expr_stmt|;
name|set_gdbarch_double_format
argument_list|(
name|gdbarch
argument_list|,
operator|&
name|floatformat_ieee_double_big
argument_list|)
expr_stmt|;
name|set_gdbarch_long_double_format
argument_list|(
name|gdbarch
argument_list|,
operator|&
name|floatformat_ieee_double_big
argument_list|)
expr_stmt|;
break|break;
case|case
name|BFD_ENDIAN_LITTLE
case|:
name|set_gdbarch_float_format
argument_list|(
name|gdbarch
argument_list|,
operator|&
name|floatformat_ieee_single_little
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdep
operator|->
name|fp_model
operator|==
name|ARM_FLOAT_VFP
operator|||
name|tdep
operator|->
name|fp_model
operator|==
name|ARM_FLOAT_SOFT_VFP
condition|)
block|{
name|set_gdbarch_double_format
argument_list|(
name|gdbarch
argument_list|,
operator|&
name|floatformat_ieee_double_little
argument_list|)
expr_stmt|;
name|set_gdbarch_long_double_format
argument_list|(
name|gdbarch
argument_list|,
operator|&
name|floatformat_ieee_double_little
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|set_gdbarch_double_format
argument_list|(
name|gdbarch
argument_list|,
operator|&
name|floatformat_ieee_double_littlebyte_bigword
argument_list|)
expr_stmt|;
name|set_gdbarch_long_double_format
argument_list|(
name|gdbarch
argument_list|,
operator|&
name|floatformat_ieee_double_littlebyte_bigword
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"arm_gdbarch_init: bad byte order for float format"
argument_list|)
expr_stmt|;
block|}
comment|/* We can't use SIZEOF_FRAME_SAVED_REGS here, since that still      references the old architecture vector, not the one we are      building here.  */
if|if
condition|(
name|prologue_cache
operator|.
name|saved_regs
operator|!=
name|NULL
condition|)
name|xfree
argument_list|(
name|prologue_cache
operator|.
name|saved_regs
argument_list|)
expr_stmt|;
name|prologue_cache
operator|.
name|saved_regs
operator|=
operator|(
name|CORE_ADDR
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
operator|*
operator|(
name|gdbarch_num_regs
argument_list|(
name|gdbarch
argument_list|)
operator|+
name|NUM_PSEUDO_REGS
operator|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|gdbarch
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_dump_tdep
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|current_gdbarch
parameter_list|,
name|struct
name|ui_file
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
if|if
condition|(
name|tdep
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|tdep
operator|->
name|abi_name
operator|!=
name|NULL
condition|)
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"arm_dump_tdep: ABI = %s\n"
argument_list|,
name|tdep
operator|->
name|abi_name
argument_list|)
expr_stmt|;
else|else
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"arm_dump_tdep: illegal setting of tdep->arm_abi (%d)"
argument_list|,
operator|(
name|int
operator|)
name|tdep
operator|->
name|arm_abi
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"arm_dump_tdep: Lowest pc = 0x%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|tdep
operator|->
name|lowest_pc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_init_abi_eabi_v1
parameter_list|(
name|struct
name|gdbarch_info
name|info
parameter_list|,
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|)
block|{
comment|/* Place-holder.  */
block|}
end_function

begin_function
specifier|static
name|void
name|arm_init_abi_eabi_v2
parameter_list|(
name|struct
name|gdbarch_info
name|info
parameter_list|,
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|)
block|{
comment|/* Place-holder.  */
block|}
end_function

begin_function
specifier|static
name|void
name|arm_init_abi_apcs
parameter_list|(
name|struct
name|gdbarch_info
name|info
parameter_list|,
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|)
block|{
comment|/* Place-holder.  */
block|}
end_function

begin_function
name|void
name|_initialize_arm_tdep
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ui_file
modifier|*
name|stb
decl_stmt|;
name|long
name|length
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|new_cmd
decl_stmt|;
specifier|const
name|char
modifier|*
name|setname
decl_stmt|;
specifier|const
name|char
modifier|*
name|setdesc
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|regnames
decl_stmt|;
name|int
name|numregs
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|static
name|char
modifier|*
name|helptext
decl_stmt|;
if|if
condition|(
name|GDB_MULTI_ARCH
condition|)
name|gdbarch_register
argument_list|(
name|bfd_arch_arm
argument_list|,
name|arm_gdbarch_init
argument_list|,
name|arm_dump_tdep
argument_list|)
expr_stmt|;
comment|/* Register some ABI variants for embedded systems.  */
name|arm_gdbarch_register_os_abi
argument_list|(
name|ARM_ABI_EABI_V1
argument_list|,
name|arm_init_abi_eabi_v1
argument_list|)
expr_stmt|;
name|arm_gdbarch_register_os_abi
argument_list|(
name|ARM_ABI_EABI_V2
argument_list|,
name|arm_init_abi_eabi_v2
argument_list|)
expr_stmt|;
name|arm_gdbarch_register_os_abi
argument_list|(
name|ARM_ABI_APCS
argument_list|,
name|arm_init_abi_apcs
argument_list|)
expr_stmt|;
name|tm_print_insn
operator|=
name|gdb_print_insn_arm
expr_stmt|;
comment|/* Get the number of possible sets of register names defined in opcodes. */
name|num_flavor_options
operator|=
name|get_arm_regname_num_options
argument_list|()
expr_stmt|;
comment|/* Sync the opcode insn printer with our register viewer: */
name|parse_arm_disassembler_option
argument_list|(
literal|"reg-names-std"
argument_list|)
expr_stmt|;
comment|/* Begin creating the help text. */
name|stb
operator|=
name|mem_fileopen
argument_list|()
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|stb
argument_list|,
literal|"Set the disassembly flavor.\n\ The valid values are:\n"
argument_list|)
expr_stmt|;
comment|/* Initialize the array that will be passed to add_set_enum_cmd(). */
name|valid_flavors
operator|=
name|xmalloc
argument_list|(
operator|(
name|num_flavor_options
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_flavor_options
condition|;
name|i
operator|++
control|)
block|{
name|numregs
operator|=
name|get_arm_regnames
argument_list|(
name|i
argument_list|,
operator|&
name|setname
argument_list|,
operator|&
name|setdesc
argument_list|,
operator|&
name|regnames
argument_list|)
expr_stmt|;
name|valid_flavors
index|[
name|i
index|]
operator|=
name|setname
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|stb
argument_list|,
literal|"%s - %s\n"
argument_list|,
name|setname
argument_list|,
name|setdesc
argument_list|)
expr_stmt|;
comment|/* Copy the default names (if found) and synchronize disassembler. */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|setname
argument_list|,
literal|"std"
argument_list|)
condition|)
block|{
name|disassembly_flavor
operator|=
name|setname
expr_stmt|;
name|current_option
operator|=
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|numregs
condition|;
name|j
operator|++
control|)
name|arm_register_names
index|[
name|j
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|regnames
index|[
name|j
index|]
expr_stmt|;
name|set_arm_regname_option
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Mark the end of valid options. */
name|valid_flavors
index|[
name|num_flavor_options
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Finish the creation of the help text. */
name|fprintf_unfiltered
argument_list|(
name|stb
argument_list|,
literal|"The default is \"std\"."
argument_list|)
expr_stmt|;
name|helptext
operator|=
name|ui_file_xstrdup
argument_list|(
name|stb
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|ui_file_delete
argument_list|(
name|stb
argument_list|)
expr_stmt|;
comment|/* Add the disassembly-flavor command */
name|new_cmd
operator|=
name|add_set_enum_cmd
argument_list|(
literal|"disassembly-flavor"
argument_list|,
name|no_class
argument_list|,
name|valid_flavors
argument_list|,
operator|&
name|disassembly_flavor
argument_list|,
name|helptext
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|set_cmd_sfunc
argument_list|(
name|new_cmd
argument_list|,
name|set_disassembly_flavor_sfunc
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|new_cmd
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
comment|/* ??? Maybe this should be a boolean.  */
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"apcs32"
argument_list|,
name|no_class
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|arm_apcs_32
argument_list|,
literal|"Set usage of ARM 32-bit mode.\n"
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
comment|/* Add the deprecated "othernames" command */
name|add_com
argument_list|(
literal|"othernames"
argument_list|,
name|class_obscure
argument_list|,
name|arm_othernames
argument_list|,
literal|"Switch to the next set of register names."
argument_list|)
expr_stmt|;
comment|/* Fill in the prologue_cache fields.  */
name|prologue_cache
operator|.
name|saved_regs
operator|=
name|NULL
expr_stmt|;
name|prologue_cache
operator|.
name|extra_info
operator|=
operator|(
expr|struct
name|frame_extra_info
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|frame_extra_info
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

