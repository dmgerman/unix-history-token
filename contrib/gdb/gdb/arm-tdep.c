begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Common target dependent code for GDB on ARM systems.    Copyright 1988, 1989, 1991, 1992, 1993, 1995, 1996, 1997, 1998, 1999, 2000    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_comment
comment|/* Internal format of COFF symbols in BFD */
end_comment

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_comment
comment|/* For register flavors. */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/* for isupper () */
end_comment

begin_function_decl
specifier|extern
name|void
name|_initialize_arm_tdep
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Number of different reg name sets (options). */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_flavor_options
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We have more registers than the disassembler as gdb can print the value    of special registers as well.    The general register names are overwritten by whatever is being used by    the disassembler at the moment. We also adjust the case of cpsr and fps. */
end_comment

begin_comment
comment|/* Initial value: Register names used in ARM's ISA documentation. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|arm_register_name_strings
index|[]
init|=
block|{
literal|"r0"
block|,
literal|"r1"
block|,
literal|"r2"
block|,
literal|"r3"
block|,
comment|/*  0  1  2  3 */
literal|"r4"
block|,
literal|"r5"
block|,
literal|"r6"
block|,
literal|"r7"
block|,
comment|/*  4  5  6  7 */
literal|"r8"
block|,
literal|"r9"
block|,
literal|"r10"
block|,
literal|"r11"
block|,
comment|/*  8  9 10 11 */
literal|"r12"
block|,
literal|"sp"
block|,
literal|"lr"
block|,
literal|"pc"
block|,
comment|/* 12 13 14 15 */
literal|"f0"
block|,
literal|"f1"
block|,
literal|"f2"
block|,
literal|"f3"
block|,
comment|/* 16 17 18 19 */
literal|"f4"
block|,
literal|"f5"
block|,
literal|"f6"
block|,
literal|"f7"
block|,
comment|/* 20 21 22 23 */
literal|"fps"
block|,
literal|"cpsr"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 24 25       */
end_comment

begin_decl_stmt
name|char
modifier|*
modifier|*
name|arm_register_names
init|=
name|arm_register_name_strings
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Valid register name flavors.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|valid_flavors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Disassembly flavor to use. Default to "std" register names. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|disassembly_flavor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|current_option
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index to that option in the opcodes table. */
end_comment

begin_comment
comment|/* This is used to keep the bfd arch_info in sync with the disassembly    flavor.  */
end_comment

begin_function_decl
specifier|static
name|void
name|set_disassembly_flavor_sfunc
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_disassembly_flavor
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|convert_from_extended
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|void
modifier|*
name|dbl
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Define other aspects of the stack frame.  We keep the offsets of    all saved registers, 'cause we need 'em a lot!  We also keep the    current size of the stack frame, and the offset of the frame    pointer from the stack pointer (for frameless functions, and when    we're still in the prologue of a function with a frame) */
end_comment

begin_struct
struct|struct
name|frame_extra_info
block|{
name|struct
name|frame_saved_regs
name|fsr
decl_stmt|;
name|int
name|framesize
decl_stmt|;
name|int
name|frameoffset
decl_stmt|;
name|int
name|framereg
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Addresses for calling Thumb functions have the bit 0 set.    Here are some macros to test, set, or clear bit 0 of addresses.  */
end_comment

begin_define
define|#
directive|define
name|IS_THUMB_ADDR
parameter_list|(
name|addr
parameter_list|)
value|((addr)& 1)
end_define

begin_define
define|#
directive|define
name|MAKE_THUMB_ADDR
parameter_list|(
name|addr
parameter_list|)
value|((addr) | 1)
end_define

begin_define
define|#
directive|define
name|UNMAKE_THUMB_ADDR
parameter_list|(
name|addr
parameter_list|)
value|((addr)& ~1)
end_define

begin_define
define|#
directive|define
name|SWAP_TARGET_AND_HOST
parameter_list|(
name|buffer
parameter_list|,
name|len
parameter_list|)
define|\
value|do									\     {									\       if (TARGET_BYTE_ORDER != HOST_BYTE_ORDER)				\ 	{								\ 	  char tmp;							\ 	  char *p = (char *)(buffer);					\ 	  char *q = ((char *)(buffer)) + len - 1;		   	\ 	  for (; p< q; p++, q--)				 	\ 	    {								\ 	      tmp = *q;							\ 	      *q = *p;							\ 	      *p = tmp;							\ 	    }								\ 	}								\     }									\   while (0)
end_define

begin_comment
comment|/* Will a function return an aggregate type in memory or in a    register?  Return 0 if an aggregate type can be returned in a    register, 1 if it must be returned in memory.  */
end_comment

begin_function
name|int
name|arm_use_struct_convention
parameter_list|(
name|int
name|gcc_p
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|int
name|nRc
decl_stmt|;
specifier|register
name|enum
name|type_code
name|code
decl_stmt|;
comment|/* In the ARM ABI, "integer" like aggregate types are returned in      registers.  For an aggregate type to be integer like, its size      must be less than or equal to REGISTER_SIZE and the offset of      each addressable subfield must be zero.  Note that bit fields are      not addressable, and all addressable subfields of unions always      start at offset zero.       This function is based on the behaviour of GCC 2.95.1.      See: gcc/arm.c: arm_return_in_memory() for details.       Note: All versions of GCC before GCC 2.95.2 do not set up the      parameters correctly for a function returning the following      structure: struct { float f;}; This should be returned in memory,      not a register.  Richard Earnshaw sent me a patch, but I do not      know of any way to detect if a function like the above has been      compiled with the correct calling convention.  */
comment|/* All aggregate types that won't fit in a register must be returned      in memory.  */
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|>
name|REGISTER_SIZE
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|/* The only aggregate types that can be returned in a register are      structs and unions.  Arrays must be returned in memory.  */
name|code
operator|=
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_CODE_STRUCT
operator|!=
name|code
operator|)
operator|&&
operator|(
name|TYPE_CODE_UNION
operator|!=
name|code
operator|)
condition|)
block|{
return|return
literal|1
return|;
block|}
comment|/* Assume all other aggregate types can be returned in a register.      Run a check for structures, unions and arrays.  */
name|nRc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_CODE_STRUCT
operator|==
name|code
operator|)
operator|||
operator|(
name|TYPE_CODE_UNION
operator|==
name|code
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Need to check if this struct/union is "integer" like.  For          this to be true, its size must be less than or equal to          REGISTER_SIZE and the offset of each addressable subfield          must be zero.  Note that bit fields are not addressable, and          unions always start at offset zero.  If any of the subfields          is a floating point type, the struct/union cannot be an          integer type.  */
comment|/* For each field in the object, check:          1) Is it FP? --> yes, nRc = 1;          2) Is it addressable (bitpos != 0) and          not packed (bitsize == 0)?          --> yes, nRc = 1          */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|enum
name|type_code
name|field_type_code
decl_stmt|;
name|field_type_code
operator|=
name|TYPE_CODE
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Is it a floating point type field?  */
if|if
condition|(
name|field_type_code
operator|==
name|TYPE_CODE_FLT
condition|)
block|{
name|nRc
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* If bitpos != 0, then we have to care about it.  */
if|if
condition|(
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Bitfields are not addressable.  If the field bitsize is  	         zero, then the field is not packed.  Hence it cannot be 	         a bitfield or any other packed type.  */
if|if
condition|(
name|TYPE_FIELD_BITSIZE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|==
literal|0
condition|)
block|{
name|nRc
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
return|return
name|nRc
return|;
block|}
end_function

begin_function
name|int
name|arm_frame_chain_valid
parameter_list|(
name|CORE_ADDR
name|chain
parameter_list|,
name|struct
name|frame_info
modifier|*
name|thisframe
parameter_list|)
block|{
return|return
operator|(
name|chain
operator|!=
literal|0
operator|&&
operator|(
name|FRAME_SAVED_PC
argument_list|(
name|thisframe
argument_list|)
operator|>=
name|LOWEST_PC
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Set to true if the 32-bit mode is in use. */
end_comment

begin_decl_stmt
name|int
name|arm_apcs_32
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag set by arm_fix_call_dummy that tells whether the target    function is a Thumb function.  This flag is checked by    arm_push_arguments.  FIXME: Change the PUSH_ARGUMENTS macro (and    its use in valops.c) to pass the function address as an additional    parameter.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|target_is_thumb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag set by arm_fix_call_dummy that tells whether the calling    function is a Thumb function.  This flag is checked by    arm_pc_is_thumb and arm_call_dummy_breakpoint_offset.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|caller_is_thumb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Determine if the program counter specified in MEMADDR is in a Thumb    function.  */
end_comment

begin_function
name|int
name|arm_pc_is_thumb
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|sym
decl_stmt|;
comment|/* If bit 0 of the address is set, assume this is a Thumb address.  */
if|if
condition|(
name|IS_THUMB_ADDR
argument_list|(
name|memaddr
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Thumb functions have a "special" bit set in minimal symbols.  */
name|sym
operator|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|memaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
return|return
operator|(
name|MSYMBOL_IS_SPECIAL
argument_list|(
name|sym
argument_list|)
operator|)
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Determine if the program counter specified in MEMADDR is in a call    dummy being called from a Thumb function.  */
end_comment

begin_function
name|int
name|arm_pc_is_thumb_dummy
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|)
block|{
name|CORE_ADDR
name|sp
init|=
name|read_sp
argument_list|()
decl_stmt|;
comment|/* FIXME: Until we switch for the new call dummy macros, this heuristic      is the best we can do.  We are trying to determine if the pc is on      the stack, which (hopefully) will only happen in a call dummy.      We hope the current stack pointer is not so far alway from the dummy      frame location (true if we have not pushed large data structures or      gone too many levels deep) and that our 1024 is not enough to consider      code regions as part of the stack (true for most practical purposes) */
if|if
condition|(
name|PC_IN_CALL_DUMMY
argument_list|(
name|memaddr
argument_list|,
name|sp
argument_list|,
name|sp
operator|+
literal|1024
argument_list|)
condition|)
return|return
name|caller_is_thumb
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|arm_addr_bits_remove
parameter_list|(
name|CORE_ADDR
name|val
parameter_list|)
block|{
if|if
condition|(
name|arm_pc_is_thumb
argument_list|(
name|val
argument_list|)
condition|)
return|return
operator|(
name|val
operator|&
operator|(
name|arm_apcs_32
condition|?
literal|0xfffffffe
else|:
literal|0x03fffffe
operator|)
operator|)
return|;
else|else
return|return
operator|(
name|val
operator|&
operator|(
name|arm_apcs_32
condition|?
literal|0xfffffffc
else|:
literal|0x03fffffc
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|arm_saved_pc_after_call
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
return|return
name|ADDR_BITS_REMOVE
argument_list|(
name|read_register
argument_list|(
name|LR_REGNUM
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|arm_frameless_function_invocation
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
name|CORE_ADDR
name|func_start
decl_stmt|,
name|after_prologue
decl_stmt|;
name|int
name|frameless
decl_stmt|;
name|func_start
operator|=
operator|(
name|get_pc_function_start
argument_list|(
operator|(
name|fi
operator|)
operator|->
name|pc
argument_list|)
operator|+
name|FUNCTION_START_OFFSET
operator|)
expr_stmt|;
name|after_prologue
operator|=
name|SKIP_PROLOGUE
argument_list|(
name|func_start
argument_list|)
expr_stmt|;
comment|/* There are some frameless functions whose first two instructions      follow the standard APCS form, in which case after_prologue will      be func_start + 8. */
name|frameless
operator|=
operator|(
name|after_prologue
operator|<
name|func_start
operator|+
literal|12
operator|)
expr_stmt|;
return|return
name|frameless
return|;
block|}
end_function

begin_comment
comment|/* A typical Thumb prologue looks like this:    push    {r7, lr}    add     sp, sp, #-28    add     r7, sp, #12    Sometimes the latter instruction may be replaced by:    mov     r7, sp        or like this:    push    {r7, lr}    mov     r7, sp    sub	   sp, #12        or, on tpcs, like this:    sub     sp,#16    push    {r7, lr}    (many instructions)    mov     r7, sp    sub	   sp, #12     There is always one instruction of three classes:    1 - push    2 - setting of r7    3 - adjusting of sp        When we have found at least one of each class we are done with the prolog.    Note that the "sub sp, #NN" before the push does not count.    */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|thumb_skip_prologue
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
name|func_end
parameter_list|)
block|{
name|CORE_ADDR
name|current_pc
decl_stmt|;
name|int
name|findmask
init|=
literal|0
decl_stmt|;
comment|/* findmask:       			   bit 0 - push { rlist } 			   bit 1 - mov r7, sp  OR  add r7, sp, #imm  (setting of r7)       			   bit 2 - sub sp, #simm  OR  add sp, #simm  (adjusting of sp) 			*/
for|for
control|(
name|current_pc
operator|=
name|pc
init|;
name|current_pc
operator|+
literal|2
operator|<
name|func_end
operator|&&
name|current_pc
operator|<
name|pc
operator|+
literal|40
condition|;
name|current_pc
operator|+=
literal|2
control|)
block|{
name|unsigned
name|short
name|insn
init|=
name|read_memory_unsigned_integer
argument_list|(
name|current_pc
argument_list|,
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xfe00
operator|)
operator|==
literal|0xb400
condition|)
comment|/* push { rlist } */
block|{
name|findmask
operator||=
literal|1
expr_stmt|;
comment|/* push found */
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xff00
operator|)
operator|==
literal|0xb000
condition|)
comment|/* add sp, #simm  OR  sub sp, #simm */
block|{
if|if
condition|(
operator|(
name|findmask
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
comment|/* before push ? */
continue|continue;
else|else
name|findmask
operator||=
literal|4
expr_stmt|;
comment|/* add/sub sp found */
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xff00
operator|)
operator|==
literal|0xaf00
condition|)
comment|/* add r7, sp, #imm */
block|{
name|findmask
operator||=
literal|2
expr_stmt|;
comment|/* setting of r7 found */
block|}
elseif|else
if|if
condition|(
name|insn
operator|==
literal|0x466f
condition|)
comment|/* mov r7, sp */
block|{
name|findmask
operator||=
literal|2
expr_stmt|;
comment|/* setting of r7 found */
block|}
else|else
continue|continue;
comment|/* something in the prolog that we don't care about or some 	  		   instruction from outside the prolog scheduled here for optimization */
block|}
return|return
name|current_pc
return|;
block|}
end_function

begin_comment
comment|/* The APCS (ARM Procedure Call Standard) defines the following    prologue:     mov          ip, sp    [stmfd       sp!, {a1,a2,a3,a4}]    stmfd        sp!, {...,fp,ip,lr,pc}    [stfe        f7, [sp, #-12]!]    [stfe        f6, [sp, #-12]!]    [stfe        f5, [sp, #-12]!]    [stfe        f4, [sp, #-12]!]    sub fp, ip, #nn @@ nn == 20 or 4 depending on second insn */
end_comment

begin_function
name|CORE_ADDR
name|arm_skip_prologue
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|unsigned
name|long
name|inst
decl_stmt|;
name|CORE_ADDR
name|skip_pc
decl_stmt|;
name|CORE_ADDR
name|func_addr
decl_stmt|,
name|func_end
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
comment|/* See what the symbol table says.  */
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
name|NULL
argument_list|,
operator|&
name|func_addr
argument_list|,
operator|&
name|func_end
argument_list|)
condition|)
block|{
name|sal
operator|=
name|find_pc_line
argument_list|(
name|func_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sal
operator|.
name|line
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|sal
operator|.
name|end
operator|<
name|func_end
operator|)
condition|)
return|return
name|sal
operator|.
name|end
return|;
block|}
comment|/* Check if this is Thumb code.  */
if|if
condition|(
name|arm_pc_is_thumb
argument_list|(
name|pc
argument_list|)
condition|)
return|return
name|thumb_skip_prologue
argument_list|(
name|pc
argument_list|,
name|func_end
argument_list|)
return|;
comment|/* Can't find the prologue end in the symbol table, try it the hard way      by disassembling the instructions. */
name|skip_pc
operator|=
name|pc
expr_stmt|;
name|inst
operator|=
name|read_memory_integer
argument_list|(
name|skip_pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst
operator|!=
literal|0xe1a0c00d
condition|)
comment|/* mov ip, sp */
return|return
name|pc
return|;
name|skip_pc
operator|+=
literal|4
expr_stmt|;
name|inst
operator|=
name|read_memory_integer
argument_list|(
name|skip_pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xfffffff0
operator|)
operator|==
literal|0xe92d0000
condition|)
comment|/* stmfd sp!,{a1,a2,a3,a4}  */
block|{
name|skip_pc
operator|+=
literal|4
expr_stmt|;
name|inst
operator|=
name|read_memory_integer
argument_list|(
name|skip_pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xfffff800
operator|)
operator|!=
literal|0xe92dd800
condition|)
comment|/* stmfd sp!,{...,fp,ip,lr,pc} */
return|return
name|pc
return|;
name|skip_pc
operator|+=
literal|4
expr_stmt|;
name|inst
operator|=
name|read_memory_integer
argument_list|(
name|skip_pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Any insns after this point may float into the code, if it makes      for better instruction scheduling, so we skip them only if we      find them, but still consdier the function to be frame-ful.  */
comment|/* We may have either one sfmfd instruction here, or several stfe      insns, depending on the version of floating point code we      support.  */
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xffbf0fff
operator|)
operator|==
literal|0xec2d0200
condition|)
comment|/* sfmfd fn,<cnt>, [sp]! */
block|{
name|skip_pc
operator|+=
literal|4
expr_stmt|;
name|inst
operator|=
name|read_memory_integer
argument_list|(
name|skip_pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|(
name|inst
operator|&
literal|0xffff8fff
operator|)
operator|==
literal|0xed6d0103
condition|)
comment|/* stfe fn, [sp, #-12]! */
block|{
name|skip_pc
operator|+=
literal|4
expr_stmt|;
name|inst
operator|=
name|read_memory_integer
argument_list|(
name|skip_pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xfffff000
operator|)
operator|==
literal|0xe24cb000
condition|)
comment|/* sub fp, ip, #nn */
name|skip_pc
operator|+=
literal|4
expr_stmt|;
return|return
name|skip_pc
return|;
block|}
end_function

begin_comment
comment|/* *INDENT-OFF* */
end_comment

begin_comment
comment|/* Function: thumb_scan_prologue (helper function for arm_scan_prologue)    This function decodes a Thumb function prologue to determine:      1) the size of the stack frame      2) which registers are saved on it      3) the offsets of saved regs      4) the offset from the stack pointer to the frame pointer    This information is stored in the "extra" fields of the frame_info.     A typical Thumb function prologue would create this stack frame    (offsets relative to FP)      old SP ->	24  stack parameters 		20  LR 		16  R7      R7 ->       0  local variables (16 bytes)      SP ->     -12  additional stack space (12 bytes)    The frame size would thus be 36 bytes, and the frame offset would be    12 bytes.  The frame register is R7.         The comments for thumb_skip_prolog() describe the algorithm we use to detect    the end of the prolog */
end_comment

begin_comment
comment|/* *INDENT-ON* */
end_comment

begin_function
specifier|static
name|void
name|thumb_scan_prologue
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
name|CORE_ADDR
name|prologue_start
decl_stmt|;
name|CORE_ADDR
name|prologue_end
decl_stmt|;
name|CORE_ADDR
name|current_pc
decl_stmt|;
name|int
name|saved_reg
index|[
literal|16
index|]
decl_stmt|;
comment|/* which register has been copied to register n? */
name|int
name|findmask
init|=
literal|0
decl_stmt|;
comment|/* findmask:       			   bit 0 - push { rlist } 			   bit 1 - mov r7, sp  OR  add r7, sp, #imm  (setting of r7)       			   bit 2 - sub sp, #simm  OR  add sp, #simm  (adjusting of sp) 			*/
name|int
name|i
decl_stmt|;
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
name|NULL
argument_list|,
operator|&
name|prologue_start
argument_list|,
operator|&
name|prologue_end
argument_list|)
condition|)
block|{
name|struct
name|symtab_and_line
name|sal
init|=
name|find_pc_line
argument_list|(
name|prologue_start
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|sal
operator|.
name|line
operator|==
literal|0
condition|)
comment|/* no line info, use current PC */
name|prologue_end
operator|=
name|fi
operator|->
name|pc
expr_stmt|;
elseif|else
if|if
condition|(
name|sal
operator|.
name|end
operator|<
name|prologue_end
condition|)
comment|/* next line begins after fn end */
name|prologue_end
operator|=
name|sal
operator|.
name|end
expr_stmt|;
comment|/* (probably means no prologue)  */
block|}
else|else
name|prologue_end
operator|=
name|prologue_start
operator|+
literal|40
expr_stmt|;
comment|/* We're in the boondocks: allow for */
comment|/* 16 pushes, an add, and "mv fp,sp" */
name|prologue_end
operator|=
name|min
argument_list|(
name|prologue_end
argument_list|,
name|fi
operator|->
name|pc
argument_list|)
expr_stmt|;
comment|/* Initialize the saved register map.  When register H is copied to      register L, we will put H in saved_reg[L].  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|saved_reg
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
comment|/* Search the prologue looking for instructions that set up the      frame pointer, adjust the stack pointer, and save registers.      Do this until all basic prolog instructions are found.  */
name|fi
operator|->
name|framesize
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|current_pc
operator|=
name|prologue_start
init|;
operator|(
name|current_pc
operator|<
name|prologue_end
operator|)
operator|&&
operator|(
operator|(
name|findmask
operator|&
literal|7
operator|)
operator|!=
literal|7
operator|)
condition|;
name|current_pc
operator|+=
literal|2
control|)
block|{
name|unsigned
name|short
name|insn
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|insn
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|current_pc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xfe00
operator|)
operator|==
literal|0xb400
condition|)
comment|/* push { rlist } */
block|{
name|int
name|mask
decl_stmt|;
name|findmask
operator||=
literal|1
expr_stmt|;
comment|/* push found */
comment|/* Bits 0-7 contain a mask for registers R0-R7.  Bit 8 says 	     whether to save LR (R14).  */
name|mask
operator|=
operator|(
name|insn
operator|&
literal|0xff
operator|)
operator||
operator|(
operator|(
name|insn
operator|&
literal|0x100
operator|)
operator|<<
literal|6
operator|)
expr_stmt|;
comment|/* Calculate offsets of saved R0-R7 and LR. */
for|for
control|(
name|regno
operator|=
name|LR_REGNUM
init|;
name|regno
operator|>=
literal|0
condition|;
name|regno
operator|--
control|)
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|regno
operator|)
condition|)
block|{
name|fi
operator|->
name|framesize
operator|+=
literal|4
expr_stmt|;
name|fi
operator|->
name|fsr
operator|.
name|regs
index|[
name|saved_reg
index|[
name|regno
index|]
index|]
operator|=
operator|-
operator|(
name|fi
operator|->
name|framesize
operator|)
expr_stmt|;
name|saved_reg
index|[
name|regno
index|]
operator|=
name|regno
expr_stmt|;
comment|/* reset saved register map */
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xff00
operator|)
operator|==
literal|0xb000
condition|)
comment|/* add sp, #simm  OR  sub sp, #simm */
block|{
if|if
condition|(
operator|(
name|findmask
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
comment|/* before push ? */
continue|continue;
else|else
name|findmask
operator||=
literal|4
expr_stmt|;
comment|/* add/sub sp found */
name|offset
operator|=
operator|(
name|insn
operator|&
literal|0x7f
operator|)
operator|<<
literal|2
expr_stmt|;
comment|/* get scaled offset */
if|if
condition|(
name|insn
operator|&
literal|0x80
condition|)
comment|/* is it signed? (==subtracting) */
block|{
name|fi
operator|->
name|frameoffset
operator|+=
name|offset
expr_stmt|;
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
block|}
name|fi
operator|->
name|framesize
operator|-=
name|offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xff00
operator|)
operator|==
literal|0xaf00
condition|)
comment|/* add r7, sp, #imm */
block|{
name|findmask
operator||=
literal|2
expr_stmt|;
comment|/* setting of r7 found */
name|fi
operator|->
name|framereg
operator|=
name|THUMB_FP_REGNUM
expr_stmt|;
name|fi
operator|->
name|frameoffset
operator|=
operator|(
name|insn
operator|&
literal|0xff
operator|)
operator|<<
literal|2
expr_stmt|;
comment|/* get scaled offset */
block|}
elseif|else
if|if
condition|(
name|insn
operator|==
literal|0x466f
condition|)
comment|/* mov r7, sp */
block|{
name|findmask
operator||=
literal|2
expr_stmt|;
comment|/* setting of r7 found */
name|fi
operator|->
name|framereg
operator|=
name|THUMB_FP_REGNUM
expr_stmt|;
name|fi
operator|->
name|frameoffset
operator|=
literal|0
expr_stmt|;
name|saved_reg
index|[
name|THUMB_FP_REGNUM
index|]
operator|=
name|SP_REGNUM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xffc0
operator|)
operator|==
literal|0x4640
condition|)
comment|/* mov r0-r7, r8-r15 */
block|{
name|int
name|lo_reg
init|=
name|insn
operator|&
literal|7
decl_stmt|;
comment|/* dest. register (r0-r7) */
name|int
name|hi_reg
init|=
operator|(
operator|(
name|insn
operator|>>
literal|3
operator|)
operator|&
literal|7
operator|)
operator|+
literal|8
decl_stmt|;
comment|/* source register (r8-15) */
name|saved_reg
index|[
name|lo_reg
index|]
operator|=
name|hi_reg
expr_stmt|;
comment|/* remember hi reg was saved */
block|}
else|else
continue|continue;
comment|/* something in the prolog that we don't care about or some 	  		   instruction from outside the prolog scheduled here for optimization */
block|}
block|}
end_function

begin_comment
comment|/* Check if prologue for this frame's PC has already been scanned.  If    it has, copy the relevant information about that prologue and    return non-zero.  Otherwise do not copy anything and return zero.     The information saved in the cache includes:    * the frame register number;    * the size of the stack frame;    * the offsets of saved regs (relative to the old SP); and    * the offset from the stack pointer to the frame pointer     The cache contains only one entry, since this is adequate for the    typical sequence of prologue scan requests we get.  When performing    a backtrace, GDB will usually ask to scan the same function twice    in a row (once to get the frame chain, and once to fill in the    extra frame information).  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|frame_info
name|prologue_cache
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|check_prologue_cache
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|fi
operator|->
name|pc
operator|==
name|prologue_cache
operator|.
name|pc
condition|)
block|{
name|fi
operator|->
name|framereg
operator|=
name|prologue_cache
operator|.
name|framereg
expr_stmt|;
name|fi
operator|->
name|framesize
operator|=
name|prologue_cache
operator|.
name|framesize
expr_stmt|;
name|fi
operator|->
name|frameoffset
operator|=
name|prologue_cache
operator|.
name|frameoffset
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|NUM_REGS
condition|;
name|i
operator|++
control|)
name|fi
operator|->
name|fsr
operator|.
name|regs
index|[
name|i
index|]
operator|=
name|prologue_cache
operator|.
name|fsr
operator|.
name|regs
index|[
name|i
index|]
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Copy the prologue information from fi to the prologue cache.  */
end_comment

begin_function
specifier|static
name|void
name|save_prologue_cache
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|prologue_cache
operator|.
name|pc
operator|=
name|fi
operator|->
name|pc
expr_stmt|;
name|prologue_cache
operator|.
name|framereg
operator|=
name|fi
operator|->
name|framereg
expr_stmt|;
name|prologue_cache
operator|.
name|framesize
operator|=
name|fi
operator|->
name|framesize
expr_stmt|;
name|prologue_cache
operator|.
name|frameoffset
operator|=
name|fi
operator|->
name|frameoffset
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|NUM_REGS
condition|;
name|i
operator|++
control|)
name|prologue_cache
operator|.
name|fsr
operator|.
name|regs
index|[
name|i
index|]
operator|=
name|fi
operator|->
name|fsr
operator|.
name|regs
index|[
name|i
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function decodes an ARM function prologue to determine:    1) the size of the stack frame    2) which registers are saved on it    3) the offsets of saved regs    4) the offset from the stack pointer to the frame pointer    This information is stored in the "extra" fields of the frame_info.     There are two basic forms for the ARM prologue.  The fixed argument    function call will look like:     mov    ip, sp    stmfd  sp!, {fp, ip, lr, pc}    sub    fp, ip, #4    [sub sp, sp, #4]     Which would create this stack frame (offsets relative to FP):    IP ->   4    (caller's stack)    FP ->   0    PC (points to address of stmfd instruction + 8 in callee)    -4   LR (return address in caller)    -8   IP (copy of caller's SP)    -12  FP (caller's FP)    SP -> -28    Local variables     The frame size would thus be 32 bytes, and the frame offset would be    28 bytes.  The stmfd call can also save any of the vN registers it    plans to use, which increases the frame size accordingly.     Note: The stored PC is 8 off of the STMFD instruction that stored it    because the ARM Store instructions always store PC + 8 when you read    the PC register.     A variable argument function call will look like:     mov    ip, sp    stmfd  sp!, {a1, a2, a3, a4}    stmfd  sp!, {fp, ip, lr, pc}    sub    fp, ip, #20     Which would create this stack frame (offsets relative to FP):    IP ->  20    (caller's stack)    16  A4    12  A3    8  A2    4  A1    FP ->   0    PC (points to address of stmfd instruction + 8 in callee)    -4   LR (return address in caller)    -8   IP (copy of caller's SP)    -12  FP (caller's FP)    SP -> -28    Local variables     The frame size would thus be 48 bytes, and the frame offset would be    28 bytes.     There is another potential complication, which is that the optimizer    will try to separate the store of fp in the "stmfd" instruction from    the "sub fp, ip, #NN" instruction.  Almost anything can be there, so    we just key on the stmfd, and then scan for the "sub fp, ip, #NN"...     Also, note, the original version of the ARM toolchain claimed that there    should be an     instruction at the end of the prologue.  I have never seen GCC produce    this, and the ARM docs don't mention it.  We still test for it below in    case it happens...   */
end_comment

begin_function
specifier|static
name|void
name|arm_scan_prologue
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
name|int
name|regno
decl_stmt|,
name|sp_offset
decl_stmt|,
name|fp_offset
decl_stmt|;
name|CORE_ADDR
name|prologue_start
decl_stmt|,
name|prologue_end
decl_stmt|,
name|current_pc
decl_stmt|;
comment|/* Check if this function is already in the cache of frame information. */
if|if
condition|(
name|check_prologue_cache
argument_list|(
name|fi
argument_list|)
condition|)
return|return;
comment|/* Assume there is no frame until proven otherwise.  */
name|fi
operator|->
name|framereg
operator|=
name|SP_REGNUM
expr_stmt|;
name|fi
operator|->
name|framesize
operator|=
literal|0
expr_stmt|;
name|fi
operator|->
name|frameoffset
operator|=
literal|0
expr_stmt|;
comment|/* Check for Thumb prologue.  */
if|if
condition|(
name|arm_pc_is_thumb
argument_list|(
name|fi
operator|->
name|pc
argument_list|)
condition|)
block|{
name|thumb_scan_prologue
argument_list|(
name|fi
argument_list|)
expr_stmt|;
name|save_prologue_cache
argument_list|(
name|fi
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Find the function prologue.  If we can't find the function in      the symbol table, peek in the stack frame to find the PC.  */
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
name|NULL
argument_list|,
operator|&
name|prologue_start
argument_list|,
operator|&
name|prologue_end
argument_list|)
condition|)
block|{
comment|/* Assume the prologue is everything between the first instruction          in the function and the first source line.  */
name|struct
name|symtab_and_line
name|sal
init|=
name|find_pc_line
argument_list|(
name|prologue_start
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|sal
operator|.
name|line
operator|==
literal|0
condition|)
comment|/* no line info, use current PC */
name|prologue_end
operator|=
name|fi
operator|->
name|pc
expr_stmt|;
elseif|else
if|if
condition|(
name|sal
operator|.
name|end
operator|<
name|prologue_end
condition|)
comment|/* next line begins after fn end */
name|prologue_end
operator|=
name|sal
operator|.
name|end
expr_stmt|;
comment|/* (probably means no prologue)  */
block|}
else|else
block|{
comment|/* Get address of the stmfd in the prologue of the callee; the saved          PC is the address of the stmfd + 8.  */
name|prologue_start
operator|=
name|ADDR_BITS_REMOVE
argument_list|(
name|read_memory_integer
argument_list|(
name|fi
operator|->
name|frame
argument_list|,
literal|4
argument_list|)
argument_list|)
operator|-
literal|8
expr_stmt|;
name|prologue_end
operator|=
name|prologue_start
operator|+
literal|64
expr_stmt|;
comment|/* This is all the insn's 						   that could be in the prologue, 						   plus room for 5 insn's inserted 						   by the scheduler.  */
block|}
comment|/* Now search the prologue looking for instructions that set up the      frame pointer, adjust the stack pointer, and save registers.       Be careful, however, and if it doesn't look like a prologue,      don't try to scan it.  If, for instance, a frameless function      begins with stmfd sp!, then we will tell ourselves there is      a frame, which will confuse stack traceback, as well ad"finish"       and other operations that rely on a knowledge of the stack      traceback.       In the APCS, the prologue should start with  "mov ip, sp" so      if we don't see this as the first insn, we will stop.  */
name|sp_offset
operator|=
name|fp_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|read_memory_unsigned_integer
argument_list|(
name|prologue_start
argument_list|,
literal|4
argument_list|)
operator|==
literal|0xe1a0c00d
condition|)
comment|/* mov ip, sp */
block|{
for|for
control|(
name|current_pc
operator|=
name|prologue_start
operator|+
literal|4
init|;
name|current_pc
operator|<
name|prologue_end
condition|;
name|current_pc
operator|+=
literal|4
control|)
block|{
name|unsigned
name|int
name|insn
init|=
name|read_memory_unsigned_integer
argument_list|(
name|current_pc
argument_list|,
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0xe92d0000
condition|)
comment|/* stmfd sp!, {..., fp, ip, lr, pc} 	       or 	       stmfd sp!, {a1, a2, a3, a4}  */
block|{
name|int
name|mask
init|=
name|insn
operator|&
literal|0xffff
decl_stmt|;
comment|/* Calculate offsets of saved registers. */
for|for
control|(
name|regno
operator|=
name|PC_REGNUM
init|;
name|regno
operator|>=
literal|0
condition|;
name|regno
operator|--
control|)
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|regno
operator|)
condition|)
block|{
name|sp_offset
operator|-=
literal|4
expr_stmt|;
name|fi
operator|->
name|fsr
operator|.
name|regs
index|[
name|regno
index|]
operator|=
name|sp_offset
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xfffff000
operator|)
operator|==
literal|0xe24cb000
condition|)
comment|/* sub fp, ip #n */
block|{
name|unsigned
name|imm
init|=
name|insn
operator|&
literal|0xff
decl_stmt|;
comment|/* immediate value */
name|unsigned
name|rot
init|=
operator|(
name|insn
operator|&
literal|0xf00
operator|)
operator|>>
literal|7
decl_stmt|;
comment|/* rotate amount */
name|imm
operator|=
operator|(
name|imm
operator|>>
name|rot
operator|)
operator||
operator|(
name|imm
operator|<<
operator|(
literal|32
operator|-
name|rot
operator|)
operator|)
expr_stmt|;
name|fp_offset
operator|=
operator|-
name|imm
expr_stmt|;
name|fi
operator|->
name|framereg
operator|=
name|FP_REGNUM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xfffff000
operator|)
operator|==
literal|0xe24dd000
condition|)
comment|/* sub sp, sp #n */
block|{
name|unsigned
name|imm
init|=
name|insn
operator|&
literal|0xff
decl_stmt|;
comment|/* immediate value */
name|unsigned
name|rot
init|=
operator|(
name|insn
operator|&
literal|0xf00
operator|)
operator|>>
literal|7
decl_stmt|;
comment|/* rotate amount */
name|imm
operator|=
operator|(
name|imm
operator|>>
name|rot
operator|)
operator||
operator|(
name|imm
operator|<<
operator|(
literal|32
operator|-
name|rot
operator|)
operator|)
expr_stmt|;
name|sp_offset
operator|-=
name|imm
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xffff7fff
operator|)
operator|==
literal|0xed6d0103
condition|)
comment|/* stfe f?, [sp, -#c]! */
block|{
name|sp_offset
operator|-=
literal|12
expr_stmt|;
name|regno
operator|=
name|F0_REGNUM
operator|+
operator|(
operator|(
name|insn
operator|>>
literal|12
operator|)
operator|&
literal|0x07
operator|)
expr_stmt|;
name|fi
operator|->
name|fsr
operator|.
name|regs
index|[
name|regno
index|]
operator|=
name|sp_offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xffbf0fff
operator|)
operator|==
literal|0xec2d0200
condition|)
comment|/* sfmfd f0, 4, [sp!] */
block|{
name|int
name|n_saved_fp_regs
decl_stmt|;
name|unsigned
name|int
name|fp_start_reg
decl_stmt|,
name|fp_bound_reg
decl_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
literal|0x800
operator|)
operator|==
literal|0x800
condition|)
comment|/* N0 is set */
block|{
if|if
condition|(
operator|(
name|insn
operator|&
literal|0x40000
operator|)
operator|==
literal|0x40000
condition|)
comment|/* N1 is set */
name|n_saved_fp_regs
operator|=
literal|3
expr_stmt|;
else|else
name|n_saved_fp_regs
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|insn
operator|&
literal|0x40000
operator|)
operator|==
literal|0x40000
condition|)
comment|/* N1 is set */
name|n_saved_fp_regs
operator|=
literal|2
expr_stmt|;
else|else
name|n_saved_fp_regs
operator|=
literal|4
expr_stmt|;
block|}
name|fp_start_reg
operator|=
name|F0_REGNUM
operator|+
operator|(
operator|(
name|insn
operator|>>
literal|12
operator|)
operator|&
literal|0x7
operator|)
expr_stmt|;
name|fp_bound_reg
operator|=
name|fp_start_reg
operator|+
name|n_saved_fp_regs
expr_stmt|;
for|for
control|(
init|;
name|fp_start_reg
operator|<
name|fp_bound_reg
condition|;
name|fp_start_reg
operator|++
control|)
block|{
name|sp_offset
operator|-=
literal|12
expr_stmt|;
name|fi
operator|->
name|fsr
operator|.
name|regs
index|[
name|fp_start_reg
operator|++
index|]
operator|=
name|sp_offset
expr_stmt|;
block|}
block|}
else|else
comment|/* The optimizer might shove anything into the prologue, 	       so we just skip what we don't recognize. */
continue|continue;
block|}
block|}
comment|/* The frame size is just the negative of the offset (from the original SP)      of the last thing thing we pushed on the stack.  The frame offset is      [new FP] - [new SP].  */
name|fi
operator|->
name|framesize
operator|=
operator|-
name|sp_offset
expr_stmt|;
name|fi
operator|->
name|frameoffset
operator|=
name|fp_offset
operator|-
name|sp_offset
expr_stmt|;
name|save_prologue_cache
argument_list|(
name|fi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find REGNUM on the stack.  Otherwise, it's in an active register.    One thing we might want to do here is to check REGNUM against the    clobber mask, and somehow flag it as invalid if it isn't saved on    the stack somewhere.  This would provide a graceful failure mode    when trying to get the value of caller-saves registers for an inner    frame.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|arm_find_callers_reg
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
for|for
control|(
init|;
name|fi
condition|;
name|fi
operator|=
name|fi
operator|->
name|next
control|)
if|#
directive|if
literal|0
comment|/* FIXME: enable this code if we convert to new call dummy scheme.  */
for|if (PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))       return generic_read_register_dummy (fi->pc, fi->frame, regnum);     else
endif|#
directive|endif
if|if
condition|(
name|fi
operator|->
name|fsr
operator|.
name|regs
index|[
name|regnum
index|]
operator|!=
literal|0
condition|)
return|return
name|read_memory_integer
argument_list|(
name|fi
operator|->
name|fsr
operator|.
name|regs
index|[
name|regnum
index|]
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
return|;
return|return
name|read_register
argument_list|(
name|regnum
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* *INDENT-OFF* */
end_comment

begin_comment
comment|/* Function: frame_chain    Given a GDB frame, determine the address of the calling function's frame.    This will be used to create a new GDB frame struct, and then    INIT_EXTRA_FRAME_INFO and INIT_FRAME_PC will be called for the new frame.    For ARM, we save the frame size when we initialize the frame_info.     The original definition of this function was a macro in tm-arm.h:       { In the case of the ARM, the frame's nominal address is the FP value, 	 and 12 bytes before comes the saved previous FP value as a 4-byte word.  }        #define FRAME_CHAIN(thisframe)  \ 	((thisframe)->pc>= LOWEST_PC ?    \ 	 read_memory_integer ((thisframe)->frame - 12, 4) :\ 	 0) */
end_comment

begin_comment
comment|/* *INDENT-ON* */
end_comment

begin_function
name|CORE_ADDR
name|arm_frame_chain
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
if|#
directive|if
literal|0
comment|/* FIXME: enable this code if we convert to new call dummy scheme.  */
block|CORE_ADDR fn_start, callers_pc, fp;
comment|/* is this a dummy frame? */
block|if (PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))     return fi->frame;
comment|/* dummy frame same as caller's frame */
comment|/* is caller-of-this a dummy frame? */
block|callers_pc = FRAME_SAVED_PC (fi);
comment|/* find out who called us: */
block|fp = arm_find_callers_reg (fi, FP_REGNUM);   if (PC_IN_CALL_DUMMY (callers_pc, fp, fp))     return fp;
comment|/* dummy frame's frame may bear no relation to ours */
block|if (find_pc_partial_function (fi->pc, 0,&fn_start, 0))     if (fn_start == entry_point_address ())       return 0;
comment|/* in _start fn, don't chain further */
endif|#
directive|endif
name|CORE_ADDR
name|caller_pc
decl_stmt|,
name|fn_start
decl_stmt|;
name|struct
name|frame_info
name|caller_fi
decl_stmt|;
name|int
name|framereg
init|=
name|fi
operator|->
name|framereg
decl_stmt|;
if|if
condition|(
name|fi
operator|->
name|pc
operator|<
name|LOWEST_PC
condition|)
return|return
literal|0
return|;
comment|/* If the caller is the startup code, we're at the end of the chain.  */
name|caller_pc
operator|=
name|FRAME_SAVED_PC
argument_list|(
name|fi
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|caller_pc
argument_list|,
literal|0
argument_list|,
operator|&
name|fn_start
argument_list|,
literal|0
argument_list|)
condition|)
if|if
condition|(
name|fn_start
operator|==
name|entry_point_address
argument_list|()
condition|)
return|return
literal|0
return|;
comment|/* If the caller is Thumb and the caller is ARM, or vice versa,      the frame register of the caller is different from ours.      So we must scan the prologue of the caller to determine its      frame register number. */
if|if
condition|(
name|arm_pc_is_thumb
argument_list|(
name|caller_pc
argument_list|)
operator|!=
name|arm_pc_is_thumb
argument_list|(
name|fi
operator|->
name|pc
argument_list|)
condition|)
block|{
name|memset
argument_list|(
operator|&
name|caller_fi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|caller_fi
argument_list|)
argument_list|)
expr_stmt|;
name|caller_fi
operator|.
name|pc
operator|=
name|caller_pc
expr_stmt|;
name|arm_scan_prologue
argument_list|(
operator|&
name|caller_fi
argument_list|)
expr_stmt|;
name|framereg
operator|=
name|caller_fi
operator|.
name|framereg
expr_stmt|;
block|}
comment|/* If the caller used a frame register, return its value.      Otherwise, return the caller's stack pointer.  */
if|if
condition|(
name|framereg
operator|==
name|FP_REGNUM
operator|||
name|framereg
operator|==
name|THUMB_FP_REGNUM
condition|)
return|return
name|arm_find_callers_reg
argument_list|(
name|fi
argument_list|,
name|framereg
argument_list|)
return|;
else|else
return|return
name|fi
operator|->
name|frame
operator|+
name|fi
operator|->
name|framesize
return|;
block|}
end_function

begin_comment
comment|/* This function actually figures out the frame address for a given pc    and sp.  This is tricky because we sometimes don't use an explicit    frame pointer, and the previous stack pointer isn't necessarily    recorded on the stack.  The only reliable way to get this info is    to examine the prologue.  FROMLEAF is a little confusing, it means    this is the next frame up the chain AFTER a frameless function.  If    this is true, then the frame value for this frame is still in the    fp register.  */
end_comment

begin_function
name|void
name|arm_init_extra_frame_info
parameter_list|(
name|int
name|fromleaf
parameter_list|,
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
if|if
condition|(
name|fi
operator|->
name|next
condition|)
name|fi
operator|->
name|pc
operator|=
name|FRAME_SAVED_PC
argument_list|(
name|fi
operator|->
name|next
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|fi
operator|->
name|fsr
operator|.
name|regs
argument_list|,
literal|'\000'
argument_list|,
sizeof|sizeof
name|fi
operator|->
name|fsr
operator|.
name|regs
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* FIXME: enable this code if we convert to new call dummy scheme.  */
block|if (PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))     {
comment|/* We need to setup fi->frame here because run_stack_dummy gets it wrong          by assuming it's always FP.  */
block|fi->frame = generic_read_register_dummy (fi->pc, fi->frame, SP_REGNUM);       fi->framesize = 0;       fi->frameoffset = 0;       return;     }   else
endif|#
directive|endif
block|{
name|arm_scan_prologue
argument_list|(
name|fi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fi
operator|->
name|next
condition|)
comment|/* this is the innermost frame? */
name|fi
operator|->
name|frame
operator|=
name|read_register
argument_list|(
name|fi
operator|->
name|framereg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fi
operator|->
name|framereg
operator|==
name|FP_REGNUM
operator|||
name|fi
operator|->
name|framereg
operator|==
name|THUMB_FP_REGNUM
condition|)
block|{
comment|/* not the innermost frame */
comment|/* If we have an FP, the callee saved it. */
if|if
condition|(
name|fi
operator|->
name|next
operator|->
name|fsr
operator|.
name|regs
index|[
name|fi
operator|->
name|framereg
index|]
operator|!=
literal|0
condition|)
name|fi
operator|->
name|frame
operator|=
name|read_memory_integer
argument_list|(
name|fi
operator|->
name|next
operator|->
name|fsr
operator|.
name|regs
index|[
name|fi
operator|->
name|framereg
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fromleaf
condition|)
comment|/* If we were called by a frameless fn.  then our frame is 	       still in the frame pointer register on the board... */
name|fi
operator|->
name|frame
operator|=
name|read_fp
argument_list|()
expr_stmt|;
block|}
comment|/* Calculate actual addresses of saved registers using offsets          determined by arm_scan_prologue.  */
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<
name|NUM_REGS
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|fi
operator|->
name|fsr
operator|.
name|regs
index|[
name|reg
index|]
operator|!=
literal|0
condition|)
name|fi
operator|->
name|fsr
operator|.
name|regs
index|[
name|reg
index|]
operator|+=
name|fi
operator|->
name|frame
operator|+
name|fi
operator|->
name|framesize
operator|-
name|fi
operator|->
name|frameoffset
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Find the caller of this frame.  We do this by seeing if LR_REGNUM    is saved in the stack anywhere, otherwise we get it from the    registers.     The old definition of this function was a macro:    #define FRAME_SAVED_PC(FRAME) \    ADDR_BITS_REMOVE (read_memory_integer ((FRAME)->frame - 4, 4)) */
end_comment

begin_function
name|CORE_ADDR
name|arm_frame_saved_pc
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{
if|#
directive|if
literal|0
comment|/* FIXME: enable this code if we convert to new call dummy scheme.  */
block|if (PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))     return generic_read_register_dummy (fi->pc, fi->frame, PC_REGNUM);   else
endif|#
directive|endif
block|{
name|CORE_ADDR
name|pc
init|=
name|arm_find_callers_reg
argument_list|(
name|fi
argument_list|,
name|LR_REGNUM
argument_list|)
decl_stmt|;
return|return
name|IS_THUMB_ADDR
argument_list|(
name|pc
argument_list|)
condition|?
name|UNMAKE_THUMB_ADDR
argument_list|(
name|pc
argument_list|)
else|:
name|pc
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return the frame address.  On ARM, it is R11; on Thumb it is R7.    Examine the Program Status Register to decide which state we're in.  */
end_comment

begin_function
name|CORE_ADDR
name|arm_target_read_fp
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|read_register
argument_list|(
name|PS_REGNUM
argument_list|)
operator|&
literal|0x20
condition|)
comment|/* Bit 5 is Thumb state bit */
return|return
name|read_register
argument_list|(
name|THUMB_FP_REGNUM
argument_list|)
return|;
comment|/* R7 if Thumb */
else|else
return|return
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
return|;
comment|/* R11 if ARM */
block|}
end_function

begin_comment
comment|/* Calculate the frame offsets of the saved registers (ARM version).  */
end_comment

begin_function
name|void
name|arm_frame_find_saved_regs
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|,
name|struct
name|frame_saved_regs
modifier|*
name|regaddr
parameter_list|)
block|{
name|memcpy
argument_list|(
name|regaddr
argument_list|,
operator|&
name|fi
operator|->
name|fsr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|frame_saved_regs
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arm_push_dummy_frame
parameter_list|(
name|void
parameter_list|)
block|{
name|CORE_ADDR
name|old_sp
init|=
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|sp
init|=
name|old_sp
decl_stmt|;
name|CORE_ADDR
name|fp
decl_stmt|,
name|prologue_start
decl_stmt|;
name|int
name|regnum
decl_stmt|;
comment|/* Push the two dummy prologue instructions in reverse order,      so that they'll be in the correct low-to-high order in memory.  */
comment|/* sub     fp, ip, #4 */
name|sp
operator|=
name|push_word
argument_list|(
name|sp
argument_list|,
literal|0xe24cb004
argument_list|)
expr_stmt|;
comment|/*  stmdb   sp!, {r0-r10, fp, ip, lr, pc} */
name|prologue_start
operator|=
name|sp
operator|=
name|push_word
argument_list|(
name|sp
argument_list|,
literal|0xe92ddfff
argument_list|)
expr_stmt|;
comment|/* Push a pointer to the dummy prologue + 12, because when stm      instruction stores the PC, it stores the address of the stm      instruction itself plus 12.  */
name|fp
operator|=
name|sp
operator|=
name|push_word
argument_list|(
name|sp
argument_list|,
name|prologue_start
operator|+
literal|12
argument_list|)
expr_stmt|;
name|sp
operator|=
name|push_word
argument_list|(
name|sp
argument_list|,
name|read_register
argument_list|(
name|PC_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FIXME: was PS_REGNUM */
name|sp
operator|=
name|push_word
argument_list|(
name|sp
argument_list|,
name|old_sp
argument_list|)
expr_stmt|;
name|sp
operator|=
name|push_word
argument_list|(
name|sp
argument_list|,
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|regnum
operator|=
literal|10
init|;
name|regnum
operator|>=
literal|0
condition|;
name|regnum
operator|--
control|)
name|sp
operator|=
name|push_word
argument_list|(
name|sp
argument_list|,
name|read_register
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|FP_REGNUM
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|THUMB_FP_REGNUM
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fix up the call dummy, based on whether the processor is currently    in Thumb or ARM mode, and whether the target function is Thumb or    ARM.  There are three different situations requiring three    different dummies:     * ARM calling ARM: uses the call dummy in tm-arm.h, which has already    been copied into the dummy parameter to this function.    * ARM calling Thumb: uses the call dummy in tm-arm.h, but with the    "mov pc,r4" instruction patched to be a "bx r4" instead.    * Thumb calling anything: uses the Thumb dummy defined below, which    works for calling both ARM and Thumb functions.     All three call dummies expect to receive the target function    address in R4, with the low bit set if it's a Thumb function.  */
end_comment

begin_function
name|void
name|arm_fix_call_dummy
parameter_list|(
name|char
modifier|*
name|dummy
parameter_list|,
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
name|fun
parameter_list|,
name|int
name|nargs
parameter_list|,
name|value_ptr
modifier|*
name|args
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|gcc_p
parameter_list|)
block|{
specifier|static
name|short
name|thumb_dummy
index|[
literal|4
index|]
init|=
block|{
literal|0xf000
block|,
literal|0xf801
block|,
comment|/*        bl      label */
literal|0xdf18
block|,
comment|/*        swi     24 */
literal|0x4720
block|,
comment|/* label: bx      r4 */
block|}
decl_stmt|;
specifier|static
name|unsigned
name|long
name|arm_bx_r4
init|=
literal|0xe12fff14
decl_stmt|;
comment|/* bx r4 instruction */
comment|/* Set flag indicating whether the current PC is in a Thumb function. */
name|caller_is_thumb
operator|=
name|arm_pc_is_thumb
argument_list|(
name|read_pc
argument_list|()
argument_list|)
expr_stmt|;
comment|/* If the target function is Thumb, set the low bit of the function      address.  And if the CPU is currently in ARM mode, patch the      second instruction of call dummy to use a BX instruction to      switch to Thumb mode.  */
name|target_is_thumb
operator|=
name|arm_pc_is_thumb
argument_list|(
name|fun
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_is_thumb
condition|)
block|{
name|fun
operator||=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|caller_is_thumb
condition|)
name|store_unsigned_integer
argument_list|(
name|dummy
operator|+
literal|4
argument_list|,
sizeof|sizeof
argument_list|(
name|arm_bx_r4
argument_list|)
argument_list|,
name|arm_bx_r4
argument_list|)
expr_stmt|;
block|}
comment|/* If the CPU is currently in Thumb mode, use the Thumb call dummy      instead of the ARM one that's already been copied.  This will      work for both Thumb and ARM target functions.  */
if|if
condition|(
name|caller_is_thumb
condition|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|dummy
decl_stmt|;
name|int
name|len
init|=
sizeof|sizeof
argument_list|(
name|thumb_dummy
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|thumb_dummy
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|store_unsigned_integer
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|thumb_dummy
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|thumb_dummy
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|thumb_dummy
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Put the target address in r4; the call dummy will copy this to      the PC. */
name|write_register
argument_list|(
literal|4
argument_list|,
name|fun
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the offset in the call dummy of the instruction that needs    to have a breakpoint placed on it.  This is the offset of the 'swi    24' instruction, which is no longer actually used, but simply acts    as a place-holder now.     This implements the CALL_DUMMY_BREAK_OFFSET macro.  */
end_comment

begin_function
name|int
name|arm_call_dummy_breakpoint_offset
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|caller_is_thumb
condition|)
return|return
literal|4
return|;
else|else
return|return
literal|8
return|;
block|}
end_function

begin_comment
comment|/* Note: ScottB     This function does not support passing parameters using the FPA    variant of the APCS.  It passes any floating point arguments in the    general registers and/or on the stack.  */
end_comment

begin_function
name|CORE_ADDR
name|arm_push_arguments
parameter_list|(
name|int
name|nargs
parameter_list|,
name|value_ptr
modifier|*
name|args
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|,
name|int
name|struct_return
parameter_list|,
name|CORE_ADDR
name|struct_addr
parameter_list|)
block|{
name|char
modifier|*
name|fp
decl_stmt|;
name|int
name|argnum
decl_stmt|,
name|argreg
decl_stmt|,
name|nstack_size
decl_stmt|;
comment|/* Walk through the list of args and determine how large a temporary      stack is required.  Need to take care here as structs may be      passed on the stack, and we have to to push them.  */
name|nstack_size
operator|=
operator|-
literal|4
operator|*
name|REGISTER_SIZE
expr_stmt|;
comment|/* Some arguments go into A1-A4.  */
if|if
condition|(
name|struct_return
condition|)
comment|/* The struct address goes in A1.  */
name|nstack_size
operator|+=
name|REGISTER_SIZE
expr_stmt|;
comment|/* Walk through the arguments and add their size to nstack_size.  */
for|for
control|(
name|argnum
operator|=
literal|0
init|;
name|argnum
operator|<
name|nargs
condition|;
name|argnum
operator|++
control|)
block|{
name|int
name|len
decl_stmt|;
name|struct
name|type
modifier|*
name|arg_type
decl_stmt|;
name|arg_type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|args
index|[
name|argnum
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|arg_type
argument_list|)
expr_stmt|;
comment|/* ANSI C code passes float arguments as integers, K&R code          passes float arguments as doubles.  Correct for this here.  */
if|if
condition|(
name|TYPE_CODE_FLT
operator|==
name|TYPE_CODE
argument_list|(
name|arg_type
argument_list|)
operator|&&
name|REGISTER_SIZE
operator|==
name|len
condition|)
name|nstack_size
operator|+=
name|FP_REGISTER_VIRTUAL_SIZE
expr_stmt|;
else|else
name|nstack_size
operator|+=
name|len
expr_stmt|;
block|}
comment|/* Allocate room on the stack, and initialize our stack frame      pointer.  */
name|fp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|nstack_size
operator|>
literal|0
condition|)
block|{
name|sp
operator|-=
name|nstack_size
expr_stmt|;
name|fp
operator|=
operator|(
name|char
operator|*
operator|)
name|sp
expr_stmt|;
block|}
comment|/* Initialize the integer argument register pointer.  */
name|argreg
operator|=
name|A1_REGNUM
expr_stmt|;
comment|/* The struct_return pointer occupies the first parameter passing      register.  */
if|if
condition|(
name|struct_return
condition|)
name|write_register
argument_list|(
name|argreg
operator|++
argument_list|,
name|struct_addr
argument_list|)
expr_stmt|;
comment|/* Process arguments from left to right.  Store as many as allowed      in the parameter passing registers (A1-A4), and save the rest on      the temporary stack.  */
for|for
control|(
name|argnum
operator|=
literal|0
init|;
name|argnum
operator|<
name|nargs
condition|;
name|argnum
operator|++
control|)
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|double
name|dbl_arg
decl_stmt|;
name|CORE_ADDR
name|regval
decl_stmt|;
name|enum
name|type_code
name|typecode
decl_stmt|;
name|struct
name|type
modifier|*
name|arg_type
decl_stmt|,
modifier|*
name|target_type
decl_stmt|;
name|arg_type
operator|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|args
index|[
name|argnum
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|target_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|arg_type
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|arg_type
argument_list|)
expr_stmt|;
name|typecode
operator|=
name|TYPE_CODE
argument_list|(
name|arg_type
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|char
operator|*
operator|)
name|VALUE_CONTENTS
argument_list|(
name|args
index|[
name|argnum
index|]
argument_list|)
expr_stmt|;
comment|/* ANSI C code passes float arguments as integers, K&R code          passes float arguments as doubles.  The .stabs record for           for ANSI prototype floating point arguments records the          type as FP_INTEGER, while a K&R style (no prototype)          .stabs records the type as FP_FLOAT.  In this latter case          the compiler converts the float arguments to double before          calling the function.  */
if|if
condition|(
name|TYPE_CODE_FLT
operator|==
name|typecode
operator|&&
name|REGISTER_SIZE
operator|==
name|len
condition|)
block|{
name|float
name|f
decl_stmt|;
name|double
name|d
decl_stmt|;
name|char
modifier|*
name|bufo
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|d
decl_stmt|;
name|char
modifier|*
name|bufd
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|dbl_arg
decl_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|double
argument_list|)
expr_stmt|;
name|f
operator|=
operator|*
operator|(
name|float
operator|*
operator|)
name|val
expr_stmt|;
name|SWAP_TARGET_AND_HOST
argument_list|(
operator|&
name|f
argument_list|,
sizeof|sizeof
argument_list|(
name|float
argument_list|)
argument_list|)
expr_stmt|;
comment|/* adjust endianess */
name|d
operator|=
name|f
expr_stmt|;
comment|/* We must revert the longwords so they get loaded into the 	     the right registers. */
name|memcpy
argument_list|(
name|bufd
argument_list|,
name|bufo
operator|+
name|len
operator|/
literal|2
argument_list|,
name|len
operator|/
literal|2
argument_list|)
expr_stmt|;
name|SWAP_TARGET_AND_HOST
argument_list|(
name|bufd
argument_list|,
name|len
operator|/
literal|2
argument_list|)
expr_stmt|;
comment|/* adjust endianess */
name|memcpy
argument_list|(
name|bufd
operator|+
name|len
operator|/
literal|2
argument_list|,
name|bufo
argument_list|,
name|len
operator|/
literal|2
argument_list|)
expr_stmt|;
name|SWAP_TARGET_AND_HOST
argument_list|(
name|bufd
operator|+
name|len
operator|/
literal|2
argument_list|,
name|len
operator|/
literal|2
argument_list|)
expr_stmt|;
comment|/* adjust endianess */
name|val
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|dbl_arg
expr_stmt|;
block|}
if|#
directive|if
literal|1
comment|/* I don't know why this code was disable. The only logical use          for a function pointer is to call that function, so setting          the mode bit is perfectly fine. FN */
comment|/* If the argument is a pointer to a function, and it is a Thumb          function, set the low bit of the pointer.  */
if|if
condition|(
name|TYPE_CODE_PTR
operator|==
name|typecode
operator|&&
name|NULL
operator|!=
name|target_type
operator|&&
name|TYPE_CODE_FUNC
operator|==
name|TYPE_CODE
argument_list|(
name|target_type
argument_list|)
condition|)
block|{
name|CORE_ADDR
name|regval
init|=
name|extract_address
argument_list|(
name|val
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|arm_pc_is_thumb
argument_list|(
name|regval
argument_list|)
condition|)
name|store_address
argument_list|(
name|val
argument_list|,
name|len
argument_list|,
name|MAKE_THUMB_ADDR
argument_list|(
name|regval
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Copy the argument to general registers or the stack in          register-sized pieces.  Large arguments are split between          registers and stack.  */
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|int
name|partial_len
init|=
name|len
operator|<
name|REGISTER_SIZE
condition|?
name|len
else|:
name|REGISTER_SIZE
decl_stmt|;
if|if
condition|(
name|argreg
operator|<=
name|ARM_LAST_ARG_REGNUM
condition|)
block|{
comment|/* It's an argument being passed in a general register.  */
name|regval
operator|=
name|extract_address
argument_list|(
name|val
argument_list|,
name|partial_len
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|argreg
operator|++
argument_list|,
name|regval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Push the arguments onto the stack.  */
name|write_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|fp
argument_list|,
name|val
argument_list|,
name|REGISTER_SIZE
argument_list|)
expr_stmt|;
name|fp
operator|+=
name|REGISTER_SIZE
expr_stmt|;
block|}
name|len
operator|-=
name|partial_len
expr_stmt|;
name|val
operator|+=
name|partial_len
expr_stmt|;
block|}
block|}
comment|/* Return adjusted stack pointer.  */
return|return
name|sp
return|;
block|}
end_function

begin_function
name|void
name|arm_pop_frame
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|regnum
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|frame
init|=
name|get_current_frame
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|PC_IN_CALL_DUMMY
argument_list|(
name|frame
operator|->
name|pc
argument_list|,
name|frame
operator|->
name|frame
argument_list|,
name|read_fp
argument_list|()
argument_list|)
condition|)
block|{
name|CORE_ADDR
name|old_SP
decl_stmt|;
name|old_SP
operator|=
name|read_register
argument_list|(
name|frame
operator|->
name|framereg
argument_list|)
expr_stmt|;
for|for
control|(
name|regnum
operator|=
literal|0
init|;
name|regnum
operator|<
name|NUM_REGS
condition|;
name|regnum
operator|++
control|)
if|if
condition|(
name|frame
operator|->
name|fsr
operator|.
name|regs
index|[
name|regnum
index|]
operator|!=
literal|0
condition|)
name|write_register
argument_list|(
name|regnum
argument_list|,
name|read_memory_integer
argument_list|(
name|frame
operator|->
name|fsr
operator|.
name|regs
index|[
name|regnum
index|]
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|PC_REGNUM
argument_list|,
name|FRAME_SAVED_PC
argument_list|(
name|frame
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|old_SP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CORE_ADDR
name|sp
decl_stmt|;
name|sp
operator|=
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
expr_stmt|;
name|sp
operator|-=
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
expr_stmt|;
comment|/* we don't care about this first word */
name|write_register
argument_list|(
name|PC_REGNUM
argument_list|,
name|read_memory_integer
argument_list|(
name|sp
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|-=
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|read_memory_integer
argument_list|(
name|sp
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|-=
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|FP_REGNUM
argument_list|,
name|read_memory_integer
argument_list|(
name|sp
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|-=
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
expr_stmt|;
for|for
control|(
name|regnum
operator|=
literal|10
init|;
name|regnum
operator|>=
literal|0
condition|;
name|regnum
operator|--
control|)
block|{
name|write_register
argument_list|(
name|regnum
argument_list|,
name|read_memory_integer
argument_list|(
name|sp
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|-=
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
expr_stmt|;
block|}
block|}
name|flush_cached_frames
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_fpu_flags
parameter_list|(
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|flags
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
condition|)
name|fputs
argument_list|(
literal|"IVO "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
condition|)
name|fputs
argument_list|(
literal|"DVZ "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
literal|1
operator|<<
literal|2
operator|)
condition|)
name|fputs
argument_list|(
literal|"OFL "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
literal|1
operator|<<
literal|3
operator|)
condition|)
name|fputs
argument_list|(
literal|"UFL "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
literal|1
operator|<<
literal|4
operator|)
condition|)
name|fputs
argument_list|(
literal|"INX "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arm_float_info
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|unsigned
name|long
name|status
init|=
name|read_register
argument_list|(
name|FPS_REGNUM
argument_list|)
decl_stmt|;
name|int
name|type
decl_stmt|;
name|type
operator|=
operator|(
name|status
operator|>>
literal|24
operator|)
operator|&
literal|127
expr_stmt|;
name|printf
argument_list|(
literal|"%s FPU type %d\n"
argument_list|,
operator|(
name|status
operator|&
operator|(
literal|1
operator|<<
literal|31
operator|)
operator|)
condition|?
literal|"Hardware"
else|:
literal|"Software"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"mask: "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|print_fpu_flags
argument_list|(
name|status
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"flags: "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|print_fpu_flags
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* FIXME:  The generated assembler works but sucks.  Instead of using    r0, r1 it pushes them on the stack, then loads them into r3, r4 and    uses those registers.  I must be missing something.  ScottB  */
end_comment

begin_comment
unit|void convert_from_extended (void *ptr, void *dbl) {   __asm__ (" 	   ldfe f0,[%0] 	   stfd f0,[%1] " :
comment|/* no output */
end_comment

begin_comment
unit|:	   "r" (ptr), "r" (dbl)); }  void convert_to_extended (void *dbl, void *ptr) {   __asm__ (" 	   ldfd f0,[%0] 	   stfe f0,[%1] " :
comment|/* no output */
end_comment

begin_else
unit|:	   "r" (dbl), "r" (ptr)); }
else|#
directive|else
end_else

begin_function
specifier|static
name|void
name|convert_from_extended
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|void
modifier|*
name|dbl
parameter_list|)
block|{
operator|*
operator|(
name|double
operator|*
operator|)
name|dbl
operator|=
operator|*
operator|(
name|double
operator|*
operator|)
name|ptr
expr_stmt|;
block|}
end_function

begin_function
name|void
name|convert_to_extended
parameter_list|(
name|void
modifier|*
name|dbl
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
operator|*
operator|(
name|double
operator|*
operator|)
name|ptr
operator|=
operator|*
operator|(
name|double
operator|*
operator|)
name|dbl
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Nonzero if register N requires conversion from raw format to    virtual format.  */
end_comment

begin_function
name|int
name|arm_register_convertible
parameter_list|(
name|unsigned
name|int
name|regnum
parameter_list|)
block|{
return|return
operator|(
operator|(
name|regnum
operator|-
name|F0_REGNUM
operator|)
operator|<
literal|8
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Convert data from raw format for register REGNUM in buffer FROM to    virtual format with type TYPE in buffer TO.  */
end_comment

begin_function
name|void
name|arm_register_convert_to_virtual
parameter_list|(
name|unsigned
name|int
name|regnum
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|void
modifier|*
name|from
parameter_list|,
name|void
modifier|*
name|to
parameter_list|)
block|{
name|double
name|val
decl_stmt|;
name|convert_from_extended
argument_list|(
name|from
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|store_floating
argument_list|(
name|to
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert data from virtual format with type TYPE in buffer FROM to    raw format for register REGNUM in buffer TO.  */
end_comment

begin_function
name|void
name|arm_register_convert_to_raw
parameter_list|(
name|unsigned
name|int
name|regnum
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|void
modifier|*
name|from
parameter_list|,
name|void
modifier|*
name|to
parameter_list|)
block|{
name|double
name|val
init|=
name|extract_floating
argument_list|(
name|from
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|convert_to_extended
argument_list|(
operator|&
name|val
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|condition_true
parameter_list|(
name|unsigned
name|long
name|cond
parameter_list|,
name|unsigned
name|long
name|status_reg
parameter_list|)
block|{
if|if
condition|(
name|cond
operator|==
name|INST_AL
operator|||
name|cond
operator|==
name|INST_NV
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|cond
condition|)
block|{
case|case
name|INST_EQ
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_Z
operator|)
operator|!=
literal|0
operator|)
return|;
case|case
name|INST_NE
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_Z
operator|)
operator|==
literal|0
operator|)
return|;
case|case
name|INST_CS
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_C
operator|)
operator|!=
literal|0
operator|)
return|;
case|case
name|INST_CC
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_C
operator|)
operator|==
literal|0
operator|)
return|;
case|case
name|INST_MI
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_N
operator|)
operator|!=
literal|0
operator|)
return|;
case|case
name|INST_PL
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_N
operator|)
operator|==
literal|0
operator|)
return|;
case|case
name|INST_VS
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_V
operator|)
operator|!=
literal|0
operator|)
return|;
case|case
name|INST_VC
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_V
operator|)
operator|==
literal|0
operator|)
return|;
case|case
name|INST_HI
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
operator|(
name|FLAG_C
operator||
name|FLAG_Z
operator|)
operator|)
operator|==
name|FLAG_C
operator|)
return|;
case|case
name|INST_LS
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
operator|(
name|FLAG_C
operator||
name|FLAG_Z
operator|)
operator|)
operator|!=
name|FLAG_C
operator|)
return|;
case|case
name|INST_GE
case|:
return|return
operator|(
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_N
operator|)
operator|==
literal|0
operator|)
operator|==
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_V
operator|)
operator|==
literal|0
operator|)
operator|)
return|;
case|case
name|INST_LT
case|:
return|return
operator|(
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_N
operator|)
operator|==
literal|0
operator|)
operator|!=
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_V
operator|)
operator|==
literal|0
operator|)
operator|)
return|;
case|case
name|INST_GT
case|:
return|return
operator|(
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_Z
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_N
operator|)
operator|==
literal|0
operator|)
operator|==
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_V
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
return|;
case|case
name|INST_LE
case|:
return|return
operator|(
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_Z
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_N
operator|)
operator|==
literal|0
operator|)
operator|!=
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_V
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|submask
parameter_list|(
name|x
parameter_list|)
value|((1L<< ((x) + 1)) - 1)
end_define

begin_define
define|#
directive|define
name|bit
parameter_list|(
name|obj
parameter_list|,
name|st
parameter_list|)
value|(((obj)>> (st))& 1)
end_define

begin_define
define|#
directive|define
name|bits
parameter_list|(
name|obj
parameter_list|,
name|st
parameter_list|,
name|fn
parameter_list|)
value|(((obj)>> (st))& submask ((fn) - (st)))
end_define

begin_define
define|#
directive|define
name|sbits
parameter_list|(
name|obj
parameter_list|,
name|st
parameter_list|,
name|fn
parameter_list|)
define|\
value|((long) (bits(obj,st,fn) | ((long) bit(obj,fn) * ~ submask (fn - st))))
end_define

begin_define
define|#
directive|define
name|BranchDest
parameter_list|(
name|addr
parameter_list|,
name|instr
parameter_list|)
define|\
value|((CORE_ADDR) (((long) (addr)) + 8 + (sbits (instr, 0, 23)<< 2)))
end_define

begin_define
define|#
directive|define
name|ARM_PC_32
value|1
end_define

begin_function
specifier|static
name|unsigned
name|long
name|shifted_reg_val
parameter_list|(
name|unsigned
name|long
name|inst
parameter_list|,
name|int
name|carry
parameter_list|,
name|unsigned
name|long
name|pc_val
parameter_list|,
name|unsigned
name|long
name|status_reg
parameter_list|)
block|{
name|unsigned
name|long
name|res
decl_stmt|,
name|shift
decl_stmt|;
name|int
name|rm
init|=
name|bits
argument_list|(
name|inst
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|shifttype
init|=
name|bits
argument_list|(
name|inst
argument_list|,
literal|5
argument_list|,
literal|6
argument_list|)
decl_stmt|;
if|if
condition|(
name|bit
argument_list|(
name|inst
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|int
name|rs
init|=
name|bits
argument_list|(
name|inst
argument_list|,
literal|8
argument_list|,
literal|11
argument_list|)
decl_stmt|;
name|shift
operator|=
operator|(
name|rs
operator|==
literal|15
condition|?
name|pc_val
operator|+
literal|8
else|:
name|read_register
argument_list|(
name|rs
argument_list|)
operator|)
operator|&
literal|0xFF
expr_stmt|;
block|}
else|else
name|shift
operator|=
name|bits
argument_list|(
name|inst
argument_list|,
literal|7
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|res
operator|=
operator|(
name|rm
operator|==
literal|15
condition|?
operator|(
operator|(
name|pc_val
operator||
operator|(
name|ARM_PC_32
condition|?
literal|0
else|:
name|status_reg
operator|)
operator|)
operator|+
operator|(
name|bit
argument_list|(
name|inst
argument_list|,
literal|4
argument_list|)
condition|?
literal|12
else|:
literal|8
operator|)
operator|)
else|:
name|read_register
argument_list|(
name|rm
argument_list|)
operator|)
expr_stmt|;
switch|switch
condition|(
name|shifttype
condition|)
block|{
case|case
literal|0
case|:
comment|/* LSL */
name|res
operator|=
name|shift
operator|>=
literal|32
condition|?
literal|0
else|:
name|res
operator|<<
name|shift
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* LSR */
name|res
operator|=
name|shift
operator|>=
literal|32
condition|?
literal|0
else|:
name|res
operator|>>
name|shift
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* ASR */
if|if
condition|(
name|shift
operator|>=
literal|32
condition|)
name|shift
operator|=
literal|31
expr_stmt|;
name|res
operator|=
operator|(
operator|(
name|res
operator|&
literal|0x80000000L
operator|)
condition|?
operator|~
operator|(
operator|(
operator|~
name|res
operator|)
operator|>>
name|shift
operator|)
else|:
name|res
operator|>>
name|shift
operator|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* ROR/RRX */
name|shift
operator|&=
literal|31
expr_stmt|;
if|if
condition|(
name|shift
operator|==
literal|0
condition|)
name|res
operator|=
operator|(
name|res
operator|>>
literal|1
operator|)
operator||
operator|(
name|carry
condition|?
literal|0x80000000L
else|:
literal|0
operator|)
expr_stmt|;
else|else
name|res
operator|=
operator|(
name|res
operator|>>
name|shift
operator|)
operator||
operator|(
name|res
operator|<<
operator|(
literal|32
operator|-
name|shift
operator|)
operator|)
expr_stmt|;
break|break;
block|}
return|return
name|res
operator|&
literal|0xffffffff
return|;
block|}
end_function

begin_comment
comment|/* Return number of 1-bits in VAL.  */
end_comment

begin_function
specifier|static
name|int
name|bitcount
parameter_list|(
name|unsigned
name|long
name|val
parameter_list|)
block|{
name|int
name|nbits
decl_stmt|;
for|for
control|(
name|nbits
operator|=
literal|0
init|;
name|val
operator|!=
literal|0
condition|;
name|nbits
operator|++
control|)
name|val
operator|&=
name|val
operator|-
literal|1
expr_stmt|;
comment|/* delete rightmost 1-bit in val */
return|return
name|nbits
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|thumb_get_next_pc
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|unsigned
name|long
name|pc_val
init|=
operator|(
operator|(
name|unsigned
name|long
operator|)
name|pc
operator|)
operator|+
literal|4
decl_stmt|;
comment|/* PC after prefetch */
name|unsigned
name|short
name|inst1
init|=
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|nextpc
init|=
name|pc
operator|+
literal|2
decl_stmt|;
comment|/* default is next instruction */
name|unsigned
name|long
name|offset
decl_stmt|;
if|if
condition|(
operator|(
name|inst1
operator|&
literal|0xff00
operator|)
operator|==
literal|0xbd00
condition|)
comment|/* pop {rlist, pc} */
block|{
name|CORE_ADDR
name|sp
decl_stmt|;
comment|/* Fetch the saved PC from the stack.  It's stored above          all of the other registers.  */
name|offset
operator|=
name|bitcount
argument_list|(
name|bits
argument_list|(
name|inst1
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|)
argument_list|)
operator|*
name|REGISTER_SIZE
expr_stmt|;
name|sp
operator|=
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
expr_stmt|;
name|nextpc
operator|=
operator|(
name|CORE_ADDR
operator|)
name|read_memory_integer
argument_list|(
name|sp
operator|+
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|nextpc
operator|=
name|ADDR_BITS_REMOVE
argument_list|(
name|nextpc
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextpc
operator|==
name|pc
condition|)
name|error
argument_list|(
literal|"Infinite loop detected"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|inst1
operator|&
literal|0xf000
operator|)
operator|==
literal|0xd000
condition|)
comment|/* conditional branch */
block|{
name|unsigned
name|long
name|status
init|=
name|read_register
argument_list|(
name|PS_REGNUM
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|cond
init|=
name|bits
argument_list|(
name|inst1
argument_list|,
literal|8
argument_list|,
literal|11
argument_list|)
decl_stmt|;
if|if
condition|(
name|cond
operator|!=
literal|0x0f
operator|&&
name|condition_true
argument_list|(
name|cond
argument_list|,
name|status
argument_list|)
condition|)
comment|/* 0x0f = SWI */
name|nextpc
operator|=
name|pc_val
operator|+
operator|(
name|sbits
argument_list|(
name|inst1
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|)
operator|<<
literal|1
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|inst1
operator|&
literal|0xf800
operator|)
operator|==
literal|0xe000
condition|)
comment|/* unconditional branch */
block|{
name|nextpc
operator|=
name|pc_val
operator|+
operator|(
name|sbits
argument_list|(
name|inst1
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
operator|<<
literal|1
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|inst1
operator|&
literal|0xf800
operator|)
operator|==
literal|0xf000
condition|)
comment|/* long branch with link */
block|{
name|unsigned
name|short
name|inst2
init|=
name|read_memory_integer
argument_list|(
name|pc
operator|+
literal|2
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|offset
operator|=
operator|(
name|sbits
argument_list|(
name|inst1
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
operator|<<
literal|12
operator|)
operator|+
operator|(
name|bits
argument_list|(
name|inst2
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
operator|<<
literal|1
operator|)
expr_stmt|;
name|nextpc
operator|=
name|pc_val
operator|+
name|offset
expr_stmt|;
block|}
return|return
name|nextpc
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|arm_get_next_pc
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|unsigned
name|long
name|pc_val
decl_stmt|;
name|unsigned
name|long
name|this_instr
decl_stmt|;
name|unsigned
name|long
name|status
decl_stmt|;
name|CORE_ADDR
name|nextpc
decl_stmt|;
if|if
condition|(
name|arm_pc_is_thumb
argument_list|(
name|pc
argument_list|)
condition|)
return|return
name|thumb_get_next_pc
argument_list|(
name|pc
argument_list|)
return|;
name|pc_val
operator|=
operator|(
name|unsigned
name|long
operator|)
name|pc
expr_stmt|;
name|this_instr
operator|=
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|status
operator|=
name|read_register
argument_list|(
name|PS_REGNUM
argument_list|)
expr_stmt|;
name|nextpc
operator|=
call|(
name|CORE_ADDR
call|)
argument_list|(
name|pc_val
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* Default case */
if|if
condition|(
name|condition_true
argument_list|(
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|28
argument_list|,
literal|31
argument_list|)
argument_list|,
name|status
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|24
argument_list|,
literal|27
argument_list|)
condition|)
block|{
case|case
literal|0x0
case|:
case|case
literal|0x1
case|:
comment|/* data processing */
case|case
literal|0x2
case|:
case|case
literal|0x3
case|:
block|{
name|unsigned
name|long
name|operand1
decl_stmt|,
name|operand2
decl_stmt|,
name|result
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|rn
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|12
argument_list|,
literal|15
argument_list|)
operator|!=
literal|15
condition|)
break|break;
if|if
condition|(
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|22
argument_list|,
literal|25
argument_list|)
operator|==
literal|0
operator|&&
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|4
argument_list|,
literal|7
argument_list|)
operator|==
literal|9
condition|)
comment|/* multiply */
name|error
argument_list|(
literal|"Illegal update to pc in instruction"
argument_list|)
expr_stmt|;
comment|/* Multiply into PC */
name|c
operator|=
operator|(
name|status
operator|&
name|FLAG_C
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|rn
operator|=
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|16
argument_list|,
literal|19
argument_list|)
expr_stmt|;
name|operand1
operator|=
operator|(
name|rn
operator|==
literal|15
operator|)
condition|?
name|pc_val
operator|+
literal|8
else|:
name|read_register
argument_list|(
name|rn
argument_list|)
expr_stmt|;
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|25
argument_list|)
condition|)
block|{
name|unsigned
name|long
name|immval
init|=
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|rotate
init|=
literal|2
operator|*
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|8
argument_list|,
literal|11
argument_list|)
decl_stmt|;
name|operand2
operator|=
operator|(
operator|(
name|immval
operator|>>
name|rotate
operator|)
operator||
operator|(
name|immval
operator|<<
operator|(
literal|32
operator|-
name|rotate
operator|)
operator|)
operator|)
operator|&
literal|0xffffffff
expr_stmt|;
block|}
else|else
comment|/* operand 2 is a shifted register */
name|operand2
operator|=
name|shifted_reg_val
argument_list|(
name|this_instr
argument_list|,
name|c
argument_list|,
name|pc_val
argument_list|,
name|status
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|21
argument_list|,
literal|24
argument_list|)
condition|)
block|{
case|case
literal|0x0
case|:
comment|/*and */
name|result
operator|=
name|operand1
operator|&
name|operand2
expr_stmt|;
break|break;
case|case
literal|0x1
case|:
comment|/*eor */
name|result
operator|=
name|operand1
operator|^
name|operand2
expr_stmt|;
break|break;
case|case
literal|0x2
case|:
comment|/*sub */
name|result
operator|=
name|operand1
operator|-
name|operand2
expr_stmt|;
break|break;
case|case
literal|0x3
case|:
comment|/*rsb */
name|result
operator|=
name|operand2
operator|-
name|operand1
expr_stmt|;
break|break;
case|case
literal|0x4
case|:
comment|/*add */
name|result
operator|=
name|operand1
operator|+
name|operand2
expr_stmt|;
break|break;
case|case
literal|0x5
case|:
comment|/*adc */
name|result
operator|=
name|operand1
operator|+
name|operand2
operator|+
name|c
expr_stmt|;
break|break;
case|case
literal|0x6
case|:
comment|/*sbc */
name|result
operator|=
name|operand1
operator|-
name|operand2
operator|+
name|c
expr_stmt|;
break|break;
case|case
literal|0x7
case|:
comment|/*rsc */
name|result
operator|=
name|operand2
operator|-
name|operand1
operator|+
name|c
expr_stmt|;
break|break;
case|case
literal|0x8
case|:
case|case
literal|0x9
case|:
case|case
literal|0xa
case|:
case|case
literal|0xb
case|:
comment|/* tst, teq, cmp, cmn */
name|result
operator|=
operator|(
name|unsigned
name|long
operator|)
name|nextpc
expr_stmt|;
break|break;
case|case
literal|0xc
case|:
comment|/*orr */
name|result
operator|=
name|operand1
operator||
name|operand2
expr_stmt|;
break|break;
case|case
literal|0xd
case|:
comment|/*mov */
comment|/* Always step into a function.  */
name|result
operator|=
name|operand2
expr_stmt|;
break|break;
case|case
literal|0xe
case|:
comment|/*bic */
name|result
operator|=
name|operand1
operator|&
operator|~
name|operand2
expr_stmt|;
break|break;
case|case
literal|0xf
case|:
comment|/*mvn */
name|result
operator|=
operator|~
name|operand2
expr_stmt|;
break|break;
block|}
name|nextpc
operator|=
operator|(
name|CORE_ADDR
operator|)
name|ADDR_BITS_REMOVE
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextpc
operator|==
name|pc
condition|)
name|error
argument_list|(
literal|"Infinite loop detected"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|0x4
case|:
case|case
literal|0x5
case|:
comment|/* data transfer */
case|case
literal|0x6
case|:
case|case
literal|0x7
case|:
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|20
argument_list|)
condition|)
block|{
comment|/* load */
if|if
condition|(
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|12
argument_list|,
literal|15
argument_list|)
operator|==
literal|15
condition|)
block|{
comment|/* rd == pc */
name|unsigned
name|long
name|rn
decl_stmt|;
name|unsigned
name|long
name|base
decl_stmt|;
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|22
argument_list|)
condition|)
name|error
argument_list|(
literal|"Illegal update to pc in instruction"
argument_list|)
expr_stmt|;
comment|/* byte write to PC */
name|rn
operator|=
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|16
argument_list|,
literal|19
argument_list|)
expr_stmt|;
name|base
operator|=
operator|(
name|rn
operator|==
literal|15
operator|)
condition|?
name|pc_val
operator|+
literal|8
else|:
name|read_register
argument_list|(
name|rn
argument_list|)
expr_stmt|;
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|24
argument_list|)
condition|)
block|{
comment|/* pre-indexed */
name|int
name|c
init|=
operator|(
name|status
operator|&
name|FLAG_C
operator|)
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|unsigned
name|long
name|offset
init|=
operator|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|25
argument_list|)
condition|?
name|shifted_reg_val
argument_list|(
name|this_instr
argument_list|,
name|c
argument_list|,
name|pc_val
argument_list|,
name|status
argument_list|)
else|:
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|0
argument_list|,
literal|11
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|23
argument_list|)
condition|)
name|base
operator|+=
name|offset
expr_stmt|;
else|else
name|base
operator|-=
name|offset
expr_stmt|;
block|}
name|nextpc
operator|=
operator|(
name|CORE_ADDR
operator|)
name|read_memory_integer
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|base
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|nextpc
operator|=
name|ADDR_BITS_REMOVE
argument_list|(
name|nextpc
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextpc
operator|==
name|pc
condition|)
name|error
argument_list|(
literal|"Infinite loop detected"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|0x8
case|:
case|case
literal|0x9
case|:
comment|/* block transfer */
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|20
argument_list|)
condition|)
block|{
comment|/* LDM */
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|15
argument_list|)
condition|)
block|{
comment|/* loading pc */
name|int
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|23
argument_list|)
condition|)
block|{
comment|/* up */
name|unsigned
name|long
name|reglist
init|=
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|0
argument_list|,
literal|14
argument_list|)
decl_stmt|;
name|offset
operator|=
name|bitcount
argument_list|(
name|reglist
argument_list|)
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|24
argument_list|)
condition|)
comment|/* pre */
name|offset
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|24
argument_list|)
condition|)
name|offset
operator|=
operator|-
literal|4
expr_stmt|;
block|{
name|unsigned
name|long
name|rn_val
init|=
name|read_register
argument_list|(
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|16
argument_list|,
literal|19
argument_list|)
argument_list|)
decl_stmt|;
name|nextpc
operator|=
operator|(
name|CORE_ADDR
operator|)
name|read_memory_integer
argument_list|(
call|(
name|CORE_ADDR
call|)
argument_list|(
name|rn_val
operator|+
name|offset
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|nextpc
operator|=
name|ADDR_BITS_REMOVE
argument_list|(
name|nextpc
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextpc
operator|==
name|pc
condition|)
name|error
argument_list|(
literal|"Infinite loop detected"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|0xb
case|:
comment|/* branch& link */
case|case
literal|0xa
case|:
comment|/* branch */
block|{
name|nextpc
operator|=
name|BranchDest
argument_list|(
name|pc
argument_list|,
name|this_instr
argument_list|)
expr_stmt|;
name|nextpc
operator|=
name|ADDR_BITS_REMOVE
argument_list|(
name|nextpc
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextpc
operator|==
name|pc
condition|)
name|error
argument_list|(
literal|"Infinite loop detected"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|0xc
case|:
case|case
literal|0xd
case|:
case|case
literal|0xe
case|:
comment|/* coproc ops */
case|case
literal|0xf
case|:
comment|/* SWI */
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad bit-field extraction\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|pc
operator|)
return|;
block|}
block|}
return|return
name|nextpc
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"bfd-in2.h"
end_include

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_function
specifier|static
name|int
name|gdb_print_insn_arm
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
name|arm_pc_is_thumb
argument_list|(
name|memaddr
argument_list|)
condition|)
block|{
specifier|static
name|asymbol
modifier|*
name|asym
decl_stmt|;
specifier|static
name|combined_entry_type
name|ce
decl_stmt|;
specifier|static
name|struct
name|coff_symbol_struct
name|csym
decl_stmt|;
specifier|static
name|struct
name|_bfd
name|fake_bfd
decl_stmt|;
specifier|static
name|bfd_target
name|fake_target
decl_stmt|;
if|if
condition|(
name|csym
operator|.
name|native
operator|==
name|NULL
condition|)
block|{
comment|/* Create a fake symbol vector containing a Thumb symbol.  This is 	     solely so that the code in print_insn_little_arm() and 	     print_insn_big_arm() in opcodes/arm-dis.c will detect the presence 	     of a Thumb symbol and switch to decoding Thumb instructions.  */
name|fake_target
operator|.
name|flavour
operator|=
name|bfd_target_coff_flavour
expr_stmt|;
name|fake_bfd
operator|.
name|xvec
operator|=
operator|&
name|fake_target
expr_stmt|;
name|ce
operator|.
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|=
name|C_THUMBEXTFUNC
expr_stmt|;
name|csym
operator|.
name|native
operator|=
operator|&
name|ce
expr_stmt|;
name|csym
operator|.
name|symbol
operator|.
name|the_bfd
operator|=
operator|&
name|fake_bfd
expr_stmt|;
name|csym
operator|.
name|symbol
operator|.
name|name
operator|=
literal|"fake"
expr_stmt|;
name|asym
operator|=
operator|(
name|asymbol
operator|*
operator|)
operator|&
name|csym
expr_stmt|;
block|}
name|memaddr
operator|=
name|UNMAKE_THUMB_ADDR
argument_list|(
name|memaddr
argument_list|)
expr_stmt|;
name|info
operator|->
name|symbols
operator|=
operator|&
name|asym
expr_stmt|;
block|}
else|else
name|info
operator|->
name|symbols
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BIG_ENDIAN
condition|)
return|return
name|print_insn_big_arm
argument_list|(
name|memaddr
argument_list|,
name|info
argument_list|)
return|;
else|else
return|return
name|print_insn_little_arm
argument_list|(
name|memaddr
argument_list|,
name|info
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This function implements the BREAKPOINT_FROM_PC macro.  It uses the    program counter value to determine whether a 16-bit or 32-bit    breakpoint should be used.  It returns a pointer to a string of    bytes that encode a breakpoint instruction, stores the length of    the string to *lenptr, and adjusts the program counter (if    necessary) to point to the actual memory location where the    breakpoint should be inserted.  */
end_comment

begin_function
name|unsigned
name|char
modifier|*
name|arm_breakpoint_from_pc
parameter_list|(
name|CORE_ADDR
modifier|*
name|pcptr
parameter_list|,
name|int
modifier|*
name|lenptr
parameter_list|)
block|{
if|if
condition|(
name|arm_pc_is_thumb
argument_list|(
operator|*
name|pcptr
argument_list|)
operator|||
name|arm_pc_is_thumb_dummy
argument_list|(
operator|*
name|pcptr
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BIG_ENDIAN
condition|)
block|{
specifier|static
name|char
name|thumb_breakpoint
index|[]
init|=
name|THUMB_BE_BREAKPOINT
decl_stmt|;
operator|*
name|pcptr
operator|=
name|UNMAKE_THUMB_ADDR
argument_list|(
operator|*
name|pcptr
argument_list|)
expr_stmt|;
operator|*
name|lenptr
operator|=
sizeof|sizeof
argument_list|(
name|thumb_breakpoint
argument_list|)
expr_stmt|;
return|return
name|thumb_breakpoint
return|;
block|}
else|else
block|{
specifier|static
name|char
name|thumb_breakpoint
index|[]
init|=
name|THUMB_LE_BREAKPOINT
decl_stmt|;
operator|*
name|pcptr
operator|=
name|UNMAKE_THUMB_ADDR
argument_list|(
operator|*
name|pcptr
argument_list|)
expr_stmt|;
operator|*
name|lenptr
operator|=
sizeof|sizeof
argument_list|(
name|thumb_breakpoint
argument_list|)
expr_stmt|;
return|return
name|thumb_breakpoint
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BIG_ENDIAN
condition|)
block|{
specifier|static
name|char
name|arm_breakpoint
index|[]
init|=
name|ARM_BE_BREAKPOINT
decl_stmt|;
operator|*
name|lenptr
operator|=
sizeof|sizeof
argument_list|(
name|arm_breakpoint
argument_list|)
expr_stmt|;
return|return
name|arm_breakpoint
return|;
block|}
else|else
block|{
specifier|static
name|char
name|arm_breakpoint
index|[]
init|=
name|ARM_LE_BREAKPOINT
decl_stmt|;
operator|*
name|lenptr
operator|=
sizeof|sizeof
argument_list|(
name|arm_breakpoint
argument_list|)
expr_stmt|;
return|return
name|arm_breakpoint
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Extract from an array REGBUF containing the (raw) register state a    function return value of type TYPE, and copy that, in virtual    format, into VALBUF.  */
end_comment

begin_function
name|void
name|arm_extract_return_value
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
name|regbuf
index|[
name|REGISTER_BYTES
index|]
parameter_list|,
name|char
modifier|*
name|valbuf
parameter_list|)
block|{
if|if
condition|(
name|TYPE_CODE_FLT
operator|==
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
name|convert_from_extended
argument_list|(
operator|&
name|regbuf
index|[
name|REGISTER_BYTE
argument_list|(
name|F0_REGNUM
argument_list|)
index|]
argument_list|,
name|valbuf
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|valbuf
argument_list|,
operator|&
name|regbuf
index|[
name|REGISTER_BYTE
argument_list|(
name|A1_REGNUM
argument_list|)
index|]
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return non-zero if the PC is inside a thumb call thunk.  */
end_comment

begin_function
name|int
name|arm_in_call_stub
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|CORE_ADDR
name|start_addr
decl_stmt|;
comment|/* Find the starting address of the function containing the PC.  If      the caller didn't give us a name, look it up at the same time.  */
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
name|name
condition|?
name|NULL
else|:
operator|&
name|name
argument_list|,
operator|&
name|start_addr
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_call_via_r"
argument_list|,
literal|11
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If PC is in a Thumb call or return stub, return the address of the    target PC, which is in a register.  The thunk functions are called    _called_via_xx, where x is the register name.  The possible names    are r0-r9, sl, fp, ip, sp, and lr.  */
end_comment

begin_function
name|CORE_ADDR
name|arm_skip_stub
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|CORE_ADDR
name|start_addr
decl_stmt|;
comment|/* Find the starting address and name of the function containing the PC.  */
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|start_addr
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Call thunks always start with "_call_via_".  */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_call_via_"
argument_list|,
literal|10
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Use the name suffix to determine which register contains the          target PC.  */
specifier|static
name|char
modifier|*
name|table
index|[
literal|15
index|]
init|=
block|{
literal|"r0"
block|,
literal|"r1"
block|,
literal|"r2"
block|,
literal|"r3"
block|,
literal|"r4"
block|,
literal|"r5"
block|,
literal|"r6"
block|,
literal|"r7"
block|,
literal|"r8"
block|,
literal|"r9"
block|,
literal|"sl"
block|,
literal|"fp"
block|,
literal|"ip"
block|,
literal|"sp"
block|,
literal|"lr"
block|}
decl_stmt|;
name|int
name|regno
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<=
literal|14
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|name
index|[
literal|10
index|]
argument_list|,
name|table
index|[
name|regno
index|]
argument_list|)
operator|==
literal|0
condition|)
return|return
name|read_register
argument_list|(
name|regno
argument_list|)
return|;
block|}
return|return
literal|0
return|;
comment|/* not a stub */
block|}
end_function

begin_comment
comment|/* If the user changes the register disassembly flavor used for info register    and other commands, we have to also switch the flavor used in opcodes    for disassembly output.    This function is run in the set disassembly_flavor command, and does that. */
end_comment

begin_function
specifier|static
name|void
name|set_disassembly_flavor_sfunc
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
name|set_disassembly_flavor
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|set_disassembly_flavor
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|setname
decl_stmt|,
modifier|*
name|setdesc
decl_stmt|,
modifier|*
modifier|*
name|regnames
decl_stmt|;
name|int
name|numregs
decl_stmt|,
name|j
decl_stmt|;
comment|/* Find the flavor that the user wants in the opcodes table. */
name|int
name|current
init|=
literal|0
decl_stmt|;
name|numregs
operator|=
name|get_arm_regnames
argument_list|(
name|current
argument_list|,
operator|&
name|setname
argument_list|,
operator|&
name|setdesc
argument_list|,
operator|&
name|regnames
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|disassembly_flavor
operator|!=
name|setname
operator|)
operator|&&
operator|(
name|current
operator|<
name|num_flavor_options
operator|)
condition|)
name|get_arm_regnames
argument_list|(
operator|++
name|current
argument_list|,
operator|&
name|setname
argument_list|,
operator|&
name|setdesc
argument_list|,
operator|&
name|regnames
argument_list|)
expr_stmt|;
name|current_option
operator|=
name|current
expr_stmt|;
comment|/* Fill our copy. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|numregs
condition|;
name|j
operator|++
control|)
name|arm_register_names
index|[
name|j
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|regnames
index|[
name|j
index|]
expr_stmt|;
comment|/* Adjust case. */
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|regnames
index|[
name|PC_REGNUM
index|]
argument_list|)
condition|)
block|{
name|arm_register_names
index|[
name|FPS_REGNUM
index|]
operator|=
literal|"FPS"
expr_stmt|;
name|arm_register_names
index|[
name|PS_REGNUM
index|]
operator|=
literal|"CPSR"
expr_stmt|;
block|}
else|else
block|{
name|arm_register_names
index|[
name|FPS_REGNUM
index|]
operator|=
literal|"fps"
expr_stmt|;
name|arm_register_names
index|[
name|PS_REGNUM
index|]
operator|=
literal|"cpsr"
expr_stmt|;
block|}
comment|/* Synchronize the disassembler. */
name|set_arm_regname_option
argument_list|(
name|current
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* arm_othernames implements the "othernames" command.  This is kind    of hacky, and I prefer the set-show disassembly-flavor which is    also used for the x86 gdb.  I will keep this around, however, in    case anyone is actually using it. */
end_comment

begin_function
specifier|static
name|void
name|arm_othernames
parameter_list|(
name|char
modifier|*
name|names
parameter_list|,
name|int
name|n
parameter_list|)
block|{
comment|/* Circle through the various flavors. */
name|current_option
operator|=
operator|(
name|current_option
operator|+
literal|1
operator|)
operator|%
name|num_flavor_options
expr_stmt|;
name|disassembly_flavor
operator|=
name|valid_flavors
index|[
name|current_option
index|]
expr_stmt|;
name|set_disassembly_flavor
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_arm_tdep
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ui_file
modifier|*
name|stb
decl_stmt|;
name|long
name|length
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|new_cmd
decl_stmt|;
specifier|const
name|char
modifier|*
name|setname
decl_stmt|,
modifier|*
name|setdesc
decl_stmt|,
modifier|*
modifier|*
name|regnames
decl_stmt|;
name|int
name|numregs
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|static
name|char
modifier|*
name|helptext
decl_stmt|;
name|tm_print_insn
operator|=
name|gdb_print_insn_arm
expr_stmt|;
comment|/* Get the number of possible sets of register names defined in opcodes. */
name|num_flavor_options
operator|=
name|get_arm_regname_num_options
argument_list|()
expr_stmt|;
comment|/* Sync the opcode insn printer with our register viewer: */
name|parse_arm_disassembler_option
argument_list|(
literal|"reg-names-std"
argument_list|)
expr_stmt|;
comment|/* Begin creating the help text. */
name|stb
operator|=
name|mem_fileopen
argument_list|()
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|stb
argument_list|,
literal|"Set the disassembly flavor.\n\ The valid values are:\n"
argument_list|)
expr_stmt|;
comment|/* Initialize the array that will be passed to add_set_enum_cmd(). */
name|valid_flavors
operator|=
name|xmalloc
argument_list|(
operator|(
name|num_flavor_options
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_flavor_options
condition|;
name|i
operator|++
control|)
block|{
name|numregs
operator|=
name|get_arm_regnames
argument_list|(
name|i
argument_list|,
operator|&
name|setname
argument_list|,
operator|&
name|setdesc
argument_list|,
operator|&
name|regnames
argument_list|)
expr_stmt|;
name|valid_flavors
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|setname
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|stb
argument_list|,
literal|"%s - %s\n"
argument_list|,
name|setname
argument_list|,
name|setdesc
argument_list|)
expr_stmt|;
comment|/* Copy the default names (if found) and synchronize disassembler. */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|setname
argument_list|,
literal|"std"
argument_list|)
condition|)
block|{
name|disassembly_flavor
operator|=
operator|(
name|char
operator|*
operator|)
name|setname
expr_stmt|;
name|current_option
operator|=
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|numregs
condition|;
name|j
operator|++
control|)
name|arm_register_names
index|[
name|j
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|regnames
index|[
name|j
index|]
expr_stmt|;
name|set_arm_regname_option
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Mark the end of valid options. */
name|valid_flavors
index|[
name|num_flavor_options
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Finish the creation of the help text. */
name|fprintf_unfiltered
argument_list|(
name|stb
argument_list|,
literal|"The default is \"std\"."
argument_list|)
expr_stmt|;
name|helptext
operator|=
name|ui_file_xstrdup
argument_list|(
name|stb
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
name|ui_file_delete
argument_list|(
name|stb
argument_list|)
expr_stmt|;
comment|/* Add the disassembly-flavor command */
name|new_cmd
operator|=
name|add_set_enum_cmd
argument_list|(
literal|"disassembly-flavor"
argument_list|,
name|no_class
argument_list|,
name|valid_flavors
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|disassembly_flavor
argument_list|,
name|helptext
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|new_cmd
operator|->
name|function
operator|.
name|sfunc
operator|=
name|set_disassembly_flavor_sfunc
expr_stmt|;
name|add_show_from_set
argument_list|(
name|new_cmd
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
comment|/* ??? Maybe this should be a boolean.  */
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"apcs32"
argument_list|,
name|no_class
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|arm_apcs_32
argument_list|,
literal|"Set usage of ARM 32-bit mode.\n"
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
comment|/* Add the deprecated "othernames" command */
name|add_com
argument_list|(
literal|"othernames"
argument_list|,
name|class_obscure
argument_list|,
name|arm_othernames
argument_list|,
literal|"Switch to the next set of register names."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Test whether the coff symbol specific value corresponds to a Thumb    function.  */
end_comment

begin_function
name|int
name|coff_sym_is_thumb
parameter_list|(
name|int
name|val
parameter_list|)
block|{
return|return
operator|(
name|val
operator|==
name|C_THUMBEXT
operator|||
name|val
operator|==
name|C_THUMBSTAT
operator|||
name|val
operator|==
name|C_THUMBEXTFUNC
operator|||
name|val
operator|==
name|C_THUMBSTATFUNC
operator|||
name|val
operator|==
name|C_THUMBLABEL
operator|)
return|;
block|}
end_function

end_unit

