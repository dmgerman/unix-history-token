begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target-dependent code for the Acorn Risc Machine, for GDB, the GNU Debugger.    Copyright (C) 1988, 1989, 1991, 1992, 1993, 1995, 1996, 1998, 1999    Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_comment
comment|/* Internal format of COFF symbols in BFD */
end_comment

begin_comment
comment|/*   The following macros are actually wrong.  Neither arm nor thumb can   or should set the lsb on addr.   The thumb addresses are mod 2, so (addr& 2) would be a good heuristic   to use when checking for thumb (see arm_pc_is_thumb() below).   Unfortunately, something else depends on these (incorrect) macros, so   fixing them actually breaks gdb.  I didn't have time to investigate. Z.R. */
end_comment

begin_comment
comment|/* Thumb function addresses are odd (bit 0 is set).  Here are some    macros to test, set, or clear bit 0 of addresses.  */
end_comment

begin_define
define|#
directive|define
name|IS_THUMB_ADDR
parameter_list|(
name|addr
parameter_list|)
value|((addr)& 1)
end_define

begin_define
define|#
directive|define
name|MAKE_THUMB_ADDR
parameter_list|(
name|addr
parameter_list|)
value|((addr) | 1)
end_define

begin_define
define|#
directive|define
name|UNMAKE_THUMB_ADDR
parameter_list|(
name|addr
parameter_list|)
value|((addr)& ~1)
end_define

begin_comment
comment|/* Macros to round N up or down to the next A boundary; A must be    a power of two. */
end_comment

begin_define
define|#
directive|define
name|ROUND_DOWN
parameter_list|(
name|n
parameter_list|,
name|a
parameter_list|)
value|((n)& ~((a) - 1))
end_define

begin_define
define|#
directive|define
name|ROUND_UP
parameter_list|(
name|n
parameter_list|,
name|a
parameter_list|)
value|(((n) + (a) - 1)& ~((a) - 1))
end_define

begin_comment
comment|/* Should call_function allocate stack space for a struct return?  */
end_comment

begin_comment
comment|/* The system C compiler uses a similar structure return convention to gcc */
end_comment

begin_function
name|int
name|arm_use_struct_convention
parameter_list|(
name|gcc_p
parameter_list|,
name|type
parameter_list|)
name|int
name|gcc_p
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
return|return
operator|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|>
literal|4
operator|)
return|;
block|}
end_function

begin_function
name|int
name|arm_frame_chain_valid
parameter_list|(
name|chain
parameter_list|,
name|thisframe
parameter_list|)
name|CORE_ADDR
name|chain
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|thisframe
decl_stmt|;
block|{
define|#
directive|define
name|LOWEST_PC
value|0x20
comment|/* the first 0x20 bytes are the trap vectors. */
return|return
operator|(
name|chain
operator|!=
literal|0
operator|&&
operator|(
name|FRAME_SAVED_PC
argument_list|(
name|thisframe
argument_list|)
operator|>=
name|LOWEST_PC
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Set to true if the 32-bit mode is in use. */
end_comment

begin_decl_stmt
name|int
name|arm_apcs_32
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag set by arm_fix_call_dummy that tells whether the target function    is a Thumb function.  This flag is checked by arm_push_arguments.    FIXME: Change the PUSH_ARGUMENTS macro (and its use in valops.c) to    pass the function address as an additional parameter.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|target_is_thumb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flag set by arm_fix_call_dummy that tells whether the calling function    is a Thumb function.  This flag is checked by arm_pc_is_thumb    and arm_call_dummy_breakpoint_offset.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|caller_is_thumb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tell if the program counter value in MEMADDR is in a Thumb function.  */
end_comment

begin_function
name|int
name|arm_pc_is_thumb
parameter_list|(
name|memaddr
parameter_list|)
name|bfd_vma
name|memaddr
decl_stmt|;
block|{
name|struct
name|minimal_symbol
modifier|*
name|sym
decl_stmt|;
name|CORE_ADDR
name|sp
decl_stmt|;
comment|/* If bit 0 of the address is set, assume this is a Thumb address. */
if|if
condition|(
name|IS_THUMB_ADDR
argument_list|(
name|memaddr
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* Thumb function have a "special" bit set in minimal symbols */
name|sym
operator|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|memaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
return|return
operator|(
name|MSYMBOL_IS_SPECIAL
argument_list|(
name|sym
argument_list|)
operator|)
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Tell if the program counter value in MEMADDR is in a call dummy that    is being called from a Thumb function.  */
end_comment

begin_function
name|int
name|arm_pc_is_thumb_dummy
parameter_list|(
name|memaddr
parameter_list|)
name|bfd_vma
name|memaddr
decl_stmt|;
block|{
name|CORE_ADDR
name|sp
init|=
name|read_sp
argument_list|()
decl_stmt|;
if|if
condition|(
name|PC_IN_CALL_DUMMY
argument_list|(
name|memaddr
argument_list|,
name|sp
argument_list|,
name|sp
operator|+
literal|64
argument_list|)
condition|)
return|return
name|caller_is_thumb
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|arm_addr_bits_remove
parameter_list|(
name|val
parameter_list|)
name|CORE_ADDR
name|val
decl_stmt|;
block|{
if|if
condition|(
name|arm_pc_is_thumb
argument_list|(
name|val
argument_list|)
condition|)
return|return
operator|(
name|val
operator|&
operator|(
name|arm_apcs_32
condition|?
literal|0xfffffffe
else|:
literal|0x03fffffe
operator|)
operator|)
return|;
else|else
return|return
operator|(
name|val
operator|&
operator|(
name|arm_apcs_32
condition|?
literal|0xfffffffc
else|:
literal|0x03fffffc
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|arm_saved_pc_after_call
parameter_list|(
name|frame
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame
decl_stmt|;
block|{
return|return
name|ADDR_BITS_REMOVE
argument_list|(
name|read_register
argument_list|(
name|LR_REGNUM
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A typical Thumb prologue looks like this:         push    {r7, lr}         add     sp, sp, #-28         add     r7, sp, #12    Sometimes the latter instruction may be replaced by:         mov     r7, sp  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|thumb_skip_prologue
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
name|CORE_ADDR
name|current_pc
decl_stmt|;
for|for
control|(
name|current_pc
operator|=
name|pc
init|;
name|current_pc
operator|<
name|pc
operator|+
literal|20
condition|;
name|current_pc
operator|+=
literal|2
control|)
block|{
name|unsigned
name|short
name|insn
init|=
name|read_memory_unsigned_integer
argument_list|(
name|current_pc
argument_list|,
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xfe00
operator|)
operator|!=
literal|0xb400
comment|/* push {..., r7, lr} */
operator|&&
operator|(
name|insn
operator|&
literal|0xff00
operator|)
operator|!=
literal|0xb000
comment|/* add sp, #simm */
operator|&&
operator|(
name|insn
operator|&
literal|0xff00
operator|)
operator|!=
literal|0xaf00
comment|/* add r7, sp, #imm */
operator|&&
name|insn
operator|!=
literal|0x466f
comment|/* mov r7, sp */
operator|&&
operator|(
name|insn
operator|&
literal|0xffc0
operator|)
operator|!=
literal|0x4640
condition|)
comment|/* mov r0-r7, r8-r15 */
break|break;
block|}
return|return
name|current_pc
return|;
block|}
end_function

begin_comment
comment|/* APCS (ARM procedure call standard) defines the following prologue:     mov		ip, sp   [stmfd	sp!, {a1,a2,a3,a4}]    stmfd	sp!, {...,fp,ip,lr,pc}   [stfe		f7, [sp, #-12]!]   [stfe		f6, [sp, #-12]!]   [stfe		f5, [sp, #-12]!]   [stfe		f4, [sp, #-12]!]    sub		fp, ip, #nn	// nn == 20 or 4 depending on second ins */
end_comment

begin_function
name|CORE_ADDR
name|arm_skip_prologue
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
name|unsigned
name|long
name|inst
decl_stmt|;
name|CORE_ADDR
name|skip_pc
decl_stmt|;
name|CORE_ADDR
name|func_addr
decl_stmt|,
name|func_end
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
comment|/* See what the symbol table says. */
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
name|NULL
argument_list|,
operator|&
name|func_addr
argument_list|,
operator|&
name|func_end
argument_list|)
condition|)
block|{
name|sal
operator|=
name|find_pc_line
argument_list|(
name|func_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|line
operator|!=
literal|0
operator|&&
name|sal
operator|.
name|end
operator|<
name|func_end
condition|)
return|return
name|sal
operator|.
name|end
return|;
block|}
comment|/* Check if this is Thumb code.  */
if|if
condition|(
name|arm_pc_is_thumb
argument_list|(
name|pc
argument_list|)
condition|)
return|return
name|thumb_skip_prologue
argument_list|(
name|pc
argument_list|)
return|;
comment|/* Can't find the prologue end in the symbol table, try it the hard way      by disassembling the instructions. */
name|skip_pc
operator|=
name|pc
expr_stmt|;
name|inst
operator|=
name|read_memory_integer
argument_list|(
name|skip_pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst
operator|!=
literal|0xe1a0c00d
condition|)
comment|/* mov ip, sp */
return|return
name|pc
return|;
name|skip_pc
operator|+=
literal|4
expr_stmt|;
name|inst
operator|=
name|read_memory_integer
argument_list|(
name|skip_pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xfffffff0
operator|)
operator|==
literal|0xe92d0000
condition|)
comment|/* stmfd sp!,{a1,a2,a3,a4}  */
block|{
name|skip_pc
operator|+=
literal|4
expr_stmt|;
name|inst
operator|=
name|read_memory_integer
argument_list|(
name|skip_pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xfffff800
operator|)
operator|!=
literal|0xe92dd800
condition|)
comment|/* stmfd sp!,{...,fp,ip,lr,pc} */
return|return
name|pc
return|;
name|skip_pc
operator|+=
literal|4
expr_stmt|;
name|inst
operator|=
name|read_memory_integer
argument_list|(
name|skip_pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Any insns after this point may float into the code, if it makes      for better instruction scheduling, so we skip them only if      we find them, but still consdier the function to be frame-ful  */
comment|/* We may have either one sfmfd instruction here, or several stfe insns,      depending on the version of floating point code we support.  */
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xffbf0fff
operator|)
operator|==
literal|0xec2d0200
condition|)
comment|/* sfmfd fn,<cnt>, [sp]! */
block|{
name|skip_pc
operator|+=
literal|4
expr_stmt|;
name|inst
operator|=
name|read_memory_integer
argument_list|(
name|skip_pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|(
name|inst
operator|&
literal|0xffff8fff
operator|)
operator|==
literal|0xed6d0103
condition|)
comment|/* stfe fn, [sp, #-12]! */
block|{
name|skip_pc
operator|+=
literal|4
expr_stmt|;
name|inst
operator|=
name|read_memory_integer
argument_list|(
name|skip_pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|inst
operator|&
literal|0xfffff000
operator|)
operator|==
literal|0xe24cb000
condition|)
comment|/* sub fp, ip, #nn */
name|skip_pc
operator|+=
literal|4
expr_stmt|;
return|return
name|skip_pc
return|;
block|}
end_function

begin_comment
comment|/* Function: thumb_scan_prologue (helper function for arm_scan_prologue)    This function decodes a Thumb function prologue to determine:      1) the size of the stack frame      2) which registers are saved on it      3) the offsets of saved regs      4) the offset from the stack pointer to the frame pointer    This information is stored in the "extra" fields of the frame_info.     A typical Thumb function prologue might look like this: 	push {r7, lr} 	sub  sp, #28, 	add  r7, sp, #12    Which would create this stack frame (offsets relative to FP)      old SP ->	24  stack parameters 		20  LR 		16  R7      R7 ->       0  local variables (16 bytes)      SP ->     -12  additional stack space (12 bytes)    The frame size would thus be 36 bytes, and the frame offset would be    12 bytes.  The frame register is R7.  */
end_comment

begin_function
specifier|static
name|void
name|thumb_scan_prologue
parameter_list|(
name|fi
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
block|{
name|CORE_ADDR
name|prologue_start
decl_stmt|;
name|CORE_ADDR
name|prologue_end
decl_stmt|;
name|CORE_ADDR
name|current_pc
decl_stmt|;
name|int
name|saved_reg
index|[
literal|16
index|]
decl_stmt|;
comment|/* which register has been copied to register n? */
name|int
name|i
decl_stmt|;
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
name|NULL
argument_list|,
operator|&
name|prologue_start
argument_list|,
operator|&
name|prologue_end
argument_list|)
condition|)
block|{
name|struct
name|symtab_and_line
name|sal
init|=
name|find_pc_line
argument_list|(
name|prologue_start
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|sal
operator|.
name|line
operator|==
literal|0
condition|)
comment|/* no line info, use current PC */
name|prologue_end
operator|=
name|fi
operator|->
name|pc
expr_stmt|;
elseif|else
if|if
condition|(
name|sal
operator|.
name|end
operator|<
name|prologue_end
condition|)
comment|/* next line begins after fn end */
name|prologue_end
operator|=
name|sal
operator|.
name|end
expr_stmt|;
comment|/* (probably means no prologue)  */
block|}
else|else
name|prologue_end
operator|=
name|prologue_start
operator|+
literal|40
expr_stmt|;
comment|/* We're in the boondocks: allow for */
comment|/* 16 pushes, an add, and "mv fp,sp" */
name|prologue_end
operator|=
name|min
argument_list|(
name|prologue_end
argument_list|,
name|fi
operator|->
name|pc
argument_list|)
expr_stmt|;
comment|/* Initialize the saved register map.  When register H is copied to      register L, we will put H in saved_reg[L].  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
name|saved_reg
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
comment|/* Search the prologue looking for instructions that set up the      frame pointer, adjust the stack pointer, and save registers.  */
name|fi
operator|->
name|framesize
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|current_pc
operator|=
name|prologue_start
init|;
name|current_pc
operator|<
name|prologue_end
condition|;
name|current_pc
operator|+=
literal|2
control|)
block|{
name|unsigned
name|short
name|insn
decl_stmt|;
name|int
name|regno
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|insn
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|current_pc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xfe00
operator|)
operator|==
literal|0xb400
condition|)
comment|/* push { rlist } */
block|{
comment|/* Bits 0-7 contain a mask for registers R0-R7.  Bit 8 says 	     whether to save LR (R14).  */
name|int
name|mask
init|=
operator|(
name|insn
operator|&
literal|0xff
operator|)
operator||
operator|(
operator|(
name|insn
operator|&
literal|0x100
operator|)
operator|<<
literal|6
operator|)
decl_stmt|;
comment|/* Calculate offsets of saved R0-R7 and LR. */
for|for
control|(
name|regno
operator|=
name|LR_REGNUM
init|;
name|regno
operator|>=
literal|0
condition|;
name|regno
operator|--
control|)
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|regno
operator|)
condition|)
block|{
name|fi
operator|->
name|framesize
operator|+=
literal|4
expr_stmt|;
name|fi
operator|->
name|fsr
operator|.
name|regs
index|[
name|saved_reg
index|[
name|regno
index|]
index|]
operator|=
operator|-
operator|(
name|fi
operator|->
name|framesize
operator|)
expr_stmt|;
name|saved_reg
index|[
name|regno
index|]
operator|=
name|regno
expr_stmt|;
comment|/* reset saved register map */
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xff00
operator|)
operator|==
literal|0xb000
condition|)
comment|/* add sp, #simm */
block|{
name|offset
operator|=
operator|(
name|insn
operator|&
literal|0x7f
operator|)
operator|<<
literal|2
expr_stmt|;
comment|/* get scaled offset */
if|if
condition|(
name|insn
operator|&
literal|0x80
condition|)
comment|/* is it signed? */
name|offset
operator|=
operator|-
name|offset
expr_stmt|;
name|fi
operator|->
name|framesize
operator|-=
name|offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xff00
operator|)
operator|==
literal|0xaf00
condition|)
comment|/* add r7, sp, #imm */
block|{
name|fi
operator|->
name|framereg
operator|=
name|THUMB_FP_REGNUM
expr_stmt|;
name|fi
operator|->
name|frameoffset
operator|=
operator|(
name|insn
operator|&
literal|0xff
operator|)
operator|<<
literal|2
expr_stmt|;
comment|/* get scaled offset */
block|}
elseif|else
if|if
condition|(
name|insn
operator|==
literal|0x466f
condition|)
comment|/* mov r7, sp */
block|{
name|fi
operator|->
name|framereg
operator|=
name|THUMB_FP_REGNUM
expr_stmt|;
name|fi
operator|->
name|frameoffset
operator|=
literal|0
expr_stmt|;
name|saved_reg
index|[
name|THUMB_FP_REGNUM
index|]
operator|=
name|SP_REGNUM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xffc0
operator|)
operator|==
literal|0x4640
condition|)
comment|/* mov r0-r7, r8-r15 */
block|{
name|int
name|lo_reg
init|=
name|insn
operator|&
literal|7
decl_stmt|;
comment|/* dest. register (r0-r7) */
name|int
name|hi_reg
init|=
operator|(
operator|(
name|insn
operator|>>
literal|3
operator|)
operator|&
literal|7
operator|)
operator|+
literal|8
decl_stmt|;
comment|/* source register (r8-15) */
name|saved_reg
index|[
name|lo_reg
index|]
operator|=
name|hi_reg
expr_stmt|;
comment|/* remember hi reg was saved */
block|}
else|else
break|break;
comment|/* anything else isn't prologue */
block|}
block|}
end_function

begin_comment
comment|/* Function: check_prologue_cache    Check if prologue for this frame's PC has already been scanned.    If it has, copy the relevant information about that prologue and    return non-zero.  Otherwise do not copy anything and return zero.     The information saved in the cache includes:      * the frame register number;      * the size of the stack frame;      * the offsets of saved regs (relative to the old SP); and      * the offset from the stack pointer to the frame pointer     The cache contains only one entry, since this is adequate    for the typical sequence of prologue scan requests we get.    When performing a backtrace, GDB will usually ask to scan    the same function twice in a row (once to get the frame chain,    and once to fill in the extra frame information). */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|frame_info
name|prologue_cache
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|check_prologue_cache
parameter_list|(
name|fi
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|fi
operator|->
name|pc
operator|==
name|prologue_cache
operator|.
name|pc
condition|)
block|{
name|fi
operator|->
name|framereg
operator|=
name|prologue_cache
operator|.
name|framereg
expr_stmt|;
name|fi
operator|->
name|framesize
operator|=
name|prologue_cache
operator|.
name|framesize
expr_stmt|;
name|fi
operator|->
name|frameoffset
operator|=
name|prologue_cache
operator|.
name|frameoffset
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|NUM_REGS
condition|;
name|i
operator|++
control|)
name|fi
operator|->
name|fsr
operator|.
name|regs
index|[
name|i
index|]
operator|=
name|prologue_cache
operator|.
name|fsr
operator|.
name|regs
index|[
name|i
index|]
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Function: save_prologue_cache    Copy the prologue information from fi to the prologue cache. */
end_comment

begin_function
specifier|static
name|void
name|save_prologue_cache
parameter_list|(
name|fi
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|prologue_cache
operator|.
name|pc
operator|=
name|fi
operator|->
name|pc
expr_stmt|;
name|prologue_cache
operator|.
name|framereg
operator|=
name|fi
operator|->
name|framereg
expr_stmt|;
name|prologue_cache
operator|.
name|framesize
operator|=
name|fi
operator|->
name|framesize
expr_stmt|;
name|prologue_cache
operator|.
name|frameoffset
operator|=
name|fi
operator|->
name|frameoffset
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|NUM_REGS
condition|;
name|i
operator|++
control|)
name|prologue_cache
operator|.
name|fsr
operator|.
name|regs
index|[
name|i
index|]
operator|=
name|fi
operator|->
name|fsr
operator|.
name|regs
index|[
name|i
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function: arm_scan_prologue    This function decodes an ARM function prologue to determine:      1) the size of the stack frame      2) which registers are saved on it      3) the offsets of saved regs      4) the offset from the stack pointer to the frame pointer    This information is stored in the "extra" fields of the frame_info.     A typical Arm function prologue might look like this: 	mov    ip, sp 	stmfd  sp!, {fp, ip, lr, pc} 	sub    fp, ip, #4 	sub    sp, sp, #16    Which would create this stack frame (offsets relative to FP):      IP ->   4	(caller's stack)      FP ->   0	PC (points to address of stmfd instruction + 12 in callee) 	    -4	LR (return address in caller) 	    -8	IP (copy of caller's SP)      	   -12	FP (caller's FP)      SP -> -28	Local variables    The frame size would thus be 32 bytes, and the frame offset would be    28 bytes.  */
end_comment

begin_function
specifier|static
name|void
name|arm_scan_prologue
parameter_list|(
name|fi
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
block|{
name|int
name|regno
decl_stmt|,
name|sp_offset
decl_stmt|,
name|fp_offset
decl_stmt|;
name|CORE_ADDR
name|prologue_start
decl_stmt|,
name|prologue_end
decl_stmt|,
name|current_pc
decl_stmt|;
comment|/* Check if this function is already in the cache of frame information. */
if|if
condition|(
name|check_prologue_cache
argument_list|(
name|fi
argument_list|)
condition|)
return|return;
comment|/* Assume there is no frame until proven otherwise.  */
name|fi
operator|->
name|framereg
operator|=
name|SP_REGNUM
expr_stmt|;
name|fi
operator|->
name|framesize
operator|=
literal|0
expr_stmt|;
name|fi
operator|->
name|frameoffset
operator|=
literal|0
expr_stmt|;
comment|/* Check for Thumb prologue.  */
if|if
condition|(
name|arm_pc_is_thumb
argument_list|(
name|fi
operator|->
name|pc
argument_list|)
condition|)
block|{
name|thumb_scan_prologue
argument_list|(
name|fi
argument_list|)
expr_stmt|;
name|save_prologue_cache
argument_list|(
name|fi
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Find the function prologue.  If we can't find the function in      the symbol table, peek in the stack frame to find the PC.  */
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
name|NULL
argument_list|,
operator|&
name|prologue_start
argument_list|,
operator|&
name|prologue_end
argument_list|)
condition|)
block|{
comment|/* Assume the prologue is everything between the first instruction          in the function and the first source line.  */
name|struct
name|symtab_and_line
name|sal
init|=
name|find_pc_line
argument_list|(
name|prologue_start
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|sal
operator|.
name|line
operator|==
literal|0
condition|)
comment|/* no line info, use current PC */
name|prologue_end
operator|=
name|fi
operator|->
name|pc
expr_stmt|;
elseif|else
if|if
condition|(
name|sal
operator|.
name|end
operator|<
name|prologue_end
condition|)
comment|/* next line begins after fn end */
name|prologue_end
operator|=
name|sal
operator|.
name|end
expr_stmt|;
comment|/* (probably means no prologue)  */
block|}
else|else
block|{
comment|/* Get address of the stmfd in the prologue of the callee; the saved          PC is the address of the stmfd + 12.  */
name|prologue_start
operator|=
operator|(
name|read_memory_integer
argument_list|(
name|fi
operator|->
name|frame
argument_list|,
literal|4
argument_list|)
operator|&
literal|0x03fffffc
operator|)
operator|-
literal|12
expr_stmt|;
name|prologue_end
operator|=
name|prologue_start
operator|+
literal|40
expr_stmt|;
comment|/* FIXME: should be big enough */
block|}
comment|/* Now search the prologue looking for instructions that set up the      frame pointer, adjust the stack pointer, and save registers.  */
name|sp_offset
operator|=
name|fp_offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|current_pc
operator|=
name|prologue_start
init|;
name|current_pc
operator|<
name|prologue_end
condition|;
name|current_pc
operator|+=
literal|4
control|)
block|{
name|unsigned
name|int
name|insn
init|=
name|read_memory_unsigned_integer
argument_list|(
name|current_pc
argument_list|,
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xffff0000
operator|)
operator|==
literal|0xe92d0000
condition|)
comment|/* stmfd sp!, {..., r7, lr} */
block|{
name|int
name|mask
init|=
name|insn
operator|&
literal|0xffff
decl_stmt|;
comment|/* Calculate offsets of saved registers. */
for|for
control|(
name|regno
operator|=
name|PC_REGNUM
init|;
name|regno
operator|>=
literal|0
condition|;
name|regno
operator|--
control|)
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
name|regno
operator|)
condition|)
block|{
name|sp_offset
operator|-=
literal|4
expr_stmt|;
name|fi
operator|->
name|fsr
operator|.
name|regs
index|[
name|regno
index|]
operator|=
name|sp_offset
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xfffff000
operator|)
operator|==
literal|0xe24cb000
condition|)
comment|/* sub fp, ip #n */
block|{
name|unsigned
name|imm
init|=
name|insn
operator|&
literal|0xff
decl_stmt|;
comment|/* immediate value */
name|unsigned
name|rot
init|=
operator|(
name|insn
operator|&
literal|0xf00
operator|)
operator|>>
literal|7
decl_stmt|;
comment|/* rotate amount */
name|imm
operator|=
operator|(
name|imm
operator|>>
name|rot
operator|)
operator||
operator|(
name|imm
operator|<<
operator|(
literal|32
operator|-
name|rot
operator|)
operator|)
expr_stmt|;
name|fp_offset
operator|=
operator|-
name|imm
expr_stmt|;
name|fi
operator|->
name|framereg
operator|=
name|FP_REGNUM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xfffff000
operator|)
operator|==
literal|0xe24dd000
condition|)
comment|/* sub sp, sp #n */
block|{
name|unsigned
name|imm
init|=
name|insn
operator|&
literal|0xff
decl_stmt|;
comment|/* immediate value */
name|unsigned
name|rot
init|=
operator|(
name|insn
operator|&
literal|0xf00
operator|)
operator|>>
literal|7
decl_stmt|;
comment|/* rotate amount */
name|imm
operator|=
operator|(
name|imm
operator|>>
name|rot
operator|)
operator||
operator|(
name|imm
operator|<<
operator|(
literal|32
operator|-
name|rot
operator|)
operator|)
expr_stmt|;
name|sp_offset
operator|-=
name|imm
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xffff7fff
operator|)
operator|==
literal|0xed6d0103
condition|)
comment|/* stfe f?, [sp, -#c]! */
block|{
name|sp_offset
operator|-=
literal|12
expr_stmt|;
name|regno
operator|=
name|F0_REGNUM
operator|+
operator|(
operator|(
name|insn
operator|>>
literal|12
operator|)
operator|&
literal|0x07
operator|)
expr_stmt|;
name|fi
operator|->
name|fsr
operator|.
name|regs
index|[
name|regno
index|]
operator|=
name|sp_offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|insn
operator|==
literal|0xe1a0c00d
condition|)
comment|/* mov ip, sp */
continue|continue;
else|else
break|break;
comment|/* not a recognized prologue instruction */
block|}
comment|/* The frame size is just the negative of the offset (from the original SP)      of the last thing thing we pushed on the stack.  The frame offset is      [new FP] - [new SP].  */
name|fi
operator|->
name|framesize
operator|=
operator|-
name|sp_offset
expr_stmt|;
name|fi
operator|->
name|frameoffset
operator|=
name|fp_offset
operator|-
name|sp_offset
expr_stmt|;
name|save_prologue_cache
argument_list|(
name|fi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function: find_callers_reg    Find REGNUM on the stack.  Otherwise, it's in an active register.  One thing    we might want to do here is to check REGNUM against the clobber mask, and    somehow flag it as invalid if it isn't saved on the stack somewhere.  This    would provide a graceful failure mode when trying to get the value of    caller-saves registers for an inner frame.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|arm_find_callers_reg
parameter_list|(
name|fi
parameter_list|,
name|regnum
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|int
name|regnum
decl_stmt|;
block|{
for|for
control|(
init|;
name|fi
condition|;
name|fi
operator|=
name|fi
operator|->
name|next
control|)
if|#
directive|if
literal|0
comment|/* FIXME: enable this code if we convert to new call dummy scheme.  */
for|if (PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))       return generic_read_register_dummy (fi->pc, fi->frame, regnum);     else
endif|#
directive|endif
if|if
condition|(
name|fi
operator|->
name|fsr
operator|.
name|regs
index|[
name|regnum
index|]
operator|!=
literal|0
condition|)
return|return
name|read_memory_integer
argument_list|(
name|fi
operator|->
name|fsr
operator|.
name|regs
index|[
name|regnum
index|]
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
return|;
return|return
name|read_register
argument_list|(
name|regnum
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Function: frame_chain    Given a GDB frame, determine the address of the calling function's frame.    This will be used to create a new GDB frame struct, and then    INIT_EXTRA_FRAME_INFO and INIT_FRAME_PC will be called for the new frame.    For ARM, we save the frame size when we initialize the frame_info.     The original definition of this function was a macro in tm-arm.h:       { In the case of the ARM, the frame's nominal address is the FP value, 	 and 12 bytes before comes the saved previous FP value as a 4-byte word.  }        #define FRAME_CHAIN(thisframe)  \ 	((thisframe)->pc>= LOWEST_PC ?    \ 	 read_memory_integer ((thisframe)->frame - 12, 4) :\ 	 0) */
end_comment

begin_function
name|CORE_ADDR
name|arm_frame_chain
parameter_list|(
name|fi
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
block|{
if|#
directive|if
literal|0
comment|/* FIXME: enable this code if we convert to new call dummy scheme.  */
block|CORE_ADDR fn_start, callers_pc, fp;
comment|/* is this a dummy frame? */
block|if (PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))     return fi->frame;
comment|/* dummy frame same as caller's frame */
comment|/* is caller-of-this a dummy frame? */
block|callers_pc = FRAME_SAVED_PC(fi);
comment|/* find out who called us: */
block|fp = arm_find_callers_reg (fi, FP_REGNUM);   if (PC_IN_CALL_DUMMY (callers_pc, fp, fp))	     return fp;
comment|/* dummy frame's frame may bear no relation to ours */
block|if (find_pc_partial_function (fi->pc, 0,&fn_start, 0))     if (fn_start == entry_point_address ())       return 0;
comment|/* in _start fn, don't chain further */
endif|#
directive|endif
name|CORE_ADDR
name|caller_pc
decl_stmt|,
name|fn_start
decl_stmt|;
name|struct
name|frame_info
name|caller_fi
decl_stmt|;
name|int
name|framereg
init|=
name|fi
operator|->
name|framereg
decl_stmt|;
if|if
condition|(
name|fi
operator|->
name|pc
operator|<
name|LOWEST_PC
condition|)
return|return
literal|0
return|;
comment|/* If the caller is the startup code, we're at the end of the chain.  */
name|caller_pc
operator|=
name|FRAME_SAVED_PC
argument_list|(
name|fi
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|caller_pc
argument_list|,
literal|0
argument_list|,
operator|&
name|fn_start
argument_list|,
literal|0
argument_list|)
condition|)
if|if
condition|(
name|fn_start
operator|==
name|entry_point_address
argument_list|()
condition|)
return|return
literal|0
return|;
comment|/* If the caller is Thumb and the caller is ARM, or vice versa,      the frame register of the caller is different from ours.      So we must scan the prologue of the caller to determine its      frame register number. */
if|if
condition|(
name|arm_pc_is_thumb
argument_list|(
name|caller_pc
argument_list|)
operator|!=
name|arm_pc_is_thumb
argument_list|(
name|fi
operator|->
name|pc
argument_list|)
condition|)
block|{
name|memset
argument_list|(
operator|&
name|caller_fi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|caller_fi
argument_list|)
argument_list|)
expr_stmt|;
name|caller_fi
operator|.
name|pc
operator|=
name|caller_pc
expr_stmt|;
name|arm_scan_prologue
argument_list|(
operator|&
name|caller_fi
argument_list|)
expr_stmt|;
name|framereg
operator|=
name|caller_fi
operator|.
name|framereg
expr_stmt|;
block|}
comment|/* If the caller used a frame register, return its value.      Otherwise, return the caller's stack pointer.  */
if|if
condition|(
name|framereg
operator|==
name|FP_REGNUM
operator|||
name|framereg
operator|==
name|THUMB_FP_REGNUM
condition|)
return|return
name|arm_find_callers_reg
argument_list|(
name|fi
argument_list|,
name|framereg
argument_list|)
return|;
else|else
return|return
name|fi
operator|->
name|frame
operator|+
name|fi
operator|->
name|framesize
return|;
block|}
end_function

begin_comment
comment|/* Function: init_extra_frame_info    This function actually figures out the frame address for a given pc and    sp.  This is tricky  because we sometimes don't use an explicit    frame pointer, and the previous stack pointer isn't necessarily recorded    on the stack.  The only reliable way to get this info is to    examine the prologue.  */
end_comment

begin_function
name|void
name|arm_init_extra_frame_info
parameter_list|(
name|fi
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
block|{
name|int
name|reg
decl_stmt|;
if|if
condition|(
name|fi
operator|->
name|next
condition|)
name|fi
operator|->
name|pc
operator|=
name|FRAME_SAVED_PC
argument_list|(
name|fi
operator|->
name|next
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|fi
operator|->
name|fsr
operator|.
name|regs
argument_list|,
literal|'\000'
argument_list|,
sizeof|sizeof
name|fi
operator|->
name|fsr
operator|.
name|regs
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* FIXME: enable this code if we convert to new call dummy scheme.  */
block|if (PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))     {
comment|/* We need to setup fi->frame here because run_stack_dummy gets it wrong 	 by assuming it's always FP.  */
block|fi->frame       = generic_read_register_dummy (fi->pc, fi->frame, SP_REGNUM);       fi->framesize   = 0;       fi->frameoffset = 0;       return;     }   else
endif|#
directive|endif
block|{
name|arm_scan_prologue
argument_list|(
name|fi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fi
operator|->
name|next
condition|)
comment|/* this is the innermost frame? */
name|fi
operator|->
name|frame
operator|=
name|read_register
argument_list|(
name|fi
operator|->
name|framereg
argument_list|)
expr_stmt|;
elseif|else
comment|/* not the innermost frame */
comment|/* If we have an FP,  the callee saved it. */
if|if
condition|(
name|fi
operator|->
name|framereg
operator|==
name|FP_REGNUM
operator|||
name|fi
operator|->
name|framereg
operator|==
name|THUMB_FP_REGNUM
condition|)
if|if
condition|(
name|fi
operator|->
name|next
operator|->
name|fsr
operator|.
name|regs
index|[
name|fi
operator|->
name|framereg
index|]
operator|!=
literal|0
condition|)
name|fi
operator|->
name|frame
operator|=
name|read_memory_integer
argument_list|(
name|fi
operator|->
name|next
operator|->
name|fsr
operator|.
name|regs
index|[
name|fi
operator|->
name|framereg
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Calculate actual addresses of saved registers using offsets determined          by arm_scan_prologue.  */
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<
name|NUM_REGS
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|fi
operator|->
name|fsr
operator|.
name|regs
index|[
name|reg
index|]
operator|!=
literal|0
condition|)
name|fi
operator|->
name|fsr
operator|.
name|regs
index|[
name|reg
index|]
operator|+=
name|fi
operator|->
name|frame
operator|+
name|fi
operator|->
name|framesize
operator|-
name|fi
operator|->
name|frameoffset
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Function: frame_saved_pc    Find the caller of this frame.  We do this by seeing if LR_REGNUM is saved    in the stack anywhere, otherwise we get it from the registers.     The old definition of this function was a macro:      #define FRAME_SAVED_PC(FRAME) \ 	ADDR_BITS_REMOVE (read_memory_integer ((FRAME)->frame - 4, 4)) */
end_comment

begin_function
name|CORE_ADDR
name|arm_frame_saved_pc
parameter_list|(
name|fi
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
block|{
if|#
directive|if
literal|0
comment|/* FIXME: enable this code if we convert to new call dummy scheme.  */
block|if (PC_IN_CALL_DUMMY (fi->pc, fi->frame, fi->frame))     return generic_read_register_dummy (fi->pc, fi->frame, PC_REGNUM);   else
endif|#
directive|endif
block|{
name|CORE_ADDR
name|pc
init|=
name|arm_find_callers_reg
argument_list|(
name|fi
argument_list|,
name|LR_REGNUM
argument_list|)
decl_stmt|;
return|return
name|IS_THUMB_ADDR
argument_list|(
name|pc
argument_list|)
condition|?
name|UNMAKE_THUMB_ADDR
argument_list|(
name|pc
argument_list|)
else|:
name|pc
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return the frame address.  On ARM, it is R11; on Thumb it is R7.    Examine the Program Status Register to decide which state we're in.  */
end_comment

begin_function
name|CORE_ADDR
name|arm_target_read_fp
parameter_list|()
block|{
if|if
condition|(
name|read_register
argument_list|(
name|PS_REGNUM
argument_list|)
operator|&
literal|0x20
condition|)
comment|/* Bit 5 is Thumb state bit */
return|return
name|read_register
argument_list|(
name|THUMB_FP_REGNUM
argument_list|)
return|;
comment|/* R7 if Thumb */
else|else
return|return
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
return|;
comment|/* R11 if ARM */
block|}
end_function

begin_comment
comment|/* Calculate the frame offsets of the saved registers (ARM version). */
end_comment

begin_function
name|void
name|arm_frame_find_saved_regs
parameter_list|(
name|fi
parameter_list|,
name|regaddr
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|struct
name|frame_saved_regs
modifier|*
name|regaddr
decl_stmt|;
block|{
name|memcpy
argument_list|(
name|regaddr
argument_list|,
operator|&
name|fi
operator|->
name|fsr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|frame_saved_regs
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arm_push_dummy_frame
parameter_list|()
block|{
name|CORE_ADDR
name|old_sp
init|=
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|sp
init|=
name|old_sp
decl_stmt|;
name|CORE_ADDR
name|fp
decl_stmt|,
name|prologue_start
decl_stmt|;
name|int
name|regnum
decl_stmt|;
comment|/* Push the two dummy prologue instructions in reverse order,      so that they'll be in the correct low-to-high order in memory.  */
comment|/* sub     fp, ip, #4 */
name|sp
operator|=
name|push_word
argument_list|(
name|sp
argument_list|,
literal|0xe24cb004
argument_list|)
expr_stmt|;
comment|/*  stmdb   sp!, {r0-r10, fp, ip, lr, pc} */
name|prologue_start
operator|=
name|sp
operator|=
name|push_word
argument_list|(
name|sp
argument_list|,
literal|0xe92ddfff
argument_list|)
expr_stmt|;
comment|/* push a pointer to the dummy prologue + 12, because when      stm instruction stores the PC, it stores the address of the stm      instruction itself plus 12.  */
name|fp
operator|=
name|sp
operator|=
name|push_word
argument_list|(
name|sp
argument_list|,
name|prologue_start
operator|+
literal|12
argument_list|)
expr_stmt|;
name|sp
operator|=
name|push_word
argument_list|(
name|sp
argument_list|,
name|read_register
argument_list|(
name|PC_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FIXME: was PS_REGNUM */
name|sp
operator|=
name|push_word
argument_list|(
name|sp
argument_list|,
name|old_sp
argument_list|)
expr_stmt|;
name|sp
operator|=
name|push_word
argument_list|(
name|sp
argument_list|,
name|read_register
argument_list|(
name|FP_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|regnum
operator|=
literal|10
init|;
name|regnum
operator|>=
literal|0
condition|;
name|regnum
operator|--
control|)
name|sp
operator|=
name|push_word
argument_list|(
name|sp
argument_list|,
name|read_register
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|FP_REGNUM
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|THUMB_FP_REGNUM
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fix up the call dummy, based on whether the processor is currently    in Thumb or ARM mode, and whether the target function is Thumb    or ARM.  There are three different situations requiring three    different dummies:     * ARM calling ARM: uses the call dummy in tm-arm.h, which has already      been copied into the dummy parameter to this function.    * ARM calling Thumb: uses the call dummy in tm-arm.h, but with the      "mov pc,r4" instruction patched to be a "bx r4" instead.    * Thumb calling anything: uses the Thumb dummy defined below, which      works for calling both ARM and Thumb functions.     All three call dummies expect to receive the target function address    in R4, with the low bit set if it's a Thumb function. */
end_comment

begin_function
name|void
name|arm_fix_call_dummy
parameter_list|(
name|dummy
parameter_list|,
name|pc
parameter_list|,
name|fun
parameter_list|,
name|nargs
parameter_list|,
name|args
parameter_list|,
name|type
parameter_list|,
name|gcc_p
parameter_list|)
name|char
modifier|*
name|dummy
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
name|CORE_ADDR
name|fun
decl_stmt|;
name|int
name|nargs
decl_stmt|;
name|value_ptr
modifier|*
name|args
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|gcc_p
decl_stmt|;
block|{
specifier|static
name|short
name|thumb_dummy
index|[
literal|4
index|]
init|=
block|{
literal|0xf000
block|,
literal|0xf801
block|,
comment|/*	  bl      label */
literal|0xdf18
block|,
comment|/*	  swi     24 */
literal|0x4720
block|,
comment|/* label: bx	  r4 */
block|}
decl_stmt|;
specifier|static
name|unsigned
name|long
name|arm_bx_r4
init|=
literal|0xe12fff14
decl_stmt|;
comment|/* bx r4 instruction */
comment|/* Set flag indicating whether the current PC is in a Thumb function. */
name|caller_is_thumb
operator|=
name|arm_pc_is_thumb
argument_list|(
name|read_pc
argument_list|()
argument_list|)
expr_stmt|;
comment|/* If the target function is Thumb, set the low bit of the function address.      And if the CPU is currently in ARM mode, patch the second instruction      of call dummy to use a BX instruction to switch to Thumb mode.  */
name|target_is_thumb
operator|=
name|arm_pc_is_thumb
argument_list|(
name|fun
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_is_thumb
condition|)
block|{
name|fun
operator||=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|caller_is_thumb
condition|)
name|store_unsigned_integer
argument_list|(
name|dummy
operator|+
literal|4
argument_list|,
sizeof|sizeof
argument_list|(
name|arm_bx_r4
argument_list|)
argument_list|,
name|arm_bx_r4
argument_list|)
expr_stmt|;
block|}
comment|/* If the CPU is currently in Thumb mode, use the Thumb call dummy      instead of the ARM one that's already been copied.  This will      work for both Thumb and ARM target functions.  */
if|if
condition|(
name|caller_is_thumb
condition|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|dummy
decl_stmt|;
name|int
name|len
init|=
sizeof|sizeof
argument_list|(
name|thumb_dummy
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|thumb_dummy
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|store_unsigned_integer
argument_list|(
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|thumb_dummy
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|thumb_dummy
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|thumb_dummy
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Put the target address in r4; the call dummy will copy this to the PC. */
name|write_register
argument_list|(
literal|4
argument_list|,
name|fun
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the offset in the call dummy of the instruction that needs    to have a breakpoint placed on it.  This is the offset of the 'swi 24'    instruction, which is no longer actually used, but simply acts    as a place-holder now.     This implements the CALL_DUMMY_BREAK_OFFSET macro. */
end_comment

begin_function
name|int
name|arm_call_dummy_breakpoint_offset
parameter_list|()
block|{
if|if
condition|(
name|caller_is_thumb
condition|)
return|return
literal|4
return|;
else|else
return|return
literal|8
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|arm_push_arguments
parameter_list|(
name|nargs
parameter_list|,
name|args
parameter_list|,
name|sp
parameter_list|,
name|struct_return
parameter_list|,
name|struct_addr
parameter_list|)
name|int
name|nargs
decl_stmt|;
name|value_ptr
modifier|*
name|args
decl_stmt|;
name|CORE_ADDR
name|sp
decl_stmt|;
name|int
name|struct_return
decl_stmt|;
name|CORE_ADDR
name|struct_addr
decl_stmt|;
block|{
name|int
name|argreg
decl_stmt|;
name|int
name|float_argreg
decl_stmt|;
name|int
name|argnum
decl_stmt|;
name|int
name|stack_offset
decl_stmt|;
struct|struct
name|stack_arg
block|{
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|}
struct|;
name|struct
name|stack_arg
modifier|*
name|stack_args
init|=
operator|(
expr|struct
name|stack_arg
operator|*
operator|)
name|alloca
argument_list|(
name|nargs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|stack_arg
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|nstack_args
init|=
literal|0
decl_stmt|;
comment|/* Initialize the integer and float register pointers.  */
name|argreg
operator|=
name|A1_REGNUM
expr_stmt|;
name|float_argreg
operator|=
name|F0_REGNUM
expr_stmt|;
comment|/* the struct_return pointer occupies the first parameter-passing reg */
if|if
condition|(
name|struct_return
condition|)
name|write_register
argument_list|(
name|argreg
operator|++
argument_list|,
name|struct_addr
argument_list|)
expr_stmt|;
comment|/* The offset onto the stack at which we will start copying parameters      (after the registers are used up) begins at 16 in the old ABI.      This leaves room for the "home" area for register parameters.  */
name|stack_offset
operator|=
name|REGISTER_SIZE
operator|*
literal|4
expr_stmt|;
comment|/* Process args from left to right.  Store as many as allowed in 	registers, save the rest to be pushed on the stack */
for|for
control|(
name|argnum
operator|=
literal|0
init|;
name|argnum
operator|<
name|nargs
condition|;
name|argnum
operator|++
control|)
block|{
name|char
modifier|*
name|val
decl_stmt|;
name|value_ptr
name|arg
init|=
name|args
index|[
name|argnum
index|]
decl_stmt|;
name|struct
name|type
modifier|*
name|arg_type
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|target_type
init|=
name|TYPE_TARGET_TYPE
argument_list|(
name|arg_type
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|arg_type
argument_list|)
decl_stmt|;
name|enum
name|type_code
name|typecode
init|=
name|TYPE_CODE
argument_list|(
name|arg_type
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|regval
decl_stmt|;
name|int
name|newarg
decl_stmt|;
name|val
operator|=
operator|(
name|char
operator|*
operator|)
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* If the argument is a pointer to a function, and it's a Thumb          function, set the low bit of the pointer.  */
if|if
condition|(
name|typecode
operator|==
name|TYPE_CODE_PTR
operator|&&
name|target_type
operator|!=
name|NULL
operator|&&
name|TYPE_CODE
argument_list|(
name|target_type
argument_list|)
operator|==
name|TYPE_CODE_FUNC
condition|)
block|{
name|regval
operator|=
name|extract_address
argument_list|(
name|val
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|arm_pc_is_thumb
argument_list|(
name|regval
argument_list|)
condition|)
name|store_address
argument_list|(
name|val
argument_list|,
name|len
argument_list|,
name|MAKE_THUMB_ADDR
argument_list|(
name|regval
argument_list|)
argument_list|)
expr_stmt|;
block|}
define|#
directive|define
name|MAPCS_FLOAT
value|0
comment|/* --mapcs-float not implemented by the compiler yet */
if|#
directive|if
name|MAPCS_FLOAT
comment|/* Up to four floating point arguments can be passed in floating          point registers on ARM (not on Thumb).  */
if|if
condition|(
name|typecode
operator|==
name|TYPE_CODE_FLT
operator|&&
name|float_argreg
operator|<=
name|ARM_LAST_FP_ARG_REGNUM
operator|&&
operator|!
name|target_is_thumb
condition|)
block|{
comment|/* This is a floating point value that fits entirely 	     in a single register.  */
name|regval
operator|=
name|extract_address
argument_list|(
name|val
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|float_argreg
operator|++
argument_list|,
name|regval
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
comment|/* Copy the argument to general registers or the stack in 	     register-sized pieces.  Large arguments are split between 	     registers and stack.  */
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|argreg
operator|<=
name|ARM_LAST_ARG_REGNUM
condition|)
block|{
name|int
name|partial_len
init|=
name|len
operator|<
name|REGISTER_SIZE
condition|?
name|len
else|:
name|REGISTER_SIZE
decl_stmt|;
name|regval
operator|=
name|extract_address
argument_list|(
name|val
argument_list|,
name|partial_len
argument_list|)
expr_stmt|;
comment|/* It's a simple argument being passed in a general 		     register.  */
name|write_register
argument_list|(
name|argreg
argument_list|,
name|regval
argument_list|)
expr_stmt|;
name|argreg
operator|++
expr_stmt|;
name|len
operator|-=
name|partial_len
expr_stmt|;
name|val
operator|+=
name|partial_len
expr_stmt|;
block|}
else|else
block|{
comment|/* keep for later pushing */
name|stack_args
index|[
name|nstack_args
index|]
operator|.
name|val
operator|=
name|val
expr_stmt|;
name|stack_args
index|[
name|nstack_args
operator|++
index|]
operator|.
name|len
operator|=
name|len
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/* now do the real stack pushing, process args right to left */
while|while
condition|(
name|nstack_args
operator|--
condition|)
block|{
name|sp
operator|-=
name|stack_args
index|[
name|nstack_args
index|]
operator|.
name|len
expr_stmt|;
name|write_memory
argument_list|(
name|sp
argument_list|,
name|stack_args
index|[
name|nstack_args
index|]
operator|.
name|val
argument_list|,
name|stack_args
index|[
name|nstack_args
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* Return adjusted stack pointer.  */
return|return
name|sp
return|;
block|}
end_function

begin_function
name|void
name|arm_pop_frame
parameter_list|()
block|{
name|struct
name|frame_info
modifier|*
name|frame
init|=
name|get_current_frame
argument_list|()
decl_stmt|;
name|int
name|regnum
decl_stmt|;
for|for
control|(
name|regnum
operator|=
literal|0
init|;
name|regnum
operator|<
name|NUM_REGS
condition|;
name|regnum
operator|++
control|)
if|if
condition|(
name|frame
operator|->
name|fsr
operator|.
name|regs
index|[
name|regnum
index|]
operator|!=
literal|0
condition|)
name|write_register
argument_list|(
name|regnum
argument_list|,
name|read_memory_integer
argument_list|(
name|frame
operator|->
name|fsr
operator|.
name|regs
index|[
name|regnum
index|]
argument_list|,
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|PC_REGNUM
argument_list|,
name|FRAME_SAVED_PC
argument_list|(
name|frame
argument_list|)
argument_list|)
expr_stmt|;
name|write_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|read_register
argument_list|(
name|frame
operator|->
name|framereg
argument_list|)
argument_list|)
expr_stmt|;
name|flush_cached_frames
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_fpu_flags
parameter_list|(
name|flags
parameter_list|)
name|int
name|flags
decl_stmt|;
block|{
if|if
condition|(
name|flags
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
condition|)
name|fputs
argument_list|(
literal|"IVO "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
condition|)
name|fputs
argument_list|(
literal|"DVZ "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
literal|1
operator|<<
literal|2
operator|)
condition|)
name|fputs
argument_list|(
literal|"OFL "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
literal|1
operator|<<
literal|3
operator|)
condition|)
name|fputs
argument_list|(
literal|"UFL "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
literal|1
operator|<<
literal|4
operator|)
condition|)
name|fputs
argument_list|(
literal|"INX "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arm_float_info
parameter_list|()
block|{
specifier|register
name|unsigned
name|long
name|status
init|=
name|read_register
argument_list|(
name|FPS_REGNUM
argument_list|)
decl_stmt|;
name|int
name|type
decl_stmt|;
name|type
operator|=
operator|(
name|status
operator|>>
literal|24
operator|)
operator|&
literal|127
expr_stmt|;
name|printf
argument_list|(
literal|"%s FPU type %d\n"
argument_list|,
operator|(
name|status
operator|&
operator|(
literal|1
operator|<<
literal|31
operator|)
operator|)
condition|?
literal|"Hardware"
else|:
literal|"Software"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"mask: "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|print_fpu_flags
argument_list|(
name|status
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"flags: "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|print_fpu_flags
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|original_register_names
index|[]
init|=
block|{
literal|"a1"
block|,
literal|"a2"
block|,
literal|"a3"
block|,
literal|"a4"
block|,
comment|/*  0  1  2  3 */
literal|"v1"
block|,
literal|"v2"
block|,
literal|"v3"
block|,
literal|"v4"
block|,
comment|/*  4  5  6  7 */
literal|"v5"
block|,
literal|"v6"
block|,
literal|"sl"
block|,
literal|"fp"
block|,
comment|/*  8  9 10 11 */
literal|"ip"
block|,
literal|"sp"
block|,
literal|"lr"
block|,
literal|"pc"
block|,
comment|/* 12 13 14 15 */
literal|"f0"
block|,
literal|"f1"
block|,
literal|"f2"
block|,
literal|"f3"
block|,
comment|/* 16 17 18 19 */
literal|"f4"
block|,
literal|"f5"
block|,
literal|"f6"
block|,
literal|"f7"
block|,
comment|/* 20 21 22 23 */
literal|"fps"
block|,
literal|"ps"
block|}
comment|/* 24 25       */
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These names are the ones which gcc emits, and     I find them less confusing.  Toggle between them    using the `othernames' command. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|additional_register_names
index|[]
init|=
block|{
literal|"r0"
block|,
literal|"r1"
block|,
literal|"r2"
block|,
literal|"r3"
block|,
comment|/*  0  1  2  3 */
literal|"r4"
block|,
literal|"r5"
block|,
literal|"r6"
block|,
literal|"r7"
block|,
comment|/*  4  5  6  7 */
literal|"r8"
block|,
literal|"r9"
block|,
literal|"sl"
block|,
literal|"fp"
block|,
comment|/*  8  9 10 11 */
literal|"ip"
block|,
literal|"sp"
block|,
literal|"lr"
block|,
literal|"pc"
block|,
comment|/* 12 13 14 15 */
literal|"f0"
block|,
literal|"f1"
block|,
literal|"f2"
block|,
literal|"f3"
block|,
comment|/* 16 17 18 19 */
literal|"f4"
block|,
literal|"f5"
block|,
literal|"f6"
block|,
literal|"f7"
block|,
comment|/* 20 21 22 23 */
literal|"fps"
block|,
literal|"ps"
block|}
comment|/* 24 25       */
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|arm_register_names
init|=
name|original_register_names
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|arm_othernames
parameter_list|()
block|{
specifier|static
name|int
name|toggle
decl_stmt|;
name|arm_register_names
operator|=
operator|(
name|toggle
condition|?
name|additional_register_names
else|:
name|original_register_names
operator|)
expr_stmt|;
name|toggle
operator|=
operator|!
name|toggle
expr_stmt|;
block|}
end_function

begin_comment
comment|/* FIXME:  Fill in with the 'right thing', see asm     template in arm-convert.s */
end_comment

begin_function
name|void
name|convert_from_extended
parameter_list|(
name|ptr
parameter_list|,
name|dbl
parameter_list|)
name|void
modifier|*
name|ptr
decl_stmt|;
name|double
modifier|*
name|dbl
decl_stmt|;
block|{
operator|*
name|dbl
operator|=
operator|*
operator|(
name|double
operator|*
operator|)
name|ptr
expr_stmt|;
block|}
end_function

begin_function
name|void
name|convert_to_extended
parameter_list|(
name|dbl
parameter_list|,
name|ptr
parameter_list|)
name|void
modifier|*
name|ptr
decl_stmt|;
name|double
modifier|*
name|dbl
decl_stmt|;
block|{
operator|*
operator|(
name|double
operator|*
operator|)
name|ptr
operator|=
operator|*
name|dbl
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|condition_true
parameter_list|(
name|cond
parameter_list|,
name|status_reg
parameter_list|)
name|unsigned
name|long
name|cond
decl_stmt|;
name|unsigned
name|long
name|status_reg
decl_stmt|;
block|{
if|if
condition|(
name|cond
operator|==
name|INST_AL
operator|||
name|cond
operator|==
name|INST_NV
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|cond
condition|)
block|{
case|case
name|INST_EQ
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_Z
operator|)
operator|!=
literal|0
operator|)
return|;
case|case
name|INST_NE
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_Z
operator|)
operator|==
literal|0
operator|)
return|;
case|case
name|INST_CS
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_C
operator|)
operator|!=
literal|0
operator|)
return|;
case|case
name|INST_CC
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_C
operator|)
operator|==
literal|0
operator|)
return|;
case|case
name|INST_MI
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_N
operator|)
operator|!=
literal|0
operator|)
return|;
case|case
name|INST_PL
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_N
operator|)
operator|==
literal|0
operator|)
return|;
case|case
name|INST_VS
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_V
operator|)
operator|!=
literal|0
operator|)
return|;
case|case
name|INST_VC
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_V
operator|)
operator|==
literal|0
operator|)
return|;
case|case
name|INST_HI
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
operator|(
name|FLAG_C
operator||
name|FLAG_Z
operator|)
operator|)
operator|==
name|FLAG_C
operator|)
return|;
case|case
name|INST_LS
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
operator|(
name|FLAG_C
operator||
name|FLAG_Z
operator|)
operator|)
operator|!=
name|FLAG_C
operator|)
return|;
case|case
name|INST_GE
case|:
return|return
operator|(
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_N
operator|)
operator|==
literal|0
operator|)
operator|==
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_V
operator|)
operator|==
literal|0
operator|)
operator|)
return|;
case|case
name|INST_LT
case|:
return|return
operator|(
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_N
operator|)
operator|==
literal|0
operator|)
operator|!=
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_V
operator|)
operator|==
literal|0
operator|)
operator|)
return|;
case|case
name|INST_GT
case|:
return|return
operator|(
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_Z
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_N
operator|)
operator|==
literal|0
operator|)
operator|==
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_V
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
return|;
case|case
name|INST_LE
case|:
return|return
operator|(
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_Z
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_N
operator|)
operator|==
literal|0
operator|)
operator|!=
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_V
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|submask
parameter_list|(
name|x
parameter_list|)
value|((1L<< ((x) + 1)) - 1)
end_define

begin_define
define|#
directive|define
name|bit
parameter_list|(
name|obj
parameter_list|,
name|st
parameter_list|)
value|(((obj)>> (st))& 1)
end_define

begin_define
define|#
directive|define
name|bits
parameter_list|(
name|obj
parameter_list|,
name|st
parameter_list|,
name|fn
parameter_list|)
value|(((obj)>> (st))& submask ((fn) - (st)))
end_define

begin_define
define|#
directive|define
name|sbits
parameter_list|(
name|obj
parameter_list|,
name|st
parameter_list|,
name|fn
parameter_list|)
define|\
value|((long) (bits(obj,st,fn) | ((long) bit(obj,fn) * ~ submask (fn - st))))
end_define

begin_define
define|#
directive|define
name|BranchDest
parameter_list|(
name|addr
parameter_list|,
name|instr
parameter_list|)
define|\
value|((CORE_ADDR) (((long) (addr)) + 8 + (sbits (instr, 0, 23)<< 2)))
end_define

begin_define
define|#
directive|define
name|ARM_PC_32
value|1
end_define

begin_function
specifier|static
name|unsigned
name|long
name|shifted_reg_val
parameter_list|(
name|inst
parameter_list|,
name|carry
parameter_list|,
name|pc_val
parameter_list|,
name|status_reg
parameter_list|)
name|unsigned
name|long
name|inst
decl_stmt|;
name|int
name|carry
decl_stmt|;
name|unsigned
name|long
name|pc_val
decl_stmt|;
name|unsigned
name|long
name|status_reg
decl_stmt|;
block|{
name|unsigned
name|long
name|res
decl_stmt|,
name|shift
decl_stmt|;
name|int
name|rm
init|=
name|bits
argument_list|(
name|inst
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|shifttype
init|=
name|bits
argument_list|(
name|inst
argument_list|,
literal|5
argument_list|,
literal|6
argument_list|)
decl_stmt|;
if|if
condition|(
name|bit
argument_list|(
name|inst
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|int
name|rs
init|=
name|bits
argument_list|(
name|inst
argument_list|,
literal|8
argument_list|,
literal|11
argument_list|)
decl_stmt|;
name|shift
operator|=
operator|(
name|rs
operator|==
literal|15
condition|?
name|pc_val
operator|+
literal|8
else|:
name|read_register
argument_list|(
name|rs
argument_list|)
operator|)
operator|&
literal|0xFF
expr_stmt|;
block|}
else|else
name|shift
operator|=
name|bits
argument_list|(
name|inst
argument_list|,
literal|7
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|res
operator|=
operator|(
name|rm
operator|==
literal|15
condition|?
operator|(
operator|(
name|pc_val
operator||
operator|(
name|ARM_PC_32
condition|?
literal|0
else|:
name|status_reg
operator|)
operator|)
operator|+
operator|(
name|bit
argument_list|(
name|inst
argument_list|,
literal|4
argument_list|)
condition|?
literal|12
else|:
literal|8
operator|)
operator|)
else|:
name|read_register
argument_list|(
name|rm
argument_list|)
operator|)
expr_stmt|;
switch|switch
condition|(
name|shifttype
condition|)
block|{
case|case
literal|0
case|:
comment|/* LSL */
name|res
operator|=
name|shift
operator|>=
literal|32
condition|?
literal|0
else|:
name|res
operator|<<
name|shift
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* LSR */
name|res
operator|=
name|shift
operator|>=
literal|32
condition|?
literal|0
else|:
name|res
operator|>>
name|shift
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* ASR */
if|if
condition|(
name|shift
operator|>=
literal|32
condition|)
name|shift
operator|=
literal|31
expr_stmt|;
name|res
operator|=
operator|(
operator|(
name|res
operator|&
literal|0x80000000L
operator|)
condition|?
operator|~
operator|(
operator|(
operator|~
name|res
operator|)
operator|>>
name|shift
operator|)
else|:
name|res
operator|>>
name|shift
operator|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* ROR/RRX */
name|shift
operator|&=
literal|31
expr_stmt|;
if|if
condition|(
name|shift
operator|==
literal|0
condition|)
name|res
operator|=
operator|(
name|res
operator|>>
literal|1
operator|)
operator||
operator|(
name|carry
condition|?
literal|0x80000000L
else|:
literal|0
operator|)
expr_stmt|;
else|else
name|res
operator|=
operator|(
name|res
operator|>>
name|shift
operator|)
operator||
operator|(
name|res
operator|<<
operator|(
literal|32
operator|-
name|shift
operator|)
operator|)
expr_stmt|;
break|break;
block|}
return|return
name|res
operator|&
literal|0xffffffff
return|;
block|}
end_function

begin_comment
comment|/* Return number of 1-bits in VAL.  */
end_comment

begin_function
specifier|static
name|int
name|bitcount
parameter_list|(
name|val
parameter_list|)
name|unsigned
name|long
name|val
decl_stmt|;
block|{
name|int
name|nbits
decl_stmt|;
for|for
control|(
name|nbits
operator|=
literal|0
init|;
name|val
operator|!=
literal|0
condition|;
name|nbits
operator|++
control|)
name|val
operator|&=
name|val
operator|-
literal|1
expr_stmt|;
comment|/* delete rightmost 1-bit in val */
return|return
name|nbits
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|thumb_get_next_pc
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
name|unsigned
name|long
name|pc_val
init|=
operator|(
operator|(
name|unsigned
name|long
operator|)
name|pc
operator|)
operator|+
literal|4
decl_stmt|;
comment|/* PC after prefetch */
name|unsigned
name|short
name|inst1
init|=
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|nextpc
init|=
name|pc
operator|+
literal|2
decl_stmt|;
comment|/* default is next instruction */
name|unsigned
name|long
name|offset
decl_stmt|;
if|if
condition|(
operator|(
name|inst1
operator|&
literal|0xff00
operator|)
operator|==
literal|0xbd00
condition|)
comment|/* pop {rlist, pc} */
block|{
name|CORE_ADDR
name|sp
decl_stmt|;
comment|/* Fetch the saved PC from the stack.  It's stored above          all of the other registers.  */
name|offset
operator|=
name|bitcount
argument_list|(
name|bits
argument_list|(
name|inst1
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|)
argument_list|)
operator|*
name|REGISTER_SIZE
expr_stmt|;
name|sp
operator|=
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
expr_stmt|;
name|nextpc
operator|=
operator|(
name|CORE_ADDR
operator|)
name|read_memory_integer
argument_list|(
name|sp
operator|+
name|offset
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|nextpc
operator|=
name|ADDR_BITS_REMOVE
argument_list|(
name|nextpc
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextpc
operator|==
name|pc
condition|)
name|error
argument_list|(
literal|"Infinite loop detected"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|inst1
operator|&
literal|0xf000
operator|)
operator|==
literal|0xd000
condition|)
comment|/* conditional branch */
block|{
name|unsigned
name|long
name|status
init|=
name|read_register
argument_list|(
name|PS_REGNUM
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|cond
init|=
name|bits
argument_list|(
name|inst1
argument_list|,
literal|8
argument_list|,
literal|11
argument_list|)
decl_stmt|;
if|if
condition|(
name|cond
operator|!=
literal|0x0f
operator|&&
name|condition_true
argument_list|(
name|cond
argument_list|,
name|status
argument_list|)
condition|)
comment|/* 0x0f = SWI */
name|nextpc
operator|=
name|pc_val
operator|+
operator|(
name|sbits
argument_list|(
name|inst1
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|)
operator|<<
literal|1
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|inst1
operator|&
literal|0xf800
operator|)
operator|==
literal|0xe000
condition|)
comment|/* unconditional branch */
block|{
name|nextpc
operator|=
name|pc_val
operator|+
operator|(
name|sbits
argument_list|(
name|inst1
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
operator|<<
literal|1
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|inst1
operator|&
literal|0xf800
operator|)
operator|==
literal|0xf000
condition|)
comment|/* long branch with link */
block|{
name|unsigned
name|short
name|inst2
init|=
name|read_memory_integer
argument_list|(
name|pc
operator|+
literal|2
argument_list|,
literal|2
argument_list|)
decl_stmt|;
name|offset
operator|=
operator|(
name|sbits
argument_list|(
name|inst1
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
operator|<<
literal|12
operator|)
operator|+
operator|(
name|bits
argument_list|(
name|inst2
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
operator|<<
literal|1
operator|)
expr_stmt|;
name|nextpc
operator|=
name|pc_val
operator|+
name|offset
expr_stmt|;
block|}
return|return
name|nextpc
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|arm_get_next_pc
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
name|unsigned
name|long
name|pc_val
decl_stmt|;
name|unsigned
name|long
name|this_instr
decl_stmt|;
name|unsigned
name|long
name|status
decl_stmt|;
name|CORE_ADDR
name|nextpc
decl_stmt|;
if|if
condition|(
name|arm_pc_is_thumb
argument_list|(
name|pc
argument_list|)
condition|)
return|return
name|thumb_get_next_pc
argument_list|(
name|pc
argument_list|)
return|;
name|pc_val
operator|=
operator|(
name|unsigned
name|long
operator|)
name|pc
expr_stmt|;
name|this_instr
operator|=
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|status
operator|=
name|read_register
argument_list|(
name|PS_REGNUM
argument_list|)
expr_stmt|;
name|nextpc
operator|=
call|(
name|CORE_ADDR
call|)
argument_list|(
name|pc_val
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* Default case */
if|if
condition|(
name|condition_true
argument_list|(
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|28
argument_list|,
literal|31
argument_list|)
argument_list|,
name|status
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|24
argument_list|,
literal|27
argument_list|)
condition|)
block|{
case|case
literal|0x0
case|:
case|case
literal|0x1
case|:
comment|/* data processing */
case|case
literal|0x2
case|:
case|case
literal|0x3
case|:
block|{
name|unsigned
name|long
name|operand1
decl_stmt|,
name|operand2
decl_stmt|,
name|result
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|rn
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|12
argument_list|,
literal|15
argument_list|)
operator|!=
literal|15
condition|)
break|break;
if|if
condition|(
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|22
argument_list|,
literal|25
argument_list|)
operator|==
literal|0
operator|&&
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|4
argument_list|,
literal|7
argument_list|)
operator|==
literal|9
condition|)
comment|/* multiply */
name|error
argument_list|(
literal|"Illegal update to pc in instruction"
argument_list|)
expr_stmt|;
comment|/* Multiply into PC */
name|c
operator|=
operator|(
name|status
operator|&
name|FLAG_C
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|rn
operator|=
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|16
argument_list|,
literal|19
argument_list|)
expr_stmt|;
name|operand1
operator|=
operator|(
name|rn
operator|==
literal|15
operator|)
condition|?
name|pc_val
operator|+
literal|8
else|:
name|read_register
argument_list|(
name|rn
argument_list|)
expr_stmt|;
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|25
argument_list|)
condition|)
block|{
name|unsigned
name|long
name|immval
init|=
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|rotate
init|=
literal|2
operator|*
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|8
argument_list|,
literal|11
argument_list|)
decl_stmt|;
name|operand2
operator|=
operator|(
operator|(
name|immval
operator|>>
name|rotate
operator|)
operator||
operator|(
name|immval
operator|<<
operator|(
literal|32
operator|-
name|rotate
operator|)
operator|)
operator|)
operator|&
literal|0xffffffff
expr_stmt|;
block|}
else|else
comment|/* operand 2 is a shifted register */
name|operand2
operator|=
name|shifted_reg_val
argument_list|(
name|this_instr
argument_list|,
name|c
argument_list|,
name|pc_val
argument_list|,
name|status
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|21
argument_list|,
literal|24
argument_list|)
condition|)
block|{
case|case
literal|0x0
case|:
comment|/*and*/
name|result
operator|=
name|operand1
operator|&
name|operand2
expr_stmt|;
break|break;
case|case
literal|0x1
case|:
comment|/*eor*/
name|result
operator|=
name|operand1
operator|^
name|operand2
expr_stmt|;
break|break;
case|case
literal|0x2
case|:
comment|/*sub*/
name|result
operator|=
name|operand1
operator|-
name|operand2
expr_stmt|;
break|break;
case|case
literal|0x3
case|:
comment|/*rsb*/
name|result
operator|=
name|operand2
operator|-
name|operand1
expr_stmt|;
break|break;
case|case
literal|0x4
case|:
comment|/*add*/
name|result
operator|=
name|operand1
operator|+
name|operand2
expr_stmt|;
break|break;
case|case
literal|0x5
case|:
comment|/*adc*/
name|result
operator|=
name|operand1
operator|+
name|operand2
operator|+
name|c
expr_stmt|;
break|break;
case|case
literal|0x6
case|:
comment|/*sbc*/
name|result
operator|=
name|operand1
operator|-
name|operand2
operator|+
name|c
expr_stmt|;
break|break;
case|case
literal|0x7
case|:
comment|/*rsc*/
name|result
operator|=
name|operand2
operator|-
name|operand1
operator|+
name|c
expr_stmt|;
break|break;
case|case
literal|0x8
case|:
case|case
literal|0x9
case|:
case|case
literal|0xa
case|:
case|case
literal|0xb
case|:
comment|/* tst, teq, cmp, cmn */
name|result
operator|=
operator|(
name|unsigned
name|long
operator|)
name|nextpc
expr_stmt|;
break|break;
case|case
literal|0xc
case|:
comment|/*orr*/
name|result
operator|=
name|operand1
operator||
name|operand2
expr_stmt|;
break|break;
case|case
literal|0xd
case|:
comment|/*mov*/
comment|/* Always step into a function.  */
name|result
operator|=
name|operand2
expr_stmt|;
break|break;
case|case
literal|0xe
case|:
comment|/*bic*/
name|result
operator|=
name|operand1
operator|&
operator|~
name|operand2
expr_stmt|;
break|break;
case|case
literal|0xf
case|:
comment|/*mvn*/
name|result
operator|=
operator|~
name|operand2
expr_stmt|;
break|break;
block|}
name|nextpc
operator|=
operator|(
name|CORE_ADDR
operator|)
name|ADDR_BITS_REMOVE
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextpc
operator|==
name|pc
condition|)
name|error
argument_list|(
literal|"Infinite loop detected"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|0x4
case|:
case|case
literal|0x5
case|:
comment|/* data transfer */
case|case
literal|0x6
case|:
case|case
literal|0x7
case|:
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|20
argument_list|)
condition|)
block|{
comment|/* load */
if|if
condition|(
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|12
argument_list|,
literal|15
argument_list|)
operator|==
literal|15
condition|)
block|{
comment|/* rd == pc */
name|unsigned
name|long
name|rn
decl_stmt|;
name|unsigned
name|long
name|base
decl_stmt|;
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|22
argument_list|)
condition|)
name|error
argument_list|(
literal|"Illegal update to pc in instruction"
argument_list|)
expr_stmt|;
comment|/* byte write to PC */
name|rn
operator|=
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|16
argument_list|,
literal|19
argument_list|)
expr_stmt|;
name|base
operator|=
operator|(
name|rn
operator|==
literal|15
operator|)
condition|?
name|pc_val
operator|+
literal|8
else|:
name|read_register
argument_list|(
name|rn
argument_list|)
expr_stmt|;
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|24
argument_list|)
condition|)
block|{
comment|/* pre-indexed */
name|int
name|c
init|=
operator|(
name|status
operator|&
name|FLAG_C
operator|)
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|unsigned
name|long
name|offset
init|=
operator|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|25
argument_list|)
condition|?
name|shifted_reg_val
argument_list|(
name|this_instr
argument_list|,
name|c
argument_list|,
name|pc_val
argument_list|)
else|:
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|0
argument_list|,
literal|11
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|23
argument_list|)
condition|)
name|base
operator|+=
name|offset
expr_stmt|;
else|else
name|base
operator|-=
name|offset
expr_stmt|;
block|}
name|nextpc
operator|=
operator|(
name|CORE_ADDR
operator|)
name|read_memory_integer
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|base
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|nextpc
operator|=
name|ADDR_BITS_REMOVE
argument_list|(
name|nextpc
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextpc
operator|==
name|pc
condition|)
name|error
argument_list|(
literal|"Infinite loop detected"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|0x8
case|:
case|case
literal|0x9
case|:
comment|/* block transfer */
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|20
argument_list|)
condition|)
block|{
comment|/* LDM */
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|15
argument_list|)
condition|)
block|{
comment|/* loading pc */
name|int
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|23
argument_list|)
condition|)
block|{
comment|/* up */
name|unsigned
name|long
name|reglist
init|=
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|0
argument_list|,
literal|14
argument_list|)
decl_stmt|;
name|offset
operator|=
name|bitcount
argument_list|(
name|reglist
argument_list|)
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|24
argument_list|)
condition|)
comment|/* pre */
name|offset
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|24
argument_list|)
condition|)
name|offset
operator|=
operator|-
literal|4
expr_stmt|;
block|{
name|unsigned
name|long
name|rn_val
init|=
name|read_register
argument_list|(
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|16
argument_list|,
literal|19
argument_list|)
argument_list|)
decl_stmt|;
name|nextpc
operator|=
operator|(
name|CORE_ADDR
operator|)
name|read_memory_integer
argument_list|(
call|(
name|CORE_ADDR
call|)
argument_list|(
name|rn_val
operator|+
name|offset
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|nextpc
operator|=
name|ADDR_BITS_REMOVE
argument_list|(
name|nextpc
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextpc
operator|==
name|pc
condition|)
name|error
argument_list|(
literal|"Infinite loop detected"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|0xb
case|:
comment|/* branch& link */
case|case
literal|0xa
case|:
comment|/* branch */
block|{
name|nextpc
operator|=
name|BranchDest
argument_list|(
name|pc
argument_list|,
name|this_instr
argument_list|)
expr_stmt|;
name|nextpc
operator|=
name|ADDR_BITS_REMOVE
argument_list|(
name|nextpc
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextpc
operator|==
name|pc
condition|)
name|error
argument_list|(
literal|"Infinite loop detected"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|0xc
case|:
case|case
literal|0xd
case|:
case|case
literal|0xe
case|:
comment|/* coproc ops */
case|case
literal|0xf
case|:
comment|/* SWI */
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad bit-field extraction\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|pc
operator|)
return|;
block|}
block|}
return|return
name|nextpc
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"bfd-in2.h"
end_include

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_function
specifier|static
name|int
name|gdb_print_insn_arm
parameter_list|(
name|memaddr
parameter_list|,
name|info
parameter_list|)
name|bfd_vma
name|memaddr
decl_stmt|;
name|disassemble_info
modifier|*
name|info
decl_stmt|;
block|{
if|if
condition|(
name|arm_pc_is_thumb
argument_list|(
name|memaddr
argument_list|)
condition|)
block|{
specifier|static
name|asymbol
modifier|*
name|asym
decl_stmt|;
specifier|static
name|combined_entry_type
name|ce
decl_stmt|;
specifier|static
name|struct
name|coff_symbol_struct
name|csym
decl_stmt|;
specifier|static
name|struct
name|_bfd
name|fake_bfd
decl_stmt|;
specifier|static
name|bfd_target
name|fake_target
decl_stmt|;
if|if
condition|(
name|csym
operator|.
name|native
operator|==
name|NULL
condition|)
block|{
comment|/* Create a fake symbol vector containing a Thumb symbol.  This is 	     solely so that the code in print_insn_little_arm() and 	     print_insn_big_arm() in opcodes/arm-dis.c will detect the presence 	     of a Thumb symbol and switch to decoding Thumb instructions.  */
name|fake_target
operator|.
name|flavour
operator|=
name|bfd_target_coff_flavour
expr_stmt|;
name|fake_bfd
operator|.
name|xvec
operator|=
operator|&
name|fake_target
expr_stmt|;
name|ce
operator|.
name|u
operator|.
name|syment
operator|.
name|n_sclass
operator|=
name|C_THUMBEXTFUNC
expr_stmt|;
name|csym
operator|.
name|native
operator|=
operator|&
name|ce
expr_stmt|;
name|csym
operator|.
name|symbol
operator|.
name|the_bfd
operator|=
operator|&
name|fake_bfd
expr_stmt|;
name|csym
operator|.
name|symbol
operator|.
name|name
operator|=
literal|"fake"
expr_stmt|;
name|asym
operator|=
operator|(
name|asymbol
operator|*
operator|)
operator|&
name|csym
expr_stmt|;
block|}
name|memaddr
operator|=
name|UNMAKE_THUMB_ADDR
argument_list|(
name|memaddr
argument_list|)
expr_stmt|;
name|info
operator|->
name|symbols
operator|=
operator|&
name|asym
expr_stmt|;
block|}
else|else
name|info
operator|->
name|symbols
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BIG_ENDIAN
condition|)
return|return
name|print_insn_big_arm
argument_list|(
name|memaddr
argument_list|,
name|info
argument_list|)
return|;
else|else
return|return
name|print_insn_little_arm
argument_list|(
name|memaddr
argument_list|,
name|info
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Sequence of bytes for breakpoint instruction.  */
end_comment

begin_define
define|#
directive|define
name|ARM_LE_BREAKPOINT
value|{0xFE,0xDE,0xFF,0xE7}
end_define

begin_comment
comment|/* Recognized illegal opcodes */
end_comment

begin_define
define|#
directive|define
name|ARM_BE_BREAKPOINT
value|{0xE7,0xFF,0xDE,0xFE}
end_define

begin_define
define|#
directive|define
name|THUMB_LE_BREAKPOINT
value|{0xfe,0xdf}
end_define

begin_define
define|#
directive|define
name|THUMB_BE_BREAKPOINT
value|{0xdf,0xfe}
end_define

begin_comment
comment|/* The following has been superseded by BREAKPOINT_FOR_PC, but    is defined merely to keep mem-break.c happy.  */
end_comment

begin_define
define|#
directive|define
name|LITTLE_BREAKPOINT
value|ARM_LE_BREAKPOINT
end_define

begin_define
define|#
directive|define
name|BIG_BREAKPOINT
value|ARM_BE_BREAKPOINT
end_define

begin_comment
comment|/* This function implements the BREAKPOINT_FROM_PC macro.  It uses the program    counter value to determine whether a 16- or 32-bit breakpoint should be    used.  It returns a pointer to a string of bytes that encode a breakpoint    instruction, stores the length of the string to *lenptr, and adjusts pc    (if necessary) to point to the actual memory location where the    breakpoint should be inserted.  */
end_comment

begin_function
name|unsigned
name|char
modifier|*
name|arm_breakpoint_from_pc
parameter_list|(
name|pcptr
parameter_list|,
name|lenptr
parameter_list|)
name|CORE_ADDR
modifier|*
name|pcptr
decl_stmt|;
name|int
modifier|*
name|lenptr
decl_stmt|;
block|{
if|if
condition|(
name|arm_pc_is_thumb
argument_list|(
operator|*
name|pcptr
argument_list|)
operator|||
name|arm_pc_is_thumb_dummy
argument_list|(
operator|*
name|pcptr
argument_list|)
condition|)
block|{
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BIG_ENDIAN
condition|)
block|{
specifier|static
name|char
name|thumb_breakpoint
index|[]
init|=
name|THUMB_BE_BREAKPOINT
decl_stmt|;
operator|*
name|pcptr
operator|=
name|UNMAKE_THUMB_ADDR
argument_list|(
operator|*
name|pcptr
argument_list|)
expr_stmt|;
operator|*
name|lenptr
operator|=
sizeof|sizeof
argument_list|(
name|thumb_breakpoint
argument_list|)
expr_stmt|;
return|return
name|thumb_breakpoint
return|;
block|}
else|else
block|{
specifier|static
name|char
name|thumb_breakpoint
index|[]
init|=
name|THUMB_LE_BREAKPOINT
decl_stmt|;
operator|*
name|pcptr
operator|=
name|UNMAKE_THUMB_ADDR
argument_list|(
operator|*
name|pcptr
argument_list|)
expr_stmt|;
operator|*
name|lenptr
operator|=
sizeof|sizeof
argument_list|(
name|thumb_breakpoint
argument_list|)
expr_stmt|;
return|return
name|thumb_breakpoint
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BIG_ENDIAN
condition|)
block|{
specifier|static
name|char
name|arm_breakpoint
index|[]
init|=
name|ARM_BE_BREAKPOINT
decl_stmt|;
operator|*
name|lenptr
operator|=
sizeof|sizeof
argument_list|(
name|arm_breakpoint
argument_list|)
expr_stmt|;
return|return
name|arm_breakpoint
return|;
block|}
else|else
block|{
specifier|static
name|char
name|arm_breakpoint
index|[]
init|=
name|ARM_LE_BREAKPOINT
decl_stmt|;
operator|*
name|lenptr
operator|=
sizeof|sizeof
argument_list|(
name|arm_breakpoint
argument_list|)
expr_stmt|;
return|return
name|arm_breakpoint
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return non-zero if the PC is inside a call thunk (aka stub or trampoline).    This implements the IN_SOLIB_CALL_TRAMPOLINE macro.  */
end_comment

begin_function
name|int
name|arm_in_call_stub
parameter_list|(
name|pc
parameter_list|,
name|name
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|CORE_ADDR
name|start_addr
decl_stmt|;
comment|/* Find the starting address of the function containing the PC.  If the      caller didn't give us a name, look it up at the same time.  */
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
name|name
condition|?
name|NULL
else|:
operator|&
name|name
argument_list|,
operator|&
name|start_addr
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_call_via_r"
argument_list|,
literal|11
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If PC is in a Thumb call or return stub, return the address of the target    PC, which is in a register.  The thunk functions are called _called_via_xx,    where x is the register name.  The possible names are r0-r9, sl, fp, ip,    sp, and lr. */
end_comment

begin_function
name|CORE_ADDR
name|arm_skip_stub
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|CORE_ADDR
name|start_addr
decl_stmt|;
comment|/* Find the starting address and name of the function containing the PC.  */
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|start_addr
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Call thunks always start with "_call_via_".  */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"_call_via_"
argument_list|,
literal|10
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Use the name suffix to determine which register contains          the target PC.  */
specifier|static
name|char
modifier|*
name|table
index|[
literal|15
index|]
init|=
block|{
literal|"r0"
block|,
literal|"r1"
block|,
literal|"r2"
block|,
literal|"r3"
block|,
literal|"r4"
block|,
literal|"r5"
block|,
literal|"r6"
block|,
literal|"r7"
block|,
literal|"r8"
block|,
literal|"r9"
block|,
literal|"sl"
block|,
literal|"fp"
block|,
literal|"ip"
block|,
literal|"sp"
block|,
literal|"lr"
block|}
decl_stmt|;
name|int
name|regno
decl_stmt|;
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<=
literal|14
condition|;
name|regno
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|&
name|name
index|[
literal|10
index|]
argument_list|,
name|table
index|[
name|regno
index|]
argument_list|)
operator|==
literal|0
condition|)
return|return
name|read_register
argument_list|(
name|regno
argument_list|)
return|;
block|}
return|return
literal|0
return|;
comment|/* not a stub */
block|}
end_function

begin_function
name|void
name|_initialize_arm_tdep
parameter_list|()
block|{
name|tm_print_insn
operator|=
name|gdb_print_insn_arm
expr_stmt|;
name|add_com
argument_list|(
literal|"othernames"
argument_list|,
name|class_obscure
argument_list|,
name|arm_othernames
argument_list|,
literal|"Switch to the other set of register names."
argument_list|)
expr_stmt|;
comment|/* ??? Maybe this should be a boolean.  */
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"apcs32"
argument_list|,
name|no_class
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|arm_apcs_32
argument_list|,
literal|"Set usage of ARM 32-bit mode.\n"
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Test whether the coff symbol specific value corresponds to a Thumb function */
end_comment

begin_function
name|int
name|coff_sym_is_thumb
parameter_list|(
name|int
name|val
parameter_list|)
block|{
return|return
operator|(
name|val
operator|==
name|C_THUMBEXT
operator|||
name|val
operator|==
name|C_THUMBSTAT
operator|||
name|val
operator|==
name|C_THUMBEXTFUNC
operator|||
name|val
operator|==
name|C_THUMBSTATFUNC
operator|||
name|val
operator|==
name|C_THUMBLABEL
operator|)
return|;
block|}
end_function

end_unit

