begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target-dependent code for the Acorn Risc Machine, for GDB, the GNU Debugger.    Copyright 1988, 1989, 1991, 1992, 1993, 1995 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_if
if|#
directive|if
literal|0
end_if

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_define
define|#
directive|define
name|N_TXTADDR
parameter_list|(
name|hdr
parameter_list|)
value|0x8000
end_define

begin_define
define|#
directive|define
name|N_DATADDR
parameter_list|(
name|hdr
parameter_list|)
value|(hdr.a_text + 0x8000)
end_define

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_comment
comment|/* After a.out.h  */
end_comment

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Work with core dump and executable files, for GDB.     This code would be in corefile.c if it weren't machine-dependent. */
end_comment

begin_comment
comment|/* Structure to describe the chain of shared libraries used    by the execfile.    e.g. prog shares Xt which shares X11 which shares c. */
end_comment

begin_comment
unit|struct shared_library {     struct exec_header header;     char name[SHLIBLEN];     CORE_ADDR text_start;
comment|/* CORE_ADDR of 1st byte of text, this file */
end_comment

begin_comment
unit|long data_offset;
comment|/* offset of data section in file */
end_comment

begin_comment
unit|int chan;
comment|/* file descriptor for the file */
end_comment

begin_comment
unit|struct shared_library *shares;
comment|/* library this one shares */
end_comment

begin_comment
unit|}; static struct shared_library *shlib = 0;
comment|/* Hook for `exec_file_command' command to call.  */
end_comment

begin_comment
unit|extern void (*exec_file_display_hook) ();     static CORE_ADDR unshared_text_start;
comment|/* extended header from exec file (for shared library info) */
end_comment

begin_comment
unit|static struct exec_header exec_header;  void exec_file_command (filename, from_tty)      char *filename;      int from_tty; {   int val;
comment|/* Eliminate all traces of old exec file.      Mark text segment as empty.  */
end_comment

begin_comment
unit|if (execfile)     free (execfile);   execfile = 0;   data_start = 0;   data_end -= exec_data_start;   text_start = 0;   unshared_text_start = 0;   text_end = 0;   exec_data_start = 0;   exec_data_end = 0;   if (execchan>= 0)     close (execchan);   execchan = -1;   if (shlib) {       close_shared_library(shlib);       shlib = 0;   }
comment|/* Now open and digest the file the user requested, if any.  */
end_comment

begin_ifdef
unit|if (filename)     {       filename = tilde_expand (filename);       make_cleanup (free, filename);        execchan = openp (getenv ("PATH"), 1, filename, O_RDONLY, 0,&execfile);       if (execchan< 0) 	perror_with_name (filename);        { 	struct stat st_exec;
ifdef|#
directive|ifdef
name|HEADER_SEEK_FD
end_ifdef

begin_endif
unit|HEADER_SEEK_FD (execchan);
endif|#
directive|endif
end_endif

begin_comment
unit|val = myread (execchan,&exec_header, sizeof exec_header); 	exec_aouthdr = exec_header.a_exec;  	if (val< 0) 	  perror_with_name (filename);  	text_start = 0x8000;
comment|/* Look for shared library if needed */
end_comment

begin_comment
unit|if (exec_header.a_exec.a_magic& MF_USES_SL) 	    shlib = open_shared_library(exec_header.a_shlibname, text_start);  	text_offset = N_TXTOFF (exec_aouthdr); 	exec_data_offset = N_TXTOFF (exec_aouthdr) + exec_aouthdr.a_text;  	if (shlib) { 	    unshared_text_start = shared_text_end(shlib)& ~0x7fff; 	    stack_start = shlib->header.a_exec.a_sldatabase; 	    stack_end = STACK_END_ADDR; 	} else 	    unshared_text_start = 0x8000; 	text_end = unshared_text_start + exec_aouthdr.a_text;  	exec_data_start = unshared_text_start + exec_aouthdr.a_text;         exec_data_end = exec_data_start + exec_aouthdr.a_data;  	data_start = exec_data_start; 	data_end += exec_data_start;  	fstat (execchan,&st_exec); 	exec_mtime = st_exec.st_mtime;       }        validate_files ();     }   else if (from_tty)     printf ("No exec file now.\n");
comment|/* Tell display code (if any) about the changed file name.  */
end_comment

begin_endif
unit|if (exec_file_display_hook)     (*exec_file_display_hook) (filename); }
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Read from the program's memory (except for inferior processes).    This function is misnamed, since it only reads, never writes; and    since it will use the core file and/or executable file as necessary.     It should be extended to write as well as read, FIXME, for patching files.     Return 0 if address could be read, EIO if addresss out of bounds.  */
end_comment

begin_comment
unit|int xfer_core_file (memaddr, myaddr, len)      CORE_ADDR memaddr;      char *myaddr;      int len; {   register int i;   register int val;   int xferchan;   char **xferfile;   int fileptr;   int returnval = 0;    while (len> 0)     {       xferfile = 0;       xferchan = 0;
comment|/* Determine which file the next bunch of addresses reside in, 	 and where in the file.  Set the file's read/write pointer 	 to point at the proper place for the desired address 	 and set xferfile and xferchan for the correct file.  	 If desired address is nonexistent, leave them zero.  	 i is set to the number of bytes that can be handled 	 along with the next address.  	 We put the most likely tests first for efficiency.  */
end_comment

begin_comment
comment|/* Note that if there is no core file 	 data_start and data_end are equal.  */
end_comment

begin_comment
unit|if (memaddr>= data_start&& memaddr< data_end) 	{ 	  i = min (len, data_end - memaddr); 	  fileptr = memaddr - data_start + data_offset; 	  xferfile =&corefile; 	  xferchan = corechan; 	}
comment|/* Note that if there is no core file 	 stack_start and stack_end define the shared library data.  */
end_comment

begin_comment
unit|else if (memaddr>= stack_start&& memaddr< stack_end) 	{ 	    if (corechan< 0) { 		struct shared_library *lib; 		for (lib = shlib; lib; lib = lib->shares) 		    if (memaddr>= lib->header.a_exec.a_sldatabase&& 			memaddr< lib->header.a_exec.a_sldatabase + 			  lib->header.a_exec.a_data) 			break; 		if (lib) { 		    i = min (len, lib->header.a_exec.a_sldatabase + 			     lib->header.a_exec.a_data - memaddr); 		    fileptr = lib->data_offset + memaddr - 			lib->header.a_exec.a_sldatabase; 		    xferfile = execfile; 		    xferchan = lib->chan; 		} 	    } else { 		i = min (len, stack_end - memaddr); 		fileptr = memaddr - stack_start + stack_offset; 		xferfile =&corefile; 		xferchan = corechan; 	    } 	}       else if (corechan< 0&& memaddr>= exec_data_start&& memaddr< exec_data_end) 	{ 	  i = min (len, exec_data_end - memaddr); 	  fileptr = memaddr - exec_data_start + exec_data_offset; 	  xferfile =&execfile; 	  xferchan = execchan; 	}       else if (memaddr>= text_start&& memaddr< text_end) 	{ 	    struct shared_library *lib; 	    for (lib = shlib; lib; lib = lib->shares) 		if (memaddr>= lib->text_start&& 		    memaddr< lib->text_start + lib->header.a_exec.a_text) 		    break; 	    if (lib) { 		i = min (len, lib->header.a_exec.a_text + 			 lib->text_start - memaddr); 		fileptr = memaddr - lib->text_start + text_offset; 		xferfile =&execfile; 		xferchan = lib->chan; 	    } else { 		i = min (len, text_end - memaddr); 		fileptr = memaddr - unshared_text_start + text_offset; 		xferfile =&execfile; 		xferchan = execchan; 	    } 	}       else if (memaddr< text_start) 	{ 	  i = min (len, text_start - memaddr); 	}       else if (memaddr>= text_end&& memaddr< (corechan>= 0? data_start : exec_data_start)) 	{ 	  i = min (len, data_start - memaddr); 	}       else if (corechan>= 0&& memaddr>= data_end&& memaddr< stack_start) 	{ 	  i = min (len, stack_start - memaddr); 	}       else if (corechan< 0&& memaddr>= exec_data_end) 	{ 	  i = min (len, - memaddr); 	}       else if (memaddr>= stack_end&& stack_end != 0) 	{ 	  i = min (len, - memaddr); 	}       else 	{
comment|/* Address did not classify into one of the known ranges. 	     This shouldn't happen; we catch the endpoints.  */
end_comment

begin_comment
unit|fatal ("Internal: Bad case logic in xfer_core_file."); 	}
comment|/* Now we know which file to use. 	 Set up its pointer and transfer the data.  */
end_comment

begin_comment
unit|if (xferfile) 	{ 	  if (*xferfile == 0) 	    if (xferfile ==&execfile) 	      error ("No program file to examine."); 	    else 	      error ("No core dump file or running program to examine."); 	  val = lseek (xferchan, fileptr, 0); 	  if (val< 0) 	    perror_with_name (*xferfile); 	  val = myread (xferchan, myaddr, i); 	  if (val< 0) 	    perror_with_name (*xferfile); 	}
comment|/* If this address is for nonexistent memory, 	 read zeros if reading, or do nothing if writing. 	 Actually, we never right.  */
end_comment

begin_endif
unit|else 	{ 	  memset (myaddr, '\0', i); 	  returnval = EIO; 	}        memaddr += i;       myaddr += i;       len -= i;     }   return returnval; }
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* APCS (ARM procedure call standard) defines the following prologue:     mov		ip, sp   [stmfd	sp!, {a1,a2,a3,a4}]    stmfd	sp!, {...,fp,ip,lr,pc}   [stfe		f7, [sp, #-12]!]   [stfe		f6, [sp, #-12]!]   [stfe		f5, [sp, #-12]!]   [stfe		f4, [sp, #-12]!]    sub		fp, ip, #nn	// nn == 20 or 4 depending on second ins */
end_comment

begin_function
name|CORE_ADDR
name|skip_prologue
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
name|CORE_ADDR
name|skip_pc
init|=
name|pc
decl_stmt|;
if|#
directive|if
literal|0
block|union insn_fmt op;      op.ins = read_memory_integer(skip_pc, 4);
comment|/* look for the "mov ip,sp" */
block|if (op.generic.type != TYPE_ARITHMETIC || 	op.arith.opcode != OPCODE_MOV || 	op.arith.dest != SPTEMP || 	op.arith.operand2 != SP) return pc;     skip_pc += 4;
comment|/* skip the "stmfd sp!,{a1,a2,a3,a4}" if its there */
block|op.ins = read_memory_integer(skip_pc, 4);     if (op.generic.type == TYPE_BLOCK_BRANCH&& 	op.generic.subtype == SUBTYPE_BLOCK&& 	op.block.mask == 0xf&& 	op.block.base == SP&& 	op.block.is_load == 0&& 	op.block.writeback == 1&& 	op.block.increment == 0&& 	op.block.before == 1) skip_pc += 4;
comment|/* skip the "stmfd sp!,{...,fp,ip,lr,pc} */
block|op.ins = read_memory_integer(skip_pc, 4);     if (op.generic.type != TYPE_BLOCK_BRANCH || 	op.generic.subtype != SUBTYPE_BLOCK ||
comment|/* the mask should look like 110110xxxxxx0000 */
block|(op.block.mask& 0xd800) != 0xd800 || 	op.block.base != SP || 	op.block.is_load != 0 || 	op.block.writeback != 1 || 	op.block.increment != 0 || 	op.block.before != 1) return pc;     skip_pc += 4;
comment|/* check for "sub fp,ip,#nn" */
block|op.ins = read_memory_integer(skip_pc, 4);     if (op.generic.type != TYPE_ARITHMETIC || 	op.arith.opcode != OPCODE_SUB || 	op.arith.dest != FP || 	op.arith.operand1 != SPTEMP) return pc;
endif|#
directive|endif
return|return
name|skip_pc
operator|+
literal|4
return|;
block|}
end_function

begin_function
name|void
name|arm_frame_find_saved_regs
parameter_list|(
name|frame_info
parameter_list|,
name|saved_regs_addr
parameter_list|)
name|struct
name|frame_info
modifier|*
name|frame_info
decl_stmt|;
name|struct
name|frame_saved_regs
modifier|*
name|saved_regs_addr
decl_stmt|;
block|{
specifier|register
name|int
name|regnum
decl_stmt|;
specifier|register
name|int
name|frame
decl_stmt|;
specifier|register
name|int
name|next_addr
decl_stmt|;
specifier|register
name|int
name|return_data_save
decl_stmt|;
specifier|register
name|int
name|saved_register_mask
decl_stmt|;
name|memset
argument_list|(
name|saved_regs_addr
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|saved_regs_addr
argument_list|)
argument_list|)
expr_stmt|;
name|frame
operator|=
name|frame_info
operator|->
name|frame
expr_stmt|;
name|return_data_save
operator|=
name|read_memory_integer
argument_list|(
name|frame
argument_list|,
literal|4
argument_list|)
operator|&
literal|0x03fffffc
operator|-
literal|12
expr_stmt|;
name|saved_register_mask
operator|=
name|read_memory_integer
argument_list|(
name|return_data_save
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|next_addr
operator|=
name|frame
operator|-
literal|12
expr_stmt|;
for|for
control|(
name|regnum
operator|=
literal|4
init|;
name|regnum
operator|<
literal|10
condition|;
name|regnum
operator|++
control|)
if|if
condition|(
name|saved_register_mask
operator|&
operator|(
literal|1
operator|<<
name|regnum
operator|)
condition|)
block|{
name|next_addr
operator|-=
literal|4
expr_stmt|;
name|saved_regs_addr
operator|->
name|regs
index|[
name|regnum
index|]
operator|=
name|next_addr
expr_stmt|;
block|}
if|if
condition|(
name|read_memory_integer
argument_list|(
name|return_data_save
operator|+
literal|4
argument_list|,
literal|4
argument_list|)
operator|==
literal|0xed6d7103
condition|)
block|{
name|next_addr
operator|-=
literal|12
expr_stmt|;
name|saved_regs_addr
operator|->
name|regs
index|[
name|F0_REGNUM
operator|+
literal|7
index|]
operator|=
name|next_addr
expr_stmt|;
block|}
if|if
condition|(
name|read_memory_integer
argument_list|(
name|return_data_save
operator|+
literal|8
argument_list|,
literal|4
argument_list|)
operator|==
literal|0xed6d6103
condition|)
block|{
name|next_addr
operator|-=
literal|12
expr_stmt|;
name|saved_regs_addr
operator|->
name|regs
index|[
name|F0_REGNUM
operator|+
literal|6
index|]
operator|=
name|next_addr
expr_stmt|;
block|}
if|if
condition|(
name|read_memory_integer
argument_list|(
name|return_data_save
operator|+
literal|12
argument_list|,
literal|4
argument_list|)
operator|==
literal|0xed6d5103
condition|)
block|{
name|next_addr
operator|-=
literal|12
expr_stmt|;
name|saved_regs_addr
operator|->
name|regs
index|[
name|F0_REGNUM
operator|+
literal|5
index|]
operator|=
name|next_addr
expr_stmt|;
block|}
if|if
condition|(
name|read_memory_integer
argument_list|(
name|return_data_save
operator|+
literal|16
argument_list|,
literal|4
argument_list|)
operator|==
literal|0xed6d4103
condition|)
block|{
name|next_addr
operator|-=
literal|12
expr_stmt|;
name|saved_regs_addr
operator|->
name|regs
index|[
name|F0_REGNUM
operator|+
literal|4
index|]
operator|=
name|next_addr
expr_stmt|;
block|}
name|saved_regs_addr
operator|->
name|regs
index|[
name|SP_REGNUM
index|]
operator|=
name|next_addr
expr_stmt|;
name|saved_regs_addr
operator|->
name|regs
index|[
name|PC_REGNUM
index|]
operator|=
name|frame
operator|-
literal|4
expr_stmt|;
name|saved_regs_addr
operator|->
name|regs
index|[
name|PS_REGNUM
index|]
operator|=
name|frame
operator|-
literal|4
expr_stmt|;
name|saved_regs_addr
operator|->
name|regs
index|[
name|FP_REGNUM
index|]
operator|=
name|frame
operator|-
literal|12
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_fpu_flags
parameter_list|(
name|flags
parameter_list|)
name|int
name|flags
decl_stmt|;
block|{
if|if
condition|(
name|flags
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
condition|)
name|fputs
argument_list|(
literal|"IVO "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
literal|1
operator|<<
literal|1
operator|)
condition|)
name|fputs
argument_list|(
literal|"DVZ "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
literal|1
operator|<<
literal|2
operator|)
condition|)
name|fputs
argument_list|(
literal|"OFL "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
literal|1
operator|<<
literal|3
operator|)
condition|)
name|fputs
argument_list|(
literal|"UFL "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
literal|1
operator|<<
literal|4
operator|)
condition|)
name|fputs
argument_list|(
literal|"INX "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arm_float_info
parameter_list|()
block|{
specifier|register
name|unsigned
name|long
name|status
init|=
name|read_register
argument_list|(
name|FPS_REGNUM
argument_list|)
decl_stmt|;
name|int
name|type
decl_stmt|;
name|type
operator|=
operator|(
name|status
operator|>>
literal|24
operator|)
operator|&
literal|127
expr_stmt|;
name|printf
argument_list|(
literal|"%s FPU type %d\n"
argument_list|,
operator|(
name|status
operator|&
operator|(
literal|1
operator|<<
literal|31
operator|)
operator|)
condition|?
literal|"Hardware"
else|:
literal|"Software"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"mask: "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|print_fpu_flags
argument_list|(
name|status
operator|>>
literal|16
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"flags: "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|print_fpu_flags
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arm_othernames
parameter_list|()
block|{
specifier|static
name|int
name|toggle
decl_stmt|;
specifier|static
name|char
modifier|*
name|original
index|[]
init|=
name|ORIGINAL_REGISTER_NAMES
decl_stmt|;
specifier|static
name|char
modifier|*
name|extra_crispy
index|[]
init|=
name|ADDITIONAL_REGISTER_NAMES
decl_stmt|;
name|memcpy
argument_list|(
name|reg_names
argument_list|,
name|toggle
condition|?
name|extra_crispy
else|:
name|original
argument_list|,
sizeof|sizeof
argument_list|(
name|original
argument_list|)
argument_list|)
expr_stmt|;
name|toggle
operator|=
operator|!
name|toggle
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_arm_tdep
parameter_list|()
block|{
name|tm_print_insn
operator|=
name|print_insn_little_arm
expr_stmt|;
name|add_com
argument_list|(
literal|"othernames"
argument_list|,
name|class_obscure
argument_list|,
name|arm_othernames
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* FIXME:  Fill in with the 'right thing', see asm     template in arm-convert.s */
end_comment

begin_function
name|void
name|convert_from_extended
parameter_list|(
name|ptr
parameter_list|,
name|dbl
parameter_list|)
name|void
modifier|*
name|ptr
decl_stmt|;
name|double
modifier|*
name|dbl
decl_stmt|;
block|{
operator|*
name|dbl
operator|=
operator|*
operator|(
name|double
operator|*
operator|)
name|ptr
expr_stmt|;
block|}
end_function

begin_function
name|void
name|convert_to_extended
parameter_list|(
name|dbl
parameter_list|,
name|ptr
parameter_list|)
name|void
modifier|*
name|ptr
decl_stmt|;
name|double
modifier|*
name|dbl
decl_stmt|;
block|{
operator|*
operator|(
name|double
operator|*
operator|)
name|ptr
operator|=
operator|*
name|dbl
expr_stmt|;
block|}
end_function

begin_function
name|int
name|arm_nullified_insn
parameter_list|(
name|inst
parameter_list|)
name|unsigned
name|long
name|inst
decl_stmt|;
block|{
name|unsigned
name|long
name|cond
init|=
name|inst
operator|&
literal|0xf0000000
decl_stmt|;
name|unsigned
name|long
name|status_reg
decl_stmt|;
if|if
condition|(
name|cond
operator|==
name|INST_AL
operator|||
name|cond
operator|==
name|INST_NV
condition|)
return|return
literal|0
return|;
name|status_reg
operator|=
name|read_register
argument_list|(
name|PS_REGNUM
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cond
condition|)
block|{
case|case
name|INST_EQ
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_Z
operator|)
operator|==
literal|0
operator|)
return|;
case|case
name|INST_NE
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_Z
operator|)
operator|!=
literal|0
operator|)
return|;
case|case
name|INST_CS
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_C
operator|)
operator|==
literal|0
operator|)
return|;
case|case
name|INST_CC
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_C
operator|)
operator|!=
literal|0
operator|)
return|;
case|case
name|INST_MI
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_N
operator|)
operator|==
literal|0
operator|)
return|;
case|case
name|INST_PL
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_N
operator|)
operator|!=
literal|0
operator|)
return|;
case|case
name|INST_VS
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_V
operator|)
operator|==
literal|0
operator|)
return|;
case|case
name|INST_VC
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_V
operator|)
operator|!=
literal|0
operator|)
return|;
case|case
name|INST_HI
case|:
return|return
operator|(
operator|(
name|status_reg
operator|&
operator|(
name|FLAG_C
operator||
name|FLAG_Z
operator|)
operator|)
operator|!=
name|FLAG_C
operator|)
return|;
case|case
name|INST_LS
case|:
return|return
operator|(
operator|(
operator|(
name|status_reg
operator|&
operator|(
name|FLAG_C
operator||
name|FLAG_Z
operator|)
operator|)
operator|^
name|FLAG_C
operator|)
operator|==
literal|0
operator|)
return|;
case|case
name|INST_GE
case|:
return|return
operator|(
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_N
operator|)
operator|==
literal|0
operator|)
operator|!=
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_V
operator|)
operator|==
literal|0
operator|)
operator|)
return|;
case|case
name|INST_LT
case|:
return|return
operator|(
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_N
operator|)
operator|==
literal|0
operator|)
operator|==
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_V
operator|)
operator|==
literal|0
operator|)
operator|)
return|;
case|case
name|INST_GT
case|:
return|return
operator|(
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_Z
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_N
operator|)
operator|==
literal|0
operator|)
operator|!=
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_V
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
return|;
case|case
name|INST_LE
case|:
return|return
operator|(
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_Z
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_N
operator|)
operator|==
literal|0
operator|)
operator|==
operator|(
operator|(
name|status_reg
operator|&
name|FLAG_V
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* taken from remote-arm.c .. */
end_comment

begin_define
define|#
directive|define
name|submask
parameter_list|(
name|x
parameter_list|)
value|((1L<< ((x) + 1)) - 1)
end_define

begin_define
define|#
directive|define
name|bit
parameter_list|(
name|obj
parameter_list|,
name|st
parameter_list|)
value|(((obj)& (1L<< (st)))>> st)
end_define

begin_define
define|#
directive|define
name|bits
parameter_list|(
name|obj
parameter_list|,
name|st
parameter_list|,
name|fn
parameter_list|)
define|\
value|(((obj)& submask (fn)& ~ submask ((st) - 1))>> (st))
end_define

begin_define
define|#
directive|define
name|sbits
parameter_list|(
name|obj
parameter_list|,
name|st
parameter_list|,
name|fn
parameter_list|)
define|\
value|((long) (bits(obj,st,fn) | ((long) bit(obj,fn) * ~ submask (fn - st))))
end_define

begin_define
define|#
directive|define
name|BranchDest
parameter_list|(
name|addr
parameter_list|,
name|instr
parameter_list|)
define|\
value|((CORE_ADDR) (((long) (addr)) + 8 + (sbits (instr, 0, 23)<< 2)))
end_define

begin_define
define|#
directive|define
name|ARM_PC_32
value|1
end_define

begin_function
specifier|static
name|unsigned
name|long
name|shifted_reg_val
parameter_list|(
name|inst
parameter_list|,
name|carry
parameter_list|,
name|pc_val
parameter_list|)
name|unsigned
name|long
name|inst
decl_stmt|;
name|int
name|carry
decl_stmt|;
name|unsigned
name|long
name|pc_val
decl_stmt|;
block|{
name|unsigned
name|long
name|res
decl_stmt|,
name|shift
decl_stmt|;
name|int
name|rm
init|=
name|bits
argument_list|(
name|inst
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|shifttype
init|=
name|bits
argument_list|(
name|inst
argument_list|,
literal|5
argument_list|,
literal|6
argument_list|)
decl_stmt|;
if|if
condition|(
name|bit
argument_list|(
name|inst
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|int
name|rs
init|=
name|bits
argument_list|(
name|inst
argument_list|,
literal|8
argument_list|,
literal|11
argument_list|)
decl_stmt|;
name|shift
operator|=
operator|(
name|rs
operator|==
literal|15
condition|?
name|pc_val
operator|+
literal|8
else|:
name|read_register
argument_list|(
name|rs
argument_list|)
operator|)
operator|&
literal|0xFF
expr_stmt|;
block|}
else|else
name|shift
operator|=
name|bits
argument_list|(
name|inst
argument_list|,
literal|7
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|res
operator|=
operator|(
name|rm
operator|==
literal|15
condition|?
operator|(
operator|(
name|pc_val
operator||
operator|(
name|ARM_PC_32
condition|?
literal|0
else|:
name|read_register
argument_list|(
name|PS_REGNUM
argument_list|)
operator|)
operator|)
operator|+
operator|(
name|bit
argument_list|(
name|inst
argument_list|,
literal|4
argument_list|)
condition|?
literal|12
else|:
literal|8
operator|)
operator|)
else|:
name|read_register
argument_list|(
name|rm
argument_list|)
operator|)
expr_stmt|;
switch|switch
condition|(
name|shifttype
condition|)
block|{
case|case
literal|0
case|:
comment|/* LSL */
name|res
operator|=
name|shift
operator|>=
literal|32
condition|?
literal|0
else|:
name|res
operator|<<
name|shift
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* LSR */
name|res
operator|=
name|shift
operator|>=
literal|32
condition|?
literal|0
else|:
name|res
operator|>>
name|shift
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* ASR */
if|if
condition|(
name|shift
operator|>=
literal|32
condition|)
name|shift
operator|=
literal|31
expr_stmt|;
name|res
operator|=
operator|(
operator|(
name|res
operator|&
literal|0x80000000L
operator|)
condition|?
operator|~
operator|(
operator|(
operator|~
name|res
operator|)
operator|>>
name|shift
operator|)
else|:
name|res
operator|>>
name|shift
operator|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* ROR/RRX */
name|shift
operator|&=
literal|31
expr_stmt|;
if|if
condition|(
name|shift
operator|==
literal|0
condition|)
name|res
operator|=
operator|(
name|res
operator|>>
literal|1
operator|)
operator||
operator|(
name|carry
condition|?
literal|0x80000000L
else|:
literal|0
operator|)
expr_stmt|;
else|else
name|res
operator|=
operator|(
name|res
operator|>>
name|shift
operator|)
operator||
operator|(
name|res
operator|<<
operator|(
literal|32
operator|-
name|shift
operator|)
operator|)
expr_stmt|;
break|break;
block|}
return|return
name|res
operator|&
literal|0xffffffff
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|arm_get_next_pc
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
name|unsigned
name|long
name|pc_val
init|=
operator|(
name|unsigned
name|long
operator|)
name|pc
decl_stmt|;
name|unsigned
name|long
name|this_instr
init|=
name|read_memory_integer
argument_list|(
name|pc
argument_list|,
literal|4
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|status
init|=
name|read_register
argument_list|(
name|PS_REGNUM
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|nextpc
init|=
call|(
name|CORE_ADDR
call|)
argument_list|(
name|pc_val
operator|+
literal|4
argument_list|)
decl_stmt|;
comment|/* Default case */
if|if
condition|(
operator|!
name|arm_nullified_insn
argument_list|(
name|this_instr
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|24
argument_list|,
literal|27
argument_list|)
condition|)
block|{
case|case
literal|0x0
case|:
case|case
literal|0x1
case|:
comment|/* data processing */
case|case
literal|0x2
case|:
case|case
literal|0x3
case|:
block|{
name|unsigned
name|long
name|operand1
decl_stmt|,
name|operand2
decl_stmt|,
name|result
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|rn
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|12
argument_list|,
literal|15
argument_list|)
operator|!=
literal|15
condition|)
break|break;
if|if
condition|(
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|22
argument_list|,
literal|25
argument_list|)
operator|==
literal|0
operator|&&
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|4
argument_list|,
literal|7
argument_list|)
operator|==
literal|9
condition|)
comment|/* multiply */
name|error
argument_list|(
literal|"Illegal update to pc in instruction"
argument_list|)
expr_stmt|;
comment|/* Multiply into PC */
name|c
operator|=
operator|(
name|status
operator|&
name|FLAG_C
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|rn
operator|=
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|16
argument_list|,
literal|19
argument_list|)
expr_stmt|;
name|operand1
operator|=
operator|(
name|rn
operator|==
literal|15
operator|)
condition|?
name|pc_val
operator|+
literal|8
else|:
name|read_register
argument_list|(
name|rn
argument_list|)
expr_stmt|;
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|25
argument_list|)
condition|)
block|{
name|unsigned
name|long
name|immval
init|=
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|0
argument_list|,
literal|7
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|rotate
init|=
literal|2
operator|*
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|8
argument_list|,
literal|11
argument_list|)
decl_stmt|;
name|operand2
operator|=
operator|(
operator|(
name|immval
operator|>>
name|rotate
operator|)
operator||
operator|(
name|immval
operator|<<
operator|(
literal|32
operator|-
name|rotate
operator|)
operator|)
operator|&
literal|0xffffffff
operator|)
expr_stmt|;
block|}
else|else
comment|/* operand 2 is a shifted register */
name|operand2
operator|=
name|shifted_reg_val
argument_list|(
name|this_instr
argument_list|,
name|c
argument_list|,
name|pc_val
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|21
argument_list|,
literal|24
argument_list|)
condition|)
block|{
case|case
literal|0x0
case|:
comment|/*and*/
name|result
operator|=
name|operand1
operator|&
name|operand2
expr_stmt|;
break|break;
case|case
literal|0x1
case|:
comment|/*eor*/
name|result
operator|=
name|operand1
operator|^
name|operand2
expr_stmt|;
break|break;
case|case
literal|0x2
case|:
comment|/*sub*/
name|result
operator|=
name|operand1
operator|-
name|operand2
expr_stmt|;
break|break;
case|case
literal|0x3
case|:
comment|/*rsb*/
name|result
operator|=
name|operand2
operator|-
name|operand1
expr_stmt|;
break|break;
case|case
literal|0x4
case|:
comment|/*add*/
name|result
operator|=
name|operand1
operator|+
name|operand2
expr_stmt|;
break|break;
case|case
literal|0x5
case|:
comment|/*adc*/
name|result
operator|=
name|operand1
operator|+
name|operand2
operator|+
name|c
expr_stmt|;
break|break;
case|case
literal|0x6
case|:
comment|/*sbc*/
name|result
operator|=
name|operand1
operator|-
name|operand2
operator|+
name|c
expr_stmt|;
break|break;
case|case
literal|0x7
case|:
comment|/*rsc*/
name|result
operator|=
name|operand2
operator|-
name|operand1
operator|+
name|c
expr_stmt|;
break|break;
case|case
literal|0x8
case|:
case|case
literal|0x9
case|:
case|case
literal|0xa
case|:
case|case
literal|0xb
case|:
comment|/* tst, teq, cmp, cmn */
name|result
operator|=
operator|(
name|unsigned
name|long
operator|)
name|nextpc
expr_stmt|;
break|break;
case|case
literal|0xc
case|:
comment|/*orr*/
name|result
operator|=
name|operand1
operator||
name|operand2
expr_stmt|;
break|break;
case|case
literal|0xd
case|:
comment|/*mov*/
comment|/* Always step into a function.  */
name|result
operator|=
name|operand2
expr_stmt|;
break|break;
case|case
literal|0xe
case|:
comment|/*bic*/
name|result
operator|=
name|operand1
operator|&
operator|~
name|operand2
expr_stmt|;
break|break;
case|case
literal|0xf
case|:
comment|/*mvn*/
name|result
operator|=
operator|~
name|operand2
expr_stmt|;
break|break;
block|}
name|nextpc
operator|=
operator|(
name|CORE_ADDR
operator|)
name|ADDR_BITS_REMOVE
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextpc
operator|==
name|pc
condition|)
name|error
argument_list|(
literal|"Infinite loop detected"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|0x4
case|:
case|case
literal|0x5
case|:
comment|/* data transfer */
case|case
literal|0x6
case|:
case|case
literal|0x7
case|:
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|20
argument_list|)
condition|)
block|{
comment|/* load */
if|if
condition|(
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|12
argument_list|,
literal|15
argument_list|)
operator|==
literal|15
condition|)
block|{
comment|/* rd == pc */
name|unsigned
name|long
name|rn
decl_stmt|;
name|unsigned
name|long
name|base
decl_stmt|;
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|22
argument_list|)
condition|)
name|error
argument_list|(
literal|"Illegal update to pc in instruction"
argument_list|)
expr_stmt|;
comment|/* byte write to PC */
name|rn
operator|=
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|16
argument_list|,
literal|19
argument_list|)
expr_stmt|;
name|base
operator|=
operator|(
name|rn
operator|==
literal|15
operator|)
condition|?
name|pc_val
operator|+
literal|8
else|:
name|read_register
argument_list|(
name|rn
argument_list|)
expr_stmt|;
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|24
argument_list|)
condition|)
block|{
comment|/* pre-indexed */
name|int
name|c
init|=
operator|(
name|status
operator|&
name|FLAG_C
operator|)
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|unsigned
name|long
name|offset
init|=
operator|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|25
argument_list|)
condition|?
name|shifted_reg_val
argument_list|(
name|this_instr
argument_list|,
name|c
argument_list|,
name|pc_val
argument_list|)
else|:
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|0
argument_list|,
literal|11
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|23
argument_list|)
condition|)
name|base
operator|+=
name|offset
expr_stmt|;
else|else
name|base
operator|-=
name|offset
expr_stmt|;
block|}
name|nextpc
operator|=
operator|(
name|CORE_ADDR
operator|)
name|read_memory_integer
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|base
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|nextpc
operator|=
name|ADDR_BITS_REMOVE
argument_list|(
name|nextpc
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextpc
operator|==
name|pc
condition|)
name|error
argument_list|(
literal|"Infinite loop detected"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|0x8
case|:
case|case
literal|0x9
case|:
comment|/* block transfer */
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|20
argument_list|)
condition|)
block|{
comment|/* LDM */
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|15
argument_list|)
condition|)
block|{
comment|/* loading pc */
name|int
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|23
argument_list|)
condition|)
block|{
comment|/* up */
name|unsigned
name|long
name|reglist
init|=
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|0
argument_list|,
literal|14
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|regbit
decl_stmt|;
for|for
control|(
init|;
name|reglist
operator|!=
literal|0
condition|;
name|reglist
operator|&=
operator|~
name|regbit
control|)
block|{
name|regbit
operator|=
name|reglist
operator|&
operator|(
operator|-
name|reglist
operator|)
expr_stmt|;
name|offset
operator|+=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|24
argument_list|)
condition|)
comment|/* pre */
name|offset
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bit
argument_list|(
name|this_instr
argument_list|,
literal|24
argument_list|)
condition|)
name|offset
operator|=
operator|-
literal|4
expr_stmt|;
block|{
name|unsigned
name|long
name|rn_val
init|=
name|read_register
argument_list|(
name|bits
argument_list|(
name|this_instr
argument_list|,
literal|16
argument_list|,
literal|19
argument_list|)
argument_list|)
decl_stmt|;
name|nextpc
operator|=
operator|(
name|CORE_ADDR
operator|)
name|read_memory_integer
argument_list|(
call|(
name|CORE_ADDR
call|)
argument_list|(
name|rn_val
operator|+
name|offset
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
name|nextpc
operator|=
name|ADDR_BITS_REMOVE
argument_list|(
name|nextpc
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextpc
operator|==
name|pc
condition|)
name|error
argument_list|(
literal|"Infinite loop detected"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|0xb
case|:
comment|/* branch& link */
case|case
literal|0xa
case|:
comment|/* branch */
block|{
name|nextpc
operator|=
name|BranchDest
argument_list|(
name|pc
argument_list|,
name|this_instr
argument_list|)
expr_stmt|;
name|nextpc
operator|=
name|ADDR_BITS_REMOVE
argument_list|(
name|nextpc
argument_list|)
expr_stmt|;
if|if
condition|(
name|nextpc
operator|==
name|pc
condition|)
name|error
argument_list|(
literal|"Infinite loop detected"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|0xc
case|:
case|case
literal|0xd
case|:
case|case
literal|0xe
case|:
comment|/* coproc ops */
case|case
literal|0xf
case|:
comment|/* SWI */
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad bit-field extraction\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|pc
operator|)
return|;
block|}
block|}
return|return
name|nextpc
return|;
block|}
end_function

end_unit

