begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* C preprocessor macro expansion for GDB.    Copyright 2002 Free Software Foundation, Inc.    Contributed by Red Hat, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_obstack.h"
end_include

begin_include
include|#
directive|include
file|"bcache.h"
end_include

begin_include
include|#
directive|include
file|"macrotab.h"
end_include

begin_include
include|#
directive|include
file|"macroexp.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* A resizeable, substringable string type.  */
end_comment

begin_comment
comment|/* A string type that we can resize, quickly append to, and use to    refer to substrings of other strings.  */
end_comment

begin_struct
struct|struct
name|macro_buffer
block|{
comment|/* An array of characters.  The first LEN bytes are the real text,      but there are SIZE bytes allocated to the array.  If SIZE is      zero, then this doesn't point to a malloc'ed block.  If SHARED is      non-zero, then this buffer is actually a pointer into some larger      string, and we shouldn't append characters to it, etc.  Because      of sharing, we can't assume in general that the text is      null-terminated.  */
name|char
modifier|*
name|text
decl_stmt|;
comment|/* The number of characters in the string.  */
name|int
name|len
decl_stmt|;
comment|/* The number of characters allocated to the string.  If SHARED is      non-zero, this is meaningless; in this case, we set it to zero so      that any "do we have room to append something?" tests will fail,      so we don't always have to check SHARED before using this field.  */
name|int
name|size
decl_stmt|;
comment|/* Zero if TEXT can be safely realloc'ed (i.e., it's its own malloc      block).  Non-zero if TEXT is actually pointing into the middle of      some other block, and we shouldn't reallocate it.  */
name|int
name|shared
decl_stmt|;
comment|/* For detecting token splicing.        This is the index in TEXT of the first character of the token      that abuts the end of TEXT.  If TEXT contains no tokens, then we      set this equal to LEN.  If TEXT ends in whitespace, then there is      no token abutting the end of TEXT (it's just whitespace), and      again, we set this equal to LEN.  We set this to -1 if we don't      know the nature of TEXT.  */
name|int
name|last_token
decl_stmt|;
comment|/* If this buffer is holding the result from get_token, then this       is non-zero if it is an identifier token, zero otherwise.  */
name|int
name|is_identifier
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Set the macro buffer *B to the empty string, guessing that its    final contents will fit in N bytes.  (It'll get resized if it    doesn't, so the guess doesn't have to be right.)  Allocate the    initial storage with xmalloc.  */
end_comment

begin_function
specifier|static
name|void
name|init_buffer
parameter_list|(
name|struct
name|macro_buffer
modifier|*
name|b
parameter_list|,
name|int
name|n
parameter_list|)
block|{
comment|/* Small value for initial testing.  */
name|n
operator|=
literal|1
expr_stmt|;
name|b
operator|->
name|size
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|b
operator|->
name|text
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
else|else
name|b
operator|->
name|text
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|len
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|shared
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|last_token
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the macro buffer *BUF to refer to the LEN bytes at ADDR, as a    shared substring.  */
end_comment

begin_function
specifier|static
name|void
name|init_shared_buffer
parameter_list|(
name|struct
name|macro_buffer
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|buf
operator|->
name|text
operator|=
name|addr
expr_stmt|;
name|buf
operator|->
name|len
operator|=
name|len
expr_stmt|;
name|buf
operator|->
name|shared
operator|=
literal|1
expr_stmt|;
name|buf
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|last_token
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Free the text of the buffer B.  Raise an error if B is shared.  */
end_comment

begin_function
specifier|static
name|void
name|free_buffer
parameter_list|(
name|struct
name|macro_buffer
modifier|*
name|b
parameter_list|)
block|{
name|gdb_assert
argument_list|(
operator|!
name|b
operator|->
name|shared
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|size
condition|)
name|xfree
argument_list|(
name|b
operator|->
name|text
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A cleanup function for macro buffers.  */
end_comment

begin_function
specifier|static
name|void
name|cleanup_macro_buffer
parameter_list|(
name|void
modifier|*
name|untyped_buf
parameter_list|)
block|{
name|free_buffer
argument_list|(
operator|(
expr|struct
name|macro_buffer
operator|*
operator|)
name|untyped_buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Resize the buffer B to be at least N bytes long.  Raise an error if    B shouldn't be resized.  */
end_comment

begin_function
specifier|static
name|void
name|resize_buffer
parameter_list|(
name|struct
name|macro_buffer
modifier|*
name|b
parameter_list|,
name|int
name|n
parameter_list|)
block|{
comment|/* We shouldn't be trying to resize shared strings.  */
name|gdb_assert
argument_list|(
operator|!
name|b
operator|->
name|shared
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|size
operator|==
literal|0
condition|)
name|b
operator|->
name|size
operator|=
name|n
expr_stmt|;
else|else
while|while
condition|(
name|b
operator|->
name|size
operator|<=
name|n
condition|)
name|b
operator|->
name|size
operator|*=
literal|2
expr_stmt|;
name|b
operator|->
name|text
operator|=
name|xrealloc
argument_list|(
name|b
operator|->
name|text
argument_list|,
name|b
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Append the character C to the buffer B.  */
end_comment

begin_function
specifier|static
name|void
name|appendc
parameter_list|(
name|struct
name|macro_buffer
modifier|*
name|b
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|int
name|new_len
init|=
name|b
operator|->
name|len
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|new_len
operator|>
name|b
operator|->
name|size
condition|)
name|resize_buffer
argument_list|(
name|b
argument_list|,
name|new_len
argument_list|)
expr_stmt|;
name|b
operator|->
name|text
index|[
name|b
operator|->
name|len
index|]
operator|=
name|c
expr_stmt|;
name|b
operator|->
name|len
operator|=
name|new_len
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Append the LEN bytes at ADDR to the buffer B.  */
end_comment

begin_function
specifier|static
name|void
name|appendmem
parameter_list|(
name|struct
name|macro_buffer
modifier|*
name|b
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|new_len
init|=
name|b
operator|->
name|len
operator|+
name|len
decl_stmt|;
if|if
condition|(
name|new_len
operator|>
name|b
operator|->
name|size
condition|)
name|resize_buffer
argument_list|(
name|b
argument_list|,
name|new_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|b
operator|->
name|text
operator|+
name|b
operator|->
name|len
argument_list|,
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|b
operator|->
name|len
operator|=
name|new_len
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Recognizing preprocessor tokens.  */
end_comment

begin_function
specifier|static
name|int
name|is_whitespace
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
operator|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\n'
operator|||
name|c
operator|==
literal|'\v'
operator|||
name|c
operator|==
literal|'\f'
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_digit
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
operator|(
literal|'0'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'9'
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_identifier_nondigit
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
operator|(
name|c
operator|==
literal|'_'
operator|||
operator|(
literal|'a'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'z'
operator|)
operator|||
operator|(
literal|'A'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'Z'
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_token
parameter_list|(
name|struct
name|macro_buffer
modifier|*
name|tok
parameter_list|,
name|char
modifier|*
name|start
parameter_list|,
name|char
modifier|*
name|end
parameter_list|)
block|{
name|init_shared_buffer
argument_list|(
name|tok
argument_list|,
name|start
argument_list|,
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
name|tok
operator|->
name|last_token
operator|=
literal|0
expr_stmt|;
comment|/* Presumed; get_identifier may overwrite this. */
name|tok
operator|->
name|is_identifier
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_comment
parameter_list|(
name|struct
name|macro_buffer
modifier|*
name|tok
parameter_list|,
name|char
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|end
parameter_list|)
block|{
if|if
condition|(
name|p
operator|+
literal|2
operator|>
name|end
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
name|char
modifier|*
name|tok_start
init|=
name|p
decl_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
for|for
control|(
init|;
name|p
operator|<
name|end
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|p
operator|+
literal|2
operator|<=
name|end
operator|&&
name|p
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
name|set_token
argument_list|(
name|tok
argument_list|,
name|tok_start
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|error
argument_list|(
literal|"Unterminated comment in macro expansion."
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|char
modifier|*
name|tok_start
init|=
name|p
decl_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
for|for
control|(
init|;
name|p
operator|<
name|end
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
break|break;
name|set_token
argument_list|(
name|tok
argument_list|,
name|tok_start
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_identifier
parameter_list|(
name|struct
name|macro_buffer
modifier|*
name|tok
parameter_list|,
name|char
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|end
parameter_list|)
block|{
if|if
condition|(
name|p
operator|<
name|end
operator|&&
name|is_identifier_nondigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|char
modifier|*
name|tok_start
init|=
name|p
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|end
operator|&&
operator|(
name|is_identifier_nondigit
argument_list|(
operator|*
name|p
argument_list|)
operator|||
name|is_digit
argument_list|(
operator|*
name|p
argument_list|)
operator|)
condition|)
name|p
operator|++
expr_stmt|;
name|set_token
argument_list|(
name|tok
argument_list|,
name|tok_start
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|tok
operator|->
name|is_identifier
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_pp_number
parameter_list|(
name|struct
name|macro_buffer
modifier|*
name|tok
parameter_list|,
name|char
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|end
parameter_list|)
block|{
if|if
condition|(
name|p
operator|<
name|end
operator|&&
operator|(
name|is_digit
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'.'
operator|)
condition|)
block|{
name|char
modifier|*
name|tok_start
init|=
name|p
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|is_digit
argument_list|(
operator|*
name|p
argument_list|)
operator|||
name|is_identifier_nondigit
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'.'
condition|)
name|p
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|+
literal|2
operator|<=
name|end
operator|&&
name|strchr
argument_list|(
literal|"eEpP."
argument_list|,
operator|*
name|p
argument_list|)
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'+'
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|'-'
operator|)
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
else|else
break|break;
block|}
name|set_token
argument_list|(
name|tok
argument_list|,
name|tok_start
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If the text starting at P going up to (but not including) END    starts with a character constant, set *TOK to point to that    character constant, and return 1.  Otherwise, return zero.    Signal an error if it contains a malformed or incomplete character    constant.  */
end_comment

begin_function
specifier|static
name|int
name|get_character_constant
parameter_list|(
name|struct
name|macro_buffer
modifier|*
name|tok
parameter_list|,
name|char
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|end
parameter_list|)
block|{
comment|/* ISO/IEC 9899:1999 (E)  Section 6.4.4.4  paragraph 1       But of course, what really matters is that we handle it the same      way GDB's C/C++ lexer does.  So we call parse_escape in utils.c      to handle escape sequences.  */
if|if
condition|(
operator|(
name|p
operator|+
literal|1
operator|<=
name|end
operator|&&
operator|*
name|p
operator|==
literal|'\''
operator|)
operator|||
operator|(
name|p
operator|+
literal|2
operator|<=
name|end
operator|&&
name|p
index|[
literal|0
index|]
operator|==
literal|'L'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'\''
operator|)
condition|)
block|{
name|char
modifier|*
name|tok_start
init|=
name|p
decl_stmt|;
name|char
modifier|*
name|body_start
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\''
condition|)
name|p
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'L'
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
else|else
name|gdb_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|body_start
operator|=
name|p
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|p
operator|>=
name|end
condition|)
name|error
argument_list|(
literal|"Unmatched single quote."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\''
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|body_start
condition|)
name|error
argument_list|(
literal|"A character constant must contain at least one "
literal|"character."
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|parse_escape
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|++
expr_stmt|;
block|}
name|set_token
argument_list|(
name|tok
argument_list|,
name|tok_start
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If the text starting at P going up to (but not including) END    starts with a string literal, set *TOK to point to that string    literal, and return 1.  Otherwise, return zero.  Signal an error if    it contains a malformed or incomplete string literal.  */
end_comment

begin_function
specifier|static
name|int
name|get_string_literal
parameter_list|(
name|struct
name|macro_buffer
modifier|*
name|tok
parameter_list|,
name|char
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|end
parameter_list|)
block|{
if|if
condition|(
operator|(
name|p
operator|+
literal|1
operator|<=
name|end
operator|&&
operator|*
name|p
operator|==
literal|'\"'
operator|)
operator|||
operator|(
name|p
operator|+
literal|2
operator|<=
name|end
operator|&&
name|p
index|[
literal|0
index|]
operator|==
literal|'L'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'\"'
operator|)
condition|)
block|{
name|char
modifier|*
name|tok_start
init|=
name|p
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\"'
condition|)
name|p
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'L'
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
else|else
name|gdb_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|p
operator|>=
name|end
condition|)
name|error
argument_list|(
literal|"Unterminated string in expression."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\"'
condition|)
block|{
name|p
operator|++
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
name|error
argument_list|(
literal|"Newline characters may not appear in string "
literal|"constants."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|parse_escape
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|++
expr_stmt|;
block|}
name|set_token
argument_list|(
name|tok
argument_list|,
name|tok_start
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_punctuator
parameter_list|(
name|struct
name|macro_buffer
modifier|*
name|tok
parameter_list|,
name|char
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|end
parameter_list|)
block|{
comment|/* Here, speed is much less important than correctness and clarity.  */
comment|/* ISO/IEC 9899:1999 (E)  Section 6.4.6  Paragraph 1  */
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|punctuators
index|[]
init|=
block|{
literal|"["
block|,
literal|"]"
block|,
literal|"("
block|,
literal|")"
block|,
literal|"{"
block|,
literal|"}"
block|,
literal|"."
block|,
literal|"->"
block|,
literal|"++"
block|,
literal|"--"
block|,
literal|"&"
block|,
literal|"*"
block|,
literal|"+"
block|,
literal|"-"
block|,
literal|"~"
block|,
literal|"!"
block|,
literal|"/"
block|,
literal|"%"
block|,
literal|"<<"
block|,
literal|">>"
block|,
literal|"<"
block|,
literal|">"
block|,
literal|"<="
block|,
literal|">="
block|,
literal|"=="
block|,
literal|"!="
block|,
literal|"^"
block|,
literal|"|"
block|,
literal|"&&"
block|,
literal|"||"
block|,
literal|"?"
block|,
literal|":"
block|,
literal|";"
block|,
literal|"..."
block|,
literal|"="
block|,
literal|"*="
block|,
literal|"/="
block|,
literal|"%="
block|,
literal|"+="
block|,
literal|"-="
block|,
literal|"<<="
block|,
literal|">>="
block|,
literal|"&="
block|,
literal|"^="
block|,
literal|"|="
block|,
literal|","
block|,
literal|"#"
block|,
literal|"##"
block|,
literal|"<:"
block|,
literal|":>"
block|,
literal|"<%"
block|,
literal|"%>"
block|,
literal|"%:"
block|,
literal|"%:%:"
block|,
literal|0
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|p
operator|+
literal|1
operator|<=
name|end
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|punctuators
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|punctuator
init|=
name|punctuators
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
name|punctuator
index|[
literal|0
index|]
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|punctuator
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|+
name|len
operator|<=
name|end
operator|&&
operator|!
name|memcmp
argument_list|(
name|p
argument_list|,
name|punctuator
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|set_token
argument_list|(
name|tok
argument_list|,
name|p
argument_list|,
name|p
operator|+
name|len
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Peel the next preprocessor token off of SRC, and put it in TOK.    Mutate TOK to refer to the first token in SRC, and mutate SRC to    refer to the text after that token.  SRC must be a shared buffer;    the resulting TOK will be shared, pointing into the same string SRC    does.  Initialize TOK's last_token field.  Return non-zero if we    succeed, or 0 if we didn't find any more tokens in SRC.  */
end_comment

begin_function
specifier|static
name|int
name|get_token
parameter_list|(
name|struct
name|macro_buffer
modifier|*
name|tok
parameter_list|,
name|struct
name|macro_buffer
modifier|*
name|src
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|src
operator|->
name|text
decl_stmt|;
name|char
modifier|*
name|end
init|=
name|p
operator|+
name|src
operator|->
name|len
decl_stmt|;
name|gdb_assert
argument_list|(
name|src
operator|->
name|shared
argument_list|)
expr_stmt|;
comment|/* From the ISO C standard, ISO/IEC 9899:1999 (E), section 6.4:       preprocessing-token:           header-name          identifier          pp-number          character-constant          string-literal          punctuator          each non-white-space character that cannot be one of the above       We don't have to deal with header-name tokens, since those can      only occur after a #include, which we will never see.  */
while|while
condition|(
name|p
operator|<
name|end
condition|)
if|if
condition|(
name|is_whitespace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|get_comment
argument_list|(
name|tok
argument_list|,
name|p
argument_list|,
name|end
argument_list|)
condition|)
name|p
operator|+=
name|tok
operator|->
name|len
expr_stmt|;
elseif|else
if|if
condition|(
name|get_pp_number
argument_list|(
name|tok
argument_list|,
name|p
argument_list|,
name|end
argument_list|)
operator|||
name|get_character_constant
argument_list|(
name|tok
argument_list|,
name|p
argument_list|,
name|end
argument_list|)
operator|||
name|get_string_literal
argument_list|(
name|tok
argument_list|,
name|p
argument_list|,
name|end
argument_list|)
comment|/* Note: the grammar in the standard seems to be                 ambiguous: L'x' can be either a wide character                 constant, or an identifier followed by a normal                 character constant.  By trying `get_identifier' after                 we try get_character_constant and get_string_literal,                 we give the wide character syntax precedence.  Now,                 since GDB doesn't handle wide character constants                 anyway, is this the right thing to do?  */
operator|||
name|get_identifier
argument_list|(
name|tok
argument_list|,
name|p
argument_list|,
name|end
argument_list|)
operator|||
name|get_punctuator
argument_list|(
name|tok
argument_list|,
name|p
argument_list|,
name|end
argument_list|)
condition|)
block|{
comment|/* How many characters did we consume, including whitespace?  */
name|int
name|consumed
init|=
name|p
operator|-
name|src
operator|->
name|text
operator|+
name|tok
operator|->
name|len
decl_stmt|;
name|src
operator|->
name|text
operator|+=
name|consumed
expr_stmt|;
name|src
operator|->
name|len
operator|-=
name|consumed
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
comment|/* We have found a "non-whitespace character that cannot be            one of the above."  Make a token out of it.  */
name|int
name|consumed
decl_stmt|;
name|set_token
argument_list|(
name|tok
argument_list|,
name|p
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
name|consumed
operator|=
name|p
operator|-
name|src
operator|->
name|text
operator|+
name|tok
operator|->
name|len
expr_stmt|;
name|src
operator|->
name|text
operator|+=
name|consumed
expr_stmt|;
name|src
operator|->
name|len
operator|-=
name|consumed
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Appending token strings, with and without splicing  */
end_comment

begin_comment
comment|/* Append the macro buffer SRC to the end of DEST, and ensure that    doing so doesn't splice the token at the end of SRC with the token    at the beginning of DEST.  SRC and DEST must have their last_token    fields set.  Upon return, DEST's last_token field is set correctly.     For example:     If DEST is "(" and SRC is "y", then we can return with    DEST set to "(y" --- we've simply appended the two buffers.     However, if DEST is "x" and SRC is "y", then we must not return    with DEST set to "xy" --- that would splice the two tokens "x" and    "y" together to make a single token "xy".  However, it would be    fine to return with DEST set to "x y".  Similarly, "<" and "<" must    yield "<<", not "<<", etc.  */
end_comment

begin_function
specifier|static
name|void
name|append_tokens_without_splicing
parameter_list|(
name|struct
name|macro_buffer
modifier|*
name|dest
parameter_list|,
name|struct
name|macro_buffer
modifier|*
name|src
parameter_list|)
block|{
name|int
name|original_dest_len
init|=
name|dest
operator|->
name|len
decl_stmt|;
name|struct
name|macro_buffer
name|dest_tail
decl_stmt|,
name|new_token
decl_stmt|;
name|gdb_assert
argument_list|(
name|src
operator|->
name|last_token
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|dest
operator|->
name|last_token
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* First, just try appending the two, and call get_token to see if      we got a splice.  */
name|appendmem
argument_list|(
name|dest
argument_list|,
name|src
operator|->
name|text
argument_list|,
name|src
operator|->
name|len
argument_list|)
expr_stmt|;
comment|/* If DEST originally had no token abutting its end, then we can't      have spliced anything, so we're done.  */
if|if
condition|(
name|dest
operator|->
name|last_token
operator|==
name|original_dest_len
condition|)
block|{
name|dest
operator|->
name|last_token
operator|=
name|original_dest_len
operator|+
name|src
operator|->
name|last_token
expr_stmt|;
return|return;
block|}
comment|/* Set DEST_TAIL to point to the last token in DEST, followed by      all the stuff we just appended.  */
name|init_shared_buffer
argument_list|(
operator|&
name|dest_tail
argument_list|,
name|dest
operator|->
name|text
operator|+
name|dest
operator|->
name|last_token
argument_list|,
name|dest
operator|->
name|len
operator|-
name|dest
operator|->
name|last_token
argument_list|)
expr_stmt|;
comment|/* Re-parse DEST's last token.  We know that DEST used to contain      at least one token, so if it doesn't contain any after the      append, then we must have spliced "/" and "*" or "/" and "/" to      make a comment start.  (Just for the record, I got this right      the first time.  This is not a bug fix.)  */
if|if
condition|(
name|get_token
argument_list|(
operator|&
name|new_token
argument_list|,
operator|&
name|dest_tail
argument_list|)
operator|&&
operator|(
name|new_token
operator|.
name|text
operator|+
name|new_token
operator|.
name|len
operator|==
name|dest
operator|->
name|text
operator|+
name|original_dest_len
operator|)
condition|)
block|{
comment|/* No splice, so we're done.  */
name|dest
operator|->
name|last_token
operator|=
name|original_dest_len
operator|+
name|src
operator|->
name|last_token
expr_stmt|;
return|return;
block|}
comment|/* Okay, a simple append caused a splice.  Let's chop dest back to      its original length and try again, but separate the texts with a      space.  */
name|dest
operator|->
name|len
operator|=
name|original_dest_len
expr_stmt|;
name|appendc
argument_list|(
name|dest
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|appendmem
argument_list|(
name|dest
argument_list|,
name|src
operator|->
name|text
argument_list|,
name|src
operator|->
name|len
argument_list|)
expr_stmt|;
name|init_shared_buffer
argument_list|(
operator|&
name|dest_tail
argument_list|,
name|dest
operator|->
name|text
operator|+
name|dest
operator|->
name|last_token
argument_list|,
name|dest
operator|->
name|len
operator|-
name|dest
operator|->
name|last_token
argument_list|)
expr_stmt|;
comment|/* Try to re-parse DEST's last token, as above.  */
if|if
condition|(
name|get_token
argument_list|(
operator|&
name|new_token
argument_list|,
operator|&
name|dest_tail
argument_list|)
operator|&&
operator|(
name|new_token
operator|.
name|text
operator|+
name|new_token
operator|.
name|len
operator|==
name|dest
operator|->
name|text
operator|+
name|original_dest_len
operator|)
condition|)
block|{
comment|/* No splice, so we're done.  */
name|dest
operator|->
name|last_token
operator|=
name|original_dest_len
operator|+
literal|1
operator|+
name|src
operator|->
name|last_token
expr_stmt|;
return|return;
block|}
comment|/* As far as I know, there's no case where inserting a space isn't      enough to prevent a splice.  */
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"unable to avoid splicing tokens during macro expansion"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Expanding macros!  */
end_comment

begin_comment
comment|/* A singly-linked list of the names of the macros we are currently     expanding --- for detecting expansion loops.  */
end_comment

begin_struct
struct|struct
name|macro_name_list
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|macro_name_list
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Return non-zero if we are currently expanding the macro named NAME,    according to LIST; otherwise, return zero.     You know, it would be possible to get rid of all the NO_LOOP    arguments to these functions by simply generating a new lookup    function and baton which refuses to find the definition for a    particular macro, and otherwise delegates the decision to another    function/baton pair.  But that makes the linked list of excluded    macros chained through untyped baton pointers, which will make it    harder to debug.  :( */
end_comment

begin_function
specifier|static
name|int
name|currently_rescanning
parameter_list|(
name|struct
name|macro_name_list
modifier|*
name|list
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
for|for
control|(
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|list
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Gather the arguments to a macro expansion.     NAME is the name of the macro being invoked.  (It's only used for    printing error messages.)     Assume that SRC is the text of the macro invocation immediately    following the macro name.  For example, if we're processing the    text foo(bar, baz), then NAME would be foo and SRC will be (bar,    baz).     If SRC doesn't start with an open paren ( token at all, return    zero, leave SRC unchanged, and don't set *ARGC_P to anything.     If SRC doesn't contain a properly terminated argument list, then    raise an error.     Otherwise, return a pointer to the first element of an array of    macro buffers referring to the argument texts, and set *ARGC_P to    the number of arguments we found --- the number of elements in the    array.  The macro buffers share their text with SRC, and their    last_token fields are initialized.  The array is allocated with    xmalloc, and the caller is responsible for freeing it.     NOTE WELL: if SRC starts with a open paren ( token followed    immediately by a close paren ) token (e.g., the invocation looks    like "foo()"), we treat that as one argument, which happens to be    the empty list of tokens.  The caller should keep in mind that such    a sequence of tokens is a valid way to invoke one-parameter    function-like macros, but also a valid way to invoke zero-parameter    function-like macros.  Eeew.     Consume the tokens from SRC; after this call, SRC contains the text    following the invocation.  */
end_comment

begin_function
specifier|static
name|struct
name|macro_buffer
modifier|*
name|gather_arguments
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|macro_buffer
modifier|*
name|src
parameter_list|,
name|int
modifier|*
name|argc_p
parameter_list|)
block|{
name|struct
name|macro_buffer
name|tok
decl_stmt|;
name|int
name|args_len
decl_stmt|,
name|args_size
decl_stmt|;
name|struct
name|macro_buffer
modifier|*
name|args
init|=
name|NULL
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
init|=
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|args
argument_list|)
decl_stmt|;
comment|/* Does SRC start with an opening paren token?  Read from a copy of      SRC, so SRC itself is unaffected if we don't find an opening      paren.  */
block|{
name|struct
name|macro_buffer
name|temp
decl_stmt|;
name|init_shared_buffer
argument_list|(
operator|&
name|temp
argument_list|,
name|src
operator|->
name|text
argument_list|,
name|src
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_token
argument_list|(
operator|&
name|tok
argument_list|,
operator|&
name|temp
argument_list|)
operator|||
name|tok
operator|.
name|len
operator|!=
literal|1
operator|||
name|tok
operator|.
name|text
index|[
literal|0
index|]
operator|!=
literal|'('
condition|)
block|{
name|discard_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* Consume SRC's opening paren.  */
name|get_token
argument_list|(
operator|&
name|tok
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|args_len
operator|=
literal|0
expr_stmt|;
name|args_size
operator|=
literal|1
expr_stmt|;
comment|/* small for initial testing */
name|args
operator|=
operator|(
expr|struct
name|macro_buffer
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|args
argument_list|)
operator|*
name|args_size
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|macro_buffer
modifier|*
name|arg
decl_stmt|;
name|int
name|depth
decl_stmt|;
comment|/* Make sure we have room for the next argument.  */
if|if
condition|(
name|args_len
operator|>=
name|args_size
condition|)
block|{
name|args_size
operator|*=
literal|2
expr_stmt|;
name|args
operator|=
name|xrealloc
argument_list|(
name|args
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|args
argument_list|)
operator|*
name|args_size
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize the next argument.  */
name|arg
operator|=
operator|&
name|args
index|[
name|args_len
operator|++
index|]
expr_stmt|;
name|set_token
argument_list|(
name|arg
argument_list|,
name|src
operator|->
name|text
argument_list|,
name|src
operator|->
name|text
argument_list|)
expr_stmt|;
comment|/* Gather the argument's tokens.  */
name|depth
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|char
modifier|*
name|start
init|=
name|src
operator|->
name|text
decl_stmt|;
if|if
condition|(
operator|!
name|get_token
argument_list|(
operator|&
name|tok
argument_list|,
name|src
argument_list|)
condition|)
name|error
argument_list|(
literal|"Malformed argument list for macro `%s'."
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Is tok an opening paren?  */
if|if
condition|(
name|tok
operator|.
name|len
operator|==
literal|1
operator|&&
name|tok
operator|.
name|text
index|[
literal|0
index|]
operator|==
literal|'('
condition|)
name|depth
operator|++
expr_stmt|;
comment|/* Is tok is a closing paren?  */
elseif|else
if|if
condition|(
name|tok
operator|.
name|len
operator|==
literal|1
operator|&&
name|tok
operator|.
name|text
index|[
literal|0
index|]
operator|==
literal|')'
condition|)
block|{
comment|/* If it's a closing paren at the top level, then that's                  the end of the argument list.  */
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
block|{
name|discard_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
operator|*
name|argc_p
operator|=
name|args_len
expr_stmt|;
return|return
name|args
return|;
block|}
name|depth
operator|--
expr_stmt|;
block|}
comment|/* If tok is a comma at top level, then that's the end of              the current argument.  */
elseif|else
if|if
condition|(
name|tok
operator|.
name|len
operator|==
literal|1
operator|&&
name|tok
operator|.
name|text
index|[
literal|0
index|]
operator|==
literal|','
operator|&&
name|depth
operator|==
literal|0
condition|)
break|break;
comment|/* Extend the current argument to enclose this token.  If              this is the current argument's first token, leave out any              leading whitespace, just for aesthetics.  */
if|if
condition|(
name|arg
operator|->
name|len
operator|==
literal|0
condition|)
block|{
name|arg
operator|->
name|text
operator|=
name|tok
operator|.
name|text
expr_stmt|;
name|arg
operator|->
name|len
operator|=
name|tok
operator|.
name|len
expr_stmt|;
name|arg
operator|->
name|last_token
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|arg
operator|->
name|len
operator|=
operator|(
name|tok
operator|.
name|text
operator|+
name|tok
operator|.
name|len
operator|)
operator|-
name|arg
operator|->
name|text
expr_stmt|;
name|arg
operator|->
name|last_token
operator|=
name|tok
operator|.
name|text
operator|-
name|arg
operator|->
name|text
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* The `expand' and `substitute_args' functions both invoke `scan'    recursively, so we need a forward declaration somewhere.  */
end_comment

begin_function_decl
specifier|static
name|void
name|scan
parameter_list|(
name|struct
name|macro_buffer
modifier|*
name|dest
parameter_list|,
name|struct
name|macro_buffer
modifier|*
name|src
parameter_list|,
name|struct
name|macro_name_list
modifier|*
name|no_loop
parameter_list|,
name|macro_lookup_ftype
modifier|*
name|lookup_func
parameter_list|,
name|void
modifier|*
name|lookup_baton
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Given the macro definition DEF, being invoked with the actual    arguments given by ARGC and ARGV, substitute the arguments into the    replacement list, and store the result in DEST.     If it is necessary to expand macro invocations in one of the    arguments, use LOOKUP_FUNC and LOOKUP_BATON to find the macro    definitions, and don't expand invocations of the macros listed in    NO_LOOP.  */
end_comment

begin_function
specifier|static
name|void
name|substitute_args
parameter_list|(
name|struct
name|macro_buffer
modifier|*
name|dest
parameter_list|,
name|struct
name|macro_definition
modifier|*
name|def
parameter_list|,
name|int
name|argc
parameter_list|,
name|struct
name|macro_buffer
modifier|*
name|argv
parameter_list|,
name|struct
name|macro_name_list
modifier|*
name|no_loop
parameter_list|,
name|macro_lookup_ftype
modifier|*
name|lookup_func
parameter_list|,
name|void
modifier|*
name|lookup_baton
parameter_list|)
block|{
comment|/* A macro buffer for the macro's replacement list.  */
name|struct
name|macro_buffer
name|replacement_list
decl_stmt|;
name|init_shared_buffer
argument_list|(
operator|&
name|replacement_list
argument_list|,
operator|(
name|char
operator|*
operator|)
name|def
operator|->
name|replacement
argument_list|,
name|strlen
argument_list|(
name|def
operator|->
name|replacement
argument_list|)
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|dest
operator|->
name|len
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dest
operator|->
name|last_token
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|macro_buffer
name|tok
decl_stmt|;
name|char
modifier|*
name|original_rl_start
init|=
name|replacement_list
operator|.
name|text
decl_stmt|;
name|int
name|substituted
init|=
literal|0
decl_stmt|;
comment|/* Find the next token in the replacement list.  */
if|if
condition|(
operator|!
name|get_token
argument_list|(
operator|&
name|tok
argument_list|,
operator|&
name|replacement_list
argument_list|)
condition|)
break|break;
comment|/* Just for aesthetics.  If we skipped some whitespace, copy          that to DEST.  */
if|if
condition|(
name|tok
operator|.
name|text
operator|>
name|original_rl_start
condition|)
block|{
name|appendmem
argument_list|(
name|dest
argument_list|,
name|original_rl_start
argument_list|,
name|tok
operator|.
name|text
operator|-
name|original_rl_start
argument_list|)
expr_stmt|;
name|dest
operator|->
name|last_token
operator|=
name|dest
operator|->
name|len
expr_stmt|;
block|}
comment|/* Is this token the stringification operator?  */
if|if
condition|(
name|tok
operator|.
name|len
operator|==
literal|1
operator|&&
name|tok
operator|.
name|text
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
name|error
argument_list|(
literal|"Stringification is not implemented yet."
argument_list|)
expr_stmt|;
comment|/* Is this token the splicing operator?  */
if|if
condition|(
name|tok
operator|.
name|len
operator|==
literal|2
operator|&&
name|tok
operator|.
name|text
index|[
literal|0
index|]
operator|==
literal|'#'
operator|&&
name|tok
operator|.
name|text
index|[
literal|1
index|]
operator|==
literal|'#'
condition|)
name|error
argument_list|(
literal|"Token splicing is not implemented yet."
argument_list|)
expr_stmt|;
comment|/* Is this token an identifier?  */
if|if
condition|(
name|tok
operator|.
name|is_identifier
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Is it the magic varargs parameter?  */
if|if
condition|(
name|tok
operator|.
name|len
operator|==
literal|11
operator|&&
operator|!
name|memcmp
argument_list|(
name|tok
operator|.
name|text
argument_list|,
literal|"__VA_ARGS__"
argument_list|,
literal|11
argument_list|)
condition|)
name|error
argument_list|(
literal|"Variable-arity macros not implemented yet."
argument_list|)
expr_stmt|;
comment|/* Is it one of the parameters?  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|def
operator|->
name|argc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|tok
operator|.
name|len
operator|==
name|strlen
argument_list|(
name|def
operator|->
name|argv
index|[
name|i
index|]
argument_list|)
operator|&&
operator|!
name|memcmp
argument_list|(
name|tok
operator|.
name|text
argument_list|,
name|def
operator|->
name|argv
index|[
name|i
index|]
argument_list|,
name|tok
operator|.
name|len
argument_list|)
condition|)
block|{
name|struct
name|macro_buffer
name|arg_src
decl_stmt|;
comment|/* Expand any macro invocations in the argument text,                    and append the result to dest.  Remember that scan                    mutates its source, so we need to scan a new buffer                    referring to the argument's text, not the argument                    itself.  */
name|init_shared_buffer
argument_list|(
operator|&
name|arg_src
argument_list|,
name|argv
index|[
name|i
index|]
operator|.
name|text
argument_list|,
name|argv
index|[
name|i
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
name|scan
argument_list|(
name|dest
argument_list|,
operator|&
name|arg_src
argument_list|,
name|no_loop
argument_list|,
name|lookup_func
argument_list|,
name|lookup_baton
argument_list|)
expr_stmt|;
name|substituted
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* If it wasn't a parameter, then just copy it across.  */
if|if
condition|(
operator|!
name|substituted
condition|)
name|append_tokens_without_splicing
argument_list|(
name|dest
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Expand a call to a macro named ID, whose definition is DEF.  Append    its expansion to DEST.  SRC is the input text following the ID    token.  We are currently rescanning the expansions of the macros    named in NO_LOOP; don't re-expand them.  Use LOOKUP_FUNC and    LOOKUP_BATON to find definitions for any nested macro references.       Return 1 if we decided to expand it, zero otherwise.  (If it's a    function-like macro name that isn't followed by an argument list,    we don't expand it.)  If we return zero, leave SRC unchanged.  */
end_comment

begin_function
specifier|static
name|int
name|expand
parameter_list|(
specifier|const
name|char
modifier|*
name|id
parameter_list|,
name|struct
name|macro_definition
modifier|*
name|def
parameter_list|,
name|struct
name|macro_buffer
modifier|*
name|dest
parameter_list|,
name|struct
name|macro_buffer
modifier|*
name|src
parameter_list|,
name|struct
name|macro_name_list
modifier|*
name|no_loop
parameter_list|,
name|macro_lookup_ftype
modifier|*
name|lookup_func
parameter_list|,
name|void
modifier|*
name|lookup_baton
parameter_list|)
block|{
name|struct
name|macro_name_list
name|new_no_loop
decl_stmt|;
comment|/* Create a new node to be added to the front of the no-expand list.      This list is appropriate for re-scanning replacement lists, but      it is *not* appropriate for scanning macro arguments; invocations      of the macro whose arguments we are gathering *do* get expanded      there.  */
name|new_no_loop
operator|.
name|name
operator|=
name|id
expr_stmt|;
name|new_no_loop
operator|.
name|next
operator|=
name|no_loop
expr_stmt|;
comment|/* What kind of macro are we expanding?  */
if|if
condition|(
name|def
operator|->
name|kind
operator|==
name|macro_object_like
condition|)
block|{
name|struct
name|macro_buffer
name|replacement_list
decl_stmt|;
name|init_shared_buffer
argument_list|(
operator|&
name|replacement_list
argument_list|,
operator|(
name|char
operator|*
operator|)
name|def
operator|->
name|replacement
argument_list|,
name|strlen
argument_list|(
name|def
operator|->
name|replacement
argument_list|)
argument_list|)
expr_stmt|;
name|scan
argument_list|(
name|dest
argument_list|,
operator|&
name|replacement_list
argument_list|,
operator|&
name|new_no_loop
argument_list|,
name|lookup_func
argument_list|,
name|lookup_baton
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|def
operator|->
name|kind
operator|==
name|macro_function_like
condition|)
block|{
name|struct
name|cleanup
modifier|*
name|back_to
init|=
name|make_cleanup
argument_list|(
name|null_cleanup
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|struct
name|macro_buffer
modifier|*
name|argv
init|=
name|NULL
decl_stmt|;
name|struct
name|macro_buffer
name|substituted
decl_stmt|;
name|struct
name|macro_buffer
name|substituted_src
decl_stmt|;
if|if
condition|(
name|def
operator|->
name|argc
operator|>=
literal|1
operator|&&
name|strcmp
argument_list|(
name|def
operator|->
name|argv
index|[
name|def
operator|->
name|argc
operator|-
literal|1
index|]
argument_list|,
literal|"..."
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Varargs macros not implemented yet."
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
name|argv
operator|=
name|gather_arguments
argument_list|(
name|id
argument_list|,
name|src
argument_list|,
operator|&
name|argc
argument_list|)
expr_stmt|;
comment|/* If we couldn't find any argument list, then we don't expand          this macro.  */
if|if
condition|(
operator|!
name|argv
condition|)
block|{
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Check that we're passing an acceptable number of arguments for          this macro.  */
if|if
condition|(
name|argc
operator|!=
name|def
operator|->
name|argc
condition|)
block|{
comment|/* Remember that a sequence of tokens like "foo()" is a              valid invocation of a macro expecting either zero or one              arguments.  */
if|if
condition|(
operator|!
operator|(
name|argc
operator|==
literal|1
operator|&&
name|argv
index|[
literal|0
index|]
operator|.
name|len
operator|==
literal|0
operator|&&
name|def
operator|->
name|argc
operator|==
literal|0
operator|)
condition|)
name|error
argument_list|(
literal|"Wrong number of arguments to macro `%s' "
literal|"(expected %d, got %d)."
argument_list|,
name|id
argument_list|,
name|def
operator|->
name|argc
argument_list|,
name|argc
argument_list|)
expr_stmt|;
block|}
comment|/* Note that we don't expand macro invocations in the arguments          yet --- we let subst_args take care of that.  Parameters that          appear as operands of the stringifying operator "#" or the          splicing operator "##" don't get macro references expanded,          so we can't really tell whether it's appropriate to macro-          expand an argument until we see how it's being used.  */
name|init_buffer
argument_list|(
operator|&
name|substituted
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|cleanup_macro_buffer
argument_list|,
operator|&
name|substituted
argument_list|)
expr_stmt|;
name|substitute_args
argument_list|(
operator|&
name|substituted
argument_list|,
name|def
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|no_loop
argument_list|,
name|lookup_func
argument_list|,
name|lookup_baton
argument_list|)
expr_stmt|;
comment|/* Now `substituted' is the macro's replacement list, with all          argument values substituted into it properly.  Re-scan it for          macro references, but don't expand invocations of this macro.           We create a new buffer, `substituted_src', which points into          `substituted', and scan that.  We can't scan `substituted'          itself, since the tokenization process moves the buffer's          text pointer around, and we still need to be able to find          `substituted's original text buffer after scanning it so we          can free it.  */
name|init_shared_buffer
argument_list|(
operator|&
name|substituted_src
argument_list|,
name|substituted
operator|.
name|text
argument_list|,
name|substituted
operator|.
name|len
argument_list|)
expr_stmt|;
name|scan
argument_list|(
name|dest
argument_list|,
operator|&
name|substituted_src
argument_list|,
operator|&
name|new_no_loop
argument_list|,
name|lookup_func
argument_list|,
name|lookup_baton
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"bad macro definition kind"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If the single token in SRC_FIRST followed by the tokens in SRC_REST    constitute a macro invokation not forbidden in NO_LOOP, append its    expansion to DEST and return non-zero.  Otherwise, return zero, and    leave DEST unchanged.     SRC_FIRST and SRC_REST must be shared buffers; DEST must not be one.    SRC_FIRST must be a string built by get_token.  */
end_comment

begin_function
specifier|static
name|int
name|maybe_expand
parameter_list|(
name|struct
name|macro_buffer
modifier|*
name|dest
parameter_list|,
name|struct
name|macro_buffer
modifier|*
name|src_first
parameter_list|,
name|struct
name|macro_buffer
modifier|*
name|src_rest
parameter_list|,
name|struct
name|macro_name_list
modifier|*
name|no_loop
parameter_list|,
name|macro_lookup_ftype
modifier|*
name|lookup_func
parameter_list|,
name|void
modifier|*
name|lookup_baton
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|src_first
operator|->
name|shared
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|src_rest
operator|->
name|shared
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
operator|!
name|dest
operator|->
name|shared
argument_list|)
expr_stmt|;
comment|/* Is this token an identifier?  */
if|if
condition|(
name|src_first
operator|->
name|is_identifier
condition|)
block|{
comment|/* Make a null-terminated copy of it, since that's what our          lookup function expects.  */
name|char
modifier|*
name|id
init|=
name|xmalloc
argument_list|(
name|src_first
operator|->
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
init|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|id
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|id
argument_list|,
name|src_first
operator|->
name|text
argument_list|,
name|src_first
operator|->
name|len
argument_list|)
expr_stmt|;
name|id
index|[
name|src_first
operator|->
name|len
index|]
operator|=
literal|0
expr_stmt|;
comment|/* If we're currently re-scanning the result of expanding          this macro, don't expand it again.  */
if|if
condition|(
operator|!
name|currently_rescanning
argument_list|(
name|no_loop
argument_list|,
name|id
argument_list|)
condition|)
block|{
comment|/* Does this identifier have a macro definition in scope?  */
name|struct
name|macro_definition
modifier|*
name|def
init|=
name|lookup_func
argument_list|(
name|id
argument_list|,
name|lookup_baton
argument_list|)
decl_stmt|;
if|if
condition|(
name|def
operator|&&
name|expand
argument_list|(
name|id
argument_list|,
name|def
argument_list|,
name|dest
argument_list|,
name|src_rest
argument_list|,
name|no_loop
argument_list|,
name|lookup_func
argument_list|,
name|lookup_baton
argument_list|)
condition|)
block|{
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Expand macro references in SRC, appending the results to DEST.    Assume we are re-scanning the result of expanding the macros named    in NO_LOOP, and don't try to re-expand references to them.     SRC must be a shared buffer; DEST must not be one.  */
end_comment

begin_function
specifier|static
name|void
name|scan
parameter_list|(
name|struct
name|macro_buffer
modifier|*
name|dest
parameter_list|,
name|struct
name|macro_buffer
modifier|*
name|src
parameter_list|,
name|struct
name|macro_name_list
modifier|*
name|no_loop
parameter_list|,
name|macro_lookup_ftype
modifier|*
name|lookup_func
parameter_list|,
name|void
modifier|*
name|lookup_baton
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|src
operator|->
name|shared
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
operator|!
name|dest
operator|->
name|shared
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|macro_buffer
name|tok
decl_stmt|;
name|char
modifier|*
name|original_src_start
init|=
name|src
operator|->
name|text
decl_stmt|;
comment|/* Find the next token in SRC.  */
if|if
condition|(
operator|!
name|get_token
argument_list|(
operator|&
name|tok
argument_list|,
name|src
argument_list|)
condition|)
break|break;
comment|/* Just for aesthetics.  If we skipped some whitespace, copy          that to DEST.  */
if|if
condition|(
name|tok
operator|.
name|text
operator|>
name|original_src_start
condition|)
block|{
name|appendmem
argument_list|(
name|dest
argument_list|,
name|original_src_start
argument_list|,
name|tok
operator|.
name|text
operator|-
name|original_src_start
argument_list|)
expr_stmt|;
name|dest
operator|->
name|last_token
operator|=
name|dest
operator|->
name|len
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|maybe_expand
argument_list|(
name|dest
argument_list|,
operator|&
name|tok
argument_list|,
name|src
argument_list|,
name|no_loop
argument_list|,
name|lookup_func
argument_list|,
name|lookup_baton
argument_list|)
condition|)
comment|/* We didn't end up expanding tok as a macro reference, so            simply append it to dest.  */
name|append_tokens_without_splicing
argument_list|(
name|dest
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
block|}
comment|/* Just for aesthetics.  If there was any trailing whitespace in      src, copy it to dest.  */
if|if
condition|(
name|src
operator|->
name|len
condition|)
block|{
name|appendmem
argument_list|(
name|dest
argument_list|,
name|src
operator|->
name|text
argument_list|,
name|src
operator|->
name|len
argument_list|)
expr_stmt|;
name|dest
operator|->
name|last_token
operator|=
name|dest
operator|->
name|len
expr_stmt|;
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|macro_expand
parameter_list|(
specifier|const
name|char
modifier|*
name|source
parameter_list|,
name|macro_lookup_ftype
modifier|*
name|lookup_func
parameter_list|,
name|void
modifier|*
name|lookup_func_baton
parameter_list|)
block|{
name|struct
name|macro_buffer
name|src
decl_stmt|,
name|dest
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
decl_stmt|;
name|init_shared_buffer
argument_list|(
operator|&
name|src
argument_list|,
operator|(
name|char
operator|*
operator|)
name|source
argument_list|,
name|strlen
argument_list|(
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|init_buffer
argument_list|(
operator|&
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dest
operator|.
name|last_token
operator|=
literal|0
expr_stmt|;
name|back_to
operator|=
name|make_cleanup
argument_list|(
name|cleanup_macro_buffer
argument_list|,
operator|&
name|dest
argument_list|)
expr_stmt|;
name|scan
argument_list|(
operator|&
name|dest
argument_list|,
operator|&
name|src
argument_list|,
literal|0
argument_list|,
name|lookup_func
argument_list|,
name|lookup_func_baton
argument_list|)
expr_stmt|;
name|appendc
argument_list|(
operator|&
name|dest
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|discard_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
return|return
name|dest
operator|.
name|text
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|macro_expand_once
parameter_list|(
specifier|const
name|char
modifier|*
name|source
parameter_list|,
name|macro_lookup_ftype
modifier|*
name|lookup_func
parameter_list|,
name|void
modifier|*
name|lookup_func_baton
parameter_list|)
block|{
name|error
argument_list|(
literal|"Expand-once not implemented yet."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|macro_expand_next
parameter_list|(
name|char
modifier|*
modifier|*
name|lexptr
parameter_list|,
name|macro_lookup_ftype
modifier|*
name|lookup_func
parameter_list|,
name|void
modifier|*
name|lookup_baton
parameter_list|)
block|{
name|struct
name|macro_buffer
name|src
decl_stmt|,
name|dest
decl_stmt|,
name|tok
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
decl_stmt|;
comment|/* Set up SRC to refer to the input text, pointed to by *lexptr.  */
name|init_shared_buffer
argument_list|(
operator|&
name|src
argument_list|,
operator|*
name|lexptr
argument_list|,
name|strlen
argument_list|(
operator|*
name|lexptr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set up DEST to receive the expansion, if there is one.  */
name|init_buffer
argument_list|(
operator|&
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dest
operator|.
name|last_token
operator|=
literal|0
expr_stmt|;
name|back_to
operator|=
name|make_cleanup
argument_list|(
name|cleanup_macro_buffer
argument_list|,
operator|&
name|dest
argument_list|)
expr_stmt|;
comment|/* Get the text's first preprocessing token.  */
if|if
condition|(
operator|!
name|get_token
argument_list|(
operator|&
name|tok
argument_list|,
operator|&
name|src
argument_list|)
condition|)
block|{
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* If it's a macro invocation, expand it.  */
if|if
condition|(
name|maybe_expand
argument_list|(
operator|&
name|dest
argument_list|,
operator|&
name|tok
argument_list|,
operator|&
name|src
argument_list|,
literal|0
argument_list|,
name|lookup_func
argument_list|,
name|lookup_baton
argument_list|)
condition|)
block|{
comment|/* It was a macro invocation!  Package up the expansion as a          null-terminated string and return it.  Set *lexptr to the          start of the next token in the input.  */
name|appendc
argument_list|(
operator|&
name|dest
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|discard_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
operator|*
name|lexptr
operator|=
name|src
operator|.
name|text
expr_stmt|;
return|return
name|dest
operator|.
name|text
return|;
block|}
else|else
block|{
comment|/* It wasn't a macro invocation.  */
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

end_unit

