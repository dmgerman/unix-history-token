begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Support for printing Chill types for GDB, the GNU debugger.    Copyright 1986, 1988, 1989, 1991 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_comment
comment|/* Binary File Description */
end_comment

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"ch-lang.h"
end_include

begin_include
include|#
directive|include
file|"typeprint.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_decl_stmt
specifier|static
name|void
name|chill_type_print_base
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|,
name|GDB_FILE
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|chill_print_type
parameter_list|(
name|type
parameter_list|,
name|varstring
parameter_list|,
name|stream
parameter_list|,
name|show
parameter_list|,
name|level
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|varstring
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|show
decl_stmt|;
name|int
name|level
decl_stmt|;
block|{
if|if
condition|(
name|varstring
operator|!=
name|NULL
operator|&&
operator|*
name|varstring
operator|!=
literal|'\0'
condition|)
block|{
name|fputs_filtered
argument_list|(
name|varstring
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|chill_type_print_base
argument_list|(
name|type
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the name of the type (or the ultimate pointer target,    function value or array element).     SHOW nonzero means don't print this type as just its name;    show its real definition even if it has a name.    SHOW zero means print just typename or tag if there is one    SHOW negative means abbreviate structure elements.    SHOW is decremented for printing of structure elements.     LEVEL is the depth to indent by.    We increase it for some recursive calls.  */
end_comment

begin_function
specifier|static
name|void
name|chill_type_print_base
parameter_list|(
name|type
parameter_list|,
name|stream
parameter_list|,
name|show
parameter_list|,
name|level
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|show
decl_stmt|;
name|int
name|level
decl_stmt|;
block|{
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|type
modifier|*
name|index_type
decl_stmt|;
name|struct
name|type
modifier|*
name|range_type
decl_stmt|;
name|LONGEST
name|low_bound
decl_stmt|;
name|LONGEST
name|high_bound
decl_stmt|;
name|QUIT
expr_stmt|;
name|wrap_here
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"<type unknown>"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* When SHOW is zero or less, and there is a valid type name, then always      just print the type name directly from the type. */
if|if
condition|(
operator|(
name|show
operator|<=
literal|0
operator|)
operator|&&
operator|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|fputs_filtered
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_TYPEDEF
condition|)
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_TYPEDEF
case|:
name|chill_type_print_base
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|level
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_PTR
case|:
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_VOID
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
condition|?
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
else|:
literal|"PTR"
argument_list|)
expr_stmt|;
break|break;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"REF "
argument_list|)
expr_stmt|;
name|chill_type_print_base
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|level
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_BOOL
case|:
comment|/* FIXME: we should probably just print the TYPE_NAME, in case 	   anyone ever fixes the compiler to give us the real names 	   in the presence of the chill equivalent of typedef (assuming 	   there is one).  */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
condition|?
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
else|:
literal|"BOOL"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_ARRAY
case|:
name|fputs_filtered
argument_list|(
literal|"ARRAY ("
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|range_type
operator|=
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|range_type
argument_list|)
operator|!=
name|TYPE_CODE_RANGE
condition|)
name|chill_print_type
argument_list|(
name|range_type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|level
argument_list|)
expr_stmt|;
else|else
block|{
name|index_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|range_type
argument_list|)
expr_stmt|;
name|low_bound
operator|=
name|TYPE_FIELD_BITPOS
argument_list|(
name|range_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|high_bound
operator|=
name|TYPE_FIELD_BITPOS
argument_list|(
name|range_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|print_type_scalar
argument_list|(
name|index_type
argument_list|,
name|low_bound
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|":"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_type_scalar
argument_list|(
name|index_type
argument_list|,
name|high_bound
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
literal|") "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|chill_print_type
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|level
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_BITSTRING
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"BOOLS (%d)"
argument_list|,
name|TYPE_FIELD_BITPOS
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_SET
case|:
name|fputs_filtered
argument_list|(
literal|"POWERSET "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|chill_print_type
argument_list|(
name|TYPE_INDEX_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
name|show
operator|-
literal|1
argument_list|,
name|level
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_STRING
case|:
name|range_type
operator|=
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|index_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|range_type
argument_list|)
expr_stmt|;
name|high_bound
operator|=
name|TYPE_FIELD_BITPOS
argument_list|(
name|range_type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"CHARS ("
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_type_scalar
argument_list|(
name|index_type
argument_list|,
name|high_bound
operator|+
literal|1
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|")"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_MEMBER
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"MEMBER "
argument_list|)
expr_stmt|;
name|chill_type_print_base
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|level
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_REF
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"/*LOC*/ "
argument_list|)
expr_stmt|;
name|chill_type_print_base
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
name|level
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_FUNC
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"PROC ("
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|type
modifier|*
name|param_type
init|=
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|param_type
argument_list|)
operator|==
name|TYPE_CODE_REF
condition|)
block|{
name|chill_type_print_base
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|param_type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" LOC"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
name|chill_type_print_base
argument_list|(
name|param_type
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
name|level
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_VOID
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|" RETURNS ("
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|chill_type_print_base
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|")"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_STRUCT
case|:
if|if
condition|(
name|chill_varying_type
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|chill_type_print_base
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" VARYING"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"STRUCT "
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"(\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&
name|TYPE_FLAG_STUB
condition|)
block|{
name|fprintfi_filtered
argument_list|(
name|level
operator|+
literal|4
argument_list|,
name|stream
argument_list|,
literal|"<incomplete type>\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintfi_filtered
argument_list|(
name|level
operator|+
literal|4
argument_list|,
name|stream
argument_list|,
literal|"<no data fields>\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|len
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|type
modifier|*
name|field_type
init|=
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|QUIT
expr_stmt|;
name|print_spaces_filtered
argument_list|(
name|level
operator|+
literal|4
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|field_type
argument_list|)
operator|==
name|TYPE_CODE_UNION
condition|)
block|{
name|int
name|j
decl_stmt|;
comment|/* variant number */
name|fputs_filtered
argument_list|(
literal|"CASE OF\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|TYPE_NFIELDS
argument_list|(
name|field_type
argument_list|)
condition|;
name|j
operator|++
control|)
block|{
name|int
name|k
decl_stmt|;
comment|/* variant field index */
name|struct
name|type
modifier|*
name|variant_type
init|=
name|TYPE_FIELD_TYPE
argument_list|(
name|field_type
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|int
name|var_len
init|=
name|TYPE_NFIELDS
argument_list|(
name|variant_type
argument_list|)
decl_stmt|;
name|print_spaces_filtered
argument_list|(
name|level
operator|+
literal|4
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|field_type
argument_list|,
name|j
argument_list|)
argument_list|,
literal|"else"
argument_list|)
operator|==
literal|0
condition|)
name|fputs_filtered
argument_list|(
literal|"ELSE\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|":\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|variant_type
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
condition|)
name|error
argument_list|(
literal|"variant record confusion"
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|var_len
condition|;
name|k
operator|++
control|)
block|{
name|print_spaces_filtered
argument_list|(
name|level
operator|+
literal|8
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|chill_print_type
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|variant_type
argument_list|,
name|k
argument_list|)
argument_list|,
name|TYPE_FIELD_NAME
argument_list|(
name|variant_type
argument_list|,
name|k
argument_list|)
argument_list|,
name|stream
argument_list|,
name|show
operator|-
literal|1
argument_list|,
name|level
operator|+
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|<
operator|(
name|var_len
operator|-
literal|1
operator|)
condition|)
name|fputs_filtered
argument_list|(
literal|","
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
name|print_spaces_filtered
argument_list|(
name|level
operator|+
literal|4
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"ESAC"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
name|chill_print_type
argument_list|(
name|field_type
argument_list|,
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|stream
argument_list|,
name|show
operator|-
literal|1
argument_list|,
name|level
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
operator|(
name|len
operator|-
literal|1
operator|)
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|","
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
literal|"\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintfi_filtered
argument_list|(
name|level
argument_list|,
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_RANGE
case|:
block|{
name|struct
name|type
modifier|*
name|target
init|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|target
operator|&&
name|TYPE_NAME
argument_list|(
name|target
argument_list|)
condition|)
name|fputs_filtered
argument_list|(
name|TYPE_NAME
argument_list|(
name|target
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|"RANGE"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
name|NULL
condition|)
name|target
operator|=
name|builtin_type_long
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" ("
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_type_scalar
argument_list|(
name|target
argument_list|,
name|TYPE_LOW_BOUND
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|":"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_type_scalar
argument_list|(
name|target
argument_list|,
name|TYPE_HIGH_BOUND
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|")"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_ENUM
case|:
block|{
specifier|register
name|int
name|lastval
init|=
literal|0
decl_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"SET ("
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastval
operator|!=
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" = %d"
argument_list|,
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|lastval
operator|=
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|lastval
operator|++
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_VOID
case|:
case|case
name|TYPE_CODE_UNDEF
case|:
case|case
name|TYPE_CODE_ERROR
case|:
case|case
name|TYPE_CODE_UNION
case|:
case|case
name|TYPE_CODE_METHOD
case|:
name|error
argument_list|(
literal|"missing language support in chill_type_print_base"
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Handle types not explicitly handled by the other cases, 	   such as fundamental types.  For these, just print whatever 	   the type name is, as recorded in the type itself.  If there 	   is no type name, then complain. */
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|fputs_filtered
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"Unrecognized type code (%d) in symbol table."
argument_list|,
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

end_unit

