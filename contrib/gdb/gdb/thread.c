begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Multi-process/thread control for GDB, the GNU debugger.    Copyright 1986, 1987, 1988, 1993, 1998     Contributed by Lynx Real-Time Systems, Inc.  Los Gatos, CA.    Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"environ.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbthread.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_comment
comment|/*#include "lynxos-core.h"*/
end_comment

begin_struct
struct|struct
name|thread_info
block|{
name|struct
name|thread_info
modifier|*
name|next
decl_stmt|;
name|int
name|pid
decl_stmt|;
comment|/* Actual process id */
name|int
name|num
decl_stmt|;
comment|/* Convenient handle */
name|CORE_ADDR
name|prev_pc
decl_stmt|;
comment|/* State from wait_for_inferior */
name|CORE_ADDR
name|prev_func_start
decl_stmt|;
name|char
modifier|*
name|prev_func_name
decl_stmt|;
name|struct
name|breakpoint
modifier|*
name|step_resume_breakpoint
decl_stmt|;
name|struct
name|breakpoint
modifier|*
name|through_sigtramp_breakpoint
decl_stmt|;
name|CORE_ADDR
name|step_range_start
decl_stmt|;
name|CORE_ADDR
name|step_range_end
decl_stmt|;
name|CORE_ADDR
name|step_frame_address
decl_stmt|;
name|int
name|trap_expected
decl_stmt|;
name|int
name|handling_longjmp
decl_stmt|;
name|int
name|another_trap
decl_stmt|;
comment|/* This is set TRUE when a catchpoint of a shared library event      triggers.  Since we don't wish to leave the inferior in the      solib hook when we report the event, we step the inferior      back to user code before stopping and reporting the event.      */
name|int
name|stepping_through_solib_after_catch
decl_stmt|;
comment|/* When stepping_through_solib_after_catch is TRUE, this is a      list of the catchpoints that should be reported as triggering      when we finally do stop stepping.      */
name|bpstat
name|stepping_through_solib_catchpoints
decl_stmt|;
comment|/* This is set to TRUE when this thread is in a signal handler      trampoline and we're single-stepping through it */
name|int
name|stepping_through_sigtramp
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Prototypes for exported functions. */
end_comment

begin_decl_stmt
name|void
name|_initialize_thread
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prototypes for local functions. */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|FIND_NEW_THREADS
argument_list|)
end_if

begin_define
define|#
directive|define
name|FIND_NEW_THREADS
value|target_find_new_threads
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|thread_info
modifier|*
name|thread_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|highest_thread_num
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|thread_info
modifier|*
name|find_thread_id
name|PARAMS
argument_list|(
operator|(
name|int
name|num
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|thread_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|tidstr
operator|,
name|int
name|from_tty
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|thread_apply_all_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|thread_alive
name|PARAMS
argument_list|(
operator|(
expr|struct
name|thread_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|info_threads_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|thread_apply_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|restore_current_thread
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|switch_to_thread
name|PARAMS
argument_list|(
operator|(
name|int
name|pid
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|prune_threads
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If the host has threads, the host machine definition may set this    macro. But, for remote thread debugging, it gets more complex and    setting macros does not bind to the various target dependent    methods well. So, we use the vector target_thread_functions */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|target_thread_vector
modifier|*
name|target_thread_functions
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|target_find_new_threads
parameter_list|()
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|target_thread_functions
operator|&&
name|target_thread_functions
operator|->
name|find_new_threads
condition|)
name|retval
operator|=
operator|(
operator|*
operator|(
name|target_thread_functions
operator|->
name|find_new_threads
operator|)
operator|)
operator|(
operator|)
expr_stmt|;
return|return
name|retval
return|;
comment|/* no support */
block|}
end_function

begin_decl_stmt
name|int
name|target_get_thread_info
name|PARAMS
argument_list|(
operator|(
name|gdb_threadref
operator|*
name|ref
operator|,
name|int
name|selection
operator|,
comment|/* FIXME: Selection */
expr|struct
name|gdb_ext_thread_info
operator|*
name|info
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|target_get_thread_info
parameter_list|(
name|ref
parameter_list|,
name|selection
parameter_list|,
name|info
parameter_list|)
name|gdb_threadref
modifier|*
name|ref
decl_stmt|;
name|int
name|selection
decl_stmt|;
comment|/* FIXME: Selection */
name|struct
name|gdb_ext_thread_info
modifier|*
name|info
decl_stmt|;
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|target_thread_functions
operator|&&
name|target_thread_functions
operator|->
name|get_thread_info
condition|)
name|retval
operator|=
operator|(
operator|*
operator|(
name|target_thread_functions
operator|->
name|get_thread_info
operator|)
operator|)
operator|(
name|ref
operator|,
name|selection
operator|,
name|info
operator|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* It is possible that these bind and unbinf functions implement a    stack the interface allows it, but its not implemented that way  */
end_comment

begin_function
name|void
name|bind_target_thread_vector
parameter_list|(
name|vec
parameter_list|)
name|struct
name|target_thread_vector
modifier|*
name|vec
decl_stmt|;
block|{
name|target_thread_functions
operator|=
name|vec
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|target_thread_vector
modifier|*
name|unbind_target_thread_vector
parameter_list|()
block|{
name|struct
name|target_thread_vector
modifier|*
name|retval
decl_stmt|;
name|retval
operator|=
name|target_thread_functions
expr_stmt|;
name|target_thread_functions
operator|=
literal|0
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* unbind_target_thread-vector */
end_comment

begin_function
name|void
name|init_thread_list
parameter_list|()
block|{
name|struct
name|thread_info
modifier|*
name|tp
decl_stmt|,
modifier|*
name|tpnext
decl_stmt|;
if|if
condition|(
operator|!
name|thread_list
condition|)
return|return;
for|for
control|(
name|tp
operator|=
name|thread_list
init|;
name|tp
condition|;
name|tp
operator|=
name|tpnext
control|)
block|{
name|tpnext
operator|=
name|tp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
name|thread_list
operator|=
name|NULL
expr_stmt|;
name|highest_thread_num
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add_thread
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|struct
name|thread_info
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
operator|(
expr|struct
name|thread_info
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|thread_info
argument_list|)
argument_list|)
expr_stmt|;
name|tp
operator|->
name|pid
operator|=
name|pid
expr_stmt|;
name|tp
operator|->
name|num
operator|=
operator|++
name|highest_thread_num
expr_stmt|;
name|tp
operator|->
name|prev_pc
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|prev_func_start
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|prev_func_name
operator|=
name|NULL
expr_stmt|;
name|tp
operator|->
name|step_range_start
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|step_range_end
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|step_frame_address
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|step_resume_breakpoint
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|through_sigtramp_breakpoint
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|handling_longjmp
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|trap_expected
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|another_trap
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|stepping_through_solib_after_catch
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|stepping_through_solib_catchpoints
operator|=
name|NULL
expr_stmt|;
name|tp
operator|->
name|stepping_through_sigtramp
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|next
operator|=
name|thread_list
expr_stmt|;
name|thread_list
operator|=
name|tp
expr_stmt|;
block|}
end_function

begin_function
name|void
name|delete_thread
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|struct
name|thread_info
modifier|*
name|tp
decl_stmt|,
modifier|*
name|tpprev
decl_stmt|;
name|tpprev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|tp
operator|=
name|thread_list
init|;
name|tp
condition|;
name|tpprev
operator|=
name|tp
operator|,
name|tp
operator|=
name|tp
operator|->
name|next
control|)
if|if
condition|(
name|tp
operator|->
name|pid
operator|==
name|pid
condition|)
break|break;
if|if
condition|(
operator|!
name|tp
condition|)
return|return;
if|if
condition|(
name|tpprev
condition|)
name|tpprev
operator|->
name|next
operator|=
name|tp
operator|->
name|next
expr_stmt|;
else|else
name|thread_list
operator|=
name|tp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|struct
name|thread_info
modifier|*
name|find_thread_id
parameter_list|(
name|num
parameter_list|)
name|int
name|num
decl_stmt|;
block|{
name|struct
name|thread_info
modifier|*
name|tp
decl_stmt|;
for|for
control|(
name|tp
operator|=
name|thread_list
init|;
name|tp
condition|;
name|tp
operator|=
name|tp
operator|->
name|next
control|)
if|if
condition|(
name|tp
operator|->
name|num
operator|==
name|num
condition|)
return|return
name|tp
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|valid_thread_id
parameter_list|(
name|num
parameter_list|)
name|int
name|num
decl_stmt|;
block|{
name|struct
name|thread_info
modifier|*
name|tp
decl_stmt|;
for|for
control|(
name|tp
operator|=
name|thread_list
init|;
name|tp
condition|;
name|tp
operator|=
name|tp
operator|->
name|next
control|)
if|if
condition|(
name|tp
operator|->
name|num
operator|==
name|num
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|pid_to_thread_id
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|struct
name|thread_info
modifier|*
name|tp
decl_stmt|;
for|for
control|(
name|tp
operator|=
name|thread_list
init|;
name|tp
condition|;
name|tp
operator|=
name|tp
operator|->
name|next
control|)
if|if
condition|(
name|tp
operator|->
name|pid
operator|==
name|pid
condition|)
return|return
name|tp
operator|->
name|num
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|thread_id_to_pid
parameter_list|(
name|num
parameter_list|)
name|int
name|num
decl_stmt|;
block|{
name|struct
name|thread_info
modifier|*
name|thread
init|=
name|find_thread_id
argument_list|(
name|num
argument_list|)
decl_stmt|;
if|if
condition|(
name|thread
condition|)
return|return
name|thread
operator|->
name|pid
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|in_thread_list
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|struct
name|thread_info
modifier|*
name|tp
decl_stmt|;
for|for
control|(
name|tp
operator|=
name|thread_list
init|;
name|tp
condition|;
name|tp
operator|=
name|tp
operator|->
name|next
control|)
if|if
condition|(
name|tp
operator|->
name|pid
operator|==
name|pid
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
comment|/* Never heard of 'im */
block|}
end_function

begin_comment
comment|/* Load infrun state for the thread PID.  */
end_comment

begin_function
name|void
name|load_infrun_state
parameter_list|(
name|pid
parameter_list|,
name|prev_pc
parameter_list|,
name|prev_func_start
parameter_list|,
name|prev_func_name
parameter_list|,
name|trap_expected
parameter_list|,
name|step_resume_breakpoint
parameter_list|,
name|through_sigtramp_breakpoint
parameter_list|,
name|step_range_start
parameter_list|,
name|step_range_end
parameter_list|,
name|step_frame_address
parameter_list|,
name|handling_longjmp
parameter_list|,
name|another_trap
parameter_list|,
name|stepping_through_solib_after_catch
parameter_list|,
name|stepping_through_solib_catchpoints
parameter_list|,
name|stepping_through_sigtramp
parameter_list|)
name|int
name|pid
decl_stmt|;
name|CORE_ADDR
modifier|*
name|prev_pc
decl_stmt|;
name|CORE_ADDR
modifier|*
name|prev_func_start
decl_stmt|;
name|char
modifier|*
modifier|*
name|prev_func_name
decl_stmt|;
name|int
modifier|*
name|trap_expected
decl_stmt|;
name|struct
name|breakpoint
modifier|*
modifier|*
name|step_resume_breakpoint
decl_stmt|;
name|struct
name|breakpoint
modifier|*
modifier|*
name|through_sigtramp_breakpoint
decl_stmt|;
name|CORE_ADDR
modifier|*
name|step_range_start
decl_stmt|;
name|CORE_ADDR
modifier|*
name|step_range_end
decl_stmt|;
name|CORE_ADDR
modifier|*
name|step_frame_address
decl_stmt|;
name|int
modifier|*
name|handling_longjmp
decl_stmt|;
name|int
modifier|*
name|another_trap
decl_stmt|;
name|int
modifier|*
name|stepping_through_solib_after_catch
decl_stmt|;
name|bpstat
modifier|*
name|stepping_through_solib_catchpoints
decl_stmt|;
name|int
modifier|*
name|stepping_through_sigtramp
decl_stmt|;
block|{
name|struct
name|thread_info
modifier|*
name|tp
decl_stmt|;
comment|/* If we can't find the thread, then we're debugging a single threaded      process.  No need to do anything in that case.  */
name|tp
operator|=
name|find_thread_id
argument_list|(
name|pid_to_thread_id
argument_list|(
name|pid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
return|return;
operator|*
name|prev_pc
operator|=
name|tp
operator|->
name|prev_pc
expr_stmt|;
operator|*
name|prev_func_start
operator|=
name|tp
operator|->
name|prev_func_start
expr_stmt|;
operator|*
name|prev_func_name
operator|=
name|tp
operator|->
name|prev_func_name
expr_stmt|;
operator|*
name|step_resume_breakpoint
operator|=
name|tp
operator|->
name|step_resume_breakpoint
expr_stmt|;
operator|*
name|step_range_start
operator|=
name|tp
operator|->
name|step_range_start
expr_stmt|;
operator|*
name|step_range_end
operator|=
name|tp
operator|->
name|step_range_end
expr_stmt|;
operator|*
name|step_frame_address
operator|=
name|tp
operator|->
name|step_frame_address
expr_stmt|;
operator|*
name|through_sigtramp_breakpoint
operator|=
name|tp
operator|->
name|through_sigtramp_breakpoint
expr_stmt|;
operator|*
name|handling_longjmp
operator|=
name|tp
operator|->
name|handling_longjmp
expr_stmt|;
operator|*
name|trap_expected
operator|=
name|tp
operator|->
name|trap_expected
expr_stmt|;
operator|*
name|another_trap
operator|=
name|tp
operator|->
name|another_trap
expr_stmt|;
operator|*
name|stepping_through_solib_after_catch
operator|=
name|tp
operator|->
name|stepping_through_solib_after_catch
expr_stmt|;
operator|*
name|stepping_through_solib_catchpoints
operator|=
name|tp
operator|->
name|stepping_through_solib_catchpoints
expr_stmt|;
operator|*
name|stepping_through_sigtramp
operator|=
name|tp
operator|->
name|stepping_through_sigtramp
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Save infrun state for the thread PID.  */
end_comment

begin_function
name|void
name|save_infrun_state
parameter_list|(
name|pid
parameter_list|,
name|prev_pc
parameter_list|,
name|prev_func_start
parameter_list|,
name|prev_func_name
parameter_list|,
name|trap_expected
parameter_list|,
name|step_resume_breakpoint
parameter_list|,
name|through_sigtramp_breakpoint
parameter_list|,
name|step_range_start
parameter_list|,
name|step_range_end
parameter_list|,
name|step_frame_address
parameter_list|,
name|handling_longjmp
parameter_list|,
name|another_trap
parameter_list|,
name|stepping_through_solib_after_catch
parameter_list|,
name|stepping_through_solib_catchpoints
parameter_list|,
name|stepping_through_sigtramp
parameter_list|)
name|int
name|pid
decl_stmt|;
name|CORE_ADDR
name|prev_pc
decl_stmt|;
name|CORE_ADDR
name|prev_func_start
decl_stmt|;
name|char
modifier|*
name|prev_func_name
decl_stmt|;
name|int
name|trap_expected
decl_stmt|;
name|struct
name|breakpoint
modifier|*
name|step_resume_breakpoint
decl_stmt|;
name|struct
name|breakpoint
modifier|*
name|through_sigtramp_breakpoint
decl_stmt|;
name|CORE_ADDR
name|step_range_start
decl_stmt|;
name|CORE_ADDR
name|step_range_end
decl_stmt|;
name|CORE_ADDR
name|step_frame_address
decl_stmt|;
name|int
name|handling_longjmp
decl_stmt|;
name|int
name|another_trap
decl_stmt|;
name|int
name|stepping_through_solib_after_catch
decl_stmt|;
name|bpstat
name|stepping_through_solib_catchpoints
decl_stmt|;
name|int
name|stepping_through_sigtramp
decl_stmt|;
block|{
name|struct
name|thread_info
modifier|*
name|tp
decl_stmt|;
comment|/* If we can't find the thread, then we're debugging a single-threaded      process.  Nothing to do in that case.  */
name|tp
operator|=
name|find_thread_id
argument_list|(
name|pid_to_thread_id
argument_list|(
name|pid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
return|return;
name|tp
operator|->
name|prev_pc
operator|=
name|prev_pc
expr_stmt|;
name|tp
operator|->
name|prev_func_start
operator|=
name|prev_func_start
expr_stmt|;
name|tp
operator|->
name|prev_func_name
operator|=
name|prev_func_name
expr_stmt|;
name|tp
operator|->
name|step_resume_breakpoint
operator|=
name|step_resume_breakpoint
expr_stmt|;
name|tp
operator|->
name|step_range_start
operator|=
name|step_range_start
expr_stmt|;
name|tp
operator|->
name|step_range_end
operator|=
name|step_range_end
expr_stmt|;
name|tp
operator|->
name|step_frame_address
operator|=
name|step_frame_address
expr_stmt|;
name|tp
operator|->
name|through_sigtramp_breakpoint
operator|=
name|through_sigtramp_breakpoint
expr_stmt|;
name|tp
operator|->
name|handling_longjmp
operator|=
name|handling_longjmp
expr_stmt|;
name|tp
operator|->
name|trap_expected
operator|=
name|trap_expected
expr_stmt|;
name|tp
operator|->
name|another_trap
operator|=
name|another_trap
expr_stmt|;
name|tp
operator|->
name|stepping_through_solib_after_catch
operator|=
name|stepping_through_solib_after_catch
expr_stmt|;
name|tp
operator|->
name|stepping_through_solib_catchpoints
operator|=
name|stepping_through_solib_catchpoints
expr_stmt|;
name|tp
operator|->
name|stepping_through_sigtramp
operator|=
name|stepping_through_sigtramp
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return true if TP is an active thread. */
end_comment

begin_function
specifier|static
name|int
name|thread_alive
parameter_list|(
name|tp
parameter_list|)
name|struct
name|thread_info
modifier|*
name|tp
decl_stmt|;
block|{
if|if
condition|(
name|tp
operator|->
name|pid
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|target_thread_alive
argument_list|(
name|tp
operator|->
name|pid
argument_list|)
condition|)
block|{
name|tp
operator|->
name|pid
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Mark it as dead */
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|prune_threads
parameter_list|()
block|{
name|struct
name|thread_info
modifier|*
name|tp
decl_stmt|,
modifier|*
name|tpprev
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|tpprev
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|tp
operator|=
name|thread_list
init|;
name|tp
condition|;
name|tp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|tp
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|thread_alive
argument_list|(
name|tp
argument_list|)
condition|)
block|{
if|if
condition|(
name|tpprev
condition|)
name|tpprev
operator|->
name|next
operator|=
name|next
expr_stmt|;
else|else
name|thread_list
operator|=
name|next
expr_stmt|;
name|free
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
else|else
name|tpprev
operator|=
name|tp
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print information about currently known threads   *  * Note: this has the drawback that it _really_ switches  *       threads, which frees the frame cache.  A no-side  *       effects info-threads command would be nicer.  */
end_comment

begin_function
specifier|static
name|void
name|info_threads_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|thread_info
modifier|*
name|tp
decl_stmt|;
name|int
name|current_pid
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|cur_frame
decl_stmt|;
name|int
name|saved_frame_level
init|=
name|selected_frame_level
decl_stmt|;
name|int
name|counter
decl_stmt|;
comment|/* Avoid coredumps which would happen if we tried to access a NULL      selected_frame.  */
if|if
condition|(
operator|!
name|target_has_stack
condition|)
name|error
argument_list|(
literal|"No stack."
argument_list|)
expr_stmt|;
name|prune_threads
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|FIND_NEW_THREADS
argument_list|)
name|FIND_NEW_THREADS
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|current_pid
operator|=
name|inferior_pid
expr_stmt|;
for|for
control|(
name|tp
operator|=
name|thread_list
init|;
name|tp
condition|;
name|tp
operator|=
name|tp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|tp
operator|->
name|pid
operator|==
name|current_pid
condition|)
name|printf_filtered
argument_list|(
literal|"* "
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HPUXHPPA
name|printf_filtered
argument_list|(
literal|"%d %s  "
argument_list|,
name|tp
operator|->
name|num
argument_list|,
name|target_tid_to_str
argument_list|(
name|tp
operator|->
name|pid
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf_filtered
argument_list|(
literal|"%d %s  "
argument_list|,
name|tp
operator|->
name|num
argument_list|,
name|target_pid_to_str
argument_list|(
name|tp
operator|->
name|pid
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|switch_to_thread
argument_list|(
name|tp
operator|->
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|selected_frame
condition|)
name|print_only_stack_frame
argument_list|(
name|selected_frame
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"[No stack.]\n"
argument_list|)
expr_stmt|;
block|}
name|switch_to_thread
argument_list|(
name|current_pid
argument_list|)
expr_stmt|;
comment|/* Code below copied from "up_silently_base" in "stack.c".    * It restores the frame set by the user before the "info threads"    * command.  We have finished the info-threads display by switching    * back to the current thread.  That switch has put us at the top    * of the stack (leaf frame).    */
name|counter
operator|=
name|saved_frame_level
expr_stmt|;
name|cur_frame
operator|=
name|find_relative_frame
argument_list|(
name|selected_frame
argument_list|,
operator|&
name|counter
argument_list|)
expr_stmt|;
if|if
condition|(
name|counter
operator|!=
literal|0
condition|)
block|{
comment|/* Ooops, can't restore, tell user where we are. */
name|warning
argument_list|(
literal|"Couldn't restore frame in current thread, at frame 0"
argument_list|)
expr_stmt|;
name|print_stack_frame
argument_list|(
name|selected_frame
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|select_frame
argument_list|(
name|cur_frame
argument_list|,
name|saved_frame_level
argument_list|)
expr_stmt|;
block|}
comment|/* re-show current frame. */
name|show_stack_frame
argument_list|(
name|cur_frame
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Switch from one thread to another. */
end_comment

begin_function
specifier|static
name|void
name|switch_to_thread
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
if|if
condition|(
name|pid
operator|==
name|inferior_pid
condition|)
return|return;
name|inferior_pid
operator|=
name|pid
expr_stmt|;
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|registers_changed
argument_list|()
expr_stmt|;
name|stop_pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|restore_current_thread
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
if|if
condition|(
name|pid
operator|!=
name|inferior_pid
condition|)
block|{
name|switch_to_thread
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|print_stack_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Apply a GDB command to a list of threads.  List syntax is a whitespace    seperated list of numbers, or ranges, or the keyword `all'.  Ranges consist    of two numbers seperated by a hyphen.  Examples:  	thread apply 1 2 7 4 backtrace	Apply backtrace cmd to threads 1,2,7,4 	thread apply 2-7 9 p foo(1)	Apply p foo(1) cmd to threads 2->7& 9 	thread apply all p x/i $pc	Apply x/i $pc cmd to all threads */
end_comment

begin_function
specifier|static
name|void
name|thread_apply_all_command
parameter_list|(
name|cmd
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|cmd
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|thread_info
modifier|*
name|tp
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
if|if
condition|(
name|cmd
operator|==
name|NULL
operator|||
operator|*
name|cmd
operator|==
literal|'\000'
condition|)
name|error
argument_list|(
literal|"Please specify a command following the thread ID list"
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|restore_current_thread
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|long
operator|)
name|inferior_pid
argument_list|)
expr_stmt|;
for|for
control|(
name|tp
operator|=
name|thread_list
init|;
name|tp
condition|;
name|tp
operator|=
name|tp
operator|->
name|next
control|)
if|if
condition|(
name|thread_alive
argument_list|(
name|tp
argument_list|)
condition|)
block|{
name|switch_to_thread
argument_list|(
name|tp
operator|->
name|pid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HPUXHPPA
name|printf_filtered
argument_list|(
literal|"\nThread %d (%s):\n"
argument_list|,
name|tp
operator|->
name|num
argument_list|,
name|target_tid_to_str
argument_list|(
name|inferior_pid
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf_filtered
argument_list|(
literal|"\nThread %d (%s):\n"
argument_list|,
name|tp
operator|->
name|num
argument_list|,
name|target_pid_to_str
argument_list|(
name|inferior_pid
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|execute_command
argument_list|(
name|cmd
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|thread_apply_command
parameter_list|(
name|tidlist
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|tidlist
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
name|cmd
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
if|if
condition|(
name|tidlist
operator|==
name|NULL
operator|||
operator|*
name|tidlist
operator|==
literal|'\000'
condition|)
name|error
argument_list|(
literal|"Please specify a thread ID list"
argument_list|)
expr_stmt|;
for|for
control|(
name|cmd
operator|=
name|tidlist
init|;
operator|*
name|cmd
operator|!=
literal|'\000'
operator|&&
operator|!
name|isalpha
argument_list|(
operator|*
name|cmd
argument_list|)
condition|;
name|cmd
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'\000'
condition|)
name|error
argument_list|(
literal|"Please specify a command following the thread ID list"
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|restore_current_thread
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|long
operator|)
name|inferior_pid
argument_list|)
expr_stmt|;
while|while
condition|(
name|tidlist
operator|<
name|cmd
condition|)
block|{
name|struct
name|thread_info
modifier|*
name|tp
decl_stmt|;
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
name|start
operator|=
name|strtol
argument_list|(
name|tidlist
argument_list|,
operator|&
name|p
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|tidlist
condition|)
name|error
argument_list|(
literal|"Error parsing %s"
argument_list|,
name|tidlist
argument_list|)
expr_stmt|;
name|tidlist
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|tidlist
operator|==
literal|' '
operator|||
operator|*
name|tidlist
operator|==
literal|'\t'
condition|)
name|tidlist
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|tidlist
operator|==
literal|'-'
condition|)
comment|/* Got a range of IDs? */
block|{
name|tidlist
operator|++
expr_stmt|;
comment|/* Skip the - */
name|end
operator|=
name|strtol
argument_list|(
name|tidlist
argument_list|,
operator|&
name|p
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|tidlist
condition|)
name|error
argument_list|(
literal|"Error parsing %s"
argument_list|,
name|tidlist
argument_list|)
expr_stmt|;
name|tidlist
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|tidlist
operator|==
literal|' '
operator|||
operator|*
name|tidlist
operator|==
literal|'\t'
condition|)
name|tidlist
operator|++
expr_stmt|;
block|}
else|else
name|end
operator|=
name|start
expr_stmt|;
for|for
control|(
init|;
name|start
operator|<=
name|end
condition|;
name|start
operator|++
control|)
block|{
name|tp
operator|=
name|find_thread_id
argument_list|(
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tp
condition|)
name|warning
argument_list|(
literal|"Unknown thread %d."
argument_list|,
name|start
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|thread_alive
argument_list|(
name|tp
argument_list|)
condition|)
name|warning
argument_list|(
literal|"Thread %d has terminated."
argument_list|,
name|start
argument_list|)
expr_stmt|;
else|else
block|{
name|switch_to_thread
argument_list|(
name|tp
operator|->
name|pid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HPUXHPPA
name|printf_filtered
argument_list|(
literal|"\nThread %d (%s):\n"
argument_list|,
name|tp
operator|->
name|num
argument_list|,
name|target_tid_to_str
argument_list|(
name|inferior_pid
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf_filtered
argument_list|(
literal|"\nThread %d (%s):\n"
argument_list|,
name|tp
operator|->
name|num
argument_list|,
name|target_pid_to_str
argument_list|(
name|inferior_pid
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|execute_command
argument_list|(
name|cmd
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Switch to the specified thread.  Will dispatch off to thread_apply_command    if prefix of arg is `apply'.  */
end_comment

begin_function
specifier|static
name|void
name|thread_command
parameter_list|(
name|tidstr
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|tidstr
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|num
decl_stmt|;
name|struct
name|thread_info
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
operator|!
name|tidstr
condition|)
block|{
comment|/* Don't generate an error, just say which thread is current. */
if|if
condition|(
name|target_has_stack
condition|)
name|printf_filtered
argument_list|(
literal|"[Current thread is %d (%s)]\n"
argument_list|,
name|pid_to_thread_id
argument_list|(
name|inferior_pid
argument_list|)
argument_list|,
if|#
directive|if
name|defined
argument_list|(
name|HPUXHPPA
argument_list|)
name|target_tid_to_str
argument_list|(
argument|inferior_pid
argument_list|)
else|#
directive|else
name|target_pid_to_str
argument_list|(
name|inferior_pid
argument_list|)
endif|#
directive|endif
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"No stack."
argument_list|)
expr_stmt|;
return|return;
block|}
name|num
operator|=
name|atoi
argument_list|(
name|tidstr
argument_list|)
expr_stmt|;
name|tp
operator|=
name|find_thread_id
argument_list|(
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tp
condition|)
name|error
argument_list|(
literal|"Thread ID %d not known.  Use the \"info threads\" command to\n\ see the IDs of currently known threads."
argument_list|,
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|thread_alive
argument_list|(
name|tp
argument_list|)
condition|)
name|error
argument_list|(
literal|"Thread ID %d has terminated.\n"
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|switch_to_thread
argument_list|(
name|tp
operator|->
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|context_hook
condition|)
name|context_hook
argument_list|(
name|num
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"[Switching to thread %d (%s)]\n"
argument_list|,
name|pid_to_thread_id
argument_list|(
name|inferior_pid
argument_list|)
argument_list|,
if|#
directive|if
name|defined
argument_list|(
name|HPUXHPPA
argument_list|)
name|target_tid_to_str
argument_list|(
argument|inferior_pid
argument_list|)
else|#
directive|else
name|target_pid_to_str
argument_list|(
name|inferior_pid
argument_list|)
endif|#
directive|endif
argument_list|)
expr_stmt|;
name|print_stack_frame
argument_list|(
name|selected_frame
argument_list|,
name|selected_frame_level
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Commands with a prefix of `thread'.  */
end_comment

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
name|thread_cmd_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_thread
parameter_list|()
block|{
specifier|static
name|struct
name|cmd_list_element
modifier|*
name|thread_apply_list
init|=
name|NULL
decl_stmt|;
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|cmdlist
decl_stmt|;
name|add_info
argument_list|(
literal|"threads"
argument_list|,
name|info_threads_command
argument_list|,
literal|"IDs of currently known threads."
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"thread"
argument_list|,
name|class_run
argument_list|,
name|thread_command
argument_list|,
literal|"Use this command to switch between threads.\n\ The new thread ID must be currently known."
argument_list|,
operator|&
name|thread_cmd_list
argument_list|,
literal|"thread "
argument_list|,
literal|1
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"apply"
argument_list|,
name|class_run
argument_list|,
name|thread_apply_command
argument_list|,
literal|"Apply a command to a list of threads."
argument_list|,
operator|&
name|thread_apply_list
argument_list|,
literal|"apply "
argument_list|,
literal|1
argument_list|,
operator|&
name|thread_cmd_list
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"all"
argument_list|,
name|class_run
argument_list|,
name|thread_apply_all_command
argument_list|,
literal|"Apply a command to all threads."
argument_list|,
operator|&
name|thread_apply_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xdb_commands
condition|)
name|add_com_alias
argument_list|(
literal|"t"
argument_list|,
literal|"thread"
argument_list|,
name|class_run
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

