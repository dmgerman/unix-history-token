begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Floating point routines for GDB, the GNU debugger.    Copyright 1986, 1988, 1989, 1990, 1991, 1992, 1993, 1994, 1995, 1996,    1997, 1998, 1999, 2000, 2001    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Support for converting target fp numbers into host DOUBLEST format.  */
end_comment

begin_comment
comment|/* XXX - This code should really be in libiberty/floatformat.c,    however configuration issues with libiberty made this very    difficult to do in the available time.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"doublest.h"
end_include

begin_include
include|#
directive|include
file|"floatformat.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_comment
comment|/* ldexp */
end_comment

begin_comment
comment|/* The odds that CHAR_BIT will be anything but 8 are low enough that I'm not    going to bother with trying to muck around with whether it is defined in    a system header, what we do if not, etc.  */
end_comment

begin_define
define|#
directive|define
name|FLOATFORMAT_CHAR_BIT
value|8
end_define

begin_function_decl
specifier|static
name|unsigned
name|long
name|get_field
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|,
name|enum
name|floatformat_byteorders
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Extract a field which starts at START and is LEN bytes long.  DATA and    TOTAL_LEN are the thing we are extracting it from, in byteorder ORDER.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|get_field
parameter_list|(
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|enum
name|floatformat_byteorders
name|order
parameter_list|,
name|unsigned
name|int
name|total_len
parameter_list|,
name|unsigned
name|int
name|start
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|)
block|{
name|unsigned
name|long
name|result
decl_stmt|;
name|unsigned
name|int
name|cur_byte
decl_stmt|;
name|int
name|cur_bitshift
decl_stmt|;
comment|/* Start at the least significant part of the field.  */
if|if
condition|(
name|order
operator|==
name|floatformat_little
operator|||
name|order
operator|==
name|floatformat_littlebyte_bigword
condition|)
block|{
comment|/* We start counting from the other end (i.e, from the high bytes 	 rather than the low bytes).  As such, we need to be concerned 	 with what happens if bit 0 doesn't start on a byte boundary.  	 I.e, we need to properly handle the case where total_len is 	 not evenly divisible by 8.  So we compute ``excess'' which 	 represents the number of bits from the end of our starting 	 byte needed to get to bit 0. */
name|int
name|excess
init|=
name|FLOATFORMAT_CHAR_BIT
operator|-
operator|(
name|total_len
operator|%
name|FLOATFORMAT_CHAR_BIT
operator|)
decl_stmt|;
name|cur_byte
operator|=
operator|(
name|total_len
operator|/
name|FLOATFORMAT_CHAR_BIT
operator|)
operator|-
operator|(
operator|(
name|start
operator|+
name|len
operator|+
name|excess
operator|)
operator|/
name|FLOATFORMAT_CHAR_BIT
operator|)
expr_stmt|;
name|cur_bitshift
operator|=
operator|(
operator|(
name|start
operator|+
name|len
operator|+
name|excess
operator|)
operator|%
name|FLOATFORMAT_CHAR_BIT
operator|)
operator|-
name|FLOATFORMAT_CHAR_BIT
expr_stmt|;
block|}
else|else
block|{
name|cur_byte
operator|=
operator|(
name|start
operator|+
name|len
operator|)
operator|/
name|FLOATFORMAT_CHAR_BIT
expr_stmt|;
name|cur_bitshift
operator|=
operator|(
operator|(
name|start
operator|+
name|len
operator|)
operator|%
name|FLOATFORMAT_CHAR_BIT
operator|)
operator|-
name|FLOATFORMAT_CHAR_BIT
expr_stmt|;
block|}
if|if
condition|(
name|cur_bitshift
operator|>
operator|-
name|FLOATFORMAT_CHAR_BIT
condition|)
name|result
operator|=
operator|*
operator|(
name|data
operator|+
name|cur_byte
operator|)
operator|>>
operator|(
operator|-
name|cur_bitshift
operator|)
expr_stmt|;
else|else
name|result
operator|=
literal|0
expr_stmt|;
name|cur_bitshift
operator|+=
name|FLOATFORMAT_CHAR_BIT
expr_stmt|;
if|if
condition|(
name|order
operator|==
name|floatformat_little
operator|||
name|order
operator|==
name|floatformat_littlebyte_bigword
condition|)
operator|++
name|cur_byte
expr_stmt|;
else|else
operator|--
name|cur_byte
expr_stmt|;
comment|/* Move towards the most significant part of the field.  */
while|while
condition|(
name|cur_bitshift
operator|<
name|len
condition|)
block|{
name|result
operator||=
operator|(
name|unsigned
name|long
operator|)
operator|*
operator|(
name|data
operator|+
name|cur_byte
operator|)
operator|<<
name|cur_bitshift
expr_stmt|;
name|cur_bitshift
operator|+=
name|FLOATFORMAT_CHAR_BIT
expr_stmt|;
if|if
condition|(
name|order
operator|==
name|floatformat_little
operator|||
name|order
operator|==
name|floatformat_littlebyte_bigword
condition|)
operator|++
name|cur_byte
expr_stmt|;
else|else
operator|--
name|cur_byte
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
name|result
argument_list|)
operator|*
name|FLOATFORMAT_CHAR_BIT
condition|)
comment|/* Mask out bits which are not part of the field */
name|result
operator|&=
operator|(
operator|(
literal|1UL
operator|<<
name|len
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Convert from FMT to a DOUBLEST.    FROM is the address of the extended float.    Store the DOUBLEST in *TO.  */
end_comment

begin_function
specifier|static
name|void
name|convert_floatformat_to_doublest
parameter_list|(
specifier|const
name|struct
name|floatformat
modifier|*
name|fmt
parameter_list|,
specifier|const
name|void
modifier|*
name|from
parameter_list|,
name|DOUBLEST
modifier|*
name|to
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|ufrom
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|from
decl_stmt|;
name|DOUBLEST
name|dto
decl_stmt|;
name|long
name|exponent
decl_stmt|;
name|unsigned
name|long
name|mant
decl_stmt|;
name|unsigned
name|int
name|mant_bits
decl_stmt|,
name|mant_off
decl_stmt|;
name|int
name|mant_bits_left
decl_stmt|;
name|int
name|special_exponent
decl_stmt|;
comment|/* It's a NaN, denorm or zero */
comment|/* If the mantissa bits are not contiguous from one end of the      mantissa to the other, we need to make a private copy of the      source bytes that is in the right order since the unpacking      algorithm assumes that the bits are contiguous.       Swap the bytes individually rather than accessing them through      "long *" since we have no guarantee that they start on a long      alignment, and also sizeof(long) for the host could be different      than sizeof(long) for the target.  FIXME: Assumes sizeof(long)      for the target is 4. */
if|if
condition|(
name|fmt
operator|->
name|byteorder
operator|==
name|floatformat_littlebyte_bigword
condition|)
block|{
specifier|static
name|unsigned
name|char
modifier|*
name|newfrom
decl_stmt|;
name|unsigned
name|char
modifier|*
name|swapin
decl_stmt|,
modifier|*
name|swapout
decl_stmt|;
name|int
name|longswaps
decl_stmt|;
name|longswaps
operator|=
name|fmt
operator|->
name|totalsize
operator|/
name|FLOATFORMAT_CHAR_BIT
expr_stmt|;
name|longswaps
operator|>>=
literal|3
expr_stmt|;
if|if
condition|(
name|newfrom
operator|==
name|NULL
condition|)
block|{
name|newfrom
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|fmt
operator|->
name|totalsize
argument_list|)
expr_stmt|;
block|}
name|swapout
operator|=
name|newfrom
expr_stmt|;
name|swapin
operator|=
name|ufrom
expr_stmt|;
name|ufrom
operator|=
name|newfrom
expr_stmt|;
while|while
condition|(
name|longswaps
operator|--
operator|>
literal|0
condition|)
block|{
comment|/* This is ugly, but efficient */
operator|*
name|swapout
operator|++
operator|=
name|swapin
index|[
literal|4
index|]
expr_stmt|;
operator|*
name|swapout
operator|++
operator|=
name|swapin
index|[
literal|5
index|]
expr_stmt|;
operator|*
name|swapout
operator|++
operator|=
name|swapin
index|[
literal|6
index|]
expr_stmt|;
operator|*
name|swapout
operator|++
operator|=
name|swapin
index|[
literal|7
index|]
expr_stmt|;
operator|*
name|swapout
operator|++
operator|=
name|swapin
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|swapout
operator|++
operator|=
name|swapin
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|swapout
operator|++
operator|=
name|swapin
index|[
literal|2
index|]
expr_stmt|;
operator|*
name|swapout
operator|++
operator|=
name|swapin
index|[
literal|3
index|]
expr_stmt|;
name|swapin
operator|+=
literal|8
expr_stmt|;
block|}
block|}
name|exponent
operator|=
name|get_field
argument_list|(
name|ufrom
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|fmt
operator|->
name|exp_start
argument_list|,
name|fmt
operator|->
name|exp_len
argument_list|)
expr_stmt|;
comment|/* Note that if exponent indicates a NaN, we can't really do anything useful      (not knowing if the host has NaN's, or how to build one).  So it will      end up as an infinity or something close; that is OK.  */
name|mant_bits_left
operator|=
name|fmt
operator|->
name|man_len
expr_stmt|;
name|mant_off
operator|=
name|fmt
operator|->
name|man_start
expr_stmt|;
name|dto
operator|=
literal|0.0
expr_stmt|;
name|special_exponent
operator|=
name|exponent
operator|==
literal|0
operator|||
name|exponent
operator|==
name|fmt
operator|->
name|exp_nan
expr_stmt|;
comment|/* Don't bias NaNs. Use minimum exponent for denorms. For simplicity,    we don't check for zero as the exponent doesn't matter. */
if|if
condition|(
operator|!
name|special_exponent
condition|)
name|exponent
operator|-=
name|fmt
operator|->
name|exp_bias
expr_stmt|;
elseif|else
if|if
condition|(
name|exponent
operator|==
literal|0
condition|)
name|exponent
operator|=
literal|1
operator|-
name|fmt
operator|->
name|exp_bias
expr_stmt|;
comment|/* Build the result algebraically.  Might go infinite, underflow, etc;      who cares. */
comment|/* If this format uses a hidden bit, explicitly add it in now.  Otherwise,    increment the exponent by one to account for the integer bit.  */
if|if
condition|(
operator|!
name|special_exponent
condition|)
block|{
if|if
condition|(
name|fmt
operator|->
name|intbit
operator|==
name|floatformat_intbit_no
condition|)
name|dto
operator|=
name|ldexp
argument_list|(
literal|1.0
argument_list|,
name|exponent
argument_list|)
expr_stmt|;
else|else
name|exponent
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|mant_bits_left
operator|>
literal|0
condition|)
block|{
name|mant_bits
operator|=
name|min
argument_list|(
name|mant_bits_left
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|mant
operator|=
name|get_field
argument_list|(
name|ufrom
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|mant_off
argument_list|,
name|mant_bits
argument_list|)
expr_stmt|;
name|dto
operator|+=
name|ldexp
argument_list|(
operator|(
name|double
operator|)
name|mant
argument_list|,
name|exponent
operator|-
name|mant_bits
argument_list|)
expr_stmt|;
name|exponent
operator|-=
name|mant_bits
expr_stmt|;
name|mant_off
operator|+=
name|mant_bits
expr_stmt|;
name|mant_bits_left
operator|-=
name|mant_bits
expr_stmt|;
block|}
comment|/* Negate it if negative.  */
if|if
condition|(
name|get_field
argument_list|(
name|ufrom
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|fmt
operator|->
name|sign_start
argument_list|,
literal|1
argument_list|)
condition|)
name|dto
operator|=
operator|-
name|dto
expr_stmt|;
operator|*
name|to
operator|=
name|dto
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function_decl
specifier|static
name|void
name|put_field
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|,
name|enum
name|floatformat_byteorders
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|unsigned
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Set a field which starts at START and is LEN bytes long.  DATA and    TOTAL_LEN are the thing we are extracting it from, in byteorder ORDER.  */
end_comment

begin_function
specifier|static
name|void
name|put_field
parameter_list|(
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|enum
name|floatformat_byteorders
name|order
parameter_list|,
name|unsigned
name|int
name|total_len
parameter_list|,
name|unsigned
name|int
name|start
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|,
name|unsigned
name|long
name|stuff_to_put
parameter_list|)
block|{
name|unsigned
name|int
name|cur_byte
decl_stmt|;
name|int
name|cur_bitshift
decl_stmt|;
comment|/* Start at the least significant part of the field.  */
if|if
condition|(
name|order
operator|==
name|floatformat_little
operator|||
name|order
operator|==
name|floatformat_littlebyte_bigword
condition|)
block|{
name|int
name|excess
init|=
name|FLOATFORMAT_CHAR_BIT
operator|-
operator|(
name|total_len
operator|%
name|FLOATFORMAT_CHAR_BIT
operator|)
decl_stmt|;
name|cur_byte
operator|=
operator|(
name|total_len
operator|/
name|FLOATFORMAT_CHAR_BIT
operator|)
operator|-
operator|(
operator|(
name|start
operator|+
name|len
operator|+
name|excess
operator|)
operator|/
name|FLOATFORMAT_CHAR_BIT
operator|)
expr_stmt|;
name|cur_bitshift
operator|=
operator|(
operator|(
name|start
operator|+
name|len
operator|+
name|excess
operator|)
operator|%
name|FLOATFORMAT_CHAR_BIT
operator|)
operator|-
name|FLOATFORMAT_CHAR_BIT
expr_stmt|;
block|}
else|else
block|{
name|cur_byte
operator|=
operator|(
name|start
operator|+
name|len
operator|)
operator|/
name|FLOATFORMAT_CHAR_BIT
expr_stmt|;
name|cur_bitshift
operator|=
operator|(
operator|(
name|start
operator|+
name|len
operator|)
operator|%
name|FLOATFORMAT_CHAR_BIT
operator|)
operator|-
name|FLOATFORMAT_CHAR_BIT
expr_stmt|;
block|}
if|if
condition|(
name|cur_bitshift
operator|>
operator|-
name|FLOATFORMAT_CHAR_BIT
condition|)
block|{
operator|*
operator|(
name|data
operator|+
name|cur_byte
operator|)
operator|&=
operator|~
operator|(
operator|(
operator|(
literal|1
operator|<<
operator|(
operator|(
name|start
operator|+
name|len
operator|)
operator|%
name|FLOATFORMAT_CHAR_BIT
operator|)
operator|)
operator|-
literal|1
operator|)
operator|<<
operator|(
operator|-
name|cur_bitshift
operator|)
operator|)
expr_stmt|;
operator|*
operator|(
name|data
operator|+
name|cur_byte
operator|)
operator||=
operator|(
name|stuff_to_put
operator|&
operator|(
operator|(
literal|1
operator|<<
name|FLOATFORMAT_CHAR_BIT
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
operator|(
operator|-
name|cur_bitshift
operator|)
expr_stmt|;
block|}
name|cur_bitshift
operator|+=
name|FLOATFORMAT_CHAR_BIT
expr_stmt|;
if|if
condition|(
name|order
operator|==
name|floatformat_little
operator|||
name|order
operator|==
name|floatformat_littlebyte_bigword
condition|)
operator|++
name|cur_byte
expr_stmt|;
else|else
operator|--
name|cur_byte
expr_stmt|;
comment|/* Move towards the most significant part of the field.  */
while|while
condition|(
name|cur_bitshift
operator|<
name|len
condition|)
block|{
if|if
condition|(
name|len
operator|-
name|cur_bitshift
operator|<
name|FLOATFORMAT_CHAR_BIT
condition|)
block|{
comment|/* This is the last byte.  */
operator|*
operator|(
name|data
operator|+
name|cur_byte
operator|)
operator|&=
operator|~
operator|(
operator|(
literal|1
operator|<<
operator|(
name|len
operator|-
name|cur_bitshift
operator|)
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
operator|*
operator|(
name|data
operator|+
name|cur_byte
operator|)
operator||=
operator|(
name|stuff_to_put
operator|>>
name|cur_bitshift
operator|)
expr_stmt|;
block|}
else|else
operator|*
operator|(
name|data
operator|+
name|cur_byte
operator|)
operator|=
operator|(
operator|(
name|stuff_to_put
operator|>>
name|cur_bitshift
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|FLOATFORMAT_CHAR_BIT
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|cur_bitshift
operator|+=
name|FLOATFORMAT_CHAR_BIT
expr_stmt|;
if|if
condition|(
name|order
operator|==
name|floatformat_little
operator|||
name|order
operator|==
name|floatformat_littlebyte_bigword
condition|)
operator|++
name|cur_byte
expr_stmt|;
else|else
operator|--
name|cur_byte
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LONG_DOUBLE
end_ifdef

begin_comment
comment|/* Return the fractional part of VALUE, and put the exponent of VALUE in *EPTR.    The range of the returned value is>= 0.5 and< 1.0.  This is equivalent to    frexp, but operates on the long double data type.  */
end_comment

begin_function_decl
specifier|static
name|long
name|double
name|ldfrexp
parameter_list|(
name|long
name|double
name|value
parameter_list|,
name|int
modifier|*
name|eptr
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|long
name|double
name|ldfrexp
parameter_list|(
name|long
name|double
name|value
parameter_list|,
name|int
modifier|*
name|eptr
parameter_list|)
block|{
name|long
name|double
name|tmp
decl_stmt|;
name|int
name|exp
decl_stmt|;
comment|/* Unfortunately, there are no portable functions for extracting the exponent      of a long double, so we have to do it iteratively by multiplying or dividing      by two until the fraction is between 0.5 and 1.0.  */
if|if
condition|(
name|value
operator|<
literal|0.0l
condition|)
name|value
operator|=
operator|-
name|value
expr_stmt|;
name|tmp
operator|=
literal|1.0l
expr_stmt|;
name|exp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|value
operator|>=
name|tmp
condition|)
comment|/* Value>= 1.0 */
while|while
condition|(
name|value
operator|>=
name|tmp
condition|)
block|{
name|tmp
operator|*=
literal|2.0l
expr_stmt|;
name|exp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
operator|!=
literal|0.0l
condition|)
comment|/* Value< 1.0  and> 0.0 */
block|{
while|while
condition|(
name|value
operator|<
name|tmp
condition|)
block|{
name|tmp
operator|/=
literal|2.0l
expr_stmt|;
name|exp
operator|--
expr_stmt|;
block|}
name|tmp
operator|*=
literal|2.0l
expr_stmt|;
name|exp
operator|++
expr_stmt|;
block|}
operator|*
name|eptr
operator|=
name|exp
expr_stmt|;
return|return
name|value
operator|/
name|tmp
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_LONG_DOUBLE */
end_comment

begin_comment
comment|/* The converse: convert the DOUBLEST *FROM to an extended float    and store where TO points.  Neither FROM nor TO have any alignment    restrictions.  */
end_comment

begin_function
specifier|static
name|void
name|convert_doublest_to_floatformat
parameter_list|(
name|CONST
name|struct
name|floatformat
modifier|*
name|fmt
parameter_list|,
specifier|const
name|DOUBLEST
modifier|*
name|from
parameter_list|,
name|void
modifier|*
name|to
parameter_list|)
block|{
name|DOUBLEST
name|dfrom
decl_stmt|;
name|int
name|exponent
decl_stmt|;
name|DOUBLEST
name|mant
decl_stmt|;
name|unsigned
name|int
name|mant_bits
decl_stmt|,
name|mant_off
decl_stmt|;
name|int
name|mant_bits_left
decl_stmt|;
name|unsigned
name|char
modifier|*
name|uto
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|to
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|dfrom
argument_list|,
name|from
argument_list|,
sizeof|sizeof
argument_list|(
name|dfrom
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|uto
argument_list|,
literal|0
argument_list|,
operator|(
name|fmt
operator|->
name|totalsize
operator|+
name|FLOATFORMAT_CHAR_BIT
operator|-
literal|1
operator|)
operator|/
name|FLOATFORMAT_CHAR_BIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|dfrom
operator|==
literal|0
condition|)
return|return;
comment|/* Result is zero */
if|if
condition|(
name|dfrom
operator|!=
name|dfrom
condition|)
comment|/* Result is NaN */
block|{
comment|/* From is NaN */
name|put_field
argument_list|(
name|uto
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|fmt
operator|->
name|exp_start
argument_list|,
name|fmt
operator|->
name|exp_len
argument_list|,
name|fmt
operator|->
name|exp_nan
argument_list|)
expr_stmt|;
comment|/* Be sure it's not infinity, but NaN value is irrel */
name|put_field
argument_list|(
name|uto
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|fmt
operator|->
name|man_start
argument_list|,
literal|32
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If negative, set the sign bit.  */
if|if
condition|(
name|dfrom
operator|<
literal|0
condition|)
block|{
name|put_field
argument_list|(
name|uto
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|fmt
operator|->
name|sign_start
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dfrom
operator|=
operator|-
name|dfrom
expr_stmt|;
block|}
if|if
condition|(
name|dfrom
operator|+
name|dfrom
operator|==
name|dfrom
operator|&&
name|dfrom
operator|!=
literal|0.0
condition|)
comment|/* Result is Infinity */
block|{
comment|/* Infinity exponent is same as NaN's.  */
name|put_field
argument_list|(
name|uto
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|fmt
operator|->
name|exp_start
argument_list|,
name|fmt
operator|->
name|exp_len
argument_list|,
name|fmt
operator|->
name|exp_nan
argument_list|)
expr_stmt|;
comment|/* Infinity mantissa is all zeroes.  */
name|put_field
argument_list|(
name|uto
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|fmt
operator|->
name|man_start
argument_list|,
name|fmt
operator|->
name|man_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|HAVE_LONG_DOUBLE
name|mant
operator|=
name|ldfrexp
argument_list|(
name|dfrom
argument_list|,
operator|&
name|exponent
argument_list|)
expr_stmt|;
else|#
directive|else
name|mant
operator|=
name|frexp
argument_list|(
name|dfrom
argument_list|,
operator|&
name|exponent
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|put_field
argument_list|(
name|uto
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|fmt
operator|->
name|exp_start
argument_list|,
name|fmt
operator|->
name|exp_len
argument_list|,
name|exponent
operator|+
name|fmt
operator|->
name|exp_bias
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mant_bits_left
operator|=
name|fmt
operator|->
name|man_len
expr_stmt|;
name|mant_off
operator|=
name|fmt
operator|->
name|man_start
expr_stmt|;
while|while
condition|(
name|mant_bits_left
operator|>
literal|0
condition|)
block|{
name|unsigned
name|long
name|mant_long
decl_stmt|;
name|mant_bits
operator|=
name|mant_bits_left
operator|<
literal|32
condition|?
name|mant_bits_left
else|:
literal|32
expr_stmt|;
name|mant
operator|*=
literal|4294967296.0
expr_stmt|;
name|mant_long
operator|=
operator|(
operator|(
name|unsigned
name|long
operator|)
name|mant
operator|)
operator|&
literal|0xffffffffL
expr_stmt|;
name|mant
operator|-=
name|mant_long
expr_stmt|;
comment|/* If the integer bit is implicit, then we need to discard it.          If we are discarding a zero, we should be (but are not) creating          a denormalized number which means adjusting the exponent          (I think).  */
if|if
condition|(
name|mant_bits_left
operator|==
name|fmt
operator|->
name|man_len
operator|&&
name|fmt
operator|->
name|intbit
operator|==
name|floatformat_intbit_no
condition|)
block|{
name|mant_long
operator|<<=
literal|1
expr_stmt|;
name|mant_long
operator|&=
literal|0xffffffffL
expr_stmt|;
name|mant_bits
operator|-=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|mant_bits
operator|<
literal|32
condition|)
block|{
comment|/* The bits we want are in the most significant MANT_BITS bits of 	     mant_long.  Move them to the least significant.  */
name|mant_long
operator|>>=
literal|32
operator|-
name|mant_bits
expr_stmt|;
block|}
name|put_field
argument_list|(
name|uto
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|mant_off
argument_list|,
name|mant_bits
argument_list|,
name|mant_long
argument_list|)
expr_stmt|;
name|mant_off
operator|+=
name|mant_bits
expr_stmt|;
name|mant_bits_left
operator|-=
name|mant_bits
expr_stmt|;
block|}
if|if
condition|(
name|fmt
operator|->
name|byteorder
operator|==
name|floatformat_littlebyte_bigword
condition|)
block|{
name|int
name|count
decl_stmt|;
name|unsigned
name|char
modifier|*
name|swaplow
init|=
name|uto
decl_stmt|;
name|unsigned
name|char
modifier|*
name|swaphigh
init|=
name|uto
operator|+
literal|4
decl_stmt|;
name|unsigned
name|char
name|tmp
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
literal|4
condition|;
name|count
operator|++
control|)
block|{
name|tmp
operator|=
operator|*
name|swaplow
expr_stmt|;
operator|*
name|swaplow
operator|++
operator|=
operator|*
name|swaphigh
expr_stmt|;
operator|*
name|swaphigh
operator|++
operator|=
name|tmp
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Check if VAL (which is assumed to be a floating point number whose    format is described by FMT) is negative.  */
end_comment

begin_function
name|int
name|floatformat_is_negative
parameter_list|(
specifier|const
name|struct
name|floatformat
modifier|*
name|fmt
parameter_list|,
name|char
modifier|*
name|val
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|uval
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|val
decl_stmt|;
name|gdb_assert
argument_list|(
name|fmt
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
name|get_field
argument_list|(
name|uval
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|fmt
operator|->
name|sign_start
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Check if VAL is "not a number" (NaN) for FMT.  */
end_comment

begin_function
name|int
name|floatformat_is_nan
parameter_list|(
specifier|const
name|struct
name|floatformat
modifier|*
name|fmt
parameter_list|,
name|char
modifier|*
name|val
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|uval
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|val
decl_stmt|;
name|long
name|exponent
decl_stmt|;
name|unsigned
name|long
name|mant
decl_stmt|;
name|unsigned
name|int
name|mant_bits
decl_stmt|,
name|mant_off
decl_stmt|;
name|int
name|mant_bits_left
decl_stmt|;
name|gdb_assert
argument_list|(
name|fmt
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fmt
operator|->
name|exp_nan
condition|)
return|return
literal|0
return|;
name|exponent
operator|=
name|get_field
argument_list|(
name|uval
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|fmt
operator|->
name|exp_start
argument_list|,
name|fmt
operator|->
name|exp_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|exponent
operator|!=
name|fmt
operator|->
name|exp_nan
condition|)
return|return
literal|0
return|;
name|mant_bits_left
operator|=
name|fmt
operator|->
name|man_len
expr_stmt|;
name|mant_off
operator|=
name|fmt
operator|->
name|man_start
expr_stmt|;
while|while
condition|(
name|mant_bits_left
operator|>
literal|0
condition|)
block|{
name|mant_bits
operator|=
name|min
argument_list|(
name|mant_bits_left
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|mant
operator|=
name|get_field
argument_list|(
name|uval
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|mant_off
argument_list|,
name|mant_bits
argument_list|)
expr_stmt|;
comment|/* If there is an explicit integer bit, mask it off.  */
if|if
condition|(
name|mant_off
operator|==
name|fmt
operator|->
name|man_start
operator|&&
name|fmt
operator|->
name|intbit
operator|==
name|floatformat_intbit_yes
condition|)
name|mant
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|mant_bits
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|mant
condition|)
return|return
literal|1
return|;
name|mant_off
operator|+=
name|mant_bits
expr_stmt|;
name|mant_bits_left
operator|-=
name|mant_bits
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Convert the mantissa of VAL (which is assumed to be a floating    point number whose format is described by FMT) into a hexadecimal    and store it in a static string.  Return a pointer to that string.  */
end_comment

begin_function
name|char
modifier|*
name|floatformat_mantissa
parameter_list|(
specifier|const
name|struct
name|floatformat
modifier|*
name|fmt
parameter_list|,
name|char
modifier|*
name|val
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|uval
init|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|val
decl_stmt|;
name|unsigned
name|long
name|mant
decl_stmt|;
name|unsigned
name|int
name|mant_bits
decl_stmt|,
name|mant_off
decl_stmt|;
name|int
name|mant_bits_left
decl_stmt|;
specifier|static
name|char
name|res
index|[
literal|50
index|]
decl_stmt|;
name|char
name|buf
index|[
literal|9
index|]
decl_stmt|;
comment|/* Make sure we have enough room to store the mantissa.  */
name|gdb_assert
argument_list|(
name|fmt
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
sizeof|sizeof
name|res
operator|>
operator|(
operator|(
name|fmt
operator|->
name|man_len
operator|+
literal|7
operator|)
operator|/
literal|8
operator|)
operator|*
literal|2
argument_list|)
expr_stmt|;
name|mant_off
operator|=
name|fmt
operator|->
name|man_start
expr_stmt|;
name|mant_bits_left
operator|=
name|fmt
operator|->
name|man_len
expr_stmt|;
name|mant_bits
operator|=
operator|(
name|mant_bits_left
operator|%
literal|32
operator|)
operator|>
literal|0
condition|?
name|mant_bits_left
operator|%
literal|32
else|:
literal|32
expr_stmt|;
name|mant
operator|=
name|get_field
argument_list|(
name|uval
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|mant_off
argument_list|,
name|mant_bits
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|res
argument_list|,
literal|"%lx"
argument_list|,
name|mant
argument_list|)
expr_stmt|;
name|mant_off
operator|+=
name|mant_bits
expr_stmt|;
name|mant_bits_left
operator|-=
name|mant_bits
expr_stmt|;
while|while
condition|(
name|mant_bits_left
operator|>
literal|0
condition|)
block|{
name|mant
operator|=
name|get_field
argument_list|(
name|uval
argument_list|,
name|fmt
operator|->
name|byteorder
argument_list|,
name|fmt
operator|->
name|totalsize
argument_list|,
name|mant_off
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%08lx"
argument_list|,
name|mant
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|res
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|mant_off
operator|+=
literal|32
expr_stmt|;
name|mant_bits_left
operator|-=
literal|32
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convert TO/FROM target to the hosts DOUBLEST floating-point format.     If the host and target formats agree, we just copy the raw data    into the appropriate type of variable and return, letting the host    increase precision as necessary.  Otherwise, we call the conversion    routine and let it do the dirty work.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HOST_FLOAT_FORMAT
end_ifndef

begin_define
define|#
directive|define
name|HOST_FLOAT_FORMAT
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HOST_DOUBLE_FORMAT
end_ifndef

begin_define
define|#
directive|define
name|HOST_DOUBLE_FORMAT
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|HOST_LONG_DOUBLE_FORMAT
end_ifndef

begin_define
define|#
directive|define
name|HOST_LONG_DOUBLE_FORMAT
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|floatformat
modifier|*
name|host_float_format
init|=
name|HOST_FLOAT_FORMAT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|floatformat
modifier|*
name|host_double_format
init|=
name|HOST_DOUBLE_FORMAT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|floatformat
modifier|*
name|host_long_double_format
init|=
name|HOST_LONG_DOUBLE_FORMAT
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|floatformat_to_doublest
parameter_list|(
specifier|const
name|struct
name|floatformat
modifier|*
name|fmt
parameter_list|,
specifier|const
name|void
modifier|*
name|in
parameter_list|,
name|DOUBLEST
modifier|*
name|out
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|fmt
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|==
name|host_float_format
condition|)
block|{
name|float
name|val
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|val
argument_list|,
name|in
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|out
operator|=
name|val
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
operator|==
name|host_double_format
condition|)
block|{
name|double
name|val
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|val
argument_list|,
name|in
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|out
operator|=
name|val
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
operator|==
name|host_long_double_format
condition|)
block|{
name|long
name|double
name|val
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|val
argument_list|,
name|in
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|out
operator|=
name|val
expr_stmt|;
block|}
else|else
name|convert_floatformat_to_doublest
argument_list|(
name|fmt
argument_list|,
name|in
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|floatformat_from_doublest
parameter_list|(
specifier|const
name|struct
name|floatformat
modifier|*
name|fmt
parameter_list|,
specifier|const
name|DOUBLEST
modifier|*
name|in
parameter_list|,
name|void
modifier|*
name|out
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|fmt
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|fmt
operator|==
name|host_float_format
condition|)
block|{
name|float
name|val
init|=
operator|*
name|in
decl_stmt|;
name|memcpy
argument_list|(
name|out
argument_list|,
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
operator|==
name|host_double_format
condition|)
block|{
name|double
name|val
init|=
operator|*
name|in
decl_stmt|;
name|memcpy
argument_list|(
name|out
argument_list|,
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fmt
operator|==
name|host_long_double_format
condition|)
block|{
name|long
name|double
name|val
init|=
operator|*
name|in
decl_stmt|;
name|memcpy
argument_list|(
name|out
argument_list|,
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|convert_doublest_to_floatformat
argument_list|(
name|fmt
argument_list|,
name|in
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a floating-point format for a floating-point variable of    length LEN.  Return NULL, if no suitable floating-point format    could be found.     We need this functionality since information about the    floating-point format of a type is not always available to GDB; the    debug information typically only tells us the size of a    floating-point type.     FIXME: kettenis/2001-10-28: In many places, particularly in    target-dependent code, the format of floating-point types is known,    but not passed on by GDB.  This should be fixed.  */
end_comment

begin_function
specifier|const
name|struct
name|floatformat
modifier|*
name|floatformat_from_length
parameter_list|(
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|*
name|TARGET_CHAR_BIT
operator|==
name|TARGET_FLOAT_BIT
condition|)
return|return
name|TARGET_FLOAT_FORMAT
return|;
elseif|else
if|if
condition|(
name|len
operator|*
name|TARGET_CHAR_BIT
operator|==
name|TARGET_DOUBLE_BIT
condition|)
return|return
name|TARGET_DOUBLE_FORMAT
return|;
elseif|else
if|if
condition|(
name|len
operator|*
name|TARGET_CHAR_BIT
operator|==
name|TARGET_LONG_DOUBLE_BIT
condition|)
return|return
name|TARGET_LONG_DOUBLE_FORMAT
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|const
name|struct
name|floatformat
modifier|*
name|floatformat_from_type
parameter_list|(
specifier|const
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FLT
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FLOATFORMAT
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
condition|)
return|return
name|TYPE_FLOATFORMAT
argument_list|(
name|type
argument_list|)
return|;
else|else
return|return
name|floatformat_from_length
argument_list|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If the host doesn't define NAN, use zero instead.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NAN
end_ifndef

begin_define
define|#
directive|define
name|NAN
value|0.0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Extract a floating-point number of length LEN from a target-order    byte-stream at ADDR.  Returns the value as type DOUBLEST.  */
end_comment

begin_function
name|DOUBLEST
name|extract_floating
parameter_list|(
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
specifier|const
name|struct
name|floatformat
modifier|*
name|fmt
init|=
name|floatformat_from_length
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|DOUBLEST
name|val
decl_stmt|;
if|if
condition|(
name|fmt
operator|==
name|NULL
condition|)
block|{
name|warning
argument_list|(
literal|"Can't store a floating-point number of %d bytes."
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|NAN
return|;
block|}
name|floatformat_to_doublest
argument_list|(
name|fmt
argument_list|,
name|addr
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Store VAL as a floating-point number of length LEN to a    target-order byte-stream at ADDR.  */
end_comment

begin_function
name|void
name|store_floating
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|int
name|len
parameter_list|,
name|DOUBLEST
name|val
parameter_list|)
block|{
specifier|const
name|struct
name|floatformat
modifier|*
name|fmt
init|=
name|floatformat_from_length
argument_list|(
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|fmt
operator|==
name|NULL
condition|)
block|{
name|warning
argument_list|(
literal|"Can't store a floating-point number of %d bytes."
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|floatformat_from_doublest
argument_list|(
name|fmt
argument_list|,
operator|&
name|val
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Extract a floating-point number of type TYPE from a target-order    byte-stream at ADDR.  Returns the value as type DOUBLEST.  */
end_comment

begin_function
name|DOUBLEST
name|extract_typed_floating
parameter_list|(
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
specifier|const
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|DOUBLEST
name|retval
decl_stmt|;
name|gdb_assert
argument_list|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FLT
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FLOATFORMAT
argument_list|(
name|type
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|extract_floating
argument_list|(
name|addr
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
name|floatformat_to_doublest
argument_list|(
name|TYPE_FLOATFORMAT
argument_list|(
name|type
argument_list|)
argument_list|,
name|addr
argument_list|,
operator|&
name|retval
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Store VAL as a floating-point number of type TYPE to a target-order    byte-stream at ADDR.  */
end_comment

begin_function
name|void
name|store_typed_floating
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
specifier|const
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|DOUBLEST
name|val
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FLT
argument_list|)
expr_stmt|;
comment|/* FIXME: kettenis/2001-10-28: It is debatable whether we should      zero out any remaining bytes in the target buffer when TYPE is      longer than the actual underlying floating-point format.  Perhaps      we should store a fixed bitpattern in those remaining bytes,      instead of zero, or perhaps we shouldn't touch those remaining      bytes at all.       NOTE: cagney/2001-10-28: With the way things currently work, it      isn't a good idea to leave the end bits undefined.  This is      because GDB writes out the entire sizeof(<floating>) bits of the      floating-point type even though the value might only be stored      in, and the target processor may only refer to, the first N<      TYPE_LENGTH (type) bits.  If the end of the buffer wasn't      initialized, GDB would write undefined data to the target.  An      errant program, refering to that undefined data, would then      become non-deterministic.       See also the function convert_typed_floating below.  */
name|memset
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FLOATFORMAT
argument_list|(
name|type
argument_list|)
operator|==
name|NULL
condition|)
name|store_floating
argument_list|(
name|addr
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|else
name|floatformat_from_doublest
argument_list|(
name|TYPE_FLOATFORMAT
argument_list|(
name|type
argument_list|)
argument_list|,
operator|&
name|val
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert a floating-point number of type FROM_TYPE from a    target-order byte-stream at FROM to a floating-point number of type    TO_TYPE, and store it to a target-order byte-stream at TO.  */
end_comment

begin_function
name|void
name|convert_typed_floating
parameter_list|(
specifier|const
name|void
modifier|*
name|from
parameter_list|,
specifier|const
name|struct
name|type
modifier|*
name|from_type
parameter_list|,
name|void
modifier|*
name|to
parameter_list|,
specifier|const
name|struct
name|type
modifier|*
name|to_type
parameter_list|)
block|{
specifier|const
name|struct
name|floatformat
modifier|*
name|from_fmt
init|=
name|floatformat_from_type
argument_list|(
name|from_type
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|floatformat
modifier|*
name|to_fmt
init|=
name|floatformat_from_type
argument_list|(
name|to_type
argument_list|)
decl_stmt|;
name|gdb_assert
argument_list|(
name|TYPE_CODE
argument_list|(
name|from_type
argument_list|)
operator|==
name|TYPE_CODE_FLT
argument_list|)
expr_stmt|;
name|gdb_assert
argument_list|(
name|TYPE_CODE
argument_list|(
name|to_type
argument_list|)
operator|==
name|TYPE_CODE_FLT
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_fmt
operator|==
name|NULL
operator|||
name|to_fmt
operator|==
name|NULL
condition|)
block|{
comment|/* If we don't know the floating-point format of FROM_TYPE or          TO_TYPE, there's not much we can do.  We might make the          assumption that if the length of FROM_TYPE and TO_TYPE match,          their floating-point format would match too, but that          assumption might be wrong on targets that support          floating-point types that only differ in endianness for          example.  So we warn instead, and zero out the target buffer.  */
name|warning
argument_list|(
literal|"Can't convert floating-point number to desired type."
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|to
argument_list|,
literal|0
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|to_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|from_fmt
operator|==
name|to_fmt
condition|)
block|{
comment|/* We're in business.  The floating-point format of FROM_TYPE          and TO_TYPE match.  However, even though the floating-point          format matches, the length of the type might still be          different.  Make sure we don't overrun any buffers.  See          comment in store_typed_floating for a discussion about          zeroing out remaining bytes in the target buffer.  */
name|memset
argument_list|(
name|to
argument_list|,
literal|0
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|to_type
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|min
argument_list|(
name|TYPE_LENGTH
argument_list|(
name|from_type
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|to_type
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The floating-point types don't match.  The best we can do          (aport from simulating the target FPU) is converting to the          widest floating-point type supported by the host, and then          again to the desired type.  */
name|DOUBLEST
name|d
decl_stmt|;
name|floatformat_to_doublest
argument_list|(
name|from_fmt
argument_list|,
name|from
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
name|floatformat_from_doublest
argument_list|(
name|to_fmt
argument_list|,
operator|&
name|d
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

