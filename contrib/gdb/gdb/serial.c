begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generic serial interface routines    Copyright 1992, 1993, 1996 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_comment
comment|/* Linked list of serial I/O handlers */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|serial_ops
modifier|*
name|serial_ops_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the last serial stream opened.  Used by connect command. */
end_comment

begin_decl_stmt
specifier|static
name|serial_t
name|last_serial_opened
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to list of scb's. */
end_comment

begin_decl_stmt
specifier|static
name|serial_t
name|scb_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-NULL gives filename which contains a recording of the remote session,    suitable for playback by gdbserver. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|serial_logfile
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|serial_logfp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|serial_reading
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|serial_writing
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|serial_log_command
parameter_list|(
name|cmd
parameter_list|)
specifier|const
name|char
modifier|*
name|cmd
decl_stmt|;
block|{
if|if
condition|(
name|serial_reading
operator|||
name|serial_writing
condition|)
block|{
name|fputc_unfiltered
argument_list|(
literal|'\n'
argument_list|,
name|serial_logfp
argument_list|)
expr_stmt|;
name|serial_reading
operator|=
literal|0
expr_stmt|;
name|serial_writing
operator|=
literal|0
expr_stmt|;
block|}
name|fprintf_unfiltered
argument_list|(
name|serial_logfp
argument_list|,
literal|"c %s\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
comment|/* Make sure that the log file is as up-to-date as possible,      in case we are getting ready to dump core or something. */
name|fflush
argument_list|(
name|serial_logfp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serial_logchar
parameter_list|(
name|ch
parameter_list|)
name|int
name|ch
decl_stmt|;
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'\\'
case|:
name|fputs_unfiltered
argument_list|(
literal|"\\\\"
argument_list|,
name|serial_logfp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|fputs_unfiltered
argument_list|(
literal|"\\b"
argument_list|,
name|serial_logfp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
name|fputs_unfiltered
argument_list|(
literal|"\\f"
argument_list|,
name|serial_logfp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|fputs_unfiltered
argument_list|(
literal|"\\n"
argument_list|,
name|serial_logfp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|fputs_unfiltered
argument_list|(
literal|"\\r"
argument_list|,
name|serial_logfp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|fputs_unfiltered
argument_list|(
literal|"\\t"
argument_list|,
name|serial_logfp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\v'
case|:
name|fputs_unfiltered
argument_list|(
literal|"\\v"
argument_list|,
name|serial_logfp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf_unfiltered
argument_list|(
name|serial_logfp
argument_list|,
name|isprint
argument_list|(
name|ch
argument_list|)
condition|?
literal|"%c"
else|:
literal|"\\x%02x"
argument_list|,
name|ch
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|int
name|serial_write
parameter_list|(
name|scb
parameter_list|,
name|str
parameter_list|,
name|len
parameter_list|)
name|serial_t
name|scb
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|count
decl_stmt|;
if|if
condition|(
name|serial_logfp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|serial_reading
condition|)
block|{
name|fputc_unfiltered
argument_list|(
literal|'\n'
argument_list|,
name|serial_logfp
argument_list|)
expr_stmt|;
name|serial_reading
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|serial_writing
condition|)
block|{
name|serial_logchar
argument_list|(
literal|'w'
argument_list|)
expr_stmt|;
name|serial_logchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|serial_writing
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|len
condition|;
name|count
operator|++
control|)
block|{
name|serial_logchar
argument_list|(
name|str
index|[
name|count
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure that the log file is as up-to-date as possible, 	 in case we are getting ready to dump core or something. */
name|fflush
argument_list|(
name|serial_logfp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|scb
operator|->
name|ops
operator|->
name|write
argument_list|(
name|scb
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|serial_readchar
parameter_list|(
name|scb
parameter_list|,
name|timeout
parameter_list|)
name|serial_t
name|scb
decl_stmt|;
name|int
name|timeout
decl_stmt|;
block|{
name|int
name|ch
decl_stmt|;
name|ch
operator|=
name|scb
operator|->
name|ops
operator|->
name|readchar
argument_list|(
name|scb
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|serial_logfp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|serial_writing
condition|)
block|{
name|fputc_unfiltered
argument_list|(
literal|'\n'
argument_list|,
name|serial_logfp
argument_list|)
expr_stmt|;
name|serial_writing
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|serial_reading
condition|)
block|{
name|serial_logchar
argument_list|(
literal|'r'
argument_list|)
expr_stmt|;
name|serial_logchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|serial_reading
operator|=
literal|1
expr_stmt|;
block|}
name|serial_logchar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
comment|/* Make sure that the log file is as up-to-date as possible, 	 in case we are getting ready to dump core or something. */
name|fflush
argument_list|(
name|serial_logfp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ch
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|serial_ops
modifier|*
name|serial_interface_lookup
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|serial_ops
modifier|*
name|ops
decl_stmt|;
for|for
control|(
name|ops
operator|=
name|serial_ops_list
init|;
name|ops
condition|;
name|ops
operator|=
name|ops
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|ops
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|ops
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|serial_add_interface
parameter_list|(
name|optable
parameter_list|)
name|struct
name|serial_ops
modifier|*
name|optable
decl_stmt|;
block|{
name|optable
operator|->
name|next
operator|=
name|serial_ops_list
expr_stmt|;
name|serial_ops_list
operator|=
name|optable
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Open up a device or a network socket, depending upon the syntax of NAME. */
end_comment

begin_function
name|serial_t
name|serial_open
parameter_list|(
name|name
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|serial_t
name|scb
decl_stmt|;
name|struct
name|serial_ops
modifier|*
name|ops
decl_stmt|;
for|for
control|(
name|scb
operator|=
name|scb_base
init|;
name|scb
condition|;
name|scb
operator|=
name|scb
operator|->
name|next
control|)
if|if
condition|(
name|scb
operator|->
name|name
operator|&&
name|strcmp
argument_list|(
name|scb
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|scb
operator|->
name|refcnt
operator|++
expr_stmt|;
return|return
name|scb
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"pc"
argument_list|)
operator|==
literal|0
condition|)
name|ops
operator|=
name|serial_interface_lookup
argument_list|(
literal|"pc"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
condition|)
name|ops
operator|=
name|serial_interface_lookup
argument_list|(
literal|"tcp"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"lpt"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|ops
operator|=
name|serial_interface_lookup
argument_list|(
literal|"parallel"
argument_list|)
expr_stmt|;
else|else
name|ops
operator|=
name|serial_interface_lookup
argument_list|(
literal|"hardwire"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ops
condition|)
return|return
name|NULL
return|;
name|scb
operator|=
operator|(
name|serial_t
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|_serial_t
argument_list|)
argument_list|)
expr_stmt|;
name|scb
operator|->
name|ops
operator|=
name|ops
expr_stmt|;
name|scb
operator|->
name|bufcnt
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|bufp
operator|=
name|scb
operator|->
name|buf
expr_stmt|;
if|if
condition|(
name|scb
operator|->
name|ops
operator|->
name|open
argument_list|(
name|scb
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|scb
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|scb
operator|->
name|name
operator|=
name|strsave
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|scb
operator|->
name|next
operator|=
name|scb_base
expr_stmt|;
name|scb
operator|->
name|refcnt
operator|=
literal|1
expr_stmt|;
name|scb_base
operator|=
name|scb
expr_stmt|;
name|last_serial_opened
operator|=
name|scb
expr_stmt|;
if|if
condition|(
name|serial_logfile
operator|!=
name|NULL
condition|)
block|{
name|serial_logfp
operator|=
name|fopen
argument_list|(
name|serial_logfile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|serial_logfp
operator|==
name|NULL
condition|)
block|{
name|perror_with_name
argument_list|(
name|serial_logfile
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|scb
return|;
block|}
end_function

begin_function
name|serial_t
name|serial_fdopen
parameter_list|(
name|fd
parameter_list|)
specifier|const
name|int
name|fd
decl_stmt|;
block|{
name|serial_t
name|scb
decl_stmt|;
name|struct
name|serial_ops
modifier|*
name|ops
decl_stmt|;
for|for
control|(
name|scb
operator|=
name|scb_base
init|;
name|scb
condition|;
name|scb
operator|=
name|scb
operator|->
name|next
control|)
if|if
condition|(
name|scb
operator|->
name|fd
operator|==
name|fd
condition|)
block|{
name|scb
operator|->
name|refcnt
operator|++
expr_stmt|;
return|return
name|scb
return|;
block|}
name|ops
operator|=
name|serial_interface_lookup
argument_list|(
literal|"hardwire"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ops
condition|)
return|return
name|NULL
return|;
name|scb
operator|=
operator|(
name|serial_t
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|_serial_t
argument_list|)
argument_list|)
expr_stmt|;
name|scb
operator|->
name|ops
operator|=
name|ops
expr_stmt|;
name|scb
operator|->
name|bufcnt
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|bufp
operator|=
name|scb
operator|->
name|buf
expr_stmt|;
name|scb
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|scb
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
name|scb
operator|->
name|next
operator|=
name|scb_base
expr_stmt|;
name|scb
operator|->
name|refcnt
operator|=
literal|1
expr_stmt|;
name|scb_base
operator|=
name|scb
expr_stmt|;
name|last_serial_opened
operator|=
name|scb
expr_stmt|;
return|return
name|scb
return|;
block|}
end_function

begin_function
name|void
name|serial_close
parameter_list|(
name|scb
parameter_list|,
name|really_close
parameter_list|)
name|serial_t
name|scb
decl_stmt|;
name|int
name|really_close
decl_stmt|;
block|{
name|serial_t
name|tmp_scb
decl_stmt|;
name|last_serial_opened
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|serial_logfp
condition|)
block|{
if|if
condition|(
name|serial_reading
operator|||
name|serial_writing
condition|)
block|{
name|fputc_unfiltered
argument_list|(
literal|'\n'
argument_list|,
name|serial_logfp
argument_list|)
expr_stmt|;
name|serial_reading
operator|=
literal|0
expr_stmt|;
name|serial_writing
operator|=
literal|0
expr_stmt|;
block|}
name|fclose
argument_list|(
name|serial_logfp
argument_list|)
expr_stmt|;
name|serial_logfp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* This is bogus.  It's not our fault if you pass us a bad scb...!  Rob, you    should fix your code instead.  */
if|if
condition|(
operator|!
name|scb
condition|)
return|return;
name|scb
operator|->
name|refcnt
operator|--
expr_stmt|;
if|if
condition|(
name|scb
operator|->
name|refcnt
operator|>
literal|0
condition|)
return|return;
if|if
condition|(
name|really_close
condition|)
name|scb
operator|->
name|ops
operator|->
name|close
argument_list|(
name|scb
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|->
name|name
condition|)
name|free
argument_list|(
name|scb
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb_base
operator|==
name|scb
condition|)
name|scb_base
operator|=
name|scb_base
operator|->
name|next
expr_stmt|;
else|else
for|for
control|(
name|tmp_scb
operator|=
name|scb_base
init|;
name|tmp_scb
condition|;
name|tmp_scb
operator|=
name|tmp_scb
operator|->
name|next
control|)
block|{
if|if
condition|(
name|tmp_scb
operator|->
name|next
operator|!=
name|scb
condition|)
continue|continue;
name|tmp_scb
operator|->
name|next
operator|=
name|tmp_scb
operator|->
name|next
operator|->
name|next
expr_stmt|;
break|break;
block|}
name|free
argument_list|(
name|scb
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* The connect command is #if 0 because I hadn't thought of an elegant way to wait for I/O on two serial_t's simultaneously.  Two solutions came to mind:  	1) Fork, and have have one fork handle the to user direction, 	   and have the other hand the to target direction.  This 	   obviously won't cut it for MSDOS.  	2) Use something like select.  This assumes that stdin and 	   the target side can both be waited on via the same 	   mechanism.  This may not be true for DOS, if GDB is 	   talking to the target via a TCP socket. -grossman, 8 Jun 93 */
end_comment

begin_comment
comment|/* Connect the user directly to the remote system.  This command acts just like    the 'cu' or 'tip' command.  Use<CR>~. or<CR>~^D to break out.  */
end_comment

begin_comment
unit|static serial_t tty_desc;
comment|/* Controlling terminal */
end_comment

begin_comment
unit|static void cleanup_tty(ttystate)      serial_ttystate ttystate; {   printf_unfiltered ("\r\n[Exiting connect mode]\r\n");   SERIAL_SET_TTY_STATE (tty_desc, ttystate);   free (ttystate);   SERIAL_CLOSE (tty_desc); }  static void connect_command (args, fromtty)      char	*args;      int	fromtty; {   int c;   char cur_esc = 0;   serial_ttystate ttystate;   serial_t port_desc;
comment|/* TTY port */
end_comment

begin_comment
unit|dont_repeat();    if (args)     fprintf_unfiltered(gdb_stderr, "This command takes no args.  They have been ignored.\n"); 	   printf_unfiltered("[Entering connect mode.  Use ~. or ~^D to escape]\n");    tty_desc = SERIAL_FDOPEN (0);   port_desc = last_serial_opened;    ttystate = SERIAL_GET_TTY_STATE (tty_desc);    SERIAL_RAW (tty_desc);   SERIAL_RAW (port_desc);    make_cleanup (cleanup_tty, ttystate);    while (1)     {       int mask;        mask = SERIAL_WAIT_2 (tty_desc, port_desc, -1);        if (mask& 2) 	{
comment|/* tty input */
end_comment

begin_comment
unit|char cx;  	  while (1) 	    { 	      c = SERIAL_READCHAR(tty_desc, 0);  	      if (c == SERIAL_TIMEOUT) 		  break;  	      if (c< 0) 		perror_with_name("connect");  	      cx = c; 	      SERIAL_WRITE(port_desc,&cx, 1);  	      switch (cur_esc) 		{ 		case 0: 		  if (c == '\r') 		    cur_esc = c; 		  break; 		case '\r': 		  if (c == '~') 		    cur_esc = c; 		  else 		    cur_esc = 0; 		  break; 		case '~': 		  if (c == '.' || c == '\004') 		    return; 		  else 		    cur_esc = 0; 		} 	    } 	}        if (mask& 1) 	{
comment|/* Port input */
end_comment

begin_endif
unit|char cx;  	  while (1) 	    { 	      c = SERIAL_READCHAR(port_desc, 0);  	      if (c == SERIAL_TIMEOUT) 		  break;  	      if (c< 0) 		perror_with_name("connect");  	      cx = c;  	      SERIAL_WRITE(tty_desc,&cx, 1); 	    } 	}     } }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|serial_printf
parameter_list|(
name|serial_t
name|desc
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|serial_printf
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|args
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
else|#
directive|else
name|serial_t
name|desc
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|desc
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|serial_t
argument_list|)
expr_stmt|;
name|format
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vasprintf
argument_list|(
operator|&
name|buf
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|SERIAL_WRITE
argument_list|(
name|desc
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_serial
parameter_list|()
block|{
if|#
directive|if
literal|0
block|add_com ("connect", class_obscure, connect_command, 	   "Connect the terminal directly up to the command monitor.\n\ Use<CR>~. or<CR>~^D to break out.");
endif|#
directive|endif
comment|/* 0 */
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"remotelogfile"
argument_list|,
name|no_class
argument_list|,
name|var_filename
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|serial_logfile
argument_list|,
literal|"Set filename for remote session recording.\n\ This file is used to record the remote session for future playback\n\ by gdbserver."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

