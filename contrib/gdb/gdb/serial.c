begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generic serial interface routines     Copyright 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,    2001, 2002 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_function_decl
specifier|extern
name|void
name|_initialize_serial
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Is serial being debugged? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|global_serial_debug_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Linked list of serial I/O handlers */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|serial_ops
modifier|*
name|serial_ops_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the last serial stream opened.  Used by connect command. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|serial
modifier|*
name|last_serial_opened
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to list of scb's. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|serial
modifier|*
name|scb_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-NULL gives filename which contains a recording of the remote session,    suitable for playback by gdbserver. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|serial_logfile
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ui_file
modifier|*
name|serial_logfp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|struct
name|serial_ops
modifier|*
name|serial_interface_lookup
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|serial_logchar
parameter_list|(
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|ch_type
parameter_list|,
name|int
name|ch
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|char
name|logbase_hex
index|[]
init|=
literal|"hex"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|logbase_octal
index|[]
init|=
literal|"octal"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|logbase_ascii
index|[]
init|=
literal|"ascii"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|logbase_enums
index|[]
init|=
block|{
name|logbase_hex
block|,
name|logbase_octal
block|,
name|logbase_ascii
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|serial_logbase
init|=
name|logbase_ascii
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|serial_current_type
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Log char CH of type CHTYPE, with TIMEOUT */
end_comment

begin_comment
comment|/* Define bogus char to represent a BREAK.  Should be careful to choose a value    that can't be confused with a normal char, or an error code.  */
end_comment

begin_define
define|#
directive|define
name|SERIAL_BREAK
value|1235
end_define

begin_function
specifier|static
name|void
name|serial_logchar
parameter_list|(
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|ch_type
parameter_list|,
name|int
name|ch
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
if|if
condition|(
name|ch_type
operator|!=
name|serial_current_type
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
literal|"\n%c "
argument_list|,
name|ch_type
argument_list|)
expr_stmt|;
name|serial_current_type
operator|=
name|ch_type
expr_stmt|;
block|}
if|if
condition|(
name|serial_logbase
operator|!=
name|logbase_ascii
condition|)
name|fputc_unfiltered
argument_list|(
literal|' '
argument_list|,
name|stream
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|SERIAL_TIMEOUT
case|:
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
literal|"<Timeout: %d seconds>"
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
return|return;
case|case
name|SERIAL_ERROR
case|:
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
literal|"<Error: %s>"
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|SERIAL_EOF
case|:
name|fputs_unfiltered
argument_list|(
literal|"<Eof>"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|SERIAL_BREAK
case|:
name|fputs_unfiltered
argument_list|(
literal|"<Break>"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
default|default:
if|if
condition|(
name|serial_logbase
operator|==
name|logbase_hex
condition|)
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
literal|"%02x"
argument_list|,
name|ch
operator|&
literal|0xff
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|serial_logbase
operator|==
name|logbase_octal
condition|)
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
literal|"%03o"
argument_list|,
name|ch
operator|&
literal|0xff
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'\\'
case|:
name|fputs_unfiltered
argument_list|(
literal|"\\\\"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|fputs_unfiltered
argument_list|(
literal|"\\b"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
name|fputs_unfiltered
argument_list|(
literal|"\\f"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|fputs_unfiltered
argument_list|(
literal|"\\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|fputs_unfiltered
argument_list|(
literal|"\\r"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|fputs_unfiltered
argument_list|(
literal|"\\t"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\v'
case|:
name|fputs_unfiltered
argument_list|(
literal|"\\v"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
name|isprint
argument_list|(
name|ch
argument_list|)
condition|?
literal|"%c"
else|:
literal|"\\x%02x"
argument_list|,
name|ch
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
name|void
name|serial_log_command
parameter_list|(
specifier|const
name|char
modifier|*
name|cmd
parameter_list|)
block|{
if|if
condition|(
operator|!
name|serial_logfp
condition|)
return|return;
name|serial_current_type
operator|=
literal|'c'
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"\nc "
argument_list|,
name|serial_logfp
argument_list|)
expr_stmt|;
name|fputs_unfiltered
argument_list|(
name|cmd
argument_list|,
name|serial_logfp
argument_list|)
expr_stmt|;
comment|/* Make sure that the log file is as up-to-date as possible,      in case we are getting ready to dump core or something. */
name|gdb_flush
argument_list|(
name|serial_logfp
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|struct
name|serial_ops
modifier|*
name|serial_interface_lookup
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|serial_ops
modifier|*
name|ops
decl_stmt|;
for|for
control|(
name|ops
operator|=
name|serial_ops_list
init|;
name|ops
condition|;
name|ops
operator|=
name|ops
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|ops
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|ops
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|serial_add_interface
parameter_list|(
name|struct
name|serial_ops
modifier|*
name|optable
parameter_list|)
block|{
name|optable
operator|->
name|next
operator|=
name|serial_ops_list
expr_stmt|;
name|serial_ops_list
operator|=
name|optable
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Open up a device or a network socket, depending upon the syntax of NAME. */
end_comment

begin_function
name|struct
name|serial
modifier|*
name|serial_open
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|serial
modifier|*
name|scb
decl_stmt|;
name|struct
name|serial_ops
modifier|*
name|ops
decl_stmt|;
specifier|const
name|char
modifier|*
name|open_name
init|=
name|name
decl_stmt|;
for|for
control|(
name|scb
operator|=
name|scb_base
init|;
name|scb
condition|;
name|scb
operator|=
name|scb
operator|->
name|next
control|)
if|if
condition|(
name|scb
operator|->
name|name
operator|&&
name|strcmp
argument_list|(
name|scb
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|scb
operator|->
name|refcnt
operator|++
expr_stmt|;
return|return
name|scb
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"pc"
argument_list|)
operator|==
literal|0
condition|)
name|ops
operator|=
name|serial_interface_lookup
argument_list|(
literal|"pc"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|':'
argument_list|)
condition|)
name|ops
operator|=
name|serial_interface_lookup
argument_list|(
literal|"tcp"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"lpt"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|ops
operator|=
name|serial_interface_lookup
argument_list|(
literal|"parallel"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"|"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ops
operator|=
name|serial_interface_lookup
argument_list|(
literal|"pipe"
argument_list|)
expr_stmt|;
name|open_name
operator|=
name|name
operator|+
literal|1
expr_stmt|;
comment|/* discard ``|'' */
block|}
else|else
name|ops
operator|=
name|serial_interface_lookup
argument_list|(
literal|"hardwire"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ops
condition|)
return|return
name|NULL
return|;
name|scb
operator|=
name|XMALLOC
argument_list|(
expr|struct
name|serial
argument_list|)
expr_stmt|;
name|scb
operator|->
name|ops
operator|=
name|ops
expr_stmt|;
name|scb
operator|->
name|bufcnt
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|bufp
operator|=
name|scb
operator|->
name|buf
expr_stmt|;
if|if
condition|(
name|scb
operator|->
name|ops
operator|->
name|open
argument_list|(
name|scb
argument_list|,
name|open_name
argument_list|)
condition|)
block|{
name|xfree
argument_list|(
name|scb
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|scb
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|scb
operator|->
name|next
operator|=
name|scb_base
expr_stmt|;
name|scb
operator|->
name|refcnt
operator|=
literal|1
expr_stmt|;
name|scb
operator|->
name|debug_p
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|async_state
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|async_handler
operator|=
name|NULL
expr_stmt|;
name|scb
operator|->
name|async_context
operator|=
name|NULL
expr_stmt|;
name|scb_base
operator|=
name|scb
expr_stmt|;
name|last_serial_opened
operator|=
name|scb
expr_stmt|;
if|if
condition|(
name|serial_logfile
operator|!=
name|NULL
condition|)
block|{
name|serial_logfp
operator|=
name|gdb_fopen
argument_list|(
name|serial_logfile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|serial_logfp
operator|==
name|NULL
condition|)
name|perror_with_name
argument_list|(
name|serial_logfile
argument_list|)
expr_stmt|;
block|}
return|return
name|scb
return|;
block|}
end_function

begin_function
name|struct
name|serial
modifier|*
name|serial_fdopen
parameter_list|(
specifier|const
name|int
name|fd
parameter_list|)
block|{
name|struct
name|serial
modifier|*
name|scb
decl_stmt|;
name|struct
name|serial_ops
modifier|*
name|ops
decl_stmt|;
for|for
control|(
name|scb
operator|=
name|scb_base
init|;
name|scb
condition|;
name|scb
operator|=
name|scb
operator|->
name|next
control|)
if|if
condition|(
name|scb
operator|->
name|fd
operator|==
name|fd
condition|)
block|{
name|scb
operator|->
name|refcnt
operator|++
expr_stmt|;
return|return
name|scb
return|;
block|}
name|ops
operator|=
name|serial_interface_lookup
argument_list|(
literal|"hardwire"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ops
condition|)
return|return
name|NULL
return|;
name|scb
operator|=
name|XMALLOC
argument_list|(
expr|struct
name|serial
argument_list|)
expr_stmt|;
name|scb
operator|->
name|ops
operator|=
name|ops
expr_stmt|;
name|scb
operator|->
name|bufcnt
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|bufp
operator|=
name|scb
operator|->
name|buf
expr_stmt|;
name|scb
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|scb
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
name|scb
operator|->
name|next
operator|=
name|scb_base
expr_stmt|;
name|scb
operator|->
name|refcnt
operator|=
literal|1
expr_stmt|;
name|scb
operator|->
name|debug_p
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|async_state
operator|=
literal|0
expr_stmt|;
name|scb
operator|->
name|async_handler
operator|=
name|NULL
expr_stmt|;
name|scb
operator|->
name|async_context
operator|=
name|NULL
expr_stmt|;
name|scb_base
operator|=
name|scb
expr_stmt|;
name|last_serial_opened
operator|=
name|scb
expr_stmt|;
return|return
name|scb
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_serial_close
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|int
name|really_close
parameter_list|)
block|{
name|struct
name|serial
modifier|*
name|tmp_scb
decl_stmt|;
name|last_serial_opened
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|serial_logfp
condition|)
block|{
name|fputs_unfiltered
argument_list|(
literal|"\nEnd of log\n"
argument_list|,
name|serial_logfp
argument_list|)
expr_stmt|;
name|serial_current_type
operator|=
literal|0
expr_stmt|;
comment|/* XXX - What if serial_logfp == gdb_stdout or gdb_stderr? */
name|ui_file_delete
argument_list|(
name|serial_logfp
argument_list|)
expr_stmt|;
name|serial_logfp
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* This is bogus.  It's not our fault if you pass us a bad scb...!  Rob, you    should fix your code instead.  */
if|if
condition|(
operator|!
name|scb
condition|)
return|return;
name|scb
operator|->
name|refcnt
operator|--
expr_stmt|;
if|if
condition|(
name|scb
operator|->
name|refcnt
operator|>
literal|0
condition|)
return|return;
comment|/* ensure that the FD has been taken out of async mode */
if|if
condition|(
name|scb
operator|->
name|async_handler
operator|!=
name|NULL
condition|)
name|serial_async
argument_list|(
name|scb
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|really_close
condition|)
name|scb
operator|->
name|ops
operator|->
name|close
argument_list|(
name|scb
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|->
name|name
condition|)
name|xfree
argument_list|(
name|scb
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb_base
operator|==
name|scb
condition|)
name|scb_base
operator|=
name|scb_base
operator|->
name|next
expr_stmt|;
else|else
for|for
control|(
name|tmp_scb
operator|=
name|scb_base
init|;
name|tmp_scb
condition|;
name|tmp_scb
operator|=
name|tmp_scb
operator|->
name|next
control|)
block|{
if|if
condition|(
name|tmp_scb
operator|->
name|next
operator|!=
name|scb
condition|)
continue|continue;
name|tmp_scb
operator|->
name|next
operator|=
name|tmp_scb
operator|->
name|next
operator|->
name|next
expr_stmt|;
break|break;
block|}
name|xfree
argument_list|(
name|scb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|serial_close
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|)
block|{
name|do_serial_close
argument_list|(
name|scb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|serial_un_fdopen
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|)
block|{
name|do_serial_close
argument_list|(
name|scb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|serial_readchar
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
comment|/* FIXME: cagney/1999-10-11: Don't enable this check until the ASYNC      code is finished. */
if|if
condition|(
literal|0
operator|&&
name|serial_is_async_p
argument_list|(
name|scb
argument_list|)
operator|&&
name|timeout
operator|<
literal|0
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"serial_readchar: blocking read in async mode"
argument_list|)
expr_stmt|;
name|ch
operator|=
name|scb
operator|->
name|ops
operator|->
name|readchar
argument_list|(
name|scb
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|serial_logfp
operator|!=
name|NULL
condition|)
block|{
name|serial_logchar
argument_list|(
name|serial_logfp
argument_list|,
literal|'r'
argument_list|,
name|ch
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
comment|/* Make sure that the log file is as up-to-date as possible,          in case we are getting ready to dump core or something. */
name|gdb_flush
argument_list|(
name|serial_logfp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|serial_debug_p
argument_list|(
name|scb
argument_list|)
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"["
argument_list|)
expr_stmt|;
name|serial_logchar
argument_list|(
name|gdb_stdlog
argument_list|,
literal|'r'
argument_list|,
name|ch
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdlog
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ch
operator|)
return|;
block|}
end_function

begin_function
name|int
name|serial_write
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|serial_logfp
operator|!=
name|NULL
condition|)
block|{
name|int
name|count
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|len
condition|;
name|count
operator|++
control|)
name|serial_logchar
argument_list|(
name|serial_logfp
argument_list|,
literal|'w'
argument_list|,
name|str
index|[
name|count
index|]
operator|&
literal|0xff
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Make sure that the log file is as up-to-date as possible,          in case we are getting ready to dump core or something. */
name|gdb_flush
argument_list|(
name|serial_logfp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|scb
operator|->
name|ops
operator|->
name|write
argument_list|(
name|scb
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|serial_printf
parameter_list|(
name|struct
name|serial
modifier|*
name|desc
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|xvasprintf
argument_list|(
operator|&
name|buf
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|serial_write
argument_list|(
name|desc
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|serial_drain_output
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|)
block|{
return|return
name|scb
operator|->
name|ops
operator|->
name|drain_output
argument_list|(
name|scb
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|serial_flush_output
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|)
block|{
return|return
name|scb
operator|->
name|ops
operator|->
name|flush_output
argument_list|(
name|scb
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|serial_flush_input
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|)
block|{
return|return
name|scb
operator|->
name|ops
operator|->
name|flush_input
argument_list|(
name|scb
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|serial_send_break
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|)
block|{
if|if
condition|(
name|serial_logfp
operator|!=
name|NULL
condition|)
name|serial_logchar
argument_list|(
name|serial_logfp
argument_list|,
literal|'w'
argument_list|,
name|SERIAL_BREAK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|scb
operator|->
name|ops
operator|->
name|send_break
argument_list|(
name|scb
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|serial_raw
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|)
block|{
name|scb
operator|->
name|ops
operator|->
name|go_raw
argument_list|(
name|scb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|serial_ttystate
name|serial_get_tty_state
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|)
block|{
return|return
name|scb
operator|->
name|ops
operator|->
name|get_tty_state
argument_list|(
name|scb
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|serial_set_tty_state
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|serial_ttystate
name|ttystate
parameter_list|)
block|{
return|return
name|scb
operator|->
name|ops
operator|->
name|set_tty_state
argument_list|(
name|scb
argument_list|,
name|ttystate
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|serial_print_tty_state
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|serial_ttystate
name|ttystate
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|scb
operator|->
name|ops
operator|->
name|print_tty_state
argument_list|(
name|scb
argument_list|,
name|ttystate
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|serial_noflush_set_tty_state
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|serial_ttystate
name|new_ttystate
parameter_list|,
name|serial_ttystate
name|old_ttystate
parameter_list|)
block|{
return|return
name|scb
operator|->
name|ops
operator|->
name|noflush_set_tty_state
argument_list|(
name|scb
argument_list|,
name|new_ttystate
argument_list|,
name|old_ttystate
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|serial_setbaudrate
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|int
name|rate
parameter_list|)
block|{
return|return
name|scb
operator|->
name|ops
operator|->
name|setbaudrate
argument_list|(
name|scb
argument_list|,
name|rate
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|serial_setstopbits
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|int
name|num
parameter_list|)
block|{
return|return
name|scb
operator|->
name|ops
operator|->
name|setstopbits
argument_list|(
name|scb
argument_list|,
name|num
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|serial_can_async_p
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|)
block|{
return|return
operator|(
name|scb
operator|->
name|ops
operator|->
name|async
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|serial_is_async_p
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|)
block|{
return|return
operator|(
name|scb
operator|->
name|ops
operator|->
name|async
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|scb
operator|->
name|async_handler
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|serial_async
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|serial_event_ftype
modifier|*
name|handler
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
comment|/* Only change mode if there is a need. */
if|if
condition|(
operator|(
name|scb
operator|->
name|async_handler
operator|==
name|NULL
operator|)
operator|!=
operator|(
name|handler
operator|==
name|NULL
operator|)
condition|)
name|scb
operator|->
name|ops
operator|->
name|async
argument_list|(
name|scb
argument_list|,
name|handler
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|scb
operator|->
name|async_handler
operator|=
name|handler
expr_stmt|;
name|scb
operator|->
name|async_context
operator|=
name|context
expr_stmt|;
block|}
end_function

begin_function
name|int
name|deprecated_serial_fd
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|)
block|{
comment|/* FIXME: should this output a warning that deprecated code is being      called? */
if|if
condition|(
name|scb
operator|->
name|fd
operator|<
literal|0
condition|)
block|{
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"serial: FD not valid"
argument_list|)
expr_stmt|;
block|}
return|return
name|scb
operator|->
name|fd
return|;
comment|/* sigh */
block|}
end_function

begin_function
name|void
name|serial_debug
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|,
name|int
name|debug_p
parameter_list|)
block|{
name|scb
operator|->
name|debug_p
operator|=
name|debug_p
expr_stmt|;
block|}
end_function

begin_function
name|int
name|serial_debug_p
parameter_list|(
name|struct
name|serial
modifier|*
name|scb
parameter_list|)
block|{
return|return
name|scb
operator|->
name|debug_p
operator|||
name|global_serial_debug_p
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* The connect command is #if 0 because I hadn't thought of an elegant    way to wait for I/O on two `struct serial *'s simultaneously.  Two    solutions came to mind:     1) Fork, and have have one fork handle the to user direction,    and have the other hand the to target direction.  This    obviously won't cut it for MSDOS.     2) Use something like select.  This assumes that stdin and    the target side can both be waited on via the same    mechanism.  This may not be true for DOS, if GDB is    talking to the target via a TCP socket.    -grossman, 8 Jun 93 */
end_comment

begin_comment
comment|/* Connect the user directly to the remote system.  This command acts just like    the 'cu' or 'tip' command.  Use<CR>~. or<CR>~^D to break out.  */
end_comment

begin_comment
unit|static struct serial *tty_desc;
comment|/* Controlling terminal */
end_comment

begin_comment
unit|static void cleanup_tty (serial_ttystate ttystate) {   printf_unfiltered ("\r\n[Exiting connect mode]\r\n");   serial_set_tty_state (tty_desc, ttystate);   xfree (ttystate);   serial_close (tty_desc); }  static void connect_command (char *args, int fromtty) {   int c;   char cur_esc = 0;   serial_ttystate ttystate;   struct serial *port_desc;
comment|/* TTY port */
end_comment

begin_comment
unit|dont_repeat ();    if (args)     fprintf_unfiltered (gdb_stderr, "This command takes no args.  They have been ignored.\n");    printf_unfiltered ("[Entering connect mode.  Use ~. or ~^D to escape]\n");    tty_desc = serial_fdopen (0);   port_desc = last_serial_opened;    ttystate = serial_get_tty_state (tty_desc);    serial_raw (tty_desc);   serial_raw (port_desc);    make_cleanup (cleanup_tty, ttystate);    while (1)     {       int mask;        mask = serial_wait_2 (tty_desc, port_desc, -1);        if (mask& 2) 	{
comment|/* tty input */
end_comment

begin_comment
unit|char cx;  	  while (1) 	    { 	      c = serial_readchar (tty_desc, 0);  	      if (c == SERIAL_TIMEOUT) 		break;  	      if (c< 0) 		perror_with_name ("connect");  	      cx = c; 	      serial_write (port_desc,&cx, 1);  	      switch (cur_esc) 		{ 		case 0: 		  if (c == '\r') 		    cur_esc = c; 		  break; 		case '\r': 		  if (c == '~') 		    cur_esc = c; 		  else 		    cur_esc = 0; 		  break; 		case '~': 		  if (c == '.' || c == '\004') 		    return; 		  else 		    cur_esc = 0; 		} 	    } 	}        if (mask& 1) 	{
comment|/* Port input */
end_comment

begin_endif
unit|char cx;  	  while (1) 	    { 	      c = serial_readchar (port_desc, 0);  	      if (c == SERIAL_TIMEOUT) 		break;  	      if (c< 0) 		perror_with_name ("connect");  	      cx = c;  	      serial_write (tty_desc,&cx, 1); 	    } 	}     } }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/* Serial set/show framework.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cmd_list_element
modifier|*
name|serial_set_cmdlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cmd_list_element
modifier|*
name|serial_show_cmdlist
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|serial_set_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\"set serial\" must be followed by the name of a command.\n"
argument_list|)
expr_stmt|;
name|help_list
argument_list|(
name|serial_set_cmdlist
argument_list|,
literal|"set serial "
argument_list|,
operator|-
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|serial_show_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|cmd_show_list
argument_list|(
name|serial_show_cmdlist
argument_list|,
name|from_tty
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_serial
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
literal|0
block|add_com ("connect", class_obscure, connect_command, 	   "Connect the terminal directly up to the command monitor.\n\ Use<CR>~. or<CR>~^D to break out.");
endif|#
directive|endif
comment|/* 0 */
name|add_prefix_cmd
argument_list|(
literal|"serial"
argument_list|,
name|class_maintenance
argument_list|,
name|serial_set_cmd
argument_list|,
literal|"\ Set default serial/parallel port configuration."
argument_list|,
operator|&
name|serial_set_cmdlist
argument_list|,
literal|"set serial "
argument_list|,
literal|0
comment|/*allow-unknown*/
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"serial"
argument_list|,
name|class_maintenance
argument_list|,
name|serial_show_cmd
argument_list|,
literal|"\ Show default serial/parallel port configuration."
argument_list|,
operator|&
name|serial_show_cmdlist
argument_list|,
literal|"show serial "
argument_list|,
literal|0
comment|/*allow-unknown*/
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"remotelogfile"
argument_list|,
name|no_class
argument_list|,
name|var_filename
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|serial_logfile
argument_list|,
literal|"Set filename for remote session recording.\n\ This file is used to record the remote session for future playback\n\ by gdbserver."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_enum_cmd
argument_list|(
literal|"remotelogbase"
argument_list|,
name|no_class
argument_list|,
name|logbase_enums
argument_list|,
operator|&
name|serial_logbase
argument_list|,
literal|"Set numerical base for remote session logging"
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"serial"
argument_list|,
name|class_maintenance
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|global_serial_debug_p
argument_list|,
literal|"Set serial debugging.\n\ When non-zero, serial port debugging is enabled."
argument_list|,
operator|&
name|setdebuglist
argument_list|)
argument_list|,
operator|&
name|showdebuglist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

