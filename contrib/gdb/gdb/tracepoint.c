begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Tracing functionality for remote targets in custom GDB protocol     Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software    Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"tracepoint.h"
end_include

begin_include
include|#
directive|include
file|"remote.h"
end_include

begin_include
include|#
directive|include
file|"linespec.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"completer.h"
end_include

begin_include
include|#
directive|include
file|"gdb-events.h"
end_include

begin_include
include|#
directive|include
file|"block.h"
end_include

begin_include
include|#
directive|include
file|"dictionary.h"
end_include

begin_include
include|#
directive|include
file|"ax.h"
end_include

begin_include
include|#
directive|include
file|"ax-gdb.h"
end_include

begin_comment
comment|/* readline include files */
end_comment

begin_include
include|#
directive|include
file|"readline/readline.h"
end_include

begin_include
include|#
directive|include
file|"readline/history.h"
end_include

begin_comment
comment|/* readline defines this.  */
end_comment

begin_undef
undef|#
directive|undef
name|savestring
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* maximum length of an agent aexpression.    this accounts for the fact that packets are limited to 400 bytes    (which includes everything -- including the checksum), and assumes    the worst case of maximum length for each of the pieces of a    continuation packet.     NOTE: expressions get mem2hex'ed otherwise this would be twice as    large.  (400 - 31)/2 == 184 */
end_comment

begin_define
define|#
directive|define
name|MAX_AGENT_EXPR_LEN
value|184
end_define

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|readline_begin_hook
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
function_decl|(
modifier|*
name|readline_hook
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|readline_end_hook
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|x_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|addressprint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print machine addresses? */
end_comment

begin_comment
comment|/* GDB commands implemented in other modules:  */
end_comment

begin_function_decl
specifier|extern
name|void
name|output_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*     Tracepoint.c:     This module defines the following debugger commands:    trace            : set a tracepoint on a function, line, or address.    info trace       : list all debugger-defined tracepoints.    delete trace     : delete one or more tracepoints.    enable trace     : enable one or more tracepoints.    disable trace    : disable one or more tracepoints.    actions          : specify actions to be taken at a tracepoint.    passcount        : specify a pass count for a tracepoint.    tstart           : start a trace experiment.    tstop            : stop a trace experiment.    tstatus          : query the status of a trace experiment.    tfind            : find a trace frame in the trace buffer.    tdump            : print everything collected at the current tracepoint.    save-tracepoints : write tracepoint setup into a file.     This module defines the following user-visible debugger variables:    $trace_frame : sequence number of trace frame currently being debugged.    $trace_line  : source line of trace frame currently being debugged.    $trace_file  : source file of trace frame currently being debugged.    $tracepoint  : tracepoint number of trace frame currently being debugged.  */
end_comment

begin_comment
comment|/* ======= Important global variables: ======= */
end_comment

begin_comment
comment|/* Chain of all tracepoints defined.  */
end_comment

begin_decl_stmt
name|struct
name|tracepoint
modifier|*
name|tracepoint_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of last tracepoint made.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tracepoint_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of last traceframe collected.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|traceframe_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tracepoint for last traceframe collected.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tracepoint_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Symbol for function for last traceframe collected */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|symbol
modifier|*
name|traceframe_fun
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Symtab and line for last traceframe collected */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|symtab_and_line
name|traceframe_sal
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tracing command lists */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cmd_list_element
modifier|*
name|tfindlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ======= Important command functions: ======= */
end_comment

begin_function_decl
specifier|static
name|void
name|trace_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tracepoints_info
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|delete_trace_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|enable_trace_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|disable_trace_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trace_pass_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trace_actions_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trace_start_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trace_stop_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trace_status_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trace_find_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trace_find_pc_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trace_find_tracepoint_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trace_find_line_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trace_find_range_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trace_find_outside_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tracepoint_save_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trace_dump_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* support routines */
end_comment

begin_function_decl
specifier|static
name|void
name|trace_mention
parameter_list|(
name|struct
name|tracepoint
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_struct_decl
struct_decl|struct
name|collection_list
struct_decl|;
end_struct_decl

begin_function_decl
specifier|static
name|void
name|add_aexpr
parameter_list|(
name|struct
name|collection_list
modifier|*
parameter_list|,
name|struct
name|agent_expr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|char
modifier|*
name|mem2hex
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_register
parameter_list|(
name|struct
name|collection_list
modifier|*
name|collection
parameter_list|,
name|unsigned
name|int
name|regno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|cleanup
modifier|*
name|make_cleanup_free_actions
parameter_list|(
name|struct
name|tracepoint
modifier|*
name|t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_actions_list
parameter_list|(
name|char
modifier|*
modifier|*
name|actions_list
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_actions_list_cleanup_wrapper
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|_initialize_tracepoint
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Utility: returns true if "target remote" */
end_comment

begin_function
specifier|static
name|int
name|target_is_remote
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|current_target
operator|.
name|to_shortname
operator|&&
name|strcmp
argument_list|(
name|current_target
operator|.
name|to_shortname
argument_list|,
literal|"remote"
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Utility: generate error from an incoming stub packet.  */
end_comment

begin_function
specifier|static
name|void
name|trace_error
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|)
block|{
if|if
condition|(
operator|*
name|buf
operator|++
operator|!=
literal|'E'
condition|)
return|return;
comment|/* not an error msg */
switch|switch
condition|(
operator|*
name|buf
condition|)
block|{
case|case
literal|'1'
case|:
comment|/* malformed packet error */
if|if
condition|(
operator|*
operator|++
name|buf
operator|==
literal|'0'
condition|)
comment|/*   general case: */
name|error
argument_list|(
literal|"tracepoint.c: error in outgoing packet."
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"tracepoint.c: error in outgoing packet at field #%ld."
argument_list|,
name|strtol
argument_list|(
name|buf
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
case|case
literal|'2'
case|:
name|error
argument_list|(
literal|"trace API error 0x%s."
argument_list|,
operator|++
name|buf
argument_list|)
expr_stmt|;
default|default:
name|error
argument_list|(
literal|"Target returns error code '%s'."
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Utility: wait for reply from stub, while accepting "O" packets */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|remote_get_noisy_reply
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|long
name|sizeof_buf
parameter_list|)
block|{
do|do
comment|/* loop on reply from remote stub */
block|{
name|QUIT
expr_stmt|;
comment|/* allow user to bail out with ^C */
name|getpkt
argument_list|(
name|buf
argument_list|,
name|sizeof_buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Target does not support this command."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'E'
condition|)
name|trace_error
argument_list|(
name|buf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'O'
operator|&&
name|buf
index|[
literal|1
index|]
operator|!=
literal|'K'
condition|)
name|remote_console_output
argument_list|(
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 'O' message from stub */
else|else
return|return
name|buf
return|;
comment|/* here's the actual reply */
block|}
do|while
condition|(
literal|1
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Set tracepoint count to NUM.  */
end_comment

begin_function
specifier|static
name|void
name|set_tracepoint_count
parameter_list|(
name|int
name|num
parameter_list|)
block|{
name|tracepoint_count
operator|=
name|num
expr_stmt|;
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"tpnum"
argument_list|)
argument_list|,
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|num
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set traceframe number to NUM.  */
end_comment

begin_function
specifier|static
name|void
name|set_traceframe_num
parameter_list|(
name|int
name|num
parameter_list|)
block|{
name|traceframe_number
operator|=
name|num
expr_stmt|;
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"trace_frame"
argument_list|)
argument_list|,
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|num
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set tracepoint number to NUM.  */
end_comment

begin_function
specifier|static
name|void
name|set_tracepoint_num
parameter_list|(
name|int
name|num
parameter_list|)
block|{
name|tracepoint_number
operator|=
name|num
expr_stmt|;
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"tracepoint"
argument_list|)
argument_list|,
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|num
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set externally visible debug variables for querying/printing    the traceframe context (line, function, file) */
end_comment

begin_function
specifier|static
name|void
name|set_traceframe_context
parameter_list|(
name|CORE_ADDR
name|trace_pc
parameter_list|)
block|{
specifier|static
name|struct
name|type
modifier|*
name|func_string
decl_stmt|,
modifier|*
name|file_string
decl_stmt|;
specifier|static
name|struct
name|type
modifier|*
name|func_range
decl_stmt|,
modifier|*
name|file_range
decl_stmt|;
name|struct
name|value
modifier|*
name|func_val
decl_stmt|;
name|struct
name|value
modifier|*
name|file_val
decl_stmt|;
specifier|static
name|struct
name|type
modifier|*
name|charstar
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|charstar
operator|==
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
condition|)
name|charstar
operator|=
name|lookup_pointer_type
argument_list|(
name|builtin_type_char
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace_pc
operator|==
operator|-
literal|1
condition|)
comment|/* cease debugging any trace buffers */
block|{
name|traceframe_fun
operator|=
literal|0
expr_stmt|;
name|traceframe_sal
operator|.
name|pc
operator|=
name|traceframe_sal
operator|.
name|line
operator|=
literal|0
expr_stmt|;
name|traceframe_sal
operator|.
name|symtab
operator|=
name|NULL
expr_stmt|;
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"trace_func"
argument_list|)
argument_list|,
name|value_from_pointer
argument_list|(
name|charstar
argument_list|,
operator|(
name|LONGEST
operator|)
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"trace_file"
argument_list|)
argument_list|,
name|value_from_pointer
argument_list|(
name|charstar
argument_list|,
operator|(
name|LONGEST
operator|)
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"trace_line"
argument_list|)
argument_list|,
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* save as globals for internal use */
name|traceframe_sal
operator|=
name|find_pc_line
argument_list|(
name|trace_pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|traceframe_fun
operator|=
name|find_pc_function
argument_list|(
name|trace_pc
argument_list|)
expr_stmt|;
comment|/* save linenumber as "$trace_line", a debugger variable visible to users */
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"trace_line"
argument_list|)
argument_list|,
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|traceframe_sal
operator|.
name|line
argument_list|)
argument_list|)
expr_stmt|;
comment|/* save func name as "$trace_func", a debugger variable visible to users */
if|if
condition|(
name|traceframe_fun
operator|==
name|NULL
operator|||
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|traceframe_fun
argument_list|)
operator|==
name|NULL
condition|)
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"trace_func"
argument_list|)
argument_list|,
name|value_from_pointer
argument_list|(
name|charstar
argument_list|,
operator|(
name|LONGEST
operator|)
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|len
operator|=
name|strlen
argument_list|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|traceframe_fun
argument_list|)
argument_list|)
expr_stmt|;
name|func_range
operator|=
name|create_range_type
argument_list|(
name|func_range
argument_list|,
name|builtin_type_int
argument_list|,
literal|0
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|func_string
operator|=
name|create_array_type
argument_list|(
name|func_string
argument_list|,
name|builtin_type_char
argument_list|,
name|func_range
argument_list|)
expr_stmt|;
name|func_val
operator|=
name|allocate_value
argument_list|(
name|func_string
argument_list|)
expr_stmt|;
name|VALUE_TYPE
argument_list|(
name|func_val
argument_list|)
operator|=
name|func_string
expr_stmt|;
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|func_val
argument_list|)
argument_list|,
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|traceframe_fun
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|func_val
operator|->
name|modifiable
operator|=
literal|0
expr_stmt|;
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"trace_func"
argument_list|)
argument_list|,
name|func_val
argument_list|)
expr_stmt|;
block|}
comment|/* save file name as "$trace_file", a debugger variable visible to users */
if|if
condition|(
name|traceframe_sal
operator|.
name|symtab
operator|==
name|NULL
operator|||
name|traceframe_sal
operator|.
name|symtab
operator|->
name|filename
operator|==
name|NULL
condition|)
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"trace_file"
argument_list|)
argument_list|,
name|value_from_pointer
argument_list|(
name|charstar
argument_list|,
operator|(
name|LONGEST
operator|)
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|len
operator|=
name|strlen
argument_list|(
name|traceframe_sal
operator|.
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
name|file_range
operator|=
name|create_range_type
argument_list|(
name|file_range
argument_list|,
name|builtin_type_int
argument_list|,
literal|0
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|file_string
operator|=
name|create_array_type
argument_list|(
name|file_string
argument_list|,
name|builtin_type_char
argument_list|,
name|file_range
argument_list|)
expr_stmt|;
name|file_val
operator|=
name|allocate_value
argument_list|(
name|file_string
argument_list|)
expr_stmt|;
name|VALUE_TYPE
argument_list|(
name|file_val
argument_list|)
operator|=
name|file_string
expr_stmt|;
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|file_val
argument_list|)
argument_list|,
name|traceframe_sal
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|file_val
operator|->
name|modifiable
operator|=
literal|0
expr_stmt|;
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"trace_file"
argument_list|)
argument_list|,
name|file_val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Low level routine to set a tracepoint.    Returns the tracepoint object so caller can set other things.    Does not set the tracepoint number!    Does not print anything.     ==> This routine should not be called if there is a chance of later    error(); otherwise it leaves a bogus tracepoint on the chain.  Validate    your arguments BEFORE calling this routine!  */
end_comment

begin_function
specifier|static
name|struct
name|tracepoint
modifier|*
name|set_raw_tracepoint
parameter_list|(
name|struct
name|symtab_and_line
name|sal
parameter_list|)
block|{
name|struct
name|tracepoint
modifier|*
name|t
decl_stmt|,
modifier|*
name|tc
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|t
operator|=
operator|(
expr|struct
name|tracepoint
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tracepoint
argument_list|)
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|address
operator|=
name|sal
operator|.
name|pc
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|symtab
operator|==
name|NULL
condition|)
name|t
operator|->
name|source_file
operator|=
name|NULL
expr_stmt|;
else|else
name|t
operator|->
name|source_file
operator|=
name|savestring
argument_list|(
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|strlen
argument_list|(
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|section
operator|=
name|sal
operator|.
name|section
expr_stmt|;
name|t
operator|->
name|language
operator|=
name|current_language
operator|->
name|la_language
expr_stmt|;
name|t
operator|->
name|input_radix
operator|=
name|input_radix
expr_stmt|;
name|t
operator|->
name|line_number
operator|=
name|sal
operator|.
name|line
expr_stmt|;
name|t
operator|->
name|enabled_p
operator|=
literal|1
expr_stmt|;
name|t
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|step_count
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|pass_count
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|addr_string
operator|=
name|NULL
expr_stmt|;
comment|/* Add this tracepoint to the end of the chain      so that a list of tracepoints will come out in order      of increasing numbers.  */
name|tc
operator|=
name|tracepoint_chain
expr_stmt|;
if|if
condition|(
name|tc
operator|==
literal|0
condition|)
name|tracepoint_chain
operator|=
name|t
expr_stmt|;
else|else
block|{
while|while
condition|(
name|tc
operator|->
name|next
condition|)
name|tc
operator|=
name|tc
operator|->
name|next
expr_stmt|;
name|tc
operator|->
name|next
operator|=
name|t
expr_stmt|;
block|}
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Set a tracepoint according to ARG (function, linenum or *address) */
end_comment

begin_function
specifier|static
name|void
name|trace_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|canonical
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|tracepoint
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|addr_start
init|=
literal|0
decl_stmt|,
modifier|*
name|addr_end
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|arg
operator|||
operator|!
operator|*
name|arg
condition|)
name|error
argument_list|(
literal|"trace command requires an argument"
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
operator|&&
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"TRACE %s\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|addr_start
operator|=
name|arg
expr_stmt|;
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|arg
argument_list|,
literal|1
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|canonical
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|addr_end
operator|=
name|arg
expr_stmt|;
if|if
condition|(
operator|!
name|sals
operator|.
name|nelts
condition|)
return|return;
comment|/* ??? Presumably decode_line_1 has already warned? */
comment|/* Resolve all line numbers to PC's */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|.
name|nelts
condition|;
name|i
operator|++
control|)
name|resolve_sal_pc
argument_list|(
operator|&
name|sals
operator|.
name|sals
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Now set all the tracepoints.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|.
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|sal
operator|=
name|sals
operator|.
name|sals
index|[
name|i
index|]
expr_stmt|;
name|t
operator|=
name|set_raw_tracepoint
argument_list|(
name|sal
argument_list|)
expr_stmt|;
name|set_tracepoint_count
argument_list|(
name|tracepoint_count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|t
operator|->
name|number
operator|=
name|tracepoint_count
expr_stmt|;
comment|/* If a canonical line spec is needed use that instead of the          command string.  */
if|if
condition|(
name|canonical
operator|!=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
operator|&&
name|canonical
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|t
operator|->
name|addr_string
operator|=
name|canonical
index|[
name|i
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|addr_start
condition|)
name|t
operator|->
name|addr_string
operator|=
name|savestring
argument_list|(
name|addr_start
argument_list|,
name|addr_end
operator|-
name|addr_start
argument_list|)
expr_stmt|;
name|trace_mention
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sals
operator|.
name|nelts
operator|>
literal|1
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Multiple tracepoints were set.\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Use 'delete trace' to delete unwanted tracepoints.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Tell the user we have just set a tracepoint TP. */
end_comment

begin_function
specifier|static
name|void
name|trace_mention
parameter_list|(
name|struct
name|tracepoint
modifier|*
name|tp
parameter_list|)
block|{
name|printf_filtered
argument_list|(
literal|"Tracepoint %d"
argument_list|,
name|tp
operator|->
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|addressprint
operator|||
operator|(
name|tp
operator|->
name|source_file
operator|==
name|NULL
operator|)
condition|)
block|{
name|printf_filtered
argument_list|(
literal|" at "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|tp
operator|->
name|address
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|source_file
condition|)
name|printf_filtered
argument_list|(
literal|": file %s, line %d."
argument_list|,
name|tp
operator|->
name|source_file
argument_list|,
name|tp
operator|->
name|line_number
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print information on tracepoint number TPNUM_EXP, or all if omitted.  */
end_comment

begin_function
specifier|static
name|void
name|tracepoints_info
parameter_list|(
name|char
modifier|*
name|tpnum_exp
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|tracepoint
modifier|*
name|t
decl_stmt|;
name|struct
name|action_line
modifier|*
name|action
decl_stmt|;
name|int
name|found_a_tracepoint
init|=
literal|0
decl_stmt|;
name|char
name|wrap_indent
index|[
literal|80
index|]
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|int
name|tpnum
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|tpnum_exp
condition|)
name|tpnum
operator|=
name|parse_and_eval_long
argument_list|(
name|tpnum_exp
argument_list|)
expr_stmt|;
name|ALL_TRACEPOINTS
argument_list|(
argument|t
argument_list|)
if|if
condition|(
name|tpnum
operator|==
operator|-
literal|1
operator|||
name|tpnum
operator|==
name|t
operator|->
name|number
condition|)
block|{
specifier|extern
name|int
name|addressprint
decl_stmt|;
comment|/* print machine addresses? */
if|if
condition|(
operator|!
name|found_a_tracepoint
operator|++
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Num Enb "
argument_list|)
expr_stmt|;
if|if
condition|(
name|addressprint
condition|)
block|{
if|if
condition|(
name|TARGET_ADDR_BIT
operator|<=
literal|32
condition|)
name|printf_filtered
argument_list|(
literal|"Address    "
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"Address            "
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"PassC StepC What\n"
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|wrap_indent
argument_list|,
literal|"                           "
argument_list|)
expr_stmt|;
if|if
condition|(
name|addressprint
condition|)
block|{
if|if
condition|(
name|TARGET_ADDR_BIT
operator|<=
literal|32
condition|)
name|strcat
argument_list|(
name|wrap_indent
argument_list|,
literal|"           "
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|wrap_indent
argument_list|,
literal|"                   "
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"%-3d %-3s "
argument_list|,
name|t
operator|->
name|number
argument_list|,
name|t
operator|->
name|enabled_p
condition|?
literal|"y"
else|:
literal|"n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|addressprint
condition|)
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|TARGET_ADDR_BIT
operator|<=
literal|32
condition|)
name|tmp
operator|=
name|local_hex_string_custom
argument_list|(
name|t
operator|->
name|address
operator|&
operator|(
name|CORE_ADDR
operator|)
literal|0xffffffff
argument_list|,
literal|"08l"
argument_list|)
expr_stmt|;
else|else
name|tmp
operator|=
name|local_hex_string_custom
argument_list|(
name|t
operator|->
name|address
argument_list|,
literal|"016l"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s "
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"%-5d %-5ld "
argument_list|,
name|t
operator|->
name|pass_count
argument_list|,
name|t
operator|->
name|step_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|source_file
condition|)
block|{
name|sym
operator|=
name|find_pc_sect_function
argument_list|(
name|t
operator|->
name|address
argument_list|,
name|t
operator|->
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"in "
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|SYMBOL_PRINT_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
name|wrap_indent
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" at "
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
name|t
operator|->
name|source_file
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|":%d"
argument_list|,
name|t
operator|->
name|line_number
argument_list|)
expr_stmt|;
block|}
else|else
name|print_address_symbolic
argument_list|(
name|t
operator|->
name|address
argument_list|,
name|gdb_stdout
argument_list|,
name|demangle
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|actions
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"  Actions for tracepoint %d: \n"
argument_list|,
name|t
operator|->
name|number
argument_list|)
expr_stmt|;
for|for
control|(
name|action
operator|=
name|t
operator|->
name|actions
init|;
name|action
condition|;
name|action
operator|=
name|action
operator|->
name|next
control|)
block|{
name|printf_filtered
argument_list|(
literal|"\t%s\n"
argument_list|,
name|action
operator|->
name|action
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|found_a_tracepoint
condition|)
block|{
if|if
condition|(
name|tpnum
operator|==
operator|-
literal|1
condition|)
name|printf_filtered
argument_list|(
literal|"No tracepoints.\n"
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"No tracepoint number %d.\n"
argument_list|,
name|tpnum
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Optimization: the code to parse an enable, disable, or delete TP command    is virtually identical except for whether it performs an enable, disable,    or delete.  Therefore I've combined them into one function with an opcode.  */
end_comment

begin_enum
enum|enum
name|tracepoint_opcode
block|{
name|enable_op
block|,
name|disable_op
block|,
name|delete_op
block|}
enum|;
end_enum

begin_comment
comment|/* This function implements enable, disable and delete commands. */
end_comment

begin_function
specifier|static
name|void
name|tracepoint_operation
parameter_list|(
name|struct
name|tracepoint
modifier|*
name|t
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|enum
name|tracepoint_opcode
name|opcode
parameter_list|)
block|{
name|struct
name|tracepoint
modifier|*
name|t2
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
comment|/* no tracepoint operand */
return|return;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|enable_op
case|:
name|t
operator|->
name|enabled_p
operator|=
literal|1
expr_stmt|;
name|tracepoint_modify_event
argument_list|(
name|t
operator|->
name|number
argument_list|)
expr_stmt|;
break|break;
case|case
name|disable_op
case|:
name|t
operator|->
name|enabled_p
operator|=
literal|0
expr_stmt|;
name|tracepoint_modify_event
argument_list|(
name|t
operator|->
name|number
argument_list|)
expr_stmt|;
break|break;
case|case
name|delete_op
case|:
if|if
condition|(
name|tracepoint_chain
operator|==
name|t
condition|)
name|tracepoint_chain
operator|=
name|t
operator|->
name|next
expr_stmt|;
name|ALL_TRACEPOINTS
argument_list|(
argument|t2
argument_list|)
if|if
condition|(
name|t2
operator|->
name|next
operator|==
name|t
condition|)
block|{
name|tracepoint_delete_event
argument_list|(
name|t2
operator|->
name|number
argument_list|)
expr_stmt|;
name|t2
operator|->
name|next
operator|=
name|t
operator|->
name|next
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|t
operator|->
name|addr_string
condition|)
name|xfree
argument_list|(
name|t
operator|->
name|addr_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|source_file
condition|)
name|xfree
argument_list|(
name|t
operator|->
name|source_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|actions
condition|)
name|free_actions
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Utility: parse a tracepoint number and look it up in the list.    If MULTI_P is true, there might be a range of tracepoints in ARG.    if OPTIONAL_P is true, then if the argument is missing, the most    recent tracepoint (tracepoint_count) is returned.  */
end_comment

begin_function
name|struct
name|tracepoint
modifier|*
name|get_tracepoint_by_number
parameter_list|(
name|char
modifier|*
modifier|*
name|arg
parameter_list|,
name|int
name|multi_p
parameter_list|,
name|int
name|optional_p
parameter_list|)
block|{
name|struct
name|tracepoint
modifier|*
name|t
decl_stmt|;
name|int
name|tpnum
decl_stmt|;
name|char
modifier|*
name|instring
init|=
name|arg
operator|==
name|NULL
condition|?
name|NULL
else|:
operator|*
name|arg
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
operator|||
operator|*
name|arg
operator|==
name|NULL
operator|||
operator|!
operator|*
operator|*
name|arg
condition|)
block|{
if|if
condition|(
name|optional_p
condition|)
name|tpnum
operator|=
name|tracepoint_count
expr_stmt|;
else|else
name|error_no_arg
argument_list|(
literal|"tracepoint number"
argument_list|)
expr_stmt|;
block|}
else|else
name|tpnum
operator|=
name|multi_p
condition|?
name|get_number_or_range
argument_list|(
name|arg
argument_list|)
else|:
name|get_number
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpnum
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|instring
operator|&&
operator|*
name|instring
condition|)
name|printf_filtered
argument_list|(
literal|"bad tracepoint number at or near '%s'\n"
argument_list|,
name|instring
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"Tracepoint argument missing and no previous tracepoint\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ALL_TRACEPOINTS
argument_list|(
argument|t
argument_list|)
if|if
condition|(
name|t
operator|->
name|number
operator|==
name|tpnum
condition|)
block|{
return|return
name|t
return|;
block|}
comment|/* FIXME: if we are in the middle of a range we don't want to give      a message.  The current interface to get_number_or_range doesn't      allow us to discover this.  */
name|printf_unfiltered
argument_list|(
literal|"No tracepoint number %d.\n"
argument_list|,
name|tpnum
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Utility: parse a list of tracepoint numbers, and call a func for each. */
end_comment

begin_function
specifier|static
name|void
name|map_args_over_tracepoints
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|enum
name|tracepoint_opcode
name|opcode
parameter_list|)
block|{
name|struct
name|tracepoint
modifier|*
name|t
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|args
operator|==
literal|0
operator|||
operator|*
name|args
operator|==
literal|0
condition|)
comment|/* do them all */
name|ALL_TRACEPOINTS_SAFE
argument_list|(
argument|t
argument_list|,
argument|tmp
argument_list|)
name|tracepoint_operation
argument_list|(
name|t
argument_list|,
name|from_tty
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
operator|*
name|args
condition|)
block|{
name|QUIT
expr_stmt|;
comment|/* give user option to bail out with ^C */
name|t
operator|=
name|get_tracepoint_by_number
argument_list|(
operator|&
name|args
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tracepoint_operation
argument_list|(
name|t
argument_list|,
name|from_tty
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|args
operator|==
literal|' '
operator|||
operator|*
name|args
operator|==
literal|'\t'
condition|)
name|args
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The 'enable trace' command enables tracepoints.  Not supported by all targets.  */
end_comment

begin_function
specifier|static
name|void
name|enable_trace_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|dont_repeat
argument_list|()
expr_stmt|;
name|map_args_over_tracepoints
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|,
name|enable_op
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The 'disable trace' command enables tracepoints.  Not supported by all targets.  */
end_comment

begin_function
specifier|static
name|void
name|disable_trace_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|dont_repeat
argument_list|()
expr_stmt|;
name|map_args_over_tracepoints
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|,
name|disable_op
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove a tracepoint (or all if no argument) */
end_comment

begin_function
specifier|static
name|void
name|delete_trace_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|dont_repeat
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|args
operator|||
operator|!
operator|*
name|args
condition|)
comment|/* No args implies all tracepoints; */
if|if
condition|(
name|from_tty
condition|)
comment|/* confirm only if from_tty... */
if|if
condition|(
name|tracepoint_chain
condition|)
comment|/* and if there are tracepoints to delete! */
if|if
condition|(
operator|!
name|query
argument_list|(
literal|"Delete all tracepoints? "
argument_list|)
condition|)
return|return;
name|map_args_over_tracepoints
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|,
name|delete_op
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set passcount for tracepoint.     First command argument is passcount, second is tracepoint number.    If tracepoint number omitted, apply to most recently defined.    Also accepts special argument "all".  */
end_comment

begin_function
specifier|static
name|void
name|trace_pass_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|tracepoint
modifier|*
name|t1
init|=
operator|(
expr|struct
name|tracepoint
operator|*
operator|)
operator|-
literal|1
decl_stmt|,
modifier|*
name|t2
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|int
name|all
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|args
operator|==
literal|0
operator|||
operator|*
name|args
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"passcount command requires an argument (count + optional TP num)"
argument_list|)
expr_stmt|;
name|count
operator|=
name|strtoul
argument_list|(
name|args
argument_list|,
operator|&
name|args
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* count comes first, then TP num */
while|while
condition|(
operator|*
name|args
operator|&&
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|args
argument_list|)
condition|)
name|args
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|args
operator|&&
name|strncasecmp
argument_list|(
name|args
argument_list|,
literal|"all"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|args
operator|+=
literal|3
expr_stmt|;
comment|/* skip special argument "all" */
name|all
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|args
condition|)
name|error
argument_list|(
literal|"Junk at end of arguments."
argument_list|)
expr_stmt|;
block|}
else|else
name|t1
operator|=
name|get_tracepoint_by_number
argument_list|(
operator|&
name|args
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|t1
condition|)
block|{
name|ALL_TRACEPOINTS
argument_list|(
argument|t2
argument_list|)
if|if
condition|(
name|t1
operator|==
operator|(
expr|struct
name|tracepoint
operator|*
operator|)
operator|-
literal|1
operator|||
name|t1
operator|==
name|t2
condition|)
block|{
name|t2
operator|->
name|pass_count
operator|=
name|count
expr_stmt|;
name|tracepoint_modify_event
argument_list|(
name|t2
operator|->
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf_filtered
argument_list|(
literal|"Setting tracepoint %d's passcount to %d\n"
argument_list|,
name|t2
operator|->
name|number
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|all
operator|&&
operator|*
name|args
condition|)
name|t1
operator|=
name|get_tracepoint_by_number
argument_list|(
operator|&
name|args
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|*
name|args
condition|)
do|;
block|}
end_function

begin_comment
comment|/* ACTIONS functions: */
end_comment

begin_comment
comment|/* Prototypes for action-parsing utility commands  */
end_comment

begin_function_decl
specifier|static
name|void
name|read_actions
parameter_list|(
name|struct
name|tracepoint
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The three functions:    collect_pseudocommand,     while_stepping_pseudocommand, and     end_actions_pseudocommand    are placeholders for "commands" that are actually ONLY to be used    within a tracepoint action list.  If the actual function is ever called,    it means that somebody issued the "command" at the top level,    which is always an error.  */
end_comment

begin_function
specifier|static
name|void
name|end_actions_pseudocommand
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|error
argument_list|(
literal|"This command cannot be used at the top level."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|while_stepping_pseudocommand
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|error
argument_list|(
literal|"This command can only be used in a tracepoint actions list."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|collect_pseudocommand
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|error
argument_list|(
literal|"This command can only be used in a tracepoint actions list."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Enter a list of actions for a tracepoint.  */
end_comment

begin_function
specifier|static
name|void
name|trace_actions_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|tracepoint
modifier|*
name|t
decl_stmt|;
name|char
name|tmpbuf
index|[
literal|128
index|]
decl_stmt|;
name|char
modifier|*
name|end_msg
init|=
literal|"End with a line saying just \"end\"."
decl_stmt|;
name|t
operator|=
name|get_tracepoint_by_number
argument_list|(
operator|&
name|args
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
condition|)
block|{
name|sprintf
argument_list|(
name|tmpbuf
argument_list|,
literal|"Enter actions for tracepoint %d, one per line."
argument_list|,
name|t
operator|->
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
if|if
condition|(
name|readline_begin_hook
condition|)
call|(
modifier|*
name|readline_begin_hook
call|)
argument_list|(
literal|"%s  %s\n"
argument_list|,
name|tmpbuf
argument_list|,
name|end_msg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|input_from_terminal_p
argument_list|()
condition|)
name|printf_filtered
argument_list|(
literal|"%s\n%s\n"
argument_list|,
name|tmpbuf
argument_list|,
name|end_msg
argument_list|)
expr_stmt|;
block|}
name|free_actions
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|->
name|step_count
operator|=
literal|0
expr_stmt|;
comment|/* read_actions may set this */
name|read_actions
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|readline_end_hook
condition|)
call|(
modifier|*
name|readline_end_hook
call|)
argument_list|()
expr_stmt|;
comment|/* tracepoints_changed () */
block|}
comment|/* else just return */
block|}
end_function

begin_comment
comment|/* worker function */
end_comment

begin_function
specifier|static
name|void
name|read_actions
parameter_list|(
name|struct
name|tracepoint
modifier|*
name|t
parameter_list|)
block|{
name|char
modifier|*
name|line
decl_stmt|;
name|char
modifier|*
name|prompt1
init|=
literal|"> "
decl_stmt|,
modifier|*
name|prompt2
init|=
literal|"> "
decl_stmt|;
name|char
modifier|*
name|prompt
init|=
name|prompt1
decl_stmt|;
name|enum
name|actionline_type
name|linetype
decl_stmt|;
specifier|extern
name|FILE
modifier|*
name|instream
decl_stmt|;
name|struct
name|action_line
modifier|*
name|next
init|=
name|NULL
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
comment|/* Control-C quits instantly if typed while in this loop      since it should not wait until the user types a newline.  */
name|immediate_quit
operator|++
expr_stmt|;
comment|/* FIXME: kettenis/20010823: Something is wrong here.  In this file      STOP_SIGNAL is never defined.  So this code has been left out, at      least for quite a while now.  Replacing STOP_SIGNAL with SIGTSTP      leads to compilation failures since the variable job_control      isn't declared.  Leave this alone for now.  */
ifdef|#
directive|ifdef
name|STOP_SIGNAL
if|if
condition|(
name|job_control
condition|)
block|{
if|if
condition|(
name|event_loop_p
condition|)
name|signal
argument_list|(
name|STOP_SIGNAL
argument_list|,
name|handle_stop_sig
argument_list|)
expr_stmt|;
else|else
name|signal
argument_list|(
name|STOP_SIGNAL
argument_list|,
name|stop_sig
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|old_chain
operator|=
name|make_cleanup_free_actions
argument_list|(
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Make sure that all output has been output.  Some machines may let          you get away with leaving out some of the gdb_flush, but not all.  */
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|readline_hook
operator|&&
name|instream
operator|==
name|NULL
condition|)
name|line
operator|=
call|(
modifier|*
name|readline_hook
call|)
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|instream
operator|==
name|stdin
operator|&&
name|ISATTY
argument_list|(
name|instream
argument_list|)
condition|)
block|{
name|line
operator|=
name|gdb_readline_wrapper
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|&&
operator|*
name|line
condition|)
comment|/* add it to command history */
name|add_history
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
else|else
name|line
operator|=
name|gdb_readline
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|linetype
operator|=
name|validate_actionline
argument_list|(
operator|&
name|line
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|linetype
operator|==
name|BADLINE
condition|)
continue|continue;
comment|/* already warned -- collect another line */
name|temp
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|action_line
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|temp
operator|->
name|action
operator|=
name|line
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
comment|/* first action for this tracepoint? */
name|t
operator|->
name|actions
operator|=
name|next
operator|=
name|temp
expr_stmt|;
else|else
block|{
name|next
operator|->
name|next
operator|=
name|temp
expr_stmt|;
name|next
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
name|linetype
operator|==
name|STEPPING
condition|)
comment|/* begin "while-stepping" */
block|{
if|if
condition|(
name|prompt
operator|==
name|prompt2
condition|)
block|{
name|warning
argument_list|(
literal|"Already processing 'while-stepping'"
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
name|prompt
operator|=
name|prompt2
expr_stmt|;
comment|/* change prompt for stepping actions */
block|}
elseif|else
if|if
condition|(
name|linetype
operator|==
name|END
condition|)
block|{
if|if
condition|(
name|prompt
operator|==
name|prompt2
condition|)
block|{
name|prompt
operator|=
name|prompt1
expr_stmt|;
comment|/* end of single-stepping actions */
block|}
else|else
block|{
comment|/* end of actions */
if|if
condition|(
name|t
operator|->
name|actions
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
comment|/* an "end" all by itself with no other actions means 		     this tracepoint has no actions.  Discard empty list. */
name|free_actions
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|STOP_SIGNAL
if|if
condition|(
name|job_control
condition|)
name|signal
argument_list|(
name|STOP_SIGNAL
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|immediate_quit
operator|--
expr_stmt|;
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* worker function */
end_comment

begin_function
name|enum
name|actionline_type
name|validate_actionline
parameter_list|(
name|char
modifier|*
modifier|*
name|line
parameter_list|,
name|struct
name|tracepoint
modifier|*
name|t
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|struct
name|expression
modifier|*
name|exp
init|=
name|NULL
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* if EOF is typed, *line is NULL */
if|if
condition|(
operator|*
name|line
operator|==
name|NULL
condition|)
return|return
name|END
return|;
for|for
control|(
name|p
operator|=
operator|*
name|line
init|;
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|p
argument_list|)
condition|;
control|)
name|p
operator|++
expr_stmt|;
comment|/* symbol lookup etc. */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
comment|/* empty line: just prompt for another line. */
return|return
name|BADLINE
return|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'#'
condition|)
comment|/* comment line */
return|return
name|GENERIC
return|;
name|c
operator|=
name|lookup_cmd
argument_list|(
operator|&
name|p
argument_list|,
name|cmdlist
argument_list|,
literal|""
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"'%s' is not an action that I know, or is ambiguous."
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|BADLINE
return|;
block|}
if|if
condition|(
name|cmd_cfunc_eq
argument_list|(
name|c
argument_list|,
name|collect_pseudocommand
argument_list|)
condition|)
block|{
name|struct
name|agent_expr
modifier|*
name|aexpr
decl_stmt|;
name|struct
name|agent_reqs
name|areqs
decl_stmt|;
do|do
block|{
comment|/* repeat over a comma-separated list */
name|QUIT
expr_stmt|;
comment|/* allow user to bail out with ^C */
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'$'
condition|)
comment|/* look for special pseudo-symbols */
block|{
if|if
condition|(
operator|(
literal|0
operator|==
name|strncasecmp
argument_list|(
literal|"reg"
argument_list|,
name|p
operator|+
literal|1
argument_list|,
literal|3
argument_list|)
operator|)
operator|||
operator|(
literal|0
operator|==
name|strncasecmp
argument_list|(
literal|"arg"
argument_list|,
name|p
operator|+
literal|1
argument_list|,
literal|3
argument_list|)
operator|)
operator|||
operator|(
literal|0
operator|==
name|strncasecmp
argument_list|(
literal|"loc"
argument_list|,
name|p
operator|+
literal|1
argument_list|,
literal|3
argument_list|)
operator|)
condition|)
block|{
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|','
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* else fall thru, treat p as an expression and parse it! */
block|}
name|exp
operator|=
name|parse_exp_1
argument_list|(
operator|&
name|p
argument_list|,
name|block_for_pc
argument_list|(
name|t
operator|->
name|address
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|elts
index|[
literal|0
index|]
operator|.
name|opcode
operator|==
name|OP_VAR_VALUE
condition|)
block|{
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|exp
operator|->
name|elts
index|[
literal|2
index|]
operator|.
name|symbol
argument_list|)
operator|==
name|LOC_CONST
condition|)
block|{
name|warning
argument_list|(
literal|"constant %s (value %ld) will not be collected."
argument_list|,
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|exp
operator|->
name|elts
index|[
literal|2
index|]
operator|.
name|symbol
argument_list|)
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|exp
operator|->
name|elts
index|[
literal|2
index|]
operator|.
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|BADLINE
return|;
block|}
elseif|else
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|exp
operator|->
name|elts
index|[
literal|2
index|]
operator|.
name|symbol
argument_list|)
operator|==
name|LOC_OPTIMIZED_OUT
condition|)
block|{
name|warning
argument_list|(
literal|"%s is optimized away and cannot be collected."
argument_list|,
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|exp
operator|->
name|elts
index|[
literal|2
index|]
operator|.
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|BADLINE
return|;
block|}
block|}
comment|/* we have something to collect, make sure that the expr to 	     bytecode translator can handle it and that it's not too long */
name|aexpr
operator|=
name|gen_trace_for_expr
argument_list|(
name|t
operator|->
name|address
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|make_cleanup_free_agent_expr
argument_list|(
name|aexpr
argument_list|)
expr_stmt|;
if|if
condition|(
name|aexpr
operator|->
name|len
operator|>
name|MAX_AGENT_EXPR_LEN
condition|)
name|error
argument_list|(
literal|"expression too complicated, try simplifying"
argument_list|)
expr_stmt|;
name|ax_reqs
argument_list|(
name|aexpr
argument_list|,
operator|&
name|areqs
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|areqs
operator|.
name|reg_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|areqs
operator|.
name|flaw
operator|!=
name|agent_flaw_none
condition|)
name|error
argument_list|(
literal|"malformed expression"
argument_list|)
expr_stmt|;
if|if
condition|(
name|areqs
operator|.
name|min_height
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"gdb: Internal error: expression has min height< 0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|areqs
operator|.
name|max_height
operator|>
literal|20
condition|)
name|error
argument_list|(
literal|"expression too complicated, try simplifying"
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|&&
operator|*
name|p
operator|++
operator|==
literal|','
condition|)
do|;
return|return
name|GENERIC
return|;
block|}
elseif|else
if|if
condition|(
name|cmd_cfunc_eq
argument_list|(
name|c
argument_list|,
name|while_stepping_pseudocommand
argument_list|)
condition|)
block|{
name|char
modifier|*
name|steparg
decl_stmt|;
comment|/* in case warning is necessary */
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
name|steparg
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
operator|||
operator|(
name|t
operator|->
name|step_count
operator|=
name|strtol
argument_list|(
name|p
argument_list|,
operator|&
name|p
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"'%s': bad step-count; command ignored."
argument_list|,
operator|*
name|line
argument_list|)
expr_stmt|;
return|return
name|BADLINE
return|;
block|}
return|return
name|STEPPING
return|;
block|}
elseif|else
if|if
condition|(
name|cmd_cfunc_eq
argument_list|(
name|c
argument_list|,
name|end_actions_pseudocommand
argument_list|)
condition|)
return|return
name|END
return|;
else|else
block|{
name|warning
argument_list|(
literal|"'%s' is not a supported tracepoint action."
argument_list|,
operator|*
name|line
argument_list|)
expr_stmt|;
return|return
name|BADLINE
return|;
block|}
block|}
end_function

begin_comment
comment|/* worker function */
end_comment

begin_function
name|void
name|free_actions
parameter_list|(
name|struct
name|tracepoint
modifier|*
name|t
parameter_list|)
block|{
name|struct
name|action_line
modifier|*
name|line
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|line
operator|=
name|t
operator|->
name|actions
init|;
name|line
condition|;
name|line
operator|=
name|next
control|)
block|{
name|next
operator|=
name|line
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|line
operator|->
name|action
condition|)
name|xfree
argument_list|(
name|line
operator|->
name|action
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
name|t
operator|->
name|actions
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_free_actions_cleanup
parameter_list|(
name|void
modifier|*
name|t
parameter_list|)
block|{
name|free_actions
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|cleanup
modifier|*
name|make_cleanup_free_actions
parameter_list|(
name|struct
name|tracepoint
modifier|*
name|t
parameter_list|)
block|{
return|return
name|make_cleanup
argument_list|(
name|do_free_actions_cleanup
argument_list|,
name|t
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|memrange
block|{
name|int
name|type
decl_stmt|;
comment|/* 0 for absolute memory range, else basereg number */
name|bfd_signed_vma
name|start
decl_stmt|;
name|bfd_signed_vma
name|end
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|collection_list
block|{
name|unsigned
name|char
name|regs_mask
index|[
literal|8
index|]
decl_stmt|;
comment|/* room for up to 256 regs */
name|long
name|listsize
decl_stmt|;
name|long
name|next_memrange
decl_stmt|;
name|struct
name|memrange
modifier|*
name|list
decl_stmt|;
name|long
name|aexpr_listsize
decl_stmt|;
comment|/* size of array pointed to by expr_list elt */
name|long
name|next_aexpr_elt
decl_stmt|;
name|struct
name|agent_expr
modifier|*
modifier|*
name|aexpr_list
decl_stmt|;
block|}
name|tracepoint_list
struct|,
name|stepping_list
struct|;
end_struct

begin_comment
comment|/* MEMRANGE functions: */
end_comment

begin_function_decl
specifier|static
name|int
name|memrange_cmp
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* compare memranges for qsort */
end_comment

begin_function
specifier|static
name|int
name|memrange_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|va
parameter_list|,
specifier|const
name|void
modifier|*
name|vb
parameter_list|)
block|{
specifier|const
name|struct
name|memrange
modifier|*
name|a
init|=
name|va
decl_stmt|,
modifier|*
name|b
init|=
name|vb
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|type
operator|<
name|b
operator|->
name|type
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|a
operator|->
name|type
operator|>
name|b
operator|->
name|type
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|a
operator|->
name|type
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|bfd_vma
operator|)
name|a
operator|->
name|start
operator|<
operator|(
name|bfd_vma
operator|)
name|b
operator|->
name|start
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
name|bfd_vma
operator|)
name|a
operator|->
name|start
operator|>
operator|(
name|bfd_vma
operator|)
name|b
operator|->
name|start
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
name|a
operator|->
name|start
operator|<
name|b
operator|->
name|start
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|a
operator|->
name|start
operator|>
name|b
operator|->
name|start
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Sort the memrange list using qsort, and merge adjacent memranges */
end_comment

begin_function
specifier|static
name|void
name|memrange_sortmerge
parameter_list|(
name|struct
name|collection_list
modifier|*
name|memranges
parameter_list|)
block|{
name|int
name|a
decl_stmt|,
name|b
decl_stmt|;
name|qsort
argument_list|(
name|memranges
operator|->
name|list
argument_list|,
name|memranges
operator|->
name|next_memrange
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|memrange
argument_list|)
argument_list|,
name|memrange_cmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|memranges
operator|->
name|next_memrange
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|a
operator|=
literal|0
operator|,
name|b
operator|=
literal|1
init|;
name|b
operator|<
name|memranges
operator|->
name|next_memrange
condition|;
name|b
operator|++
control|)
block|{
if|if
condition|(
name|memranges
operator|->
name|list
index|[
name|a
index|]
operator|.
name|type
operator|==
name|memranges
operator|->
name|list
index|[
name|b
index|]
operator|.
name|type
operator|&&
name|memranges
operator|->
name|list
index|[
name|b
index|]
operator|.
name|start
operator|-
name|memranges
operator|->
name|list
index|[
name|a
index|]
operator|.
name|end
operator|<=
name|MAX_REGISTER_SIZE
condition|)
block|{
comment|/* memrange b starts before memrange a ends; merge them.  */
if|if
condition|(
name|memranges
operator|->
name|list
index|[
name|b
index|]
operator|.
name|end
operator|>
name|memranges
operator|->
name|list
index|[
name|a
index|]
operator|.
name|end
condition|)
name|memranges
operator|->
name|list
index|[
name|a
index|]
operator|.
name|end
operator|=
name|memranges
operator|->
name|list
index|[
name|b
index|]
operator|.
name|end
expr_stmt|;
continue|continue;
comment|/* next b, same a */
block|}
name|a
operator|++
expr_stmt|;
comment|/* next a */
if|if
condition|(
name|a
operator|!=
name|b
condition|)
name|memcpy
argument_list|(
operator|&
name|memranges
operator|->
name|list
index|[
name|a
index|]
argument_list|,
operator|&
name|memranges
operator|->
name|list
index|[
name|b
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|memrange
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|memranges
operator|->
name|next_memrange
operator|=
name|a
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add a register to a collection list */
end_comment

begin_function
specifier|static
name|void
name|add_register
parameter_list|(
name|struct
name|collection_list
modifier|*
name|collection
parameter_list|,
name|unsigned
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"collect register %d\n"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|collection
operator|->
name|regs_mask
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"Internal: register number %d too large for tracepoint"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|collection
operator|->
name|regs_mask
index|[
name|regno
operator|/
literal|8
index|]
operator||=
literal|1
operator|<<
operator|(
name|regno
operator|%
literal|8
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a memrange to a collection list */
end_comment

begin_function
specifier|static
name|void
name|add_memrange
parameter_list|(
name|struct
name|collection_list
modifier|*
name|memranges
parameter_list|,
name|int
name|type
parameter_list|,
name|bfd_signed_vma
name|base
parameter_list|,
name|unsigned
name|long
name|len
parameter_list|)
block|{
if|if
condition|(
name|info_verbose
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"(%d,"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|printf_vma
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|",%ld)\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* type: 0 == memory, n == basereg */
name|memranges
operator|->
name|list
index|[
name|memranges
operator|->
name|next_memrange
index|]
operator|.
name|type
operator|=
name|type
expr_stmt|;
comment|/* base: addr if memory, offset if reg relative. */
name|memranges
operator|->
name|list
index|[
name|memranges
operator|->
name|next_memrange
index|]
operator|.
name|start
operator|=
name|base
expr_stmt|;
comment|/* len: we actually save end (base + len) for convenience */
name|memranges
operator|->
name|list
index|[
name|memranges
operator|->
name|next_memrange
index|]
operator|.
name|end
operator|=
name|base
operator|+
name|len
expr_stmt|;
name|memranges
operator|->
name|next_memrange
operator|++
expr_stmt|;
if|if
condition|(
name|memranges
operator|->
name|next_memrange
operator|>=
name|memranges
operator|->
name|listsize
condition|)
block|{
name|memranges
operator|->
name|listsize
operator|*=
literal|2
expr_stmt|;
name|memranges
operator|->
name|list
operator|=
name|xrealloc
argument_list|(
name|memranges
operator|->
name|list
argument_list|,
name|memranges
operator|->
name|listsize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|!=
operator|-
literal|1
condition|)
comment|/* better collect the base register! */
name|add_register
argument_list|(
name|memranges
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a symbol to a collection list */
end_comment

begin_function
specifier|static
name|void
name|collect_symbol
parameter_list|(
name|struct
name|collection_list
modifier|*
name|collect
parameter_list|,
name|struct
name|symbol
modifier|*
name|sym
parameter_list|,
name|long
name|frame_regno
parameter_list|,
name|long
name|frame_offset
parameter_list|)
block|{
name|unsigned
name|long
name|len
decl_stmt|;
name|unsigned
name|int
name|reg
decl_stmt|;
name|bfd_signed_vma
name|offset
decl_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|check_typedef
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
condition|)
block|{
default|default:
name|printf_filtered
argument_list|(
literal|"%s: don't know symbol class %d\n"
argument_list|,
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_CONST
case|:
name|printf_filtered
argument_list|(
literal|"constant %s (value %ld) will not be collected.\n"
argument_list|,
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_STATIC
case|:
name|offset
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_verbose
condition|)
block|{
name|char
name|tmp
index|[
literal|40
index|]
decl_stmt|;
name|sprintf_vma
argument_list|(
name|tmp
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"LOC_STATIC %s: collect %ld bytes at %s.\n"
argument_list|,
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|len
argument_list|,
name|tmp
comment|/* address */
argument_list|)
expr_stmt|;
block|}
name|add_memrange
argument_list|(
name|collect
argument_list|,
operator|-
literal|1
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* 0 == memory */
break|break;
case|case
name|LOC_REGISTER
case|:
case|case
name|LOC_REGPARM
case|:
name|reg
operator|=
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"LOC_REG[parm] %s: "
argument_list|,
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|add_register
argument_list|(
name|collect
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* check for doubles stored in two registers */
comment|/* FIXME: how about larger types stored in 3 or more regs? */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_FLT
operator|&&
name|len
operator|>
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|reg
argument_list|)
condition|)
name|add_register
argument_list|(
name|collect
argument_list|,
name|reg
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_REF_ARG
case|:
name|printf_filtered
argument_list|(
literal|"Sorry, don't know how to do LOC_REF_ARG yet.\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"       (will not collect %s)\n"
argument_list|,
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_ARG
case|:
name|reg
operator|=
name|frame_regno
expr_stmt|;
name|offset
operator|=
name|frame_offset
operator|+
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_verbose
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"LOC_LOCAL %s: Collect %ld bytes at offset "
argument_list|,
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|printf_vma
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" from frame ptr reg %d\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
name|add_memrange
argument_list|(
name|collect
argument_list|,
name|reg
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_REGPARM_ADDR
case|:
name|reg
operator|=
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|info_verbose
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"LOC_REGPARM_ADDR %s: Collect %ld bytes at offset "
argument_list|,
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|printf_vma
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" from reg %d\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
name|add_memrange
argument_list|(
name|collect
argument_list|,
name|reg
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_LOCAL
case|:
case|case
name|LOC_LOCAL_ARG
case|:
name|reg
operator|=
name|frame_regno
expr_stmt|;
name|offset
operator|=
name|frame_offset
operator|+
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_verbose
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"LOC_LOCAL %s: Collect %ld bytes at offset "
argument_list|,
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|printf_vma
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" from frame ptr reg %d\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
name|add_memrange
argument_list|(
name|collect
argument_list|,
name|reg
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_BASEREG
case|:
case|case
name|LOC_BASEREG_ARG
case|:
name|reg
operator|=
name|SYMBOL_BASEREG
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|offset
operator|=
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_verbose
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"LOC_BASEREG %s: collect %ld bytes at offset "
argument_list|,
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|printf_vma
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" from basereg %d\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
name|add_memrange
argument_list|(
name|collect
argument_list|,
name|reg
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_UNRESOLVED
case|:
name|printf_filtered
argument_list|(
literal|"Don't know LOC_UNRESOLVED %s\n"
argument_list|,
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_OPTIMIZED_OUT
case|:
name|printf_filtered
argument_list|(
literal|"%s has been optimized out of existence.\n"
argument_list|,
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Add all locals (or args) symbols to collection list */
end_comment

begin_function
specifier|static
name|void
name|add_local_symbols
parameter_list|(
name|struct
name|collection_list
modifier|*
name|collect
parameter_list|,
name|CORE_ADDR
name|pc
parameter_list|,
name|long
name|frame_regno
parameter_list|,
name|long
name|frame_offset
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|block
modifier|*
name|block
decl_stmt|;
name|struct
name|dict_iterator
name|iter
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|block
operator|=
name|block_for_pc
argument_list|(
name|pc
argument_list|)
expr_stmt|;
while|while
condition|(
name|block
operator|!=
literal|0
condition|)
block|{
name|QUIT
expr_stmt|;
comment|/* allow user to bail out with ^C */
name|ALL_BLOCK_SYMBOLS
argument_list|(
argument|block
argument_list|,
argument|iter
argument_list|,
argument|sym
argument_list|)
block|{
switch|switch
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
condition|)
block|{
default|default:
name|warning
argument_list|(
literal|"don't know how to trace local symbol %s"
argument_list|,
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|LOC_LOCAL
case|:
case|case
name|LOC_STATIC
case|:
case|case
name|LOC_REGISTER
case|:
case|case
name|LOC_BASEREG
case|:
if|if
condition|(
name|type
operator|==
literal|'L'
condition|)
comment|/* collecting Locals */
block|{
name|count
operator|++
expr_stmt|;
name|collect_symbol
argument_list|(
name|collect
argument_list|,
name|sym
argument_list|,
name|frame_regno
argument_list|,
name|frame_offset
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LOC_ARG
case|:
case|case
name|LOC_LOCAL_ARG
case|:
case|case
name|LOC_REF_ARG
case|:
case|case
name|LOC_REGPARM
case|:
case|case
name|LOC_REGPARM_ADDR
case|:
case|case
name|LOC_BASEREG_ARG
case|:
if|if
condition|(
name|type
operator|==
literal|'A'
condition|)
comment|/* collecting Arguments */
block|{
name|count
operator|++
expr_stmt|;
name|collect_symbol
argument_list|(
name|collect
argument_list|,
name|sym
argument_list|,
name|frame_regno
argument_list|,
name|frame_offset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|BLOCK_FUNCTION
argument_list|(
name|block
argument_list|)
condition|)
break|break;
else|else
name|block
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"No %s found in scope."
argument_list|,
name|type
operator|==
literal|'L'
condition|?
literal|"locals"
else|:
literal|"args"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* worker function */
end_comment

begin_function
specifier|static
name|void
name|clear_collection_list
parameter_list|(
name|struct
name|collection_list
modifier|*
name|list
parameter_list|)
block|{
name|int
name|ndx
decl_stmt|;
name|list
operator|->
name|next_memrange
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ndx
operator|=
literal|0
init|;
name|ndx
operator|<
name|list
operator|->
name|next_aexpr_elt
condition|;
name|ndx
operator|++
control|)
block|{
name|free_agent_expr
argument_list|(
name|list
operator|->
name|aexpr_list
index|[
name|ndx
index|]
argument_list|)
expr_stmt|;
name|list
operator|->
name|aexpr_list
index|[
name|ndx
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|list
operator|->
name|next_aexpr_elt
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|list
operator|->
name|regs_mask
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|list
operator|->
name|regs_mask
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* reduce a collection list to string form (for gdb protocol) */
end_comment

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|stringify_collection_list
parameter_list|(
name|struct
name|collection_list
modifier|*
name|list
parameter_list|,
name|char
modifier|*
name|string
parameter_list|)
block|{
name|char
name|temp_buf
index|[
literal|2048
index|]
decl_stmt|;
name|char
name|tmp2
index|[
literal|40
index|]
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|ndx
init|=
literal|0
decl_stmt|;
name|char
argument_list|*
operator|(
operator|*
name|str_list
operator|)
index|[]
argument_list|;
name|char
operator|*
name|end
argument_list|;
name|long
name|i
argument_list|;
name|count
operator|=
literal|1
operator|+
name|list
operator|->
name|next_memrange
operator|+
name|list
operator|->
name|next_aexpr_elt
operator|+
literal|1
argument_list|;
name|str_list
operator|=
operator|(
name|char
operator|*
operator|(
operator|*
operator|)
index|[]
operator|)
name|xmalloc
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
argument_list|;    for
operator|(
name|i
operator|=
sizeof|sizeof
argument_list|(
name|list
operator|->
name|regs_mask
argument_list|)
operator|-
literal|1
expr|;
name|i
operator|>
literal|0
expr|;
name|i
operator|--
operator|)
if|if
condition|(
name|list
operator|->
name|regs_mask
index|[
name|i
index|]
operator|!=
literal|0
condition|)
comment|/* skip leading zeroes in regs_mask */
break|break;
if|if
condition|(
name|list
operator|->
name|regs_mask
index|[
name|i
index|]
operator|!=
literal|0
condition|)
comment|/* prepare to send regs_mask to the stub */
block|{
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"\nCollecting registers (mask): 0x"
argument_list|)
expr_stmt|;
name|end
operator|=
name|temp_buf
expr_stmt|;
operator|*
name|end
operator|++
operator|=
literal|'R'
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|QUIT
expr_stmt|;
comment|/* allow user to bail out with ^C */
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"%02X"
argument_list|,
name|list
operator|->
name|regs_mask
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|end
argument_list|,
literal|"%02X"
argument_list|,
name|list
operator|->
name|regs_mask
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|end
operator|+=
literal|2
expr_stmt|;
block|}
operator|(
operator|*
name|str_list
operator|)
index|[
name|ndx
index|]
operator|=
name|savestring
argument_list|(
name|temp_buf
argument_list|,
name|end
operator|-
name|temp_buf
argument_list|)
expr_stmt|;
name|ndx
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|->
name|next_memrange
operator|>
literal|0
operator|&&
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"Collecting memranges: \n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|count
operator|=
literal|0
operator|,
name|end
operator|=
name|temp_buf
init|;
name|i
operator|<
name|list
operator|->
name|next_memrange
condition|;
name|i
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
comment|/* allow user to bail out with ^C */
name|sprintf_vma
argument_list|(
name|tmp2
argument_list|,
name|list
operator|->
name|list
index|[
name|i
index|]
operator|.
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_verbose
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"(%d, %s, %ld)\n"
argument_list|,
name|list
operator|->
name|list
index|[
name|i
index|]
operator|.
name|type
argument_list|,
name|tmp2
argument_list|,
call|(
name|long
call|)
argument_list|(
name|list
operator|->
name|list
index|[
name|i
index|]
operator|.
name|end
operator|-
name|list
operator|->
name|list
index|[
name|i
index|]
operator|.
name|start
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|+
literal|27
operator|>
name|MAX_AGENT_EXPR_LEN
condition|)
block|{
operator|(
operator|*
name|str_list
operator|)
index|[
name|ndx
index|]
operator|=
name|savestring
argument_list|(
name|temp_buf
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|ndx
operator|++
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|end
operator|=
name|temp_buf
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|end
argument_list|,
literal|"M%X,%s,%lX"
argument_list|,
name|list
operator|->
name|list
index|[
name|i
index|]
operator|.
name|type
argument_list|,
name|tmp2
argument_list|,
call|(
name|long
call|)
argument_list|(
name|list
operator|->
name|list
index|[
name|i
index|]
operator|.
name|end
operator|-
name|list
operator|->
name|list
index|[
name|i
index|]
operator|.
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|+=
name|strlen
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|end
operator|+=
name|count
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list
operator|->
name|next_aexpr_elt
condition|;
name|i
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
comment|/* allow user to bail out with ^C */
if|if
condition|(
operator|(
name|count
operator|+
literal|10
operator|+
literal|2
operator|*
name|list
operator|->
name|aexpr_list
index|[
name|i
index|]
operator|->
name|len
operator|)
operator|>
name|MAX_AGENT_EXPR_LEN
condition|)
block|{
operator|(
operator|*
name|str_list
operator|)
index|[
name|ndx
index|]
operator|=
name|savestring
argument_list|(
name|temp_buf
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|ndx
operator|++
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|end
operator|=
name|temp_buf
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|end
argument_list|,
literal|"X%08X,"
argument_list|,
name|list
operator|->
name|aexpr_list
index|[
name|i
index|]
operator|->
name|len
argument_list|)
expr_stmt|;
name|end
operator|+=
literal|10
expr_stmt|;
comment|/* 'X' + 8 hex digits + ',' */
name|count
operator|+=
literal|10
expr_stmt|;
name|end
operator|=
name|mem2hex
argument_list|(
name|list
operator|->
name|aexpr_list
index|[
name|i
index|]
operator|->
name|buf
argument_list|,
name|end
argument_list|,
name|list
operator|->
name|aexpr_list
index|[
name|i
index|]
operator|->
name|len
argument_list|)
expr_stmt|;
name|count
operator|+=
literal|2
operator|*
name|list
operator|->
name|aexpr_list
index|[
name|i
index|]
operator|->
name|len
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
operator|(
operator|*
name|str_list
operator|)
index|[
name|ndx
index|]
operator|=
name|savestring
argument_list|(
name|temp_buf
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|ndx
operator|++
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|end
operator|=
name|temp_buf
expr_stmt|;
block|}
operator|(
operator|*
name|str_list
operator|)
index|[
name|ndx
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ndx
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
else|else
return|return
operator|*
name|str_list
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_actions_list_cleanup_wrapper
parameter_list|(
name|void
modifier|*
name|al
parameter_list|)
block|{
name|free_actions_list
argument_list|(
name|al
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_actions_list
parameter_list|(
name|char
modifier|*
modifier|*
name|actions_list
parameter_list|)
block|{
name|int
name|ndx
decl_stmt|;
if|if
condition|(
name|actions_list
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|ndx
operator|=
literal|0
init|;
name|actions_list
index|[
name|ndx
index|]
condition|;
name|ndx
operator|++
control|)
name|xfree
argument_list|(
name|actions_list
index|[
name|ndx
index|]
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|actions_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* render all actions into gdb protocol */
end_comment

begin_function
specifier|static
name|void
name|encode_actions
parameter_list|(
name|struct
name|tracepoint
modifier|*
name|t
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|tdp_actions
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
name|stepping_actions
parameter_list|)
block|{
specifier|static
name|char
name|tdp_buff
index|[
literal|2048
index|]
decl_stmt|,
name|step_buff
index|[
literal|2048
index|]
decl_stmt|;
name|char
modifier|*
name|action_exp
decl_stmt|;
name|struct
name|expression
modifier|*
name|exp
init|=
name|NULL
decl_stmt|;
name|struct
name|action_line
modifier|*
name|action
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|value
modifier|*
name|tempval
decl_stmt|;
name|struct
name|collection_list
modifier|*
name|collect
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|cmd
decl_stmt|;
name|struct
name|agent_expr
modifier|*
name|aexpr
decl_stmt|;
name|int
name|frame_reg
decl_stmt|;
name|LONGEST
name|frame_offset
decl_stmt|;
name|clear_collection_list
argument_list|(
operator|&
name|tracepoint_list
argument_list|)
expr_stmt|;
name|clear_collection_list
argument_list|(
operator|&
name|stepping_list
argument_list|)
expr_stmt|;
name|collect
operator|=
operator|&
name|tracepoint_list
expr_stmt|;
operator|*
name|tdp_actions
operator|=
name|NULL
expr_stmt|;
operator|*
name|stepping_actions
operator|=
name|NULL
expr_stmt|;
name|TARGET_VIRTUAL_FRAME_POINTER
argument_list|(
name|t
operator|->
name|address
argument_list|,
operator|&
name|frame_reg
argument_list|,
operator|&
name|frame_offset
argument_list|)
expr_stmt|;
for|for
control|(
name|action
operator|=
name|t
operator|->
name|actions
init|;
name|action
condition|;
name|action
operator|=
name|action
operator|->
name|next
control|)
block|{
name|QUIT
expr_stmt|;
comment|/* allow user to bail out with ^C */
name|action_exp
operator|=
name|action
operator|->
name|action
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|action_exp
argument_list|)
condition|)
name|action_exp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|action_exp
operator|==
literal|'#'
condition|)
comment|/* comment line */
return|return;
name|cmd
operator|=
name|lookup_cmd
argument_list|(
operator|&
name|action_exp
argument_list|,
name|cmdlist
argument_list|,
literal|""
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Bad action list item: %s"
argument_list|,
name|action_exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd_cfunc_eq
argument_list|(
name|cmd
argument_list|,
name|collect_pseudocommand
argument_list|)
condition|)
block|{
do|do
block|{
comment|/* repeat over a comma-separated list */
name|QUIT
expr_stmt|;
comment|/* allow user to bail out with ^C */
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|action_exp
argument_list|)
condition|)
name|action_exp
operator|++
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|strncasecmp
argument_list|(
literal|"$reg"
argument_list|,
name|action_exp
argument_list|,
literal|4
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
condition|;
name|i
operator|++
control|)
name|add_register
argument_list|(
name|collect
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|action_exp
operator|=
name|strchr
argument_list|(
name|action_exp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
comment|/* more? */
block|}
elseif|else
if|if
condition|(
literal|0
operator|==
name|strncasecmp
argument_list|(
literal|"$arg"
argument_list|,
name|action_exp
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|add_local_symbols
argument_list|(
name|collect
argument_list|,
name|t
operator|->
name|address
argument_list|,
name|frame_reg
argument_list|,
name|frame_offset
argument_list|,
literal|'A'
argument_list|)
expr_stmt|;
name|action_exp
operator|=
name|strchr
argument_list|(
name|action_exp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
comment|/* more? */
block|}
elseif|else
if|if
condition|(
literal|0
operator|==
name|strncasecmp
argument_list|(
literal|"$loc"
argument_list|,
name|action_exp
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|add_local_symbols
argument_list|(
name|collect
argument_list|,
name|t
operator|->
name|address
argument_list|,
name|frame_reg
argument_list|,
name|frame_offset
argument_list|,
literal|'L'
argument_list|)
expr_stmt|;
name|action_exp
operator|=
name|strchr
argument_list|(
name|action_exp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
comment|/* more? */
block|}
else|else
block|{
name|unsigned
name|long
name|addr
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|NULL
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain1
init|=
name|NULL
decl_stmt|;
name|struct
name|agent_reqs
name|areqs
decl_stmt|;
name|exp
operator|=
name|parse_exp_1
argument_list|(
operator|&
name|action_exp
argument_list|,
name|block_for_pc
argument_list|(
name|t
operator|->
name|address
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|exp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|exp
operator|->
name|elts
index|[
literal|0
index|]
operator|.
name|opcode
condition|)
block|{
case|case
name|OP_REGISTER
case|:
name|i
operator|=
name|exp
operator|->
name|elts
index|[
literal|1
index|]
operator|.
name|longconst
expr_stmt|;
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"OP_REGISTER: "
argument_list|)
expr_stmt|;
name|add_register
argument_list|(
name|collect
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNOP_MEMVAL
case|:
comment|/* safe because we know it's a simple expression */
name|tempval
operator|=
name|evaluate_expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|addr
operator|=
name|VALUE_ADDRESS
argument_list|(
name|tempval
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|tempval
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|check_typedef
argument_list|(
name|exp
operator|->
name|elts
index|[
literal|1
index|]
operator|.
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|add_memrange
argument_list|(
name|collect
argument_list|,
operator|-
literal|1
argument_list|,
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_VAR_VALUE
case|:
name|collect_symbol
argument_list|(
name|collect
argument_list|,
name|exp
operator|->
name|elts
index|[
literal|2
index|]
operator|.
name|symbol
argument_list|,
name|frame_reg
argument_list|,
name|frame_offset
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* full-fledged expression */
name|aexpr
operator|=
name|gen_trace_for_expr
argument_list|(
name|t
operator|->
name|address
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|old_chain1
operator|=
name|make_cleanup_free_agent_expr
argument_list|(
name|aexpr
argument_list|)
expr_stmt|;
name|ax_reqs
argument_list|(
name|aexpr
argument_list|,
operator|&
name|areqs
argument_list|)
expr_stmt|;
if|if
condition|(
name|areqs
operator|.
name|flaw
operator|!=
name|agent_flaw_none
condition|)
name|error
argument_list|(
literal|"malformed expression"
argument_list|)
expr_stmt|;
if|if
condition|(
name|areqs
operator|.
name|min_height
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"gdb: Internal error: expression has min height< 0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|areqs
operator|.
name|max_height
operator|>
literal|20
condition|)
name|error
argument_list|(
literal|"expression too complicated, try simplifying"
argument_list|)
expr_stmt|;
name|discard_cleanups
argument_list|(
name|old_chain1
argument_list|)
expr_stmt|;
name|add_aexpr
argument_list|(
name|collect
argument_list|,
name|aexpr
argument_list|)
expr_stmt|;
comment|/* take care of the registers */
if|if
condition|(
name|areqs
operator|.
name|reg_mask_len
operator|>
literal|0
condition|)
block|{
name|int
name|ndx1
decl_stmt|;
name|int
name|ndx2
decl_stmt|;
for|for
control|(
name|ndx1
operator|=
literal|0
init|;
name|ndx1
operator|<
name|areqs
operator|.
name|reg_mask_len
condition|;
name|ndx1
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
comment|/* allow user to bail out with ^C */
if|if
condition|(
name|areqs
operator|.
name|reg_mask
index|[
name|ndx1
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* assume chars have 8 bits */
for|for
control|(
name|ndx2
operator|=
literal|0
init|;
name|ndx2
operator|<
literal|8
condition|;
name|ndx2
operator|++
control|)
if|if
condition|(
name|areqs
operator|.
name|reg_mask
index|[
name|ndx1
index|]
operator|&
operator|(
literal|1
operator|<<
name|ndx2
operator|)
condition|)
comment|/* it's used -- record it */
name|add_register
argument_list|(
name|collect
argument_list|,
name|ndx1
operator|*
literal|8
operator|+
name|ndx2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
comment|/* switch */
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
comment|/* do */
block|}
do|while
condition|(
name|action_exp
operator|&&
operator|*
name|action_exp
operator|++
operator|==
literal|','
condition|)
do|;
block|}
comment|/* if */
elseif|else
if|if
condition|(
name|cmd_cfunc_eq
argument_list|(
name|cmd
argument_list|,
name|while_stepping_pseudocommand
argument_list|)
condition|)
block|{
name|collect
operator|=
operator|&
name|stepping_list
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd_cfunc_eq
argument_list|(
name|cmd
argument_list|,
name|end_actions_pseudocommand
argument_list|)
condition|)
block|{
if|if
condition|(
name|collect
operator|==
operator|&
name|stepping_list
condition|)
comment|/* end stepping actions */
name|collect
operator|=
operator|&
name|tracepoint_list
expr_stmt|;
else|else
break|break;
comment|/* end tracepoint actions */
block|}
block|}
comment|/* for */
name|memrange_sortmerge
argument_list|(
operator|&
name|tracepoint_list
argument_list|)
expr_stmt|;
name|memrange_sortmerge
argument_list|(
operator|&
name|stepping_list
argument_list|)
expr_stmt|;
operator|*
name|tdp_actions
operator|=
name|stringify_collection_list
argument_list|(
operator|&
name|tracepoint_list
argument_list|,
name|tdp_buff
argument_list|)
expr_stmt|;
operator|*
name|stepping_actions
operator|=
name|stringify_collection_list
argument_list|(
operator|&
name|stepping_list
argument_list|,
name|step_buff
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_aexpr
parameter_list|(
name|struct
name|collection_list
modifier|*
name|collect
parameter_list|,
name|struct
name|agent_expr
modifier|*
name|aexpr
parameter_list|)
block|{
if|if
condition|(
name|collect
operator|->
name|next_aexpr_elt
operator|>=
name|collect
operator|->
name|aexpr_listsize
condition|)
block|{
name|collect
operator|->
name|aexpr_list
operator|=
name|xrealloc
argument_list|(
name|collect
operator|->
name|aexpr_list
argument_list|,
literal|2
operator|*
name|collect
operator|->
name|aexpr_listsize
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|agent_expr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|collect
operator|->
name|aexpr_listsize
operator|*=
literal|2
expr_stmt|;
block|}
name|collect
operator|->
name|aexpr_list
index|[
name|collect
operator|->
name|next_aexpr_elt
index|]
operator|=
name|aexpr
expr_stmt|;
name|collect
operator|->
name|next_aexpr_elt
operator|++
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|target_buf
index|[
literal|2048
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set "transparent" memory ranges     Allow trace mechanism to treat text-like sections    (and perhaps all read-only sections) transparently,     i.e. don't reject memory requests from these address ranges    just because they haven't been collected.  */
end_comment

begin_function
specifier|static
name|void
name|remote_set_transparent_ranges
parameter_list|(
name|void
parameter_list|)
block|{
specifier|extern
name|bfd
modifier|*
name|exec_bfd
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|bfd_vma
name|lma
decl_stmt|;
name|int
name|anysecs
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|exec_bfd
condition|)
return|return;
comment|/* no information to give. */
name|strcpy
argument_list|(
name|target_buf
argument_list|,
literal|"QTro"
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|exec_bfd
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|char
name|tmp1
index|[
literal|40
index|]
decl_stmt|,
name|tmp2
index|[
literal|40
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
operator|||
comment|/* (s->flags& SEC_CODE)     == 0 || */
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|anysecs
operator|=
literal|1
expr_stmt|;
name|lma
operator|=
name|s
operator|->
name|lma
expr_stmt|;
name|size
operator|=
name|bfd_get_section_size
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sprintf_vma
argument_list|(
name|tmp1
argument_list|,
name|lma
argument_list|)
expr_stmt|;
name|sprintf_vma
argument_list|(
name|tmp2
argument_list|,
name|lma
operator|+
name|size
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|target_buf
operator|+
name|strlen
argument_list|(
name|target_buf
argument_list|)
argument_list|,
literal|":%s,%s"
argument_list|,
name|tmp1
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|anysecs
condition|)
block|{
name|putpkt
argument_list|(
name|target_buf
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|target_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|target_buf
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* tstart command:     Tell target to clear any previous trace experiment.    Walk the list of tracepoints, and send them (and their actions)    to the target.  If no errors,     Tell target to start a new trace experiment.  */
end_comment

begin_function
specifier|static
name|void
name|trace_start_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
comment|/* STUB_COMM MOSTLY_IMPLEMENTED */
name|struct
name|tracepoint
modifier|*
name|t
decl_stmt|;
name|char
name|buf
index|[
literal|2048
index|]
decl_stmt|;
name|char
modifier|*
modifier|*
name|tdp_actions
decl_stmt|;
name|char
modifier|*
modifier|*
name|stepping_actions
decl_stmt|;
name|int
name|ndx
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|NULL
decl_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
comment|/* like "run", dangerous to repeat accidentally */
if|if
condition|(
name|target_is_remote
argument_list|()
condition|)
block|{
name|putpkt
argument_list|(
literal|"QTinit"
argument_list|)
expr_stmt|;
name|remote_get_noisy_reply
argument_list|(
name|target_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|target_buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|target_buf
argument_list|,
literal|"OK"
argument_list|)
condition|)
name|error
argument_list|(
literal|"Target does not support this command."
argument_list|)
expr_stmt|;
name|ALL_TRACEPOINTS
argument_list|(
argument|t
argument_list|)
block|{
name|char
name|tmp
index|[
literal|40
index|]
decl_stmt|;
name|sprintf_vma
argument_list|(
name|tmp
argument_list|,
name|t
operator|->
name|address
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"QTDP:%x:%s:%c:%lx:%x"
argument_list|,
name|t
operator|->
name|number
argument_list|,
name|tmp
argument_list|,
comment|/* address */
name|t
operator|->
name|enabled_p
condition|?
literal|'E'
else|:
literal|'D'
argument_list|,
name|t
operator|->
name|step_count
argument_list|,
name|t
operator|->
name|pass_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|actions
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|remote_get_noisy_reply
argument_list|(
name|target_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|target_buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|target_buf
argument_list|,
literal|"OK"
argument_list|)
condition|)
name|error
argument_list|(
literal|"Target does not support tracepoints."
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|actions
condition|)
block|{
name|encode_actions
argument_list|(
name|t
argument_list|,
operator|&
name|tdp_actions
argument_list|,
operator|&
name|stepping_actions
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free_actions_list_cleanup_wrapper
argument_list|,
name|tdp_actions
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|make_cleanup
argument_list|(
name|free_actions_list_cleanup_wrapper
argument_list|,
name|stepping_actions
argument_list|)
expr_stmt|;
comment|/* do_single_steps (t); */
if|if
condition|(
name|tdp_actions
condition|)
block|{
for|for
control|(
name|ndx
operator|=
literal|0
init|;
name|tdp_actions
index|[
name|ndx
index|]
condition|;
name|ndx
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
comment|/* allow user to bail out with ^C */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"QTDP:-%x:%s:%s%c"
argument_list|,
name|t
operator|->
name|number
argument_list|,
name|tmp
argument_list|,
comment|/* address */
name|tdp_actions
index|[
name|ndx
index|]
argument_list|,
operator|(
operator|(
name|tdp_actions
index|[
name|ndx
operator|+
literal|1
index|]
operator|||
name|stepping_actions
operator|)
condition|?
literal|'-'
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|remote_get_noisy_reply
argument_list|(
name|target_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|target_buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|target_buf
argument_list|,
literal|"OK"
argument_list|)
condition|)
name|error
argument_list|(
literal|"Error on target while setting tracepoints."
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stepping_actions
condition|)
block|{
for|for
control|(
name|ndx
operator|=
literal|0
init|;
name|stepping_actions
index|[
name|ndx
index|]
condition|;
name|ndx
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
comment|/* allow user to bail out with ^C */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"QTDP:-%x:%s:%s%s%s"
argument_list|,
name|t
operator|->
name|number
argument_list|,
name|tmp
argument_list|,
comment|/* address */
operator|(
operator|(
name|ndx
operator|==
literal|0
operator|)
condition|?
literal|"S"
else|:
literal|""
operator|)
argument_list|,
name|stepping_actions
index|[
name|ndx
index|]
argument_list|,
operator|(
name|stepping_actions
index|[
name|ndx
operator|+
literal|1
index|]
condition|?
literal|"-"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|remote_get_noisy_reply
argument_list|(
name|target_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|target_buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|target_buf
argument_list|,
literal|"OK"
argument_list|)
condition|)
name|error
argument_list|(
literal|"Error on target while setting tracepoints."
argument_list|)
expr_stmt|;
block|}
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Tell target to treat text-like sections as transparent */
name|remote_set_transparent_ranges
argument_list|()
expr_stmt|;
comment|/* Now insert traps and begin collecting data */
name|putpkt
argument_list|(
literal|"QTStart"
argument_list|)
expr_stmt|;
name|remote_get_noisy_reply
argument_list|(
name|target_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|target_buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|target_buf
argument_list|,
literal|"OK"
argument_list|)
condition|)
name|error
argument_list|(
literal|"Bogus reply from target: %s"
argument_list|,
name|target_buf
argument_list|)
expr_stmt|;
name|set_traceframe_num
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* all old traceframes invalidated */
name|set_tracepoint_num
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|set_traceframe_context
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|trace_running_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|trace_start_stop_hook
condition|)
name|trace_start_stop_hook
argument_list|(
literal|1
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Trace can only be run on remote targets."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* tstop command */
end_comment

begin_function
specifier|static
name|void
name|trace_stop_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
comment|/* STUB_COMM IS_IMPLEMENTED */
if|if
condition|(
name|target_is_remote
argument_list|()
condition|)
block|{
name|putpkt
argument_list|(
literal|"QTStop"
argument_list|)
expr_stmt|;
name|remote_get_noisy_reply
argument_list|(
name|target_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|target_buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|target_buf
argument_list|,
literal|"OK"
argument_list|)
condition|)
name|error
argument_list|(
literal|"Bogus reply from target: %s"
argument_list|,
name|target_buf
argument_list|)
expr_stmt|;
name|trace_running_p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|trace_start_stop_hook
condition|)
name|trace_start_stop_hook
argument_list|(
literal|0
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Trace can only be run on remote targets."
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|unsigned
name|long
name|trace_running_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tstatus command */
end_comment

begin_function
specifier|static
name|void
name|trace_status_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
comment|/* STUB_COMM IS_IMPLEMENTED */
if|if
condition|(
name|target_is_remote
argument_list|()
condition|)
block|{
name|putpkt
argument_list|(
literal|"qTStatus"
argument_list|)
expr_stmt|;
name|remote_get_noisy_reply
argument_list|(
name|target_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|target_buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_buf
index|[
literal|0
index|]
operator|!=
literal|'T'
operator|||
operator|(
name|target_buf
index|[
literal|1
index|]
operator|!=
literal|'0'
operator|&&
name|target_buf
index|[
literal|1
index|]
operator|!=
literal|'1'
operator|)
condition|)
name|error
argument_list|(
literal|"Bogus reply from target: %s"
argument_list|,
name|target_buf
argument_list|)
expr_stmt|;
comment|/* exported for use by the GUI */
name|trace_running_p
operator|=
operator|(
name|target_buf
index|[
literal|1
index|]
operator|==
literal|'1'
operator|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Trace can only be run on remote targets."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Worker function for the various flavors of the tfind command */
end_comment

begin_function
specifier|static
name|void
name|finish_tfind_command
parameter_list|(
name|char
modifier|*
name|msg
parameter_list|,
name|long
name|sizeof_msg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|int
name|target_frameno
init|=
operator|-
literal|1
decl_stmt|,
name|target_tracept
init|=
operator|-
literal|1
decl_stmt|;
name|CORE_ADDR
name|old_frame_addr
decl_stmt|;
name|struct
name|symbol
modifier|*
name|old_func
decl_stmt|;
name|char
modifier|*
name|reply
decl_stmt|;
name|old_frame_addr
operator|=
name|get_frame_base
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
expr_stmt|;
name|old_func
operator|=
name|find_pc_function
argument_list|(
name|read_pc
argument_list|()
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|reply
operator|=
name|remote_get_noisy_reply
argument_list|(
name|msg
argument_list|,
name|sizeof_msg
argument_list|)
expr_stmt|;
while|while
condition|(
name|reply
operator|&&
operator|*
name|reply
condition|)
switch|switch
condition|(
operator|*
name|reply
condition|)
block|{
case|case
literal|'F'
case|:
if|if
condition|(
operator|(
name|target_frameno
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
operator|++
name|reply
argument_list|,
operator|&
name|reply
argument_list|,
literal|16
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* A request for a non-existant trace frame has failed. 	       Our response will be different, depending on FROM_TTY:  	       If FROM_TTY is true, meaning that this command was  	       typed interactively by the user, then give an error 	       and DO NOT change the state of traceframe_number etc.  	       However if FROM_TTY is false, meaning that we're either 	       in a script, a loop, or a user-defined command, then  	       DON'T give an error, but DO change the state of 	       traceframe_number etc. to invalid.  	       The rationalle is that if you typed the command, you 	       might just have committed a typo or something, and you'd 	       like to NOT lose your current debugging state.  However 	       if you're in a user-defined command or especially in a 	       loop, then you need a way to detect that the command 	       failed WITHOUT aborting.  This allows you to write 	       scripts that search thru the trace buffer until the end, 	       and then continue on to do something else.  */
if|if
condition|(
name|from_tty
condition|)
name|error
argument_list|(
literal|"Target failed to find requested trace frame."
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"End of trace buffer.\n"
argument_list|)
expr_stmt|;
comment|/* The following will not recurse, since it's special-cased */
name|trace_find_command
argument_list|(
literal|"-1"
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|reply
operator|=
name|NULL
expr_stmt|;
comment|/* break out of loop,  				   (avoid recursive nonsense) */
block|}
block|}
break|break;
case|case
literal|'T'
case|:
if|if
condition|(
operator|(
name|target_tracept
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
operator|++
name|reply
argument_list|,
operator|&
name|reply
argument_list|,
literal|16
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"Target failed to find requested trace frame."
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
comment|/* "OK"? */
if|if
condition|(
name|reply
index|[
literal|1
index|]
operator|==
literal|'K'
operator|&&
name|reply
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
name|reply
operator|+=
literal|2
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Bogus reply from target: %s"
argument_list|,
name|reply
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Bogus reply from target: %s"
argument_list|,
name|reply
argument_list|)
expr_stmt|;
block|}
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|registers_changed
argument_list|()
expr_stmt|;
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
expr_stmt|;
name|set_traceframe_num
argument_list|(
name|target_frameno
argument_list|)
expr_stmt|;
name|set_tracepoint_num
argument_list|(
name|target_tracept
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_frameno
operator|==
operator|-
literal|1
condition|)
name|set_traceframe_context
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|set_traceframe_context
argument_list|(
name|read_pc
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|int
name|source_only
decl_stmt|;
comment|/* NOTE: in immitation of the step command, try to determine          whether we have made a transition from one function to another.          If so, we'll print the "stack frame" (ie. the new function and          it's arguments) -- otherwise we'll just show the new source line.           This determination is made by checking (1) whether the current          function has changed, and (2) whether the current FP has changed.          Hack: if the FP wasn't collected, either at the current or the          previous frame, assume that the FP has NOT changed.  */
if|if
condition|(
name|old_func
operator|==
name|find_pc_function
argument_list|(
name|read_pc
argument_list|()
argument_list|)
operator|&&
operator|(
name|old_frame_addr
operator|==
literal|0
operator|||
name|get_frame_base
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
operator|==
literal|0
operator|||
name|old_frame_addr
operator|==
name|get_frame_base
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
operator|)
condition|)
name|source_only
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|source_only
operator|=
literal|1
expr_stmt|;
name|print_stack_frame
argument_list|(
name|deprecated_selected_frame
argument_list|,
name|frame_relative_level
argument_list|(
name|deprecated_selected_frame
argument_list|)
argument_list|,
name|source_only
argument_list|)
expr_stmt|;
name|do_displays
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* trace_find_command takes a trace frame number n,     sends "QTFrame:<n>" to the target,     and accepts a reply that may contain several optional pieces    of information: a frame number, a tracepoint number, and an    indication of whether this is a trap frame or a stepping frame.     The minimal response is just "OK" (which indicates that the     target does not give us a frame number or a tracepoint number).    Instead of that, the target may send us a string containing    any combination of:    F<hexnum>    (gives the selected frame number)    T<hexnum>    (gives the selected tracepoint number)  */
end_comment

begin_comment
comment|/* tfind command */
end_comment

begin_function
specifier|static
name|void
name|trace_find_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
comment|/* STUB_COMM PART_IMPLEMENTED */
comment|/* this should only be called with a numeric argument */
name|int
name|frameno
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|target_is_remote
argument_list|()
condition|)
block|{
if|if
condition|(
name|trace_find_hook
condition|)
name|trace_find_hook
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|==
literal|0
operator|||
operator|*
name|args
operator|==
literal|0
condition|)
block|{
comment|/* TFIND with no args means find NEXT trace frame. */
if|if
condition|(
name|traceframe_number
operator|==
operator|-
literal|1
condition|)
name|frameno
operator|=
literal|0
expr_stmt|;
comment|/* "next" is first one */
else|else
name|frameno
operator|=
name|traceframe_number
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|args
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
if|if
condition|(
name|traceframe_number
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"not debugging trace buffer"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|from_tty
operator|&&
name|traceframe_number
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"already at start of trace buffer"
argument_list|)
expr_stmt|;
name|frameno
operator|=
name|traceframe_number
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|frameno
operator|=
name|parse_and_eval_long
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|frameno
operator|<
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"invalid input (%d is less than zero)"
argument_list|,
name|frameno
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|target_buf
argument_list|,
literal|"QTFrame:%x"
argument_list|,
name|frameno
argument_list|)
expr_stmt|;
name|finish_tfind_command
argument_list|(
name|target_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|target_buf
argument_list|)
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Trace can only be run on remote targets."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* tfind end */
end_comment

begin_function
specifier|static
name|void
name|trace_find_end_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|trace_find_command
argument_list|(
literal|"-1"
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* tfind none */
end_comment

begin_function
specifier|static
name|void
name|trace_find_none_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|trace_find_command
argument_list|(
literal|"-1"
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* tfind start */
end_comment

begin_function
specifier|static
name|void
name|trace_find_start_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|trace_find_command
argument_list|(
literal|"0"
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* tfind pc command */
end_comment

begin_function
specifier|static
name|void
name|trace_find_pc_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
comment|/* STUB_COMM PART_IMPLEMENTED */
name|CORE_ADDR
name|pc
decl_stmt|;
name|char
name|tmp
index|[
literal|40
index|]
decl_stmt|;
if|if
condition|(
name|target_is_remote
argument_list|()
condition|)
block|{
if|if
condition|(
name|args
operator|==
literal|0
operator|||
operator|*
name|args
operator|==
literal|0
condition|)
name|pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
comment|/* default is current pc */
else|else
name|pc
operator|=
name|parse_and_eval_address
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|sprintf_vma
argument_list|(
name|tmp
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|target_buf
argument_list|,
literal|"QTFrame:pc:%s"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|finish_tfind_command
argument_list|(
name|target_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|target_buf
argument_list|)
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Trace can only be run on remote targets."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* tfind tracepoint command */
end_comment

begin_function
specifier|static
name|void
name|trace_find_tracepoint_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
comment|/* STUB_COMM PART_IMPLEMENTED */
name|int
name|tdp
decl_stmt|;
if|if
condition|(
name|target_is_remote
argument_list|()
condition|)
block|{
if|if
condition|(
name|args
operator|==
literal|0
operator|||
operator|*
name|args
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tracepoint_number
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"No current tracepoint -- please supply an argument."
argument_list|)
expr_stmt|;
else|else
name|tdp
operator|=
name|tracepoint_number
expr_stmt|;
comment|/* default is current TDP */
block|}
else|else
name|tdp
operator|=
name|parse_and_eval_long
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|target_buf
argument_list|,
literal|"QTFrame:tdp:%x"
argument_list|,
name|tdp
argument_list|)
expr_stmt|;
name|finish_tfind_command
argument_list|(
name|target_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|target_buf
argument_list|)
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Trace can only be run on remote targets."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TFIND LINE command:     This command will take a sourceline for argument, just like BREAK    or TRACE (ie. anything that "decode_line_1" can handle).       With no argument, this command will find the next trace frame     corresponding to a source line OTHER THAN THE CURRENT ONE.  */
end_comment

begin_function
specifier|static
name|void
name|trace_find_line_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
comment|/* STUB_COMM PART_IMPLEMENTED */
specifier|static
name|CORE_ADDR
name|start_pc
decl_stmt|,
name|end_pc
decl_stmt|;
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|char
name|startpc_str
index|[
literal|40
index|]
decl_stmt|,
name|endpc_str
index|[
literal|40
index|]
decl_stmt|;
if|if
condition|(
name|target_is_remote
argument_list|()
condition|)
block|{
if|if
condition|(
name|args
operator|==
literal|0
operator|||
operator|*
name|args
operator|==
literal|0
condition|)
block|{
name|sal
operator|=
name|find_pc_line
argument_list|(
name|get_frame_pc
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sals
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
name|sals
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|sals
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|sal
expr_stmt|;
block|}
else|else
block|{
name|sals
operator|=
name|decode_line_spec
argument_list|(
name|args
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sal
operator|=
name|sals
operator|.
name|sals
index|[
literal|0
index|]
expr_stmt|;
block|}
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|symtab
operator|==
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"TFIND: No line number information available"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|pc
operator|!=
literal|0
condition|)
block|{
comment|/* This is useful for "info line *0x7f34".  If we can't tell the 	         user about a source line, at least let them have the symbolic 	         address.  */
name|printf_filtered
argument_list|(
literal|" for address "
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|print_address
argument_list|(
name|sal
operator|.
name|pc
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|";\n -- will attempt to find by PC. \n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
return|return;
comment|/* no line, no PC; what can we do? */
block|}
block|}
elseif|else
if|if
condition|(
name|sal
operator|.
name|line
operator|>
literal|0
operator|&&
name|find_line_pc_range
argument_list|(
name|sal
argument_list|,
operator|&
name|start_pc
argument_list|,
operator|&
name|end_pc
argument_list|)
condition|)
block|{
if|if
condition|(
name|start_pc
operator|==
name|end_pc
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Line %d of \"%s\""
argument_list|,
name|sal
operator|.
name|line
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" is at address "
argument_list|)
expr_stmt|;
name|print_address
argument_list|(
name|start_pc
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" but contains no code.\n"
argument_list|)
expr_stmt|;
name|sal
operator|=
name|find_pc_line
argument_list|(
name|start_pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|line
operator|>
literal|0
operator|&&
name|find_line_pc_range
argument_list|(
name|sal
argument_list|,
operator|&
name|start_pc
argument_list|,
operator|&
name|end_pc
argument_list|)
operator|&&
name|start_pc
operator|!=
name|end_pc
condition|)
name|printf_filtered
argument_list|(
literal|"Attempting to find line %d instead.\n"
argument_list|,
name|sal
operator|.
name|line
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Cannot find a good line."
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* Is there any case in which we get here, and have an address 	   which the user would want to see?  If we have debugging symbols 	   and no line numbers?  */
name|error
argument_list|(
literal|"Line number %d is out of range for \"%s\".\n"
argument_list|,
name|sal
operator|.
name|line
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
name|sprintf_vma
argument_list|(
name|startpc_str
argument_list|,
name|start_pc
argument_list|)
expr_stmt|;
name|sprintf_vma
argument_list|(
name|endpc_str
argument_list|,
name|end_pc
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|&&
operator|*
name|args
condition|)
comment|/* find within range of stated line */
name|sprintf
argument_list|(
name|target_buf
argument_list|,
literal|"QTFrame:range:%s:%s"
argument_list|,
name|startpc_str
argument_list|,
name|endpc_str
argument_list|)
expr_stmt|;
else|else
comment|/* find OUTSIDE OF range of CURRENT line */
name|sprintf
argument_list|(
name|target_buf
argument_list|,
literal|"QTFrame:outside:%s:%s"
argument_list|,
name|startpc_str
argument_list|,
name|endpc_str
argument_list|)
expr_stmt|;
name|finish_tfind_command
argument_list|(
name|target_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|target_buf
argument_list|)
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Trace can only be run on remote targets."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* tfind range command */
end_comment

begin_function
specifier|static
name|void
name|trace_find_range_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
specifier|static
name|CORE_ADDR
name|start
decl_stmt|,
name|stop
decl_stmt|;
name|char
name|start_str
index|[
literal|40
index|]
decl_stmt|,
name|stop_str
index|[
literal|40
index|]
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|target_is_remote
argument_list|()
condition|)
block|{
if|if
condition|(
name|args
operator|==
literal|0
operator|||
operator|*
name|args
operator|==
literal|0
condition|)
block|{
comment|/* XXX FIXME: what should default behavior be? */
name|printf_filtered
argument_list|(
literal|"Usage: tfind range<startaddr>,<endaddr>\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
literal|0
operator|!=
operator|(
name|tmp
operator|=
name|strchr
argument_list|(
name|args
argument_list|,
literal|','
argument_list|)
operator|)
condition|)
block|{
operator|*
name|tmp
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* terminate start address */
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|tmp
argument_list|)
condition|)
name|tmp
operator|++
expr_stmt|;
name|start
operator|=
name|parse_and_eval_address
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|stop
operator|=
name|parse_and_eval_address
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* no explicit end address? */
name|start
operator|=
name|parse_and_eval_address
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|stop
operator|=
name|start
operator|+
literal|1
expr_stmt|;
comment|/* ??? */
block|}
name|sprintf_vma
argument_list|(
name|start_str
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|sprintf_vma
argument_list|(
name|stop_str
argument_list|,
name|stop
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|target_buf
argument_list|,
literal|"QTFrame:range:%s:%s"
argument_list|,
name|start_str
argument_list|,
name|stop_str
argument_list|)
expr_stmt|;
name|finish_tfind_command
argument_list|(
name|target_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|target_buf
argument_list|)
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Trace can only be run on remote targets."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* tfind outside command */
end_comment

begin_function
specifier|static
name|void
name|trace_find_outside_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|CORE_ADDR
name|start
decl_stmt|,
name|stop
decl_stmt|;
name|char
name|start_str
index|[
literal|40
index|]
decl_stmt|,
name|stop_str
index|[
literal|40
index|]
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|target_is_remote
argument_list|()
condition|)
block|{
if|if
condition|(
name|args
operator|==
literal|0
operator|||
operator|*
name|args
operator|==
literal|0
condition|)
block|{
comment|/* XXX FIXME: what should default behavior be? */
name|printf_filtered
argument_list|(
literal|"Usage: tfind outside<startaddr>,<endaddr>\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
literal|0
operator|!=
operator|(
name|tmp
operator|=
name|strchr
argument_list|(
name|args
argument_list|,
literal|','
argument_list|)
operator|)
condition|)
block|{
operator|*
name|tmp
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* terminate start address */
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|tmp
argument_list|)
condition|)
name|tmp
operator|++
expr_stmt|;
name|start
operator|=
name|parse_and_eval_address
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|stop
operator|=
name|parse_and_eval_address
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* no explicit end address? */
name|start
operator|=
name|parse_and_eval_address
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|stop
operator|=
name|start
operator|+
literal|1
expr_stmt|;
comment|/* ??? */
block|}
name|sprintf_vma
argument_list|(
name|start_str
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|sprintf_vma
argument_list|(
name|stop_str
argument_list|,
name|stop
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|target_buf
argument_list|,
literal|"QTFrame:outside:%s:%s"
argument_list|,
name|start_str
argument_list|,
name|stop_str
argument_list|)
expr_stmt|;
name|finish_tfind_command
argument_list|(
name|target_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|target_buf
argument_list|)
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Trace can only be run on remote targets."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* save-tracepoints command */
end_comment

begin_function
specifier|static
name|void
name|tracepoint_save_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|tracepoint
modifier|*
name|tp
decl_stmt|;
name|struct
name|action_line
modifier|*
name|line
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|i1
init|=
literal|"    "
decl_stmt|,
modifier|*
name|i2
init|=
literal|"      "
decl_stmt|;
name|char
modifier|*
name|indent
decl_stmt|,
modifier|*
name|actionline
decl_stmt|,
modifier|*
name|pathname
decl_stmt|;
name|char
name|tmp
index|[
literal|40
index|]
decl_stmt|;
if|if
condition|(
name|args
operator|==
literal|0
operator|||
operator|*
name|args
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Argument required (file name in which to save tracepoints"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tracepoint_chain
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"save-tracepoints: no tracepoints to save.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pathname
operator|=
name|tilde_expand
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|pathname
argument_list|,
literal|"w"
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"Unable to open file '%s' for saving tracepoints (%s)"
argument_list|,
name|args
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
name|ALL_TRACEPOINTS
argument_list|(
argument|tp
argument_list|)
block|{
if|if
condition|(
name|tp
operator|->
name|addr_string
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"trace %s\n"
argument_list|,
name|tp
operator|->
name|addr_string
argument_list|)
expr_stmt|;
else|else
block|{
name|sprintf_vma
argument_list|(
name|tmp
argument_list|,
name|tp
operator|->
name|address
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"trace *0x%s\n"
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|pass_count
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  passcount %d\n"
argument_list|,
name|tp
operator|->
name|pass_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|actions
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  actions\n"
argument_list|)
expr_stmt|;
name|indent
operator|=
name|i1
expr_stmt|;
for|for
control|(
name|line
operator|=
name|tp
operator|->
name|actions
init|;
name|line
condition|;
name|line
operator|=
name|line
operator|->
name|next
control|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|cmd
decl_stmt|;
name|QUIT
expr_stmt|;
comment|/* allow user to bail out with ^C */
name|actionline
operator|=
name|line
operator|->
name|action
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|actionline
argument_list|)
condition|)
name|actionline
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s%s\n"
argument_list|,
name|indent
argument_list|,
name|actionline
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|actionline
operator|!=
literal|'#'
condition|)
comment|/* skip for comment lines */
block|{
name|cmd
operator|=
name|lookup_cmd
argument_list|(
operator|&
name|actionline
argument_list|,
name|cmdlist
argument_list|,
literal|""
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Bad action list item: %s"
argument_list|,
name|actionline
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd_cfunc_eq
argument_list|(
name|cmd
argument_list|,
name|while_stepping_pseudocommand
argument_list|)
condition|)
name|indent
operator|=
name|i2
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd_cfunc_eq
argument_list|(
name|cmd
argument_list|,
name|end_actions_pseudocommand
argument_list|)
condition|)
name|indent
operator|=
name|i1
expr_stmt|;
block|}
block|}
block|}
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf_filtered
argument_list|(
literal|"Tracepoints saved to file '%s'.\n"
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* info scope command: list the locals for a scope.  */
end_comment

begin_function
specifier|static
name|void
name|scope_info
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msym
decl_stmt|;
name|struct
name|block
modifier|*
name|block
decl_stmt|;
name|char
modifier|*
modifier|*
name|canonical
decl_stmt|,
modifier|*
name|symname
decl_stmt|,
modifier|*
name|save_args
init|=
name|args
decl_stmt|;
name|struct
name|dict_iterator
name|iter
decl_stmt|;
name|int
name|j
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|args
operator|==
literal|0
operator|||
operator|*
name|args
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"requires an argument (function, line or *addr) to define a scope"
argument_list|)
expr_stmt|;
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|args
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|canonical
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sals
operator|.
name|nelts
operator|==
literal|0
condition|)
return|return;
comment|/* presumably decode_line_1 has already warned */
comment|/* Resolve line numbers to PC */
name|resolve_sal_pc
argument_list|(
operator|&
name|sals
operator|.
name|sals
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|block
operator|=
name|block_for_pc
argument_list|(
name|sals
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|pc
argument_list|)
expr_stmt|;
while|while
condition|(
name|block
operator|!=
literal|0
condition|)
block|{
name|QUIT
expr_stmt|;
comment|/* allow user to bail out with ^C */
name|ALL_BLOCK_SYMBOLS
argument_list|(
argument|block
argument_list|,
argument|iter
argument_list|,
argument|sym
argument_list|)
block|{
name|QUIT
expr_stmt|;
comment|/* allow user to bail out with ^C */
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|"Scope for %s:\n"
argument_list|,
name|save_args
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|symname
operator|=
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|symname
operator|==
name|NULL
operator|||
operator|*
name|symname
operator|==
literal|'\0'
condition|)
continue|continue;
comment|/* probably botched, certainly useless */
name|printf_filtered
argument_list|(
literal|"Symbol %s is "
argument_list|,
name|symname
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
condition|)
block|{
default|default:
case|case
name|LOC_UNDEF
case|:
comment|/* messed up symbol? */
name|printf_filtered
argument_list|(
literal|"a bogus symbol, class %d.\n"
argument_list|,
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|--
expr_stmt|;
comment|/* don't count this one */
continue|continue;
case|case
name|LOC_CONST
case|:
name|printf_filtered
argument_list|(
literal|"a constant with value %ld (0x%lx)"
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_CONST_BYTES
case|:
name|printf_filtered
argument_list|(
literal|"constant bytes: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|TYPE_LENGTH
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|;
name|j
operator|++
control|)
name|fprintf_filtered
argument_list|(
name|gdb_stdout
argument_list|,
literal|" %02x"
argument_list|,
operator|(
name|unsigned
operator|)
name|SYMBOL_VALUE_BYTES
argument_list|(
name|sym
argument_list|)
index|[
name|j
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_STATIC
case|:
name|printf_filtered
argument_list|(
literal|"in static storage at address "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_REGISTER
case|:
name|printf_filtered
argument_list|(
literal|"a local variable in register $%s"
argument_list|,
name|REGISTER_NAME
argument_list|(
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_ARG
case|:
case|case
name|LOC_LOCAL_ARG
case|:
name|printf_filtered
argument_list|(
literal|"an argument at stack/frame offset %ld"
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_LOCAL
case|:
name|printf_filtered
argument_list|(
literal|"a local variable at frame offset %ld"
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_REF_ARG
case|:
name|printf_filtered
argument_list|(
literal|"a reference argument at offset %ld"
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_REGPARM
case|:
name|printf_filtered
argument_list|(
literal|"an argument in register $%s"
argument_list|,
name|REGISTER_NAME
argument_list|(
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_REGPARM_ADDR
case|:
name|printf_filtered
argument_list|(
literal|"the address of an argument, in register $%s"
argument_list|,
name|REGISTER_NAME
argument_list|(
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_TYPEDEF
case|:
name|printf_filtered
argument_list|(
literal|"a typedef.\n"
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|LOC_LABEL
case|:
name|printf_filtered
argument_list|(
literal|"a label at address "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_BLOCK
case|:
name|printf_filtered
argument_list|(
literal|"a function at address "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_BASEREG
case|:
name|printf_filtered
argument_list|(
literal|"a variable at offset %ld from register $%s"
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|REGISTER_NAME
argument_list|(
name|SYMBOL_BASEREG
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_BASEREG_ARG
case|:
name|printf_filtered
argument_list|(
literal|"an argument at offset %ld from register $%s"
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|REGISTER_NAME
argument_list|(
name|SYMBOL_BASEREG
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_UNRESOLVED
case|:
name|msym
operator|=
name|lookup_minimal_symbol
argument_list|(
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|msym
operator|==
name|NULL
condition|)
name|printf_filtered
argument_list|(
literal|"Unresolved Static"
argument_list|)
expr_stmt|;
else|else
block|{
name|printf_filtered
argument_list|(
literal|"static storage at address "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msym
argument_list|)
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LOC_OPTIMIZED_OUT
case|:
name|printf_filtered
argument_list|(
literal|"optimized out.\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
condition|)
name|printf_filtered
argument_list|(
literal|", length %d.\n"
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|check_typedef
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|BLOCK_FUNCTION
argument_list|(
name|block
argument_list|)
condition|)
break|break;
else|else
name|block
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|"Scope for %s contains no locals or arguments.\n"
argument_list|,
name|save_args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* worker function (cleanup) */
end_comment

begin_function
specifier|static
name|void
name|replace_comma
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|char
modifier|*
name|comma
init|=
name|data
decl_stmt|;
operator|*
name|comma
operator|=
literal|','
expr_stmt|;
block|}
end_function

begin_comment
comment|/* tdump command */
end_comment

begin_function
specifier|static
name|void
name|trace_dump_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|tracepoint
modifier|*
name|t
decl_stmt|;
name|struct
name|action_line
modifier|*
name|action
decl_stmt|;
name|char
modifier|*
name|action_exp
decl_stmt|,
modifier|*
name|next_comma
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_cleanups
decl_stmt|;
name|int
name|stepping_actions
init|=
literal|0
decl_stmt|;
name|int
name|stepping_frame
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|target_is_remote
argument_list|()
condition|)
block|{
name|error
argument_list|(
literal|"Trace can only be run on remote targets."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|tracepoint_number
operator|==
operator|-
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"No current trace frame."
argument_list|)
expr_stmt|;
return|return;
block|}
name|ALL_TRACEPOINTS
argument_list|(
argument|t
argument_list|)
if|if
condition|(
name|t
operator|->
name|number
operator|==
name|tracepoint_number
condition|)
break|break;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"No known tracepoint matches 'current' tracepoint #%d."
argument_list|,
name|tracepoint_number
argument_list|)
expr_stmt|;
name|old_cleanups
operator|=
name|make_cleanup
argument_list|(
name|null_cleanup
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Data collected at tracepoint %d, trace frame %d:\n"
argument_list|,
name|tracepoint_number
argument_list|,
name|traceframe_number
argument_list|)
expr_stmt|;
comment|/* The current frame is a trap frame if the frame PC is equal      to the tracepoint PC.  If not, then the current frame was      collected during single-stepping.  */
name|stepping_frame
operator|=
operator|(
name|t
operator|->
name|address
operator|!=
operator|(
name|read_pc
argument_list|()
operator|-
name|DECR_PC_AFTER_BREAK
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|action
operator|=
name|t
operator|->
name|actions
init|;
name|action
condition|;
name|action
operator|=
name|action
operator|->
name|next
control|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|cmd
decl_stmt|;
name|QUIT
expr_stmt|;
comment|/* allow user to bail out with ^C */
name|action_exp
operator|=
name|action
operator|->
name|action
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|action_exp
argument_list|)
condition|)
name|action_exp
operator|++
expr_stmt|;
comment|/* The collection actions to be done while stepping are          bracketed by the commands "while-stepping" and "end".  */
if|if
condition|(
operator|*
name|action_exp
operator|==
literal|'#'
condition|)
comment|/* comment line */
continue|continue;
name|cmd
operator|=
name|lookup_cmd
argument_list|(
operator|&
name|action_exp
argument_list|,
name|cmdlist
argument_list|,
literal|""
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Bad action list item: %s"
argument_list|,
name|action_exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd_cfunc_eq
argument_list|(
name|cmd
argument_list|,
name|while_stepping_pseudocommand
argument_list|)
condition|)
name|stepping_actions
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd_cfunc_eq
argument_list|(
name|cmd
argument_list|,
name|end_actions_pseudocommand
argument_list|)
condition|)
name|stepping_actions
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd_cfunc_eq
argument_list|(
name|cmd
argument_list|,
name|collect_pseudocommand
argument_list|)
condition|)
block|{
comment|/* Display the collected data. 	     For the trap frame, display only what was collected at the trap. 	     Likewise for stepping frames, display only what was collected 	     while stepping.  This means that the two boolean variables, 	     STEPPING_FRAME and STEPPING_ACTIONS should be equal.  */
if|if
condition|(
name|stepping_frame
operator|==
name|stepping_actions
condition|)
block|{
do|do
block|{
comment|/* repeat over a comma-separated list */
name|QUIT
expr_stmt|;
comment|/* allow user to bail out with ^C */
if|if
condition|(
operator|*
name|action_exp
operator|==
literal|','
condition|)
name|action_exp
operator|++
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|int
operator|)
operator|*
name|action_exp
argument_list|)
condition|)
name|action_exp
operator|++
expr_stmt|;
name|next_comma
operator|=
name|strchr
argument_list|(
name|action_exp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|strncasecmp
argument_list|(
name|action_exp
argument_list|,
literal|"$reg"
argument_list|,
literal|4
argument_list|)
condition|)
name|registers_info
argument_list|(
name|NULL
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strncasecmp
argument_list|(
name|action_exp
argument_list|,
literal|"$loc"
argument_list|,
literal|4
argument_list|)
condition|)
name|locals_info
argument_list|(
name|NULL
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strncasecmp
argument_list|(
name|action_exp
argument_list|,
literal|"$arg"
argument_list|,
literal|4
argument_list|)
condition|)
name|args_info
argument_list|(
name|NULL
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* variable */
if|if
condition|(
name|next_comma
condition|)
block|{
name|make_cleanup
argument_list|(
name|replace_comma
argument_list|,
name|next_comma
argument_list|)
expr_stmt|;
operator|*
name|next_comma
operator|=
literal|'\0'
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"%s = "
argument_list|,
name|action_exp
argument_list|)
expr_stmt|;
name|output_command
argument_list|(
name|action_exp
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|next_comma
condition|)
operator|*
name|next_comma
operator|=
literal|','
expr_stmt|;
name|action_exp
operator|=
name|next_comma
expr_stmt|;
block|}
do|while
condition|(
name|action_exp
operator|&&
operator|*
name|action_exp
operator|==
literal|','
condition|)
do|;
block|}
block|}
block|}
name|discard_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert the memory pointed to by mem into hex, placing result in buf.  * Return a pointer to the last char put in buf (null)  * "stolen" from sparc-stub.c  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|hexchars
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|mem2hex
parameter_list|(
name|unsigned
name|char
modifier|*
name|mem
parameter_list|,
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|unsigned
name|char
name|ch
decl_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
name|ch
operator|=
operator|*
name|mem
operator|++
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|hexchars
index|[
name|ch
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|hexchars
index|[
name|ch
operator|&
literal|0xf
index|]
expr_stmt|;
block|}
operator|*
name|buf
operator|=
literal|0
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
name|int
name|get_traceframe_number
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|traceframe_number
return|;
block|}
end_function

begin_comment
comment|/* module initialization */
end_comment

begin_function
name|void
name|_initialize_tracepoint
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|tracepoint_chain
operator|=
literal|0
expr_stmt|;
name|tracepoint_count
operator|=
literal|0
expr_stmt|;
name|traceframe_number
operator|=
operator|-
literal|1
expr_stmt|;
name|tracepoint_number
operator|=
operator|-
literal|1
expr_stmt|;
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"tpnum"
argument_list|)
argument_list|,
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"trace_frame"
argument_list|)
argument_list|,
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tracepoint_list
operator|.
name|list
operator|==
name|NULL
condition|)
block|{
name|tracepoint_list
operator|.
name|listsize
operator|=
literal|128
expr_stmt|;
name|tracepoint_list
operator|.
name|list
operator|=
name|xmalloc
argument_list|(
name|tracepoint_list
operator|.
name|listsize
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|memrange
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tracepoint_list
operator|.
name|aexpr_list
operator|==
name|NULL
condition|)
block|{
name|tracepoint_list
operator|.
name|aexpr_listsize
operator|=
literal|128
expr_stmt|;
name|tracepoint_list
operator|.
name|aexpr_list
operator|=
name|xmalloc
argument_list|(
name|tracepoint_list
operator|.
name|aexpr_listsize
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|agent_expr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stepping_list
operator|.
name|list
operator|==
name|NULL
condition|)
block|{
name|stepping_list
operator|.
name|listsize
operator|=
literal|128
expr_stmt|;
name|stepping_list
operator|.
name|list
operator|=
name|xmalloc
argument_list|(
name|stepping_list
operator|.
name|listsize
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|memrange
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stepping_list
operator|.
name|aexpr_list
operator|==
name|NULL
condition|)
block|{
name|stepping_list
operator|.
name|aexpr_listsize
operator|=
literal|128
expr_stmt|;
name|stepping_list
operator|.
name|aexpr_list
operator|=
name|xmalloc
argument_list|(
name|stepping_list
operator|.
name|aexpr_listsize
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|agent_expr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|add_info
argument_list|(
literal|"scope"
argument_list|,
name|scope_info
argument_list|,
literal|"List the variables local to a scope"
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"tracepoints"
argument_list|,
name|class_trace
argument_list|,
name|NULL
argument_list|,
literal|"Tracing of program execution without stopping the program."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"tracepoints"
argument_list|,
name|tracepoints_info
argument_list|,
literal|"Status of tracepoints, or tracepoint number NUMBER.\n\ Convenience variable \"$tpnum\" contains the number of the\n\ last tracepoint set."
argument_list|)
expr_stmt|;
name|add_info_alias
argument_list|(
literal|"tp"
argument_list|,
literal|"tracepoints"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_com
argument_list|(
literal|"save-tracepoints"
argument_list|,
name|class_trace
argument_list|,
name|tracepoint_save_command
argument_list|,
literal|"Save current tracepoint definitions as a script.\n\ Use the 'source' command in another debug session to restore them."
argument_list|)
expr_stmt|;
name|set_cmd_completer
argument_list|(
name|c
argument_list|,
name|filename_completer
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"tdump"
argument_list|,
name|class_trace
argument_list|,
name|trace_dump_command
argument_list|,
literal|"Print everything collected at the current tracepoint."
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"tfind"
argument_list|,
name|class_trace
argument_list|,
name|trace_find_command
argument_list|,
literal|"Select a trace frame;\n\ No argument means forward by one frame; '-' meand backward by one frame."
argument_list|,
operator|&
name|tfindlist
argument_list|,
literal|"tfind "
argument_list|,
literal|1
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"outside"
argument_list|,
name|class_trace
argument_list|,
name|trace_find_outside_command
argument_list|,
literal|"Select a trace frame whose PC is outside the given \ range.\nUsage: tfind outside addr1, addr2"
argument_list|,
operator|&
name|tfindlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"range"
argument_list|,
name|class_trace
argument_list|,
name|trace_find_range_command
argument_list|,
literal|"Select a trace frame whose PC is in the given range.\n\ Usage: tfind range addr1,addr2"
argument_list|,
operator|&
name|tfindlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"line"
argument_list|,
name|class_trace
argument_list|,
name|trace_find_line_command
argument_list|,
literal|"Select a trace frame by source line.\n\ Argument can be a line number (with optional source file), \n\ a function name, or '*' followed by an address.\n\ Default argument is 'the next source line that was traced'."
argument_list|,
operator|&
name|tfindlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"tracepoint"
argument_list|,
name|class_trace
argument_list|,
name|trace_find_tracepoint_command
argument_list|,
literal|"Select a trace frame by tracepoint number.\n\ Default is the tracepoint for the current trace frame."
argument_list|,
operator|&
name|tfindlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"pc"
argument_list|,
name|class_trace
argument_list|,
name|trace_find_pc_command
argument_list|,
literal|"Select a trace frame by PC.\n\ Default is the current PC, or the PC of the current trace frame."
argument_list|,
operator|&
name|tfindlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"end"
argument_list|,
name|class_trace
argument_list|,
name|trace_find_end_command
argument_list|,
literal|"Synonym for 'none'.\n\ De-select any trace frame and resume 'live' debugging."
argument_list|,
operator|&
name|tfindlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"none"
argument_list|,
name|class_trace
argument_list|,
name|trace_find_none_command
argument_list|,
literal|"De-select any trace frame and resume 'live' debugging."
argument_list|,
operator|&
name|tfindlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"start"
argument_list|,
name|class_trace
argument_list|,
name|trace_find_start_command
argument_list|,
literal|"Select the first trace frame in the trace buffer."
argument_list|,
operator|&
name|tfindlist
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"tstatus"
argument_list|,
name|class_trace
argument_list|,
name|trace_status_command
argument_list|,
literal|"Display the status of the current trace data collection."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"tstop"
argument_list|,
name|class_trace
argument_list|,
name|trace_stop_command
argument_list|,
literal|"Stop trace data collection."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"tstart"
argument_list|,
name|class_trace
argument_list|,
name|trace_start_command
argument_list|,
literal|"Start trace data collection."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"passcount"
argument_list|,
name|class_trace
argument_list|,
name|trace_pass_command
argument_list|,
literal|"Set the passcount for a tracepoint.\n\ The trace will end when the tracepoint has been passed 'count' times.\n\ Usage: passcount COUNT TPNUM, where TPNUM may also be \"all\";\n\ if TPNUM is omitted, passcount refers to the last tracepoint defined."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"end"
argument_list|,
name|class_trace
argument_list|,
name|end_actions_pseudocommand
argument_list|,
literal|"Ends a list of commands or actions.\n\ Several GDB commands allow you to enter a list of commands or actions.\n\ Entering \"end\" on a line by itself is the normal way to terminate\n\ such a list.\n\n\ Note: the \"end\" command cannot be used at the gdb prompt."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"while-stepping"
argument_list|,
name|class_trace
argument_list|,
name|while_stepping_pseudocommand
argument_list|,
literal|"Specify single-stepping behavior at a tracepoint.\n\ Argument is number of instructions to trace in single-step mode\n\ following the tracepoint.  This command is normally followed by\n\ one or more \"collect\" commands, to specify what to collect\n\ while single-stepping.\n\n\ Note: this command can only be used in a tracepoint \"actions\" list."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"ws"
argument_list|,
literal|"while-stepping"
argument_list|,
name|class_alias
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"stepping"
argument_list|,
literal|"while-stepping"
argument_list|,
name|class_alias
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"collect"
argument_list|,
name|class_trace
argument_list|,
name|collect_pseudocommand
argument_list|,
literal|"Specify one or more data items to be collected at a tracepoint.\n\ Accepts a comma-separated list of (one or more) expressions.  GDB will\n\ collect all data (variables, registers) referenced by that expression.\n\ Also accepts the following special arguments:\n\     $regs   -- all registers.\n\     $args   -- all function arguments.\n\     $locals -- all variables local to the block/function scope.\n\ Note: this command can only be used in a tracepoint \"actions\" list."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"actions"
argument_list|,
name|class_trace
argument_list|,
name|trace_actions_command
argument_list|,
literal|"Specify the actions to be taken at a tracepoint.\n\ Tracepoint actions may include collecting of specified data, \n\ single-stepping, or enabling/disabling other tracepoints, \n\ depending on target's capabilities."
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"tracepoints"
argument_list|,
name|class_trace
argument_list|,
name|delete_trace_command
argument_list|,
literal|"Delete specified tracepoints.\n\ Arguments are tracepoint numbers, separated by spaces.\n\ No argument means delete all tracepoints."
argument_list|,
operator|&
name|deletelist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"tracepoints"
argument_list|,
name|class_trace
argument_list|,
name|disable_trace_command
argument_list|,
literal|"Disable specified tracepoints.\n\ Arguments are tracepoint numbers, separated by spaces.\n\ No argument means disable all tracepoints."
argument_list|,
operator|&
name|disablelist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"tracepoints"
argument_list|,
name|class_trace
argument_list|,
name|enable_trace_command
argument_list|,
literal|"Enable specified tracepoints.\n\ Arguments are tracepoint numbers, separated by spaces.\n\ No argument means enable all tracepoints."
argument_list|,
operator|&
name|enablelist
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_com
argument_list|(
literal|"trace"
argument_list|,
name|class_trace
argument_list|,
name|trace_command
argument_list|,
literal|"Set a tracepoint at a specified line or function or address.\n\ Argument may be a line number, function name, or '*' plus an address.\n\ For a line number or function, trace at the start of its code.\n\ If an address is specified, trace at that exact address.\n\n\ Do \"help tracepoints\" for info on other tracepoint commands."
argument_list|)
expr_stmt|;
name|set_cmd_completer
argument_list|(
name|c
argument_list|,
name|location_completer
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"tp"
argument_list|,
literal|"trace"
argument_list|,
name|class_alias
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"tr"
argument_list|,
literal|"trace"
argument_list|,
name|class_alias
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"tra"
argument_list|,
literal|"trace"
argument_list|,
name|class_alias
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"trac"
argument_list|,
literal|"trace"
argument_list|,
name|class_alias
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

