begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Tracing functionality for remote targets in custom GDB protocol    Copyright 1997, 1998 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"tracepoint.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"ax.h"
end_include

begin_include
include|#
directive|include
file|"ax-gdb.h"
end_include

begin_comment
comment|/* readline include files */
end_comment

begin_include
include|#
directive|include
file|<readline/readline.h>
end_include

begin_include
include|#
directive|include
file|<readline/history.h>
end_include

begin_comment
comment|/* readline defines this.  */
end_comment

begin_undef
undef|#
directive|undef
name|savestring
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* maximum length of an agent aexpression.    this accounts for the fact that packets are limited to 400 bytes    (which includes everything -- including the checksum), and assumes    the worst case of maximum length for each of the pieces of a    continuation packet.        NOTE: expressions get mem2hex'ed otherwise this would be twice as    large.  (400 - 31)/2 == 184 */
end_comment

begin_define
define|#
directive|define
name|MAX_AGENT_EXPR_LEN
value|184
end_define

begin_decl_stmt
specifier|extern
name|int
name|info_verbose
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern void (*readline_begin_hook
end_extern

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern char * (*readline_hook
end_extern

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_extern
extern|extern void (*readline_end_hook
end_extern

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|extern
name|void
name|x_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|addressprint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print machine addresses? */
end_comment

begin_comment
comment|/* If this definition isn't overridden by the header files, assume    that isatty and fileno exist on this system.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ISATTY
end_ifndef

begin_define
define|#
directive|define
name|ISATTY
parameter_list|(
name|FP
parameter_list|)
value|(isatty (fileno (FP)))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*     Tracepoint.c:     This module defines the following debugger commands:    trace            : set a tracepoint on a function, line, or address.    info trace       : list all debugger-defined tracepoints.    delete trace     : delete one or more tracepoints.    enable trace     : enable one or more tracepoints.    disable trace    : disable one or more tracepoints.    actions          : specify actions to be taken at a tracepoint.    passcount        : specify a pass count for a tracepoint.    tstart           : start a trace experiment.    tstop            : stop a trace experiment.    tstatus          : query the status of a trace experiment.    tfind            : find a trace frame in the trace buffer.    tdump            : print everything collected at the current tracepoint.    save-tracepoints : write tracepoint setup into a file.     This module defines the following user-visible debugger variables:    $trace_frame : sequence number of trace frame currently being debugged.    $trace_line  : source line of trace frame currently being debugged.    $trace_file  : source file of trace frame currently being debugged.    $tracepoint  : tracepoint number of trace frame currently being debugged.    */
end_comment

begin_comment
comment|/* ======= Important global variables: ======= */
end_comment

begin_comment
comment|/* Chain of all tracepoints defined.  */
end_comment

begin_decl_stmt
name|struct
name|tracepoint
modifier|*
name|tracepoint_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of last tracepoint made.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tracepoint_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of last traceframe collected.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|traceframe_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tracepoint for last traceframe collected.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tracepoint_number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Symbol for function for last traceframe collected */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|symbol
modifier|*
name|traceframe_fun
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Symtab and line for last traceframe collected */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|symtab_and_line
name|traceframe_sal
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tracing command lists */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cmd_list_element
modifier|*
name|tfindlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ======= Important command functions: ======= */
end_comment

begin_decl_stmt
specifier|static
name|void
name|trace_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tracepoints_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|delete_trace_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|enable_trace_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|disable_trace_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|trace_pass_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|trace_actions_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|trace_start_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|trace_stop_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|trace_status_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|trace_find_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|trace_find_pc_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|trace_find_tracepoint_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|trace_find_line_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|trace_find_range_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|trace_find_outside_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tracepoint_save_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|trace_dump_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* support routines */
end_comment

begin_decl_stmt
specifier|static
name|void
name|trace_mention
name|PARAMS
argument_list|(
operator|(
expr|struct
name|tracepoint
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct_decl
struct_decl|struct
name|collection_list
struct_decl|;
end_struct_decl

begin_decl_stmt
specifier|static
name|void
name|add_aexpr
name|PARAMS
argument_list|(
operator|(
expr|struct
name|collection_list
operator|*
operator|,
expr|struct
name|agent_expr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|unsigned
name|char
modifier|*
name|mem2hex
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|,
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Utility: returns true if "target remote" */
end_comment

begin_function
specifier|static
name|int
name|target_is_remote
parameter_list|()
block|{
if|if
condition|(
name|current_target
operator|.
name|to_shortname
operator|&&
name|strcmp
argument_list|(
name|current_target
operator|.
name|to_shortname
argument_list|,
literal|"remote"
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Utility: generate error from an incoming stub packet.  */
end_comment

begin_function
specifier|static
name|void
name|trace_error
parameter_list|(
name|buf
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|buf
operator|++
operator|!=
literal|'E'
condition|)
return|return;
comment|/* not an error msg */
switch|switch
condition|(
operator|*
name|buf
condition|)
block|{
case|case
literal|'1'
case|:
comment|/* malformed packet error */
if|if
condition|(
operator|*
operator|++
name|buf
operator|==
literal|'0'
condition|)
comment|/*   general case: */
name|error
argument_list|(
literal|"tracepoint.c: error in outgoing packet."
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"tracepoint.c: error in outgoing packet at field #%d."
argument_list|,
name|strtol
argument_list|(
name|buf
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
argument_list|)
expr_stmt|;
case|case
literal|'2'
case|:
name|error
argument_list|(
literal|"trace API error 0x%s."
argument_list|,
operator|++
name|buf
argument_list|)
expr_stmt|;
default|default:
name|error
argument_list|(
literal|"Target returns error code '%s'."
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Utility: wait for reply from stub, while accepting "O" packets */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|remote_get_noisy_reply
parameter_list|(
name|buf
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
block|{
do|do
comment|/* loop on reply from remote stub */
block|{
name|QUIT
expr_stmt|;
comment|/* allow user to bail out with ^C */
name|getpkt
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Target does not support this command."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'E'
condition|)
name|trace_error
argument_list|(
name|buf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'O'
operator|&&
name|buf
index|[
literal|1
index|]
operator|!=
literal|'K'
condition|)
name|remote_console_output
argument_list|(
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 'O' message from stub */
else|else
return|return
name|buf
return|;
comment|/* here's the actual reply */
block|}
do|while
condition|(
literal|1
condition|)
do|;
block|}
end_function

begin_comment
comment|/* Set tracepoint count to NUM.  */
end_comment

begin_function
specifier|static
name|void
name|set_tracepoint_count
parameter_list|(
name|num
parameter_list|)
name|int
name|num
decl_stmt|;
block|{
name|tracepoint_count
operator|=
name|num
expr_stmt|;
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"tpnum"
argument_list|)
argument_list|,
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|num
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set traceframe number to NUM.  */
end_comment

begin_function
specifier|static
name|void
name|set_traceframe_num
parameter_list|(
name|num
parameter_list|)
name|int
name|num
decl_stmt|;
block|{
name|traceframe_number
operator|=
name|num
expr_stmt|;
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"trace_frame"
argument_list|)
argument_list|,
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|num
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set tracepoint number to NUM.  */
end_comment

begin_function
specifier|static
name|void
name|set_tracepoint_num
parameter_list|(
name|num
parameter_list|)
name|int
name|num
decl_stmt|;
block|{
name|tracepoint_number
operator|=
name|num
expr_stmt|;
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"tracepoint"
argument_list|)
argument_list|,
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|num
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set externally visible debug variables for querying/printing    the traceframe context (line, function, file) */
end_comment

begin_function
specifier|static
name|void
name|set_traceframe_context
parameter_list|(
name|trace_pc
parameter_list|)
name|CORE_ADDR
name|trace_pc
decl_stmt|;
block|{
specifier|static
name|struct
name|type
modifier|*
name|func_string
decl_stmt|,
modifier|*
name|file_string
decl_stmt|;
specifier|static
name|struct
name|type
modifier|*
name|func_range
decl_stmt|,
modifier|*
name|file_range
decl_stmt|;
specifier|static
name|value_ptr
name|func_val
decl_stmt|,
name|file_val
decl_stmt|;
specifier|static
name|struct
name|type
modifier|*
name|charstar
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|charstar
operator|==
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
condition|)
name|charstar
operator|=
name|lookup_pointer_type
argument_list|(
name|builtin_type_char
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace_pc
operator|==
operator|-
literal|1
condition|)
comment|/* cease debugging any trace buffers */
block|{
name|traceframe_fun
operator|=
literal|0
expr_stmt|;
name|traceframe_sal
operator|.
name|pc
operator|=
name|traceframe_sal
operator|.
name|line
operator|=
literal|0
expr_stmt|;
name|traceframe_sal
operator|.
name|symtab
operator|=
name|NULL
expr_stmt|;
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"trace_func"
argument_list|)
argument_list|,
name|value_from_longest
argument_list|(
name|charstar
argument_list|,
operator|(
name|LONGEST
operator|)
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"trace_file"
argument_list|)
argument_list|,
name|value_from_longest
argument_list|(
name|charstar
argument_list|,
operator|(
name|LONGEST
operator|)
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"trace_line"
argument_list|)
argument_list|,
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* save as globals for internal use */
name|traceframe_sal
operator|=
name|find_pc_line
argument_list|(
name|trace_pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|traceframe_fun
operator|=
name|find_pc_function
argument_list|(
name|trace_pc
argument_list|)
expr_stmt|;
comment|/* save linenumber as "$trace_line", a debugger variable visible to users */
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"trace_line"
argument_list|)
argument_list|,
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|traceframe_sal
operator|.
name|line
argument_list|)
argument_list|)
expr_stmt|;
comment|/* save func name as "$trace_func", a debugger variable visible to users */
if|if
condition|(
name|traceframe_fun
operator|==
name|NULL
operator|||
name|SYMBOL_NAME
argument_list|(
name|traceframe_fun
argument_list|)
operator|==
name|NULL
condition|)
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"trace_func"
argument_list|)
argument_list|,
name|value_from_longest
argument_list|(
name|charstar
argument_list|,
operator|(
name|LONGEST
operator|)
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|len
operator|=
name|strlen
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|traceframe_fun
argument_list|)
argument_list|)
expr_stmt|;
name|func_range
operator|=
name|create_range_type
argument_list|(
name|func_range
argument_list|,
name|builtin_type_int
argument_list|,
literal|0
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|func_string
operator|=
name|create_array_type
argument_list|(
name|func_string
argument_list|,
name|builtin_type_char
argument_list|,
name|func_range
argument_list|)
expr_stmt|;
name|func_val
operator|=
name|allocate_value
argument_list|(
name|func_string
argument_list|)
expr_stmt|;
name|VALUE_TYPE
argument_list|(
name|func_val
argument_list|)
operator|=
name|func_string
expr_stmt|;
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|func_val
argument_list|)
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|traceframe_fun
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|func_val
operator|->
name|modifiable
operator|=
literal|0
expr_stmt|;
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"trace_func"
argument_list|)
argument_list|,
name|func_val
argument_list|)
expr_stmt|;
block|}
comment|/* save file name as "$trace_file", a debugger variable visible to users */
if|if
condition|(
name|traceframe_sal
operator|.
name|symtab
operator|==
name|NULL
operator|||
name|traceframe_sal
operator|.
name|symtab
operator|->
name|filename
operator|==
name|NULL
condition|)
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"trace_file"
argument_list|)
argument_list|,
name|value_from_longest
argument_list|(
name|charstar
argument_list|,
operator|(
name|LONGEST
operator|)
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|len
operator|=
name|strlen
argument_list|(
name|traceframe_sal
operator|.
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
name|file_range
operator|=
name|create_range_type
argument_list|(
name|file_range
argument_list|,
name|builtin_type_int
argument_list|,
literal|0
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|file_string
operator|=
name|create_array_type
argument_list|(
name|file_string
argument_list|,
name|builtin_type_char
argument_list|,
name|file_range
argument_list|)
expr_stmt|;
name|file_val
operator|=
name|allocate_value
argument_list|(
name|file_string
argument_list|)
expr_stmt|;
name|VALUE_TYPE
argument_list|(
name|file_val
argument_list|)
operator|=
name|file_string
expr_stmt|;
name|memcpy
argument_list|(
name|VALUE_CONTENTS_RAW
argument_list|(
name|file_val
argument_list|)
argument_list|,
name|traceframe_sal
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|file_val
operator|->
name|modifiable
operator|=
literal|0
expr_stmt|;
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"trace_file"
argument_list|)
argument_list|,
name|file_val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Low level routine to set a tracepoint.    Returns the tracepoint object so caller can set other things.    Does not set the tracepoint number!    Does not print anything.     ==> This routine should not be called if there is a chance of later    error(); otherwise it leaves a bogus tracepoint on the chain.  Validate    your arguments BEFORE calling this routine!  */
end_comment

begin_function
specifier|static
name|struct
name|tracepoint
modifier|*
name|set_raw_tracepoint
parameter_list|(
name|sal
parameter_list|)
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
block|{
specifier|register
name|struct
name|tracepoint
modifier|*
name|t
decl_stmt|,
modifier|*
name|tc
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|t
operator|=
operator|(
expr|struct
name|tracepoint
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tracepoint
argument_list|)
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|address
operator|=
name|sal
operator|.
name|pc
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|symtab
operator|==
name|NULL
condition|)
name|t
operator|->
name|source_file
operator|=
name|NULL
expr_stmt|;
else|else
name|t
operator|->
name|source_file
operator|=
name|savestring
argument_list|(
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|,
name|strlen
argument_list|(
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|section
operator|=
name|sal
operator|.
name|section
expr_stmt|;
name|t
operator|->
name|language
operator|=
name|current_language
operator|->
name|la_language
expr_stmt|;
name|t
operator|->
name|input_radix
operator|=
name|input_radix
expr_stmt|;
name|t
operator|->
name|line_number
operator|=
name|sal
operator|.
name|line
expr_stmt|;
name|t
operator|->
name|enabled
operator|=
name|enabled
expr_stmt|;
name|t
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|step_count
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|pass_count
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|addr_string
operator|=
name|NULL
expr_stmt|;
comment|/* Add this tracepoint to the end of the chain      so that a list of tracepoints will come out in order      of increasing numbers.  */
name|tc
operator|=
name|tracepoint_chain
expr_stmt|;
if|if
condition|(
name|tc
operator|==
literal|0
condition|)
name|tracepoint_chain
operator|=
name|t
expr_stmt|;
else|else
block|{
while|while
condition|(
name|tc
operator|->
name|next
condition|)
name|tc
operator|=
name|tc
operator|->
name|next
expr_stmt|;
name|tc
operator|->
name|next
operator|=
name|t
expr_stmt|;
block|}
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_comment
comment|/* Set a tracepoint according to ARG (function, linenum or *address) */
end_comment

begin_function
specifier|static
name|void
name|trace_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|canonical
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
decl_stmt|;
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|tracepoint
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|addr_start
init|=
literal|0
decl_stmt|,
modifier|*
name|addr_end
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|arg
operator|||
operator|!
operator|*
name|arg
condition|)
name|error
argument_list|(
literal|"trace command requires an argument"
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
operator|&&
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"TRACE %s\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|addr_start
operator|=
name|arg
expr_stmt|;
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|arg
argument_list|,
literal|1
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|canonical
argument_list|)
expr_stmt|;
name|addr_end
operator|=
name|arg
expr_stmt|;
if|if
condition|(
operator|!
name|sals
operator|.
name|nelts
condition|)
return|return;
comment|/* ??? Presumably decode_line_1 has already warned? */
comment|/* Resolve all line numbers to PC's */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|.
name|nelts
condition|;
name|i
operator|++
control|)
name|resolve_sal_pc
argument_list|(
operator|&
name|sals
operator|.
name|sals
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Now set all the tracepoints.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sals
operator|.
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|sal
operator|=
name|sals
operator|.
name|sals
index|[
name|i
index|]
expr_stmt|;
name|t
operator|=
name|set_raw_tracepoint
argument_list|(
name|sal
argument_list|)
expr_stmt|;
name|set_tracepoint_count
argument_list|(
name|tracepoint_count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|t
operator|->
name|number
operator|=
name|tracepoint_count
expr_stmt|;
comment|/* If a canonical line spec is needed use that instead of the 	 command string.  */
if|if
condition|(
name|canonical
operator|!=
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
operator|&&
name|canonical
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|t
operator|->
name|addr_string
operator|=
name|canonical
index|[
name|i
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|addr_start
condition|)
name|t
operator|->
name|addr_string
operator|=
name|savestring
argument_list|(
name|addr_start
argument_list|,
name|addr_end
operator|-
name|addr_start
argument_list|)
expr_stmt|;
name|trace_mention
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* Let the UI know of any additions */
if|if
condition|(
name|create_tracepoint_hook
condition|)
name|create_tracepoint_hook
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sals
operator|.
name|nelts
operator|>
literal|1
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Multiple tracepoints were set.\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Use 'delete trace' to delete unwanted tracepoints.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Tell the user we have just set a tracepoint TP. */
end_comment

begin_function
specifier|static
name|void
name|trace_mention
parameter_list|(
name|tp
parameter_list|)
name|struct
name|tracepoint
modifier|*
name|tp
decl_stmt|;
block|{
name|printf_filtered
argument_list|(
literal|"Tracepoint %d"
argument_list|,
name|tp
operator|->
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|addressprint
operator|||
operator|(
name|tp
operator|->
name|source_file
operator|==
name|NULL
operator|)
condition|)
block|{
name|printf_filtered
argument_list|(
literal|" at "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|tp
operator|->
name|address
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|source_file
condition|)
name|printf_filtered
argument_list|(
literal|": file %s, line %d."
argument_list|,
name|tp
operator|->
name|source_file
argument_list|,
name|tp
operator|->
name|line_number
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print information on tracepoint number TPNUM_EXP, or all if omitted.  */
end_comment

begin_function
specifier|static
name|void
name|tracepoints_info
parameter_list|(
name|tpnum_exp
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|tpnum_exp
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|tracepoint
modifier|*
name|t
decl_stmt|;
name|struct
name|action_line
modifier|*
name|action
decl_stmt|;
name|int
name|found_a_tracepoint
init|=
literal|0
decl_stmt|;
name|char
name|wrap_indent
index|[
literal|80
index|]
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|int
name|tpnum
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|tpnum_exp
condition|)
name|tpnum
operator|=
name|parse_and_eval_address
argument_list|(
name|tpnum_exp
argument_list|)
expr_stmt|;
name|ALL_TRACEPOINTS
argument_list|(
argument|t
argument_list|)
if|if
condition|(
name|tpnum
operator|==
operator|-
literal|1
operator|||
name|tpnum
operator|==
name|t
operator|->
name|number
condition|)
block|{
specifier|extern
name|int
name|addressprint
decl_stmt|;
comment|/* print machine addresses? */
if|if
condition|(
operator|!
name|found_a_tracepoint
operator|++
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Num Enb "
argument_list|)
expr_stmt|;
if|if
condition|(
name|addressprint
condition|)
name|printf_filtered
argument_list|(
literal|"Address    "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"PassC StepC What\n"
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|wrap_indent
argument_list|,
literal|"                           "
argument_list|)
expr_stmt|;
if|if
condition|(
name|addressprint
condition|)
name|strcat
argument_list|(
name|wrap_indent
argument_list|,
literal|"           "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%-3d %-3s "
argument_list|,
name|t
operator|->
name|number
argument_list|,
name|t
operator|->
name|enabled
operator|==
name|enabled
condition|?
literal|"y"
else|:
literal|"n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|addressprint
condition|)
name|printf_filtered
argument_list|(
literal|"%s "
argument_list|,
name|local_hex_string_custom
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|t
operator|->
name|address
argument_list|,
literal|"08l"
argument_list|)
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%-5d %-5d "
argument_list|,
name|t
operator|->
name|pass_count
argument_list|,
name|t
operator|->
name|step_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|source_file
condition|)
block|{
name|sym
operator|=
name|find_pc_sect_function
argument_list|(
name|t
operator|->
name|address
argument_list|,
name|t
operator|->
name|section
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"in "
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|SYMBOL_SOURCE_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
name|wrap_indent
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" at "
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
name|t
operator|->
name|source_file
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|":%d"
argument_list|,
name|t
operator|->
name|line_number
argument_list|)
expr_stmt|;
block|}
else|else
name|print_address_symbolic
argument_list|(
name|t
operator|->
name|address
argument_list|,
name|gdb_stdout
argument_list|,
name|demangle
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|actions
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"  Actions for tracepoint %d: \n"
argument_list|,
name|t
operator|->
name|number
argument_list|)
expr_stmt|;
for|for
control|(
name|action
operator|=
name|t
operator|->
name|actions
init|;
name|action
condition|;
name|action
operator|=
name|action
operator|->
name|next
control|)
block|{
name|printf_filtered
argument_list|(
literal|"\t%s\n"
argument_list|,
name|action
operator|->
name|action
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|found_a_tracepoint
condition|)
block|{
if|if
condition|(
name|tpnum
operator|==
operator|-
literal|1
condition|)
name|printf_filtered
argument_list|(
literal|"No tracepoints.\n"
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"No tracepoint number %d.\n"
argument_list|,
name|tpnum
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Optimization: the code to parse an enable, disable, or delete TP command    is virtually identical except for whether it performs an enable, disable,    or delete.  Therefore I've combined them into one function with an opcode.    */
end_comment

begin_enum
enum|enum
name|tracepoint_opcode
block|{
name|enable
block|,
name|disable
block|,
name|delete
block|}
enum|;
end_enum

begin_comment
comment|/* This function implements enable, disable and delete. */
end_comment

begin_function
specifier|static
name|void
name|tracepoint_operation
parameter_list|(
name|t
parameter_list|,
name|from_tty
parameter_list|,
name|opcode
parameter_list|)
name|struct
name|tracepoint
modifier|*
name|t
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|enum
name|tracepoint_opcode
name|opcode
decl_stmt|;
block|{
name|struct
name|tracepoint
modifier|*
name|t2
decl_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|enable
case|:
name|t
operator|->
name|enabled
operator|=
name|enabled
expr_stmt|;
if|if
condition|(
name|modify_tracepoint_hook
condition|)
name|modify_tracepoint_hook
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|disable
case|:
name|t
operator|->
name|enabled
operator|=
name|disabled
expr_stmt|;
if|if
condition|(
name|modify_tracepoint_hook
condition|)
name|modify_tracepoint_hook
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
name|delete
case|:
if|if
condition|(
name|tracepoint_chain
operator|==
name|t
condition|)
name|tracepoint_chain
operator|=
name|t
operator|->
name|next
expr_stmt|;
name|ALL_TRACEPOINTS
argument_list|(
argument|t2
argument_list|)
if|if
condition|(
name|t2
operator|->
name|next
operator|==
name|t
condition|)
block|{
name|t2
operator|->
name|next
operator|=
name|t
operator|->
name|next
expr_stmt|;
break|break;
block|}
comment|/* Let the UI know of any deletions */
if|if
condition|(
name|delete_tracepoint_hook
condition|)
name|delete_tracepoint_hook
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|addr_string
condition|)
name|free
argument_list|(
name|t
operator|->
name|addr_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|source_file
condition|)
name|free
argument_list|(
name|t
operator|->
name|source_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|actions
condition|)
name|free_actions
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Utility: parse a tracepoint number and look it up in the list.  */
end_comment

begin_function
name|struct
name|tracepoint
modifier|*
name|get_tracepoint_by_number
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|tracepoint
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|,
modifier|*
name|copy
decl_stmt|;
name|value_ptr
name|val
decl_stmt|;
name|int
name|tpnum
decl_stmt|;
if|if
condition|(
name|arg
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Bad tracepoint argument"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|arg
operator|==
literal|0
operator|||
operator|*
operator|*
name|arg
operator|==
literal|0
condition|)
comment|/* empty arg means refer to last tp */
name|tpnum
operator|=
name|tracepoint_count
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|*
name|arg
operator|==
literal|'$'
condition|)
comment|/* handle convenience variable */
block|{
comment|/* Make a copy of the name, so we can null-terminate it 	 to pass to lookup_internalvar().  */
name|end
operator|=
operator|*
name|arg
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
operator|*
name|end
argument_list|)
operator|||
operator|*
name|end
operator|==
literal|'_'
condition|)
name|end
operator|++
expr_stmt|;
name|copy
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|end
operator|-
operator|*
name|arg
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|copy
argument_list|,
operator|*
name|arg
operator|+
literal|1
argument_list|,
operator|(
name|end
operator|-
operator|*
name|arg
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|copy
index|[
name|end
operator|-
operator|*
name|arg
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|arg
operator|=
name|end
expr_stmt|;
name|val
operator|=
name|value_of_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
name|copy
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_INT
condition|)
name|error
argument_list|(
literal|"Convenience variable must have integral type."
argument_list|)
expr_stmt|;
name|tpnum
operator|=
operator|(
name|int
operator|)
name|value_as_long
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* handle tracepoint number */
block|{
name|tpnum
operator|=
name|strtol
argument_list|(
operator|*
name|arg
argument_list|,
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpnum
operator|==
literal|0
condition|)
comment|/* possible strtol failure */
while|while
condition|(
operator|*
operator|*
name|arg
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
operator|*
name|arg
argument_list|)
condition|)
operator|(
operator|*
name|arg
operator|)
operator|++
expr_stmt|;
comment|/* advance to next white space, if any */
block|}
name|ALL_TRACEPOINTS
argument_list|(
argument|t
argument_list|)
if|if
condition|(
name|t
operator|->
name|number
operator|==
name|tpnum
condition|)
block|{
return|return
name|t
return|;
block|}
name|printf_unfiltered
argument_list|(
literal|"No tracepoint number %d.\n"
argument_list|,
name|tpnum
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Utility: parse a list of tracepoint numbers, and call a func for each. */
end_comment

begin_function
specifier|static
name|void
name|map_args_over_tracepoints
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|,
name|opcode
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|enum
name|tracepoint_opcode
name|opcode
decl_stmt|;
block|{
name|struct
name|tracepoint
modifier|*
name|t
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|int
name|tpnum
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|args
operator|==
literal|0
operator|||
operator|*
name|args
operator|==
literal|0
condition|)
comment|/* do them all */
name|ALL_TRACEPOINTS_SAFE
argument_list|(
argument|t
argument_list|,
argument|tmp
argument_list|)
name|tracepoint_operation
argument_list|(
name|t
argument_list|,
name|from_tty
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
operator|*
name|args
condition|)
block|{
name|QUIT
expr_stmt|;
comment|/* give user option to bail out with ^C */
if|if
condition|(
name|t
operator|=
name|get_tracepoint_by_number
argument_list|(
operator|&
name|args
argument_list|)
condition|)
name|tracepoint_operation
argument_list|(
name|t
argument_list|,
name|from_tty
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|args
operator|==
literal|' '
operator|||
operator|*
name|args
operator|==
literal|'\t'
condition|)
name|args
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The 'enable trace' command enables tracepoints.  Not supported by all targets.  */
end_comment

begin_function
specifier|static
name|void
name|enable_trace_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|dont_repeat
argument_list|()
expr_stmt|;
name|map_args_over_tracepoints
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|,
name|enable
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The 'disable trace' command enables tracepoints.  Not supported by all targets.  */
end_comment

begin_function
specifier|static
name|void
name|disable_trace_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|dont_repeat
argument_list|()
expr_stmt|;
name|map_args_over_tracepoints
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|,
name|disable
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove a tracepoint (or all if no argument) */
end_comment

begin_function
specifier|static
name|void
name|delete_trace_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|dont_repeat
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|args
operator|||
operator|!
operator|*
name|args
condition|)
comment|/* No args implies all tracepoints; */
if|if
condition|(
name|from_tty
condition|)
comment|/* confirm only if from_tty... */
if|if
condition|(
name|tracepoint_chain
condition|)
comment|/* and if there are tracepoints to delete! */
if|if
condition|(
operator|!
name|query
argument_list|(
literal|"Delete all tracepoints? "
argument_list|)
condition|)
return|return;
name|map_args_over_tracepoints
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|,
name|delete
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set passcount for tracepoint.     First command argument is passcount, second is tracepoint number.    If tracepoint number omitted, apply to most recently defined.    Also accepts special argument "all".  */
end_comment

begin_function
specifier|static
name|void
name|trace_pass_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|tracepoint
modifier|*
name|t1
init|=
operator|(
expr|struct
name|tracepoint
operator|*
operator|)
operator|-
literal|1
decl_stmt|,
modifier|*
name|t2
decl_stmt|;
name|unsigned
name|long
name|count
decl_stmt|;
if|if
condition|(
name|args
operator|==
literal|0
operator|||
operator|*
name|args
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"PASS command requires an argument (count + optional TP num)"
argument_list|)
expr_stmt|;
name|count
operator|=
name|strtoul
argument_list|(
name|args
argument_list|,
operator|&
name|args
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* count comes first, then TP num */
while|while
condition|(
operator|*
name|args
operator|&&
name|isspace
argument_list|(
operator|*
name|args
argument_list|)
condition|)
name|args
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|args
operator|&&
name|strncasecmp
argument_list|(
name|args
argument_list|,
literal|"all"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|args
operator|+=
literal|3
expr_stmt|;
comment|/* skip special argument "all" */
else|else
name|t1
operator|=
name|get_tracepoint_by_number
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|args
condition|)
name|error
argument_list|(
literal|"Junk at end of arguments."
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
operator|==
name|NULL
condition|)
return|return;
comment|/* error, bad tracepoint number */
name|ALL_TRACEPOINTS
argument_list|(
argument|t2
argument_list|)
if|if
condition|(
name|t1
operator|==
operator|(
expr|struct
name|tracepoint
operator|*
operator|)
operator|-
literal|1
operator|||
name|t1
operator|==
name|t2
condition|)
block|{
name|t2
operator|->
name|pass_count
operator|=
name|count
expr_stmt|;
if|if
condition|(
name|modify_tracepoint_hook
condition|)
name|modify_tracepoint_hook
argument_list|(
name|t2
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf_filtered
argument_list|(
literal|"Setting tracepoint %d's passcount to %d\n"
argument_list|,
name|t2
operator|->
name|number
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ACTIONS functions: */
end_comment

begin_comment
comment|/* Prototypes for action-parsing utility commands  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|read_actions
name|PARAMS
argument_list|(
operator|(
expr|struct
name|tracepoint
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|parse_and_eval_memrange
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|CORE_ADDR
operator|,
name|long
operator|*
operator|,
name|bfd_signed_vma
operator|*
operator|,
name|long
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The three functions:    	collect_pseudocommand,  	while_stepping_pseudocommand, and  	end_actions_pseudocommand    are placeholders for "commands" that are actually ONLY to be used    within a tracepoint action list.  If the actual function is ever called,    it means that somebody issued the "command" at the top level,    which is always an error.  */
end_comment

begin_function
specifier|static
name|void
name|end_actions_pseudocommand
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|error
argument_list|(
literal|"This command cannot be used at the top level."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|while_stepping_pseudocommand
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|error
argument_list|(
literal|"This command can only be used in a tracepoint actions list."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|collect_pseudocommand
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|error
argument_list|(
literal|"This command can only be used in a tracepoint actions list."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Enter a list of actions for a tracepoint.  */
end_comment

begin_function
specifier|static
name|void
name|trace_actions_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|tracepoint
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|actions
decl_stmt|;
name|char
name|tmpbuf
index|[
literal|128
index|]
decl_stmt|;
name|char
modifier|*
name|end_msg
init|=
literal|"End with a line saying just \"end\"."
decl_stmt|;
if|if
condition|(
name|t
operator|=
name|get_tracepoint_by_number
argument_list|(
operator|&
name|args
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|tmpbuf
argument_list|,
literal|"Enter actions for tracepoint %d, one per line."
argument_list|,
name|t
operator|->
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
if|if
condition|(
name|readline_begin_hook
condition|)
call|(
modifier|*
name|readline_begin_hook
call|)
argument_list|(
literal|"%s  %s\n"
argument_list|,
name|tmpbuf
argument_list|,
name|end_msg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|input_from_terminal_p
argument_list|()
condition|)
name|printf_filtered
argument_list|(
literal|"%s\n%s\n"
argument_list|,
name|tmpbuf
argument_list|,
name|end_msg
argument_list|)
expr_stmt|;
block|}
name|free_actions
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|->
name|step_count
operator|=
literal|0
expr_stmt|;
comment|/* read_actions may set this */
name|read_actions
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|readline_end_hook
condition|)
call|(
modifier|*
name|readline_end_hook
call|)
argument_list|()
expr_stmt|;
comment|/* tracepoints_changed () */
block|}
comment|/* else error, just return; */
block|}
end_function

begin_comment
comment|/* worker function */
end_comment

begin_function
specifier|static
name|void
name|read_actions
parameter_list|(
name|t
parameter_list|)
name|struct
name|tracepoint
modifier|*
name|t
decl_stmt|;
block|{
name|char
modifier|*
name|line
decl_stmt|;
name|char
modifier|*
name|prompt1
init|=
literal|"> "
decl_stmt|,
modifier|*
name|prompt2
init|=
literal|"> "
decl_stmt|;
name|char
modifier|*
name|prompt
init|=
name|prompt1
decl_stmt|;
name|enum
name|actionline_type
name|linetype
decl_stmt|;
specifier|extern
name|FILE
modifier|*
name|instream
decl_stmt|;
name|struct
name|action_line
modifier|*
name|next
init|=
name|NULL
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
comment|/* Control-C quits instantly if typed while in this loop      since it should not wait until the user types a newline.  */
name|immediate_quit
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|STOP_SIGNAL
if|if
condition|(
name|job_control
condition|)
name|signal
argument_list|(
name|STOP_SIGNAL
argument_list|,
name|stop_sig
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|old_chain
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_actions
argument_list|,
operator|(
name|void
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Make sure that all output has been output.  Some machines may let 	 you get away with leaving out some of the gdb_flush, but not all.  */
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|readline_hook
operator|&&
name|instream
operator|==
name|NULL
condition|)
name|line
operator|=
call|(
modifier|*
name|readline_hook
call|)
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|instream
operator|==
name|stdin
operator|&&
name|ISATTY
argument_list|(
name|instream
argument_list|)
condition|)
block|{
name|line
operator|=
name|readline
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|&&
operator|*
name|line
condition|)
comment|/* add it to command history */
name|add_history
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
else|else
name|line
operator|=
name|gdb_readline
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|linetype
operator|=
name|validate_actionline
argument_list|(
operator|&
name|line
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|linetype
operator|==
name|BADLINE
condition|)
continue|continue;
comment|/* already warned -- collect another line */
name|temp
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|action_line
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|temp
operator|->
name|action
operator|=
name|line
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
comment|/* first action for this tracepoint? */
name|t
operator|->
name|actions
operator|=
name|next
operator|=
name|temp
expr_stmt|;
else|else
block|{
name|next
operator|->
name|next
operator|=
name|temp
expr_stmt|;
name|next
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
name|linetype
operator|==
name|STEPPING
condition|)
comment|/* begin "while-stepping" */
if|if
condition|(
name|prompt
operator|==
name|prompt2
condition|)
block|{
name|warning
argument_list|(
literal|"Already processing 'while-stepping'"
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
name|prompt
operator|=
name|prompt2
expr_stmt|;
comment|/* change prompt for stepping actions */
elseif|else
if|if
condition|(
name|linetype
operator|==
name|END
condition|)
if|if
condition|(
name|prompt
operator|==
name|prompt2
condition|)
block|{
name|prompt
operator|=
name|prompt1
expr_stmt|;
comment|/* end of single-stepping actions */
block|}
else|else
block|{
comment|/* end of actions */
if|if
condition|(
name|t
operator|->
name|actions
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
comment|/* an "end" all by itself with no other actions means 		   this tracepoint has no actions.  Discard empty list. */
name|free_actions
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|STOP_SIGNAL
if|if
condition|(
name|job_control
condition|)
name|signal
argument_list|(
name|STOP_SIGNAL
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|immediate_quit
operator|=
literal|0
expr_stmt|;
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* worker function */
end_comment

begin_function
name|enum
name|actionline_type
name|validate_actionline
parameter_list|(
name|line
parameter_list|,
name|t
parameter_list|)
name|char
modifier|*
modifier|*
name|line
decl_stmt|;
name|struct
name|tracepoint
modifier|*
name|t
decl_stmt|;
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|struct
name|expression
modifier|*
name|exp
init|=
name|NULL
decl_stmt|;
name|value_ptr
name|temp
decl_stmt|,
name|temp2
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|line
init|;
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
control|)
name|p
operator|++
expr_stmt|;
comment|/* symbol lookup etc. */
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
comment|/* empty line: just prompt for another line. */
return|return
name|BADLINE
return|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'#'
condition|)
comment|/* comment line */
return|return
name|GENERIC
return|;
name|c
operator|=
name|lookup_cmd
argument_list|(
operator|&
name|p
argument_list|,
name|cmdlist
argument_list|,
literal|""
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"'%s' is not an action that I know, or is ambiguous."
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|BADLINE
return|;
block|}
if|if
condition|(
name|c
operator|->
name|function
operator|.
name|cfunc
operator|==
name|collect_pseudocommand
condition|)
block|{
name|struct
name|agent_expr
modifier|*
name|aexpr
decl_stmt|;
name|struct
name|agent_reqs
name|areqs
decl_stmt|;
do|do
block|{
comment|/* repeat over a comma-separated list */
name|QUIT
expr_stmt|;
comment|/* allow user to bail out with ^C */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'$'
condition|)
comment|/* look for special pseudo-symbols */
block|{
name|long
name|typecode
decl_stmt|,
name|size
decl_stmt|;
name|bfd_signed_vma
name|offset
decl_stmt|;
if|if
condition|(
operator|(
literal|0
operator|==
name|strncasecmp
argument_list|(
literal|"reg"
argument_list|,
name|p
operator|+
literal|1
argument_list|,
literal|3
argument_list|)
operator|)
operator|||
operator|(
literal|0
operator|==
name|strncasecmp
argument_list|(
literal|"arg"
argument_list|,
name|p
operator|+
literal|1
argument_list|,
literal|3
argument_list|)
operator|)
operator|||
operator|(
literal|0
operator|==
name|strncasecmp
argument_list|(
literal|"loc"
argument_list|,
name|p
operator|+
literal|1
argument_list|,
literal|3
argument_list|)
operator|)
condition|)
block|{
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|','
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* else fall thru, treat p as an expression and parse it! */
block|}
name|exp
operator|=
name|parse_exp_1
argument_list|(
operator|&
name|p
argument_list|,
name|block_for_pc
argument_list|(
name|t
operator|->
name|address
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_current_contents
argument_list|,
operator|&
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|elts
index|[
literal|0
index|]
operator|.
name|opcode
operator|==
name|OP_VAR_VALUE
condition|)
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|exp
operator|->
name|elts
index|[
literal|2
index|]
operator|.
name|symbol
argument_list|)
operator|==
name|LOC_CONST
condition|)
block|{
name|warning
argument_list|(
literal|"%s is constant (value %d): will not be collected."
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|exp
operator|->
name|elts
index|[
literal|2
index|]
operator|.
name|symbol
argument_list|)
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|exp
operator|->
name|elts
index|[
literal|2
index|]
operator|.
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|BADLINE
return|;
block|}
elseif|else
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|exp
operator|->
name|elts
index|[
literal|2
index|]
operator|.
name|symbol
argument_list|)
operator|==
name|LOC_OPTIMIZED_OUT
condition|)
block|{
name|warning
argument_list|(
literal|"%s is optimized away and cannot be collected."
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|exp
operator|->
name|elts
index|[
literal|2
index|]
operator|.
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|BADLINE
return|;
block|}
comment|/* we have something to collect, make sure that the expr to 	   bytecode translator can handle it and that it's not too long */
name|aexpr
operator|=
name|gen_trace_for_expr
argument_list|(
name|t
operator|->
name|address
argument_list|,
name|exp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_agent_expr
argument_list|,
name|aexpr
argument_list|)
expr_stmt|;
if|if
condition|(
name|aexpr
operator|->
name|len
operator|>
name|MAX_AGENT_EXPR_LEN
condition|)
name|error
argument_list|(
literal|"expression too complicated, try simplifying"
argument_list|)
expr_stmt|;
name|ax_reqs
argument_list|(
name|aexpr
argument_list|,
operator|&
name|areqs
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|areqs
operator|.
name|reg_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|areqs
operator|.
name|flaw
operator|!=
name|agent_flaw_none
condition|)
name|error
argument_list|(
literal|"malformed expression"
argument_list|)
expr_stmt|;
if|if
condition|(
name|areqs
operator|.
name|min_height
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"gdb: Internal error: expression has min height< 0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|areqs
operator|.
name|max_height
operator|>
literal|20
condition|)
name|error
argument_list|(
literal|"expression too complicated, try simplifying"
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|&&
operator|*
name|p
operator|++
operator|==
literal|','
condition|)
do|;
return|return
name|GENERIC
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|function
operator|.
name|cfunc
operator|==
name|while_stepping_pseudocommand
condition|)
block|{
name|char
modifier|*
name|steparg
decl_stmt|;
comment|/* in case warning is necessary */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
name|steparg
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
operator|||
operator|(
name|t
operator|->
name|step_count
operator|=
name|strtol
argument_list|(
name|p
argument_list|,
operator|&
name|p
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"bad step-count: command ignored."
argument_list|,
operator|*
name|line
argument_list|)
expr_stmt|;
return|return
name|BADLINE
return|;
block|}
return|return
name|STEPPING
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|function
operator|.
name|cfunc
operator|==
name|end_actions_pseudocommand
condition|)
return|return
name|END
return|;
else|else
block|{
name|warning
argument_list|(
literal|"'%s' is not a supported tracepoint action."
argument_list|,
operator|*
name|line
argument_list|)
expr_stmt|;
return|return
name|BADLINE
return|;
block|}
block|}
end_function

begin_comment
comment|/* worker function */
end_comment

begin_function
name|void
name|free_actions
parameter_list|(
name|t
parameter_list|)
name|struct
name|tracepoint
modifier|*
name|t
decl_stmt|;
block|{
name|struct
name|action_line
modifier|*
name|line
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|line
operator|=
name|t
operator|->
name|actions
init|;
name|line
condition|;
name|line
operator|=
name|next
control|)
block|{
name|next
operator|=
name|line
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|line
operator|->
name|action
condition|)
name|free
argument_list|(
name|line
operator|->
name|action
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
name|t
operator|->
name|actions
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|memrange
block|{
name|int
name|type
decl_stmt|;
comment|/* 0 for absolute memory range, else basereg number */
name|bfd_signed_vma
name|start
decl_stmt|;
name|bfd_signed_vma
name|end
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|collection_list
block|{
name|unsigned
name|char
name|regs_mask
index|[
literal|8
index|]
decl_stmt|;
comment|/* room for up to 256 regs */
name|long
name|listsize
decl_stmt|;
name|long
name|next_memrange
decl_stmt|;
name|struct
name|memrange
modifier|*
name|list
decl_stmt|;
name|long
name|aexpr_listsize
decl_stmt|;
comment|/* size of array pointed to by expr_list elt */
name|long
name|next_aexpr_elt
decl_stmt|;
name|struct
name|agent_expr
modifier|*
modifier|*
name|aexpr_list
decl_stmt|;
block|}
name|tracepoint_list
struct|,
name|stepping_list
struct|;
end_struct

begin_comment
comment|/* MEMRANGE functions: */
end_comment

begin_decl_stmt
specifier|static
name|int
name|memrange_cmp
name|PARAMS
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
specifier|const
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* compare memranges for qsort */
end_comment

begin_function
specifier|static
name|int
name|memrange_cmp
parameter_list|(
name|va
parameter_list|,
name|vb
parameter_list|)
specifier|const
name|void
modifier|*
name|va
decl_stmt|;
specifier|const
name|void
modifier|*
name|vb
decl_stmt|;
block|{
specifier|const
name|struct
name|memrange
modifier|*
name|a
init|=
name|va
decl_stmt|,
modifier|*
name|b
init|=
name|vb
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|type
operator|<
name|b
operator|->
name|type
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|a
operator|->
name|type
operator|>
name|b
operator|->
name|type
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|a
operator|->
name|type
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|bfd_vma
operator|)
name|a
operator|->
name|start
operator|<
operator|(
name|bfd_vma
operator|)
name|b
operator|->
name|start
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
name|bfd_vma
operator|)
name|a
operator|->
name|start
operator|>
operator|(
name|bfd_vma
operator|)
name|b
operator|->
name|start
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
if|if
condition|(
name|a
operator|->
name|start
operator|<
name|b
operator|->
name|start
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|a
operator|->
name|start
operator|>
name|b
operator|->
name|start
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Sort the memrange list using qsort, and merge adjacent memranges */
end_comment

begin_function
specifier|static
name|void
name|memrange_sortmerge
parameter_list|(
name|memranges
parameter_list|)
name|struct
name|collection_list
modifier|*
name|memranges
decl_stmt|;
block|{
name|int
name|a
decl_stmt|,
name|b
decl_stmt|;
name|qsort
argument_list|(
name|memranges
operator|->
name|list
argument_list|,
name|memranges
operator|->
name|next_memrange
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|memrange
argument_list|)
argument_list|,
name|memrange_cmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|memranges
operator|->
name|next_memrange
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|a
operator|=
literal|0
operator|,
name|b
operator|=
literal|1
init|;
name|b
operator|<
name|memranges
operator|->
name|next_memrange
condition|;
name|b
operator|++
control|)
block|{
if|if
condition|(
name|memranges
operator|->
name|list
index|[
name|a
index|]
operator|.
name|type
operator|==
name|memranges
operator|->
name|list
index|[
name|b
index|]
operator|.
name|type
operator|&&
name|memranges
operator|->
name|list
index|[
name|b
index|]
operator|.
name|start
operator|-
name|memranges
operator|->
name|list
index|[
name|a
index|]
operator|.
name|end
operator|<=
name|MAX_REGISTER_VIRTUAL_SIZE
condition|)
block|{
comment|/* memrange b starts before memrange a ends; merge them.  */
if|if
condition|(
name|memranges
operator|->
name|list
index|[
name|b
index|]
operator|.
name|end
operator|>
name|memranges
operator|->
name|list
index|[
name|a
index|]
operator|.
name|end
condition|)
name|memranges
operator|->
name|list
index|[
name|a
index|]
operator|.
name|end
operator|=
name|memranges
operator|->
name|list
index|[
name|b
index|]
operator|.
name|end
expr_stmt|;
continue|continue;
comment|/* next b, same a */
block|}
name|a
operator|++
expr_stmt|;
comment|/* next a */
if|if
condition|(
name|a
operator|!=
name|b
condition|)
name|memcpy
argument_list|(
operator|&
name|memranges
operator|->
name|list
index|[
name|a
index|]
argument_list|,
operator|&
name|memranges
operator|->
name|list
index|[
name|b
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|memrange
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|memranges
operator|->
name|next_memrange
operator|=
name|a
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add a register to a collection list */
end_comment

begin_function
name|void
name|add_register
parameter_list|(
name|collection
parameter_list|,
name|regno
parameter_list|)
name|struct
name|collection_list
modifier|*
name|collection
decl_stmt|;
name|unsigned
name|long
name|regno
decl_stmt|;
block|{
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"collect register %d\n"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|collection
operator|->
name|regs_mask
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"Internal: register number %d too large for tracepoint"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|collection
operator|->
name|regs_mask
index|[
name|regno
operator|/
literal|8
index|]
operator||=
literal|1
operator|<<
operator|(
name|regno
operator|%
literal|8
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a memrange to a collection list */
end_comment

begin_function
specifier|static
name|void
name|add_memrange
parameter_list|(
name|memranges
parameter_list|,
name|type
parameter_list|,
name|base
parameter_list|,
name|len
parameter_list|)
name|struct
name|collection_list
modifier|*
name|memranges
decl_stmt|;
name|int
name|type
decl_stmt|;
name|bfd_signed_vma
name|base
decl_stmt|;
name|unsigned
name|long
name|len
decl_stmt|;
block|{
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"(%d,0x%x,%d)\n"
argument_list|,
name|type
argument_list|,
name|base
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* type: 0 == memory, n == basereg */
name|memranges
operator|->
name|list
index|[
name|memranges
operator|->
name|next_memrange
index|]
operator|.
name|type
operator|=
name|type
expr_stmt|;
comment|/* base: addr if memory, offset if reg relative. */
name|memranges
operator|->
name|list
index|[
name|memranges
operator|->
name|next_memrange
index|]
operator|.
name|start
operator|=
name|base
expr_stmt|;
comment|/* len: we actually save end (base + len) for convenience */
name|memranges
operator|->
name|list
index|[
name|memranges
operator|->
name|next_memrange
index|]
operator|.
name|end
operator|=
name|base
operator|+
name|len
expr_stmt|;
name|memranges
operator|->
name|next_memrange
operator|++
expr_stmt|;
if|if
condition|(
name|memranges
operator|->
name|next_memrange
operator|>=
name|memranges
operator|->
name|listsize
condition|)
block|{
name|memranges
operator|->
name|listsize
operator|*=
literal|2
expr_stmt|;
name|memranges
operator|->
name|list
operator|=
name|xrealloc
argument_list|(
name|memranges
operator|->
name|list
argument_list|,
name|memranges
operator|->
name|listsize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|!=
operator|-
literal|1
condition|)
comment|/* better collect the base register! */
name|add_register
argument_list|(
name|memranges
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a symbol to a collection list */
end_comment

begin_function
specifier|static
name|void
name|collect_symbol
parameter_list|(
name|collect
parameter_list|,
name|sym
parameter_list|,
name|frame_regno
parameter_list|,
name|frame_offset
parameter_list|)
name|struct
name|collection_list
modifier|*
name|collect
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|long
name|frame_regno
decl_stmt|;
name|long
name|frame_offset
decl_stmt|;
block|{
name|unsigned
name|long
name|len
decl_stmt|;
name|unsigned
name|long
name|reg
decl_stmt|;
name|bfd_signed_vma
name|offset
decl_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|check_typedef
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
condition|)
block|{
default|default:
name|printf_filtered
argument_list|(
literal|"%s: don't know symbol class %d\n"
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_CONST
case|:
name|printf_filtered
argument_list|(
literal|"%s is constant, value is %d: will not be collected.\n"
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_STATIC
case|:
name|offset
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"LOC_STATIC %s: collect %d bytes at 0x%08x\n"
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|len
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|add_memrange
argument_list|(
name|collect
argument_list|,
operator|-
literal|1
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* 0 == memory */
break|break;
case|case
name|LOC_REGISTER
case|:
case|case
name|LOC_REGPARM
case|:
name|reg
operator|=
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"LOC_REG[parm] %s: "
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|add_register
argument_list|(
name|collect
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* check for doubles stored in two registers */
comment|/* FIXME: how about larger types stored in 3 or more regs? */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_FLT
operator|&&
name|len
operator|>
name|REGISTER_RAW_SIZE
argument_list|(
name|reg
argument_list|)
condition|)
name|add_register
argument_list|(
name|collect
argument_list|,
name|reg
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_REF_ARG
case|:
name|printf_filtered
argument_list|(
literal|"Sorry, don't know how to do LOC_REF_ARG yet.\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"       (will not collect %s)\n"
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_ARG
case|:
name|reg
operator|=
name|frame_regno
expr_stmt|;
name|offset
operator|=
name|frame_offset
operator|+
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_verbose
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"LOC_LOCAL %s: Collect %d bytes at offset"
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" %d from frame ptr reg %d\n"
argument_list|,
name|offset
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
name|add_memrange
argument_list|(
name|collect
argument_list|,
name|reg
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_REGPARM_ADDR
case|:
name|reg
operator|=
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|info_verbose
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"LOC_REGPARM_ADDR %s: Collect %d bytes at offset"
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" %d from reg %d\n"
argument_list|,
name|offset
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
name|add_memrange
argument_list|(
name|collect
argument_list|,
name|reg
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_LOCAL
case|:
case|case
name|LOC_LOCAL_ARG
case|:
name|reg
operator|=
name|frame_regno
expr_stmt|;
name|offset
operator|=
name|frame_offset
operator|+
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_verbose
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"LOC_LOCAL %s: Collect %d bytes at offset"
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" %d from frame ptr reg %d\n"
argument_list|,
name|offset
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
name|add_memrange
argument_list|(
name|collect
argument_list|,
name|reg
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_BASEREG
case|:
case|case
name|LOC_BASEREG_ARG
case|:
name|reg
operator|=
name|SYMBOL_BASEREG
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|offset
operator|=
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_verbose
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"LOC_BASEREG %s: collect %d bytes at offset %d from basereg %d\n"
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|len
argument_list|,
name|offset
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
name|add_memrange
argument_list|(
name|collect
argument_list|,
name|reg
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_UNRESOLVED
case|:
name|printf_filtered
argument_list|(
literal|"Don't know LOC_UNRESOLVED %s\n"
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_OPTIMIZED_OUT
case|:
name|printf_filtered
argument_list|(
literal|"%s has been optimized out of existance.\n"
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Add all locals (or args) symbols to collection list */
end_comment

begin_function
specifier|static
name|void
name|add_local_symbols
parameter_list|(
name|collect
parameter_list|,
name|pc
parameter_list|,
name|frame_regno
parameter_list|,
name|frame_offset
parameter_list|,
name|type
parameter_list|)
name|struct
name|collection_list
modifier|*
name|collect
decl_stmt|;
name|CORE_ADDR
name|pc
decl_stmt|;
name|long
name|frame_regno
decl_stmt|;
name|long
name|frame_offset
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|block
modifier|*
name|block
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nsyms
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
name|block
operator|=
name|block_for_pc
argument_list|(
name|pc
argument_list|)
expr_stmt|;
while|while
condition|(
name|block
operator|!=
literal|0
condition|)
block|{
name|QUIT
expr_stmt|;
comment|/* allow user to bail out with ^C */
name|nsyms
operator|=
name|BLOCK_NSYMS
argument_list|(
name|block
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|block
argument_list|,
name|i
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
condition|)
block|{
case|case
name|LOC_LOCAL
case|:
case|case
name|LOC_STATIC
case|:
case|case
name|LOC_REGISTER
case|:
case|case
name|LOC_BASEREG
case|:
if|if
condition|(
name|type
operator|==
literal|'L'
condition|)
comment|/* collecting Locals */
block|{
name|count
operator|++
expr_stmt|;
name|collect_symbol
argument_list|(
name|collect
argument_list|,
name|sym
argument_list|,
name|frame_regno
argument_list|,
name|frame_offset
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LOC_ARG
case|:
case|case
name|LOC_LOCAL_ARG
case|:
case|case
name|LOC_REF_ARG
case|:
case|case
name|LOC_REGPARM
case|:
case|case
name|LOC_REGPARM_ADDR
case|:
case|case
name|LOC_BASEREG_ARG
case|:
if|if
condition|(
name|type
operator|==
literal|'A'
condition|)
comment|/* collecting Arguments */
block|{
name|count
operator|++
expr_stmt|;
name|collect_symbol
argument_list|(
name|collect
argument_list|,
name|sym
argument_list|,
name|frame_regno
argument_list|,
name|frame_offset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|BLOCK_FUNCTION
argument_list|(
name|block
argument_list|)
condition|)
break|break;
else|else
name|block
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"No %s found in scope."
argument_list|,
name|type
operator|==
literal|'L'
condition|?
literal|"locals"
else|:
literal|"args"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* worker function */
end_comment

begin_function
specifier|static
name|void
name|clear_collection_list
parameter_list|(
name|list
parameter_list|)
name|struct
name|collection_list
modifier|*
name|list
decl_stmt|;
block|{
name|int
name|ndx
decl_stmt|;
name|list
operator|->
name|next_memrange
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ndx
operator|=
literal|0
init|;
name|ndx
operator|<
name|list
operator|->
name|next_aexpr_elt
condition|;
name|ndx
operator|++
control|)
block|{
name|free_agent_expr
argument_list|(
name|list
operator|->
name|aexpr_list
index|[
name|ndx
index|]
argument_list|)
expr_stmt|;
name|list
operator|->
name|aexpr_list
index|[
name|ndx
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|list
operator|->
name|next_aexpr_elt
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|list
operator|->
name|regs_mask
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|list
operator|->
name|regs_mask
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* reduce a collection list to string form (for gdb protocol) */
end_comment

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|stringify_collection_list
parameter_list|(
name|list
parameter_list|,
name|string
parameter_list|)
name|struct
name|collection_list
modifier|*
name|list
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|char
name|temp_buf
index|[
literal|2048
index|]
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|ndx
init|=
literal|0
decl_stmt|;
name|char
argument_list|*
operator|(
operator|*
name|str_list
operator|)
index|[]
argument_list|;
name|char
operator|*
name|end
argument_list|;
name|long
name|i
argument_list|;
name|count
operator|=
literal|1
operator|+
name|list
operator|->
name|next_memrange
operator|+
name|list
operator|->
name|next_aexpr_elt
operator|+
literal|1
argument_list|;
name|str_list
operator|=
operator|(
name|char
operator|*
operator|(
operator|*
operator|)
index|[]
operator|)
name|xmalloc
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
argument_list|;    for
operator|(
name|i
operator|=
sizeof|sizeof
argument_list|(
name|list
operator|->
name|regs_mask
argument_list|)
operator|-
literal|1
expr|;
name|i
operator|>
literal|0
expr|;
name|i
operator|--
operator|)
if|if
condition|(
name|list
operator|->
name|regs_mask
index|[
name|i
index|]
operator|!=
literal|0
condition|)
comment|/* skip leading zeroes in regs_mask */
break|break;
if|if
condition|(
name|list
operator|->
name|regs_mask
index|[
name|i
index|]
operator|!=
literal|0
condition|)
comment|/* prepare to send regs_mask to the stub */
block|{
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"\nCollecting registers (mask): 0x"
argument_list|)
expr_stmt|;
name|end
operator|=
name|temp_buf
expr_stmt|;
operator|*
name|end
operator|++
operator|=
literal|'R'
expr_stmt|;
for|for
control|(
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|QUIT
expr_stmt|;
comment|/* allow user to bail out with ^C */
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"%02X"
argument_list|,
name|list
operator|->
name|regs_mask
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|end
argument_list|,
literal|"%02X"
argument_list|,
name|list
operator|->
name|regs_mask
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|end
operator|+=
literal|2
expr_stmt|;
block|}
operator|(
operator|*
name|str_list
operator|)
index|[
name|ndx
index|]
operator|=
name|savestring
argument_list|(
name|temp_buf
argument_list|,
name|end
operator|-
name|temp_buf
argument_list|)
expr_stmt|;
name|ndx
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|->
name|next_memrange
operator|>
literal|0
operator|&&
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"Collecting memranges: \n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|count
operator|=
literal|0
operator|,
name|end
operator|=
name|temp_buf
init|;
name|i
operator|<
name|list
operator|->
name|next_memrange
condition|;
name|i
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
comment|/* allow user to bail out with ^C */
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"(%d, 0x%x, %d)\n"
argument_list|,
name|list
operator|->
name|list
index|[
name|i
index|]
operator|.
name|type
argument_list|,
name|list
operator|->
name|list
index|[
name|i
index|]
operator|.
name|start
argument_list|,
name|list
operator|->
name|list
index|[
name|i
index|]
operator|.
name|end
operator|-
name|list
operator|->
name|list
index|[
name|i
index|]
operator|.
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|+
literal|27
operator|>
name|MAX_AGENT_EXPR_LEN
condition|)
block|{
operator|(
operator|*
name|str_list
operator|)
index|[
name|ndx
index|]
operator|=
name|savestring
argument_list|(
name|temp_buf
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|ndx
operator|++
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|end
operator|=
name|temp_buf
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|end
argument_list|,
literal|"M%X,%X,%X"
argument_list|,
name|list
operator|->
name|list
index|[
name|i
index|]
operator|.
name|type
argument_list|,
name|list
operator|->
name|list
index|[
name|i
index|]
operator|.
name|start
argument_list|,
name|list
operator|->
name|list
index|[
name|i
index|]
operator|.
name|end
operator|-
name|list
operator|->
name|list
index|[
name|i
index|]
operator|.
name|start
argument_list|)
expr_stmt|;
name|count
operator|+=
name|strlen
argument_list|(
name|end
argument_list|)
expr_stmt|;
name|end
operator|+=
name|strlen
argument_list|(
name|end
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list
operator|->
name|next_aexpr_elt
condition|;
name|i
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
comment|/* allow user to bail out with ^C */
if|if
condition|(
operator|(
name|count
operator|+
literal|10
operator|+
literal|2
operator|*
name|list
operator|->
name|aexpr_list
index|[
name|i
index|]
operator|->
name|len
operator|)
operator|>
name|MAX_AGENT_EXPR_LEN
condition|)
block|{
operator|(
operator|*
name|str_list
operator|)
index|[
name|ndx
index|]
operator|=
name|savestring
argument_list|(
name|temp_buf
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|ndx
operator|++
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|end
operator|=
name|temp_buf
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|end
argument_list|,
literal|"X%08X,"
argument_list|,
name|list
operator|->
name|aexpr_list
index|[
name|i
index|]
operator|->
name|len
argument_list|)
expr_stmt|;
name|end
operator|+=
literal|10
expr_stmt|;
comment|/* 'X' + 8 hex digits + ',' */
name|count
operator|+=
literal|10
expr_stmt|;
name|end
operator|=
name|mem2hex
argument_list|(
name|list
operator|->
name|aexpr_list
index|[
name|i
index|]
operator|->
name|buf
argument_list|,
name|end
argument_list|,
name|list
operator|->
name|aexpr_list
index|[
name|i
index|]
operator|->
name|len
argument_list|)
expr_stmt|;
name|count
operator|+=
literal|2
operator|*
name|list
operator|->
name|aexpr_list
index|[
name|i
index|]
operator|->
name|len
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
operator|(
operator|*
name|str_list
operator|)
index|[
name|ndx
index|]
operator|=
name|savestring
argument_list|(
name|temp_buf
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|ndx
operator|++
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|end
operator|=
name|temp_buf
expr_stmt|;
block|}
operator|(
operator|*
name|str_list
operator|)
index|[
name|ndx
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ndx
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
else|else
return|return
operator|*
name|str_list
return|;
block|}
end_function

begin_function
name|void
name|free_actions_list
parameter_list|(
name|actions_list
parameter_list|)
name|char
modifier|*
modifier|*
name|actions_list
decl_stmt|;
block|{
name|int
name|ndx
decl_stmt|;
if|if
condition|(
name|actions_list
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|ndx
operator|=
literal|0
init|;
name|actions_list
index|[
name|ndx
index|]
condition|;
name|ndx
operator|++
control|)
name|free
argument_list|(
name|actions_list
index|[
name|ndx
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|actions_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* render all actions into gdb protocol */
end_comment

begin_function
specifier|static
name|void
name|encode_actions
parameter_list|(
name|t
parameter_list|,
name|tdp_actions
parameter_list|,
name|stepping_actions
parameter_list|)
name|struct
name|tracepoint
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|tdp_actions
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|stepping_actions
decl_stmt|;
block|{
specifier|static
name|char
name|tdp_buff
index|[
literal|2048
index|]
decl_stmt|,
name|step_buff
index|[
literal|2048
index|]
decl_stmt|;
name|char
modifier|*
name|action_exp
decl_stmt|;
name|struct
name|expression
modifier|*
name|exp
init|=
name|NULL
decl_stmt|;
name|struct
name|action_line
modifier|*
name|action
decl_stmt|;
name|bfd_signed_vma
name|offset
decl_stmt|;
name|long
name|i
decl_stmt|;
name|value_ptr
name|tempval
decl_stmt|;
name|struct
name|collection_list
modifier|*
name|collect
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|cmd
decl_stmt|;
name|struct
name|agent_expr
modifier|*
name|aexpr
decl_stmt|;
name|long
name|frame_reg
decl_stmt|,
name|frame_offset
decl_stmt|;
name|clear_collection_list
argument_list|(
operator|&
name|tracepoint_list
argument_list|)
expr_stmt|;
name|clear_collection_list
argument_list|(
operator|&
name|stepping_list
argument_list|)
expr_stmt|;
name|collect
operator|=
operator|&
name|tracepoint_list
expr_stmt|;
operator|*
name|tdp_actions
operator|=
name|NULL
expr_stmt|;
operator|*
name|stepping_actions
operator|=
name|NULL
expr_stmt|;
name|TARGET_VIRTUAL_FRAME_POINTER
argument_list|(
name|t
operator|->
name|address
argument_list|,
operator|&
name|frame_reg
argument_list|,
operator|&
name|frame_offset
argument_list|)
expr_stmt|;
for|for
control|(
name|action
operator|=
name|t
operator|->
name|actions
init|;
name|action
condition|;
name|action
operator|=
name|action
operator|->
name|next
control|)
block|{
name|QUIT
expr_stmt|;
comment|/* allow user to bail out with ^C */
name|action_exp
operator|=
name|action
operator|->
name|action
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|action_exp
argument_list|)
condition|)
name|action_exp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|action_exp
operator|==
literal|'#'
condition|)
comment|/* comment line */
return|return;
name|cmd
operator|=
name|lookup_cmd
argument_list|(
operator|&
name|action_exp
argument_list|,
name|cmdlist
argument_list|,
literal|""
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Bad action list item: %s"
argument_list|,
name|action_exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|function
operator|.
name|cfunc
operator|==
name|collect_pseudocommand
condition|)
block|{
do|do
block|{
comment|/* repeat over a comma-separated list */
name|QUIT
expr_stmt|;
comment|/* allow user to bail out with ^C */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|action_exp
argument_list|)
condition|)
name|action_exp
operator|++
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|strncasecmp
argument_list|(
literal|"$reg"
argument_list|,
name|action_exp
argument_list|,
literal|4
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
condition|;
name|i
operator|++
control|)
name|add_register
argument_list|(
name|collect
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|action_exp
operator|=
name|strchr
argument_list|(
name|action_exp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
comment|/* more? */
block|}
elseif|else
if|if
condition|(
literal|0
operator|==
name|strncasecmp
argument_list|(
literal|"$arg"
argument_list|,
name|action_exp
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|add_local_symbols
argument_list|(
name|collect
argument_list|,
name|t
operator|->
name|address
argument_list|,
name|frame_reg
argument_list|,
name|frame_offset
argument_list|,
literal|'A'
argument_list|)
expr_stmt|;
name|action_exp
operator|=
name|strchr
argument_list|(
name|action_exp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
comment|/* more? */
block|}
elseif|else
if|if
condition|(
literal|0
operator|==
name|strncasecmp
argument_list|(
literal|"$loc"
argument_list|,
name|action_exp
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|add_local_symbols
argument_list|(
name|collect
argument_list|,
name|t
operator|->
name|address
argument_list|,
name|frame_reg
argument_list|,
name|frame_offset
argument_list|,
literal|'L'
argument_list|)
expr_stmt|;
name|action_exp
operator|=
name|strchr
argument_list|(
name|action_exp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
comment|/* more? */
block|}
else|else
block|{
name|unsigned
name|long
name|addr
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|NULL
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain1
init|=
name|NULL
decl_stmt|;
name|struct
name|agent_reqs
name|areqs
decl_stmt|;
name|exp
operator|=
name|parse_exp_1
argument_list|(
operator|&
name|action_exp
argument_list|,
name|block_for_pc
argument_list|(
name|t
operator|->
name|address
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_current_contents
argument_list|,
operator|&
name|exp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|exp
operator|->
name|elts
index|[
literal|0
index|]
operator|.
name|opcode
condition|)
block|{
case|case
name|OP_REGISTER
case|:
name|i
operator|=
name|exp
operator|->
name|elts
index|[
literal|1
index|]
operator|.
name|longconst
expr_stmt|;
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"OP_REGISTER: "
argument_list|)
expr_stmt|;
name|add_register
argument_list|(
name|collect
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|UNOP_MEMVAL
case|:
comment|/* safe because we know it's a simple expression */
name|tempval
operator|=
name|evaluate_expression
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|addr
operator|=
name|VALUE_ADDRESS
argument_list|(
name|tempval
argument_list|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|tempval
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|check_typedef
argument_list|(
name|exp
operator|->
name|elts
index|[
literal|1
index|]
operator|.
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|add_memrange
argument_list|(
name|collect
argument_list|,
operator|-
literal|1
argument_list|,
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_VAR_VALUE
case|:
name|collect_symbol
argument_list|(
name|collect
argument_list|,
name|exp
operator|->
name|elts
index|[
literal|2
index|]
operator|.
name|symbol
argument_list|,
name|frame_reg
argument_list|,
name|frame_offset
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* full-fledged expression */
name|aexpr
operator|=
name|gen_trace_for_expr
argument_list|(
name|t
operator|->
name|address
argument_list|,
name|exp
argument_list|)
expr_stmt|;
name|old_chain1
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_agent_expr
argument_list|,
name|aexpr
argument_list|)
expr_stmt|;
name|ax_reqs
argument_list|(
name|aexpr
argument_list|,
operator|&
name|areqs
argument_list|)
expr_stmt|;
if|if
condition|(
name|areqs
operator|.
name|flaw
operator|!=
name|agent_flaw_none
condition|)
name|error
argument_list|(
literal|"malformed expression"
argument_list|)
expr_stmt|;
if|if
condition|(
name|areqs
operator|.
name|min_height
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"gdb: Internal error: expression has min height< 0"
argument_list|)
expr_stmt|;
if|if
condition|(
name|areqs
operator|.
name|max_height
operator|>
literal|20
condition|)
name|error
argument_list|(
literal|"expression too complicated, try simplifying"
argument_list|)
expr_stmt|;
name|discard_cleanups
argument_list|(
name|old_chain1
argument_list|)
expr_stmt|;
name|add_aexpr
argument_list|(
name|collect
argument_list|,
name|aexpr
argument_list|)
expr_stmt|;
comment|/* take care of the registers */
if|if
condition|(
name|areqs
operator|.
name|reg_mask_len
operator|>
literal|0
condition|)
block|{
name|int
name|ndx1
decl_stmt|;
name|int
name|ndx2
decl_stmt|;
for|for
control|(
name|ndx1
operator|=
literal|0
init|;
name|ndx1
operator|<
name|areqs
operator|.
name|reg_mask_len
condition|;
name|ndx1
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
comment|/* allow user to bail out with ^C */
if|if
condition|(
name|areqs
operator|.
name|reg_mask
index|[
name|ndx1
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* assume chars have 8 bits */
for|for
control|(
name|ndx2
operator|=
literal|0
init|;
name|ndx2
operator|<
literal|8
condition|;
name|ndx2
operator|++
control|)
if|if
condition|(
name|areqs
operator|.
name|reg_mask
index|[
name|ndx1
index|]
operator|&
operator|(
literal|1
operator|<<
name|ndx2
operator|)
condition|)
comment|/* it's used -- record it */
name|add_register
argument_list|(
name|collect
argument_list|,
name|ndx1
operator|*
literal|8
operator|+
name|ndx2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
comment|/* switch */
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
comment|/* do */
block|}
do|while
condition|(
name|action_exp
operator|&&
operator|*
name|action_exp
operator|++
operator|==
literal|','
condition|)
do|;
block|}
comment|/* if */
elseif|else
if|if
condition|(
name|cmd
operator|->
name|function
operator|.
name|cfunc
operator|==
name|while_stepping_pseudocommand
condition|)
block|{
name|collect
operator|=
operator|&
name|stepping_list
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|->
name|function
operator|.
name|cfunc
operator|==
name|end_actions_pseudocommand
condition|)
block|{
if|if
condition|(
name|collect
operator|==
operator|&
name|stepping_list
condition|)
comment|/* end stepping actions */
name|collect
operator|=
operator|&
name|tracepoint_list
expr_stmt|;
else|else
break|break;
comment|/* end tracepoint actions */
block|}
block|}
comment|/* for */
name|memrange_sortmerge
argument_list|(
operator|&
name|tracepoint_list
argument_list|)
expr_stmt|;
name|memrange_sortmerge
argument_list|(
operator|&
name|stepping_list
argument_list|)
expr_stmt|;
operator|*
name|tdp_actions
operator|=
name|stringify_collection_list
argument_list|(
operator|&
name|tracepoint_list
argument_list|,
operator|&
name|tdp_buff
argument_list|)
expr_stmt|;
operator|*
name|stepping_actions
operator|=
name|stringify_collection_list
argument_list|(
operator|&
name|stepping_list
argument_list|,
operator|&
name|step_buff
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_aexpr
parameter_list|(
name|collect
parameter_list|,
name|aexpr
parameter_list|)
name|struct
name|collection_list
modifier|*
name|collect
decl_stmt|;
name|struct
name|agent_expr
modifier|*
name|aexpr
decl_stmt|;
block|{
if|if
condition|(
name|collect
operator|->
name|next_aexpr_elt
operator|>=
name|collect
operator|->
name|aexpr_listsize
condition|)
block|{
name|collect
operator|->
name|aexpr_list
operator|=
name|xrealloc
argument_list|(
name|collect
operator|->
name|aexpr_list
argument_list|,
literal|2
operator|*
name|collect
operator|->
name|aexpr_listsize
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|agent_expr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|collect
operator|->
name|aexpr_listsize
operator|*=
literal|2
expr_stmt|;
block|}
name|collect
operator|->
name|aexpr_list
index|[
name|collect
operator|->
name|next_aexpr_elt
index|]
operator|=
name|aexpr
expr_stmt|;
name|collect
operator|->
name|next_aexpr_elt
operator|++
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|target_buf
index|[
literal|2048
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set "transparent" memory ranges     Allow trace mechanism to treat text-like sections    (and perhaps all read-only sections) transparently,     i.e. don't reject memory requests from these address ranges    just because they haven't been collected.  */
end_comment

begin_function
specifier|static
name|void
name|remote_set_transparent_ranges
parameter_list|(
name|void
parameter_list|)
block|{
specifier|extern
name|bfd
modifier|*
name|exec_bfd
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|bfd_size_type
name|size
decl_stmt|;
name|bfd_vma
name|lma
decl_stmt|;
name|int
name|anysecs
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|exec_bfd
condition|)
return|return;
comment|/* no information to give. */
name|strcpy
argument_list|(
name|target_buf
argument_list|,
literal|"QTro"
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|exec_bfd
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
name|char
name|tmp
index|[
literal|40
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
operator|)
operator|==
literal|0
operator|||
comment|/* (s->flags& SEC_CODE)     == 0 || */
operator|(
name|s
operator|->
name|flags
operator|&
name|SEC_READONLY
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|anysecs
operator|=
literal|1
expr_stmt|;
name|lma
operator|=
name|s
operator|->
name|lma
expr_stmt|;
name|size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|":%x,%x"
argument_list|,
name|lma
argument_list|,
name|lma
operator|+
name|size
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|target_buf
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|anysecs
condition|)
block|{
name|putpkt
argument_list|(
name|target_buf
argument_list|)
expr_stmt|;
name|getpkt
argument_list|(
name|target_buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* tstart command:      Tell target to clear any previous trace experiment.    Walk the list of tracepoints, and send them (and their actions)    to the target.  If no errors,     Tell target to start a new trace experiment.  */
end_comment

begin_function
specifier|static
name|void
name|trace_start_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
comment|/* STUB_COMM MOSTLY_IMPLEMENTED */
name|struct
name|tracepoint
modifier|*
name|t
decl_stmt|;
name|char
name|buf
index|[
literal|2048
index|]
decl_stmt|;
name|char
modifier|*
modifier|*
name|tdp_actions
decl_stmt|;
name|char
modifier|*
modifier|*
name|stepping_actions
decl_stmt|;
name|int
name|ndx
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|NULL
decl_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
comment|/* like "run", dangerous to repeat accidentally */
if|if
condition|(
name|target_is_remote
argument_list|()
condition|)
block|{
name|putpkt
argument_list|(
literal|"QTinit"
argument_list|)
expr_stmt|;
name|remote_get_noisy_reply
argument_list|(
name|target_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|target_buf
argument_list|,
literal|"OK"
argument_list|)
condition|)
name|error
argument_list|(
literal|"Target does not support this command."
argument_list|)
expr_stmt|;
name|ALL_TRACEPOINTS
argument_list|(
argument|t
argument_list|)
block|{
name|int
name|ss_count
decl_stmt|;
comment|/* if actions include singlestepping */
name|int
name|disable_mask
decl_stmt|;
comment|/* ??? */
name|int
name|enable_mask
decl_stmt|;
comment|/* ??? */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"QTDP:%x:%x:%c:%x:%x"
argument_list|,
name|t
operator|->
name|number
argument_list|,
name|t
operator|->
name|address
argument_list|,
name|t
operator|->
name|enabled
operator|==
name|enabled
condition|?
literal|'E'
else|:
literal|'D'
argument_list|,
name|t
operator|->
name|step_count
argument_list|,
name|t
operator|->
name|pass_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|actions
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|remote_get_noisy_reply
argument_list|(
name|target_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|target_buf
argument_list|,
literal|"OK"
argument_list|)
condition|)
name|error
argument_list|(
literal|"Target does not support tracepoints."
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|actions
condition|)
block|{
name|encode_actions
argument_list|(
name|t
argument_list|,
operator|&
name|tdp_actions
argument_list|,
operator|&
name|stepping_actions
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free_actions_list
argument_list|,
name|tdp_actions
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|make_cleanup
argument_list|(
name|free_actions_list
argument_list|,
name|stepping_actions
argument_list|)
expr_stmt|;
comment|/* do_single_steps (t); */
if|if
condition|(
name|tdp_actions
condition|)
block|{
for|for
control|(
name|ndx
operator|=
literal|0
init|;
name|tdp_actions
index|[
name|ndx
index|]
condition|;
name|ndx
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
comment|/* allow user to bail out with ^C */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"QTDP:-%x:%x:%s%c"
argument_list|,
name|t
operator|->
name|number
argument_list|,
name|t
operator|->
name|address
argument_list|,
name|tdp_actions
index|[
name|ndx
index|]
argument_list|,
operator|(
operator|(
name|tdp_actions
index|[
name|ndx
operator|+
literal|1
index|]
operator|||
name|stepping_actions
operator|)
condition|?
literal|'-'
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|remote_get_noisy_reply
argument_list|(
name|target_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|target_buf
argument_list|,
literal|"OK"
argument_list|)
condition|)
name|error
argument_list|(
literal|"Error on target while setting tracepoints."
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stepping_actions
condition|)
block|{
for|for
control|(
name|ndx
operator|=
literal|0
init|;
name|stepping_actions
index|[
name|ndx
index|]
condition|;
name|ndx
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
comment|/* allow user to bail out with ^C */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"QTDP:-%x:%x:%s%s%s"
argument_list|,
name|t
operator|->
name|number
argument_list|,
name|t
operator|->
name|address
argument_list|,
operator|(
operator|(
name|ndx
operator|==
literal|0
operator|)
condition|?
literal|"S"
else|:
literal|""
operator|)
argument_list|,
name|stepping_actions
index|[
name|ndx
index|]
argument_list|,
operator|(
name|stepping_actions
index|[
name|ndx
operator|+
literal|1
index|]
condition|?
literal|"-"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|remote_get_noisy_reply
argument_list|(
name|target_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|target_buf
argument_list|,
literal|"OK"
argument_list|)
condition|)
name|error
argument_list|(
literal|"Error on target while setting tracepoints."
argument_list|)
expr_stmt|;
block|}
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Tell target to treat text-like sections as transparent */
name|remote_set_transparent_ranges
argument_list|()
expr_stmt|;
comment|/* Now insert traps and begin collecting data */
name|putpkt
argument_list|(
literal|"QTStart"
argument_list|)
expr_stmt|;
name|remote_get_noisy_reply
argument_list|(
name|target_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|target_buf
argument_list|,
literal|"OK"
argument_list|)
condition|)
name|error
argument_list|(
literal|"Bogus reply from target: %s"
argument_list|,
name|target_buf
argument_list|)
expr_stmt|;
name|set_traceframe_num
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* all old traceframes invalidated */
name|set_tracepoint_num
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|set_traceframe_context
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|trace_running_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|trace_start_stop_hook
condition|)
name|trace_start_stop_hook
argument_list|(
literal|1
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Trace can only be run on remote targets."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* tstop command */
end_comment

begin_function
specifier|static
name|void
name|trace_stop_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
comment|/* STUB_COMM IS_IMPLEMENTED */
if|if
condition|(
name|target_is_remote
argument_list|()
condition|)
block|{
name|putpkt
argument_list|(
literal|"QTStop"
argument_list|)
expr_stmt|;
name|remote_get_noisy_reply
argument_list|(
name|target_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|target_buf
argument_list|,
literal|"OK"
argument_list|)
condition|)
name|error
argument_list|(
literal|"Bogus reply from target: %s"
argument_list|,
name|target_buf
argument_list|)
expr_stmt|;
name|trace_running_p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|trace_start_stop_hook
condition|)
name|trace_start_stop_hook
argument_list|(
literal|0
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Trace can only be run on remote targets."
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|unsigned
name|long
name|trace_running_p
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tstatus command */
end_comment

begin_function
specifier|static
name|void
name|trace_status_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
comment|/* STUB_COMM IS_IMPLEMENTED */
if|if
condition|(
name|target_is_remote
argument_list|()
condition|)
block|{
name|putpkt
argument_list|(
literal|"qTStatus"
argument_list|)
expr_stmt|;
name|remote_get_noisy_reply
argument_list|(
name|target_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_buf
index|[
literal|0
index|]
operator|!=
literal|'T'
operator|||
operator|(
name|target_buf
index|[
literal|1
index|]
operator|!=
literal|'0'
operator|&&
name|target_buf
index|[
literal|1
index|]
operator|!=
literal|'1'
operator|)
condition|)
name|error
argument_list|(
literal|"Bogus reply from target: %s"
argument_list|,
name|target_buf
argument_list|)
expr_stmt|;
comment|/* exported for use by the GUI */
name|trace_running_p
operator|=
operator|(
name|target_buf
index|[
literal|1
index|]
operator|==
literal|'1'
operator|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Trace can only be run on remote targets."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Worker function for the various flavors of the tfind command */
end_comment

begin_function
specifier|static
name|void
name|finish_tfind_command
parameter_list|(
name|msg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|msg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|target_frameno
init|=
operator|-
literal|1
decl_stmt|,
name|target_tracept
init|=
operator|-
literal|1
decl_stmt|;
name|CORE_ADDR
name|old_frame_addr
decl_stmt|;
name|struct
name|symbol
modifier|*
name|old_func
decl_stmt|;
name|char
modifier|*
name|reply
decl_stmt|;
name|old_frame_addr
operator|=
name|FRAME_FP
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
expr_stmt|;
name|old_func
operator|=
name|find_pc_function
argument_list|(
name|read_pc
argument_list|()
argument_list|)
expr_stmt|;
name|putpkt
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|reply
operator|=
name|remote_get_noisy_reply
argument_list|(
name|msg
argument_list|)
expr_stmt|;
while|while
condition|(
name|reply
operator|&&
operator|*
name|reply
condition|)
switch|switch
condition|(
operator|*
name|reply
condition|)
block|{
case|case
literal|'F'
case|:
if|if
condition|(
operator|(
name|target_frameno
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
operator|++
name|reply
argument_list|,
operator|&
name|reply
argument_list|,
literal|16
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* A request for a non-existant trace frame has failed. 	     Our response will be different, depending on FROM_TTY:  	     If FROM_TTY is true, meaning that this command was  	     typed interactively by the user, then give an error 	     and DO NOT change the state of traceframe_number etc.  	     However if FROM_TTY is false, meaning that we're either 	     in a script, a loop, or a user-defined command, then  	     DON'T give an error, but DO change the state of 	     traceframe_number etc. to invalid.  	     The rationalle is that if you typed the command, you 	     might just have committed a typo or something, and you'd 	     like to NOT lose your current debugging state.  However 	     if you're in a user-defined command or especially in a 	     loop, then you need a way to detect that the command 	     failed WITHOUT aborting.  This allows you to write 	     scripts that search thru the trace buffer until the end, 	     and then continue on to do something else.  */
if|if
condition|(
name|from_tty
condition|)
name|error
argument_list|(
literal|"Target failed to find requested trace frame."
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"End of trace buffer.\n"
argument_list|)
expr_stmt|;
comment|/* The following will not recurse, since it's special-cased */
name|trace_find_command
argument_list|(
literal|"-1"
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|reply
operator|=
name|NULL
expr_stmt|;
comment|/* break out of loop,  				   (avoid recursive nonsense) */
block|}
block|}
break|break;
case|case
literal|'T'
case|:
if|if
condition|(
operator|(
name|target_tracept
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
operator|++
name|reply
argument_list|,
operator|&
name|reply
argument_list|,
literal|16
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"Target failed to find requested trace frame."
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
comment|/* "OK"? */
if|if
condition|(
name|reply
index|[
literal|1
index|]
operator|==
literal|'K'
operator|&&
name|reply
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
name|reply
operator|+=
literal|2
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Bogus reply from target: %s"
argument_list|,
name|reply
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Bogus reply from target: %s"
argument_list|,
name|reply
argument_list|)
expr_stmt|;
block|}
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|registers_changed
argument_list|()
expr_stmt|;
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_traceframe_num
argument_list|(
name|target_frameno
argument_list|)
expr_stmt|;
name|set_tracepoint_num
argument_list|(
name|target_tracept
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_frameno
operator|==
operator|-
literal|1
condition|)
name|set_traceframe_context
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|set_traceframe_context
argument_list|(
name|read_pc
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|int
name|source_only
decl_stmt|;
comment|/* NOTE: in immitation of the step command, try to determine 	 whether we have made a transition from one function to another. 	 If so, we'll print the "stack frame" (ie. the new function and 	 it's arguments) -- otherwise we'll just show the new source line.  	 This determination is made by checking (1) whether the current 	 function has changed, and (2) whether the current FP has changed. 	 Hack: if the FP wasn't collected, either at the current or the 	 previous frame, assume that the FP has NOT changed.  */
if|if
condition|(
name|old_func
operator|==
name|find_pc_function
argument_list|(
name|read_pc
argument_list|()
argument_list|)
operator|&&
operator|(
name|old_frame_addr
operator|==
literal|0
operator|||
name|FRAME_FP
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
operator|==
literal|0
operator|||
name|old_frame_addr
operator|==
name|FRAME_FP
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
operator|)
condition|)
name|source_only
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|source_only
operator|=
literal|1
expr_stmt|;
name|print_stack_frame
argument_list|(
name|selected_frame
argument_list|,
name|selected_frame_level
argument_list|,
name|source_only
argument_list|)
expr_stmt|;
name|do_displays
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* trace_find_command takes a trace frame number n,     sends "QTFrame:<n>" to the target,     and accepts a reply that may contain several optional pieces    of information: a frame number, a tracepoint number, and an    indication of whether this is a trap frame or a stepping frame.     The minimal response is just "OK" (which indicates that the     target does not give us a frame number or a tracepoint number).    Instead of that, the target may send us a string containing    any combination of: 	F<hexnum>	(gives the selected frame number) 	T<hexnum>	(gives the selected tracepoint number)    */
end_comment

begin_comment
comment|/* tfind command */
end_comment

begin_function
specifier|static
name|void
name|trace_find_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
comment|/* STUB_COMM PART_IMPLEMENTED */
comment|/* this should only be called with a numeric argument */
name|int
name|frameno
init|=
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|target_is_remote
argument_list|()
condition|)
block|{
if|if
condition|(
name|trace_find_hook
condition|)
name|trace_find_hook
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|==
literal|0
operator|||
operator|*
name|args
operator|==
literal|0
condition|)
block|{
comment|/* TFIND with no args means find NEXT trace frame. */
if|if
condition|(
name|traceframe_number
operator|==
operator|-
literal|1
condition|)
name|frameno
operator|=
literal|0
expr_stmt|;
comment|/* "next" is first one */
else|else
name|frameno
operator|=
name|traceframe_number
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|args
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
if|if
condition|(
name|traceframe_number
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"not debugging trace buffer"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|from_tty
operator|&&
name|traceframe_number
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"already at start of trace buffer"
argument_list|)
expr_stmt|;
name|frameno
operator|=
name|traceframe_number
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|frameno
operator|=
name|parse_and_eval_address
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|frameno
operator|<
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"invalid input (%d is less than zero)"
argument_list|,
name|frameno
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|target_buf
argument_list|,
literal|"QTFrame:%x"
argument_list|,
name|frameno
argument_list|)
expr_stmt|;
name|finish_tfind_command
argument_list|(
name|target_buf
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Trace can only be run on remote targets."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* tfind end */
end_comment

begin_function
specifier|static
name|void
name|trace_find_end_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|trace_find_command
argument_list|(
literal|"-1"
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* tfind none */
end_comment

begin_function
specifier|static
name|void
name|trace_find_none_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|trace_find_command
argument_list|(
literal|"-1"
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* tfind start */
end_comment

begin_function
specifier|static
name|void
name|trace_find_start_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|trace_find_command
argument_list|(
literal|"0"
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* tfind pc command */
end_comment

begin_function
specifier|static
name|void
name|trace_find_pc_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
comment|/* STUB_COMM PART_IMPLEMENTED */
name|CORE_ADDR
name|pc
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|target_is_remote
argument_list|()
condition|)
block|{
if|if
condition|(
name|args
operator|==
literal|0
operator|||
operator|*
name|args
operator|==
literal|0
condition|)
name|pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
comment|/* default is current pc */
else|else
name|pc
operator|=
name|parse_and_eval_address
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|target_buf
argument_list|,
literal|"QTFrame:pc:%x"
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|finish_tfind_command
argument_list|(
name|target_buf
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Trace can only be run on remote targets."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* tfind tracepoint command */
end_comment

begin_function
specifier|static
name|void
name|trace_find_tracepoint_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
comment|/* STUB_COMM PART_IMPLEMENTED */
name|int
name|tdp
decl_stmt|;
name|char
name|buf
index|[
literal|40
index|]
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|target_is_remote
argument_list|()
condition|)
block|{
if|if
condition|(
name|args
operator|==
literal|0
operator|||
operator|*
name|args
operator|==
literal|0
condition|)
if|if
condition|(
name|tracepoint_number
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"No current tracepoint -- please supply an argument."
argument_list|)
expr_stmt|;
else|else
name|tdp
operator|=
name|tracepoint_number
expr_stmt|;
comment|/* default is current TDP */
else|else
name|tdp
operator|=
name|parse_and_eval_address
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|target_buf
argument_list|,
literal|"QTFrame:tdp:%x"
argument_list|,
name|tdp
argument_list|)
expr_stmt|;
name|finish_tfind_command
argument_list|(
name|target_buf
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Trace can only be run on remote targets."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* TFIND LINE command:      This command will take a sourceline for argument, just like BREAK    or TRACE (ie. anything that "decode_line_1" can handle).          With no argument, this command will find the next trace frame     corresponding to a source line OTHER THAN THE CURRENT ONE.  */
end_comment

begin_function
specifier|static
name|void
name|trace_find_line_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
comment|/* STUB_COMM PART_IMPLEMENTED */
specifier|static
name|CORE_ADDR
name|start_pc
decl_stmt|,
name|end_pc
decl_stmt|;
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
if|if
condition|(
name|target_is_remote
argument_list|()
condition|)
block|{
if|if
condition|(
name|args
operator|==
literal|0
operator|||
operator|*
name|args
operator|==
literal|0
condition|)
block|{
name|sal
operator|=
name|find_pc_line
argument_list|(
operator|(
name|get_current_frame
argument_list|()
operator|)
operator|->
name|pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sals
operator|.
name|nelts
operator|=
literal|1
expr_stmt|;
name|sals
operator|.
name|sals
operator|=
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|symtab_and_line
argument_list|)
argument_list|)
expr_stmt|;
name|sals
operator|.
name|sals
index|[
literal|0
index|]
operator|=
name|sal
expr_stmt|;
block|}
else|else
block|{
name|sals
operator|=
name|decode_line_spec
argument_list|(
name|args
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sal
operator|=
name|sals
operator|.
name|sals
index|[
literal|0
index|]
expr_stmt|;
block|}
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|sals
operator|.
name|sals
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|symtab
operator|==
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"TFIND: No line number information available"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|pc
operator|!=
literal|0
condition|)
block|{
comment|/* This is useful for "info line *0x7f34".  If we can't tell the 		 user about a source line, at least let them have the symbolic 		 address.  */
name|printf_filtered
argument_list|(
literal|" for address "
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|print_address
argument_list|(
name|sal
operator|.
name|pc
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|";\n -- will attempt to find by PC. \n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
return|return;
comment|/* no line, no PC; what can we do? */
block|}
block|}
elseif|else
if|if
condition|(
name|sal
operator|.
name|line
operator|>
literal|0
operator|&&
name|find_line_pc_range
argument_list|(
name|sal
argument_list|,
operator|&
name|start_pc
argument_list|,
operator|&
name|end_pc
argument_list|)
condition|)
block|{
if|if
condition|(
name|start_pc
operator|==
name|end_pc
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Line %d of \"%s\""
argument_list|,
name|sal
operator|.
name|line
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" is at address "
argument_list|)
expr_stmt|;
name|print_address
argument_list|(
name|start_pc
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|" but contains no code.\n"
argument_list|)
expr_stmt|;
name|sal
operator|=
name|find_pc_line
argument_list|(
name|start_pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|line
operator|>
literal|0
operator|&&
name|find_line_pc_range
argument_list|(
name|sal
argument_list|,
operator|&
name|start_pc
argument_list|,
operator|&
name|end_pc
argument_list|)
operator|&&
name|start_pc
operator|!=
name|end_pc
condition|)
name|printf_filtered
argument_list|(
literal|"Attempting to find line %d instead.\n"
argument_list|,
name|sal
operator|.
name|line
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Cannot find a good line."
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* Is there any case in which we get here, and have an address 	   which the user would want to see?  If we have debugging symbols 	   and no line numbers?  */
name|error
argument_list|(
literal|"Line number %d is out of range for \"%s\".\n"
argument_list|,
name|sal
operator|.
name|line
argument_list|,
name|sal
operator|.
name|symtab
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|&&
operator|*
name|args
condition|)
comment|/* find within range of stated line */
name|sprintf
argument_list|(
name|target_buf
argument_list|,
literal|"QTFrame:range:%x:%x"
argument_list|,
name|start_pc
argument_list|,
name|end_pc
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
comment|/* find OUTSIDE OF range of CURRENT line */
name|sprintf
argument_list|(
name|target_buf
argument_list|,
literal|"QTFrame:outside:%x:%x"
argument_list|,
name|start_pc
argument_list|,
name|end_pc
operator|-
literal|1
argument_list|)
expr_stmt|;
name|finish_tfind_command
argument_list|(
name|target_buf
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Trace can only be run on remote targets."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* tfind range command */
end_comment

begin_function
specifier|static
name|void
name|trace_find_range_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
comment|/* STUB_COMM PART_IMPLEMENTED */
specifier|static
name|CORE_ADDR
name|start
decl_stmt|,
name|stop
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|target_is_remote
argument_list|()
condition|)
block|{
if|if
condition|(
name|args
operator|==
literal|0
operator|||
operator|*
name|args
operator|==
literal|0
condition|)
block|{
comment|/* XXX FIXME: what should default behavior be? */
name|printf_filtered
argument_list|(
literal|"Usage: tfind range<startaddr>,<endaddr>\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
literal|0
operator|!=
operator|(
name|tmp
operator|=
name|strchr
argument_list|(
name|args
argument_list|,
literal|','
argument_list|)
operator|)
condition|)
block|{
operator|*
name|tmp
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* terminate start address */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|tmp
argument_list|)
condition|)
name|tmp
operator|++
expr_stmt|;
name|start
operator|=
name|parse_and_eval_address
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|stop
operator|=
name|parse_and_eval_address
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* no explicit end address? */
name|start
operator|=
name|parse_and_eval_address
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|stop
operator|=
name|start
operator|+
literal|1
expr_stmt|;
comment|/* ??? */
block|}
name|sprintf
argument_list|(
name|target_buf
argument_list|,
literal|"QTFrame:range:%x:%x"
argument_list|,
name|start
argument_list|,
name|stop
argument_list|)
expr_stmt|;
name|finish_tfind_command
argument_list|(
name|target_buf
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Trace can only be run on remote targets."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* tfind outside command */
end_comment

begin_function
specifier|static
name|void
name|trace_find_outside_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
comment|/* STUB_COMM PART_IMPLEMENTED */
name|CORE_ADDR
name|start
decl_stmt|,
name|stop
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|target_is_remote
argument_list|()
condition|)
block|{
if|if
condition|(
name|args
operator|==
literal|0
operator|||
operator|*
name|args
operator|==
literal|0
condition|)
block|{
comment|/* XXX FIXME: what should default behavior be? */
name|printf_filtered
argument_list|(
literal|"Usage: tfind outside<startaddr>,<endaddr>\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
literal|0
operator|!=
operator|(
name|tmp
operator|=
name|strchr
argument_list|(
name|args
argument_list|,
literal|','
argument_list|)
operator|)
condition|)
block|{
operator|*
name|tmp
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* terminate start address */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|tmp
argument_list|)
condition|)
name|tmp
operator|++
expr_stmt|;
name|start
operator|=
name|parse_and_eval_address
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|stop
operator|=
name|parse_and_eval_address
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* no explicit end address? */
name|start
operator|=
name|parse_and_eval_address
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|stop
operator|=
name|start
operator|+
literal|1
expr_stmt|;
comment|/* ??? */
block|}
name|sprintf
argument_list|(
name|target_buf
argument_list|,
literal|"QTFrame:outside:%x:%x"
argument_list|,
name|start
argument_list|,
name|stop
argument_list|)
expr_stmt|;
name|finish_tfind_command
argument_list|(
name|target_buf
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"Trace can only be run on remote targets."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* save-tracepoints command */
end_comment

begin_function
specifier|static
name|void
name|tracepoint_save_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|tracepoint
modifier|*
name|tp
decl_stmt|;
name|struct
name|action_line
modifier|*
name|line
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|i1
init|=
literal|"    "
decl_stmt|,
modifier|*
name|i2
init|=
literal|"      "
decl_stmt|;
name|char
modifier|*
name|indent
decl_stmt|,
modifier|*
name|actionline
decl_stmt|;
if|if
condition|(
name|args
operator|==
literal|0
operator|||
operator|*
name|args
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Argument required (file name in which to save tracepoints"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tracepoint_chain
operator|==
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"save-tracepoints: no tracepoints to save.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|args
argument_list|,
literal|"w"
argument_list|)
operator|)
condition|)
name|error
argument_list|(
literal|"Unable to open file '%s' for saving tracepoints"
argument_list|)
expr_stmt|;
name|ALL_TRACEPOINTS
argument_list|(
argument|tp
argument_list|)
block|{
if|if
condition|(
name|tp
operator|->
name|addr_string
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"trace %s\n"
argument_list|,
name|tp
operator|->
name|addr_string
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"trace *0x%x\n"
argument_list|,
name|tp
operator|->
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|pass_count
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  passcount %d\n"
argument_list|,
name|tp
operator|->
name|pass_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|actions
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"  actions\n"
argument_list|)
expr_stmt|;
name|indent
operator|=
name|i1
expr_stmt|;
for|for
control|(
name|line
operator|=
name|tp
operator|->
name|actions
init|;
name|line
condition|;
name|line
operator|=
name|line
operator|->
name|next
control|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|cmd
decl_stmt|;
name|QUIT
expr_stmt|;
comment|/* allow user to bail out with ^C */
name|actionline
operator|=
name|line
operator|->
name|action
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|actionline
argument_list|)
condition|)
name|actionline
operator|++
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s%s\n"
argument_list|,
name|indent
argument_list|,
name|actionline
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|actionline
operator|!=
literal|'#'
condition|)
comment|/* skip for comment lines */
block|{
name|cmd
operator|=
name|lookup_cmd
argument_list|(
operator|&
name|actionline
argument_list|,
name|cmdlist
argument_list|,
literal|""
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Bad action list item: %s"
argument_list|,
name|actionline
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|function
operator|.
name|cfunc
operator|==
name|while_stepping_pseudocommand
condition|)
name|indent
operator|=
name|i2
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd
operator|->
name|function
operator|.
name|cfunc
operator|==
name|end_actions_pseudocommand
condition|)
name|indent
operator|=
name|i1
expr_stmt|;
block|}
block|}
block|}
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf_filtered
argument_list|(
literal|"Tracepoints saved to file '%s'.\n"
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* info scope command: list the locals for a scope.  */
end_comment

begin_function
specifier|static
name|void
name|scope_info
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|struct
name|symtabs_and_lines
name|sals
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msym
decl_stmt|;
name|struct
name|block
modifier|*
name|block
decl_stmt|;
name|char
modifier|*
modifier|*
name|canonical
decl_stmt|,
modifier|*
name|symname
decl_stmt|,
modifier|*
name|save_args
init|=
name|args
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|nsyms
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|args
operator|==
literal|0
operator|||
operator|*
name|args
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"requires an argument (function, line or *addr) to define a scope"
argument_list|)
expr_stmt|;
name|sals
operator|=
name|decode_line_1
argument_list|(
operator|&
name|args
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|canonical
argument_list|)
expr_stmt|;
if|if
condition|(
name|sals
operator|.
name|nelts
operator|==
literal|0
condition|)
return|return;
comment|/* presumably decode_line_1 has already warned */
comment|/* Resolve line numbers to PC */
name|resolve_sal_pc
argument_list|(
operator|&
name|sals
operator|.
name|sals
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|block
operator|=
name|block_for_pc
argument_list|(
name|sals
operator|.
name|sals
index|[
literal|0
index|]
operator|.
name|pc
argument_list|)
expr_stmt|;
while|while
condition|(
name|block
operator|!=
literal|0
condition|)
block|{
name|QUIT
expr_stmt|;
comment|/* allow user to bail out with ^C */
name|nsyms
operator|=
name|BLOCK_NSYMS
argument_list|(
name|block
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsyms
condition|;
name|i
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
comment|/* allow user to bail out with ^C */
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|"Scope for %s:\n"
argument_list|,
name|save_args
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|sym
operator|=
name|BLOCK_SYM
argument_list|(
name|block
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|symname
operator|=
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|symname
operator|==
name|NULL
operator|||
operator|*
name|symname
operator|==
literal|'\0'
condition|)
continue|continue;
comment|/* probably botched, certainly useless */
name|printf_filtered
argument_list|(
literal|"Symbol %s is "
argument_list|,
name|symname
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
condition|)
block|{
default|default:
case|case
name|LOC_UNDEF
case|:
comment|/* messed up symbol? */
name|printf_filtered
argument_list|(
literal|"a bogus symbol, class %d.\n"
argument_list|,
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|--
expr_stmt|;
comment|/* don't count this one */
continue|continue;
case|case
name|LOC_CONST
case|:
name|printf_filtered
argument_list|(
literal|"a constant with value %d (0x%x)"
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_CONST_BYTES
case|:
name|printf_filtered
argument_list|(
literal|"constant bytes: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|TYPE_LENGTH
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
condition|;
name|j
operator|++
control|)
name|fprintf_filtered
argument_list|(
name|gdb_stdout
argument_list|,
literal|" %02x"
argument_list|,
operator|(
name|unsigned
operator|)
name|SYMBOL_VALUE_BYTES
argument_list|(
name|sym
argument_list|)
index|[
name|j
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_STATIC
case|:
name|printf_filtered
argument_list|(
literal|"in static storage at address "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_REGISTER
case|:
name|printf_filtered
argument_list|(
literal|"a local variable in register $%s"
argument_list|,
name|REGISTER_NAME
argument_list|(
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_ARG
case|:
case|case
name|LOC_LOCAL_ARG
case|:
name|printf_filtered
argument_list|(
literal|"an argument at stack/frame offset %ld"
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_LOCAL
case|:
name|printf_filtered
argument_list|(
literal|"a local variable at frame offset %ld"
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_REF_ARG
case|:
name|printf_filtered
argument_list|(
literal|"a reference argument at offset %ld"
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_REGPARM
case|:
name|printf_filtered
argument_list|(
literal|"an argument in register $%s"
argument_list|,
name|REGISTER_NAME
argument_list|(
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_REGPARM_ADDR
case|:
name|printf_filtered
argument_list|(
literal|"the address of an argument, in register $%s"
argument_list|,
name|REGISTER_NAME
argument_list|(
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_TYPEDEF
case|:
name|printf_filtered
argument_list|(
literal|"a typedef.\n"
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|LOC_LABEL
case|:
name|printf_filtered
argument_list|(
literal|"a label at address "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_BLOCK
case|:
name|printf_filtered
argument_list|(
literal|"a function at address "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_BASEREG
case|:
name|printf_filtered
argument_list|(
literal|"a variable at offset %d from register $%s"
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|REGISTER_NAME
argument_list|(
name|SYMBOL_BASEREG
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_BASEREG_ARG
case|:
name|printf_filtered
argument_list|(
literal|"an argument at offset %d from register $%s"
argument_list|,
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
argument_list|,
name|REGISTER_NAME
argument_list|(
name|SYMBOL_BASEREG
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_UNRESOLVED
case|:
name|msym
operator|=
name|lookup_minimal_symbol
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|msym
operator|==
name|NULL
condition|)
name|printf_filtered
argument_list|(
literal|"Unresolved Static"
argument_list|)
expr_stmt|;
else|else
block|{
name|printf_filtered
argument_list|(
literal|"static storage at address "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msym
argument_list|)
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|LOC_OPTIMIZED_OUT
case|:
name|printf_filtered
argument_list|(
literal|"optimized out.\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
condition|)
name|printf_filtered
argument_list|(
literal|", length %d.\n"
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|check_typedef
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|BLOCK_FUNCTION
argument_list|(
name|block
argument_list|)
condition|)
break|break;
else|else
name|block
operator|=
name|BLOCK_SUPERBLOCK
argument_list|(
name|block
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
name|printf_filtered
argument_list|(
literal|"Scope for %s contains no locals or arguments.\n"
argument_list|,
name|save_args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* worker function (cleanup) */
end_comment

begin_function
specifier|static
name|void
name|replace_comma
parameter_list|(
name|comma
parameter_list|)
name|char
modifier|*
name|comma
decl_stmt|;
block|{
operator|*
name|comma
operator|=
literal|','
expr_stmt|;
block|}
end_function

begin_comment
comment|/* tdump command */
end_comment

begin_function
specifier|static
name|void
name|trace_dump_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|tracepoint
modifier|*
name|t
decl_stmt|;
name|struct
name|action_line
modifier|*
name|action
decl_stmt|;
name|char
modifier|*
name|action_exp
decl_stmt|,
modifier|*
name|next_comma
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_cleanups
decl_stmt|;
name|int
name|stepping_actions
init|=
literal|0
decl_stmt|;
name|int
name|stepping_frame
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|target_is_remote
argument_list|()
condition|)
block|{
name|error
argument_list|(
literal|"Trace can only be run on remote targets."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|tracepoint_number
operator|==
operator|-
literal|1
condition|)
block|{
name|warning
argument_list|(
literal|"No current trace frame."
argument_list|)
expr_stmt|;
return|return;
block|}
name|ALL_TRACEPOINTS
argument_list|(
argument|t
argument_list|)
if|if
condition|(
name|t
operator|->
name|number
operator|==
name|tracepoint_number
condition|)
break|break;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"No known tracepoint matches 'current' tracepoint #%d."
argument_list|,
name|tracepoint_number
argument_list|)
expr_stmt|;
name|old_cleanups
operator|=
name|make_cleanup
argument_list|(
name|null_cleanup
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Data collected at tracepoint %d, trace frame %d:\n"
argument_list|,
name|tracepoint_number
argument_list|,
name|traceframe_number
argument_list|)
expr_stmt|;
comment|/* The current frame is a trap frame if the frame PC is equal      to the tracepoint PC.  If not, then the current frame was      collected during single-stepping.  */
name|stepping_frame
operator|=
operator|(
name|t
operator|->
name|address
operator|!=
name|read_pc
argument_list|()
operator|)
expr_stmt|;
for|for
control|(
name|action
operator|=
name|t
operator|->
name|actions
init|;
name|action
condition|;
name|action
operator|=
name|action
operator|->
name|next
control|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|cmd
decl_stmt|;
name|QUIT
expr_stmt|;
comment|/* allow user to bail out with ^C */
name|action_exp
operator|=
name|action
operator|->
name|action
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|action_exp
argument_list|)
condition|)
name|action_exp
operator|++
expr_stmt|;
comment|/* The collection actions to be done while stepping are 	 bracketed by the commands "while-stepping" and "end".  */
if|if
condition|(
operator|*
name|action_exp
operator|==
literal|'#'
condition|)
comment|/* comment line */
continue|continue;
name|cmd
operator|=
name|lookup_cmd
argument_list|(
operator|&
name|action_exp
argument_list|,
name|cmdlist
argument_list|,
literal|""
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Bad action list item: %s"
argument_list|,
name|action_exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|function
operator|.
name|cfunc
operator|==
name|while_stepping_pseudocommand
condition|)
name|stepping_actions
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd
operator|->
name|function
operator|.
name|cfunc
operator|==
name|end_actions_pseudocommand
condition|)
name|stepping_actions
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd
operator|->
name|function
operator|.
name|cfunc
operator|==
name|collect_pseudocommand
condition|)
block|{
comment|/* Display the collected data. 	     For the trap frame, display only what was collected at the trap. 	     Likewise for stepping frames, display only what was collected 	     while stepping.  This means that the two boolean variables, 	     STEPPING_FRAME and STEPPING_ACTIONS should be equal.  */
if|if
condition|(
name|stepping_frame
operator|==
name|stepping_actions
condition|)
block|{
do|do
block|{
comment|/* repeat over a comma-separated list */
name|QUIT
expr_stmt|;
comment|/* allow user to bail out with ^C */
if|if
condition|(
operator|*
name|action_exp
operator|==
literal|','
condition|)
name|action_exp
operator|++
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|action_exp
argument_list|)
condition|)
name|action_exp
operator|++
expr_stmt|;
name|next_comma
operator|=
name|strchr
argument_list|(
name|action_exp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|strncasecmp
argument_list|(
name|action_exp
argument_list|,
literal|"$reg"
argument_list|,
literal|4
argument_list|)
condition|)
name|registers_info
argument_list|(
name|NULL
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strncasecmp
argument_list|(
name|action_exp
argument_list|,
literal|"$loc"
argument_list|,
literal|4
argument_list|)
condition|)
name|locals_info
argument_list|(
name|NULL
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
literal|0
operator|==
name|strncasecmp
argument_list|(
name|action_exp
argument_list|,
literal|"$arg"
argument_list|,
literal|4
argument_list|)
condition|)
name|args_info
argument_list|(
name|NULL
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* variable */
if|if
condition|(
name|next_comma
condition|)
block|{
name|make_cleanup
argument_list|(
name|replace_comma
argument_list|,
name|next_comma
argument_list|)
expr_stmt|;
operator|*
name|next_comma
operator|=
literal|'\0'
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"%s = "
argument_list|,
name|action_exp
argument_list|)
expr_stmt|;
name|output_command
argument_list|(
name|action_exp
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|next_comma
condition|)
operator|*
name|next_comma
operator|=
literal|','
expr_stmt|;
name|action_exp
operator|=
name|next_comma
expr_stmt|;
block|}
do|while
condition|(
name|action_exp
operator|&&
operator|*
name|action_exp
operator|==
literal|','
condition|)
do|;
block|}
block|}
block|}
name|discard_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert the memory pointed to by mem into hex, placing result in buf.  * Return a pointer to the last char put in buf (null)  * "stolen" from sparc-stub.c  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|hexchars
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|mem2hex
parameter_list|(
name|mem
parameter_list|,
name|buf
parameter_list|,
name|count
parameter_list|)
name|unsigned
name|char
modifier|*
name|mem
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
name|unsigned
name|char
name|ch
decl_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
name|ch
operator|=
operator|*
name|mem
operator|++
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|hexchars
index|[
name|ch
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|buf
operator|++
operator|=
name|hexchars
index|[
name|ch
operator|&
literal|0xf
index|]
expr_stmt|;
block|}
operator|*
name|buf
operator|=
literal|0
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_function
name|int
name|get_traceframe_number
parameter_list|()
block|{
return|return
name|traceframe_number
return|;
block|}
end_function

begin_comment
comment|/* module initialization */
end_comment

begin_function
name|void
name|_initialize_tracepoint
parameter_list|()
block|{
name|tracepoint_chain
operator|=
literal|0
expr_stmt|;
name|tracepoint_count
operator|=
literal|0
expr_stmt|;
name|traceframe_number
operator|=
operator|-
literal|1
expr_stmt|;
name|tracepoint_number
operator|=
operator|-
literal|1
expr_stmt|;
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"tpnum"
argument_list|)
argument_list|,
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|set_internalvar
argument_list|(
name|lookup_internalvar
argument_list|(
literal|"trace_frame"
argument_list|)
argument_list|,
name|value_from_longest
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tracepoint_list
operator|.
name|list
operator|==
name|NULL
condition|)
block|{
name|tracepoint_list
operator|.
name|listsize
operator|=
literal|128
expr_stmt|;
name|tracepoint_list
operator|.
name|list
operator|=
name|xmalloc
argument_list|(
name|tracepoint_list
operator|.
name|listsize
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|memrange
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tracepoint_list
operator|.
name|aexpr_list
operator|==
name|NULL
condition|)
block|{
name|tracepoint_list
operator|.
name|aexpr_listsize
operator|=
literal|128
expr_stmt|;
name|tracepoint_list
operator|.
name|aexpr_list
operator|=
name|xmalloc
argument_list|(
name|tracepoint_list
operator|.
name|aexpr_listsize
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|agent_expr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stepping_list
operator|.
name|list
operator|==
name|NULL
condition|)
block|{
name|stepping_list
operator|.
name|listsize
operator|=
literal|128
expr_stmt|;
name|stepping_list
operator|.
name|list
operator|=
name|xmalloc
argument_list|(
name|stepping_list
operator|.
name|listsize
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|memrange
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stepping_list
operator|.
name|aexpr_list
operator|==
name|NULL
condition|)
block|{
name|stepping_list
operator|.
name|aexpr_listsize
operator|=
literal|128
expr_stmt|;
name|stepping_list
operator|.
name|aexpr_list
operator|=
name|xmalloc
argument_list|(
name|stepping_list
operator|.
name|aexpr_listsize
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|agent_expr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|add_info
argument_list|(
literal|"scope"
argument_list|,
name|scope_info
argument_list|,
literal|"List the variables local to a scope"
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"tracepoints"
argument_list|,
name|class_trace
argument_list|,
name|NO_FUNCTION
argument_list|,
literal|"Tracing of program execution without stopping the program."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"tracepoints"
argument_list|,
name|tracepoints_info
argument_list|,
literal|"Status of tracepoints, or tracepoint number NUMBER.\n\ Convenience variable \"$tpnum\" contains the number of the\n\ last tracepoint set."
argument_list|)
expr_stmt|;
name|add_info_alias
argument_list|(
literal|"tp"
argument_list|,
literal|"tracepoints"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"save-tracepoints"
argument_list|,
name|class_trace
argument_list|,
name|tracepoint_save_command
argument_list|,
literal|"Save current tracepoint definitions as a script.\n\ Use the 'source' command in another debug session to restore them."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"tdump"
argument_list|,
name|class_trace
argument_list|,
name|trace_dump_command
argument_list|,
literal|"Print everything collected at the current tracepoint."
argument_list|)
expr_stmt|;
name|add_prefix_cmd
argument_list|(
literal|"tfind"
argument_list|,
name|class_trace
argument_list|,
name|trace_find_command
argument_list|,
literal|"Select a trace frame;\n\ No argument means forward by one frame; '-' meand backward by one frame."
argument_list|,
operator|&
name|tfindlist
argument_list|,
literal|"tfind "
argument_list|,
literal|1
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"outside"
argument_list|,
name|class_trace
argument_list|,
name|trace_find_outside_command
argument_list|,
literal|"Select a trace frame whose PC is outside the given \ range.\nUsage: tfind outside addr1, addr2"
argument_list|,
operator|&
name|tfindlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"range"
argument_list|,
name|class_trace
argument_list|,
name|trace_find_range_command
argument_list|,
literal|"Select a trace frame whose PC is in the given range.\n\ Usage: tfind range addr1,addr2"
argument_list|,
operator|&
name|tfindlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"line"
argument_list|,
name|class_trace
argument_list|,
name|trace_find_line_command
argument_list|,
literal|"Select a trace frame by source line.\n\ Argument can be a line number (with optional source file), \n\ a function name, or '*' followed by an address.\n\ Default argument is 'the next source line that was traced'."
argument_list|,
operator|&
name|tfindlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"tracepoint"
argument_list|,
name|class_trace
argument_list|,
name|trace_find_tracepoint_command
argument_list|,
literal|"Select a trace frame by tracepoint number.\n\ Default is the tracepoint for the current trace frame."
argument_list|,
operator|&
name|tfindlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"pc"
argument_list|,
name|class_trace
argument_list|,
name|trace_find_pc_command
argument_list|,
literal|"Select a trace frame by PC.\n\ Default is the current PC, or the PC of the current trace frame."
argument_list|,
operator|&
name|tfindlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"end"
argument_list|,
name|class_trace
argument_list|,
name|trace_find_end_command
argument_list|,
literal|"Synonym for 'none'.\n\ De-select any trace frame and resume 'live' debugging."
argument_list|,
operator|&
name|tfindlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"none"
argument_list|,
name|class_trace
argument_list|,
name|trace_find_none_command
argument_list|,
literal|"De-select any trace frame and resume 'live' debugging."
argument_list|,
operator|&
name|tfindlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"start"
argument_list|,
name|class_trace
argument_list|,
name|trace_find_start_command
argument_list|,
literal|"Select the first trace frame in the trace buffer."
argument_list|,
operator|&
name|tfindlist
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"tstatus"
argument_list|,
name|class_trace
argument_list|,
name|trace_status_command
argument_list|,
literal|"Display the status of the current trace data collection."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"tstop"
argument_list|,
name|class_trace
argument_list|,
name|trace_stop_command
argument_list|,
literal|"Stop trace data collection."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"tstart"
argument_list|,
name|class_trace
argument_list|,
name|trace_start_command
argument_list|,
literal|"Start trace data collection."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"passcount"
argument_list|,
name|class_trace
argument_list|,
name|trace_pass_command
argument_list|,
literal|"Set the passcount for a tracepoint.\n\ The trace will end when the tracepoint has been passed 'count' times.\n\ Usage: passcount COUNT TPNUM, where TPNUM may also be \"all\";\n\ if TPNUM is omitted, passcount refers to the last tracepoint defined."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"end"
argument_list|,
name|class_trace
argument_list|,
name|end_actions_pseudocommand
argument_list|,
literal|"Ends a list of commands or actions.\n\ Several GDB commands allow you to enter a list of commands or actions.\n\ Entering \"end\" on a line by itself is the normal way to terminate\n\ such a list.\n\n\ Note: the \"end\" command cannot be used at the gdb prompt."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"while-stepping"
argument_list|,
name|class_trace
argument_list|,
name|while_stepping_pseudocommand
argument_list|,
literal|"Specify single-stepping behavior at a tracepoint.\n\ Argument is number of instructions to trace in single-step mode\n\ following the tracepoint.  This command is normally followed by\n\ one or more \"collect\" commands, to specify what to collect\n\ while single-stepping.\n\n\ Note: this command can only be used in a tracepoint \"actions\" list."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"ws"
argument_list|,
literal|"while-stepping"
argument_list|,
name|class_alias
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"stepping"
argument_list|,
literal|"while-stepping"
argument_list|,
name|class_alias
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"collect"
argument_list|,
name|class_trace
argument_list|,
name|collect_pseudocommand
argument_list|,
literal|"Specify one or more data items to be collected at a tracepoint.\n\ Accepts a comma-separated list of (one or more) expressions.  GDB will\n\ collect all data (variables, registers) referenced by that expression.\n\ Also accepts the following special arguments:\n\     $regs   -- all registers.\n\     $args   -- all function arguments.\n\     $locals -- all variables local to the block/function scope.\n\ Note: this command can only be used in a tracepoint \"actions\" list."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"actions"
argument_list|,
name|class_trace
argument_list|,
name|trace_actions_command
argument_list|,
literal|"Specify the actions to be taken at a tracepoint.\n\ Tracepoint actions may include collecting of specified data, \n\ single-stepping, or enabling/disabling other tracepoints, \n\ depending on target's capabilities."
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"tracepoints"
argument_list|,
name|class_trace
argument_list|,
name|delete_trace_command
argument_list|,
literal|"Delete specified tracepoints.\n\ Arguments are tracepoint numbers, separated by spaces.\n\ No argument means delete all tracepoints."
argument_list|,
operator|&
name|deletelist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"tracepoints"
argument_list|,
name|class_trace
argument_list|,
name|disable_trace_command
argument_list|,
literal|"Disable specified tracepoints.\n\ Arguments are tracepoint numbers, separated by spaces.\n\ No argument means disable all tracepoints."
argument_list|,
operator|&
name|disablelist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"tracepoints"
argument_list|,
name|class_trace
argument_list|,
name|enable_trace_command
argument_list|,
literal|"Enable specified tracepoints.\n\ Arguments are tracepoint numbers, separated by spaces.\n\ No argument means enable all tracepoints."
argument_list|,
operator|&
name|enablelist
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"trace"
argument_list|,
name|class_trace
argument_list|,
name|trace_command
argument_list|,
literal|"Set a tracepoint at a specified line or function or address.\n\ Argument may be a line number, function name, or '*' plus an address.\n\ For a line number or function, trace at the start of its code.\n\ If an address is specified, trace at that exact address.\n\n\ Do \"help tracepoints\" for info on other tracepoint commands."
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"tp"
argument_list|,
literal|"trace"
argument_list|,
name|class_alias
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"tr"
argument_list|,
literal|"trace"
argument_list|,
name|class_alias
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"tra"
argument_list|,
literal|"trace"
argument_list|,
name|class_alias
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_com_alias
argument_list|(
literal|"trac"
argument_list|,
literal|"trace"
argument_list|,
name|class_alias
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

