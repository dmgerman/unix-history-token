begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* IBM RS/6000 native-dependent code for GDB, the GNU debugger.     Copyright 1986, 1987, 1989, 1991, 1992, 1993, 1994, 1995, 1996,    1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software    Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"xcoffsolib.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"libbfd.h"
end_include

begin_comment
comment|/* For bfd_cache_lookup (FIXME) */
end_comment

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"gdb-stabs.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"arch-utils.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_comment
comment|/* for local_hex_string().  */
end_comment

begin_include
include|#
directive|include
file|"ppc-tdep.h"
end_include

begin_include
include|#
directive|include
file|"exec.h"
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/reg.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_include
include|#
directive|include
file|<sys/core.h>
end_include

begin_define
define|#
directive|define
name|__LDINFO_PTRACE32__
end_define

begin_comment
comment|/* for __ld_info32 */
end_comment

begin_define
define|#
directive|define
name|__LDINFO_PTRACE64__
end_define

begin_comment
comment|/* for __ld_info64 */
end_comment

begin_include
include|#
directive|include
file|<sys/ldr.h>
end_include

begin_include
include|#
directive|include
file|<sys/systemcfg.h>
end_include

begin_comment
comment|/* On AIX4.3+, sys/ldr.h provides different versions of struct ld_info for    debugging 32-bit and 64-bit processes.  Define a typedef and macros for    accessing fields in the appropriate structures. */
end_comment

begin_comment
comment|/* In 32-bit compilation mode (which is the only mode from which ptrace()    works on 4.3), __ld_info32 is #defined as equivalent to ld_info. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__ld_info32
end_ifdef

begin_define
define|#
directive|define
name|ARCH3264
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return whether the current architecture is 64-bit. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ARCH3264
end_ifndef

begin_define
define|#
directive|define
name|ARCH64
parameter_list|()
value|0
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ARCH64
parameter_list|()
value|(DEPRECATED_REGISTER_RAW_SIZE (0) == 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Union of 32-bit and 64-bit ".reg" core file sections. */
end_comment

begin_typedef
typedef|typedef
union|union
block|{
ifdef|#
directive|ifdef
name|ARCH3264
name|struct
name|__context64
name|r64
decl_stmt|;
else|#
directive|else
name|struct
name|mstsave
name|r64
decl_stmt|;
endif|#
directive|endif
name|struct
name|mstsave
name|r32
decl_stmt|;
block|}
name|CoreRegs
typedef|;
end_typedef

begin_comment
comment|/* Union of 32-bit and 64-bit versions of ld_info. */
end_comment

begin_typedef
typedef|typedef
union|union
block|{
ifndef|#
directive|ifndef
name|ARCH3264
name|struct
name|ld_info
name|l32
decl_stmt|;
name|struct
name|ld_info
name|l64
decl_stmt|;
else|#
directive|else
name|struct
name|__ld_info32
name|l32
decl_stmt|;
name|struct
name|__ld_info64
name|l64
decl_stmt|;
endif|#
directive|endif
block|}
name|LdInfo
typedef|;
end_typedef

begin_comment
comment|/* If compiling with 32-bit and 64-bit debugging capability (e.g. AIX 4.x),    declare and initialize a variable named VAR suitable for use as the arch64    parameter to the various LDI_*() macros. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ARCH3264
end_ifndef

begin_define
define|#
directive|define
name|ARCH64_DECL
parameter_list|(
name|var
parameter_list|)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ARCH64_DECL
parameter_list|(
name|var
parameter_list|)
value|int var = ARCH64 ()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return LDI's FIELD for a 64-bit process if ARCH64 and for a 32-bit process    otherwise.  This technique only works for FIELDs with the same data type in    32-bit and 64-bit versions of ld_info. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ARCH3264
end_ifndef

begin_define
define|#
directive|define
name|LDI_FIELD
parameter_list|(
name|ldi
parameter_list|,
name|arch64
parameter_list|,
name|field
parameter_list|)
value|(ldi)->l32.ldinfo_##field
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|LDI_FIELD
parameter_list|(
name|ldi
parameter_list|,
name|arch64
parameter_list|,
name|field
parameter_list|)
define|\
value|(arch64 ? (ldi)->l64.ldinfo_##field : (ldi)->l32.ldinfo_##field)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return various LDI fields for a 64-bit process if ARCH64 and for a 32-bit    process otherwise. */
end_comment

begin_define
define|#
directive|define
name|LDI_NEXT
parameter_list|(
name|ldi
parameter_list|,
name|arch64
parameter_list|)
value|LDI_FIELD(ldi, arch64, next)
end_define

begin_define
define|#
directive|define
name|LDI_FD
parameter_list|(
name|ldi
parameter_list|,
name|arch64
parameter_list|)
value|LDI_FIELD(ldi, arch64, fd)
end_define

begin_define
define|#
directive|define
name|LDI_FILENAME
parameter_list|(
name|ldi
parameter_list|,
name|arch64
parameter_list|)
value|LDI_FIELD(ldi, arch64, filename)
end_define

begin_function_decl
specifier|extern
name|struct
name|vmap
modifier|*
name|map_vmap
parameter_list|(
name|bfd
modifier|*
name|bf
parameter_list|,
name|bfd
modifier|*
name|arch
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vmap_exec
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vmap_ldinfo
parameter_list|(
name|LdInfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|vmap
modifier|*
name|add_vmap
parameter_list|(
name|LdInfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|objfile_symbol_add
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vmap_symtab
parameter_list|(
name|struct
name|vmap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fetch_core_registers
parameter_list|(
name|char
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|,
name|int
parameter_list|,
name|CORE_ADDR
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|exec_one_dummy_insn
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|fixup_breakpoints
parameter_list|(
name|CORE_ADDR
name|low
parameter_list|,
name|CORE_ADDR
name|high
parameter_list|,
name|CORE_ADDR
name|delta
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Given REGNO, a gdb register number, return the corresponding    number suitable for use as a ptrace() parameter.  Return -1 if    there's no suitable mapping.  Also, set the int pointed to by    ISFLOAT to indicate whether REGNO is a floating point register.  */
end_comment

begin_function
specifier|static
name|int
name|regmap
parameter_list|(
name|int
name|regno
parameter_list|,
name|int
modifier|*
name|isfloat
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
operator|*
name|isfloat
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tdep
operator|->
name|ppc_gp0_regnum
operator|<=
name|regno
operator|&&
name|regno
operator|<=
name|tdep
operator|->
name|ppc_gplast_regnum
condition|)
return|return
name|regno
return|;
elseif|else
if|if
condition|(
name|FP0_REGNUM
operator|<=
name|regno
operator|&&
name|regno
operator|<=
name|FPLAST_REGNUM
condition|)
block|{
operator|*
name|isfloat
operator|=
literal|1
expr_stmt|;
return|return
name|regno
operator|-
name|FP0_REGNUM
operator|+
name|FPR0
return|;
block|}
elseif|else
if|if
condition|(
name|regno
operator|==
name|PC_REGNUM
condition|)
return|return
name|IAR
return|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|tdep
operator|->
name|ppc_ps_regnum
condition|)
return|return
name|MSR
return|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|tdep
operator|->
name|ppc_cr_regnum
condition|)
return|return
name|CR
return|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|tdep
operator|->
name|ppc_lr_regnum
condition|)
return|return
name|LR
return|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|tdep
operator|->
name|ppc_ctr_regnum
condition|)
return|return
name|CTR
return|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|tdep
operator|->
name|ppc_xer_regnum
condition|)
return|return
name|XER
return|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|tdep
operator|->
name|ppc_fpscr_regnum
condition|)
return|return
name|FPSCR
return|;
elseif|else
if|if
condition|(
name|tdep
operator|->
name|ppc_mq_regnum
operator|>=
literal|0
operator|&&
name|regno
operator|==
name|tdep
operator|->
name|ppc_mq_regnum
condition|)
return|return
name|MQ
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Call ptrace(REQ, ID, ADDR, DATA, BUF). */
end_comment

begin_function
specifier|static
name|int
name|rs6000_ptrace32
parameter_list|(
name|int
name|req
parameter_list|,
name|int
name|id
parameter_list|,
name|int
modifier|*
name|addr
parameter_list|,
name|int
name|data
parameter_list|,
name|int
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|ret
init|=
name|ptrace
argument_list|(
name|req
argument_list|,
name|id
argument_list|,
operator|(
name|int
operator|*
operator|)
name|addr
argument_list|,
name|data
argument_list|,
name|buf
argument_list|)
decl_stmt|;
if|#
directive|if
literal|0
block|printf ("rs6000_ptrace32 (%d, %d, 0x%x, %08x, 0x%x) = 0x%x\n", 	  req, id, (unsigned int)addr, data, (unsigned int)buf, ret);
endif|#
directive|endif
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Call ptracex(REQ, ID, ADDR, DATA, BUF). */
end_comment

begin_function
specifier|static
name|int
name|rs6000_ptrace64
parameter_list|(
name|int
name|req
parameter_list|,
name|int
name|id
parameter_list|,
name|long
name|long
name|addr
parameter_list|,
name|int
name|data
parameter_list|,
name|int
modifier|*
name|buf
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ARCH3264
name|int
name|ret
init|=
name|ptracex
argument_list|(
name|req
argument_list|,
name|id
argument_list|,
name|addr
argument_list|,
name|data
argument_list|,
name|buf
argument_list|)
decl_stmt|;
else|#
directive|else
name|int
name|ret
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
block|printf ("rs6000_ptrace64 (%d, %d, 0x%llx, %08x, 0x%x) = 0x%x\n", 	  req, id, addr, data, (unsigned int)buf, ret);
endif|#
directive|endif
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* Fetch register REGNO from the inferior. */
end_comment

begin_function
specifier|static
name|void
name|fetch_register
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|int
name|addr
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|int
name|nr
decl_stmt|,
name|isfloat
decl_stmt|;
comment|/* Retrieved values may be -1, so infer errors from errno. */
name|errno
operator|=
literal|0
expr_stmt|;
name|nr
operator|=
name|regmap
argument_list|(
name|regno
argument_list|,
operator|&
name|isfloat
argument_list|)
expr_stmt|;
comment|/* Floating-point registers. */
if|if
condition|(
name|isfloat
condition|)
name|rs6000_ptrace32
argument_list|(
name|PT_READ_FPR
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|addr
argument_list|,
name|nr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Bogus register number. */
elseif|else
if|if
condition|(
name|nr
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|regno
operator|>=
name|NUM_REGS
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"gdb error: register no %d not implemented.\n"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Fixed-point registers. */
else|else
block|{
if|if
condition|(
operator|!
name|ARCH64
argument_list|()
condition|)
operator|*
name|addr
operator|=
name|rs6000_ptrace32
argument_list|(
name|PT_READ_GPR
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
operator|(
name|int
operator|*
operator|)
name|nr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* PT_READ_GPR requires the buffer parameter to point to long long, 	     even if the register is really only 32 bits. */
name|long
name|long
name|buf
decl_stmt|;
name|rs6000_ptrace64
argument_list|(
name|PT_READ_GPR
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|nr
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
operator|==
literal|8
condition|)
name|memcpy
argument_list|(
name|addr
argument_list|,
operator|&
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
else|else
operator|*
name|addr
operator|=
name|buf
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|errno
condition|)
name|supply_register
argument_list|(
name|regno
argument_list|,
operator|(
name|char
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
else|else
block|{
if|#
directive|if
literal|0
comment|/* FIXME: this happens 3 times at the start of each 64-bit program. */
block|perror ("ptrace read");
endif|#
directive|endif
name|errno
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Store register REGNO back into the inferior. */
end_comment

begin_function
specifier|static
name|void
name|store_register
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|int
name|addr
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|int
name|nr
decl_stmt|,
name|isfloat
decl_stmt|;
comment|/* Fetch the register's value from the register cache.  */
name|regcache_collect
argument_list|(
name|regno
argument_list|,
name|addr
argument_list|)
expr_stmt|;
comment|/* -1 can be a successful return value, so infer errors from errno. */
name|errno
operator|=
literal|0
expr_stmt|;
name|nr
operator|=
name|regmap
argument_list|(
name|regno
argument_list|,
operator|&
name|isfloat
argument_list|)
expr_stmt|;
comment|/* Floating-point registers. */
if|if
condition|(
name|isfloat
condition|)
name|rs6000_ptrace32
argument_list|(
name|PT_WRITE_FPR
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|addr
argument_list|,
name|nr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Bogus register number. */
elseif|else
if|if
condition|(
name|nr
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|regno
operator|>=
name|NUM_REGS
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"gdb error: register no %d not implemented.\n"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
comment|/* Fixed-point registers. */
else|else
block|{
if|if
condition|(
name|regno
operator|==
name|SP_REGNUM
condition|)
comment|/* Execute one dummy instruction (which is a breakpoint) in inferior 	   process to give kernel a chance to do internal housekeeping. 	   Otherwise the following ptrace(2) calls will mess up user stack 	   since kernel will get confused about the bottom of the stack 	   (%sp). */
name|exec_one_dummy_insn
argument_list|()
expr_stmt|;
comment|/* The PT_WRITE_GPR operation is rather odd.  For 32-bit inferiors,          the register's value is passed by value, but for 64-bit inferiors, 	 the address of a buffer containing the value is passed.  */
if|if
condition|(
operator|!
name|ARCH64
argument_list|()
condition|)
name|rs6000_ptrace32
argument_list|(
name|PT_WRITE_GPR
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
operator|(
name|int
operator|*
operator|)
name|nr
argument_list|,
operator|*
name|addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* PT_WRITE_GPR requires the buffer parameter to point to an 8-byte 	     area, even if the register is really only 32 bits. */
name|long
name|long
name|buf
decl_stmt|;
if|if
condition|(
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
operator|==
literal|8
condition|)
name|memcpy
argument_list|(
operator|&
name|buf
argument_list|,
name|addr
argument_list|,
literal|8
argument_list|)
expr_stmt|;
else|else
name|buf
operator|=
operator|*
name|addr
expr_stmt|;
name|rs6000_ptrace64
argument_list|(
name|PT_WRITE_GPR
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|nr
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errno
condition|)
block|{
name|perror
argument_list|(
literal|"ptrace write"
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Read from the inferior all registers if REGNO == -1 and just register    REGNO otherwise. */
end_comment

begin_function
name|void
name|fetch_inferior_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
name|regno
operator|!=
operator|-
literal|1
condition|)
name|fetch_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
comment|/* Read 32 general purpose registers.  */
for|for
control|(
name|regno
operator|=
name|tdep
operator|->
name|ppc_gp0_regnum
init|;
name|regno
operator|<=
name|tdep
operator|->
name|ppc_gplast_regnum
condition|;
name|regno
operator|++
control|)
block|{
name|fetch_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
comment|/* Read general purpose floating point registers.  */
for|for
control|(
name|regno
operator|=
name|FP0_REGNUM
init|;
name|regno
operator|<=
name|FPLAST_REGNUM
condition|;
name|regno
operator|++
control|)
name|fetch_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
comment|/* Read special registers.  */
name|fetch_register
argument_list|(
name|PC_REGNUM
argument_list|)
expr_stmt|;
name|fetch_register
argument_list|(
name|tdep
operator|->
name|ppc_ps_regnum
argument_list|)
expr_stmt|;
name|fetch_register
argument_list|(
name|tdep
operator|->
name|ppc_cr_regnum
argument_list|)
expr_stmt|;
name|fetch_register
argument_list|(
name|tdep
operator|->
name|ppc_lr_regnum
argument_list|)
expr_stmt|;
name|fetch_register
argument_list|(
name|tdep
operator|->
name|ppc_ctr_regnum
argument_list|)
expr_stmt|;
name|fetch_register
argument_list|(
name|tdep
operator|->
name|ppc_xer_regnum
argument_list|)
expr_stmt|;
name|fetch_register
argument_list|(
name|tdep
operator|->
name|ppc_fpscr_regnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdep
operator|->
name|ppc_mq_regnum
operator|>=
literal|0
condition|)
name|fetch_register
argument_list|(
name|tdep
operator|->
name|ppc_mq_regnum
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Store our register values back into the inferior.    If REGNO is -1, do this for all registers.    Otherwise, REGNO specifies which register (so we can save time).  */
end_comment

begin_function
name|void
name|store_inferior_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
name|regno
operator|!=
operator|-
literal|1
condition|)
name|store_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
comment|/* Write general purpose registers first.  */
for|for
control|(
name|regno
operator|=
name|tdep
operator|->
name|ppc_gp0_regnum
init|;
name|regno
operator|<=
name|tdep
operator|->
name|ppc_gplast_regnum
condition|;
name|regno
operator|++
control|)
block|{
name|store_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
comment|/* Write floating point registers.  */
for|for
control|(
name|regno
operator|=
name|FP0_REGNUM
init|;
name|regno
operator|<=
name|FPLAST_REGNUM
condition|;
name|regno
operator|++
control|)
name|store_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
comment|/* Write special registers.  */
name|store_register
argument_list|(
name|PC_REGNUM
argument_list|)
expr_stmt|;
name|store_register
argument_list|(
name|tdep
operator|->
name|ppc_ps_regnum
argument_list|)
expr_stmt|;
name|store_register
argument_list|(
name|tdep
operator|->
name|ppc_cr_regnum
argument_list|)
expr_stmt|;
name|store_register
argument_list|(
name|tdep
operator|->
name|ppc_lr_regnum
argument_list|)
expr_stmt|;
name|store_register
argument_list|(
name|tdep
operator|->
name|ppc_ctr_regnum
argument_list|)
expr_stmt|;
name|store_register
argument_list|(
name|tdep
operator|->
name|ppc_xer_regnum
argument_list|)
expr_stmt|;
name|store_register
argument_list|(
name|tdep
operator|->
name|ppc_fpscr_regnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdep
operator|->
name|ppc_mq_regnum
operator|>=
literal|0
condition|)
name|store_register
argument_list|(
name|tdep
operator|->
name|ppc_mq_regnum
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Store in *TO the 32-bit word at 32-bit-aligned ADDR in the child    process, which is 64-bit if ARCH64 and 32-bit otherwise.  Return    success. */
end_comment

begin_function
specifier|static
name|int
name|read_word
parameter_list|(
name|CORE_ADDR
name|from
parameter_list|,
name|int
modifier|*
name|to
parameter_list|,
name|int
name|arch64
parameter_list|)
block|{
comment|/* Retrieved values may be -1, so infer errors from errno. */
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|arch64
condition|)
operator|*
name|to
operator|=
name|rs6000_ptrace64
argument_list|(
name|PT_READ_I
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|from
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
operator|*
name|to
operator|=
name|rs6000_ptrace32
argument_list|(
name|PT_READ_I
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|(
name|long
operator|)
name|from
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|!
name|errno
return|;
block|}
end_function

begin_comment
comment|/* Copy LEN bytes to or from inferior's memory starting at MEMADDR    to debugger memory starting at MYADDR.  Copy to inferior if    WRITE is nonzero.     Returns the length copied, which is either the LEN argument or zero.    This xfer function does not do partial moves, since child_ops    doesn't allow memory operations to cross below us in the target stack    anyway.  */
end_comment

begin_function
name|int
name|child_xfer_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|write
parameter_list|,
name|struct
name|mem_attrib
modifier|*
name|attrib
parameter_list|,
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
block|{
comment|/* Round starting address down to 32-bit word boundary. */
name|int
name|mask
init|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
decl_stmt|;
name|CORE_ADDR
name|addr
init|=
name|memaddr
operator|&
operator|~
operator|(
name|CORE_ADDR
operator|)
name|mask
decl_stmt|;
comment|/* Round ending address up to 32-bit word boundary. */
name|int
name|count
init|=
operator|(
operator|(
name|memaddr
operator|+
name|len
operator|-
name|addr
operator|+
name|mask
operator|)
operator|&
operator|~
operator|(
name|CORE_ADDR
operator|)
name|mask
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
comment|/* Allocate word transfer buffer. */
comment|/* FIXME (alloca): This code, cloned from infptrace.c, is unsafe      because it uses alloca to allocate a buffer of arbitrary size.      For very large xfers, this could crash GDB's stack.  */
name|int
modifier|*
name|buf
init|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|arch64
init|=
name|ARCH64
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|write
condition|)
block|{
comment|/* Retrieve memory a word at a time. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|read_word
argument_list|(
name|addr
argument_list|,
name|buf
operator|+
name|i
argument_list|,
name|arch64
argument_list|)
condition|)
return|return
literal|0
return|;
name|QUIT
expr_stmt|;
block|}
comment|/* Copy memory to supplied buffer. */
name|addr
operator|-=
name|count
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|myaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
operator|(
name|memaddr
operator|-
name|addr
operator|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Fetch leading memory needed for alignment. */
if|if
condition|(
name|addr
operator|<
name|memaddr
condition|)
if|if
condition|(
operator|!
name|read_word
argument_list|(
name|addr
argument_list|,
name|buf
argument_list|,
name|arch64
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Fetch trailing memory needed for alignment. */
if|if
condition|(
name|addr
operator|+
name|count
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|>
name|memaddr
operator|+
name|len
condition|)
if|if
condition|(
operator|!
name|read_word
argument_list|(
name|addr
operator|+
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|buf
operator|+
name|count
operator|-
literal|1
argument_list|,
name|arch64
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Copy supplied data into memory buffer. */
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
operator|(
name|memaddr
operator|-
name|addr
operator|)
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Store memory one word at a time. */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|errno
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
control|)
block|{
if|if
condition|(
name|arch64
condition|)
name|rs6000_ptrace64
argument_list|(
name|PT_WRITE_D
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|addr
argument_list|,
name|buf
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|rs6000_ptrace32
argument_list|(
name|PT_WRITE_D
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|(
name|long
operator|)
name|addr
argument_list|,
name|buf
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
return|return
literal|0
return|;
name|QUIT
expr_stmt|;
block|}
block|}
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* Execute one dummy breakpoint instruction.  This way we give the kernel    a chance to do some housekeeping and update inferior's internal data,    including u_area. */
end_comment

begin_function
specifier|static
name|void
name|exec_one_dummy_insn
parameter_list|(
name|void
parameter_list|)
block|{
define|#
directive|define
name|DUMMY_INSN_ADDR
value|(TEXT_SEGMENT_BASE)+0x200
name|char
name|shadow_contents
index|[
name|BREAKPOINT_MAX
index|]
decl_stmt|;
comment|/* Stash old bkpt addr contents */
name|int
name|ret
decl_stmt|,
name|status
decl_stmt|,
name|pid
decl_stmt|;
name|CORE_ADDR
name|prev_pc
decl_stmt|;
comment|/* We plant one dummy breakpoint into DUMMY_INSN_ADDR address. We      assume that this address will never be executed again by the real      code. */
name|target_insert_breakpoint
argument_list|(
name|DUMMY_INSN_ADDR
argument_list|,
name|shadow_contents
argument_list|)
expr_stmt|;
comment|/* You might think this could be done with a single ptrace call, and      you'd be correct for just about every platform I've ever worked      on.  However, rs6000-ibm-aix4.1.3 seems to have screwed this up --      the inferior never hits the breakpoint (it's also worth noting      powerpc-ibm-aix4.1.3 works correctly).  */
name|prev_pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
name|write_pc
argument_list|(
name|DUMMY_INSN_ADDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ARCH64
argument_list|()
condition|)
name|ret
operator|=
name|rs6000_ptrace64
argument_list|(
name|PT_CONTINUE
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|rs6000_ptrace32
argument_list|(
name|PT_CONTINUE
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|perror
argument_list|(
literal|"pt_continue"
argument_list|)
expr_stmt|;
do|do
block|{
name|pid
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|pid
operator|!=
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
condition|)
do|;
name|write_pc
argument_list|(
name|prev_pc
argument_list|)
expr_stmt|;
name|target_remove_breakpoint
argument_list|(
name|DUMMY_INSN_ADDR
argument_list|,
name|shadow_contents
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fetch registers from the register section in core bfd. */
end_comment

begin_function
specifier|static
name|void
name|fetch_core_registers
parameter_list|(
name|char
modifier|*
name|core_reg_sect
parameter_list|,
name|unsigned
name|core_reg_size
parameter_list|,
name|int
name|which
parameter_list|,
name|CORE_ADDR
name|reg_addr
parameter_list|)
block|{
name|CoreRegs
modifier|*
name|regs
decl_stmt|;
name|int
name|regi
decl_stmt|;
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|current_gdbarch
argument_list|)
decl_stmt|;
if|if
condition|(
name|which
operator|!=
literal|0
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Gdb error: unknown parameter to fetch_core_registers().\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|regs
operator|=
operator|(
name|CoreRegs
operator|*
operator|)
name|core_reg_sect
expr_stmt|;
comment|/* Put the register values from the core file section in the regcache.  */
if|if
condition|(
name|ARCH64
argument_list|()
condition|)
block|{
for|for
control|(
name|regi
operator|=
literal|0
init|;
name|regi
operator|<
literal|32
condition|;
name|regi
operator|++
control|)
name|supply_register
argument_list|(
name|regi
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|regs
operator|->
name|r64
operator|.
name|gpr
index|[
name|regi
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|regi
operator|=
literal|0
init|;
name|regi
operator|<
literal|32
condition|;
name|regi
operator|++
control|)
name|supply_register
argument_list|(
name|FP0_REGNUM
operator|+
name|regi
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|regs
operator|->
name|r64
operator|.
name|fpr
index|[
name|regi
index|]
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|PC_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|regs
operator|->
name|r64
operator|.
name|iar
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|tdep
operator|->
name|ppc_ps_regnum
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|regs
operator|->
name|r64
operator|.
name|msr
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|tdep
operator|->
name|ppc_cr_regnum
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|regs
operator|->
name|r64
operator|.
name|cr
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|tdep
operator|->
name|ppc_lr_regnum
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|regs
operator|->
name|r64
operator|.
name|lr
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|tdep
operator|->
name|ppc_ctr_regnum
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|regs
operator|->
name|r64
operator|.
name|ctr
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|tdep
operator|->
name|ppc_xer_regnum
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|regs
operator|->
name|r64
operator|.
name|xer
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|tdep
operator|->
name|ppc_fpscr_regnum
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|regs
operator|->
name|r64
operator|.
name|fpscr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|regi
operator|=
literal|0
init|;
name|regi
operator|<
literal|32
condition|;
name|regi
operator|++
control|)
name|supply_register
argument_list|(
name|regi
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|regs
operator|->
name|r32
operator|.
name|gpr
index|[
name|regi
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|regi
operator|=
literal|0
init|;
name|regi
operator|<
literal|32
condition|;
name|regi
operator|++
control|)
name|supply_register
argument_list|(
name|FP0_REGNUM
operator|+
name|regi
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|regs
operator|->
name|r32
operator|.
name|fpr
index|[
name|regi
index|]
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|PC_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|regs
operator|->
name|r32
operator|.
name|iar
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|tdep
operator|->
name|ppc_ps_regnum
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|regs
operator|->
name|r32
operator|.
name|msr
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|tdep
operator|->
name|ppc_cr_regnum
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|regs
operator|->
name|r32
operator|.
name|cr
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|tdep
operator|->
name|ppc_lr_regnum
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|regs
operator|->
name|r32
operator|.
name|lr
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|tdep
operator|->
name|ppc_ctr_regnum
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|regs
operator|->
name|r32
operator|.
name|ctr
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|tdep
operator|->
name|ppc_xer_regnum
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|regs
operator|->
name|r32
operator|.
name|xer
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|tdep
operator|->
name|ppc_fpscr_regnum
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|regs
operator|->
name|r32
operator|.
name|fpscr
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdep
operator|->
name|ppc_mq_regnum
operator|>=
literal|0
condition|)
name|supply_register
argument_list|(
name|tdep
operator|->
name|ppc_mq_regnum
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|regs
operator|->
name|r32
operator|.
name|mq
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copy information about text and data sections from LDI to VP for a 64-bit    process if ARCH64 and for a 32-bit process otherwise. */
end_comment

begin_function
specifier|static
name|void
name|vmap_secs
parameter_list|(
name|struct
name|vmap
modifier|*
name|vp
parameter_list|,
name|LdInfo
modifier|*
name|ldi
parameter_list|,
name|int
name|arch64
parameter_list|)
block|{
if|if
condition|(
name|arch64
condition|)
block|{
name|vp
operator|->
name|tstart
operator|=
operator|(
name|CORE_ADDR
operator|)
name|ldi
operator|->
name|l64
operator|.
name|ldinfo_textorg
expr_stmt|;
name|vp
operator|->
name|tend
operator|=
name|vp
operator|->
name|tstart
operator|+
name|ldi
operator|->
name|l64
operator|.
name|ldinfo_textsize
expr_stmt|;
name|vp
operator|->
name|dstart
operator|=
operator|(
name|CORE_ADDR
operator|)
name|ldi
operator|->
name|l64
operator|.
name|ldinfo_dataorg
expr_stmt|;
name|vp
operator|->
name|dend
operator|=
name|vp
operator|->
name|dstart
operator|+
name|ldi
operator|->
name|l64
operator|.
name|ldinfo_datasize
expr_stmt|;
block|}
else|else
block|{
name|vp
operator|->
name|tstart
operator|=
operator|(
name|unsigned
name|long
operator|)
name|ldi
operator|->
name|l32
operator|.
name|ldinfo_textorg
expr_stmt|;
name|vp
operator|->
name|tend
operator|=
name|vp
operator|->
name|tstart
operator|+
name|ldi
operator|->
name|l32
operator|.
name|ldinfo_textsize
expr_stmt|;
name|vp
operator|->
name|dstart
operator|=
operator|(
name|unsigned
name|long
operator|)
name|ldi
operator|->
name|l32
operator|.
name|ldinfo_dataorg
expr_stmt|;
name|vp
operator|->
name|dend
operator|=
name|vp
operator|->
name|dstart
operator|+
name|ldi
operator|->
name|l32
operator|.
name|ldinfo_datasize
expr_stmt|;
block|}
comment|/* The run time loader maps the file header in addition to the text      section and returns a pointer to the header in ldinfo_textorg.      Adjust the text start address to point to the real start address      of the text section.  */
name|vp
operator|->
name|tstart
operator|+=
name|vp
operator|->
name|toffs
expr_stmt|;
block|}
end_function

begin_comment
comment|/* handle symbol translation on vmapping */
end_comment

begin_function
specifier|static
name|void
name|vmap_symtab
parameter_list|(
name|struct
name|vmap
modifier|*
name|vp
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|new_offsets
decl_stmt|;
name|int
name|i
decl_stmt|;
name|objfile
operator|=
name|vp
operator|->
name|objfile
expr_stmt|;
if|if
condition|(
name|objfile
operator|==
name|NULL
condition|)
block|{
comment|/* OK, it's not an objfile we opened ourselves.          Currently, that can only happen with the exec file, so          relocate the symbols for the symfile.  */
if|if
condition|(
name|symfile_objfile
operator|==
name|NULL
condition|)
return|return;
name|objfile
operator|=
name|symfile_objfile
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|vp
operator|->
name|loaded
condition|)
comment|/* If symbols are not yet loaded, offsets are not yet valid. */
return|return;
name|new_offsets
operator|=
operator|(
expr|struct
name|section_offsets
operator|*
operator|)
name|alloca
argument_list|(
name|SIZEOF_N_SECTION_OFFSETS
argument_list|(
name|objfile
operator|->
name|num_sections
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|objfile
operator|->
name|num_sections
condition|;
operator|++
name|i
control|)
name|new_offsets
operator|->
name|offsets
index|[
name|i
index|]
operator|=
name|ANOFFSET
argument_list|(
name|objfile
operator|->
name|section_offsets
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* The symbols in the object file are linked to the VMA of the section,      relocate them VMA relative.  */
name|new_offsets
operator|->
name|offsets
index|[
name|SECT_OFF_TEXT
argument_list|(
name|objfile
argument_list|)
index|]
operator|=
name|vp
operator|->
name|tstart
operator|-
name|vp
operator|->
name|tvma
expr_stmt|;
name|new_offsets
operator|->
name|offsets
index|[
name|SECT_OFF_DATA
argument_list|(
name|objfile
argument_list|)
index|]
operator|=
name|vp
operator|->
name|dstart
operator|-
name|vp
operator|->
name|dvma
expr_stmt|;
name|new_offsets
operator|->
name|offsets
index|[
name|SECT_OFF_BSS
argument_list|(
name|objfile
argument_list|)
index|]
operator|=
name|vp
operator|->
name|dstart
operator|-
name|vp
operator|->
name|dvma
expr_stmt|;
name|objfile_relocate
argument_list|(
name|objfile
argument_list|,
name|new_offsets
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Add symbols for an objfile.  */
end_comment

begin_function
specifier|static
name|int
name|objfile_symbol_add
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|obj
init|=
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|arg
decl_stmt|;
name|syms_from_objfile
argument_list|(
name|obj
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|new_symfile_objfile
argument_list|(
name|obj
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Add symbols for a vmap. Return zero upon error.  */
end_comment

begin_function
name|int
name|vmap_add_symbols
parameter_list|(
name|struct
name|vmap
modifier|*
name|vp
parameter_list|)
block|{
if|if
condition|(
name|catch_errors
argument_list|(
name|objfile_symbol_add
argument_list|,
name|vp
operator|->
name|objfile
argument_list|,
literal|"Error while reading shared library symbols:\n"
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
condition|)
block|{
comment|/* Note this is only done if symbol reading was successful.  */
name|vp
operator|->
name|loaded
operator|=
literal|1
expr_stmt|;
name|vmap_symtab
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Add a new vmap entry based on ldinfo() information.     If ldi->ldinfo_fd is not valid (e.g. this struct ld_info is from a    core file), the caller should set it to -1, and we will open the file.     Return the vmap new entry.  */
end_comment

begin_function
specifier|static
name|struct
name|vmap
modifier|*
name|add_vmap
parameter_list|(
name|LdInfo
modifier|*
name|ldi
parameter_list|)
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|char
modifier|*
name|mem
decl_stmt|,
modifier|*
name|objname
decl_stmt|,
modifier|*
name|filename
decl_stmt|;
name|struct
name|objfile
modifier|*
name|obj
decl_stmt|;
name|struct
name|vmap
modifier|*
name|vp
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|ARCH64_DECL
argument_list|(
name|arch64
argument_list|)
expr_stmt|;
comment|/* This ldi structure was allocated using alloca() in       xcoff_relocate_symtab(). Now we need to have persistent object       and member names, so we should save them. */
name|filename
operator|=
name|LDI_FILENAME
argument_list|(
name|ldi
argument_list|,
name|arch64
argument_list|)
expr_stmt|;
name|mem
operator|=
name|filename
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|1
expr_stmt|;
name|mem
operator|=
name|savestring
argument_list|(
name|mem
argument_list|,
name|strlen
argument_list|(
name|mem
argument_list|)
argument_list|)
expr_stmt|;
name|objname
operator|=
name|savestring
argument_list|(
name|filename
argument_list|,
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|)
expr_stmt|;
name|fd
operator|=
name|LDI_FD
argument_list|(
name|ldi
argument_list|,
name|arch64
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
comment|/* Note that this opens it once for every member; a possible        enhancement would be to only open it once for every object.  */
name|abfd
operator|=
name|bfd_openr
argument_list|(
name|objname
argument_list|,
name|gnutarget
argument_list|)
expr_stmt|;
else|else
name|abfd
operator|=
name|bfd_fdopenr
argument_list|(
name|objname
argument_list|,
name|gnutarget
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abfd
condition|)
block|{
name|warning
argument_list|(
literal|"Could not open `%s' as an executable file: %s"
argument_list|,
name|objname
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* make sure we have an object file */
if|if
condition|(
name|bfd_check_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
name|vp
operator|=
name|map_vmap
argument_list|(
name|abfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_check_format
argument_list|(
name|abfd
argument_list|,
name|bfd_archive
argument_list|)
condition|)
block|{
name|last
operator|=
literal|0
expr_stmt|;
comment|/* FIXME??? am I tossing BFDs?  bfd? */
while|while
condition|(
operator|(
name|last
operator|=
name|bfd_openr_next_archived_file
argument_list|(
name|abfd
argument_list|,
name|last
argument_list|)
operator|)
condition|)
if|if
condition|(
name|DEPRECATED_STREQ
argument_list|(
name|mem
argument_list|,
name|last
operator|->
name|filename
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|last
condition|)
block|{
name|warning
argument_list|(
literal|"\"%s\": member \"%s\" missing."
argument_list|,
name|objname
argument_list|,
name|mem
argument_list|)
expr_stmt|;
name|bfd_close
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|last
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"\"%s\": member \"%s\" not in executable format: %s."
argument_list|,
name|objname
argument_list|,
name|mem
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_close
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|bfd_close
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|vp
operator|=
name|map_vmap
argument_list|(
name|last
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"\"%s\": not in executable format: %s."
argument_list|,
name|objname
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_close
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|obj
operator|=
name|allocate_objfile
argument_list|(
name|vp
operator|->
name|bfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vp
operator|->
name|objfile
operator|=
name|obj
expr_stmt|;
comment|/* Always add symbols for the main objfile.  */
if|if
condition|(
name|vp
operator|==
name|vmap
operator|||
name|auto_solib_add
condition|)
name|vmap_add_symbols
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
name|vp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* update VMAP info with ldinfo() information    Input is ptr to ldinfo() results.  */
end_comment

begin_function
specifier|static
name|void
name|vmap_ldinfo
parameter_list|(
name|LdInfo
modifier|*
name|ldi
parameter_list|)
block|{
name|struct
name|stat
name|ii
decl_stmt|,
name|vi
decl_stmt|;
name|struct
name|vmap
modifier|*
name|vp
decl_stmt|;
name|int
name|got_one
decl_stmt|,
name|retried
decl_stmt|;
name|int
name|got_exec_file
init|=
literal|0
decl_stmt|;
name|uint
name|next
decl_stmt|;
name|int
name|arch64
init|=
name|ARCH64
argument_list|()
decl_stmt|;
comment|/* For each *ldi, see if we have a corresponding *vp.      If so, update the mapping, and symbol table.      If not, add an entry and symbol table.  */
do|do
block|{
name|char
modifier|*
name|name
init|=
name|LDI_FILENAME
argument_list|(
name|ldi
argument_list|,
name|arch64
argument_list|)
decl_stmt|;
name|char
modifier|*
name|memb
init|=
name|name
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
decl_stmt|;
name|int
name|fd
init|=
name|LDI_FD
argument_list|(
name|ldi
argument_list|,
name|arch64
argument_list|)
decl_stmt|;
name|retried
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|ii
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* The kernel sets ld_info to -1, if the process is still using the 	     object, and the object is removed. Keep the symbol info for the 	     removed object and issue a warning.  */
name|warning
argument_list|(
literal|"%s (fd=%d) has disappeared, keeping its symbols"
argument_list|,
name|name
argument_list|,
name|fd
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|retry
label|:
for|for
control|(
name|got_one
operator|=
literal|0
operator|,
name|vp
operator|=
name|vmap
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|nxt
control|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
comment|/* First try to find a `vp', which is the same as in ldinfo. 	     If not the same, just continue and grep the next `vp'. If same, 	     relocate its tstart, tend, dstart, dend values. If no such `vp' 	     found, get out of this for loop, add this ldi entry as a new vmap 	     (add_vmap) and come back, find its `vp' and so on... */
comment|/* The filenames are not always sufficient to match on. */
if|if
condition|(
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
operator|!
name|DEPRECATED_STREQ
argument_list|(
name|name
argument_list|,
name|vp
operator|->
name|name
argument_list|)
operator|)
operator|||
operator|(
name|memb
index|[
literal|0
index|]
operator|&&
operator|!
name|DEPRECATED_STREQ
argument_list|(
name|memb
argument_list|,
name|vp
operator|->
name|member
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* See if we are referring to the same file. 	     We have to check objfile->obfd, symfile.c:reread_symbols might 	     have updated the obfd after a change.  */
name|objfile
operator|=
name|vp
operator|->
name|objfile
operator|==
name|NULL
condition|?
name|symfile_objfile
else|:
name|vp
operator|->
name|objfile
expr_stmt|;
if|if
condition|(
name|objfile
operator|==
name|NULL
operator|||
name|objfile
operator|->
name|obfd
operator|==
name|NULL
operator|||
name|bfd_stat
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|vi
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to stat %s, keeping its symbols"
argument_list|,
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ii
operator|.
name|st_dev
operator|!=
name|vi
operator|.
name|st_dev
operator|||
name|ii
operator|.
name|st_ino
operator|!=
name|vi
operator|.
name|st_ino
condition|)
continue|continue;
if|if
condition|(
operator|!
name|retried
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
operator|++
name|got_one
expr_stmt|;
comment|/* Found a corresponding VMAP.  Remap!  */
name|vmap_secs
argument_list|(
name|vp
argument_list|,
name|ldi
argument_list|,
name|arch64
argument_list|)
expr_stmt|;
comment|/* The objfile is only NULL for the exec file.  */
if|if
condition|(
name|vp
operator|->
name|objfile
operator|==
name|NULL
condition|)
name|got_exec_file
operator|=
literal|1
expr_stmt|;
comment|/* relocate symbol table(s). */
name|vmap_symtab
argument_list|(
name|vp
argument_list|)
expr_stmt|;
comment|/* Announce new object files.  Doing this after symbol relocation 	     makes aix-thread.c's job easier. */
if|if
condition|(
name|target_new_objfile_hook
operator|&&
name|vp
operator|->
name|objfile
condition|)
name|target_new_objfile_hook
argument_list|(
name|vp
operator|->
name|objfile
argument_list|)
expr_stmt|;
comment|/* There may be more, so we don't break out of the loop.  */
block|}
comment|/* if there was no matching *vp, we must perforce create the sucker(s) */
if|if
condition|(
operator|!
name|got_one
operator|&&
operator|!
name|retried
condition|)
block|{
name|add_vmap
argument_list|(
name|ldi
argument_list|)
expr_stmt|;
operator|++
name|retried
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
do|while
condition|(
operator|(
name|next
operator|=
name|LDI_NEXT
argument_list|(
name|ldi
argument_list|,
name|arch64
argument_list|)
operator|)
operator|&&
operator|(
name|ldi
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|next
operator|+
operator|(
name|char
operator|*
operator|)
name|ldi
operator|)
operator|)
condition|)
do|;
comment|/* If we don't find the symfile_objfile anywhere in the ldinfo, it      is unlikely that the symbol file is relocated to the proper      address.  And we might have attached to a process which is      running a different copy of the same executable.  */
if|if
condition|(
name|symfile_objfile
operator|!=
name|NULL
operator|&&
operator|!
name|got_exec_file
condition|)
block|{
name|warning
argument_list|(
literal|"Symbol file %s\nis not mapped; discarding it.\n\ If in fact that file has symbols which the mapped files listed by\n\ \"info files\" lack, you can load symbols with the \"symbol-file\" or\n\ \"add-symbol-file\" commands (note that you must take care of relocating\n\ symbols to the proper address)."
argument_list|,
name|symfile_objfile
operator|->
name|name
argument_list|)
expr_stmt|;
name|free_objfile
argument_list|(
name|symfile_objfile
argument_list|)
expr_stmt|;
name|symfile_objfile
operator|=
name|NULL
expr_stmt|;
block|}
name|breakpoint_re_set
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* As well as symbol tables, exec_sections need relocation. After    the inferior process' termination, there will be a relocated symbol    table exist with no corresponding inferior process. At that time, we    need to use `exec' bfd, rather than the inferior process's memory space    to look up symbols.     `exec_sections' need to be relocated only once, as long as the exec    file remains unchanged.  */
end_comment

begin_function
specifier|static
name|void
name|vmap_exec
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|bfd
modifier|*
name|execbfd
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|execbfd
operator|==
name|exec_bfd
condition|)
return|return;
name|execbfd
operator|=
name|exec_bfd
expr_stmt|;
if|if
condition|(
operator|!
name|vmap
operator|||
operator|!
name|exec_ops
operator|.
name|to_sections
condition|)
name|error
argument_list|(
literal|"vmap_exec: vmap or exec_ops.to_sections == 0\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|&
name|exec_ops
operator|.
name|to_sections
index|[
name|i
index|]
operator|<
name|exec_ops
operator|.
name|to_sections_end
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|DEPRECATED_STREQ
argument_list|(
literal|".text"
argument_list|,
name|exec_ops
operator|.
name|to_sections
index|[
name|i
index|]
operator|.
name|the_bfd_section
operator|->
name|name
argument_list|)
condition|)
block|{
name|exec_ops
operator|.
name|to_sections
index|[
name|i
index|]
operator|.
name|addr
operator|+=
name|vmap
operator|->
name|tstart
operator|-
name|vmap
operator|->
name|tvma
expr_stmt|;
name|exec_ops
operator|.
name|to_sections
index|[
name|i
index|]
operator|.
name|endaddr
operator|+=
name|vmap
operator|->
name|tstart
operator|-
name|vmap
operator|->
name|tvma
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DEPRECATED_STREQ
argument_list|(
literal|".data"
argument_list|,
name|exec_ops
operator|.
name|to_sections
index|[
name|i
index|]
operator|.
name|the_bfd_section
operator|->
name|name
argument_list|)
condition|)
block|{
name|exec_ops
operator|.
name|to_sections
index|[
name|i
index|]
operator|.
name|addr
operator|+=
name|vmap
operator|->
name|dstart
operator|-
name|vmap
operator|->
name|dvma
expr_stmt|;
name|exec_ops
operator|.
name|to_sections
index|[
name|i
index|]
operator|.
name|endaddr
operator|+=
name|vmap
operator|->
name|dstart
operator|-
name|vmap
operator|->
name|dvma
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DEPRECATED_STREQ
argument_list|(
literal|".bss"
argument_list|,
name|exec_ops
operator|.
name|to_sections
index|[
name|i
index|]
operator|.
name|the_bfd_section
operator|->
name|name
argument_list|)
condition|)
block|{
name|exec_ops
operator|.
name|to_sections
index|[
name|i
index|]
operator|.
name|addr
operator|+=
name|vmap
operator|->
name|dstart
operator|-
name|vmap
operator|->
name|dvma
expr_stmt|;
name|exec_ops
operator|.
name|to_sections
index|[
name|i
index|]
operator|.
name|endaddr
operator|+=
name|vmap
operator|->
name|dstart
operator|-
name|vmap
operator|->
name|dvma
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Set the current architecture from the host running GDB.  Called when    starting a child process. */
end_comment

begin_function
specifier|static
name|void
name|set_host_arch
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
name|enum
name|bfd_architecture
name|arch
decl_stmt|;
name|unsigned
name|long
name|mach
decl_stmt|;
name|bfd
name|abfd
decl_stmt|;
name|struct
name|gdbarch_info
name|info
decl_stmt|;
if|if
condition|(
name|__power_rs
argument_list|()
condition|)
block|{
name|arch
operator|=
name|bfd_arch_rs6000
expr_stmt|;
name|mach
operator|=
name|bfd_mach_rs6k
expr_stmt|;
block|}
else|else
block|{
name|arch
operator|=
name|bfd_arch_powerpc
expr_stmt|;
name|mach
operator|=
name|bfd_mach_ppc
expr_stmt|;
block|}
comment|/* FIXME: schauer/2002-02-25:      We don't know if we are executing a 32 or 64 bit executable,      and have no way to pass the proper word size to rs6000_gdbarch_init.      So we have to avoid switching to a new architecture, if the architecture      matches already.      Blindly calling rs6000_gdbarch_init used to work in older versions of      GDB, as rs6000_gdbarch_init incorrectly used the previous tdep to      determine the wordsize.  */
if|if
condition|(
name|exec_bfd
condition|)
block|{
specifier|const
name|struct
name|bfd_arch_info
modifier|*
name|exec_bfd_arch_info
decl_stmt|;
name|exec_bfd_arch_info
operator|=
name|bfd_get_arch_info
argument_list|(
name|exec_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|arch
operator|==
name|exec_bfd_arch_info
operator|->
name|arch
condition|)
return|return;
block|}
name|bfd_default_set_arch_mach
argument_list|(
operator|&
name|abfd
argument_list|,
name|arch
argument_list|,
name|mach
argument_list|)
expr_stmt|;
name|gdbarch_info_init
argument_list|(
operator|&
name|info
argument_list|)
expr_stmt|;
name|info
operator|.
name|bfd_arch_info
operator|=
name|bfd_get_arch_info
argument_list|(
operator|&
name|abfd
argument_list|)
expr_stmt|;
name|info
operator|.
name|abfd
operator|=
name|exec_bfd
expr_stmt|;
if|if
condition|(
operator|!
name|gdbarch_update_p
argument_list|(
name|info
argument_list|)
condition|)
block|{
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"set_host_arch: failed to select architecture"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* xcoff_relocate_symtab -      hook for symbol table relocation.    also reads shared libraries.. */
end_comment

begin_function
name|void
name|xcoff_relocate_symtab
parameter_list|(
name|unsigned
name|int
name|pid
parameter_list|)
block|{
name|int
name|load_segs
init|=
literal|64
decl_stmt|;
comment|/* number of load segments */
name|int
name|rc
decl_stmt|;
name|LdInfo
modifier|*
name|ldi
init|=
name|NULL
decl_stmt|;
name|int
name|arch64
init|=
name|ARCH64
argument_list|()
decl_stmt|;
name|int
name|ldisize
init|=
name|arch64
condition|?
sizeof|sizeof
argument_list|(
name|ldi
operator|->
name|l64
argument_list|)
else|:
sizeof|sizeof
argument_list|(
name|ldi
operator|->
name|l32
argument_list|)
decl_stmt|;
name|int
name|size
decl_stmt|;
do|do
block|{
name|size
operator|=
name|load_segs
operator|*
name|ldisize
expr_stmt|;
name|ldi
operator|=
operator|(
name|void
operator|*
operator|)
name|xrealloc
argument_list|(
name|ldi
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* According to my humble theory, AIX has some timing problems and          when the user stack grows, kernel doesn't update stack info in time          and ptrace calls step on user stack. That is why we sleep here a          little, and give kernel to update its internals. */
block|usleep (36000);
endif|#
directive|endif
if|if
condition|(
name|arch64
condition|)
name|rc
operator|=
name|rs6000_ptrace64
argument_list|(
name|PT_LDINFO
argument_list|,
name|pid
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ldi
argument_list|,
name|size
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|rc
operator|=
name|rs6000_ptrace32
argument_list|(
name|PT_LDINFO
argument_list|,
name|pid
argument_list|,
operator|(
name|int
operator|*
operator|)
name|ldi
argument_list|,
name|size
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
name|load_segs
operator|*=
literal|2
expr_stmt|;
else|else
name|perror_with_name
argument_list|(
literal|"ptrace ldinfo"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vmap_ldinfo
argument_list|(
name|ldi
argument_list|)
expr_stmt|;
name|vmap_exec
argument_list|()
expr_stmt|;
comment|/* relocate the exec and core sections as well. */
block|}
block|}
do|while
condition|(
name|rc
operator|==
operator|-
literal|1
condition|)
do|;
if|if
condition|(
name|ldi
condition|)
name|xfree
argument_list|(
name|ldi
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Core file stuff.  */
end_comment

begin_comment
comment|/* Relocate symtabs and read in shared library info, based on symbols    from the core file.  */
end_comment

begin_function
name|void
name|xcoff_relocate_core
parameter_list|(
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
block|{
name|struct
name|bfd_section
modifier|*
name|ldinfo_sec
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|LdInfo
modifier|*
name|ldi
decl_stmt|;
name|struct
name|vmap
modifier|*
name|vp
decl_stmt|;
name|int
name|arch64
init|=
name|ARCH64
argument_list|()
decl_stmt|;
comment|/* Size of a struct ld_info except for the variable-length filename. */
name|int
name|nonfilesz
init|=
operator|(
name|int
operator|)
name|LDI_FILENAME
argument_list|(
operator|(
name|LdInfo
operator|*
operator|)
literal|0
argument_list|,
name|arch64
argument_list|)
decl_stmt|;
comment|/* Allocated size of buffer.  */
name|int
name|buffer_size
init|=
name|nonfilesz
decl_stmt|;
name|char
modifier|*
name|buffer
init|=
name|xmalloc
argument_list|(
name|buffer_size
argument_list|)
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old
init|=
name|make_cleanup
argument_list|(
name|free_current_contents
argument_list|,
operator|&
name|buffer
argument_list|)
decl_stmt|;
name|ldinfo_sec
operator|=
name|bfd_get_section_by_name
argument_list|(
name|core_bfd
argument_list|,
literal|".ldinfo"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ldinfo_sec
operator|==
name|NULL
condition|)
block|{
name|bfd_err
label|:
name|fprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Couldn't get ldinfo from core file: %s\n"
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old
argument_list|)
expr_stmt|;
return|return;
block|}
do|do
block|{
name|int
name|i
decl_stmt|;
name|int
name|names_found
init|=
literal|0
decl_stmt|;
comment|/* Read in everything but the name.  */
if|if
condition|(
name|bfd_get_section_contents
argument_list|(
name|core_bfd
argument_list|,
name|ldinfo_sec
argument_list|,
name|buffer
argument_list|,
name|offset
argument_list|,
name|nonfilesz
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|bfd_err
goto|;
comment|/* Now the name.  */
name|i
operator|=
name|nonfilesz
expr_stmt|;
do|do
block|{
if|if
condition|(
name|i
operator|==
name|buffer_size
condition|)
block|{
name|buffer_size
operator|*=
literal|2
expr_stmt|;
name|buffer
operator|=
name|xrealloc
argument_list|(
name|buffer
argument_list|,
name|buffer_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bfd_get_section_contents
argument_list|(
name|core_bfd
argument_list|,
name|ldinfo_sec
argument_list|,
operator|&
name|buffer
index|[
name|i
index|]
argument_list|,
name|offset
operator|+
name|i
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|bfd_err
goto|;
if|if
condition|(
name|buffer
index|[
name|i
operator|++
index|]
operator|==
literal|'\0'
condition|)
operator|++
name|names_found
expr_stmt|;
block|}
do|while
condition|(
name|names_found
operator|<
literal|2
condition|)
do|;
name|ldi
operator|=
operator|(
name|LdInfo
operator|*
operator|)
name|buffer
expr_stmt|;
comment|/* Can't use a file descriptor from the core file; need to open it.  */
if|if
condition|(
name|arch64
condition|)
name|ldi
operator|->
name|l64
operator|.
name|ldinfo_fd
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|ldi
operator|->
name|l32
operator|.
name|ldinfo_fd
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* The first ldinfo is for the exec file, allocated elsewhere.  */
if|if
condition|(
name|offset
operator|==
literal|0
operator|&&
name|vmap
operator|!=
name|NULL
condition|)
name|vp
operator|=
name|vmap
expr_stmt|;
else|else
name|vp
operator|=
name|add_vmap
argument_list|(
name|ldi
argument_list|)
expr_stmt|;
comment|/* Process next shared library upon error. */
name|offset
operator|+=
name|LDI_NEXT
argument_list|(
name|ldi
argument_list|,
name|arch64
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
continue|continue;
name|vmap_secs
argument_list|(
name|vp
argument_list|,
name|ldi
argument_list|,
name|arch64
argument_list|)
expr_stmt|;
comment|/* Unless this is the exec file,          add our sections to the section table for the core target.  */
if|if
condition|(
name|vp
operator|!=
name|vmap
condition|)
block|{
name|struct
name|section_table
modifier|*
name|stp
decl_stmt|;
name|target_resize_to_sections
argument_list|(
name|target
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|stp
operator|=
name|target
operator|->
name|to_sections_end
operator|-
literal|2
expr_stmt|;
name|stp
operator|->
name|bfd
operator|=
name|vp
operator|->
name|bfd
expr_stmt|;
name|stp
operator|->
name|the_bfd_section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|stp
operator|->
name|bfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
name|stp
operator|->
name|addr
operator|=
name|vp
operator|->
name|tstart
expr_stmt|;
name|stp
operator|->
name|endaddr
operator|=
name|vp
operator|->
name|tend
expr_stmt|;
name|stp
operator|++
expr_stmt|;
name|stp
operator|->
name|bfd
operator|=
name|vp
operator|->
name|bfd
expr_stmt|;
name|stp
operator|->
name|the_bfd_section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|stp
operator|->
name|bfd
argument_list|,
literal|".data"
argument_list|)
expr_stmt|;
name|stp
operator|->
name|addr
operator|=
name|vp
operator|->
name|dstart
expr_stmt|;
name|stp
operator|->
name|endaddr
operator|=
name|vp
operator|->
name|dend
expr_stmt|;
block|}
name|vmap_symtab
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_new_objfile_hook
operator|&&
name|vp
operator|!=
name|vmap
operator|&&
name|vp
operator|->
name|objfile
condition|)
name|target_new_objfile_hook
argument_list|(
name|vp
operator|->
name|objfile
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|LDI_NEXT
argument_list|(
name|ldi
argument_list|,
name|arch64
argument_list|)
operator|!=
literal|0
condition|)
do|;
name|vmap_exec
argument_list|()
expr_stmt|;
name|breakpoint_re_set
argument_list|()
expr_stmt|;
name|do_cleanups
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|kernel_u_size
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|user
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Under AIX, we have to pass the correct TOC pointer to a function    when calling functions in the inferior.    We try to find the relative toc offset of the objfile containing PC    and add the current load address of the data segment from the vmap.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|find_toc_address
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|struct
name|vmap
modifier|*
name|vp
decl_stmt|;
specifier|extern
name|CORE_ADDR
name|get_toc_offset
argument_list|(
expr|struct
name|objfile
operator|*
argument_list|)
decl_stmt|;
comment|/* xcoffread.c */
for|for
control|(
name|vp
operator|=
name|vmap
init|;
name|vp
condition|;
name|vp
operator|=
name|vp
operator|->
name|nxt
control|)
block|{
if|if
condition|(
name|pc
operator|>=
name|vp
operator|->
name|tstart
operator|&&
name|pc
operator|<
name|vp
operator|->
name|tend
condition|)
block|{
comment|/* vp->objfile is only NULL for the exec file.  */
return|return
name|vp
operator|->
name|dstart
operator|+
name|get_toc_offset
argument_list|(
name|vp
operator|->
name|objfile
operator|==
name|NULL
condition|?
name|symfile_objfile
else|:
name|vp
operator|->
name|objfile
argument_list|)
return|;
block|}
block|}
name|error
argument_list|(
literal|"Unable to find TOC entry for pc %s\n"
argument_list|,
name|local_hex_string
argument_list|(
name|pc
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Register that we are able to handle rs6000 core file formats. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|core_fns
name|rs6000_core_fns
init|=
block|{
name|bfd_target_xcoff_flavour
block|,
comment|/* core_flavour */
name|default_check_format
block|,
comment|/* check_format */
name|default_core_sniffer
block|,
comment|/* core_sniffer */
name|fetch_core_registers
block|,
comment|/* core_read_registers */
name|NULL
comment|/* next */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_core_rs6000
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Initialize hook in rs6000-tdep.c for determining the TOC address when      calling functions in the inferior.  */
name|rs6000_find_toc_address_hook
operator|=
name|find_toc_address
expr_stmt|;
comment|/* Initialize hook in rs6000-tdep.c to set the current architecture when      starting a child process. */
name|rs6000_set_host_arch_hook
operator|=
name|set_host_arch
expr_stmt|;
name|add_core_fns
argument_list|(
operator|&
name|rs6000_core_fns
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

