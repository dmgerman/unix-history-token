begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target-dependent code for GDB, the GNU debugger.     Copyright 2001, 2002, 2003, 2004 Free Software Foundation, Inc.     Contributed by D.J. Barrow (djbarrow@de.ibm.com,barrow_dj@yahoo.com)    for IBM Deutschland Entwicklung GmbH, IBM Corporation.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA    02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"arch-utils.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"tm.h"
end_include

begin_include
include|#
directive|include
file|"../bfd/bfd.h"
end_include

begin_include
include|#
directive|include
file|"floatformat.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"trad-frame.h"
end_include

begin_include
include|#
directive|include
file|"frame-base.h"
end_include

begin_include
include|#
directive|include
file|"frame-unwind.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2-frame.h"
end_include

begin_include
include|#
directive|include
file|"reggroups.h"
end_include

begin_include
include|#
directive|include
file|"regset.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_include
include|#
directive|include
file|"solib-svr4.h"
end_include

begin_comment
comment|/* For struct link_map_offsets.  */
end_comment

begin_include
include|#
directive|include
file|"s390-tdep.h"
end_include

begin_comment
comment|/* The tdep structure.  */
end_comment

begin_struct
struct|struct
name|gdbarch_tdep
block|{
comment|/* ABI version.  */
enum|enum
block|{
name|ABI_LINUX_S390
block|,
name|ABI_LINUX_ZSERIES
block|}
name|abi
enum|;
comment|/* Core file register sets.  */
specifier|const
name|struct
name|regset
modifier|*
name|gregset
decl_stmt|;
name|int
name|sizeof_gregset
decl_stmt|;
specifier|const
name|struct
name|regset
modifier|*
name|fpregset
decl_stmt|;
name|int
name|sizeof_fpregset
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Register information.  */
end_comment

begin_struct
struct|struct
name|s390_register_info
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|type
modifier|*
modifier|*
name|type
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|s390_register_info
name|s390_register_info
index|[
name|S390_NUM_TOTAL_REGS
index|]
init|=
block|{
comment|/* Program Status Word.  */
block|{
literal|"pswm"
block|,
operator|&
name|builtin_type_long
block|}
block|,
block|{
literal|"pswa"
block|,
operator|&
name|builtin_type_long
block|}
block|,
comment|/* General Purpose Registers.  */
block|{
literal|"r0"
block|,
operator|&
name|builtin_type_long
block|}
block|,
block|{
literal|"r1"
block|,
operator|&
name|builtin_type_long
block|}
block|,
block|{
literal|"r2"
block|,
operator|&
name|builtin_type_long
block|}
block|,
block|{
literal|"r3"
block|,
operator|&
name|builtin_type_long
block|}
block|,
block|{
literal|"r4"
block|,
operator|&
name|builtin_type_long
block|}
block|,
block|{
literal|"r5"
block|,
operator|&
name|builtin_type_long
block|}
block|,
block|{
literal|"r6"
block|,
operator|&
name|builtin_type_long
block|}
block|,
block|{
literal|"r7"
block|,
operator|&
name|builtin_type_long
block|}
block|,
block|{
literal|"r8"
block|,
operator|&
name|builtin_type_long
block|}
block|,
block|{
literal|"r9"
block|,
operator|&
name|builtin_type_long
block|}
block|,
block|{
literal|"r10"
block|,
operator|&
name|builtin_type_long
block|}
block|,
block|{
literal|"r11"
block|,
operator|&
name|builtin_type_long
block|}
block|,
block|{
literal|"r12"
block|,
operator|&
name|builtin_type_long
block|}
block|,
block|{
literal|"r13"
block|,
operator|&
name|builtin_type_long
block|}
block|,
block|{
literal|"r14"
block|,
operator|&
name|builtin_type_long
block|}
block|,
block|{
literal|"r15"
block|,
operator|&
name|builtin_type_long
block|}
block|,
comment|/* Access Registers.  */
block|{
literal|"acr0"
block|,
operator|&
name|builtin_type_int
block|}
block|,
block|{
literal|"acr1"
block|,
operator|&
name|builtin_type_int
block|}
block|,
block|{
literal|"acr2"
block|,
operator|&
name|builtin_type_int
block|}
block|,
block|{
literal|"acr3"
block|,
operator|&
name|builtin_type_int
block|}
block|,
block|{
literal|"acr4"
block|,
operator|&
name|builtin_type_int
block|}
block|,
block|{
literal|"acr5"
block|,
operator|&
name|builtin_type_int
block|}
block|,
block|{
literal|"acr6"
block|,
operator|&
name|builtin_type_int
block|}
block|,
block|{
literal|"acr7"
block|,
operator|&
name|builtin_type_int
block|}
block|,
block|{
literal|"acr8"
block|,
operator|&
name|builtin_type_int
block|}
block|,
block|{
literal|"acr9"
block|,
operator|&
name|builtin_type_int
block|}
block|,
block|{
literal|"acr10"
block|,
operator|&
name|builtin_type_int
block|}
block|,
block|{
literal|"acr11"
block|,
operator|&
name|builtin_type_int
block|}
block|,
block|{
literal|"acr12"
block|,
operator|&
name|builtin_type_int
block|}
block|,
block|{
literal|"acr13"
block|,
operator|&
name|builtin_type_int
block|}
block|,
block|{
literal|"acr14"
block|,
operator|&
name|builtin_type_int
block|}
block|,
block|{
literal|"acr15"
block|,
operator|&
name|builtin_type_int
block|}
block|,
comment|/* Floating Point Control Word.  */
block|{
literal|"fpc"
block|,
operator|&
name|builtin_type_int
block|}
block|,
comment|/* Floating Point Registers.  */
block|{
literal|"f0"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"f1"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"f2"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"f3"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"f4"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"f5"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"f6"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"f7"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"f8"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"f9"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"f10"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"f11"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"f12"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"f13"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"f14"
block|,
operator|&
name|builtin_type_double
block|}
block|,
block|{
literal|"f15"
block|,
operator|&
name|builtin_type_double
block|}
block|,
comment|/* Pseudo registers.  */
block|{
literal|"pc"
block|,
operator|&
name|builtin_type_void_func_ptr
block|}
block|,
block|{
literal|"cc"
block|,
operator|&
name|builtin_type_int
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the name of register REGNUM.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|s390_register_name
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
name|S390_NUM_TOTAL_REGS
argument_list|)
expr_stmt|;
return|return
name|s390_register_info
index|[
name|regnum
index|]
operator|.
name|name
return|;
block|}
end_function

begin_comment
comment|/* Return the GDB type object for the "standard" data type of data in    register REGNUM. */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|s390_register_type
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<
name|S390_NUM_TOTAL_REGS
argument_list|)
expr_stmt|;
return|return
operator|*
name|s390_register_info
index|[
name|regnum
index|]
operator|.
name|type
return|;
block|}
end_function

begin_comment
comment|/* DWARF Register Mapping.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|s390_dwarf_regmap
index|[]
init|=
block|{
comment|/* General Purpose Registers.  */
name|S390_R0_REGNUM
block|,
name|S390_R1_REGNUM
block|,
name|S390_R2_REGNUM
block|,
name|S390_R3_REGNUM
block|,
name|S390_R4_REGNUM
block|,
name|S390_R5_REGNUM
block|,
name|S390_R6_REGNUM
block|,
name|S390_R7_REGNUM
block|,
name|S390_R8_REGNUM
block|,
name|S390_R9_REGNUM
block|,
name|S390_R10_REGNUM
block|,
name|S390_R11_REGNUM
block|,
name|S390_R12_REGNUM
block|,
name|S390_R13_REGNUM
block|,
name|S390_R14_REGNUM
block|,
name|S390_R15_REGNUM
block|,
comment|/* Floating Point Registers.  */
name|S390_F0_REGNUM
block|,
name|S390_F2_REGNUM
block|,
name|S390_F4_REGNUM
block|,
name|S390_F6_REGNUM
block|,
name|S390_F1_REGNUM
block|,
name|S390_F3_REGNUM
block|,
name|S390_F5_REGNUM
block|,
name|S390_F7_REGNUM
block|,
name|S390_F8_REGNUM
block|,
name|S390_F10_REGNUM
block|,
name|S390_F12_REGNUM
block|,
name|S390_F14_REGNUM
block|,
name|S390_F9_REGNUM
block|,
name|S390_F11_REGNUM
block|,
name|S390_F13_REGNUM
block|,
name|S390_F15_REGNUM
block|,
comment|/* Control Registers (not mapped).  */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* Access Registers.  */
name|S390_A0_REGNUM
block|,
name|S390_A1_REGNUM
block|,
name|S390_A2_REGNUM
block|,
name|S390_A3_REGNUM
block|,
name|S390_A4_REGNUM
block|,
name|S390_A5_REGNUM
block|,
name|S390_A6_REGNUM
block|,
name|S390_A7_REGNUM
block|,
name|S390_A8_REGNUM
block|,
name|S390_A9_REGNUM
block|,
name|S390_A10_REGNUM
block|,
name|S390_A11_REGNUM
block|,
name|S390_A12_REGNUM
block|,
name|S390_A13_REGNUM
block|,
name|S390_A14_REGNUM
block|,
name|S390_A15_REGNUM
block|,
comment|/* Program Status Word.  */
name|S390_PSWM_REGNUM
block|,
name|S390_PSWA_REGNUM
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Convert DWARF register number REG to the appropriate register    number used by GDB.  */
end_comment

begin_function
specifier|static
name|int
name|s390_dwarf_reg_to_regnum
parameter_list|(
name|int
name|reg
parameter_list|)
block|{
name|int
name|regnum
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|reg
operator|>=
literal|0
operator|||
name|reg
operator|<
name|ARRAY_SIZE
argument_list|(
name|s390_dwarf_regmap
argument_list|)
condition|)
name|regnum
operator|=
name|s390_dwarf_regmap
index|[
name|reg
index|]
expr_stmt|;
if|if
condition|(
name|regnum
operator|==
operator|-
literal|1
condition|)
name|warning
argument_list|(
literal|"Unmapped DWARF Register #%d encountered\n"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
return|return
name|regnum
return|;
block|}
end_function

begin_comment
comment|/* Pseudo registers - PC and condition code.  */
end_comment

begin_function
specifier|static
name|void
name|s390_pseudo_register_read
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|ULONGEST
name|val
decl_stmt|;
switch|switch
condition|(
name|regnum
condition|)
block|{
case|case
name|S390_PC_REGNUM
case|:
name|regcache_raw_read_unsigned
argument_list|(
name|regcache
argument_list|,
name|S390_PSWA_REGNUM
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
name|val
operator|&
literal|0x7fffffff
argument_list|)
expr_stmt|;
break|break;
case|case
name|S390_CC_REGNUM
case|:
name|regcache_raw_read_unsigned
argument_list|(
name|regcache
argument_list|,
name|S390_PSWM_REGNUM
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
operator|(
name|val
operator|>>
literal|12
operator|)
operator|&
literal|3
argument_list|)
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"invalid regnum"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|s390_pseudo_register_write
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|ULONGEST
name|val
decl_stmt|,
name|psw
decl_stmt|;
switch|switch
condition|(
name|regnum
condition|)
block|{
case|case
name|S390_PC_REGNUM
case|:
name|val
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|regcache_raw_read_unsigned
argument_list|(
name|regcache
argument_list|,
name|S390_PSWA_REGNUM
argument_list|,
operator|&
name|psw
argument_list|)
expr_stmt|;
name|psw
operator|=
operator|(
name|psw
operator|&
literal|0x80000000
operator|)
operator||
operator|(
name|val
operator|&
literal|0x7fffffff
operator|)
expr_stmt|;
name|regcache_raw_write_unsigned
argument_list|(
name|regcache
argument_list|,
name|S390_PSWA_REGNUM
argument_list|,
name|psw
argument_list|)
expr_stmt|;
break|break;
case|case
name|S390_CC_REGNUM
case|:
name|val
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|regcache_raw_read_unsigned
argument_list|(
name|regcache
argument_list|,
name|S390_PSWM_REGNUM
argument_list|,
operator|&
name|psw
argument_list|)
expr_stmt|;
name|psw
operator|=
operator|(
name|psw
operator|&
operator|~
operator|(
operator|(
name|ULONGEST
operator|)
literal|3
operator|<<
literal|12
operator|)
operator|)
operator||
operator|(
operator|(
name|val
operator|&
literal|3
operator|)
operator|<<
literal|12
operator|)
expr_stmt|;
name|regcache_raw_write_unsigned
argument_list|(
name|regcache
argument_list|,
name|S390_PSWM_REGNUM
argument_list|,
name|psw
argument_list|)
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"invalid regnum"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|s390x_pseudo_register_read
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|ULONGEST
name|val
decl_stmt|;
switch|switch
condition|(
name|regnum
condition|)
block|{
case|case
name|S390_PC_REGNUM
case|:
name|regcache_raw_read
argument_list|(
name|regcache
argument_list|,
name|S390_PSWA_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|S390_CC_REGNUM
case|:
name|regcache_raw_read_unsigned
argument_list|(
name|regcache
argument_list|,
name|S390_PSWM_REGNUM
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|,
operator|(
name|val
operator|>>
literal|44
operator|)
operator|&
literal|3
argument_list|)
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"invalid regnum"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|s390x_pseudo_register_write
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|ULONGEST
name|val
decl_stmt|,
name|psw
decl_stmt|;
switch|switch
condition|(
name|regnum
condition|)
block|{
case|case
name|S390_PC_REGNUM
case|:
name|regcache_raw_write
argument_list|(
name|regcache
argument_list|,
name|S390_PSWA_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|S390_CC_REGNUM
case|:
name|val
operator|=
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|regcache_raw_read_unsigned
argument_list|(
name|regcache
argument_list|,
name|S390_PSWM_REGNUM
argument_list|,
operator|&
name|psw
argument_list|)
expr_stmt|;
name|psw
operator|=
operator|(
name|psw
operator|&
operator|~
operator|(
operator|(
name|ULONGEST
operator|)
literal|3
operator|<<
literal|44
operator|)
operator|)
operator||
operator|(
operator|(
name|val
operator|&
literal|3
operator|)
operator|<<
literal|44
operator|)
expr_stmt|;
name|regcache_raw_write_unsigned
argument_list|(
name|regcache
argument_list|,
name|S390_PSWM_REGNUM
argument_list|,
name|psw
argument_list|)
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"invalid regnum"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* 'float' values are stored in the upper half of floating-point    registers, even though we are otherwise a big-endian platform.  */
end_comment

begin_function
specifier|static
name|int
name|s390_convert_register_p
parameter_list|(
name|int
name|regno
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
return|return
operator|(
name|regno
operator|>=
name|S390_F0_REGNUM
operator|&&
name|regno
operator|<=
name|S390_F15_REGNUM
operator|)
operator|&&
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|<
literal|8
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|s390_register_to_value
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|regnum
parameter_list|,
name|struct
name|type
modifier|*
name|valtype
parameter_list|,
name|void
modifier|*
name|out
parameter_list|)
block|{
name|char
name|in
index|[
literal|8
index|]
decl_stmt|;
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
decl_stmt|;
name|gdb_assert
argument_list|(
name|len
operator|<
literal|8
argument_list|)
expr_stmt|;
name|get_frame_register
argument_list|(
name|frame
argument_list|,
name|regnum
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|out
argument_list|,
name|in
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s390_value_to_register
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|,
name|int
name|regnum
parameter_list|,
name|struct
name|type
modifier|*
name|valtype
parameter_list|,
specifier|const
name|void
modifier|*
name|in
parameter_list|)
block|{
name|char
name|out
index|[
literal|8
index|]
decl_stmt|;
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|valtype
argument_list|)
decl_stmt|;
name|gdb_assert
argument_list|(
name|len
operator|<
literal|8
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|out
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|out
argument_list|,
name|in
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|put_frame_register
argument_list|(
name|frame
argument_list|,
name|regnum
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Register groups.  */
end_comment

begin_function
specifier|static
name|int
name|s390_register_reggroup_p
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|int
name|regnum
parameter_list|,
name|struct
name|reggroup
modifier|*
name|group
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|gdbarch
argument_list|)
decl_stmt|;
comment|/* Registers displayed via 'info regs'.  */
if|if
condition|(
name|group
operator|==
name|general_reggroup
condition|)
return|return
operator|(
name|regnum
operator|>=
name|S390_R0_REGNUM
operator|&&
name|regnum
operator|<=
name|S390_R15_REGNUM
operator|)
operator|||
name|regnum
operator|==
name|S390_PC_REGNUM
operator|||
name|regnum
operator|==
name|S390_CC_REGNUM
return|;
comment|/* Registers displayed via 'info float'.  */
if|if
condition|(
name|group
operator|==
name|float_reggroup
condition|)
return|return
operator|(
name|regnum
operator|>=
name|S390_F0_REGNUM
operator|&&
name|regnum
operator|<=
name|S390_F15_REGNUM
operator|)
operator|||
name|regnum
operator|==
name|S390_FPC_REGNUM
return|;
comment|/* Registers that need to be saved/restored in order to      push or pop frames.  */
if|if
condition|(
name|group
operator|==
name|save_reggroup
operator|||
name|group
operator|==
name|restore_reggroup
condition|)
return|return
name|regnum
operator|!=
name|S390_PSWM_REGNUM
operator|&&
name|regnum
operator|!=
name|S390_PSWA_REGNUM
return|;
return|return
name|default_register_reggroup_p
argument_list|(
name|gdbarch
argument_list|,
name|regnum
argument_list|,
name|group
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Core file register sets.  */
end_comment

begin_decl_stmt
name|int
name|s390_regmap_gregset
index|[
name|S390_NUM_REGS
index|]
init|=
block|{
comment|/* Program Status Word.  */
literal|0x00
block|,
literal|0x04
block|,
comment|/* General Purpose Registers.  */
literal|0x08
block|,
literal|0x0c
block|,
literal|0x10
block|,
literal|0x14
block|,
literal|0x18
block|,
literal|0x1c
block|,
literal|0x20
block|,
literal|0x24
block|,
literal|0x28
block|,
literal|0x2c
block|,
literal|0x30
block|,
literal|0x34
block|,
literal|0x38
block|,
literal|0x3c
block|,
literal|0x40
block|,
literal|0x44
block|,
comment|/* Access Registers.  */
literal|0x48
block|,
literal|0x4c
block|,
literal|0x50
block|,
literal|0x54
block|,
literal|0x58
block|,
literal|0x5c
block|,
literal|0x60
block|,
literal|0x64
block|,
literal|0x68
block|,
literal|0x6c
block|,
literal|0x70
block|,
literal|0x74
block|,
literal|0x78
block|,
literal|0x7c
block|,
literal|0x80
block|,
literal|0x84
block|,
comment|/* Floating Point Control Word.  */
operator|-
literal|1
block|,
comment|/* Floating Point Registers.  */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|s390x_regmap_gregset
index|[
name|S390_NUM_REGS
index|]
init|=
block|{
literal|0x00
block|,
literal|0x08
block|,
comment|/* General Purpose Registers.  */
literal|0x10
block|,
literal|0x18
block|,
literal|0x20
block|,
literal|0x28
block|,
literal|0x30
block|,
literal|0x38
block|,
literal|0x40
block|,
literal|0x48
block|,
literal|0x50
block|,
literal|0x58
block|,
literal|0x60
block|,
literal|0x68
block|,
literal|0x70
block|,
literal|0x78
block|,
literal|0x80
block|,
literal|0x88
block|,
comment|/* Access Registers.  */
literal|0x90
block|,
literal|0x94
block|,
literal|0x98
block|,
literal|0x9c
block|,
literal|0xa0
block|,
literal|0xa4
block|,
literal|0xa8
block|,
literal|0xac
block|,
literal|0xb0
block|,
literal|0xb4
block|,
literal|0xb8
block|,
literal|0xbc
block|,
literal|0xc0
block|,
literal|0xc4
block|,
literal|0xc8
block|,
literal|0xcc
block|,
comment|/* Floating Point Control Word.  */
operator|-
literal|1
block|,
comment|/* Floating Point Registers.  */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|s390_regmap_fpregset
index|[
name|S390_NUM_REGS
index|]
init|=
block|{
comment|/* Program Status Word.  */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* General Purpose Registers.  */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* Access Registers.  */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* Floating Point Control Word.  */
literal|0x00
block|,
comment|/* Floating Point Registers.  */
literal|0x08
block|,
literal|0x10
block|,
literal|0x18
block|,
literal|0x20
block|,
literal|0x28
block|,
literal|0x30
block|,
literal|0x38
block|,
literal|0x40
block|,
literal|0x48
block|,
literal|0x50
block|,
literal|0x58
block|,
literal|0x60
block|,
literal|0x68
block|,
literal|0x70
block|,
literal|0x78
block|,
literal|0x80
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Supply register REGNUM from the register set REGSET to register cache     REGCACHE.  If REGNUM is -1, do this for all registers in REGSET.  */
end_comment

begin_function
specifier|static
name|void
name|s390_supply_regset
parameter_list|(
specifier|const
name|struct
name|regset
modifier|*
name|regset
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|int
name|regnum
parameter_list|,
specifier|const
name|void
modifier|*
name|regs
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|int
modifier|*
name|offset
init|=
name|regset
operator|->
name|descr
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|S390_NUM_REGS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|regnum
operator|==
name|i
operator|||
name|regnum
operator|==
operator|-
literal|1
operator|)
operator|&&
name|offset
index|[
name|i
index|]
operator|!=
operator|-
literal|1
condition|)
name|regcache_raw_supply
argument_list|(
name|regcache
argument_list|,
name|i
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|regs
operator|+
name|offset
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|regset
name|s390_gregset
init|=
block|{
name|s390_regmap_gregset
block|,
name|s390_supply_regset
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|regset
name|s390x_gregset
init|=
block|{
name|s390x_regmap_gregset
block|,
name|s390_supply_regset
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|regset
name|s390_fpregset
init|=
block|{
name|s390_regmap_fpregset
block|,
name|s390_supply_regset
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return the appropriate register set for the core section identified    by SECT_NAME and SECT_SIZE.  */
end_comment

begin_function
specifier|const
name|struct
name|regset
modifier|*
name|s390_regset_from_core_section
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
specifier|const
name|char
modifier|*
name|sect_name
parameter_list|,
name|size_t
name|sect_size
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|gdbarch
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|sect_name
argument_list|,
literal|".reg"
argument_list|)
operator|==
literal|0
operator|&&
name|sect_size
operator|==
name|tdep
operator|->
name|sizeof_gregset
condition|)
return|return
name|tdep
operator|->
name|gregset
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|sect_name
argument_list|,
literal|".reg2"
argument_list|)
operator|==
literal|0
operator|&&
name|sect_size
operator|==
name|tdep
operator|->
name|sizeof_fpregset
condition|)
return|return
name|tdep
operator|->
name|fpregset
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Prologue analysis.  */
end_comment

begin_comment
comment|/* When we analyze a prologue, we're really doing 'abstract    interpretation' or 'pseudo-evaluation': running the function's code    in simulation, but using conservative approximations of the values    it would have when it actually runs.  For example, if our function    starts with the instruction:        ahi r1, 42     # add halfword immediate 42 to r1     we don't know exactly what value will be in r1 after executing this    instruction, but we do know it'll be 42 greater than its original    value.     If we then see an instruction like:        ahi r1, 22     # add halfword immediate 22 to r1     we still don't know what r1's value is, but again, we can say it is    now 64 greater than its original value.     If the next instruction were:        lr r2, r1      # set r2 to r1's value     then we can say that r2's value is now the original value of r1    plus 64.  And so on.     Of course, this can only go so far before it gets unreasonable.  If    we wanted to be able to say anything about the value of r1 after    the instruction:        xr r1, r3      # exclusive-or r1 and r3, place result in r1     then things would get pretty complex.  But remember, we're just    doing a conservative approximation; if exclusive-or instructions    aren't relevant to prologues, we can just say r1's value is now    'unknown'.  We can ignore things that are too complex, if that loss    of information is acceptable for our application.     Once you've reached an instruction that you don't know how to    simulate, you stop.  Now you examine the state of the registers and    stack slots you've kept track of.  For example:     - To see how large your stack frame is, just check the value of sp;      if it's the original value of sp minus a constant, then that      constant is the stack frame's size.  If the sp's value has been      marked as 'unknown', then that means the prologue has done      something too complex for us to track, and we don't know the      frame size.     - To see whether we've saved the SP in the current frame's back      chain slot, we just check whether the current value of the back      chain stack slot is the original value of the sp.     Sure, this takes some work.  But prologue analyzers aren't    quick-and-simple pattern patching to recognize a few fixed prologue    forms any more; they're big, hairy functions.  Along with inferior    function calls, prologue analysis accounts for a substantial    portion of the time needed to stabilize a GDB port.  So I think    it's worthwhile to look for an approach that will be easier to    understand and maintain.  In the approach used here:     - It's easier to see that the analyzer is correct: you just see      whether the analyzer properly (albiet conservatively) simulates      the effect of each instruction.     - It's easier to extend the analyzer: you can add support for new      instructions, and know that you haven't broken anything that      wasn't already broken before.     - It's orthogonal: to gather new information, you don't need to      complicate the code for each instruction.  As long as your domain      of conservative values is already detailed enough to tell you      what you need, then all the existing instruction simulations are      already gathering the right data for you.     A 'struct prologue_value' is a conservative approximation of the    real value the register or stack slot will have.  */
end_comment

begin_struct
struct|struct
name|prologue_value
block|{
comment|/* What sort of value is this?  This determines the interpretation      of subsequent fields.  */
enum|enum
block|{
comment|/* We don't know anything about the value.  This is also used for        values we could have kept track of, when doing so would have        been too complex and we don't want to bother.  The bottom of        our lattice.  */
name|pv_unknown
block|,
comment|/* A known constant.  K is its value.  */
name|pv_constant
block|,
comment|/* The value that register REG originally had *UPON ENTRY TO THE        FUNCTION*, plus K.  If K is zero, this means, obviously, just        the value REG had upon entry to the function.  REG is a GDB        register number.  Before we start interpreting, we initialize        every register R to { pv_register, R, 0 }.  */
name|pv_register
block|,    }
name|kind
enum|;
comment|/* The meanings of the following fields depend on 'kind'; see the      comments for the specific 'kind' values.  */
name|int
name|reg
decl_stmt|;
name|CORE_ADDR
name|k
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Set V to be unknown.  */
end_comment

begin_function
specifier|static
name|void
name|pv_set_to_unknown
parameter_list|(
name|struct
name|prologue_value
modifier|*
name|v
parameter_list|)
block|{
name|v
operator|->
name|kind
operator|=
name|pv_unknown
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set V to the constant K.  */
end_comment

begin_function
specifier|static
name|void
name|pv_set_to_constant
parameter_list|(
name|struct
name|prologue_value
modifier|*
name|v
parameter_list|,
name|CORE_ADDR
name|k
parameter_list|)
block|{
name|v
operator|->
name|kind
operator|=
name|pv_constant
expr_stmt|;
name|v
operator|->
name|k
operator|=
name|k
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set V to the original value of register REG, plus K.  */
end_comment

begin_function
specifier|static
name|void
name|pv_set_to_register
parameter_list|(
name|struct
name|prologue_value
modifier|*
name|v
parameter_list|,
name|int
name|reg
parameter_list|,
name|CORE_ADDR
name|k
parameter_list|)
block|{
name|v
operator|->
name|kind
operator|=
name|pv_register
expr_stmt|;
name|v
operator|->
name|reg
operator|=
name|reg
expr_stmt|;
name|v
operator|->
name|k
operator|=
name|k
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If one of *A and *B is a constant, and the other isn't, swap the    pointers as necessary to ensure that *B points to the constant.    This can reduce the number of cases we need to analyze in the    functions below.  */
end_comment

begin_function
specifier|static
name|void
name|pv_constant_last
parameter_list|(
name|struct
name|prologue_value
modifier|*
modifier|*
name|a
parameter_list|,
name|struct
name|prologue_value
modifier|*
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|*
name|a
operator|)
operator|->
name|kind
operator|==
name|pv_constant
operator|&&
operator|(
operator|*
name|b
operator|)
operator|->
name|kind
operator|!=
name|pv_constant
condition|)
block|{
name|struct
name|prologue_value
modifier|*
name|temp
init|=
operator|*
name|a
decl_stmt|;
operator|*
name|a
operator|=
operator|*
name|b
expr_stmt|;
operator|*
name|b
operator|=
name|temp
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Set SUM to the sum of A and B.  SUM, A, and B may point to the same    'struct prologue_value' object.  */
end_comment

begin_function
specifier|static
name|void
name|pv_add
parameter_list|(
name|struct
name|prologue_value
modifier|*
name|sum
parameter_list|,
name|struct
name|prologue_value
modifier|*
name|a
parameter_list|,
name|struct
name|prologue_value
modifier|*
name|b
parameter_list|)
block|{
name|pv_constant_last
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
comment|/* We can handle adding constants to registers, and other constants.  */
if|if
condition|(
name|b
operator|->
name|kind
operator|==
name|pv_constant
operator|&&
operator|(
name|a
operator|->
name|kind
operator|==
name|pv_register
operator|||
name|a
operator|->
name|kind
operator|==
name|pv_constant
operator|)
condition|)
block|{
name|sum
operator|->
name|kind
operator|=
name|a
operator|->
name|kind
expr_stmt|;
name|sum
operator|->
name|reg
operator|=
name|a
operator|->
name|reg
expr_stmt|;
comment|/* not meaningful if a is pv_constant, but                                harmless */
name|sum
operator|->
name|k
operator|=
name|a
operator|->
name|k
operator|+
name|b
operator|->
name|k
expr_stmt|;
block|}
comment|/* Anything else we don't know how to add.  We don't have a      representation for, say, the sum of two registers, or a multiple      of a register's value (adding a register to itself).  */
else|else
name|sum
operator|->
name|kind
operator|=
name|pv_unknown
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add the constant K to V.  */
end_comment

begin_function
specifier|static
name|void
name|pv_add_constant
parameter_list|(
name|struct
name|prologue_value
modifier|*
name|v
parameter_list|,
name|CORE_ADDR
name|k
parameter_list|)
block|{
name|struct
name|prologue_value
name|pv_k
decl_stmt|;
comment|/* Rather than thinking of all the cases we can and can't handle,      we'll just let pv_add take care of that for us.  */
name|pv_set_to_constant
argument_list|(
operator|&
name|pv_k
argument_list|,
name|k
argument_list|)
expr_stmt|;
name|pv_add
argument_list|(
name|v
argument_list|,
name|v
argument_list|,
operator|&
name|pv_k
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Subtract B from A, and put the result in DIFF.     This isn't quite the same as negating B and adding it to A, since    we don't have a representation for the negation of anything but a    constant.  For example, we can't negate { pv_register, R1, 10 },    but we do know that { pv_register, R1, 10 } minus { pv_register,    R1, 5 } is { pv_constant,<ignored>, 5 }.     This means, for example, that we can subtract two stack addresses;    they're both relative to the original SP.  Since the frame pointer    is set based on the SP, its value will be the original SP plus some    constant (probably zero), so we can use its value just fine.  */
end_comment

begin_function
specifier|static
name|void
name|pv_subtract
parameter_list|(
name|struct
name|prologue_value
modifier|*
name|diff
parameter_list|,
name|struct
name|prologue_value
modifier|*
name|a
parameter_list|,
name|struct
name|prologue_value
modifier|*
name|b
parameter_list|)
block|{
name|pv_constant_last
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
comment|/* We can subtract a constant from another constant, or from a      register.  */
if|if
condition|(
name|b
operator|->
name|kind
operator|==
name|pv_constant
operator|&&
operator|(
name|a
operator|->
name|kind
operator|==
name|pv_register
operator|||
name|a
operator|->
name|kind
operator|==
name|pv_constant
operator|)
condition|)
block|{
name|diff
operator|->
name|kind
operator|=
name|a
operator|->
name|kind
expr_stmt|;
name|diff
operator|->
name|reg
operator|=
name|a
operator|->
name|reg
expr_stmt|;
comment|/* not always meaningful, but harmless */
name|diff
operator|->
name|k
operator|=
name|a
operator|->
name|k
operator|-
name|b
operator|->
name|k
expr_stmt|;
block|}
comment|/* We can subtract a register from itself, yielding a constant.  */
elseif|else
if|if
condition|(
name|a
operator|->
name|kind
operator|==
name|pv_register
operator|&&
name|b
operator|->
name|kind
operator|==
name|pv_register
operator|&&
name|a
operator|->
name|reg
operator|==
name|b
operator|->
name|reg
condition|)
block|{
name|diff
operator|->
name|kind
operator|=
name|pv_constant
expr_stmt|;
name|diff
operator|->
name|k
operator|=
name|a
operator|->
name|k
operator|-
name|b
operator|->
name|k
expr_stmt|;
block|}
comment|/* We don't know how to subtract anything else.  */
else|else
name|diff
operator|->
name|kind
operator|=
name|pv_unknown
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set AND to the logical and of A and B.  */
end_comment

begin_function
specifier|static
name|void
name|pv_logical_and
parameter_list|(
name|struct
name|prologue_value
modifier|*
name|and
parameter_list|,
name|struct
name|prologue_value
modifier|*
name|a
parameter_list|,
name|struct
name|prologue_value
modifier|*
name|b
parameter_list|)
block|{
name|pv_constant_last
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
comment|/* We can 'and' two constants.  */
if|if
condition|(
name|a
operator|->
name|kind
operator|==
name|pv_constant
operator|&&
name|b
operator|->
name|kind
operator|==
name|pv_constant
condition|)
block|{
name|and
operator|->
name|kind
operator|=
name|pv_constant
expr_stmt|;
name|and
operator|->
name|k
operator|=
name|a
operator|->
name|k
operator|&
name|b
operator|->
name|k
expr_stmt|;
block|}
comment|/* We can 'and' anything with the constant zero.  */
elseif|else
if|if
condition|(
name|b
operator|->
name|kind
operator|==
name|pv_constant
operator|&&
name|b
operator|->
name|k
operator|==
literal|0
condition|)
block|{
name|and
operator|->
name|kind
operator|=
name|pv_constant
expr_stmt|;
name|and
operator|->
name|k
operator|=
literal|0
expr_stmt|;
block|}
comment|/* We can 'and' anything with ~0.  */
elseif|else
if|if
condition|(
name|b
operator|->
name|kind
operator|==
name|pv_constant
operator|&&
name|b
operator|->
name|k
operator|==
operator|~
operator|(
name|CORE_ADDR
operator|)
literal|0
condition|)
operator|*
name|and
operator|=
operator|*
name|a
expr_stmt|;
comment|/* We can 'and' a register with itself.  */
elseif|else
if|if
condition|(
name|a
operator|->
name|kind
operator|==
name|pv_register
operator|&&
name|b
operator|->
name|kind
operator|==
name|pv_register
operator|&&
name|a
operator|->
name|reg
operator|==
name|b
operator|->
name|reg
operator|&&
name|a
operator|->
name|k
operator|==
name|b
operator|->
name|k
condition|)
operator|*
name|and
operator|=
operator|*
name|a
expr_stmt|;
comment|/* Otherwise, we don't know.  */
else|else
name|pv_set_to_unknown
argument_list|(
name|and
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return non-zero iff A and B are identical expressions.     This is not the same as asking if the two values are equal; the    result of such a comparison would have to be a pv_boolean, and    asking whether two 'unknown' values were equal would give you    pv_maybe.  Same for comparing, say, { pv_register, R1, 0 } and {    pv_register, R2, 0}.  Instead, this is asking whether the two    representations are the same.  */
end_comment

begin_function
specifier|static
name|int
name|pv_is_identical
parameter_list|(
name|struct
name|prologue_value
modifier|*
name|a
parameter_list|,
name|struct
name|prologue_value
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
name|a
operator|->
name|kind
operator|!=
name|b
operator|->
name|kind
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|a
operator|->
name|kind
condition|)
block|{
case|case
name|pv_unknown
case|:
return|return
literal|1
return|;
case|case
name|pv_constant
case|:
return|return
operator|(
name|a
operator|->
name|k
operator|==
name|b
operator|->
name|k
operator|)
return|;
case|case
name|pv_register
case|:
return|return
operator|(
name|a
operator|->
name|reg
operator|==
name|b
operator|->
name|reg
operator|&&
name|a
operator|->
name|k
operator|==
name|b
operator|->
name|k
operator|)
return|;
default|default:
name|gdb_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return non-zero if A is the original value of register number R    plus K, zero otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|pv_is_register
parameter_list|(
name|struct
name|prologue_value
modifier|*
name|a
parameter_list|,
name|int
name|r
parameter_list|,
name|CORE_ADDR
name|k
parameter_list|)
block|{
return|return
operator|(
name|a
operator|->
name|kind
operator|==
name|pv_register
operator|&&
name|a
operator|->
name|reg
operator|==
name|r
operator|&&
name|a
operator|->
name|k
operator|==
name|k
operator|)
return|;
block|}
end_function

begin_comment
comment|/* A prologue-value-esque boolean type, including "maybe", when we    can't figure out whether something is true or not.  */
end_comment

begin_enum
enum|enum
name|pv_boolean
block|{
name|pv_maybe
block|,
name|pv_definite_yes
block|,
name|pv_definite_no
block|, }
enum|;
end_enum

begin_comment
comment|/* Decide whether a reference to SIZE bytes at ADDR refers exactly to    an element of an array.  The array starts at ARRAY_ADDR, and has    ARRAY_LEN values of ELT_SIZE bytes each.  If ADDR definitely does    refer to an array element, set *I to the index of the referenced    element in the array, and return pv_definite_yes.  If it definitely    doesn't, return pv_definite_no.  If we can't tell, return pv_maybe.     If the reference does touch the array, but doesn't fall exactly on    an element boundary, or doesn't refer to the whole element, return    pv_maybe.  */
end_comment

begin_function
specifier|static
name|enum
name|pv_boolean
name|pv_is_array_ref
parameter_list|(
name|struct
name|prologue_value
modifier|*
name|addr
parameter_list|,
name|CORE_ADDR
name|size
parameter_list|,
name|struct
name|prologue_value
modifier|*
name|array_addr
parameter_list|,
name|CORE_ADDR
name|array_len
parameter_list|,
name|CORE_ADDR
name|elt_size
parameter_list|,
name|int
modifier|*
name|i
parameter_list|)
block|{
name|struct
name|prologue_value
name|offset
decl_stmt|;
comment|/* Note that, since ->k is a CORE_ADDR, and CORE_ADDR is unsigned,      if addr is *before* the start of the array, then this isn't going      to be negative...  */
name|pv_subtract
argument_list|(
operator|&
name|offset
argument_list|,
name|addr
argument_list|,
name|array_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|.
name|kind
operator|==
name|pv_constant
condition|)
block|{
comment|/* This is a rather odd test.  We want to know if the SIZE bytes          at ADDR don't overlap the array at all, so you'd expect it to          be an || expression: "if we're completely before || we're          completely after".  But with unsigned arithmetic, things are          different: since it's a number circle, not a number line, the          right values for offset.k are actually one contiguous range.  */
if|if
condition|(
name|offset
operator|.
name|k
operator|<=
operator|-
name|size
operator|&&
name|offset
operator|.
name|k
operator|>=
name|array_len
operator|*
name|elt_size
condition|)
return|return
name|pv_definite_no
return|;
elseif|else
if|if
condition|(
name|offset
operator|.
name|k
operator|%
name|elt_size
operator|!=
literal|0
operator|||
name|size
operator|!=
name|elt_size
condition|)
return|return
name|pv_maybe
return|;
else|else
block|{
operator|*
name|i
operator|=
name|offset
operator|.
name|k
operator|/
name|elt_size
expr_stmt|;
return|return
name|pv_definite_yes
return|;
block|}
block|}
else|else
return|return
name|pv_maybe
return|;
block|}
end_function

begin_comment
comment|/* Decoding S/390 instructions.  */
end_comment

begin_comment
comment|/* Named opcode values for the S/390 instructions we recognize.  Some    instructions have their opcode split across two fields; those are the    op1_* and op2_* enums.  */
end_comment

begin_enum
enum|enum
block|{
name|op1_lhi
init|=
literal|0xa7
block|,
name|op2_lhi
init|=
literal|0x08
block|,
name|op1_lghi
init|=
literal|0xa7
block|,
name|op2_lghi
init|=
literal|0x09
block|,
name|op_lr
init|=
literal|0x18
block|,
name|op_lgr
init|=
literal|0xb904
block|,
name|op_l
init|=
literal|0x58
block|,
name|op1_ly
init|=
literal|0xe3
block|,
name|op2_ly
init|=
literal|0x58
block|,
name|op1_lg
init|=
literal|0xe3
block|,
name|op2_lg
init|=
literal|0x04
block|,
name|op_lm
init|=
literal|0x98
block|,
name|op1_lmy
init|=
literal|0xeb
block|,
name|op2_lmy
init|=
literal|0x98
block|,
name|op1_lmg
init|=
literal|0xeb
block|,
name|op2_lmg
init|=
literal|0x04
block|,
name|op_st
init|=
literal|0x50
block|,
name|op1_sty
init|=
literal|0xe3
block|,
name|op2_sty
init|=
literal|0x50
block|,
name|op1_stg
init|=
literal|0xe3
block|,
name|op2_stg
init|=
literal|0x24
block|,
name|op_std
init|=
literal|0x60
block|,
name|op_stm
init|=
literal|0x90
block|,
name|op1_stmy
init|=
literal|0xeb
block|,
name|op2_stmy
init|=
literal|0x90
block|,
name|op1_stmg
init|=
literal|0xeb
block|,
name|op2_stmg
init|=
literal|0x24
block|,
name|op1_aghi
init|=
literal|0xa7
block|,
name|op2_aghi
init|=
literal|0x0b
block|,
name|op1_ahi
init|=
literal|0xa7
block|,
name|op2_ahi
init|=
literal|0x0a
block|,
name|op_ar
init|=
literal|0x1a
block|,
name|op_agr
init|=
literal|0xb908
block|,
name|op_a
init|=
literal|0x5a
block|,
name|op1_ay
init|=
literal|0xe3
block|,
name|op2_ay
init|=
literal|0x5a
block|,
name|op1_ag
init|=
literal|0xe3
block|,
name|op2_ag
init|=
literal|0x08
block|,
name|op_sr
init|=
literal|0x1b
block|,
name|op_sgr
init|=
literal|0xb909
block|,
name|op_s
init|=
literal|0x5b
block|,
name|op1_sy
init|=
literal|0xe3
block|,
name|op2_sy
init|=
literal|0x5b
block|,
name|op1_sg
init|=
literal|0xe3
block|,
name|op2_sg
init|=
literal|0x09
block|,
name|op_nr
init|=
literal|0x14
block|,
name|op_ngr
init|=
literal|0xb980
block|,
name|op_la
init|=
literal|0x41
block|,
name|op1_lay
init|=
literal|0xe3
block|,
name|op2_lay
init|=
literal|0x71
block|,
name|op1_larl
init|=
literal|0xc0
block|,
name|op2_larl
init|=
literal|0x00
block|,
name|op_basr
init|=
literal|0x0d
block|,
name|op_bas
init|=
literal|0x4d
block|,
name|op_bcr
init|=
literal|0x07
block|,
name|op_bc
init|=
literal|0x0d
block|,
name|op1_bras
init|=
literal|0xa7
block|,
name|op2_bras
init|=
literal|0x05
block|,
name|op1_brasl
init|=
literal|0xc0
block|,
name|op2_brasl
init|=
literal|0x05
block|,
name|op1_brc
init|=
literal|0xa7
block|,
name|op2_brc
init|=
literal|0x04
block|,
name|op1_brcl
init|=
literal|0xc0
block|,
name|op2_brcl
init|=
literal|0x04
block|,   }
enum|;
end_enum

begin_comment
comment|/* Read a single instruction from address AT.  */
end_comment

begin_define
define|#
directive|define
name|S390_MAX_INSTR_SIZE
value|6
end_define

begin_function
specifier|static
name|int
name|s390_readinstruction
parameter_list|(
name|bfd_byte
name|instr
index|[]
parameter_list|,
name|CORE_ADDR
name|at
parameter_list|)
block|{
specifier|static
name|int
name|s390_instrlen
index|[]
init|=
block|{
literal|2
block|,
literal|4
block|,
literal|4
block|,
literal|6
block|}
decl_stmt|;
name|int
name|instrlen
decl_stmt|;
if|if
condition|(
name|read_memory_nobpt
argument_list|(
name|at
argument_list|,
operator|&
name|instr
index|[
literal|0
index|]
argument_list|,
literal|2
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|instrlen
operator|=
name|s390_instrlen
index|[
name|instr
index|[
literal|0
index|]
operator|>>
literal|6
index|]
expr_stmt|;
if|if
condition|(
name|instrlen
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|read_memory_nobpt
argument_list|(
name|at
operator|+
literal|2
argument_list|,
operator|&
name|instr
index|[
literal|2
index|]
argument_list|,
name|instrlen
operator|-
literal|2
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
name|instrlen
return|;
block|}
end_function

begin_comment
comment|/* The functions below are for recognizing and decoding S/390    instructions of various formats.  Each of them checks whether INSN    is an instruction of the given format, with the specified opcodes.    If it is, it sets the remaining arguments to the values of the    instruction's fields, and returns a non-zero value; otherwise, it    returns zero.     These functions' arguments appear in the order they appear in the    instruction, not in the machine-language form.  So, opcodes always    come first, even though they're sometimes scattered around the    instructions.  And displacements appear before base and extension    registers, as they do in the assembly syntax, not at the end, as    they do in the machine language.  */
end_comment

begin_function
specifier|static
name|int
name|is_ri
parameter_list|(
name|bfd_byte
modifier|*
name|insn
parameter_list|,
name|int
name|op1
parameter_list|,
name|int
name|op2
parameter_list|,
name|unsigned
name|int
modifier|*
name|r1
parameter_list|,
name|int
modifier|*
name|i2
parameter_list|)
block|{
if|if
condition|(
name|insn
index|[
literal|0
index|]
operator|==
name|op1
operator|&&
operator|(
name|insn
index|[
literal|1
index|]
operator|&
literal|0xf
operator|)
operator|==
name|op2
condition|)
block|{
operator|*
name|r1
operator|=
operator|(
name|insn
index|[
literal|1
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
expr_stmt|;
comment|/* i2 is a 16-bit signed quantity.  */
operator|*
name|i2
operator|=
operator|(
operator|(
operator|(
name|insn
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
name|insn
index|[
literal|3
index|]
operator|)
operator|^
literal|0x8000
operator|)
operator|-
literal|0x8000
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_ril
parameter_list|(
name|bfd_byte
modifier|*
name|insn
parameter_list|,
name|int
name|op1
parameter_list|,
name|int
name|op2
parameter_list|,
name|unsigned
name|int
modifier|*
name|r1
parameter_list|,
name|int
modifier|*
name|i2
parameter_list|)
block|{
if|if
condition|(
name|insn
index|[
literal|0
index|]
operator|==
name|op1
operator|&&
operator|(
name|insn
index|[
literal|1
index|]
operator|&
literal|0xf
operator|)
operator|==
name|op2
condition|)
block|{
operator|*
name|r1
operator|=
operator|(
name|insn
index|[
literal|1
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
expr_stmt|;
comment|/* i2 is a signed quantity.  If the host 'int' is 32 bits long,          no sign extension is necessary, but we don't want to assume          that.  */
operator|*
name|i2
operator|=
operator|(
operator|(
operator|(
name|insn
index|[
literal|2
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|insn
index|[
literal|3
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|insn
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|insn
index|[
literal|5
index|]
operator|)
operator|)
operator|^
literal|0x80000000
operator|)
operator|-
literal|0x80000000
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_rr
parameter_list|(
name|bfd_byte
modifier|*
name|insn
parameter_list|,
name|int
name|op
parameter_list|,
name|unsigned
name|int
modifier|*
name|r1
parameter_list|,
name|unsigned
name|int
modifier|*
name|r2
parameter_list|)
block|{
if|if
condition|(
name|insn
index|[
literal|0
index|]
operator|==
name|op
condition|)
block|{
operator|*
name|r1
operator|=
operator|(
name|insn
index|[
literal|1
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
expr_stmt|;
operator|*
name|r2
operator|=
name|insn
index|[
literal|1
index|]
operator|&
literal|0xf
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_rre
parameter_list|(
name|bfd_byte
modifier|*
name|insn
parameter_list|,
name|int
name|op
parameter_list|,
name|unsigned
name|int
modifier|*
name|r1
parameter_list|,
name|unsigned
name|int
modifier|*
name|r2
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|(
name|insn
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|insn
index|[
literal|1
index|]
operator|)
operator|==
name|op
condition|)
block|{
comment|/* Yes, insn[3].  insn[2] is unused in RRE format.  */
operator|*
name|r1
operator|=
operator|(
name|insn
index|[
literal|3
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
expr_stmt|;
operator|*
name|r2
operator|=
name|insn
index|[
literal|3
index|]
operator|&
literal|0xf
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_rs
parameter_list|(
name|bfd_byte
modifier|*
name|insn
parameter_list|,
name|int
name|op
parameter_list|,
name|unsigned
name|int
modifier|*
name|r1
parameter_list|,
name|unsigned
name|int
modifier|*
name|r3
parameter_list|,
name|unsigned
name|int
modifier|*
name|d2
parameter_list|,
name|unsigned
name|int
modifier|*
name|b2
parameter_list|)
block|{
if|if
condition|(
name|insn
index|[
literal|0
index|]
operator|==
name|op
condition|)
block|{
operator|*
name|r1
operator|=
operator|(
name|insn
index|[
literal|1
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
expr_stmt|;
operator|*
name|r3
operator|=
name|insn
index|[
literal|1
index|]
operator|&
literal|0xf
expr_stmt|;
operator|*
name|b2
operator|=
operator|(
name|insn
index|[
literal|2
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
expr_stmt|;
operator|*
name|d2
operator|=
operator|(
operator|(
name|insn
index|[
literal|2
index|]
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
operator||
name|insn
index|[
literal|3
index|]
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_rsy
parameter_list|(
name|bfd_byte
modifier|*
name|insn
parameter_list|,
name|int
name|op1
parameter_list|,
name|int
name|op2
parameter_list|,
name|unsigned
name|int
modifier|*
name|r1
parameter_list|,
name|unsigned
name|int
modifier|*
name|r3
parameter_list|,
name|unsigned
name|int
modifier|*
name|d2
parameter_list|,
name|unsigned
name|int
modifier|*
name|b2
parameter_list|)
block|{
if|if
condition|(
name|insn
index|[
literal|0
index|]
operator|==
name|op1
operator|&&
name|insn
index|[
literal|5
index|]
operator|==
name|op2
condition|)
block|{
operator|*
name|r1
operator|=
operator|(
name|insn
index|[
literal|1
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
expr_stmt|;
operator|*
name|r3
operator|=
name|insn
index|[
literal|1
index|]
operator|&
literal|0xf
expr_stmt|;
operator|*
name|b2
operator|=
operator|(
name|insn
index|[
literal|2
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
expr_stmt|;
comment|/* The 'long displacement' is a 20-bit signed integer.  */
operator|*
name|d2
operator|=
operator|(
operator|(
operator|(
operator|(
name|insn
index|[
literal|2
index|]
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
operator||
name|insn
index|[
literal|3
index|]
operator||
operator|(
name|insn
index|[
literal|4
index|]
operator|<<
literal|12
operator|)
operator|)
operator|^
literal|0x80000
operator|)
operator|-
literal|0x80000
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_rx
parameter_list|(
name|bfd_byte
modifier|*
name|insn
parameter_list|,
name|int
name|op
parameter_list|,
name|unsigned
name|int
modifier|*
name|r1
parameter_list|,
name|unsigned
name|int
modifier|*
name|d2
parameter_list|,
name|unsigned
name|int
modifier|*
name|x2
parameter_list|,
name|unsigned
name|int
modifier|*
name|b2
parameter_list|)
block|{
if|if
condition|(
name|insn
index|[
literal|0
index|]
operator|==
name|op
condition|)
block|{
operator|*
name|r1
operator|=
operator|(
name|insn
index|[
literal|1
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
expr_stmt|;
operator|*
name|x2
operator|=
name|insn
index|[
literal|1
index|]
operator|&
literal|0xf
expr_stmt|;
operator|*
name|b2
operator|=
operator|(
name|insn
index|[
literal|2
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
expr_stmt|;
operator|*
name|d2
operator|=
operator|(
operator|(
name|insn
index|[
literal|2
index|]
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
operator||
name|insn
index|[
literal|3
index|]
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_rxy
parameter_list|(
name|bfd_byte
modifier|*
name|insn
parameter_list|,
name|int
name|op1
parameter_list|,
name|int
name|op2
parameter_list|,
name|unsigned
name|int
modifier|*
name|r1
parameter_list|,
name|unsigned
name|int
modifier|*
name|d2
parameter_list|,
name|unsigned
name|int
modifier|*
name|x2
parameter_list|,
name|unsigned
name|int
modifier|*
name|b2
parameter_list|)
block|{
if|if
condition|(
name|insn
index|[
literal|0
index|]
operator|==
name|op1
operator|&&
name|insn
index|[
literal|5
index|]
operator|==
name|op2
condition|)
block|{
operator|*
name|r1
operator|=
operator|(
name|insn
index|[
literal|1
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
expr_stmt|;
operator|*
name|x2
operator|=
name|insn
index|[
literal|1
index|]
operator|&
literal|0xf
expr_stmt|;
operator|*
name|b2
operator|=
operator|(
name|insn
index|[
literal|2
index|]
operator|>>
literal|4
operator|)
operator|&
literal|0xf
expr_stmt|;
comment|/* The 'long displacement' is a 20-bit signed integer.  */
operator|*
name|d2
operator|=
operator|(
operator|(
operator|(
operator|(
name|insn
index|[
literal|2
index|]
operator|&
literal|0xf
operator|)
operator|<<
literal|8
operator|)
operator||
name|insn
index|[
literal|3
index|]
operator||
operator|(
name|insn
index|[
literal|4
index|]
operator|<<
literal|12
operator|)
operator|)
operator|^
literal|0x80000
operator|)
operator|-
literal|0x80000
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Set ADDR to the effective address for an X-style instruction, like:          L R1, D2(X2, B2)     Here, X2 and B2 are registers, and D2 is a signed 20-bit    constant; the effective address is the sum of all three.  If either    X2 or B2 are zero, then it doesn't contribute to the sum --- this    means that r0 can't be used as either X2 or B2.     GPR is an array of general register values, indexed by GPR number,    not GDB register number.  */
end_comment

begin_function
specifier|static
name|void
name|compute_x_addr
parameter_list|(
name|struct
name|prologue_value
modifier|*
name|addr
parameter_list|,
name|struct
name|prologue_value
modifier|*
name|gpr
parameter_list|,
name|int
name|d2
parameter_list|,
name|unsigned
name|int
name|x2
parameter_list|,
name|unsigned
name|int
name|b2
parameter_list|)
block|{
comment|/* We can't just add stuff directly in addr; it might alias some of      the registers we need to read.  */
name|struct
name|prologue_value
name|result
decl_stmt|;
name|pv_set_to_constant
argument_list|(
operator|&
name|result
argument_list|,
name|d2
argument_list|)
expr_stmt|;
if|if
condition|(
name|x2
condition|)
name|pv_add
argument_list|(
operator|&
name|result
argument_list|,
operator|&
name|result
argument_list|,
operator|&
name|gpr
index|[
name|x2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|b2
condition|)
name|pv_add
argument_list|(
operator|&
name|result
argument_list|,
operator|&
name|result
argument_list|,
operator|&
name|gpr
index|[
name|b2
index|]
argument_list|)
expr_stmt|;
operator|*
name|addr
operator|=
name|result
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The number of GPR and FPR spill slots in an S/390 stack frame.  We    track general-purpose registers r2 -- r15, and floating-point    registers f0, f2, f4, and f6.  */
end_comment

begin_define
define|#
directive|define
name|S390_NUM_SPILL_SLOTS
value|(14 + 4)
end_define

begin_define
define|#
directive|define
name|S390_NUM_GPRS
value|16
end_define

begin_define
define|#
directive|define
name|S390_NUM_FPRS
value|16
end_define

begin_struct
struct|struct
name|s390_prologue_data
block|{
comment|/* The size of a GPR or FPR.  */
name|int
name|gpr_size
decl_stmt|;
name|int
name|fpr_size
decl_stmt|;
comment|/* The general-purpose registers.  */
name|struct
name|prologue_value
name|gpr
index|[
name|S390_NUM_GPRS
index|]
decl_stmt|;
comment|/* The floating-point registers.  */
name|struct
name|prologue_value
name|fpr
index|[
name|S390_NUM_FPRS
index|]
decl_stmt|;
comment|/* The register spill stack slots in the caller's frame ---      general-purpose registers r2 through r15, and floating-point      registers.  spill[i] is where gpr i+2 gets spilled;      spill[(14, 15, 16, 17)] is where (f0, f2, f4, f6) get spilled.  */
name|struct
name|prologue_value
name|spill
index|[
name|S390_NUM_SPILL_SLOTS
index|]
decl_stmt|;
comment|/* The value of the back chain slot.  This is only valid if the stack      pointer is known to be less than its original value --- that is,      if we have indeed allocated space on the stack.  */
name|struct
name|prologue_value
name|back_chain
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* If the SIZE bytes at ADDR are a stack slot we're actually tracking,    return pv_definite_yes and set *STACK to point to the slot.  If    we're sure that they are not any of our stack slots, then return    pv_definite_no.  Otherwise, return pv_maybe.     DATA describes our current state (registers and stack slots).  */
end_comment

begin_function
specifier|static
name|enum
name|pv_boolean
name|s390_on_stack
parameter_list|(
name|struct
name|prologue_value
modifier|*
name|addr
parameter_list|,
name|CORE_ADDR
name|size
parameter_list|,
name|struct
name|s390_prologue_data
modifier|*
name|data
parameter_list|,
name|struct
name|prologue_value
modifier|*
modifier|*
name|stack
parameter_list|)
block|{
name|struct
name|prologue_value
name|gpr_spill_addr
decl_stmt|;
name|struct
name|prologue_value
name|fpr_spill_addr
decl_stmt|;
name|struct
name|prologue_value
name|back_chain_addr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|enum
name|pv_boolean
name|b
decl_stmt|;
comment|/* Construct the addresses of the spill arrays and the back chain.  */
name|pv_set_to_register
argument_list|(
operator|&
name|gpr_spill_addr
argument_list|,
name|S390_SP_REGNUM
argument_list|,
literal|2
operator|*
name|data
operator|->
name|gpr_size
argument_list|)
expr_stmt|;
name|pv_set_to_register
argument_list|(
operator|&
name|fpr_spill_addr
argument_list|,
name|S390_SP_REGNUM
argument_list|,
literal|16
operator|*
name|data
operator|->
name|gpr_size
argument_list|)
expr_stmt|;
name|back_chain_addr
operator|=
name|data
operator|->
name|gpr
index|[
name|S390_SP_REGNUM
operator|-
name|S390_R0_REGNUM
index|]
expr_stmt|;
comment|/* We have to check for GPR and FPR references using two separate      calls to pv_is_array_ref, since the GPR and FPR spill slots are      different sizes.  (SPILL is an array, but the thing it tracks      isn't really an array.)  */
comment|/* Was it a reference to the GPR spill array?  */
name|b
operator|=
name|pv_is_array_ref
argument_list|(
name|addr
argument_list|,
name|size
argument_list|,
operator|&
name|gpr_spill_addr
argument_list|,
literal|14
argument_list|,
name|data
operator|->
name|gpr_size
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|pv_definite_yes
condition|)
block|{
operator|*
name|stack
operator|=
operator|&
name|data
operator|->
name|spill
index|[
name|i
index|]
expr_stmt|;
return|return
name|pv_definite_yes
return|;
block|}
if|if
condition|(
name|b
operator|==
name|pv_maybe
condition|)
return|return
name|pv_maybe
return|;
comment|/* Was it a reference to the FPR spill array?  */
name|b
operator|=
name|pv_is_array_ref
argument_list|(
name|addr
argument_list|,
name|size
argument_list|,
operator|&
name|fpr_spill_addr
argument_list|,
literal|4
argument_list|,
name|data
operator|->
name|fpr_size
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|pv_definite_yes
condition|)
block|{
operator|*
name|stack
operator|=
operator|&
name|data
operator|->
name|spill
index|[
literal|14
operator|+
name|i
index|]
expr_stmt|;
return|return
name|pv_definite_yes
return|;
block|}
if|if
condition|(
name|b
operator|==
name|pv_maybe
condition|)
return|return
name|pv_maybe
return|;
comment|/* Was it a reference to the back chain?      This isn't quite right.  We ought to check whether we have      actually allocated any new frame at all.  */
name|b
operator|=
name|pv_is_array_ref
argument_list|(
name|addr
argument_list|,
name|size
argument_list|,
operator|&
name|back_chain_addr
argument_list|,
literal|1
argument_list|,
name|data
operator|->
name|gpr_size
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|pv_definite_yes
condition|)
block|{
operator|*
name|stack
operator|=
operator|&
name|data
operator|->
name|back_chain
expr_stmt|;
return|return
name|pv_definite_yes
return|;
block|}
if|if
condition|(
name|b
operator|==
name|pv_maybe
condition|)
return|return
name|pv_maybe
return|;
comment|/* All the above queries returned definite 'no's.  */
return|return
name|pv_definite_no
return|;
block|}
end_function

begin_comment
comment|/* Do a SIZE-byte store of VALUE to ADDR.  */
end_comment

begin_function
specifier|static
name|void
name|s390_store
parameter_list|(
name|struct
name|prologue_value
modifier|*
name|addr
parameter_list|,
name|CORE_ADDR
name|size
parameter_list|,
name|struct
name|prologue_value
modifier|*
name|value
parameter_list|,
name|struct
name|s390_prologue_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|prologue_value
modifier|*
name|stack
decl_stmt|;
comment|/* We can do it if it's definitely a reference to something on the stack.  */
if|if
condition|(
name|s390_on_stack
argument_list|(
name|addr
argument_list|,
name|size
argument_list|,
name|data
argument_list|,
operator|&
name|stack
argument_list|)
operator|==
name|pv_definite_yes
condition|)
block|{
operator|*
name|stack
operator|=
operator|*
name|value
expr_stmt|;
return|return;
block|}
comment|/* Note: If s390_on_stack returns pv_maybe, you might think we should      forget our cached values, as any of those might have been hit.       However, we make the assumption that --since the fields we track      are save areas private to compiler, and never directly exposed to       the user-- every access to our data is explicit.  Hence, every       memory access we cannot follow can't hit our data.  */
block|}
end_function

begin_comment
comment|/* Do a SIZE-byte load from ADDR into VALUE.  */
end_comment

begin_function
specifier|static
name|void
name|s390_load
parameter_list|(
name|struct
name|prologue_value
modifier|*
name|addr
parameter_list|,
name|CORE_ADDR
name|size
parameter_list|,
name|struct
name|prologue_value
modifier|*
name|value
parameter_list|,
name|struct
name|s390_prologue_data
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|prologue_value
modifier|*
name|stack
decl_stmt|;
comment|/* If it's a load from an in-line constant pool, then we can      simulate that, under the assumption that the code isn't      going to change between the time the processor actually      executed it creating the current frame, and the time when      we're analyzing the code to unwind past that frame.  */
if|if
condition|(
name|addr
operator|->
name|kind
operator|==
name|pv_constant
condition|)
block|{
name|struct
name|section_table
modifier|*
name|secp
decl_stmt|;
name|secp
operator|=
name|target_section_by_addr
argument_list|(
operator|&
name|current_target
argument_list|,
name|addr
operator|->
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
name|secp
operator|!=
name|NULL
operator|&&
operator|(
name|bfd_get_section_flags
argument_list|(
name|secp
operator|->
name|bfd
argument_list|,
name|secp
operator|->
name|the_bfd_section
argument_list|)
operator|&
name|SEC_READONLY
operator|)
condition|)
block|{
name|pv_set_to_constant
argument_list|(
name|value
argument_list|,
name|read_memory_integer
argument_list|(
name|addr
operator|->
name|k
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* If it's definitely a reference to something on the stack,       we can do that.  */
if|if
condition|(
name|s390_on_stack
argument_list|(
name|addr
argument_list|,
name|size
argument_list|,
name|data
argument_list|,
operator|&
name|stack
argument_list|)
operator|==
name|pv_definite_yes
condition|)
block|{
operator|*
name|value
operator|=
operator|*
name|stack
expr_stmt|;
return|return;
block|}
comment|/* Otherwise, we don't know the value.  */
name|pv_set_to_unknown
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Analyze the prologue of the function starting at START_PC,    continuing at most until CURRENT_PC.  Initialize DATA to    hold all information we find out about the state of the registers    and stack slots.  Return the address of the instruction after    the last one that changed the SP, FP, or back chain; or zero    on error.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|s390_analyze_prologue
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|CORE_ADDR
name|start_pc
parameter_list|,
name|CORE_ADDR
name|current_pc
parameter_list|,
name|struct
name|s390_prologue_data
modifier|*
name|data
parameter_list|)
block|{
name|int
name|word_size
init|=
name|gdbarch_ptr_bit
argument_list|(
name|gdbarch
argument_list|)
operator|/
literal|8
decl_stmt|;
comment|/* Our return value:      The address of the instruction after the last one that changed      the SP, FP, or back chain;  zero if we got an error trying to       read memory.  */
name|CORE_ADDR
name|result
init|=
name|start_pc
decl_stmt|;
comment|/* The current PC for our abstract interpretation.  */
name|CORE_ADDR
name|pc
decl_stmt|;
comment|/* The address of the next instruction after that.  */
name|CORE_ADDR
name|next_pc
decl_stmt|;
comment|/* Set up everything's initial value.  */
block|{
name|int
name|i
decl_stmt|;
comment|/* For the purpose of prologue tracking, we consider the GPR size to        be equal to the ABI word size, even if it is actually larger        (i.e. when running a 32-bit binary under a 64-bit kernel).  */
name|data
operator|->
name|gpr_size
operator|=
name|word_size
expr_stmt|;
name|data
operator|->
name|fpr_size
operator|=
literal|8
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|S390_NUM_GPRS
condition|;
name|i
operator|++
control|)
name|pv_set_to_register
argument_list|(
operator|&
name|data
operator|->
name|gpr
index|[
name|i
index|]
argument_list|,
name|S390_R0_REGNUM
operator|+
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|S390_NUM_FPRS
condition|;
name|i
operator|++
control|)
name|pv_set_to_register
argument_list|(
operator|&
name|data
operator|->
name|fpr
index|[
name|i
index|]
argument_list|,
name|S390_F0_REGNUM
operator|+
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|S390_NUM_SPILL_SLOTS
condition|;
name|i
operator|++
control|)
name|pv_set_to_unknown
argument_list|(
operator|&
name|data
operator|->
name|spill
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|pv_set_to_unknown
argument_list|(
operator|&
name|data
operator|->
name|back_chain
argument_list|)
expr_stmt|;
block|}
comment|/* Start interpreting instructions, until we hit the frame's      current PC or the first branch instruction.  */
for|for
control|(
name|pc
operator|=
name|start_pc
init|;
name|pc
operator|>
literal|0
operator|&&
name|pc
operator|<
name|current_pc
condition|;
name|pc
operator|=
name|next_pc
control|)
block|{
name|bfd_byte
name|insn
index|[
name|S390_MAX_INSTR_SIZE
index|]
decl_stmt|;
name|int
name|insn_len
init|=
name|s390_readinstruction
argument_list|(
name|insn
argument_list|,
name|pc
argument_list|)
decl_stmt|;
comment|/* Fields for various kinds of instructions.  */
name|unsigned
name|int
name|b2
decl_stmt|,
name|r1
decl_stmt|,
name|r2
decl_stmt|,
name|x2
decl_stmt|,
name|r3
decl_stmt|;
name|int
name|i2
decl_stmt|,
name|d2
decl_stmt|;
comment|/* The values of SP, FP, and back chain before this instruction,          for detecting instructions that change them.  */
name|struct
name|prologue_value
name|pre_insn_sp
decl_stmt|,
name|pre_insn_fp
decl_stmt|,
name|pre_insn_back_chain
decl_stmt|;
comment|/* If we got an error trying to read the instruction, report it.  */
if|if
condition|(
name|insn_len
operator|<
literal|0
condition|)
block|{
name|result
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|next_pc
operator|=
name|pc
operator|+
name|insn_len
expr_stmt|;
name|pre_insn_sp
operator|=
name|data
operator|->
name|gpr
index|[
name|S390_SP_REGNUM
operator|-
name|S390_R0_REGNUM
index|]
expr_stmt|;
name|pre_insn_fp
operator|=
name|data
operator|->
name|gpr
index|[
name|S390_FRAME_REGNUM
operator|-
name|S390_R0_REGNUM
index|]
expr_stmt|;
name|pre_insn_back_chain
operator|=
name|data
operator|->
name|back_chain
expr_stmt|;
comment|/* LHI r1, i2 --- load halfword immediate */
if|if
condition|(
name|word_size
operator|==
literal|4
operator|&&
name|is_ri
argument_list|(
name|insn
argument_list|,
name|op1_lhi
argument_list|,
name|op2_lhi
argument_list|,
operator|&
name|r1
argument_list|,
operator|&
name|i2
argument_list|)
condition|)
name|pv_set_to_constant
argument_list|(
operator|&
name|data
operator|->
name|gpr
index|[
name|r1
index|]
argument_list|,
name|i2
argument_list|)
expr_stmt|;
comment|/* LGHI r1, i2 --- load halfword immediate (64-bit version) */
elseif|else
if|if
condition|(
name|word_size
operator|==
literal|8
operator|&&
name|is_ri
argument_list|(
name|insn
argument_list|,
name|op1_lghi
argument_list|,
name|op2_lghi
argument_list|,
operator|&
name|r1
argument_list|,
operator|&
name|i2
argument_list|)
condition|)
name|pv_set_to_constant
argument_list|(
operator|&
name|data
operator|->
name|gpr
index|[
name|r1
index|]
argument_list|,
name|i2
argument_list|)
expr_stmt|;
comment|/* LR r1, r2 --- load from register */
elseif|else
if|if
condition|(
name|word_size
operator|==
literal|4
operator|&&
name|is_rr
argument_list|(
name|insn
argument_list|,
name|op_lr
argument_list|,
operator|&
name|r1
argument_list|,
operator|&
name|r2
argument_list|)
condition|)
name|data
operator|->
name|gpr
index|[
name|r1
index|]
operator|=
name|data
operator|->
name|gpr
index|[
name|r2
index|]
expr_stmt|;
comment|/* LGR r1, r2 --- load from register (64-bit version) */
elseif|else
if|if
condition|(
name|word_size
operator|==
literal|8
operator|&&
name|is_rre
argument_list|(
name|insn
argument_list|,
name|op_lgr
argument_list|,
operator|&
name|r1
argument_list|,
operator|&
name|r2
argument_list|)
condition|)
name|data
operator|->
name|gpr
index|[
name|r1
index|]
operator|=
name|data
operator|->
name|gpr
index|[
name|r2
index|]
expr_stmt|;
comment|/* L r1, d2(x2, b2) --- load */
elseif|else
if|if
condition|(
name|word_size
operator|==
literal|4
operator|&&
name|is_rx
argument_list|(
name|insn
argument_list|,
name|op_l
argument_list|,
operator|&
name|r1
argument_list|,
operator|&
name|d2
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|b2
argument_list|)
condition|)
block|{
name|struct
name|prologue_value
name|addr
decl_stmt|;
name|compute_x_addr
argument_list|(
operator|&
name|addr
argument_list|,
name|data
operator|->
name|gpr
argument_list|,
name|d2
argument_list|,
name|x2
argument_list|,
name|b2
argument_list|)
expr_stmt|;
name|s390_load
argument_list|(
operator|&
name|addr
argument_list|,
literal|4
argument_list|,
operator|&
name|data
operator|->
name|gpr
index|[
name|r1
index|]
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
comment|/* LY r1, d2(x2, b2) --- load (long-displacement version) */
elseif|else
if|if
condition|(
name|word_size
operator|==
literal|4
operator|&&
name|is_rxy
argument_list|(
name|insn
argument_list|,
name|op1_ly
argument_list|,
name|op2_ly
argument_list|,
operator|&
name|r1
argument_list|,
operator|&
name|d2
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|b2
argument_list|)
condition|)
block|{
name|struct
name|prologue_value
name|addr
decl_stmt|;
name|compute_x_addr
argument_list|(
operator|&
name|addr
argument_list|,
name|data
operator|->
name|gpr
argument_list|,
name|d2
argument_list|,
name|x2
argument_list|,
name|b2
argument_list|)
expr_stmt|;
name|s390_load
argument_list|(
operator|&
name|addr
argument_list|,
literal|4
argument_list|,
operator|&
name|data
operator|->
name|gpr
index|[
name|r1
index|]
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
comment|/* LG r1, d2(x2, b2) --- load (64-bit version) */
elseif|else
if|if
condition|(
name|word_size
operator|==
literal|8
operator|&&
name|is_rxy
argument_list|(
name|insn
argument_list|,
name|op1_lg
argument_list|,
name|op2_lg
argument_list|,
operator|&
name|r1
argument_list|,
operator|&
name|d2
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|b2
argument_list|)
condition|)
block|{
name|struct
name|prologue_value
name|addr
decl_stmt|;
name|compute_x_addr
argument_list|(
operator|&
name|addr
argument_list|,
name|data
operator|->
name|gpr
argument_list|,
name|d2
argument_list|,
name|x2
argument_list|,
name|b2
argument_list|)
expr_stmt|;
name|s390_load
argument_list|(
operator|&
name|addr
argument_list|,
literal|8
argument_list|,
operator|&
name|data
operator|->
name|gpr
index|[
name|r1
index|]
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
comment|/* ST r1, d2(x2, b2) --- store */
elseif|else
if|if
condition|(
name|word_size
operator|==
literal|4
operator|&&
name|is_rx
argument_list|(
name|insn
argument_list|,
name|op_st
argument_list|,
operator|&
name|r1
argument_list|,
operator|&
name|d2
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|b2
argument_list|)
condition|)
block|{
name|struct
name|prologue_value
name|addr
decl_stmt|;
name|compute_x_addr
argument_list|(
operator|&
name|addr
argument_list|,
name|data
operator|->
name|gpr
argument_list|,
name|d2
argument_list|,
name|x2
argument_list|,
name|b2
argument_list|)
expr_stmt|;
name|s390_store
argument_list|(
operator|&
name|addr
argument_list|,
literal|4
argument_list|,
operator|&
name|data
operator|->
name|gpr
index|[
name|r1
index|]
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
comment|/* STY r1, d2(x2, b2) --- store (long-displacement version) */
elseif|else
if|if
condition|(
name|word_size
operator|==
literal|4
operator|&&
name|is_rxy
argument_list|(
name|insn
argument_list|,
name|op1_sty
argument_list|,
name|op2_sty
argument_list|,
operator|&
name|r1
argument_list|,
operator|&
name|d2
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|b2
argument_list|)
condition|)
block|{
name|struct
name|prologue_value
name|addr
decl_stmt|;
name|compute_x_addr
argument_list|(
operator|&
name|addr
argument_list|,
name|data
operator|->
name|gpr
argument_list|,
name|d2
argument_list|,
name|x2
argument_list|,
name|b2
argument_list|)
expr_stmt|;
name|s390_store
argument_list|(
operator|&
name|addr
argument_list|,
literal|4
argument_list|,
operator|&
name|data
operator|->
name|gpr
index|[
name|r1
index|]
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
comment|/* STG r1, d2(x2, b2) --- store (64-bit version) */
elseif|else
if|if
condition|(
name|word_size
operator|==
literal|8
operator|&&
name|is_rxy
argument_list|(
name|insn
argument_list|,
name|op1_stg
argument_list|,
name|op2_stg
argument_list|,
operator|&
name|r1
argument_list|,
operator|&
name|d2
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|b2
argument_list|)
condition|)
block|{
name|struct
name|prologue_value
name|addr
decl_stmt|;
name|compute_x_addr
argument_list|(
operator|&
name|addr
argument_list|,
name|data
operator|->
name|gpr
argument_list|,
name|d2
argument_list|,
name|x2
argument_list|,
name|b2
argument_list|)
expr_stmt|;
name|s390_store
argument_list|(
operator|&
name|addr
argument_list|,
literal|8
argument_list|,
operator|&
name|data
operator|->
name|gpr
index|[
name|r1
index|]
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
comment|/* STD r1, d2(x2,b2) --- store floating-point register  */
elseif|else
if|if
condition|(
name|is_rx
argument_list|(
name|insn
argument_list|,
name|op_std
argument_list|,
operator|&
name|r1
argument_list|,
operator|&
name|d2
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|b2
argument_list|)
condition|)
block|{
name|struct
name|prologue_value
name|addr
decl_stmt|;
name|compute_x_addr
argument_list|(
operator|&
name|addr
argument_list|,
name|data
operator|->
name|gpr
argument_list|,
name|d2
argument_list|,
name|x2
argument_list|,
name|b2
argument_list|)
expr_stmt|;
name|s390_store
argument_list|(
operator|&
name|addr
argument_list|,
literal|8
argument_list|,
operator|&
name|data
operator|->
name|fpr
index|[
name|r1
index|]
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
comment|/* STM r1, r3, d2(b2) --- store multiple */
elseif|else
if|if
condition|(
name|word_size
operator|==
literal|4
operator|&&
name|is_rs
argument_list|(
name|insn
argument_list|,
name|op_stm
argument_list|,
operator|&
name|r1
argument_list|,
operator|&
name|r3
argument_list|,
operator|&
name|d2
argument_list|,
operator|&
name|b2
argument_list|)
condition|)
block|{
name|int
name|regnum
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|struct
name|prologue_value
name|addr
decl_stmt|;
for|for
control|(
name|regnum
operator|=
name|r1
operator|,
name|offset
operator|=
literal|0
init|;
name|regnum
operator|<=
name|r3
condition|;
name|regnum
operator|++
operator|,
name|offset
operator|+=
literal|4
control|)
block|{
name|compute_x_addr
argument_list|(
operator|&
name|addr
argument_list|,
name|data
operator|->
name|gpr
argument_list|,
name|d2
operator|+
name|offset
argument_list|,
literal|0
argument_list|,
name|b2
argument_list|)
expr_stmt|;
name|s390_store
argument_list|(
operator|&
name|addr
argument_list|,
literal|4
argument_list|,
operator|&
name|data
operator|->
name|gpr
index|[
name|regnum
index|]
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* STMY r1, r3, d2(b2) --- store multiple (long-displacement version) */
elseif|else
if|if
condition|(
name|word_size
operator|==
literal|4
operator|&&
name|is_rsy
argument_list|(
name|insn
argument_list|,
name|op1_stmy
argument_list|,
name|op2_stmy
argument_list|,
operator|&
name|r1
argument_list|,
operator|&
name|r3
argument_list|,
operator|&
name|d2
argument_list|,
operator|&
name|b2
argument_list|)
condition|)
block|{
name|int
name|regnum
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|struct
name|prologue_value
name|addr
decl_stmt|;
for|for
control|(
name|regnum
operator|=
name|r1
operator|,
name|offset
operator|=
literal|0
init|;
name|regnum
operator|<=
name|r3
condition|;
name|regnum
operator|++
operator|,
name|offset
operator|+=
literal|4
control|)
block|{
name|compute_x_addr
argument_list|(
operator|&
name|addr
argument_list|,
name|data
operator|->
name|gpr
argument_list|,
name|d2
operator|+
name|offset
argument_list|,
literal|0
argument_list|,
name|b2
argument_list|)
expr_stmt|;
name|s390_store
argument_list|(
operator|&
name|addr
argument_list|,
literal|4
argument_list|,
operator|&
name|data
operator|->
name|gpr
index|[
name|regnum
index|]
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* STMG r1, r3, d2(b2) --- store multiple (64-bit version) */
elseif|else
if|if
condition|(
name|word_size
operator|==
literal|8
operator|&&
name|is_rsy
argument_list|(
name|insn
argument_list|,
name|op1_stmg
argument_list|,
name|op2_stmg
argument_list|,
operator|&
name|r1
argument_list|,
operator|&
name|r3
argument_list|,
operator|&
name|d2
argument_list|,
operator|&
name|b2
argument_list|)
condition|)
block|{
name|int
name|regnum
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|struct
name|prologue_value
name|addr
decl_stmt|;
for|for
control|(
name|regnum
operator|=
name|r1
operator|,
name|offset
operator|=
literal|0
init|;
name|regnum
operator|<=
name|r3
condition|;
name|regnum
operator|++
operator|,
name|offset
operator|+=
literal|8
control|)
block|{
name|compute_x_addr
argument_list|(
operator|&
name|addr
argument_list|,
name|data
operator|->
name|gpr
argument_list|,
name|d2
operator|+
name|offset
argument_list|,
literal|0
argument_list|,
name|b2
argument_list|)
expr_stmt|;
name|s390_store
argument_list|(
operator|&
name|addr
argument_list|,
literal|8
argument_list|,
operator|&
name|data
operator|->
name|gpr
index|[
name|regnum
index|]
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* AHI r1, i2 --- add halfword immediate */
elseif|else
if|if
condition|(
name|word_size
operator|==
literal|4
operator|&&
name|is_ri
argument_list|(
name|insn
argument_list|,
name|op1_ahi
argument_list|,
name|op2_ahi
argument_list|,
operator|&
name|r1
argument_list|,
operator|&
name|i2
argument_list|)
condition|)
name|pv_add_constant
argument_list|(
operator|&
name|data
operator|->
name|gpr
index|[
name|r1
index|]
argument_list|,
name|i2
argument_list|)
expr_stmt|;
comment|/* AGHI r1, i2 --- add halfword immediate (64-bit version) */
elseif|else
if|if
condition|(
name|word_size
operator|==
literal|8
operator|&&
name|is_ri
argument_list|(
name|insn
argument_list|,
name|op1_aghi
argument_list|,
name|op2_aghi
argument_list|,
operator|&
name|r1
argument_list|,
operator|&
name|i2
argument_list|)
condition|)
name|pv_add_constant
argument_list|(
operator|&
name|data
operator|->
name|gpr
index|[
name|r1
index|]
argument_list|,
name|i2
argument_list|)
expr_stmt|;
comment|/* AR r1, r2 -- add register */
elseif|else
if|if
condition|(
name|word_size
operator|==
literal|4
operator|&&
name|is_rr
argument_list|(
name|insn
argument_list|,
name|op_ar
argument_list|,
operator|&
name|r1
argument_list|,
operator|&
name|r2
argument_list|)
condition|)
name|pv_add
argument_list|(
operator|&
name|data
operator|->
name|gpr
index|[
name|r1
index|]
argument_list|,
operator|&
name|data
operator|->
name|gpr
index|[
name|r1
index|]
argument_list|,
operator|&
name|data
operator|->
name|gpr
index|[
name|r2
index|]
argument_list|)
expr_stmt|;
comment|/* AGR r1, r2 -- add register (64-bit version) */
elseif|else
if|if
condition|(
name|word_size
operator|==
literal|8
operator|&&
name|is_rre
argument_list|(
name|insn
argument_list|,
name|op_agr
argument_list|,
operator|&
name|r1
argument_list|,
operator|&
name|r2
argument_list|)
condition|)
name|pv_add
argument_list|(
operator|&
name|data
operator|->
name|gpr
index|[
name|r1
index|]
argument_list|,
operator|&
name|data
operator|->
name|gpr
index|[
name|r1
index|]
argument_list|,
operator|&
name|data
operator|->
name|gpr
index|[
name|r2
index|]
argument_list|)
expr_stmt|;
comment|/* A r1, d2(x2, b2) -- add */
elseif|else
if|if
condition|(
name|word_size
operator|==
literal|4
operator|&&
name|is_rx
argument_list|(
name|insn
argument_list|,
name|op_a
argument_list|,
operator|&
name|r1
argument_list|,
operator|&
name|d2
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|b2
argument_list|)
condition|)
block|{
name|struct
name|prologue_value
name|addr
decl_stmt|;
name|struct
name|prologue_value
name|value
decl_stmt|;
name|compute_x_addr
argument_list|(
operator|&
name|addr
argument_list|,
name|data
operator|->
name|gpr
argument_list|,
name|d2
argument_list|,
name|x2
argument_list|,
name|b2
argument_list|)
expr_stmt|;
name|s390_load
argument_list|(
operator|&
name|addr
argument_list|,
literal|4
argument_list|,
operator|&
name|value
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|pv_add
argument_list|(
operator|&
name|data
operator|->
name|gpr
index|[
name|r1
index|]
argument_list|,
operator|&
name|data
operator|->
name|gpr
index|[
name|r1
index|]
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* AY r1, d2(x2, b2) -- add (long-displacement version) */
elseif|else
if|if
condition|(
name|word_size
operator|==
literal|4
operator|&&
name|is_rxy
argument_list|(
name|insn
argument_list|,
name|op1_ay
argument_list|,
name|op2_ay
argument_list|,
operator|&
name|r1
argument_list|,
operator|&
name|d2
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|b2
argument_list|)
condition|)
block|{
name|struct
name|prologue_value
name|addr
decl_stmt|;
name|struct
name|prologue_value
name|value
decl_stmt|;
name|compute_x_addr
argument_list|(
operator|&
name|addr
argument_list|,
name|data
operator|->
name|gpr
argument_list|,
name|d2
argument_list|,
name|x2
argument_list|,
name|b2
argument_list|)
expr_stmt|;
name|s390_load
argument_list|(
operator|&
name|addr
argument_list|,
literal|4
argument_list|,
operator|&
name|value
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|pv_add
argument_list|(
operator|&
name|data
operator|->
name|gpr
index|[
name|r1
index|]
argument_list|,
operator|&
name|data
operator|->
name|gpr
index|[
name|r1
index|]
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* AG r1, d2(x2, b2) -- add (64-bit version) */
elseif|else
if|if
condition|(
name|word_size
operator|==
literal|8
operator|&&
name|is_rxy
argument_list|(
name|insn
argument_list|,
name|op1_ag
argument_list|,
name|op2_ag
argument_list|,
operator|&
name|r1
argument_list|,
operator|&
name|d2
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|b2
argument_list|)
condition|)
block|{
name|struct
name|prologue_value
name|addr
decl_stmt|;
name|struct
name|prologue_value
name|value
decl_stmt|;
name|compute_x_addr
argument_list|(
operator|&
name|addr
argument_list|,
name|data
operator|->
name|gpr
argument_list|,
name|d2
argument_list|,
name|x2
argument_list|,
name|b2
argument_list|)
expr_stmt|;
name|s390_load
argument_list|(
operator|&
name|addr
argument_list|,
literal|8
argument_list|,
operator|&
name|value
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|pv_add
argument_list|(
operator|&
name|data
operator|->
name|gpr
index|[
name|r1
index|]
argument_list|,
operator|&
name|data
operator|->
name|gpr
index|[
name|r1
index|]
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* SR r1, r2 -- subtract register */
elseif|else
if|if
condition|(
name|word_size
operator|==
literal|4
operator|&&
name|is_rr
argument_list|(
name|insn
argument_list|,
name|op_sr
argument_list|,
operator|&
name|r1
argument_list|,
operator|&
name|r2
argument_list|)
condition|)
name|pv_subtract
argument_list|(
operator|&
name|data
operator|->
name|gpr
index|[
name|r1
index|]
argument_list|,
operator|&
name|data
operator|->
name|gpr
index|[
name|r1
index|]
argument_list|,
operator|&
name|data
operator|->
name|gpr
index|[
name|r2
index|]
argument_list|)
expr_stmt|;
comment|/* SGR r1, r2 -- subtract register (64-bit version) */
elseif|else
if|if
condition|(
name|word_size
operator|==
literal|8
operator|&&
name|is_rre
argument_list|(
name|insn
argument_list|,
name|op_sgr
argument_list|,
operator|&
name|r1
argument_list|,
operator|&
name|r2
argument_list|)
condition|)
name|pv_subtract
argument_list|(
operator|&
name|data
operator|->
name|gpr
index|[
name|r1
index|]
argument_list|,
operator|&
name|data
operator|->
name|gpr
index|[
name|r1
index|]
argument_list|,
operator|&
name|data
operator|->
name|gpr
index|[
name|r2
index|]
argument_list|)
expr_stmt|;
comment|/* S r1, d2(x2, b2) -- subtract */
elseif|else
if|if
condition|(
name|word_size
operator|==
literal|4
operator|&&
name|is_rx
argument_list|(
name|insn
argument_list|,
name|op_s
argument_list|,
operator|&
name|r1
argument_list|,
operator|&
name|d2
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|b2
argument_list|)
condition|)
block|{
name|struct
name|prologue_value
name|addr
decl_stmt|;
name|struct
name|prologue_value
name|value
decl_stmt|;
name|compute_x_addr
argument_list|(
operator|&
name|addr
argument_list|,
name|data
operator|->
name|gpr
argument_list|,
name|d2
argument_list|,
name|x2
argument_list|,
name|b2
argument_list|)
expr_stmt|;
name|s390_load
argument_list|(
operator|&
name|addr
argument_list|,
literal|4
argument_list|,
operator|&
name|value
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|pv_subtract
argument_list|(
operator|&
name|data
operator|->
name|gpr
index|[
name|r1
index|]
argument_list|,
operator|&
name|data
operator|->
name|gpr
index|[
name|r1
index|]
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* SY r1, d2(x2, b2) -- subtract (long-displacement version) */
elseif|else
if|if
condition|(
name|word_size
operator|==
literal|4
operator|&&
name|is_rxy
argument_list|(
name|insn
argument_list|,
name|op1_sy
argument_list|,
name|op2_sy
argument_list|,
operator|&
name|r1
argument_list|,
operator|&
name|d2
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|b2
argument_list|)
condition|)
block|{
name|struct
name|prologue_value
name|addr
decl_stmt|;
name|struct
name|prologue_value
name|value
decl_stmt|;
name|compute_x_addr
argument_list|(
operator|&
name|addr
argument_list|,
name|data
operator|->
name|gpr
argument_list|,
name|d2
argument_list|,
name|x2
argument_list|,
name|b2
argument_list|)
expr_stmt|;
name|s390_load
argument_list|(
operator|&
name|addr
argument_list|,
literal|4
argument_list|,
operator|&
name|value
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|pv_subtract
argument_list|(
operator|&
name|data
operator|->
name|gpr
index|[
name|r1
index|]
argument_list|,
operator|&
name|data
operator|->
name|gpr
index|[
name|r1
index|]
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* SG r1, d2(x2, b2) -- subtract (64-bit version) */
elseif|else
if|if
condition|(
name|word_size
operator|==
literal|8
operator|&&
name|is_rxy
argument_list|(
name|insn
argument_list|,
name|op1_sg
argument_list|,
name|op2_sg
argument_list|,
operator|&
name|r1
argument_list|,
operator|&
name|d2
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|b2
argument_list|)
condition|)
block|{
name|struct
name|prologue_value
name|addr
decl_stmt|;
name|struct
name|prologue_value
name|value
decl_stmt|;
name|compute_x_addr
argument_list|(
operator|&
name|addr
argument_list|,
name|data
operator|->
name|gpr
argument_list|,
name|d2
argument_list|,
name|x2
argument_list|,
name|b2
argument_list|)
expr_stmt|;
name|s390_load
argument_list|(
operator|&
name|addr
argument_list|,
literal|8
argument_list|,
operator|&
name|value
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|pv_subtract
argument_list|(
operator|&
name|data
operator|->
name|gpr
index|[
name|r1
index|]
argument_list|,
operator|&
name|data
operator|->
name|gpr
index|[
name|r1
index|]
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* NR r1, r2 --- logical and */
elseif|else
if|if
condition|(
name|word_size
operator|==
literal|4
operator|&&
name|is_rr
argument_list|(
name|insn
argument_list|,
name|op_nr
argument_list|,
operator|&
name|r1
argument_list|,
operator|&
name|r2
argument_list|)
condition|)
name|pv_logical_and
argument_list|(
operator|&
name|data
operator|->
name|gpr
index|[
name|r1
index|]
argument_list|,
operator|&
name|data
operator|->
name|gpr
index|[
name|r1
index|]
argument_list|,
operator|&
name|data
operator|->
name|gpr
index|[
name|r2
index|]
argument_list|)
expr_stmt|;
comment|/* NGR r1, r2>--- logical and (64-bit version) */
elseif|else
if|if
condition|(
name|word_size
operator|==
literal|8
operator|&&
name|is_rre
argument_list|(
name|insn
argument_list|,
name|op_ngr
argument_list|,
operator|&
name|r1
argument_list|,
operator|&
name|r2
argument_list|)
condition|)
name|pv_logical_and
argument_list|(
operator|&
name|data
operator|->
name|gpr
index|[
name|r1
index|]
argument_list|,
operator|&
name|data
operator|->
name|gpr
index|[
name|r1
index|]
argument_list|,
operator|&
name|data
operator|->
name|gpr
index|[
name|r2
index|]
argument_list|)
expr_stmt|;
comment|/* LA r1, d2(x2, b2) --- load address */
elseif|else
if|if
condition|(
name|is_rx
argument_list|(
name|insn
argument_list|,
name|op_la
argument_list|,
operator|&
name|r1
argument_list|,
operator|&
name|d2
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|b2
argument_list|)
condition|)
name|compute_x_addr
argument_list|(
operator|&
name|data
operator|->
name|gpr
index|[
name|r1
index|]
argument_list|,
name|data
operator|->
name|gpr
argument_list|,
name|d2
argument_list|,
name|x2
argument_list|,
name|b2
argument_list|)
expr_stmt|;
comment|/* LAY r1, d2(x2, b2) --- load address (long-displacement version) */
elseif|else
if|if
condition|(
name|is_rxy
argument_list|(
name|insn
argument_list|,
name|op1_lay
argument_list|,
name|op2_lay
argument_list|,
operator|&
name|r1
argument_list|,
operator|&
name|d2
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|b2
argument_list|)
condition|)
name|compute_x_addr
argument_list|(
operator|&
name|data
operator|->
name|gpr
index|[
name|r1
index|]
argument_list|,
name|data
operator|->
name|gpr
argument_list|,
name|d2
argument_list|,
name|x2
argument_list|,
name|b2
argument_list|)
expr_stmt|;
comment|/* LARL r1, i2 --- load address relative long */
elseif|else
if|if
condition|(
name|is_ril
argument_list|(
name|insn
argument_list|,
name|op1_larl
argument_list|,
name|op2_larl
argument_list|,
operator|&
name|r1
argument_list|,
operator|&
name|i2
argument_list|)
condition|)
name|pv_set_to_constant
argument_list|(
operator|&
name|data
operator|->
name|gpr
index|[
name|r1
index|]
argument_list|,
name|pc
operator|+
name|i2
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|/* BASR r1, 0 --- branch and save          Since r2 is zero, this saves the PC in r1, but doesn't branch.  */
elseif|else
if|if
condition|(
name|is_rr
argument_list|(
name|insn
argument_list|,
name|op_basr
argument_list|,
operator|&
name|r1
argument_list|,
operator|&
name|r2
argument_list|)
operator|&&
name|r2
operator|==
literal|0
condition|)
name|pv_set_to_constant
argument_list|(
operator|&
name|data
operator|->
name|gpr
index|[
name|r1
index|]
argument_list|,
name|next_pc
argument_list|)
expr_stmt|;
comment|/* BRAS r1, i2 --- branch relative and save */
elseif|else
if|if
condition|(
name|is_ri
argument_list|(
name|insn
argument_list|,
name|op1_bras
argument_list|,
name|op2_bras
argument_list|,
operator|&
name|r1
argument_list|,
operator|&
name|i2
argument_list|)
condition|)
block|{
name|pv_set_to_constant
argument_list|(
operator|&
name|data
operator|->
name|gpr
index|[
name|r1
index|]
argument_list|,
name|next_pc
argument_list|)
expr_stmt|;
name|next_pc
operator|=
name|pc
operator|+
name|i2
operator|*
literal|2
expr_stmt|;
comment|/* We'd better not interpret any backward branches.  We'll              never terminate.  */
if|if
condition|(
name|next_pc
operator|<=
name|pc
condition|)
break|break;
block|}
comment|/* Terminate search when hitting any other branch instruction.  */
elseif|else
if|if
condition|(
name|is_rr
argument_list|(
name|insn
argument_list|,
name|op_basr
argument_list|,
operator|&
name|r1
argument_list|,
operator|&
name|r2
argument_list|)
operator|||
name|is_rx
argument_list|(
name|insn
argument_list|,
name|op_bas
argument_list|,
operator|&
name|r1
argument_list|,
operator|&
name|d2
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|b2
argument_list|)
operator|||
name|is_rr
argument_list|(
name|insn
argument_list|,
name|op_bcr
argument_list|,
operator|&
name|r1
argument_list|,
operator|&
name|r2
argument_list|)
operator|||
name|is_rx
argument_list|(
name|insn
argument_list|,
name|op_bc
argument_list|,
operator|&
name|r1
argument_list|,
operator|&
name|d2
argument_list|,
operator|&
name|x2
argument_list|,
operator|&
name|b2
argument_list|)
operator|||
name|is_ri
argument_list|(
name|insn
argument_list|,
name|op1_brc
argument_list|,
name|op2_brc
argument_list|,
operator|&
name|r1
argument_list|,
operator|&
name|i2
argument_list|)
operator|||
name|is_ril
argument_list|(
name|insn
argument_list|,
name|op1_brcl
argument_list|,
name|op2_brcl
argument_list|,
operator|&
name|r1
argument_list|,
operator|&
name|i2
argument_list|)
operator|||
name|is_ril
argument_list|(
name|insn
argument_list|,
name|op1_brasl
argument_list|,
name|op2_brasl
argument_list|,
operator|&
name|r2
argument_list|,
operator|&
name|i2
argument_list|)
condition|)
break|break;
else|else
comment|/* An instruction we don't know how to simulate.  The only            safe thing to do would be to set every value we're tracking            to 'unknown'.  Instead, we'll be optimistic: we assume that 	   we *can* interpret every instruction that the compiler uses 	   to manipulate any of the data we're interested in here -- 	   then we can just ignore anything else.  */
empty_stmt|;
comment|/* Record the address after the last instruction that changed          the FP, SP, or backlink.  Ignore instructions that changed          them back to their original values --- those are probably          restore instructions.  (The back chain is never restored,          just popped.)  */
block|{
name|struct
name|prologue_value
modifier|*
name|sp
init|=
operator|&
name|data
operator|->
name|gpr
index|[
name|S390_SP_REGNUM
operator|-
name|S390_R0_REGNUM
index|]
decl_stmt|;
name|struct
name|prologue_value
modifier|*
name|fp
init|=
operator|&
name|data
operator|->
name|gpr
index|[
name|S390_FRAME_REGNUM
operator|-
name|S390_R0_REGNUM
index|]
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|pv_is_identical
argument_list|(
operator|&
name|pre_insn_sp
argument_list|,
name|sp
argument_list|)
operator|&&
operator|!
name|pv_is_register
argument_list|(
name|sp
argument_list|,
name|S390_SP_REGNUM
argument_list|,
literal|0
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|pv_is_identical
argument_list|(
operator|&
name|pre_insn_fp
argument_list|,
name|fp
argument_list|)
operator|&&
operator|!
name|pv_is_register
argument_list|(
name|fp
argument_list|,
name|S390_FRAME_REGNUM
argument_list|,
literal|0
argument_list|)
operator|)
operator|||
operator|!
name|pv_is_identical
argument_list|(
operator|&
name|pre_insn_back_chain
argument_list|,
operator|&
name|data
operator|->
name|back_chain
argument_list|)
condition|)
name|result
operator|=
name|next_pc
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Advance PC across any function entry prologue instructions to reach     some "real" code.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|s390_skip_prologue
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|struct
name|s390_prologue_data
name|data
decl_stmt|;
name|CORE_ADDR
name|skip_pc
decl_stmt|;
name|skip_pc
operator|=
name|s390_analyze_prologue
argument_list|(
name|current_gdbarch
argument_list|,
name|pc
argument_list|,
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
return|return
name|skip_pc
condition|?
name|skip_pc
else|:
name|pc
return|;
block|}
end_function

begin_comment
comment|/* Return true if we are in the functin's epilogue, i.e. after the    instruction that destroyed the function's stack frame.  */
end_comment

begin_function
specifier|static
name|int
name|s390_in_function_epilogue_p
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|int
name|word_size
init|=
name|gdbarch_ptr_bit
argument_list|(
name|gdbarch
argument_list|)
operator|/
literal|8
decl_stmt|;
comment|/* In frameless functions, there's not frame to destroy and thus      we don't care about the epilogue.       In functions with frame, the epilogue sequence is a pair of      a LM-type instruction that restores (amongst others) the      return register %r14 and the stack pointer %r15, followed      by a branch 'br %r14' --or equivalent-- that effects the      actual return.       In that situation, this function needs to return 'true' in      exactly one case: when pc points to that branch instruction.       Thus we try to disassemble the one instructions immediately      preceeding pc and check whether it is an LM-type instruction      modifying the stack pointer.       Note that disassembling backwards is not reliable, so there      is a slight chance of false positives here ...  */
name|bfd_byte
name|insn
index|[
literal|6
index|]
decl_stmt|;
name|unsigned
name|int
name|r1
decl_stmt|,
name|r3
decl_stmt|,
name|b2
decl_stmt|;
name|int
name|d2
decl_stmt|;
if|if
condition|(
name|word_size
operator|==
literal|4
operator|&&
operator|!
name|read_memory_nobpt
argument_list|(
name|pc
operator|-
literal|4
argument_list|,
name|insn
argument_list|,
literal|4
argument_list|)
operator|&&
name|is_rs
argument_list|(
name|insn
argument_list|,
name|op_lm
argument_list|,
operator|&
name|r1
argument_list|,
operator|&
name|r3
argument_list|,
operator|&
name|d2
argument_list|,
operator|&
name|b2
argument_list|)
operator|&&
name|r3
operator|==
name|S390_SP_REGNUM
operator|-
name|S390_R0_REGNUM
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|word_size
operator|==
literal|4
operator|&&
operator|!
name|read_memory_nobpt
argument_list|(
name|pc
operator|-
literal|6
argument_list|,
name|insn
argument_list|,
literal|6
argument_list|)
operator|&&
name|is_rsy
argument_list|(
name|insn
argument_list|,
name|op1_lmy
argument_list|,
name|op2_lmy
argument_list|,
operator|&
name|r1
argument_list|,
operator|&
name|r3
argument_list|,
operator|&
name|d2
argument_list|,
operator|&
name|b2
argument_list|)
operator|&&
name|r3
operator|==
name|S390_SP_REGNUM
operator|-
name|S390_R0_REGNUM
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|word_size
operator|==
literal|8
operator|&&
operator|!
name|read_memory_nobpt
argument_list|(
name|pc
operator|-
literal|6
argument_list|,
name|insn
argument_list|,
literal|6
argument_list|)
operator|&&
name|is_rsy
argument_list|(
name|insn
argument_list|,
name|op1_lmg
argument_list|,
name|op2_lmg
argument_list|,
operator|&
name|r1
argument_list|,
operator|&
name|r3
argument_list|,
operator|&
name|d2
argument_list|,
operator|&
name|b2
argument_list|)
operator|&&
name|r3
operator|==
name|S390_SP_REGNUM
operator|-
name|S390_R0_REGNUM
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Normal stack frames.  */
end_comment

begin_struct
struct|struct
name|s390_unwind_cache
block|{
name|CORE_ADDR
name|func
decl_stmt|;
name|CORE_ADDR
name|frame_base
decl_stmt|;
name|CORE_ADDR
name|local_base
decl_stmt|;
name|struct
name|trad_frame_saved_reg
modifier|*
name|saved_regs
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|s390_prologue_frame_unwind_cache
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|struct
name|s390_unwind_cache
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|gdbarch
modifier|*
name|gdbarch
init|=
name|get_frame_arch
argument_list|(
name|next_frame
argument_list|)
decl_stmt|;
name|int
name|word_size
init|=
name|gdbarch_ptr_bit
argument_list|(
name|gdbarch
argument_list|)
operator|/
literal|8
decl_stmt|;
name|struct
name|s390_prologue_data
name|data
decl_stmt|;
name|struct
name|prologue_value
modifier|*
name|fp
init|=
operator|&
name|data
operator|.
name|gpr
index|[
name|S390_FRAME_REGNUM
operator|-
name|S390_R0_REGNUM
index|]
decl_stmt|;
name|struct
name|prologue_value
modifier|*
name|sp
init|=
operator|&
name|data
operator|.
name|gpr
index|[
name|S390_SP_REGNUM
operator|-
name|S390_R0_REGNUM
index|]
decl_stmt|;
name|int
name|slot_num
decl_stmt|;
name|CORE_ADDR
name|slot_addr
decl_stmt|;
name|CORE_ADDR
name|func
decl_stmt|;
name|CORE_ADDR
name|result
decl_stmt|;
name|ULONGEST
name|reg
decl_stmt|;
name|CORE_ADDR
name|prev_sp
decl_stmt|;
name|int
name|frame_pointer
decl_stmt|;
name|int
name|size
decl_stmt|;
comment|/* Try to find the function start address.  If we can't find it, we don't      bother searching for it -- with modern compilers this would be mostly      pointless anyway.  Trust that we'll either have valid DWARF-2 CFI data      or else a valid backchain ...  */
name|func
operator|=
name|frame_func_unwind
argument_list|(
name|next_frame
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|func
condition|)
return|return
literal|0
return|;
comment|/* Try to analyze the prologue.  */
name|result
operator|=
name|s390_analyze_prologue
argument_list|(
name|gdbarch
argument_list|,
name|func
argument_list|,
name|frame_pc_unwind
argument_list|(
name|next_frame
argument_list|)
argument_list|,
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
return|return
literal|0
return|;
comment|/* If this was successful, we should have found the instruction that      sets the stack pointer register to the previous value of the stack       pointer minus the frame size.  */
if|if
condition|(
name|sp
operator|->
name|kind
operator|!=
name|pv_register
operator|||
name|sp
operator|->
name|reg
operator|!=
name|S390_SP_REGNUM
condition|)
return|return
literal|0
return|;
comment|/* A frame size of zero at this point can mean either a real       frameless function, or else a failure to find the prologue.      Perform some sanity checks to verify we really have a       frameless function.  */
if|if
condition|(
name|sp
operator|->
name|k
operator|==
literal|0
condition|)
block|{
comment|/* If the next frame is a NORMAL_FRAME, this frame *cannot* have frame  	 size zero.  This is only possible if the next frame is a sentinel  	 frame, a dummy frame, or a signal trampoline frame.  */
if|if
condition|(
name|get_frame_type
argument_list|(
name|next_frame
argument_list|)
operator|==
name|NORMAL_FRAME
comment|/* For some reason, sentinel frames are NORMAL_FRAMEs 	     -- but they have negative frame level.  */
operator|&&
name|frame_relative_level
argument_list|(
name|next_frame
argument_list|)
operator|>=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* If we really have a frameless function, %r14 must be valid 	 -- in particular, it must point to a different function.  */
name|reg
operator|=
name|frame_unwind_register_unsigned
argument_list|(
name|next_frame
argument_list|,
name|S390_RETADDR_REGNUM
argument_list|)
expr_stmt|;
name|reg
operator|=
name|gdbarch_addr_bits_remove
argument_list|(
name|gdbarch
argument_list|,
name|reg
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|get_pc_function_start
argument_list|(
name|reg
argument_list|)
operator|==
name|func
condition|)
block|{
comment|/* However, there is one case where it *is* valid for %r14 	     to point to the same function -- if this is a recursive 	     call, and we have stopped in the prologue *before* the 	     stack frame was allocated.  	     Recognize this case by looking ahead a bit ...  */
name|struct
name|s390_prologue_data
name|data2
decl_stmt|;
name|struct
name|prologue_value
modifier|*
name|sp
init|=
operator|&
name|data2
operator|.
name|gpr
index|[
name|S390_SP_REGNUM
operator|-
name|S390_R0_REGNUM
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|s390_analyze_prologue
argument_list|(
name|gdbarch
argument_list|,
name|func
argument_list|,
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
argument_list|,
operator|&
name|data2
argument_list|)
operator|&&
name|sp
operator|->
name|kind
operator|==
name|pv_register
operator|&&
name|sp
operator|->
name|reg
operator|==
name|S390_SP_REGNUM
operator|&&
name|sp
operator|->
name|k
operator|!=
literal|0
operator|)
condition|)
return|return
literal|0
return|;
block|}
block|}
comment|/* OK, we've found valid prologue data.  */
name|size
operator|=
operator|-
name|sp
operator|->
name|k
expr_stmt|;
comment|/* If the frame pointer originally also holds the same value      as the stack pointer, we're probably using it.  If it holds      some other value -- even a constant offset -- it is most      likely used as temp register.  */
if|if
condition|(
name|pv_is_identical
argument_list|(
name|sp
argument_list|,
name|fp
argument_list|)
condition|)
name|frame_pointer
operator|=
name|S390_FRAME_REGNUM
expr_stmt|;
else|else
name|frame_pointer
operator|=
name|S390_SP_REGNUM
expr_stmt|;
comment|/* If we've detected a function with stack frame, we'll still have to       treat it as frameless if we're currently within the function epilog       code at a point where the frame pointer has already been restored.        This can only happen in an innermost frame.  */
if|if
condition|(
name|size
operator|>
literal|0
operator|&&
operator|(
name|get_frame_type
argument_list|(
name|next_frame
argument_list|)
operator|!=
name|NORMAL_FRAME
operator|||
name|frame_relative_level
argument_list|(
name|next_frame
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
comment|/* See the comment in s390_in_function_epilogue_p on why this is 	 not completely reliable ...  */
if|if
condition|(
name|s390_in_function_epilogue_p
argument_list|(
name|gdbarch
argument_list|,
name|frame_pc_unwind
argument_list|(
name|next_frame
argument_list|)
argument_list|)
condition|)
block|{
name|memset
argument_list|(
operator|&
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
name|frame_pointer
operator|=
name|S390_SP_REGNUM
expr_stmt|;
block|}
block|}
comment|/* Once we know the frame register and the frame size, we can unwind      the current value of the frame register from the next frame, and      add back the frame size to arrive that the previous frame's       stack pointer value.  */
name|prev_sp
operator|=
name|frame_unwind_register_unsigned
argument_list|(
name|next_frame
argument_list|,
name|frame_pointer
argument_list|)
operator|+
name|size
expr_stmt|;
comment|/* Scan the spill array; if a spill slot says it holds the      original value of some register, then record that slot's      address as the place that register was saved.  */
comment|/* Slots for %r2 .. %r15.  */
for|for
control|(
name|slot_num
operator|=
literal|0
operator|,
name|slot_addr
operator|=
name|prev_sp
operator|+
literal|2
operator|*
name|data
operator|.
name|gpr_size
init|;
name|slot_num
operator|<
literal|14
condition|;
name|slot_num
operator|++
operator|,
name|slot_addr
operator|+=
name|data
operator|.
name|gpr_size
control|)
block|{
name|struct
name|prologue_value
modifier|*
name|slot
init|=
operator|&
name|data
operator|.
name|spill
index|[
name|slot_num
index|]
decl_stmt|;
if|if
condition|(
name|slot
operator|->
name|kind
operator|==
name|pv_register
operator|&&
name|slot
operator|->
name|k
operator|==
literal|0
condition|)
name|info
operator|->
name|saved_regs
index|[
name|slot
operator|->
name|reg
index|]
operator|.
name|addr
operator|=
name|slot_addr
expr_stmt|;
block|}
comment|/* Slots for %f0 .. %f6.  */
for|for
control|(
name|slot_num
operator|=
literal|14
operator|,
name|slot_addr
operator|=
name|prev_sp
operator|+
literal|16
operator|*
name|data
operator|.
name|gpr_size
init|;
name|slot_num
operator|<
name|S390_NUM_SPILL_SLOTS
condition|;
name|slot_num
operator|++
operator|,
name|slot_addr
operator|+=
name|data
operator|.
name|fpr_size
control|)
block|{
name|struct
name|prologue_value
modifier|*
name|slot
init|=
operator|&
name|data
operator|.
name|spill
index|[
name|slot_num
index|]
decl_stmt|;
if|if
condition|(
name|slot
operator|->
name|kind
operator|==
name|pv_register
operator|&&
name|slot
operator|->
name|k
operator|==
literal|0
condition|)
name|info
operator|->
name|saved_regs
index|[
name|slot
operator|->
name|reg
index|]
operator|.
name|addr
operator|=
name|slot_addr
expr_stmt|;
block|}
comment|/* Function return will set PC to %r14.  */
name|info
operator|->
name|saved_regs
index|[
name|S390_PC_REGNUM
index|]
operator|=
name|info
operator|->
name|saved_regs
index|[
name|S390_RETADDR_REGNUM
index|]
expr_stmt|;
comment|/* In frameless functions, we unwind simply by moving the return      address to the PC.  However, if we actually stored to the      save area, use that -- we might only think the function frameless      because we're in the middle of the prologue ...  */
if|if
condition|(
name|size
operator|==
literal|0
operator|&&
operator|!
name|trad_frame_addr_p
argument_list|(
name|info
operator|->
name|saved_regs
argument_list|,
name|S390_PC_REGNUM
argument_list|)
condition|)
block|{
name|info
operator|->
name|saved_regs
index|[
name|S390_PC_REGNUM
index|]
operator|.
name|realreg
operator|=
name|S390_RETADDR_REGNUM
expr_stmt|;
block|}
comment|/* Another sanity check: unless this is a frameless function,      we should have found spill slots for SP and PC.      If not, we cannot unwind further -- this happens e.g. in      libc's thread_start routine.  */
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|trad_frame_addr_p
argument_list|(
name|info
operator|->
name|saved_regs
argument_list|,
name|S390_SP_REGNUM
argument_list|)
operator|||
operator|!
name|trad_frame_addr_p
argument_list|(
name|info
operator|->
name|saved_regs
argument_list|,
name|S390_PC_REGNUM
argument_list|)
condition|)
name|prev_sp
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* We use the current value of the frame register as local_base,      and the top of the register save area as frame_base.  */
if|if
condition|(
name|prev_sp
operator|!=
operator|-
literal|1
condition|)
block|{
name|info
operator|->
name|frame_base
operator|=
name|prev_sp
operator|+
literal|16
operator|*
name|word_size
operator|+
literal|32
expr_stmt|;
name|info
operator|->
name|local_base
operator|=
name|prev_sp
operator|-
name|size
expr_stmt|;
block|}
name|info
operator|->
name|func
operator|=
name|func
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|s390_backchain_frame_unwind_cache
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|struct
name|s390_unwind_cache
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|gdbarch
modifier|*
name|gdbarch
init|=
name|get_frame_arch
argument_list|(
name|next_frame
argument_list|)
decl_stmt|;
name|int
name|word_size
init|=
name|gdbarch_ptr_bit
argument_list|(
name|gdbarch
argument_list|)
operator|/
literal|8
decl_stmt|;
name|CORE_ADDR
name|backchain
decl_stmt|;
name|ULONGEST
name|reg
decl_stmt|;
name|LONGEST
name|sp
decl_stmt|;
comment|/* Get the backchain.  */
name|reg
operator|=
name|frame_unwind_register_unsigned
argument_list|(
name|next_frame
argument_list|,
name|S390_SP_REGNUM
argument_list|)
expr_stmt|;
name|backchain
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|reg
argument_list|,
name|word_size
argument_list|)
expr_stmt|;
comment|/* A zero backchain terminates the frame chain.  As additional      sanity check, let's verify that the spill slot for SP in the      save area pointed to by the backchain in fact links back to      the save area.  */
if|if
condition|(
name|backchain
operator|!=
literal|0
operator|&&
name|safe_read_memory_integer
argument_list|(
name|backchain
operator|+
literal|15
operator|*
name|word_size
argument_list|,
name|word_size
argument_list|,
operator|&
name|sp
argument_list|)
operator|&&
operator|(
name|CORE_ADDR
operator|)
name|sp
operator|==
name|backchain
condition|)
block|{
comment|/* We don't know which registers were saved, but it will have          to be at least %r14 and %r15.  This will allow us to continue          unwinding, but other prev-frame registers may be incorrect ...  */
name|info
operator|->
name|saved_regs
index|[
name|S390_SP_REGNUM
index|]
operator|.
name|addr
operator|=
name|backchain
operator|+
literal|15
operator|*
name|word_size
expr_stmt|;
name|info
operator|->
name|saved_regs
index|[
name|S390_RETADDR_REGNUM
index|]
operator|.
name|addr
operator|=
name|backchain
operator|+
literal|14
operator|*
name|word_size
expr_stmt|;
comment|/* Function return will set PC to %r14.  */
name|info
operator|->
name|saved_regs
index|[
name|S390_PC_REGNUM
index|]
operator|=
name|info
operator|->
name|saved_regs
index|[
name|S390_RETADDR_REGNUM
index|]
expr_stmt|;
comment|/* We use the current value of the frame register as local_base,          and the top of the register save area as frame_base.  */
name|info
operator|->
name|frame_base
operator|=
name|backchain
operator|+
literal|16
operator|*
name|word_size
operator|+
literal|32
expr_stmt|;
name|info
operator|->
name|local_base
operator|=
name|reg
expr_stmt|;
block|}
name|info
operator|->
name|func
operator|=
name|frame_pc_unwind
argument_list|(
name|next_frame
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|s390_unwind_cache
modifier|*
name|s390_frame_unwind_cache
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_prologue_cache
parameter_list|)
block|{
name|struct
name|s390_unwind_cache
modifier|*
name|info
decl_stmt|;
if|if
condition|(
operator|*
name|this_prologue_cache
condition|)
return|return
operator|*
name|this_prologue_cache
return|;
name|info
operator|=
name|FRAME_OBSTACK_ZALLOC
argument_list|(
expr|struct
name|s390_unwind_cache
argument_list|)
expr_stmt|;
operator|*
name|this_prologue_cache
operator|=
name|info
expr_stmt|;
name|info
operator|->
name|saved_regs
operator|=
name|trad_frame_alloc_saved_regs
argument_list|(
name|next_frame
argument_list|)
expr_stmt|;
name|info
operator|->
name|func
operator|=
operator|-
literal|1
expr_stmt|;
name|info
operator|->
name|frame_base
operator|=
operator|-
literal|1
expr_stmt|;
name|info
operator|->
name|local_base
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Try to use prologue analysis to fill the unwind cache.      If this fails, fall back to reading the stack backchain.  */
if|if
condition|(
operator|!
name|s390_prologue_frame_unwind_cache
argument_list|(
name|next_frame
argument_list|,
name|info
argument_list|)
condition|)
name|s390_backchain_frame_unwind_cache
argument_list|(
name|next_frame
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return
name|info
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|s390_frame_this_id
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_prologue_cache
parameter_list|,
name|struct
name|frame_id
modifier|*
name|this_id
parameter_list|)
block|{
name|struct
name|s390_unwind_cache
modifier|*
name|info
init|=
name|s390_frame_unwind_cache
argument_list|(
name|next_frame
argument_list|,
name|this_prologue_cache
argument_list|)
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|frame_base
operator|==
operator|-
literal|1
condition|)
return|return;
operator|*
name|this_id
operator|=
name|frame_id_build
argument_list|(
name|info
operator|->
name|frame_base
argument_list|,
name|info
operator|->
name|func
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s390_frame_prev_register
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_prologue_cache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|int
modifier|*
name|optimizedp
parameter_list|,
name|enum
name|lval_type
modifier|*
name|lvalp
parameter_list|,
name|CORE_ADDR
modifier|*
name|addrp
parameter_list|,
name|int
modifier|*
name|realnump
parameter_list|,
name|void
modifier|*
name|bufferp
parameter_list|)
block|{
name|struct
name|s390_unwind_cache
modifier|*
name|info
init|=
name|s390_frame_unwind_cache
argument_list|(
name|next_frame
argument_list|,
name|this_prologue_cache
argument_list|)
decl_stmt|;
name|trad_frame_prev_register
argument_list|(
name|next_frame
argument_list|,
name|info
operator|->
name|saved_regs
argument_list|,
name|regnum
argument_list|,
name|optimizedp
argument_list|,
name|lvalp
argument_list|,
name|addrp
argument_list|,
name|realnump
argument_list|,
name|bufferp
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|frame_unwind
name|s390_frame_unwind
init|=
block|{
name|NORMAL_FRAME
block|,
name|s390_frame_this_id
block|,
name|s390_frame_prev_register
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|struct
name|frame_unwind
modifier|*
name|s390_frame_sniffer
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
return|return
operator|&
name|s390_frame_unwind
return|;
block|}
end_function

begin_comment
comment|/* Code stubs and their stack frames.  For things like PLTs and NULL    function calls (where there is no true frame and the return address    is in the RETADDR register).  */
end_comment

begin_struct
struct|struct
name|s390_stub_unwind_cache
block|{
name|CORE_ADDR
name|frame_base
decl_stmt|;
name|struct
name|trad_frame_saved_reg
modifier|*
name|saved_regs
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|struct
name|s390_stub_unwind_cache
modifier|*
name|s390_stub_frame_unwind_cache
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_prologue_cache
parameter_list|)
block|{
name|struct
name|gdbarch
modifier|*
name|gdbarch
init|=
name|get_frame_arch
argument_list|(
name|next_frame
argument_list|)
decl_stmt|;
name|int
name|word_size
init|=
name|gdbarch_ptr_bit
argument_list|(
name|gdbarch
argument_list|)
operator|/
literal|8
decl_stmt|;
name|struct
name|s390_stub_unwind_cache
modifier|*
name|info
decl_stmt|;
name|ULONGEST
name|reg
decl_stmt|;
if|if
condition|(
operator|*
name|this_prologue_cache
condition|)
return|return
operator|*
name|this_prologue_cache
return|;
name|info
operator|=
name|FRAME_OBSTACK_ZALLOC
argument_list|(
expr|struct
name|s390_stub_unwind_cache
argument_list|)
expr_stmt|;
operator|*
name|this_prologue_cache
operator|=
name|info
expr_stmt|;
name|info
operator|->
name|saved_regs
operator|=
name|trad_frame_alloc_saved_regs
argument_list|(
name|next_frame
argument_list|)
expr_stmt|;
comment|/* The return address is in register %r14.  */
name|info
operator|->
name|saved_regs
index|[
name|S390_PC_REGNUM
index|]
operator|.
name|realreg
operator|=
name|S390_RETADDR_REGNUM
expr_stmt|;
comment|/* Retrieve stack pointer and determine our frame base.  */
name|reg
operator|=
name|frame_unwind_register_unsigned
argument_list|(
name|next_frame
argument_list|,
name|S390_SP_REGNUM
argument_list|)
expr_stmt|;
name|info
operator|->
name|frame_base
operator|=
name|reg
operator|+
literal|16
operator|*
name|word_size
operator|+
literal|32
expr_stmt|;
return|return
name|info
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|s390_stub_frame_this_id
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_prologue_cache
parameter_list|,
name|struct
name|frame_id
modifier|*
name|this_id
parameter_list|)
block|{
name|struct
name|s390_stub_unwind_cache
modifier|*
name|info
init|=
name|s390_stub_frame_unwind_cache
argument_list|(
name|next_frame
argument_list|,
name|this_prologue_cache
argument_list|)
decl_stmt|;
operator|*
name|this_id
operator|=
name|frame_id_build
argument_list|(
name|info
operator|->
name|frame_base
argument_list|,
name|frame_pc_unwind
argument_list|(
name|next_frame
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s390_stub_frame_prev_register
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_prologue_cache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|int
modifier|*
name|optimizedp
parameter_list|,
name|enum
name|lval_type
modifier|*
name|lvalp
parameter_list|,
name|CORE_ADDR
modifier|*
name|addrp
parameter_list|,
name|int
modifier|*
name|realnump
parameter_list|,
name|void
modifier|*
name|bufferp
parameter_list|)
block|{
name|struct
name|s390_stub_unwind_cache
modifier|*
name|info
init|=
name|s390_stub_frame_unwind_cache
argument_list|(
name|next_frame
argument_list|,
name|this_prologue_cache
argument_list|)
decl_stmt|;
name|trad_frame_prev_register
argument_list|(
name|next_frame
argument_list|,
name|info
operator|->
name|saved_regs
argument_list|,
name|regnum
argument_list|,
name|optimizedp
argument_list|,
name|lvalp
argument_list|,
name|addrp
argument_list|,
name|realnump
argument_list|,
name|bufferp
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|frame_unwind
name|s390_stub_frame_unwind
init|=
block|{
name|NORMAL_FRAME
block|,
name|s390_stub_frame_this_id
block|,
name|s390_stub_frame_prev_register
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|struct
name|frame_unwind
modifier|*
name|s390_stub_frame_sniffer
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
name|CORE_ADDR
name|pc
init|=
name|frame_pc_unwind
argument_list|(
name|next_frame
argument_list|)
decl_stmt|;
name|bfd_byte
name|insn
index|[
name|S390_MAX_INSTR_SIZE
index|]
decl_stmt|;
comment|/* If the current PC points to non-readable memory, we assume we      have trapped due to an invalid function pointer call.  We handle      the non-existing current function like a PLT stub.  */
if|if
condition|(
name|in_plt_section
argument_list|(
name|pc
argument_list|,
name|NULL
argument_list|)
operator|||
name|s390_readinstruction
argument_list|(
name|insn
argument_list|,
name|pc
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|&
name|s390_stub_frame_unwind
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Signal trampoline stack frames.  */
end_comment

begin_struct
struct|struct
name|s390_sigtramp_unwind_cache
block|{
name|CORE_ADDR
name|frame_base
decl_stmt|;
name|struct
name|trad_frame_saved_reg
modifier|*
name|saved_regs
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|struct
name|s390_sigtramp_unwind_cache
modifier|*
name|s390_sigtramp_frame_unwind_cache
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_prologue_cache
parameter_list|)
block|{
name|struct
name|gdbarch
modifier|*
name|gdbarch
init|=
name|get_frame_arch
argument_list|(
name|next_frame
argument_list|)
decl_stmt|;
name|int
name|word_size
init|=
name|gdbarch_ptr_bit
argument_list|(
name|gdbarch
argument_list|)
operator|/
literal|8
decl_stmt|;
name|struct
name|s390_sigtramp_unwind_cache
modifier|*
name|info
decl_stmt|;
name|ULONGEST
name|this_sp
decl_stmt|,
name|prev_sp
decl_stmt|;
name|CORE_ADDR
name|next_ra
decl_stmt|,
name|next_cfa
decl_stmt|,
name|sigreg_ptr
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|*
name|this_prologue_cache
condition|)
return|return
operator|*
name|this_prologue_cache
return|;
name|info
operator|=
name|FRAME_OBSTACK_ZALLOC
argument_list|(
expr|struct
name|s390_sigtramp_unwind_cache
argument_list|)
expr_stmt|;
operator|*
name|this_prologue_cache
operator|=
name|info
expr_stmt|;
name|info
operator|->
name|saved_regs
operator|=
name|trad_frame_alloc_saved_regs
argument_list|(
name|next_frame
argument_list|)
expr_stmt|;
name|this_sp
operator|=
name|frame_unwind_register_unsigned
argument_list|(
name|next_frame
argument_list|,
name|S390_SP_REGNUM
argument_list|)
expr_stmt|;
name|next_ra
operator|=
name|frame_pc_unwind
argument_list|(
name|next_frame
argument_list|)
expr_stmt|;
name|next_cfa
operator|=
name|this_sp
operator|+
literal|16
operator|*
name|word_size
operator|+
literal|32
expr_stmt|;
comment|/* New-style RT frame: 	retcode + alignment (8 bytes) 	siginfo (128 bytes) 	ucontext (contains sigregs at offset 5 words)  */
if|if
condition|(
name|next_ra
operator|==
name|next_cfa
condition|)
block|{
name|sigreg_ptr
operator|=
name|next_cfa
operator|+
literal|8
operator|+
literal|128
operator|+
literal|5
operator|*
name|word_size
expr_stmt|;
block|}
comment|/* Old-style RT frame and all non-RT frames: 	old signal mask (8 bytes) 	pointer to sigregs  */
else|else
block|{
name|sigreg_ptr
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|next_cfa
operator|+
literal|8
argument_list|,
name|word_size
argument_list|)
expr_stmt|;
block|}
comment|/* The sigregs structure looks like this:             long   psw_mask;             long   psw_addr;             long   gprs[16];             int    acrs[16];             int    fpc;             int    __pad;             double fprs[16];  */
comment|/* Let's ignore the PSW mask, it will not be restored anyway.  */
name|sigreg_ptr
operator|+=
name|word_size
expr_stmt|;
comment|/* Next comes the PSW address.  */
name|info
operator|->
name|saved_regs
index|[
name|S390_PC_REGNUM
index|]
operator|.
name|addr
operator|=
name|sigreg_ptr
expr_stmt|;
name|sigreg_ptr
operator|+=
name|word_size
expr_stmt|;
comment|/* Then the GPRs.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|info
operator|->
name|saved_regs
index|[
name|S390_R0_REGNUM
operator|+
name|i
index|]
operator|.
name|addr
operator|=
name|sigreg_ptr
expr_stmt|;
name|sigreg_ptr
operator|+=
name|word_size
expr_stmt|;
block|}
comment|/* Then the ACRs.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|info
operator|->
name|saved_regs
index|[
name|S390_A0_REGNUM
operator|+
name|i
index|]
operator|.
name|addr
operator|=
name|sigreg_ptr
expr_stmt|;
name|sigreg_ptr
operator|+=
literal|4
expr_stmt|;
block|}
comment|/* The floating-point control word.  */
name|info
operator|->
name|saved_regs
index|[
name|S390_FPC_REGNUM
index|]
operator|.
name|addr
operator|=
name|sigreg_ptr
expr_stmt|;
name|sigreg_ptr
operator|+=
literal|8
expr_stmt|;
comment|/* And finally the FPRs.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|info
operator|->
name|saved_regs
index|[
name|S390_F0_REGNUM
operator|+
name|i
index|]
operator|.
name|addr
operator|=
name|sigreg_ptr
expr_stmt|;
name|sigreg_ptr
operator|+=
literal|8
expr_stmt|;
block|}
comment|/* Restore the previous frame's SP.  */
name|prev_sp
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|info
operator|->
name|saved_regs
index|[
name|S390_SP_REGNUM
index|]
operator|.
name|addr
argument_list|,
name|word_size
argument_list|)
expr_stmt|;
comment|/* Determine our frame base.  */
name|info
operator|->
name|frame_base
operator|=
name|prev_sp
operator|+
literal|16
operator|*
name|word_size
operator|+
literal|32
expr_stmt|;
return|return
name|info
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|s390_sigtramp_frame_this_id
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_prologue_cache
parameter_list|,
name|struct
name|frame_id
modifier|*
name|this_id
parameter_list|)
block|{
name|struct
name|s390_sigtramp_unwind_cache
modifier|*
name|info
init|=
name|s390_sigtramp_frame_unwind_cache
argument_list|(
name|next_frame
argument_list|,
name|this_prologue_cache
argument_list|)
decl_stmt|;
operator|*
name|this_id
operator|=
name|frame_id_build
argument_list|(
name|info
operator|->
name|frame_base
argument_list|,
name|frame_pc_unwind
argument_list|(
name|next_frame
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|s390_sigtramp_frame_prev_register
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_prologue_cache
parameter_list|,
name|int
name|regnum
parameter_list|,
name|int
modifier|*
name|optimizedp
parameter_list|,
name|enum
name|lval_type
modifier|*
name|lvalp
parameter_list|,
name|CORE_ADDR
modifier|*
name|addrp
parameter_list|,
name|int
modifier|*
name|realnump
parameter_list|,
name|void
modifier|*
name|bufferp
parameter_list|)
block|{
name|struct
name|s390_sigtramp_unwind_cache
modifier|*
name|info
init|=
name|s390_sigtramp_frame_unwind_cache
argument_list|(
name|next_frame
argument_list|,
name|this_prologue_cache
argument_list|)
decl_stmt|;
name|trad_frame_prev_register
argument_list|(
name|next_frame
argument_list|,
name|info
operator|->
name|saved_regs
argument_list|,
name|regnum
argument_list|,
name|optimizedp
argument_list|,
name|lvalp
argument_list|,
name|addrp
argument_list|,
name|realnump
argument_list|,
name|bufferp
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|frame_unwind
name|s390_sigtramp_frame_unwind
init|=
block|{
name|SIGTRAMP_FRAME
block|,
name|s390_sigtramp_frame_this_id
block|,
name|s390_sigtramp_frame_prev_register
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|struct
name|frame_unwind
modifier|*
name|s390_sigtramp_frame_sniffer
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
name|CORE_ADDR
name|pc
init|=
name|frame_pc_unwind
argument_list|(
name|next_frame
argument_list|)
decl_stmt|;
name|bfd_byte
name|sigreturn
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|read_memory_nobpt
argument_list|(
name|pc
argument_list|,
name|sigreturn
argument_list|,
literal|2
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|sigreturn
index|[
literal|0
index|]
operator|!=
literal|0x0a
comment|/* svc */
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|sigreturn
index|[
literal|1
index|]
operator|!=
literal|119
comment|/* sigreturn */
operator|&&
name|sigreturn
index|[
literal|1
index|]
operator|!=
literal|173
comment|/* rt_sigreturn */
condition|)
return|return
name|NULL
return|;
return|return
operator|&
name|s390_sigtramp_frame_unwind
return|;
block|}
end_function

begin_comment
comment|/* Frame base handling.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|s390_frame_base_address
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|)
block|{
name|struct
name|s390_unwind_cache
modifier|*
name|info
init|=
name|s390_frame_unwind_cache
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|)
decl_stmt|;
return|return
name|info
operator|->
name|frame_base
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|s390_local_base_address
parameter_list|(
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|,
name|void
modifier|*
modifier|*
name|this_cache
parameter_list|)
block|{
name|struct
name|s390_unwind_cache
modifier|*
name|info
init|=
name|s390_frame_unwind_cache
argument_list|(
name|next_frame
argument_list|,
name|this_cache
argument_list|)
decl_stmt|;
return|return
name|info
operator|->
name|local_base
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|frame_base
name|s390_frame_base
init|=
block|{
operator|&
name|s390_frame_unwind
block|,
name|s390_frame_base_address
block|,
name|s390_local_base_address
block|,
name|s390_local_base_address
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|CORE_ADDR
name|s390_unwind_pc
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
name|ULONGEST
name|pc
decl_stmt|;
name|pc
operator|=
name|frame_unwind_register_unsigned
argument_list|(
name|next_frame
argument_list|,
name|S390_PC_REGNUM
argument_list|)
expr_stmt|;
return|return
name|gdbarch_addr_bits_remove
argument_list|(
name|gdbarch
argument_list|,
name|pc
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|s390_unwind_sp
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
name|ULONGEST
name|sp
decl_stmt|;
name|sp
operator|=
name|frame_unwind_register_unsigned
argument_list|(
name|next_frame
argument_list|,
name|S390_SP_REGNUM
argument_list|)
expr_stmt|;
return|return
name|gdbarch_addr_bits_remove
argument_list|(
name|gdbarch
argument_list|,
name|sp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* DWARF-2 frame support.  */
end_comment

begin_function
specifier|static
name|void
name|s390_dwarf2_frame_init_reg
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|int
name|regnum
parameter_list|,
name|struct
name|dwarf2_frame_state_reg
modifier|*
name|reg
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|gdbarch
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|tdep
operator|->
name|abi
condition|)
block|{
case|case
name|ABI_LINUX_S390
case|:
comment|/* Call-saved registers.  */
if|if
condition|(
operator|(
name|regnum
operator|>=
name|S390_R6_REGNUM
operator|&&
name|regnum
operator|<=
name|S390_R15_REGNUM
operator|)
operator|||
name|regnum
operator|==
name|S390_F4_REGNUM
operator|||
name|regnum
operator|==
name|S390_F6_REGNUM
condition|)
name|reg
operator|->
name|how
operator|=
name|DWARF2_FRAME_REG_SAME_VALUE
expr_stmt|;
comment|/* Call-clobbered registers.  */
elseif|else
if|if
condition|(
operator|(
name|regnum
operator|>=
name|S390_R0_REGNUM
operator|&&
name|regnum
operator|<=
name|S390_R5_REGNUM
operator|)
operator|||
operator|(
name|regnum
operator|>=
name|S390_F0_REGNUM
operator|&&
name|regnum
operator|<=
name|S390_F15_REGNUM
operator|&&
name|regnum
operator|!=
name|S390_F4_REGNUM
operator|&&
name|regnum
operator|!=
name|S390_F6_REGNUM
operator|)
condition|)
name|reg
operator|->
name|how
operator|=
name|DWARF2_FRAME_REG_UNDEFINED
expr_stmt|;
comment|/* The return address column.  */
elseif|else
if|if
condition|(
name|regnum
operator|==
name|S390_PC_REGNUM
condition|)
name|reg
operator|->
name|how
operator|=
name|DWARF2_FRAME_REG_RA
expr_stmt|;
break|break;
case|case
name|ABI_LINUX_ZSERIES
case|:
comment|/* Call-saved registers.  */
if|if
condition|(
operator|(
name|regnum
operator|>=
name|S390_R6_REGNUM
operator|&&
name|regnum
operator|<=
name|S390_R15_REGNUM
operator|)
operator|||
operator|(
name|regnum
operator|>=
name|S390_F8_REGNUM
operator|&&
name|regnum
operator|<=
name|S390_F15_REGNUM
operator|)
condition|)
name|reg
operator|->
name|how
operator|=
name|DWARF2_FRAME_REG_SAME_VALUE
expr_stmt|;
comment|/* Call-clobbered registers.  */
elseif|else
if|if
condition|(
operator|(
name|regnum
operator|>=
name|S390_R0_REGNUM
operator|&&
name|regnum
operator|<=
name|S390_R5_REGNUM
operator|)
operator|||
operator|(
name|regnum
operator|>=
name|S390_F0_REGNUM
operator|&&
name|regnum
operator|<=
name|S390_F7_REGNUM
operator|)
condition|)
name|reg
operator|->
name|how
operator|=
name|DWARF2_FRAME_REG_UNDEFINED
expr_stmt|;
comment|/* The return address column.  */
elseif|else
if|if
condition|(
name|regnum
operator|==
name|S390_PC_REGNUM
condition|)
name|reg
operator|->
name|how
operator|=
name|DWARF2_FRAME_REG_RA
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Dummy function calls.  */
end_comment

begin_comment
comment|/* Return non-zero if TYPE is an integer-like type, zero otherwise.    "Integer-like" types are those that should be passed the way    integers are: integers, enums, ranges, characters, and booleans.  */
end_comment

begin_function
specifier|static
name|int
name|is_integer_like
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|enum
name|type_code
name|code
init|=
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
return|return
operator|(
name|code
operator|==
name|TYPE_CODE_INT
operator|||
name|code
operator|==
name|TYPE_CODE_ENUM
operator|||
name|code
operator|==
name|TYPE_CODE_RANGE
operator|||
name|code
operator|==
name|TYPE_CODE_CHAR
operator|||
name|code
operator|==
name|TYPE_CODE_BOOL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if TYPE is a pointer-like type, zero otherwise.    "Pointer-like" types are those that should be passed the way    pointers are: pointers and references.  */
end_comment

begin_function
specifier|static
name|int
name|is_pointer_like
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|enum
name|type_code
name|code
init|=
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
return|return
operator|(
name|code
operator|==
name|TYPE_CODE_PTR
operator|||
name|code
operator|==
name|TYPE_CODE_REF
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if TYPE is a `float singleton' or `double    singleton', zero otherwise.     A `T singleton' is a struct type with one member, whose type is    either T or a `T singleton'.  So, the following are all float    singletons:     struct { float x };    struct { struct { float x; } x; };    struct { struct { struct { float x; } x; } x; };     ... and so on.     All such structures are passed as if they were floats or doubles,    as the (revised) ABI says.  */
end_comment

begin_function
specifier|static
name|int
name|is_float_singleton
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|&&
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|==
literal|1
condition|)
block|{
name|struct
name|type
modifier|*
name|singleton_type
init|=
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|singleton_type
argument_list|)
expr_stmt|;
return|return
operator|(
name|TYPE_CODE
argument_list|(
name|singleton_type
argument_list|)
operator|==
name|TYPE_CODE_FLT
operator|||
name|is_float_singleton
argument_list|(
name|singleton_type
argument_list|)
operator|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if TYPE is a struct-like type, zero otherwise.    "Struct-like" types are those that should be passed as structs are:    structs and unions.     As an odd quirk, not mentioned in the ABI, GCC passes float and    double singletons as if they were a plain float, double, etc.  (The    corresponding union types are handled normally.)  So we exclude    those types here.  *shrug* */
end_comment

begin_function
specifier|static
name|int
name|is_struct_like
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|enum
name|type_code
name|code
init|=
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
return|return
operator|(
name|code
operator|==
name|TYPE_CODE_UNION
operator|||
operator|(
name|code
operator|==
name|TYPE_CODE_STRUCT
operator|&&
operator|!
name|is_float_singleton
argument_list|(
name|type
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if TYPE is a float-like type, zero otherwise.    "Float-like" types are those that should be passed as    floating-point values are.     You'd think this would just be floats, doubles, long doubles, etc.    But as an odd quirk, not mentioned in the ABI, GCC passes float and    double singletons as if they were a plain float, double, etc.  (The    corresponding union types are handled normally.)  So we include    those types here.  *shrug* */
end_comment

begin_function
specifier|static
name|int
name|is_float_like
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
return|return
operator|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FLT
operator|||
name|is_float_singleton
argument_list|(
name|type
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_power_of_two
parameter_list|(
name|unsigned
name|int
name|n
parameter_list|)
block|{
return|return
operator|(
operator|(
name|n
operator|&
operator|(
name|n
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if TYPE should be passed as a pointer to a copy,    zero otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|s390_function_arg_pass_by_reference
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|unsigned
name|length
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|length
operator|>
literal|8
condition|)
return|return
literal|1
return|;
comment|/* FIXME: All complex and vector types are also returned by reference.  */
return|return
name|is_struct_like
argument_list|(
name|type
argument_list|)
operator|&&
operator|!
name|is_power_of_two
argument_list|(
name|length
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if TYPE should be passed in a float register    if possible.  */
end_comment

begin_function
specifier|static
name|int
name|s390_function_arg_float
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|unsigned
name|length
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|length
operator|>
literal|8
condition|)
return|return
literal|0
return|;
return|return
name|is_float_like
argument_list|(
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return non-zero if TYPE should be passed in an integer register    (or a pair of integer registers) if possible.  */
end_comment

begin_function
specifier|static
name|int
name|s390_function_arg_integer
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|unsigned
name|length
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|length
operator|>
literal|8
condition|)
return|return
literal|0
return|;
return|return
name|is_integer_like
argument_list|(
name|type
argument_list|)
operator|||
name|is_pointer_like
argument_list|(
name|type
argument_list|)
operator|||
operator|(
name|is_struct_like
argument_list|(
name|type
argument_list|)
operator|&&
name|is_power_of_two
argument_list|(
name|length
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return ARG, a `SIMPLE_ARG', sign-extended or zero-extended to a full    word as required for the ABI.  */
end_comment

begin_function
specifier|static
name|LONGEST
name|extend_simple_arg
parameter_list|(
name|struct
name|value
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
comment|/* Even structs get passed in the least significant bits of the      register / memory word.  It's not really right to extract them as      an integer, but it does take care of the extension.  */
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
return|return
name|extract_unsigned_integer
argument_list|(
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
else|else
return|return
name|extract_signed_integer
argument_list|(
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the alignment required by TYPE.  */
end_comment

begin_function
specifier|static
name|int
name|alignment_of
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|int
name|alignment
decl_stmt|;
if|if
condition|(
name|is_integer_like
argument_list|(
name|type
argument_list|)
operator|||
name|is_pointer_like
argument_list|(
name|type
argument_list|)
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FLT
condition|)
name|alignment
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
operator|||
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_UNION
condition|)
block|{
name|int
name|i
decl_stmt|;
name|alignment
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|field_alignment
init|=
name|alignment_of
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|field_alignment
operator|>
name|alignment
condition|)
name|alignment
operator|=
name|field_alignment
expr_stmt|;
block|}
block|}
else|else
name|alignment
operator|=
literal|1
expr_stmt|;
comment|/* Check that everything we ever return is a power of two.  Lots of      code doesn't want to deal with aligning things to arbitrary      boundaries.  */
name|gdb_assert
argument_list|(
operator|(
name|alignment
operator|&
operator|(
name|alignment
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
name|alignment
return|;
block|}
end_function

begin_comment
comment|/* Put the actual parameter values pointed to by ARGS[0..NARGS-1] in    place to be passed to a function, as specified by the "GNU/Linux    for S/390 ELF Application Binary Interface Supplement".     SP is the current stack pointer.  We must put arguments, links,    padding, etc. whereever they belong, and return the new stack    pointer value.        If STRUCT_RETURN is non-zero, then the function we're calling is    going to return a structure by value; STRUCT_ADDR is the address of    a block we've allocated for it on the stack.     Our caller has taken care of any type promotions needed to satisfy    prototypes or the old K&R argument-passing rules.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|s390_push_dummy_call
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|CORE_ADDR
name|func_addr
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|CORE_ADDR
name|bp_addr
parameter_list|,
name|int
name|nargs
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|args
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|,
name|int
name|struct_return
parameter_list|,
name|CORE_ADDR
name|struct_addr
parameter_list|)
block|{
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
init|=
name|gdbarch_tdep
argument_list|(
name|gdbarch
argument_list|)
decl_stmt|;
name|int
name|word_size
init|=
name|gdbarch_ptr_bit
argument_list|(
name|gdbarch
argument_list|)
operator|/
literal|8
decl_stmt|;
name|ULONGEST
name|orig_sp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* If the i'th argument is passed as a reference to a copy, then      copy_addr[i] is the address of the copy we made.  */
name|CORE_ADDR
modifier|*
name|copy_addr
init|=
name|alloca
argument_list|(
name|nargs
operator|*
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Build the reference-to-copy area.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|value
modifier|*
name|arg
init|=
name|args
index|[
name|i
index|]
decl_stmt|;
name|struct
name|type
modifier|*
name|type
init|=
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|unsigned
name|length
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|s390_function_arg_pass_by_reference
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|sp
operator|-=
name|length
expr_stmt|;
name|sp
operator|=
name|align_down
argument_list|(
name|sp
argument_list|,
name|alignment_of
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|sp
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|copy_addr
index|[
name|i
index|]
operator|=
name|sp
expr_stmt|;
block|}
block|}
comment|/* Reserve space for the parameter area.  As a conservative      simplification, we assume that everything will be passed on the      stack.  Since every argument larger than 8 bytes will be       passed by reference, we use this simple upper bound.  */
name|sp
operator|-=
name|nargs
operator|*
literal|8
expr_stmt|;
comment|/* After all that, make sure it's still aligned on an eight-byte      boundary.  */
name|sp
operator|=
name|align_down
argument_list|(
name|sp
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* Finally, place the actual parameters, working from SP towards      higher addresses.  The code above is supposed to reserve enough      space for this.  */
block|{
name|int
name|fr
init|=
literal|0
decl_stmt|;
name|int
name|gr
init|=
literal|2
decl_stmt|;
name|CORE_ADDR
name|starg
init|=
name|sp
decl_stmt|;
comment|/* A struct is returned using general register 2.  */
if|if
condition|(
name|struct_return
condition|)
block|{
name|regcache_cooked_write_unsigned
argument_list|(
name|regcache
argument_list|,
name|S390_R0_REGNUM
operator|+
name|gr
argument_list|,
name|struct_addr
argument_list|)
expr_stmt|;
name|gr
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|value
modifier|*
name|arg
init|=
name|args
index|[
name|i
index|]
decl_stmt|;
name|struct
name|type
modifier|*
name|type
init|=
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
decl_stmt|;
name|unsigned
name|length
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|s390_function_arg_pass_by_reference
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|gr
operator|<=
literal|6
condition|)
block|{
name|regcache_cooked_write_unsigned
argument_list|(
name|regcache
argument_list|,
name|S390_R0_REGNUM
operator|+
name|gr
argument_list|,
name|copy_addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|gr
operator|++
expr_stmt|;
block|}
else|else
block|{
name|write_memory_unsigned_integer
argument_list|(
name|starg
argument_list|,
name|word_size
argument_list|,
name|copy_addr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|starg
operator|+=
name|word_size
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|s390_function_arg_float
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* The GNU/Linux for S/390 ABI uses FPRs 0 and 2 to pass arguments, 	       the GNU/Linux for zSeries ABI uses 0, 2, 4, and 6.  */
if|if
condition|(
name|fr
operator|<=
operator|(
name|tdep
operator|->
name|abi
operator|==
name|ABI_LINUX_S390
condition|?
literal|2
else|:
literal|6
operator|)
condition|)
block|{
comment|/* When we store a single-precision value in an FP register, 		   it occupies the leftmost bits.  */
name|regcache_cooked_write_part
argument_list|(
name|regcache
argument_list|,
name|S390_F0_REGNUM
operator|+
name|fr
argument_list|,
literal|0
argument_list|,
name|length
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|fr
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* When we store a single-precision value in a stack slot, 		   it occupies the rightmost bits.  */
name|starg
operator|=
name|align_up
argument_list|(
name|starg
operator|+
name|length
argument_list|,
name|word_size
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|starg
operator|-
name|length
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|s390_function_arg_integer
argument_list|(
name|type
argument_list|)
operator|&&
name|length
operator|<=
name|word_size
condition|)
block|{
if|if
condition|(
name|gr
operator|<=
literal|6
condition|)
block|{
comment|/* Integer arguments are always extended to word size.  */
name|regcache_cooked_write_signed
argument_list|(
name|regcache
argument_list|,
name|S390_R0_REGNUM
operator|+
name|gr
argument_list|,
name|extend_simple_arg
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|gr
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* Integer arguments are always extended to word size.  */
name|write_memory_signed_integer
argument_list|(
name|starg
argument_list|,
name|word_size
argument_list|,
name|extend_simple_arg
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|starg
operator|+=
name|word_size
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|s390_function_arg_integer
argument_list|(
name|type
argument_list|)
operator|&&
name|length
operator|==
literal|2
operator|*
name|word_size
condition|)
block|{
if|if
condition|(
name|gr
operator|<=
literal|5
condition|)
block|{
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|S390_R0_REGNUM
operator|+
name|gr
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|S390_R0_REGNUM
operator|+
name|gr
operator|+
literal|1
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
operator|+
name|word_size
argument_list|)
expr_stmt|;
name|gr
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* If we skipped r6 because we couldn't fit a DOUBLE_ARG 		   in it, then don't go back and use it again later.  */
name|gr
operator|=
literal|7
expr_stmt|;
name|write_memory
argument_list|(
name|starg
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|starg
operator|+=
name|length
expr_stmt|;
block|}
block|}
else|else
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"unknown argument type"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Allocate the standard frame areas: the register save area, the      word reserved for the compiler (which seems kind of meaningless),      and the back chain pointer.  */
name|sp
operator|-=
literal|16
operator|*
name|word_size
operator|+
literal|32
expr_stmt|;
comment|/* Write the back chain pointer into the first word of the stack      frame.  This is needed to unwind across a dummy frame.  */
name|regcache_cooked_read_unsigned
argument_list|(
name|regcache
argument_list|,
name|S390_SP_REGNUM
argument_list|,
operator|&
name|orig_sp
argument_list|)
expr_stmt|;
name|write_memory_unsigned_integer
argument_list|(
name|sp
argument_list|,
name|word_size
argument_list|,
name|orig_sp
argument_list|)
expr_stmt|;
comment|/* Store return address.  */
name|regcache_cooked_write_unsigned
argument_list|(
name|regcache
argument_list|,
name|S390_RETADDR_REGNUM
argument_list|,
name|bp_addr
argument_list|)
expr_stmt|;
comment|/* Store updated stack pointer.  */
name|regcache_cooked_write_unsigned
argument_list|(
name|regcache
argument_list|,
name|S390_SP_REGNUM
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/* We need to return the 'stack part' of the frame ID,      which is actually the top of the register save area      allocated on the original stack.  */
return|return
name|orig_sp
operator|+
literal|16
operator|*
name|word_size
operator|+
literal|32
return|;
block|}
end_function

begin_comment
comment|/* Assuming NEXT_FRAME->prev is a dummy, return the frame ID of that    dummy frame.  The frame ID's base needs to match the TOS value    returned by push_dummy_call, and the PC match the dummy frame's    breakpoint.  */
end_comment

begin_function
specifier|static
name|struct
name|frame_id
name|s390_unwind_dummy_id
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|frame_info
modifier|*
name|next_frame
parameter_list|)
block|{
name|int
name|word_size
init|=
name|gdbarch_ptr_bit
argument_list|(
name|gdbarch
argument_list|)
operator|/
literal|8
decl_stmt|;
name|CORE_ADDR
name|this_sp
init|=
name|s390_unwind_sp
argument_list|(
name|gdbarch
argument_list|,
name|next_frame
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|prev_sp
init|=
name|read_memory_unsigned_integer
argument_list|(
name|this_sp
argument_list|,
name|word_size
argument_list|)
decl_stmt|;
return|return
name|frame_id_build
argument_list|(
name|prev_sp
operator|+
literal|16
operator|*
name|word_size
operator|+
literal|32
argument_list|,
name|frame_pc_unwind
argument_list|(
name|next_frame
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|s390_frame_align
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|)
block|{
comment|/* Both the 32- and 64-bit ABI's say that the stack pointer should      always be aligned on an eight-byte boundary.  */
return|return
operator|(
name|addr
operator|&
operator|-
literal|8
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Function return value access.  */
end_comment

begin_function
specifier|static
name|enum
name|return_value_convention
name|s390_return_value_convention
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|int
name|length
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|length
operator|>
literal|8
condition|)
return|return
name|RETURN_VALUE_STRUCT_CONVENTION
return|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_STRUCT
case|:
case|case
name|TYPE_CODE_UNION
case|:
case|case
name|TYPE_CODE_ARRAY
case|:
return|return
name|RETURN_VALUE_STRUCT_CONVENTION
return|;
default|default:
return|return
name|RETURN_VALUE_REGISTER_CONVENTION
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|enum
name|return_value_convention
name|s390_return_value
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|regcache
modifier|*
name|regcache
parameter_list|,
name|void
modifier|*
name|out
parameter_list|,
specifier|const
name|void
modifier|*
name|in
parameter_list|)
block|{
name|int
name|word_size
init|=
name|gdbarch_ptr_bit
argument_list|(
name|gdbarch
argument_list|)
operator|/
literal|8
decl_stmt|;
name|int
name|length
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|enum
name|return_value_convention
name|rvc
init|=
name|s390_return_value_convention
argument_list|(
name|gdbarch
argument_list|,
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|in
condition|)
block|{
switch|switch
condition|(
name|rvc
condition|)
block|{
case|case
name|RETURN_VALUE_REGISTER_CONVENTION
case|:
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FLT
condition|)
block|{
comment|/* When we store a single-precision value in an FP register, 		 it occupies the leftmost bits.  */
name|regcache_cooked_write_part
argument_list|(
name|regcache
argument_list|,
name|S390_F0_REGNUM
argument_list|,
literal|0
argument_list|,
name|length
argument_list|,
name|in
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|length
operator|<=
name|word_size
condition|)
block|{
comment|/* Integer arguments are always extended to word size.  */
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
name|regcache_cooked_write_unsigned
argument_list|(
name|regcache
argument_list|,
name|S390_R2_REGNUM
argument_list|,
name|extract_unsigned_integer
argument_list|(
name|in
argument_list|,
name|length
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|regcache_cooked_write_signed
argument_list|(
name|regcache
argument_list|,
name|S390_R2_REGNUM
argument_list|,
name|extract_signed_integer
argument_list|(
name|in
argument_list|,
name|length
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|length
operator|==
literal|2
operator|*
name|word_size
condition|)
block|{
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|S390_R2_REGNUM
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|regcache_cooked_write
argument_list|(
name|regcache
argument_list|,
name|S390_R3_REGNUM
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|in
operator|+
name|word_size
argument_list|)
expr_stmt|;
block|}
else|else
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"invalid return type"
argument_list|)
expr_stmt|;
break|break;
case|case
name|RETURN_VALUE_STRUCT_CONVENTION
case|:
name|error
argument_list|(
literal|"Cannot set function return value."
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|out
condition|)
block|{
switch|switch
condition|(
name|rvc
condition|)
block|{
case|case
name|RETURN_VALUE_REGISTER_CONVENTION
case|:
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FLT
condition|)
block|{
comment|/* When we store a single-precision value in an FP register, 		 it occupies the leftmost bits.  */
name|regcache_cooked_read_part
argument_list|(
name|regcache
argument_list|,
name|S390_F0_REGNUM
argument_list|,
literal|0
argument_list|,
name|length
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|length
operator|<=
name|word_size
condition|)
block|{
comment|/* Integer arguments occupy the rightmost bits.  */
name|regcache_cooked_read_part
argument_list|(
name|regcache
argument_list|,
name|S390_R2_REGNUM
argument_list|,
name|word_size
operator|-
name|length
argument_list|,
name|length
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|length
operator|==
literal|2
operator|*
name|word_size
condition|)
block|{
name|regcache_cooked_read
argument_list|(
name|regcache
argument_list|,
name|S390_R2_REGNUM
argument_list|,
name|out
argument_list|)
expr_stmt|;
name|regcache_cooked_read
argument_list|(
name|regcache
argument_list|,
name|S390_R3_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
name|out
operator|+
name|word_size
argument_list|)
expr_stmt|;
block|}
else|else
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"invalid return type"
argument_list|)
expr_stmt|;
break|break;
case|case
name|RETURN_VALUE_STRUCT_CONVENTION
case|:
name|error
argument_list|(
literal|"Function return value unknown."
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|rvc
return|;
block|}
end_function

begin_comment
comment|/* Breakpoints.  */
end_comment

begin_function
specifier|static
specifier|const
name|unsigned
name|char
modifier|*
name|s390_breakpoint_from_pc
parameter_list|(
name|CORE_ADDR
modifier|*
name|pcptr
parameter_list|,
name|int
modifier|*
name|lenptr
parameter_list|)
block|{
specifier|static
name|unsigned
name|char
name|breakpoint
index|[]
init|=
block|{
literal|0x0
block|,
literal|0x1
block|}
decl_stmt|;
operator|*
name|lenptr
operator|=
sizeof|sizeof
argument_list|(
name|breakpoint
argument_list|)
expr_stmt|;
return|return
name|breakpoint
return|;
block|}
end_function

begin_comment
comment|/* Address handling.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|s390_addr_bits_remove
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|)
block|{
return|return
name|addr
operator|&
literal|0x7fffffff
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|s390_address_class_type_flags
parameter_list|(
name|int
name|byte_size
parameter_list|,
name|int
name|dwarf2_addr_class
parameter_list|)
block|{
if|if
condition|(
name|byte_size
operator|==
literal|4
condition|)
return|return
name|TYPE_FLAG_ADDRESS_CLASS_1
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|s390_address_class_type_flags_to_name
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|int
name|type_flags
parameter_list|)
block|{
if|if
condition|(
name|type_flags
operator|&
name|TYPE_FLAG_ADDRESS_CLASS_1
condition|)
return|return
literal|"mode32"
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|s390_address_class_name_to_type_flags
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
modifier|*
name|type_flags_ptr
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"mode32"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|type_flags_ptr
operator|=
name|TYPE_FLAG_ADDRESS_CLASS_1
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Link map offsets.  */
end_comment

begin_function
specifier|static
name|struct
name|link_map_offsets
modifier|*
name|s390_svr4_fetch_link_map_offsets
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|struct
name|link_map_offsets
name|lmo
decl_stmt|;
specifier|static
name|struct
name|link_map_offsets
modifier|*
name|lmp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|lmp
operator|==
name|NULL
condition|)
block|{
name|lmp
operator|=
operator|&
name|lmo
expr_stmt|;
name|lmo
operator|.
name|r_debug_size
operator|=
literal|8
expr_stmt|;
name|lmo
operator|.
name|r_map_offset
operator|=
literal|4
expr_stmt|;
name|lmo
operator|.
name|r_map_size
operator|=
literal|4
expr_stmt|;
name|lmo
operator|.
name|link_map_size
operator|=
literal|20
expr_stmt|;
name|lmo
operator|.
name|l_addr_offset
operator|=
literal|0
expr_stmt|;
name|lmo
operator|.
name|l_addr_size
operator|=
literal|4
expr_stmt|;
name|lmo
operator|.
name|l_name_offset
operator|=
literal|4
expr_stmt|;
name|lmo
operator|.
name|l_name_size
operator|=
literal|4
expr_stmt|;
name|lmo
operator|.
name|l_next_offset
operator|=
literal|12
expr_stmt|;
name|lmo
operator|.
name|l_next_size
operator|=
literal|4
expr_stmt|;
name|lmo
operator|.
name|l_prev_offset
operator|=
literal|16
expr_stmt|;
name|lmo
operator|.
name|l_prev_size
operator|=
literal|4
expr_stmt|;
block|}
return|return
name|lmp
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|link_map_offsets
modifier|*
name|s390x_svr4_fetch_link_map_offsets
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|struct
name|link_map_offsets
name|lmo
decl_stmt|;
specifier|static
name|struct
name|link_map_offsets
modifier|*
name|lmp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|lmp
operator|==
name|NULL
condition|)
block|{
name|lmp
operator|=
operator|&
name|lmo
expr_stmt|;
name|lmo
operator|.
name|r_debug_size
operator|=
literal|16
expr_stmt|;
comment|/* All we need.  */
name|lmo
operator|.
name|r_map_offset
operator|=
literal|8
expr_stmt|;
name|lmo
operator|.
name|r_map_size
operator|=
literal|8
expr_stmt|;
name|lmo
operator|.
name|link_map_size
operator|=
literal|40
expr_stmt|;
comment|/* All we need.  */
name|lmo
operator|.
name|l_addr_offset
operator|=
literal|0
expr_stmt|;
name|lmo
operator|.
name|l_addr_size
operator|=
literal|8
expr_stmt|;
name|lmo
operator|.
name|l_name_offset
operator|=
literal|8
expr_stmt|;
name|lmo
operator|.
name|l_name_size
operator|=
literal|8
expr_stmt|;
name|lmo
operator|.
name|l_next_offset
operator|=
literal|24
expr_stmt|;
name|lmo
operator|.
name|l_next_size
operator|=
literal|8
expr_stmt|;
name|lmo
operator|.
name|l_prev_offset
operator|=
literal|32
expr_stmt|;
name|lmo
operator|.
name|l_prev_size
operator|=
literal|8
expr_stmt|;
block|}
return|return
name|lmp
return|;
block|}
end_function

begin_comment
comment|/* Set up gdbarch struct.  */
end_comment

begin_function
specifier|static
name|struct
name|gdbarch
modifier|*
name|s390_gdbarch_init
parameter_list|(
name|struct
name|gdbarch_info
name|info
parameter_list|,
name|struct
name|gdbarch_list
modifier|*
name|arches
parameter_list|)
block|{
name|struct
name|gdbarch
modifier|*
name|gdbarch
decl_stmt|;
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
decl_stmt|;
comment|/* First see if there is already a gdbarch that can satisfy the request.  */
name|arches
operator|=
name|gdbarch_list_lookup_by_info
argument_list|(
name|arches
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|arches
operator|!=
name|NULL
condition|)
return|return
name|arches
operator|->
name|gdbarch
return|;
comment|/* None found: is the request for a s390 architecture? */
if|if
condition|(
name|info
operator|.
name|bfd_arch_info
operator|->
name|arch
operator|!=
name|bfd_arch_s390
condition|)
return|return
name|NULL
return|;
comment|/* No; then it's not for us.  */
comment|/* Yes: create a new gdbarch for the specified machine type.  */
name|tdep
operator|=
name|XCALLOC
argument_list|(
literal|1
argument_list|,
expr|struct
name|gdbarch_tdep
argument_list|)
expr_stmt|;
name|gdbarch
operator|=
name|gdbarch_alloc
argument_list|(
operator|&
name|info
argument_list|,
name|tdep
argument_list|)
expr_stmt|;
name|set_gdbarch_believe_pcc_promotion
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_gdbarch_char_signed
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Amount PC must be decremented by after a breakpoint.  This is      often the number of bytes returned by BREAKPOINT_FROM_PC but not      always.  */
name|set_gdbarch_decr_pc_after_break
argument_list|(
name|gdbarch
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Stack grows downward.  */
name|set_gdbarch_inner_than
argument_list|(
name|gdbarch
argument_list|,
name|core_addr_lessthan
argument_list|)
expr_stmt|;
name|set_gdbarch_breakpoint_from_pc
argument_list|(
name|gdbarch
argument_list|,
name|s390_breakpoint_from_pc
argument_list|)
expr_stmt|;
name|set_gdbarch_skip_prologue
argument_list|(
name|gdbarch
argument_list|,
name|s390_skip_prologue
argument_list|)
expr_stmt|;
name|set_gdbarch_in_function_epilogue_p
argument_list|(
name|gdbarch
argument_list|,
name|s390_in_function_epilogue_p
argument_list|)
expr_stmt|;
name|set_gdbarch_pc_regnum
argument_list|(
name|gdbarch
argument_list|,
name|S390_PC_REGNUM
argument_list|)
expr_stmt|;
name|set_gdbarch_sp_regnum
argument_list|(
name|gdbarch
argument_list|,
name|S390_SP_REGNUM
argument_list|)
expr_stmt|;
name|set_gdbarch_fp0_regnum
argument_list|(
name|gdbarch
argument_list|,
name|S390_F0_REGNUM
argument_list|)
expr_stmt|;
name|set_gdbarch_num_regs
argument_list|(
name|gdbarch
argument_list|,
name|S390_NUM_REGS
argument_list|)
expr_stmt|;
name|set_gdbarch_num_pseudo_regs
argument_list|(
name|gdbarch
argument_list|,
name|S390_NUM_PSEUDO_REGS
argument_list|)
expr_stmt|;
name|set_gdbarch_register_name
argument_list|(
name|gdbarch
argument_list|,
name|s390_register_name
argument_list|)
expr_stmt|;
name|set_gdbarch_register_type
argument_list|(
name|gdbarch
argument_list|,
name|s390_register_type
argument_list|)
expr_stmt|;
name|set_gdbarch_stab_reg_to_regnum
argument_list|(
name|gdbarch
argument_list|,
name|s390_dwarf_reg_to_regnum
argument_list|)
expr_stmt|;
name|set_gdbarch_dwarf_reg_to_regnum
argument_list|(
name|gdbarch
argument_list|,
name|s390_dwarf_reg_to_regnum
argument_list|)
expr_stmt|;
name|set_gdbarch_dwarf2_reg_to_regnum
argument_list|(
name|gdbarch
argument_list|,
name|s390_dwarf_reg_to_regnum
argument_list|)
expr_stmt|;
name|set_gdbarch_convert_register_p
argument_list|(
name|gdbarch
argument_list|,
name|s390_convert_register_p
argument_list|)
expr_stmt|;
name|set_gdbarch_register_to_value
argument_list|(
name|gdbarch
argument_list|,
name|s390_register_to_value
argument_list|)
expr_stmt|;
name|set_gdbarch_value_to_register
argument_list|(
name|gdbarch
argument_list|,
name|s390_value_to_register
argument_list|)
expr_stmt|;
name|set_gdbarch_register_reggroup_p
argument_list|(
name|gdbarch
argument_list|,
name|s390_register_reggroup_p
argument_list|)
expr_stmt|;
name|set_gdbarch_regset_from_core_section
argument_list|(
name|gdbarch
argument_list|,
name|s390_regset_from_core_section
argument_list|)
expr_stmt|;
comment|/* Inferior function calls.  */
name|set_gdbarch_push_dummy_call
argument_list|(
name|gdbarch
argument_list|,
name|s390_push_dummy_call
argument_list|)
expr_stmt|;
name|set_gdbarch_unwind_dummy_id
argument_list|(
name|gdbarch
argument_list|,
name|s390_unwind_dummy_id
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_align
argument_list|(
name|gdbarch
argument_list|,
name|s390_frame_align
argument_list|)
expr_stmt|;
name|set_gdbarch_return_value
argument_list|(
name|gdbarch
argument_list|,
name|s390_return_value
argument_list|)
expr_stmt|;
comment|/* Frame handling.  */
name|set_gdbarch_in_solib_call_trampoline
argument_list|(
name|gdbarch
argument_list|,
name|in_plt_section
argument_list|)
expr_stmt|;
name|dwarf2_frame_set_init_reg
argument_list|(
name|gdbarch
argument_list|,
name|s390_dwarf2_frame_init_reg
argument_list|)
expr_stmt|;
name|frame_unwind_append_sniffer
argument_list|(
name|gdbarch
argument_list|,
name|dwarf2_frame_sniffer
argument_list|)
expr_stmt|;
name|frame_base_append_sniffer
argument_list|(
name|gdbarch
argument_list|,
name|dwarf2_frame_base_sniffer
argument_list|)
expr_stmt|;
name|frame_unwind_append_sniffer
argument_list|(
name|gdbarch
argument_list|,
name|s390_stub_frame_sniffer
argument_list|)
expr_stmt|;
name|frame_unwind_append_sniffer
argument_list|(
name|gdbarch
argument_list|,
name|s390_sigtramp_frame_sniffer
argument_list|)
expr_stmt|;
name|frame_unwind_append_sniffer
argument_list|(
name|gdbarch
argument_list|,
name|s390_frame_sniffer
argument_list|)
expr_stmt|;
name|frame_base_set_default
argument_list|(
name|gdbarch
argument_list|,
operator|&
name|s390_frame_base
argument_list|)
expr_stmt|;
name|set_gdbarch_unwind_pc
argument_list|(
name|gdbarch
argument_list|,
name|s390_unwind_pc
argument_list|)
expr_stmt|;
name|set_gdbarch_unwind_sp
argument_list|(
name|gdbarch
argument_list|,
name|s390_unwind_sp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|info
operator|.
name|bfd_arch_info
operator|->
name|mach
condition|)
block|{
case|case
name|bfd_mach_s390_31
case|:
name|tdep
operator|->
name|abi
operator|=
name|ABI_LINUX_S390
expr_stmt|;
name|tdep
operator|->
name|gregset
operator|=
operator|&
name|s390_gregset
expr_stmt|;
name|tdep
operator|->
name|sizeof_gregset
operator|=
name|s390_sizeof_gregset
expr_stmt|;
name|tdep
operator|->
name|fpregset
operator|=
operator|&
name|s390_fpregset
expr_stmt|;
name|tdep
operator|->
name|sizeof_fpregset
operator|=
name|s390_sizeof_fpregset
expr_stmt|;
name|set_gdbarch_addr_bits_remove
argument_list|(
name|gdbarch
argument_list|,
name|s390_addr_bits_remove
argument_list|)
expr_stmt|;
name|set_gdbarch_pseudo_register_read
argument_list|(
name|gdbarch
argument_list|,
name|s390_pseudo_register_read
argument_list|)
expr_stmt|;
name|set_gdbarch_pseudo_register_write
argument_list|(
name|gdbarch
argument_list|,
name|s390_pseudo_register_write
argument_list|)
expr_stmt|;
name|set_solib_svr4_fetch_link_map_offsets
argument_list|(
name|gdbarch
argument_list|,
name|s390_svr4_fetch_link_map_offsets
argument_list|)
expr_stmt|;
break|break;
case|case
name|bfd_mach_s390_64
case|:
name|tdep
operator|->
name|abi
operator|=
name|ABI_LINUX_ZSERIES
expr_stmt|;
name|tdep
operator|->
name|gregset
operator|=
operator|&
name|s390x_gregset
expr_stmt|;
name|tdep
operator|->
name|sizeof_gregset
operator|=
name|s390x_sizeof_gregset
expr_stmt|;
name|tdep
operator|->
name|fpregset
operator|=
operator|&
name|s390_fpregset
expr_stmt|;
name|tdep
operator|->
name|sizeof_fpregset
operator|=
name|s390_sizeof_fpregset
expr_stmt|;
name|set_gdbarch_long_bit
argument_list|(
name|gdbarch
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|set_gdbarch_long_long_bit
argument_list|(
name|gdbarch
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|set_gdbarch_ptr_bit
argument_list|(
name|gdbarch
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|set_gdbarch_pseudo_register_read
argument_list|(
name|gdbarch
argument_list|,
name|s390x_pseudo_register_read
argument_list|)
expr_stmt|;
name|set_gdbarch_pseudo_register_write
argument_list|(
name|gdbarch
argument_list|,
name|s390x_pseudo_register_write
argument_list|)
expr_stmt|;
name|set_solib_svr4_fetch_link_map_offsets
argument_list|(
name|gdbarch
argument_list|,
name|s390x_svr4_fetch_link_map_offsets
argument_list|)
expr_stmt|;
name|set_gdbarch_address_class_type_flags
argument_list|(
name|gdbarch
argument_list|,
name|s390_address_class_type_flags
argument_list|)
expr_stmt|;
name|set_gdbarch_address_class_type_flags_to_name
argument_list|(
name|gdbarch
argument_list|,
name|s390_address_class_type_flags_to_name
argument_list|)
expr_stmt|;
name|set_gdbarch_address_class_name_to_type_flags
argument_list|(
name|gdbarch
argument_list|,
name|s390_address_class_name_to_type_flags
argument_list|)
expr_stmt|;
break|break;
block|}
name|set_gdbarch_print_insn
argument_list|(
name|gdbarch
argument_list|,
name|print_insn_s390
argument_list|)
expr_stmt|;
return|return
name|gdbarch
return|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|initialize_file_ftype
name|_initialize_s390_tdep
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -Wmissing-prototypes */
end_comment

begin_function
name|void
name|_initialize_s390_tdep
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Hook us into the gdbarch mechanism.  */
name|register_gdbarch_init
argument_list|(
name|bfd_arch_s390
argument_list|,
name|s390_gdbarch_init
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

