begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target-dependent code for the GNU C Library (glibc).     Copyright 2002, 2003 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"glibc-tdep.h"
end_include

begin_comment
comment|/* Calling functions in shared libraries.  */
end_comment

begin_comment
comment|/* Find the minimal symbol named NAME, and return both the minsym    struct and its objfile.  This probably ought to be in minsym.c, but    everything there is trying to deal with things like C++ and    SOFUN_ADDRESS_MAYBE_TURQUOISE, ...  Since this is so simple, it may    be considered too special-purpose for general consumption.  */
end_comment

begin_function
specifier|static
name|struct
name|minimal_symbol
modifier|*
name|find_minsym_and_objfile
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|objfile
modifier|*
modifier|*
name|objfile_p
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|ALL_OBJFILES
argument_list|(
argument|objfile
argument_list|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|msym
decl_stmt|;
name|ALL_OBJFILE_MSYMBOLS
argument_list|(
argument|objfile
argument_list|,
argument|msym
argument_list|)
block|{
if|if
condition|(
name|SYMBOL_LINKAGE_NAME
argument_list|(
name|msym
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|SYMBOL_LINKAGE_NAME
argument_list|(
name|msym
argument_list|)
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|objfile_p
operator|=
name|objfile
expr_stmt|;
return|return
name|msym
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* See the comments for SKIP_SOLIB_RESOLVER at the top of infrun.c.    This function:    1) decides whether a PLT has sent us into the linker to resolve       a function reference, and     2) if so, tells us where to set a temporary breakpoint that will       trigger when the dynamic linker is done.  */
end_comment

begin_function
name|CORE_ADDR
name|glibc_skip_solib_resolver
parameter_list|(
name|struct
name|gdbarch
modifier|*
name|gdbarch
parameter_list|,
name|CORE_ADDR
name|pc
parameter_list|)
block|{
comment|/* The GNU dynamic linker is part of the GNU C library, and is used      by all GNU systems (GNU/Hurd, GNU/Linux).  An unresolved PLT      entry points to "_dl_runtime_resolve", which calls "fixup" to      patch the PLT, and then passes control to the function.       We look for the symbol `_dl_runtime_resolve', and find `fixup' in      the same objfile.  If we are at the entry point of `fixup', then      we set a breakpoint at the return address (at the top of the      stack), and continue.         It's kind of gross to do all these checks every time we're      called, since they don't change once the executable has gotten      started.  But this is only a temporary hack --- upcoming versions      of GNU/Linux will provide a portable, efficient interface for      debugging programs that use shared libraries.  */
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|resolver
init|=
name|find_minsym_and_objfile
argument_list|(
literal|"_dl_runtime_resolve"
argument_list|,
operator|&
name|objfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|resolver
condition|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|fixup
init|=
name|lookup_minimal_symbol
argument_list|(
literal|"fixup"
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|fixup
operator|&&
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|fixup
argument_list|)
operator|==
name|pc
condition|)
return|return
name|frame_pc_unwind
argument_list|(
name|get_current_frame
argument_list|()
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

