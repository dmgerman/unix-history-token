begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* DWARF 2 debugging format support for GDB.    Copyright 1994, 1995, 1996, 1997, 1998 Free Software Foundation, Inc.     Adapted by Gary Funck (gary@intrepid.com), Intrepid Technology,    Inc.  with support from Florida State University (under contract    with the Ada Joint Program Office), and Silicon Graphics, Inc.    Initial contribution by Brent Benson, Harris Computer Systems, Inc.,    based on Fred Fish's (Cygnus Support) implementation of DWARF 1    support in dwarfread.c  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"elf/dwarf2.h"
end_include

begin_include
include|#
directive|include
file|"buildsym.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"complaints.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_comment
comment|/* .debug_info header for a compilation unit     Because of alignment constraints, this structure has padding and cannot    be mapped directly onto the beginning of the .debug_info section.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|comp_unit_header
block|{
name|unsigned
name|int
name|length
decl_stmt|;
comment|/* length of the .debug_info 				   contribution */
name|unsigned
name|short
name|version
decl_stmt|;
comment|/* version number -- 2 for DWARF 				   version 2 */
name|unsigned
name|int
name|abbrev_offset
decl_stmt|;
comment|/* offset into .debug_abbrev section */
name|unsigned
name|char
name|addr_size
decl_stmt|;
comment|/* byte size of an address -- 4 */
block|}
name|_COMP_UNIT_HEADER
typedef|;
end_typedef

begin_define
define|#
directive|define
name|_ACTUAL_COMP_UNIT_HEADER_SIZE
value|11
end_define

begin_comment
comment|/* .debug_pubnames header    Because of alignment constraints, this structure has padding and cannot    be mapped directly onto the beginning of the .debug_info section.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|pubnames_header
block|{
name|unsigned
name|int
name|length
decl_stmt|;
comment|/* length of the .debug_pubnames 				   contribution  */
name|unsigned
name|char
name|version
decl_stmt|;
comment|/* version number -- 2 for DWARF 				   version 2 */
name|unsigned
name|int
name|info_offset
decl_stmt|;
comment|/* offset into .debug_info section */
name|unsigned
name|int
name|info_size
decl_stmt|;
comment|/* byte size of .debug_info section 				   portion */
block|}
name|_PUBNAMES_HEADER
typedef|;
end_typedef

begin_define
define|#
directive|define
name|_ACTUAL_PUBNAMES_HEADER_SIZE
value|13
end_define

begin_comment
comment|/* .debug_pubnames header    Because of alignment constraints, this structure has padding and cannot    be mapped directly onto the beginning of the .debug_info section.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|aranges_header
block|{
name|unsigned
name|int
name|length
decl_stmt|;
comment|/* byte len of the .debug_aranges 				   contribution */
name|unsigned
name|short
name|version
decl_stmt|;
comment|/* version number -- 2 for DWARF 				   version 2 */
name|unsigned
name|int
name|info_offset
decl_stmt|;
comment|/* offset into .debug_info section */
name|unsigned
name|char
name|addr_size
decl_stmt|;
comment|/* byte size of an address */
name|unsigned
name|char
name|seg_size
decl_stmt|;
comment|/* byte size of segment descriptor */
block|}
name|_ARANGES_HEADER
typedef|;
end_typedef

begin_define
define|#
directive|define
name|_ACTUAL_ARANGES_HEADER_SIZE
value|12
end_define

begin_comment
comment|/* .debug_line statement program prologue    Because of alignment constraints, this structure has padding and cannot    be mapped directly onto the beginning of the .debug_info section.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|statement_prologue
block|{
name|unsigned
name|int
name|total_length
decl_stmt|;
comment|/* byte length of the statement 				   information */
name|unsigned
name|short
name|version
decl_stmt|;
comment|/* version number -- 2 for DWARF 				   version 2 */
name|unsigned
name|int
name|prologue_length
decl_stmt|;
comment|/* # bytes between prologue& 					   stmt program */
name|unsigned
name|char
name|minimum_instruction_length
decl_stmt|;
comment|/* byte size of 						   smallest instr */
name|unsigned
name|char
name|default_is_stmt
decl_stmt|;
comment|/* initial value of is_stmt 					   register */
name|char
name|line_base
decl_stmt|;
name|unsigned
name|char
name|line_range
decl_stmt|;
name|unsigned
name|char
name|opcode_base
decl_stmt|;
comment|/* number assigned to first special 				   opcode */
name|unsigned
name|char
modifier|*
name|standard_opcode_lengths
decl_stmt|;
block|}
name|_STATEMENT_PROLOGUE
typedef|;
end_typedef

begin_comment
comment|/* offsets and sizes of debugging sections */
end_comment

begin_decl_stmt
specifier|static
name|file_ptr
name|dwarf_info_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|file_ptr
name|dwarf_abbrev_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|file_ptr
name|dwarf_line_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|file_ptr
name|dwarf_pubnames_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|file_ptr
name|dwarf_aranges_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|file_ptr
name|dwarf_loc_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|file_ptr
name|dwarf_macinfo_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|file_ptr
name|dwarf_str_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|dwarf_info_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|dwarf_abbrev_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|dwarf_line_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|dwarf_pubnames_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|dwarf_aranges_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|dwarf_loc_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|dwarf_macinfo_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|dwarf_str_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* names of the debugging sections */
end_comment

begin_define
define|#
directive|define
name|INFO_SECTION
value|".debug_info"
end_define

begin_define
define|#
directive|define
name|ABBREV_SECTION
value|".debug_abbrev"
end_define

begin_define
define|#
directive|define
name|LINE_SECTION
value|".debug_line"
end_define

begin_define
define|#
directive|define
name|PUBNAMES_SECTION
value|".debug_pubnames"
end_define

begin_define
define|#
directive|define
name|ARANGES_SECTION
value|".debug_aranges"
end_define

begin_define
define|#
directive|define
name|LOC_SECTION
value|".debug_loc"
end_define

begin_define
define|#
directive|define
name|MACINFO_SECTION
value|".debug_macinfo"
end_define

begin_define
define|#
directive|define
name|STR_SECTION
value|".debug_str"
end_define

begin_comment
comment|/* local data types */
end_comment

begin_comment
comment|/* The data in a compilation unit header looks like this.  */
end_comment

begin_struct
struct|struct
name|comp_unit_head
block|{
name|unsigned
name|int
name|length
decl_stmt|;
name|short
name|version
decl_stmt|;
name|unsigned
name|int
name|abbrev_offset
decl_stmt|;
name|unsigned
name|char
name|addr_size
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The data in the .debug_line statement prologue looks like this.  */
end_comment

begin_struct
struct|struct
name|line_head
block|{
name|unsigned
name|int
name|total_length
decl_stmt|;
name|unsigned
name|short
name|version
decl_stmt|;
name|unsigned
name|int
name|prologue_length
decl_stmt|;
name|unsigned
name|char
name|minimum_instruction_length
decl_stmt|;
name|unsigned
name|char
name|default_is_stmt
decl_stmt|;
name|int
name|line_base
decl_stmt|;
name|unsigned
name|char
name|line_range
decl_stmt|;
name|unsigned
name|char
name|opcode_base
decl_stmt|;
name|unsigned
name|char
modifier|*
name|standard_opcode_lengths
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* When we construct a partial symbol table entry we only    need this much information. */
end_comment

begin_struct
struct|struct
name|partial_die_info
block|{
name|enum
name|dwarf_tag
name|tag
decl_stmt|;
name|unsigned
name|char
name|has_children
decl_stmt|;
name|unsigned
name|char
name|is_external
decl_stmt|;
name|unsigned
name|char
name|is_declaration
decl_stmt|;
name|unsigned
name|char
name|has_type
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
name|unsigned
name|int
name|abbrev
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|CORE_ADDR
name|lowpc
decl_stmt|;
name|CORE_ADDR
name|highpc
decl_stmt|;
name|struct
name|dwarf_block
modifier|*
name|locdesc
decl_stmt|;
name|unsigned
name|int
name|language
decl_stmt|;
name|char
modifier|*
name|sibling
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This data structure holds the information of an abbrev. */
end_comment

begin_struct
struct|struct
name|abbrev_info
block|{
name|unsigned
name|int
name|number
decl_stmt|;
comment|/* number identifying abbrev */
name|enum
name|dwarf_tag
name|tag
decl_stmt|;
comment|/* dwarf tag */
name|int
name|has_children
decl_stmt|;
comment|/* boolean */
name|unsigned
name|int
name|num_attrs
decl_stmt|;
comment|/* number of attributes */
name|struct
name|attr_abbrev
modifier|*
name|attrs
decl_stmt|;
comment|/* an array of attribute descriptions */
name|struct
name|abbrev_info
modifier|*
name|next
decl_stmt|;
comment|/* next in chain */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|attr_abbrev
block|{
name|enum
name|dwarf_attribute
name|name
decl_stmt|;
name|enum
name|dwarf_form
name|form
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This data structure holds a complete die structure. */
end_comment

begin_struct
struct|struct
name|die_info
block|{
name|enum
name|dwarf_tag
name|tag
decl_stmt|;
comment|/* Tag indicating type of die */
name|unsigned
name|short
name|has_children
decl_stmt|;
comment|/* Does the die have children */
name|unsigned
name|int
name|abbrev
decl_stmt|;
comment|/* Abbrev number */
name|unsigned
name|int
name|offset
decl_stmt|;
comment|/* Offset in .debug_info section */
name|unsigned
name|int
name|num_attrs
decl_stmt|;
comment|/* Number of attributes */
name|struct
name|attribute
modifier|*
name|attrs
decl_stmt|;
comment|/* An array of attributes */
name|struct
name|die_info
modifier|*
name|next_ref
decl_stmt|;
comment|/* Next die in ref hash table */
name|struct
name|die_info
modifier|*
name|next
decl_stmt|;
comment|/* Next die in linked list */
name|struct
name|type
modifier|*
name|type
decl_stmt|;
comment|/* Cached type information */
block|}
struct|;
end_struct

begin_comment
comment|/* Attributes have a name and a value */
end_comment

begin_struct
struct|struct
name|attribute
block|{
name|enum
name|dwarf_attribute
name|name
decl_stmt|;
name|enum
name|dwarf_form
name|form
decl_stmt|;
union|union
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|struct
name|dwarf_block
modifier|*
name|blk
decl_stmt|;
name|unsigned
name|int
name|unsnd
decl_stmt|;
name|int
name|snd
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* Get at parts of an attribute structure */
end_comment

begin_define
define|#
directive|define
name|DW_STRING
parameter_list|(
name|attr
parameter_list|)
value|((attr)->u.str)
end_define

begin_define
define|#
directive|define
name|DW_UNSND
parameter_list|(
name|attr
parameter_list|)
value|((attr)->u.unsnd)
end_define

begin_define
define|#
directive|define
name|DW_BLOCK
parameter_list|(
name|attr
parameter_list|)
value|((attr)->u.blk)
end_define

begin_define
define|#
directive|define
name|DW_SND
parameter_list|(
name|attr
parameter_list|)
value|((attr)->u.snd)
end_define

begin_define
define|#
directive|define
name|DW_ADDR
parameter_list|(
name|attr
parameter_list|)
value|((attr)->u.addr)
end_define

begin_comment
comment|/* Blocks are a bunch of untyped bytes. */
end_comment

begin_struct
struct|struct
name|dwarf_block
block|{
name|unsigned
name|int
name|size
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* We only hold one compilation unit's abbrevs in    memory at any one time.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ABBREV_HASH_SIZE
end_ifndef

begin_define
define|#
directive|define
name|ABBREV_HASH_SIZE
value|121
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ATTR_ALLOC_CHUNK
end_ifndef

begin_define
define|#
directive|define
name|ATTR_ALLOC_CHUNK
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|abbrev_info
modifier|*
name|dwarf2_abbrevs
index|[
name|ABBREV_HASH_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A hash table of die offsets for following references.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|REF_HASH_SIZE
end_ifndef

begin_define
define|#
directive|define
name|REF_HASH_SIZE
value|1021
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|die_info
modifier|*
name|die_ref_table
index|[
name|REF_HASH_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Obstack for allocating temporary storage used during symbol reading.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|obstack
name|dwarf2_tmp_obstack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Offset to the first byte of the current compilation unit header,    for resolving relative reference dies. */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|cu_header_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate fields for structs, unions and enums in this size.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DW_FIELD_ALLOC_CHUNK
end_ifndef

begin_define
define|#
directive|define
name|DW_FIELD_ALLOC_CHUNK
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The language we are debugging.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|language
name|cu_language
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|language_defn
modifier|*
name|cu_language_defn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Actually data from the sections.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dwarf_info_buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dwarf_abbrev_buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dwarf_line_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A zeroed version of a partial die for initialization purposes.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|partial_die_info
name|zeroed_partial_die
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The generic symbol table building routines have separate lists for    file scope symbols and all all other scopes (local scopes).  So    we need to select the right one to pass to add_symbol_to_list().    We do it by keeping a pointer to the correct list in list_in_scope.     FIXME:  The original dwarf code just treated the file scope as the first    local scope, and all other local scopes as nested local scopes, and worked    fine.  Check to see if we really need to distinguish these    in buildsym.c.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pending
modifier|*
modifier|*
name|list_in_scope
init|=
operator|&
name|file_symbols
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FIXME: The following variables pass additional information from    decode_locdesc to the caller.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|optimized_out
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Kludge to identify optimized out variables */
end_comment

begin_decl_stmt
specifier|static
name|int
name|isreg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Kludge to identify register variables */
end_comment

begin_decl_stmt
specifier|static
name|int
name|offreg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Kludge to identify basereg references */
end_comment

begin_decl_stmt
specifier|static
name|int
name|basereg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Which base register is it relative to?  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|islocal
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Kludge to identify local variables */
end_comment

begin_comment
comment|/* DW_AT_frame_base values for the current function.    frame_base_reg is -1 if DW_AT_frame_base is missing, otherwise it    contains the register number for the frame register.    frame_base_offset is the offset from the frame register to the    virtual stack frame. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|frame_base_reg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|frame_base_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This value is added to each symbol value.  FIXME:  Generalize to     the section_offsets structure used by dbxread (once this is done,    pass the appropriate section number to end_symtab).  */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|baseaddr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add to each symbol value */
end_comment

begin_comment
comment|/* We put a pointer to this structure in the read_symtab_private field    of the psymtab.    The complete dwarf information for an objfile is kept in the    psymbol_obstack, so that absolute die references can be handled.    Most of the information in this structure is related to an entire    object file and could be passed via the sym_private field of the objfile.    It is however conceivable that dwarf2 might not be the only type    of symbols read from an object file.  */
end_comment

begin_struct
struct|struct
name|dwarf2_pinfo
block|{
comment|/* Pointer to start of dwarf info buffer for the objfile.  */
name|char
modifier|*
name|dwarf_info_buffer
decl_stmt|;
comment|/* Offset in dwarf_info_buffer for this compilation unit. */
name|unsigned
name|long
name|dwarf_info_offset
decl_stmt|;
comment|/* Pointer to start of dwarf abbreviation buffer for the objfile.  */
name|char
modifier|*
name|dwarf_abbrev_buffer
decl_stmt|;
comment|/* Size of dwarf abbreviation section for the objfile.  */
name|unsigned
name|int
name|dwarf_abbrev_size
decl_stmt|;
comment|/* Pointer to start of dwarf line buffer for the objfile.  */
name|char
modifier|*
name|dwarf_line_buffer
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|PST_PRIVATE
parameter_list|(
name|p
parameter_list|)
value|((struct dwarf2_pinfo *)(p)->read_symtab_private)
end_define

begin_define
define|#
directive|define
name|DWARF_INFO_BUFFER
parameter_list|(
name|p
parameter_list|)
value|(PST_PRIVATE(p)->dwarf_info_buffer)
end_define

begin_define
define|#
directive|define
name|DWARF_INFO_OFFSET
parameter_list|(
name|p
parameter_list|)
value|(PST_PRIVATE(p)->dwarf_info_offset)
end_define

begin_define
define|#
directive|define
name|DWARF_ABBREV_BUFFER
parameter_list|(
name|p
parameter_list|)
value|(PST_PRIVATE(p)->dwarf_abbrev_buffer)
end_define

begin_define
define|#
directive|define
name|DWARF_ABBREV_SIZE
parameter_list|(
name|p
parameter_list|)
value|(PST_PRIVATE(p)->dwarf_abbrev_size)
end_define

begin_define
define|#
directive|define
name|DWARF_LINE_BUFFER
parameter_list|(
name|p
parameter_list|)
value|(PST_PRIVATE(p)->dwarf_line_buffer)
end_define

begin_comment
comment|/* Maintain an array of referenced fundamental types for the current    compilation unit being read.  For DWARF version 1, we have to construct    the fundamental types on the fly, since no information about the    fundamental types is supplied.  Each such fundamental type is created by    calling a language dependent routine to create the type, and then a    pointer to that type is then placed in the array at the index specified    by it's FT_<TYPENAME> value.  The array has a fixed size set by the    FT_NUM_MEMBERS compile time constant, which is the number of predefined    fundamental types gdb knows how to construct.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|ftypes
index|[
name|FT_NUM_MEMBERS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Fundamental types */
end_comment

begin_comment
comment|/* FIXME: We might want to set this from BFD via bfd_arch_bits_per_byte,    but this would require a corresponding change in unpack_field_as_long    and friends.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bits_per_byte
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The routines that read and process dies for a C struct or C++ class    pass lists of data member fields and lists of member function fields    in an instance of a field_info structure, as defined below.  */
end_comment

begin_struct
struct|struct
name|field_info
block|{
comment|/* List of data member and baseclasses fields. */
struct|struct
name|nextfield
block|{
name|struct
name|nextfield
modifier|*
name|next
decl_stmt|;
name|int
name|accessibility
decl_stmt|;
name|int
name|virtuality
decl_stmt|;
name|struct
name|field
name|field
decl_stmt|;
block|}
modifier|*
name|fields
struct|;
comment|/* Number of fields.  */
name|int
name|nfields
decl_stmt|;
comment|/* Number of baseclasses.  */
name|int
name|nbaseclasses
decl_stmt|;
comment|/* Set if the accesibility of one of the fields is not public.  */
name|int
name|non_public_fields
decl_stmt|;
comment|/* Member function fields array, entries are allocated in the order they      are encountered in the object file.  */
struct|struct
name|nextfnfield
block|{
name|struct
name|nextfnfield
modifier|*
name|next
decl_stmt|;
name|struct
name|fn_field
name|fnfield
decl_stmt|;
block|}
modifier|*
name|fnfields
struct|;
comment|/* Member function fieldlist array, contains name of possibly overloaded      member function, number of overloaded member functions and a pointer      to the head of the member function field chain.  */
struct|struct
name|fnfieldlist
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|length
decl_stmt|;
name|struct
name|nextfnfield
modifier|*
name|head
decl_stmt|;
block|}
modifier|*
name|fnfieldlists
struct|;
comment|/* Number of entries in the fnfieldlists array.  */
name|int
name|nfnfields
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* FIXME: Kludge to mark a varargs function type for C++ member function    argument processing.  */
end_comment

begin_define
define|#
directive|define
name|TYPE_FLAG_VARARGS
value|(1<< 10)
end_define

begin_comment
comment|/* Dwarf2 has no clean way to discern C++ static and non-static member    functions. G++ helps GDB by marking the first parameter for non-static    member functions (which is the this pointer) as artificial.    We pass this information between dwarf2_add_member_fn and    read_subroutine_type via TYPE_FIELD_ARTIFICIAL.  */
end_comment

begin_define
define|#
directive|define
name|TYPE_FIELD_ARTIFICIAL
value|TYPE_FIELD_BITPOS
end_define

begin_comment
comment|/* Various complaints about symbol reading that don't abort the process */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|dwarf2_const_ignored
init|=
block|{
literal|"type qualifier 'const' ignored"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|dwarf2_volatile_ignored
init|=
block|{
literal|"type qualifier 'volatile' ignored"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|dwarf2_non_const_array_bound_ignored
init|=
block|{
literal|"non-constant array bounds form '%s' ignored"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|dwarf2_missing_line_number_section
init|=
block|{
literal|"missing .debug_line section"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|dwarf2_mangled_line_number_section
init|=
block|{
literal|"mangled .debug_line section"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|dwarf2_unsupported_die_ref_attr
init|=
block|{
literal|"unsupported die ref attribute form: '%s'"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|dwarf2_unsupported_stack_op
init|=
block|{
literal|"unsupported stack op: '%s'"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|dwarf2_unsupported_tag
init|=
block|{
literal|"unsupported tag: '%s'"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|dwarf2_unsupported_at_encoding
init|=
block|{
literal|"unsupported DW_AT_encoding: '%s'"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|dwarf2_unsupported_at_frame_base
init|=
block|{
literal|"unsupported DW_AT_frame_base for function '%s'"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|dwarf2_unexpected_tag
init|=
block|{
literal|"unexepected tag in read_type_die: '%s'"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|dwarf2_missing_at_frame_base
init|=
block|{
literal|"DW_AT_frame_base missing for DW_OP_fbreg"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|dwarf2_bad_static_member_name
init|=
block|{
literal|"unrecognized static data member name '%s'"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|dwarf2_unsupported_accessibility
init|=
block|{
literal|"unsupported accessibility %d"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|dwarf2_bad_member_name_complaint
init|=
block|{
literal|"cannot extract member name from '%s'"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|dwarf2_missing_member_fn_type_complaint
init|=
block|{
literal|"member function type missing for '%s'"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|dwarf2_vtbl_not_found_complaint
init|=
block|{
literal|"virtual function table pointer not found when defining class '%s'"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|dwarf2_absolute_sibling_complaint
init|=
block|{
literal|"ignoring absolute DW_AT_sibling"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|dwarf2_const_value_length_mismatch
init|=
block|{
literal|"const value length mismatch for '%s', got %d, expected %d"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaint
name|dwarf2_unsupported_const_value_attr
init|=
block|{
literal|"unsupported const value attribute form: '%s'"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Remember the addr_size read from the dwarf.    If a target expects to link compilation units with differing address    sizes, gdb needs to be sure that the appropriate size is here for    whatever scope is currently getting read. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|address_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Some elf32 object file formats while linked for a 32 bit address    space contain debug information that has assumed 64 bit    addresses. Eg 64 bit MIPS target produced by GCC/GAS/LD where the    symbol table contains 32bit address values while its .debug_info    section contains 64 bit address values.    ADDRESS_SIGNIFICANT_SIZE specifies the number significant bits in    the ADDRESS_SIZE bytes read from the file */
end_comment

begin_decl_stmt
specifier|static
name|int
name|address_significant_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Externals references.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|info_verbose
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* From main.c; nonzero => verbose */
end_comment

begin_comment
comment|/* local function prototypes */
end_comment

begin_decl_stmt
specifier|static
name|void
name|dwarf2_locate_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void dwarf2_build_psymtabs_easy PARAMS ((struct objfile *, 						struct section_offsets *, 						int));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|dwarf2_build_psymtabs_hard
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|,
expr|struct
name|section_offsets
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|scan_partial_symbols
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|,
name|CORE_ADDR
operator|*
operator|,
name|CORE_ADDR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_partial_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|partial_die_info
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dwarf2_psymtab_to_symtab
name|PARAMS
argument_list|(
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|psymtab_to_symtab_1
name|PARAMS
argument_list|(
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dwarf2_read_section
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|,
name|file_ptr
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dwarf2_read_abbrevs
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dwarf2_empty_abbrev_table
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|abbrev_info
modifier|*
name|dwarf2_lookup_abbrev
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|read_partial_die
name|PARAMS
argument_list|(
operator|(
expr|struct
name|partial_die_info
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|read_full_die
name|PARAMS
argument_list|(
operator|(
expr|struct
name|die_info
operator|*
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|read_attribute
name|PARAMS
argument_list|(
operator|(
expr|struct
name|attribute
operator|*
operator|,
expr|struct
name|attr_abbrev
operator|*
operator|,
name|bfd
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|read_1_byte
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|read_1_signed_byte
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|read_2_bytes
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|read_4_bytes
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|read_8_bytes
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|read_address
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|read_n_bytes
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|read_string
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|read_unsigned_leb128
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|read_signed_leb128
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|,
name|unsigned
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_cu_language
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|attribute
modifier|*
name|dwarf_attr
name|PARAMS
argument_list|(
operator|(
expr|struct
name|die_info
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dwarf_decode_lines
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
name|char
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dwarf2_start_subfile
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|symbol
modifier|*
name|new_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|die_info
operator|*
operator|,
expr|struct
name|type
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dwarf2_const_value
name|PARAMS
argument_list|(
operator|(
expr|struct
name|attribute
operator|*
operator|,
expr|struct
name|symbol
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|die_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|die_info
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|die_containing_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|die_info
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static struct type *type_at_offset PARAMS ((unsigned int, struct objfile *));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|tag_type_to_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|die_info
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_type_die
name|PARAMS
argument_list|(
operator|(
expr|struct
name|die_info
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_typedef
name|PARAMS
argument_list|(
operator|(
expr|struct
name|die_info
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_base_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|die_info
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_file_scope
name|PARAMS
argument_list|(
operator|(
expr|struct
name|die_info
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_func_scope
name|PARAMS
argument_list|(
operator|(
expr|struct
name|die_info
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_lexical_block_scope
name|PARAMS
argument_list|(
operator|(
expr|struct
name|die_info
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dwarf2_get_pc_bounds
name|PARAMS
argument_list|(
operator|(
expr|struct
name|die_info
operator|*
operator|,
name|CORE_ADDR
operator|*
operator|,
name|CORE_ADDR
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dwarf2_add_field
name|PARAMS
argument_list|(
operator|(
expr|struct
name|field_info
operator|*
operator|,
expr|struct
name|die_info
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dwarf2_attach_fields_to_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|field_info
operator|*
operator|,
expr|struct
name|type
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|skip_member_fn_name
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dwarf2_add_member_fn
name|PARAMS
argument_list|(
operator|(
expr|struct
name|field_info
operator|*
operator|,
expr|struct
name|die_info
operator|*
operator|,
expr|struct
name|type
operator|*
operator|,
expr|struct
name|objfile
operator|*
name|objfile
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dwarf2_attach_fn_fields_to_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|field_info
operator|*
operator|,
expr|struct
name|type
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_structure_scope
name|PARAMS
argument_list|(
operator|(
expr|struct
name|die_info
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_common_block
name|PARAMS
argument_list|(
operator|(
expr|struct
name|die_info
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_enumeration
name|PARAMS
argument_list|(
operator|(
expr|struct
name|die_info
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|dwarf_base_type
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|decode_locdesc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|dwarf_block
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_array_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|die_info
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_tag_pointer_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|die_info
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_tag_ptr_to_member_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|die_info
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_tag_reference_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|die_info
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_tag_const_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|die_info
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_tag_volatile_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|die_info
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_tag_string_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|die_info
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_subroutine_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|die_info
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|die_info
modifier|*
name|read_comp_unit
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_die_list
name|PARAMS
argument_list|(
operator|(
expr|struct
name|die_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_die
name|PARAMS
argument_list|(
operator|(
expr|struct
name|die_info
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dwarf2_linkage_name
name|PARAMS
argument_list|(
operator|(
expr|struct
name|die_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dwarf_tag_name
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dwarf_attr_name
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dwarf_form_name
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dwarf_stack_op_name
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dwarf_bool_name
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dwarf_type_encoding_name
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char *dwarf_cfi_name PARAMS ((unsigned int));  struct die_info *copy_die PARAMS ((struct die_info *));
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|die_info
modifier|*
name|sibling_die
name|PARAMS
argument_list|(
operator|(
expr|struct
name|die_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|dump_die
name|PARAMS
argument_list|(
operator|(
expr|struct
name|die_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|dump_die_list
name|PARAMS
argument_list|(
operator|(
expr|struct
name|die_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|store_in_ref_table
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|,
expr|struct
name|die_info
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dwarf2_empty_die_ref_table
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|dwarf2_get_ref_die_offset
name|PARAMS
argument_list|(
operator|(
expr|struct
name|attribute
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|die_info
modifier|*
name|follow_die_ref
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|dwarf2_fundamental_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* memory allocation interface */
end_comment

begin_decl_stmt
specifier|static
name|void
name|dwarf2_free_tmp_obstack
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|dwarf_block
modifier|*
name|dwarf_alloc_block
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|abbrev_info
modifier|*
name|dwarf_alloc_abbrev
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|die_info
modifier|*
name|dwarf_alloc_die
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Try to locate the sections we need for DWARF 2 debugging    information and return true if we have enough to do something.  */
end_comment

begin_function
name|int
name|dwarf2_has_info
parameter_list|(
name|abfd
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|dwarf_info_offset
operator|=
name|dwarf_abbrev_offset
operator|=
name|dwarf_line_offset
operator|=
literal|0
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|dwarf2_locate_sections
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwarf_info_offset
operator|&&
name|dwarf_abbrev_offset
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* This function is mapped across the sections and remembers the    offset and size of each of the debugging sections we are interested    in.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2_locate_sections
parameter_list|(
name|ignore_abfd
parameter_list|,
name|sectp
parameter_list|,
name|ignore_ptr
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
decl_stmt|;
name|asection
modifier|*
name|sectp
decl_stmt|;
name|PTR
name|ignore_ptr
decl_stmt|;
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|sectp
operator|->
name|name
argument_list|,
name|INFO_SECTION
argument_list|)
condition|)
block|{
name|dwarf_info_offset
operator|=
name|sectp
operator|->
name|filepos
expr_stmt|;
name|dwarf_info_size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|sectp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|sectp
operator|->
name|name
argument_list|,
name|ABBREV_SECTION
argument_list|)
condition|)
block|{
name|dwarf_abbrev_offset
operator|=
name|sectp
operator|->
name|filepos
expr_stmt|;
name|dwarf_abbrev_size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|sectp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|sectp
operator|->
name|name
argument_list|,
name|LINE_SECTION
argument_list|)
condition|)
block|{
name|dwarf_line_offset
operator|=
name|sectp
operator|->
name|filepos
expr_stmt|;
name|dwarf_line_size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|sectp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|sectp
operator|->
name|name
argument_list|,
name|PUBNAMES_SECTION
argument_list|)
condition|)
block|{
name|dwarf_pubnames_offset
operator|=
name|sectp
operator|->
name|filepos
expr_stmt|;
name|dwarf_pubnames_size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|sectp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|sectp
operator|->
name|name
argument_list|,
name|ARANGES_SECTION
argument_list|)
condition|)
block|{
name|dwarf_aranges_offset
operator|=
name|sectp
operator|->
name|filepos
expr_stmt|;
name|dwarf_aranges_size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|sectp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|sectp
operator|->
name|name
argument_list|,
name|LOC_SECTION
argument_list|)
condition|)
block|{
name|dwarf_loc_offset
operator|=
name|sectp
operator|->
name|filepos
expr_stmt|;
name|dwarf_loc_size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|sectp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|sectp
operator|->
name|name
argument_list|,
name|MACINFO_SECTION
argument_list|)
condition|)
block|{
name|dwarf_macinfo_offset
operator|=
name|sectp
operator|->
name|filepos
expr_stmt|;
name|dwarf_macinfo_size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|sectp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|sectp
operator|->
name|name
argument_list|,
name|STR_SECTION
argument_list|)
condition|)
block|{
name|dwarf_str_offset
operator|=
name|sectp
operator|->
name|filepos
expr_stmt|;
name|dwarf_str_size
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|sectp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Build a partial symbol table.  */
end_comment

begin_function
name|void
name|dwarf2_build_psymtabs
parameter_list|(
name|objfile
parameter_list|,
name|section_offsets
parameter_list|,
name|mainline
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|int
name|mainline
decl_stmt|;
block|{
comment|/* We definitely need the .debug_info and .debug_abbrev sections */
name|dwarf_info_buffer
operator|=
name|dwarf2_read_section
argument_list|(
name|objfile
argument_list|,
name|dwarf_info_offset
argument_list|,
name|dwarf_info_size
argument_list|)
expr_stmt|;
name|dwarf_abbrev_buffer
operator|=
name|dwarf2_read_section
argument_list|(
name|objfile
argument_list|,
name|dwarf_abbrev_offset
argument_list|,
name|dwarf_abbrev_size
argument_list|)
expr_stmt|;
name|dwarf_line_buffer
operator|=
name|dwarf2_read_section
argument_list|(
name|objfile
argument_list|,
name|dwarf_line_offset
argument_list|,
name|dwarf_line_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|mainline
operator|||
name|objfile
operator|->
name|global_psymbols
operator|.
name|size
operator|==
literal|0
operator|||
name|objfile
operator|->
name|static_psymbols
operator|.
name|size
operator|==
literal|0
condition|)
block|{
name|init_psymbol_list
argument_list|(
name|objfile
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|if (dwarf_aranges_offset&& dwarf_pubnames_offset)     {
comment|/* Things are significanlty easier if we have .debug_aranges and          .debug_pubnames sections */
block|dwarf2_build_psymtabs_easy (objfile, section_offsets, mainline);     }   else
endif|#
directive|endif
comment|/* only test this case for now */
block|{
comment|/* In this case we have to work a bit harder */
name|dwarf2_build_psymtabs_hard
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|,
name|mainline
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Build the partial symbol table from the information in the    .debug_pubnames and .debug_aranges sections.  */
end_comment

begin_endif
unit|static void dwarf2_build_psymtabs_easy (objfile, section_offsets, mainline)      struct objfile *objfile;      struct section_offsets *section_offsets;      int mainline; {   bfd *abfd = objfile->obfd;   char *aranges_buffer, *pubnames_buffer;   char *aranges_ptr, *pubnames_ptr;   unsigned int entry_length, version, info_offset, info_size;    pubnames_buffer = dwarf2_read_section (objfile, 					 dwarf_pubnames_offset, 					 dwarf_pubnames_size);   pubnames_ptr = pubnames_buffer;   while ((pubnames_ptr - pubnames_buffer)< dwarf_pubnames_size)     {       entry_length = read_4_bytes (abfd, pubnames_ptr);       pubnames_ptr += 4;       version = read_1_byte (abfd, pubnames_ptr);       pubnames_ptr += 1;       info_offset = read_4_bytes (abfd, pubnames_ptr);       pubnames_ptr += 4;       info_size = read_4_bytes (abfd, pubnames_ptr);       pubnames_ptr += 4;     }    aranges_buffer = dwarf2_read_section (objfile, 					dwarf_aranges_offset, 					dwarf_aranges_size);  }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Build the partial symbol table by doing a quick pass through the    .debug_info and .debug_abbrev sections.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2_build_psymtabs_hard
parameter_list|(
name|objfile
parameter_list|,
name|section_offsets
parameter_list|,
name|mainline
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|int
name|mainline
decl_stmt|;
block|{
comment|/* Instead of reading this into a big buffer, we should probably use      mmap()  on architectures that support it. (FIXME) */
name|bfd
modifier|*
name|abfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
name|char
modifier|*
name|info_ptr
decl_stmt|,
modifier|*
name|abbrev_ptr
decl_stmt|;
name|char
modifier|*
name|beg_of_comp_unit
decl_stmt|;
name|struct
name|comp_unit_head
name|cu_header
decl_stmt|;
name|struct
name|partial_die_info
name|comp_unit_die
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
decl_stmt|;
name|int
name|comp_unit_has_pc_info
decl_stmt|;
name|CORE_ADDR
name|lowpc
decl_stmt|,
name|highpc
decl_stmt|;
comment|/* Number of bytes of any addresses that are signficant */
name|address_significant_size
operator|=
name|get_elf_backend_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|s
operator|->
name|arch_size
operator|/
literal|8
expr_stmt|;
name|info_ptr
operator|=
name|dwarf_info_buffer
expr_stmt|;
name|abbrev_ptr
operator|=
name|dwarf_abbrev_buffer
expr_stmt|;
name|obstack_init
argument_list|(
operator|&
name|dwarf2_tmp_obstack
argument_list|)
expr_stmt|;
name|back_to
operator|=
name|make_cleanup
argument_list|(
name|dwarf2_free_tmp_obstack
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|info_ptr
operator|-
name|dwarf_info_buffer
argument_list|)
operator|+
operator|(
operator|(
name|info_ptr
operator|-
name|dwarf_info_buffer
operator|)
operator|%
literal|4
operator|)
operator|<
name|dwarf_info_size
condition|)
block|{
name|beg_of_comp_unit
operator|=
name|info_ptr
expr_stmt|;
name|cu_header
operator|.
name|length
operator|=
name|read_4_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|4
expr_stmt|;
name|cu_header
operator|.
name|version
operator|=
name|read_2_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|2
expr_stmt|;
name|cu_header
operator|.
name|abbrev_offset
operator|=
name|read_4_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|4
expr_stmt|;
name|cu_header
operator|.
name|addr_size
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|1
expr_stmt|;
name|address_size
operator|=
name|cu_header
operator|.
name|addr_size
expr_stmt|;
if|if
condition|(
name|cu_header
operator|.
name|version
operator|!=
literal|2
condition|)
block|{
name|error
argument_list|(
literal|"Dwarf Error: wrong version in compilation unit header."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cu_header
operator|.
name|abbrev_offset
operator|>=
name|dwarf_abbrev_size
condition|)
block|{
name|error
argument_list|(
literal|"Dwarf Error: bad offset (0x%lx) in compilation unit header (offset 0x%lx + 6)."
argument_list|,
operator|(
name|long
operator|)
name|cu_header
operator|.
name|abbrev_offset
argument_list|,
call|(
name|long
call|)
argument_list|(
name|beg_of_comp_unit
operator|-
name|dwarf_info_buffer
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|beg_of_comp_unit
operator|+
name|cu_header
operator|.
name|length
operator|+
literal|4
operator|>
name|dwarf_info_buffer
operator|+
name|dwarf_info_size
condition|)
block|{
name|error
argument_list|(
literal|"Dwarf Error: bad length (0x%lx) in compilation unit header (offset 0x%lx + 0)."
argument_list|,
operator|(
name|long
operator|)
name|cu_header
operator|.
name|length
argument_list|,
call|(
name|long
call|)
argument_list|(
name|beg_of_comp_unit
operator|-
name|dwarf_info_buffer
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|address_size
operator|<
name|address_significant_size
condition|)
block|{
name|error
argument_list|(
literal|"Dwarf Error: bad address size (%ld) in compilation unit header (offset 0x%lx + 11)."
argument_list|,
operator|(
name|long
operator|)
name|cu_header
operator|.
name|addr_size
argument_list|,
call|(
name|long
call|)
argument_list|(
name|beg_of_comp_unit
operator|-
name|dwarf_info_buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Read the abbrevs for this compilation unit into a table */
name|dwarf2_read_abbrevs
argument_list|(
name|abfd
argument_list|,
name|cu_header
operator|.
name|abbrev_offset
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|dwarf2_empty_abbrev_table
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Read the compilation unit die */
name|info_ptr
operator|=
name|read_partial_die
argument_list|(
operator|&
name|comp_unit_die
argument_list|,
name|abfd
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|comp_unit_has_pc_info
argument_list|)
expr_stmt|;
comment|/* Set the language we're debugging */
name|set_cu_language
argument_list|(
name|comp_unit_die
operator|.
name|language
argument_list|)
expr_stmt|;
comment|/* Allocate a new partial symbol table structure */
name|pst
operator|=
name|start_psymtab_common
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|,
name|comp_unit_die
operator|.
name|name
condition|?
name|comp_unit_die
operator|.
name|name
else|:
literal|""
argument_list|,
name|comp_unit_die
operator|.
name|lowpc
argument_list|,
name|objfile
operator|->
name|global_psymbols
operator|.
name|next
argument_list|,
name|objfile
operator|->
name|static_psymbols
operator|.
name|next
argument_list|)
expr_stmt|;
name|pst
operator|->
name|read_symtab_private
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dwarf2_pinfo
argument_list|)
argument_list|)
expr_stmt|;
name|cu_header_offset
operator|=
name|beg_of_comp_unit
operator|-
name|dwarf_info_buffer
expr_stmt|;
name|DWARF_INFO_BUFFER
argument_list|(
name|pst
argument_list|)
operator|=
name|dwarf_info_buffer
expr_stmt|;
name|DWARF_INFO_OFFSET
argument_list|(
name|pst
argument_list|)
operator|=
name|beg_of_comp_unit
operator|-
name|dwarf_info_buffer
expr_stmt|;
name|DWARF_ABBREV_BUFFER
argument_list|(
name|pst
argument_list|)
operator|=
name|dwarf_abbrev_buffer
expr_stmt|;
name|DWARF_ABBREV_SIZE
argument_list|(
name|pst
argument_list|)
operator|=
name|dwarf_abbrev_size
expr_stmt|;
name|DWARF_LINE_BUFFER
argument_list|(
name|pst
argument_list|)
operator|=
name|dwarf_line_buffer
expr_stmt|;
name|baseaddr
operator|=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Store the function that reads in the rest of the symbol table */
name|pst
operator|->
name|read_symtab
operator|=
name|dwarf2_psymtab_to_symtab
expr_stmt|;
comment|/* Check if comp unit has_children.          If so, read the rest of the partial symbols from this comp unit.          If not, there's no more debug_info for this comp unit. */
if|if
condition|(
name|comp_unit_die
operator|.
name|has_children
condition|)
block|{
name|info_ptr
operator|=
name|scan_partial_symbols
argument_list|(
name|info_ptr
argument_list|,
name|objfile
argument_list|,
operator|&
name|lowpc
argument_list|,
operator|&
name|highpc
argument_list|)
expr_stmt|;
comment|/* If the compilation unit didn't have an explicit address range, 	     then use the information extracted from its child dies.  */
if|if
condition|(
operator|!
name|comp_unit_has_pc_info
condition|)
block|{
name|comp_unit_die
operator|.
name|lowpc
operator|=
name|lowpc
expr_stmt|;
name|comp_unit_die
operator|.
name|highpc
operator|=
name|highpc
expr_stmt|;
block|}
block|}
name|pst
operator|->
name|textlow
operator|=
name|comp_unit_die
operator|.
name|lowpc
operator|+
name|baseaddr
expr_stmt|;
name|pst
operator|->
name|texthigh
operator|=
name|comp_unit_die
operator|.
name|highpc
operator|+
name|baseaddr
expr_stmt|;
name|pst
operator|->
name|n_global_syms
operator|=
name|objfile
operator|->
name|global_psymbols
operator|.
name|next
operator|-
operator|(
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|pst
operator|->
name|globals_offset
operator|)
expr_stmt|;
name|pst
operator|->
name|n_static_syms
operator|=
name|objfile
operator|->
name|static_psymbols
operator|.
name|next
operator|-
operator|(
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|pst
operator|->
name|statics_offset
operator|)
expr_stmt|;
name|sort_pst_symbols
argument_list|(
name|pst
argument_list|)
expr_stmt|;
comment|/* If there is already a psymtab or symtab for a file of this          name, remove it. (If there is a symtab, more drastic things          also happen.) This happens in VxWorks.  */
name|free_named_symtabs
argument_list|(
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
name|info_ptr
operator|=
name|beg_of_comp_unit
operator|+
name|cu_header
operator|.
name|length
operator|+
literal|4
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read in all interesting dies to the end of the compilation unit.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|scan_partial_symbols
parameter_list|(
name|info_ptr
parameter_list|,
name|objfile
parameter_list|,
name|lowpc
parameter_list|,
name|highpc
parameter_list|)
name|char
modifier|*
name|info_ptr
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|CORE_ADDR
modifier|*
name|lowpc
decl_stmt|;
name|CORE_ADDR
modifier|*
name|highpc
decl_stmt|;
block|{
name|bfd
modifier|*
name|abfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
name|struct
name|partial_die_info
name|pdi
decl_stmt|;
comment|/* This function is called after we've read in the comp_unit_die in      order to read its children.  We start the nesting level at 1 since      we have pushed 1 level down in order to read the comp unit's children.      The comp unit itself is at level 0, so we stop reading when we pop      back to that level. */
name|int
name|nesting_level
init|=
literal|1
decl_stmt|;
name|int
name|has_pc_info
decl_stmt|;
operator|*
name|lowpc
operator|=
operator|(
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
operator|*
name|highpc
operator|=
operator|(
operator|(
name|CORE_ADDR
operator|)
literal|0
operator|)
expr_stmt|;
while|while
condition|(
name|nesting_level
condition|)
block|{
name|info_ptr
operator|=
name|read_partial_die
argument_list|(
operator|&
name|pdi
argument_list|,
name|abfd
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|has_pc_info
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdi
operator|.
name|name
condition|)
block|{
switch|switch
condition|(
name|pdi
operator|.
name|tag
condition|)
block|{
case|case
name|DW_TAG_subprogram
case|:
if|if
condition|(
name|has_pc_info
condition|)
block|{
if|if
condition|(
name|pdi
operator|.
name|lowpc
operator|<
operator|*
name|lowpc
condition|)
block|{
operator|*
name|lowpc
operator|=
name|pdi
operator|.
name|lowpc
expr_stmt|;
block|}
if|if
condition|(
name|pdi
operator|.
name|highpc
operator|>
operator|*
name|highpc
condition|)
block|{
operator|*
name|highpc
operator|=
name|pdi
operator|.
name|highpc
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pdi
operator|.
name|is_external
operator|||
name|nesting_level
operator|==
literal|1
operator|)
operator|&&
operator|!
name|pdi
operator|.
name|is_declaration
condition|)
block|{
name|add_partial_symbol
argument_list|(
operator|&
name|pdi
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|DW_TAG_variable
case|:
case|case
name|DW_TAG_typedef
case|:
case|case
name|DW_TAG_class_type
case|:
case|case
name|DW_TAG_structure_type
case|:
case|case
name|DW_TAG_union_type
case|:
case|case
name|DW_TAG_enumeration_type
case|:
if|if
condition|(
operator|(
name|pdi
operator|.
name|is_external
operator|||
name|nesting_level
operator|==
literal|1
operator|)
operator|&&
operator|!
name|pdi
operator|.
name|is_declaration
condition|)
block|{
name|add_partial_symbol
argument_list|(
operator|&
name|pdi
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DW_TAG_enumerator
case|:
comment|/* File scope enumerators are added to the partial symbol 		 table.  */
if|if
condition|(
name|nesting_level
operator|==
literal|2
condition|)
name|add_partial_symbol
argument_list|(
operator|&
name|pdi
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_base_type
case|:
comment|/* File scope base type definitions are added to the partial 		 symbol table.  */
if|if
condition|(
name|nesting_level
operator|==
literal|1
condition|)
name|add_partial_symbol
argument_list|(
operator|&
name|pdi
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* If the die has a sibling, skip to the sibling. 	 Do not skip enumeration types, we want to record their 	 enumerators.  */
if|if
condition|(
name|pdi
operator|.
name|sibling
operator|&&
name|pdi
operator|.
name|tag
operator|!=
name|DW_TAG_enumeration_type
condition|)
block|{
name|info_ptr
operator|=
name|pdi
operator|.
name|sibling
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pdi
operator|.
name|has_children
condition|)
block|{
comment|/* Die has children, but the optional DW_AT_sibling attribute 	     is missing.  */
name|nesting_level
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|pdi
operator|.
name|tag
operator|==
literal|0
condition|)
block|{
name|nesting_level
operator|--
expr_stmt|;
block|}
block|}
comment|/* If we didn't find a lowpc, set it to highpc to avoid complaints      from `maint check'.  */
if|if
condition|(
operator|*
name|lowpc
operator|==
operator|(
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
operator|)
condition|)
operator|*
name|lowpc
operator|=
operator|*
name|highpc
expr_stmt|;
return|return
name|info_ptr
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_partial_symbol
parameter_list|(
name|pdi
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|partial_die_info
modifier|*
name|pdi
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|CORE_ADDR
name|addr
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|pdi
operator|->
name|tag
condition|)
block|{
case|case
name|DW_TAG_subprogram
case|:
if|if
condition|(
name|pdi
operator|->
name|is_external
condition|)
block|{
comment|/*prim_record_minimal_symbol (pdi->name, pdi->lowpc + baseaddr, 				      mst_text, objfile);*/
name|add_psymbol_to_list
argument_list|(
name|pdi
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|pdi
operator|->
name|name
argument_list|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_BLOCK
argument_list|,
operator|&
name|objfile
operator|->
name|global_psymbols
argument_list|,
literal|0
argument_list|,
name|pdi
operator|->
name|lowpc
operator|+
name|baseaddr
argument_list|,
name|cu_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*prim_record_minimal_symbol (pdi->name, pdi->lowpc + baseaddr, 				      mst_file_text, objfile);*/
name|add_psymbol_to_list
argument_list|(
name|pdi
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|pdi
operator|->
name|name
argument_list|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_BLOCK
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
literal|0
argument_list|,
name|pdi
operator|->
name|lowpc
operator|+
name|baseaddr
argument_list|,
name|cu_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DW_TAG_variable
case|:
if|if
condition|(
name|pdi
operator|->
name|is_external
condition|)
block|{
comment|/* Global Variable. 	     Don't enter into the minimal symbol tables as there is 	     a minimal symbol table entry from the ELF symbols already. 	     Enter into partial symbol table if it has a location 	     descriptor or a type. 	     If the location descriptor is missing, new_symbol will create 	     a LOC_UNRESOLVED symbol, the address of the variable will then 	     be determined from the minimal symbol table whenever the variable 	     is referenced. 	     The address for the partial symbol table entry is not 	     used by GDB, but it comes in handy for debugging partial symbol 	     table building.  */
if|if
condition|(
name|pdi
operator|->
name|locdesc
condition|)
name|addr
operator|=
name|decode_locdesc
argument_list|(
name|pdi
operator|->
name|locdesc
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdi
operator|->
name|locdesc
operator|||
name|pdi
operator|->
name|has_type
condition|)
name|add_psymbol_to_list
argument_list|(
name|pdi
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|pdi
operator|->
name|name
argument_list|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_STATIC
argument_list|,
operator|&
name|objfile
operator|->
name|global_psymbols
argument_list|,
literal|0
argument_list|,
name|addr
operator|+
name|baseaddr
argument_list|,
name|cu_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Static Variable. Skip symbols without location descriptors.  */
if|if
condition|(
name|pdi
operator|->
name|locdesc
operator|==
name|NULL
condition|)
return|return;
name|addr
operator|=
name|decode_locdesc
argument_list|(
name|pdi
operator|->
name|locdesc
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/*prim_record_minimal_symbol (pdi->name, addr + baseaddr, 				      mst_file_data, objfile);*/
name|add_psymbol_to_list
argument_list|(
name|pdi
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|pdi
operator|->
name|name
argument_list|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_STATIC
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
literal|0
argument_list|,
name|addr
operator|+
name|baseaddr
argument_list|,
name|cu_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DW_TAG_typedef
case|:
case|case
name|DW_TAG_base_type
case|:
name|add_psymbol_to_list
argument_list|(
name|pdi
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|pdi
operator|->
name|name
argument_list|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_TYPEDEF
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
literal|0
argument_list|,
operator|(
name|CORE_ADDR
operator|)
literal|0
argument_list|,
name|cu_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_class_type
case|:
case|case
name|DW_TAG_structure_type
case|:
case|case
name|DW_TAG_union_type
case|:
case|case
name|DW_TAG_enumeration_type
case|:
comment|/* Skip aggregate types without children, these are external 	 references.  */
if|if
condition|(
name|pdi
operator|->
name|has_children
operator|==
literal|0
condition|)
return|return;
name|add_psymbol_to_list
argument_list|(
name|pdi
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|pdi
operator|->
name|name
argument_list|)
argument_list|,
name|STRUCT_NAMESPACE
argument_list|,
name|LOC_TYPEDEF
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
literal|0
argument_list|,
operator|(
name|CORE_ADDR
operator|)
literal|0
argument_list|,
name|cu_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|cu_language
operator|==
name|language_cplus
condition|)
block|{
comment|/* For C++, these implicitly act as typedefs as well. */
name|add_psymbol_to_list
argument_list|(
name|pdi
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|pdi
operator|->
name|name
argument_list|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_TYPEDEF
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
literal|0
argument_list|,
operator|(
name|CORE_ADDR
operator|)
literal|0
argument_list|,
name|cu_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DW_TAG_enumerator
case|:
name|add_psymbol_to_list
argument_list|(
name|pdi
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|pdi
operator|->
name|name
argument_list|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_CONST
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
literal|0
argument_list|,
operator|(
name|CORE_ADDR
operator|)
literal|0
argument_list|,
name|cu_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Expand this partial symbol table into a full symbol table.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2_psymtab_to_symtab
parameter_list|(
name|pst
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
block|{
comment|/* FIXME: This is barely more than a stub.  */
if|if
condition|(
name|pst
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pst
operator|->
name|readin
condition|)
block|{
name|warning
argument_list|(
literal|"bug: psymtab for %s is already read in."
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|info_verbose
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Reading in symbols for %s..."
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|psymtab_to_symtab_1
argument_list|(
name|pst
argument_list|)
expr_stmt|;
comment|/* Finish up the debug error message.  */
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"done.\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|psymtab_to_symtab_1
parameter_list|(
name|pst
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
block|{
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|pst
operator|->
name|objfile
decl_stmt|;
name|bfd
modifier|*
name|abfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
name|struct
name|comp_unit_head
name|cu_header
decl_stmt|;
name|struct
name|die_info
modifier|*
name|dies
decl_stmt|;
name|unsigned
name|long
name|offset
decl_stmt|;
name|CORE_ADDR
name|lowpc
decl_stmt|,
name|highpc
decl_stmt|;
name|struct
name|die_info
modifier|*
name|child_die
decl_stmt|;
name|char
modifier|*
name|info_ptr
decl_stmt|;
name|struct
name|symtab
modifier|*
name|symtab
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
decl_stmt|;
comment|/* Set local variables from the partial symbol table info.  */
name|offset
operator|=
name|DWARF_INFO_OFFSET
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|dwarf_info_buffer
operator|=
name|DWARF_INFO_BUFFER
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|dwarf_abbrev_buffer
operator|=
name|DWARF_ABBREV_BUFFER
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|dwarf_abbrev_size
operator|=
name|DWARF_ABBREV_SIZE
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|dwarf_line_buffer
operator|=
name|DWARF_LINE_BUFFER
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|baseaddr
operator|=
name|ANOFFSET
argument_list|(
name|pst
operator|->
name|section_offsets
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cu_header_offset
operator|=
name|offset
expr_stmt|;
name|info_ptr
operator|=
name|dwarf_info_buffer
operator|+
name|offset
expr_stmt|;
name|obstack_init
argument_list|(
operator|&
name|dwarf2_tmp_obstack
argument_list|)
expr_stmt|;
name|back_to
operator|=
name|make_cleanup
argument_list|(
name|dwarf2_free_tmp_obstack
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|buildsym_init
argument_list|()
expr_stmt|;
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|really_free_pendings
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* read in the comp_unit header  */
name|cu_header
operator|.
name|length
operator|=
name|read_4_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|4
expr_stmt|;
name|cu_header
operator|.
name|version
operator|=
name|read_2_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|2
expr_stmt|;
name|cu_header
operator|.
name|abbrev_offset
operator|=
name|read_4_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|4
expr_stmt|;
name|cu_header
operator|.
name|addr_size
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|1
expr_stmt|;
comment|/* Read the abbrevs for this compilation unit  */
name|dwarf2_read_abbrevs
argument_list|(
name|abfd
argument_list|,
name|cu_header
operator|.
name|abbrev_offset
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|dwarf2_empty_abbrev_table
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dies
operator|=
name|read_comp_unit
argument_list|(
name|info_ptr
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_die_list
argument_list|,
name|dies
argument_list|)
expr_stmt|;
comment|/* Do line number decoding in read_file_scope () */
name|process_die
argument_list|(
name|dies
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dwarf2_get_pc_bounds
argument_list|(
name|dies
argument_list|,
operator|&
name|lowpc
argument_list|,
operator|&
name|highpc
argument_list|,
name|objfile
argument_list|)
condition|)
block|{
comment|/* Some compilers don't define a DW_AT_high_pc attribute for 	 the compilation unit.   If the DW_AT_high_pc is missing, 	 synthesize it, by scanning the DIE's below the compilation unit.  */
name|highpc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dies
operator|->
name|has_children
condition|)
block|{
name|child_die
operator|=
name|dies
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|child_die
operator|&&
name|child_die
operator|->
name|tag
condition|)
block|{
if|if
condition|(
name|child_die
operator|->
name|tag
operator|==
name|DW_TAG_subprogram
condition|)
block|{
name|CORE_ADDR
name|low
decl_stmt|,
name|high
decl_stmt|;
if|if
condition|(
name|dwarf2_get_pc_bounds
argument_list|(
name|child_die
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|high
argument_list|,
name|objfile
argument_list|)
condition|)
block|{
name|highpc
operator|=
name|max
argument_list|(
name|highpc
argument_list|,
name|high
argument_list|)
expr_stmt|;
block|}
block|}
name|child_die
operator|=
name|sibling_die
argument_list|(
name|child_die
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|symtab
operator|=
name|end_symtab
argument_list|(
name|highpc
operator|+
name|baseaddr
argument_list|,
name|objfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set symtab language to language from DW_AT_language.      If the compilation is from a C file generated by language preprocessors,      do not set the language if it was already deduced by start_subfile.  */
if|if
condition|(
name|symtab
operator|!=
name|NULL
operator|&&
operator|!
operator|(
name|cu_language
operator|==
name|language_c
operator|&&
name|symtab
operator|->
name|language
operator|!=
name|language_c
operator|)
condition|)
block|{
name|symtab
operator|->
name|language
operator|=
name|cu_language
expr_stmt|;
block|}
name|pst
operator|->
name|symtab
operator|=
name|symtab
expr_stmt|;
name|pst
operator|->
name|readin
operator|=
literal|1
expr_stmt|;
name|sort_symtab_syms
argument_list|(
name|pst
operator|->
name|symtab
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process a die and its children.  */
end_comment

begin_function
specifier|static
name|void
name|process_die
parameter_list|(
name|die
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|die_info
modifier|*
name|die
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
switch|switch
condition|(
name|die
operator|->
name|tag
condition|)
block|{
case|case
name|DW_TAG_padding
case|:
break|break;
case|case
name|DW_TAG_compile_unit
case|:
name|read_file_scope
argument_list|(
name|die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_subprogram
case|:
name|read_subroutine_type
argument_list|(
name|die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|read_func_scope
argument_list|(
name|die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_inlined_subroutine
case|:
comment|/* FIXME:  These are ignored for now. 	 They could be used to set breakpoints on all inlined instances 	 of a function and make GDB `next' properly over inlined functions.  */
break|break;
case|case
name|DW_TAG_lexical_block
case|:
name|read_lexical_block_scope
argument_list|(
name|die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_class_type
case|:
case|case
name|DW_TAG_structure_type
case|:
case|case
name|DW_TAG_union_type
case|:
name|read_structure_scope
argument_list|(
name|die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_enumeration_type
case|:
name|read_enumeration
argument_list|(
name|die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_subroutine_type
case|:
name|read_subroutine_type
argument_list|(
name|die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_array_type
case|:
name|read_array_type
argument_list|(
name|die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_pointer_type
case|:
name|read_tag_pointer_type
argument_list|(
name|die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_ptr_to_member_type
case|:
name|read_tag_ptr_to_member_type
argument_list|(
name|die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_reference_type
case|:
name|read_tag_reference_type
argument_list|(
name|die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_string_type
case|:
name|read_tag_string_type
argument_list|(
name|die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_base_type
case|:
name|read_base_type
argument_list|(
name|die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_name
argument_list|)
condition|)
block|{
comment|/* Add a typedef symbol for the base type definition.  */
name|new_symbol
argument_list|(
name|die
argument_list|,
name|die
operator|->
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DW_TAG_common_block
case|:
name|read_common_block
argument_list|(
name|die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_common_inclusion
case|:
break|break;
default|default:
name|new_symbol
argument_list|(
name|die
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|read_file_scope
parameter_list|(
name|die
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|die_info
modifier|*
name|die
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|unsigned
name|int
name|line_offset
init|=
literal|0
decl_stmt|;
name|CORE_ADDR
name|lowpc
init|=
operator|(
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
name|CORE_ADDR
name|highpc
init|=
operator|(
operator|(
name|CORE_ADDR
operator|)
literal|0
operator|)
decl_stmt|;
name|struct
name|attribute
modifier|*
name|attr
decl_stmt|;
name|char
modifier|*
name|name
init|=
literal|"<unknown>"
decl_stmt|;
name|char
modifier|*
name|comp_dir
init|=
name|NULL
decl_stmt|;
name|struct
name|die_info
modifier|*
name|child_die
decl_stmt|;
name|bfd
modifier|*
name|abfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
if|if
condition|(
operator|!
name|dwarf2_get_pc_bounds
argument_list|(
name|die
argument_list|,
operator|&
name|lowpc
argument_list|,
operator|&
name|highpc
argument_list|,
name|objfile
argument_list|)
condition|)
block|{
if|if
condition|(
name|die
operator|->
name|has_children
condition|)
block|{
name|child_die
operator|=
name|die
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|child_die
operator|&&
name|child_die
operator|->
name|tag
condition|)
block|{
if|if
condition|(
name|child_die
operator|->
name|tag
operator|==
name|DW_TAG_subprogram
condition|)
block|{
name|CORE_ADDR
name|low
decl_stmt|,
name|high
decl_stmt|;
if|if
condition|(
name|dwarf2_get_pc_bounds
argument_list|(
name|child_die
argument_list|,
operator|&
name|low
argument_list|,
operator|&
name|high
argument_list|,
name|objfile
argument_list|)
condition|)
block|{
name|lowpc
operator|=
name|min
argument_list|(
name|lowpc
argument_list|,
name|low
argument_list|)
expr_stmt|;
name|highpc
operator|=
name|max
argument_list|(
name|highpc
argument_list|,
name|high
argument_list|)
expr_stmt|;
block|}
block|}
name|child_die
operator|=
name|sibling_die
argument_list|(
name|child_die
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* If we didn't find a lowpc, set it to highpc to avoid complaints      from finish_block.  */
if|if
condition|(
name|lowpc
operator|==
operator|(
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
operator|)
condition|)
name|lowpc
operator|=
name|highpc
expr_stmt|;
name|lowpc
operator|+=
name|baseaddr
expr_stmt|;
name|highpc
operator|+=
name|baseaddr
expr_stmt|;
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|name
operator|=
name|DW_STRING
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_comp_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|comp_dir
operator|=
name|DW_STRING
argument_list|(
name|attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|comp_dir
condition|)
block|{
comment|/* Irix 6.2 native cc prepends<machine>.: to the compilation 	     directory, get rid of it.  */
name|char
modifier|*
name|cp
init|=
name|strchr
argument_list|(
name|comp_dir
argument_list|,
literal|':'
argument_list|)
decl_stmt|;
if|if
condition|(
name|cp
operator|&&
name|cp
operator|!=
name|comp_dir
operator|&&
name|cp
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|cp
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
name|comp_dir
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|objfile
operator|->
name|ei
operator|.
name|entry_point
operator|>=
name|lowpc
operator|&&
name|objfile
operator|->
name|ei
operator|.
name|entry_point
operator|<
name|highpc
condition|)
block|{
name|objfile
operator|->
name|ei
operator|.
name|entry_file_lowpc
operator|=
name|lowpc
expr_stmt|;
name|objfile
operator|->
name|ei
operator|.
name|entry_file_highpc
operator|=
name|highpc
expr_stmt|;
block|}
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_language
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|set_cu_language
argument_list|(
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We assume that we're processing GCC output. */
name|processing_gcc_compilation
operator|=
literal|2
expr_stmt|;
if|#
directive|if
literal|0
comment|/* FIXME:Do something here.  */
block|if (dip->at_producer != NULL)     {       handle_producer (dip->at_producer);     }
endif|#
directive|endif
comment|/* The compilation unit may be in a different language or objfile,      zero out all remembered fundamental types.  */
name|memset
argument_list|(
name|ftypes
argument_list|,
literal|0
argument_list|,
name|FT_NUM_MEMBERS
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|start_symtab
argument_list|(
name|name
argument_list|,
name|comp_dir
argument_list|,
name|lowpc
argument_list|)
expr_stmt|;
name|record_debugformat
argument_list|(
literal|"DWARF 2"
argument_list|)
expr_stmt|;
comment|/* Decode line number information if present.  */
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_stmt_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|line_offset
operator|=
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|dwarf_decode_lines
argument_list|(
name|line_offset
argument_list|,
name|comp_dir
argument_list|,
name|abfd
argument_list|)
expr_stmt|;
block|}
comment|/* Process all dies in compilation unit.  */
if|if
condition|(
name|die
operator|->
name|has_children
condition|)
block|{
name|child_die
operator|=
name|die
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|child_die
operator|&&
name|child_die
operator|->
name|tag
condition|)
block|{
name|process_die
argument_list|(
name|child_die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|child_die
operator|=
name|sibling_die
argument_list|(
name|child_die
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|read_func_scope
parameter_list|(
name|die
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|die_info
modifier|*
name|die
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
specifier|register
name|struct
name|context_stack
modifier|*
name|new
decl_stmt|;
name|CORE_ADDR
name|lowpc
decl_stmt|;
name|CORE_ADDR
name|highpc
decl_stmt|;
name|struct
name|die_info
modifier|*
name|child_die
decl_stmt|;
name|struct
name|attribute
modifier|*
name|attr
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|dwarf2_linkage_name
argument_list|(
name|die
argument_list|)
expr_stmt|;
comment|/* Ignore functions with missing or empty names and functions with      missing or invalid low and high pc attributes.  */
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
operator|!
name|dwarf2_get_pc_bounds
argument_list|(
name|die
argument_list|,
operator|&
name|lowpc
argument_list|,
operator|&
name|highpc
argument_list|,
name|objfile
argument_list|)
condition|)
return|return;
name|lowpc
operator|+=
name|baseaddr
expr_stmt|;
name|highpc
operator|+=
name|baseaddr
expr_stmt|;
if|if
condition|(
name|objfile
operator|->
name|ei
operator|.
name|entry_point
operator|>=
name|lowpc
operator|&&
name|objfile
operator|->
name|ei
operator|.
name|entry_point
operator|<
name|highpc
condition|)
block|{
name|objfile
operator|->
name|ei
operator|.
name|entry_func_lowpc
operator|=
name|lowpc
expr_stmt|;
name|objfile
operator|->
name|ei
operator|.
name|entry_func_highpc
operator|=
name|highpc
expr_stmt|;
block|}
if|if
condition|(
name|STREQ
argument_list|(
name|name
argument_list|,
literal|"main"
argument_list|)
condition|)
comment|/* FIXME: hardwired name */
block|{
name|objfile
operator|->
name|ei
operator|.
name|main_func_lowpc
operator|=
name|lowpc
expr_stmt|;
name|objfile
operator|->
name|ei
operator|.
name|main_func_highpc
operator|=
name|highpc
expr_stmt|;
block|}
comment|/* Decode DW_AT_frame_base location descriptor if present, keep result      for DW_OP_fbreg operands in decode_locdesc.  */
name|frame_base_reg
operator|=
operator|-
literal|1
expr_stmt|;
name|frame_base_offset
operator|=
literal|0
expr_stmt|;
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_frame_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|CORE_ADDR
name|addr
init|=
name|decode_locdesc
argument_list|(
name|DW_BLOCK
argument_list|(
name|attr
argument_list|)
argument_list|,
name|objfile
argument_list|)
decl_stmt|;
if|if
condition|(
name|isreg
condition|)
name|frame_base_reg
operator|=
name|addr
expr_stmt|;
elseif|else
if|if
condition|(
name|offreg
condition|)
block|{
name|frame_base_reg
operator|=
name|basereg
expr_stmt|;
name|frame_base_offset
operator|=
name|addr
expr_stmt|;
block|}
else|else
name|complain
argument_list|(
operator|&
name|dwarf2_unsupported_at_frame_base
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|new
operator|=
name|push_context
argument_list|(
literal|0
argument_list|,
name|lowpc
argument_list|)
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|new_symbol
argument_list|(
name|die
argument_list|,
name|die
operator|->
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|list_in_scope
operator|=
operator|&
name|local_symbols
expr_stmt|;
if|if
condition|(
name|die
operator|->
name|has_children
condition|)
block|{
name|child_die
operator|=
name|die
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|child_die
operator|&&
name|child_die
operator|->
name|tag
condition|)
block|{
name|process_die
argument_list|(
name|child_die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|child_die
operator|=
name|sibling_die
argument_list|(
name|child_die
argument_list|)
expr_stmt|;
block|}
block|}
name|new
operator|=
name|pop_context
argument_list|()
expr_stmt|;
comment|/* Make a block for the local symbols within.  */
name|finish_block
argument_list|(
name|new
operator|->
name|name
argument_list|,
operator|&
name|local_symbols
argument_list|,
name|new
operator|->
name|old_blocks
argument_list|,
name|lowpc
argument_list|,
name|highpc
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|list_in_scope
operator|=
operator|&
name|file_symbols
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Process all the DIES contained within a lexical block scope.  Start    a new scope, process the dies, and then close the scope.  */
end_comment

begin_function
specifier|static
name|void
name|read_lexical_block_scope
parameter_list|(
name|die
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|die_info
modifier|*
name|die
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
specifier|register
name|struct
name|context_stack
modifier|*
name|new
decl_stmt|;
name|CORE_ADDR
name|lowpc
decl_stmt|,
name|highpc
decl_stmt|;
name|struct
name|die_info
modifier|*
name|child_die
decl_stmt|;
comment|/* Ignore blocks with missing or invalid low and high pc attributes.  */
if|if
condition|(
operator|!
name|dwarf2_get_pc_bounds
argument_list|(
name|die
argument_list|,
operator|&
name|lowpc
argument_list|,
operator|&
name|highpc
argument_list|,
name|objfile
argument_list|)
condition|)
return|return;
name|lowpc
operator|+=
name|baseaddr
expr_stmt|;
name|highpc
operator|+=
name|baseaddr
expr_stmt|;
name|push_context
argument_list|(
literal|0
argument_list|,
name|lowpc
argument_list|)
expr_stmt|;
if|if
condition|(
name|die
operator|->
name|has_children
condition|)
block|{
name|child_die
operator|=
name|die
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|child_die
operator|&&
name|child_die
operator|->
name|tag
condition|)
block|{
name|process_die
argument_list|(
name|child_die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|child_die
operator|=
name|sibling_die
argument_list|(
name|child_die
argument_list|)
expr_stmt|;
block|}
block|}
name|new
operator|=
name|pop_context
argument_list|()
expr_stmt|;
if|if
condition|(
name|local_symbols
operator|!=
name|NULL
condition|)
block|{
name|finish_block
argument_list|(
literal|0
argument_list|,
operator|&
name|local_symbols
argument_list|,
name|new
operator|->
name|old_blocks
argument_list|,
name|new
operator|->
name|start_addr
argument_list|,
name|highpc
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
name|local_symbols
operator|=
name|new
operator|->
name|locals
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Get low and high pc attributes from a die.    Return 1 if the attributes are present and valid, otherwise, return 0.  */
end_comment

begin_function
specifier|static
name|int
name|dwarf2_get_pc_bounds
parameter_list|(
name|die
parameter_list|,
name|lowpc
parameter_list|,
name|highpc
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|die_info
modifier|*
name|die
decl_stmt|;
name|CORE_ADDR
modifier|*
name|lowpc
decl_stmt|;
name|CORE_ADDR
modifier|*
name|highpc
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|attribute
modifier|*
name|attr
decl_stmt|;
name|CORE_ADDR
name|low
decl_stmt|;
name|CORE_ADDR
name|high
decl_stmt|;
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_low_pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
name|low
operator|=
name|DW_ADDR
argument_list|(
name|attr
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_high_pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
name|high
operator|=
name|DW_ADDR
argument_list|(
name|attr
argument_list|)
expr_stmt|;
else|else
return|return
literal|0
return|;
if|if
condition|(
name|high
operator|<
name|low
condition|)
return|return
literal|0
return|;
comment|/* When using the GNU linker, .gnu.linkonce. sections are used to      eliminate duplicate copies of functions and vtables and such.      The linker will arbitrarily choose one and discard the others.      The AT_*_pc values for such functions refer to local labels in      these sections.  If the section from that file was discarded, the      labels are not in the output, so the relocs get a value of 0.      If this is a discarded function, mark the pc bounds as invalid,      so that GDB will ignore it.  */
if|if
condition|(
name|low
operator|==
literal|0
operator|&&
operator|(
name|bfd_get_file_flags
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|)
operator|&
name|HAS_RELOC
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
operator|*
name|lowpc
operator|=
name|low
expr_stmt|;
operator|*
name|highpc
operator|=
name|high
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Add an aggregate field to the field list.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2_add_field
parameter_list|(
name|fip
parameter_list|,
name|die
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|field_info
modifier|*
name|fip
decl_stmt|;
name|struct
name|die_info
modifier|*
name|die
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|nextfield
modifier|*
name|new_field
decl_stmt|;
name|struct
name|attribute
modifier|*
name|attr
decl_stmt|;
name|struct
name|field
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|fieldname
init|=
literal|""
decl_stmt|;
comment|/* Allocate a new field list entry and link it in.  */
name|new_field
operator|=
operator|(
expr|struct
name|nextfield
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|new_field
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new_field
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|new_field
operator|->
name|next
operator|=
name|fip
operator|->
name|fields
expr_stmt|;
name|fip
operator|->
name|fields
operator|=
name|new_field
expr_stmt|;
name|fip
operator|->
name|nfields
operator|++
expr_stmt|;
comment|/* Handle accessibility and virtuality of field.      The default accessibility for members is public, the default      accessibility for inheritance is private.  */
if|if
condition|(
name|die
operator|->
name|tag
operator|!=
name|DW_TAG_inheritance
condition|)
name|new_field
operator|->
name|accessibility
operator|=
name|DW_ACCESS_public
expr_stmt|;
else|else
name|new_field
operator|->
name|accessibility
operator|=
name|DW_ACCESS_private
expr_stmt|;
name|new_field
operator|->
name|virtuality
operator|=
name|DW_VIRTUALITY_none
expr_stmt|;
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_accessibility
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
name|new_field
operator|->
name|accessibility
operator|=
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_field
operator|->
name|accessibility
operator|!=
name|DW_ACCESS_public
condition|)
name|fip
operator|->
name|non_public_fields
operator|=
literal|1
expr_stmt|;
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_virtuality
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
name|new_field
operator|->
name|virtuality
operator|=
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|fp
operator|=
operator|&
name|new_field
operator|->
name|field
expr_stmt|;
if|if
condition|(
name|die
operator|->
name|tag
operator|==
name|DW_TAG_member
condition|)
block|{
comment|/* Get type of field.  */
name|fp
operator|->
name|type
operator|=
name|die_type
argument_list|(
name|die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Get bit size of field (zero if none).  */
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_bit_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|FIELD_BITSIZE
argument_list|(
operator|*
name|fp
argument_list|)
operator|=
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FIELD_BITSIZE
argument_list|(
operator|*
name|fp
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Get bit offset of field.  */
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_data_member_location
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|FIELD_BITPOS
argument_list|(
operator|*
name|fp
argument_list|)
operator|=
name|decode_locdesc
argument_list|(
name|DW_BLOCK
argument_list|(
name|attr
argument_list|)
argument_list|,
name|objfile
argument_list|)
operator|*
name|bits_per_byte
expr_stmt|;
block|}
else|else
name|FIELD_BITPOS
argument_list|(
operator|*
name|fp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_bit_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
if|if
condition|(
name|BITS_BIG_ENDIAN
condition|)
block|{
comment|/* For big endian bits, the DW_AT_bit_offset gives the 		 additional bit offset from the MSB of the containing 		 anonymous object to the MSB of the field.  We don't 		 have to do anything special since we don't need to 		 know the size of the anonymous object.  */
name|FIELD_BITPOS
argument_list|(
operator|*
name|fp
argument_list|)
operator|+=
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* For little endian bits, compute the bit offset to the 		 MSB of the anonymous object, subtract off the number of 		 bits from the MSB of the field to the MSB of the 		 object, and then subtract off the number of bits of 		 the field itself.  The result is the bit offset of 		 the LSB of the field.  */
name|int
name|anonymous_size
decl_stmt|;
name|int
name|bit_offset
init|=
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
decl_stmt|;
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_byte_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
comment|/* The size of the anonymous object containing 		     the bit field is explicit, so use the 		     indicated size (in bytes).  */
name|anonymous_size
operator|=
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The size of the anonymous object containing 		     the bit field must be inferred from the type 		     attribute of the data member containing the 		     bit field.  */
name|anonymous_size
operator|=
name|TYPE_LENGTH
argument_list|(
name|fp
operator|->
name|type
argument_list|)
expr_stmt|;
block|}
name|FIELD_BITPOS
argument_list|(
operator|*
name|fp
argument_list|)
operator|+=
name|anonymous_size
operator|*
name|bits_per_byte
operator|-
name|bit_offset
operator|-
name|FIELD_BITSIZE
argument_list|(
operator|*
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Get name of field.  */
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|&&
name|DW_STRING
argument_list|(
name|attr
argument_list|)
condition|)
name|fieldname
operator|=
name|DW_STRING
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|fp
operator|->
name|name
operator|=
name|obsavestring
argument_list|(
name|fieldname
argument_list|,
name|strlen
argument_list|(
name|fieldname
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|)
expr_stmt|;
comment|/* Change accessibility for artificial fields (e.g. virtual table 	 pointer or virtual base class pointer) to private.  */
if|if
condition|(
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_artificial
argument_list|)
condition|)
block|{
name|new_field
operator|->
name|accessibility
operator|=
name|DW_ACCESS_private
expr_stmt|;
name|fip
operator|->
name|non_public_fields
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|die
operator|->
name|tag
operator|==
name|DW_TAG_variable
condition|)
block|{
name|char
modifier|*
name|physname
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* C++ static member. 	 Get physical name, extract field name from physical name.  */
name|physname
operator|=
name|dwarf2_linkage_name
argument_list|(
name|die
argument_list|)
expr_stmt|;
if|if
condition|(
name|physname
operator|==
name|NULL
condition|)
return|return;
name|cp
operator|=
name|physname
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|&&
operator|!
name|is_cplus_marker
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
condition|)
name|fieldname
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|fieldname
operator|==
literal|'\0'
condition|)
block|{
name|complain
argument_list|(
operator|&
name|dwarf2_bad_static_member_name
argument_list|,
name|physname
argument_list|)
expr_stmt|;
block|}
name|SET_FIELD_PHYSNAME
argument_list|(
operator|*
name|fp
argument_list|,
name|obsavestring
argument_list|(
name|physname
argument_list|,
name|strlen
argument_list|(
name|physname
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|)
argument_list|)
expr_stmt|;
name|FIELD_TYPE
argument_list|(
operator|*
name|fp
argument_list|)
operator|=
name|die_type
argument_list|(
name|die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|FIELD_NAME
argument_list|(
operator|*
name|fp
argument_list|)
operator|=
name|obsavestring
argument_list|(
name|fieldname
argument_list|,
name|strlen
argument_list|(
name|fieldname
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|die
operator|->
name|tag
operator|==
name|DW_TAG_inheritance
condition|)
block|{
comment|/* C++ base class field.  */
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_data_member_location
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
name|FIELD_BITPOS
argument_list|(
operator|*
name|fp
argument_list|)
operator|=
name|decode_locdesc
argument_list|(
name|DW_BLOCK
argument_list|(
name|attr
argument_list|)
argument_list|,
name|objfile
argument_list|)
operator|*
name|bits_per_byte
expr_stmt|;
name|FIELD_BITSIZE
argument_list|(
operator|*
name|fp
argument_list|)
operator|=
literal|0
expr_stmt|;
name|FIELD_TYPE
argument_list|(
operator|*
name|fp
argument_list|)
operator|=
name|die_type
argument_list|(
name|die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|FIELD_NAME
argument_list|(
operator|*
name|fp
argument_list|)
operator|=
name|type_name_no_tag
argument_list|(
name|fp
operator|->
name|type
argument_list|)
expr_stmt|;
name|fip
operator|->
name|nbaseclasses
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Create the vector of fields, and attach it to the type.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2_attach_fields_to_type
parameter_list|(
name|fip
parameter_list|,
name|type
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|field_info
modifier|*
name|fip
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|int
name|nfields
init|=
name|fip
operator|->
name|nfields
decl_stmt|;
comment|/* Record the field count, allocate space for the array of fields,      and create blank accessibility bitfields if necessary.  */
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|nfields
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|nfields
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|nfields
argument_list|)
expr_stmt|;
if|if
condition|(
name|fip
operator|->
name|non_public_fields
condition|)
block|{
name|ALLOCATE_CPLUS_STRUCT_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_FIELD_PRIVATE_BITS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|B_TYPE
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
name|B_BYTES
argument_list|(
name|nfields
argument_list|)
argument_list|)
expr_stmt|;
name|B_CLRALL
argument_list|(
name|TYPE_FIELD_PRIVATE_BITS
argument_list|(
name|type
argument_list|)
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
name|TYPE_FIELD_PROTECTED_BITS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|B_TYPE
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
name|B_BYTES
argument_list|(
name|nfields
argument_list|)
argument_list|)
expr_stmt|;
name|B_CLRALL
argument_list|(
name|TYPE_FIELD_PROTECTED_BITS
argument_list|(
name|type
argument_list|)
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
name|TYPE_FIELD_IGNORE_BITS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|B_TYPE
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
name|B_BYTES
argument_list|(
name|nfields
argument_list|)
argument_list|)
expr_stmt|;
name|B_CLRALL
argument_list|(
name|TYPE_FIELD_IGNORE_BITS
argument_list|(
name|type
argument_list|)
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
block|}
comment|/* If the type has baseclasses, allocate and clear a bit vector for      TYPE_FIELD_VIRTUAL_BITS.  */
if|if
condition|(
name|fip
operator|->
name|nbaseclasses
condition|)
block|{
name|int
name|num_bytes
init|=
name|B_BYTES
argument_list|(
name|fip
operator|->
name|nbaseclasses
argument_list|)
decl_stmt|;
name|char
modifier|*
name|pointer
decl_stmt|;
name|ALLOCATE_CPLUS_STRUCT_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|pointer
operator|=
operator|(
name|char
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
name|num_bytes
argument_list|)
expr_stmt|;
name|TYPE_FIELD_VIRTUAL_BITS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
name|B_TYPE
operator|*
operator|)
name|pointer
expr_stmt|;
name|B_CLRALL
argument_list|(
name|TYPE_FIELD_VIRTUAL_BITS
argument_list|(
name|type
argument_list|)
argument_list|,
name|fip
operator|->
name|nbaseclasses
argument_list|)
expr_stmt|;
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
operator|=
name|fip
operator|->
name|nbaseclasses
expr_stmt|;
block|}
comment|/* Copy the saved-up fields into the field vector.  Start from the head      of the list, adding to the tail of the field array, so that they end      up in the same order in the array in which they were added to the list.  */
while|while
condition|(
name|nfields
operator|--
operator|>
literal|0
condition|)
block|{
name|TYPE_FIELD
argument_list|(
name|type
argument_list|,
name|nfields
argument_list|)
operator|=
name|fip
operator|->
name|fields
operator|->
name|field
expr_stmt|;
switch|switch
condition|(
name|fip
operator|->
name|fields
operator|->
name|accessibility
condition|)
block|{
case|case
name|DW_ACCESS_private
case|:
name|SET_TYPE_FIELD_PRIVATE
argument_list|(
name|type
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_ACCESS_protected
case|:
name|SET_TYPE_FIELD_PROTECTED
argument_list|(
name|type
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_ACCESS_public
case|:
break|break;
default|default:
comment|/* Unknown accessibility.  Complain and treat it as public.  */
block|{
name|complain
argument_list|(
operator|&
name|dwarf2_unsupported_accessibility
argument_list|,
name|fip
operator|->
name|fields
operator|->
name|accessibility
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|nfields
operator|<
name|fip
operator|->
name|nbaseclasses
condition|)
block|{
switch|switch
condition|(
name|fip
operator|->
name|fields
operator|->
name|virtuality
condition|)
block|{
case|case
name|DW_VIRTUALITY_virtual
case|:
case|case
name|DW_VIRTUALITY_pure_virtual
case|:
name|SET_TYPE_FIELD_VIRTUAL
argument_list|(
name|type
argument_list|,
name|nfields
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|fip
operator|->
name|fields
operator|=
name|fip
operator|->
name|fields
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Skip to the end of a member function name in a mangled name.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|skip_member_fn_name
parameter_list|(
name|physname
parameter_list|)
name|char
modifier|*
name|physname
decl_stmt|;
block|{
name|char
modifier|*
name|endname
init|=
name|physname
decl_stmt|;
comment|/* Skip over leading underscores.  */
while|while
condition|(
operator|*
name|endname
operator|==
literal|'_'
condition|)
name|endname
operator|++
expr_stmt|;
comment|/* Find two succesive underscores.  */
do|do
name|endname
operator|=
name|strchr
argument_list|(
name|endname
argument_list|,
literal|'_'
argument_list|)
expr_stmt|;
do|while
condition|(
name|endname
operator|!=
name|NULL
operator|&&
operator|*
operator|++
name|endname
operator|!=
literal|'_'
condition|)
do|;
if|if
condition|(
name|endname
operator|==
name|NULL
condition|)
block|{
name|complain
argument_list|(
operator|&
name|dwarf2_bad_member_name_complaint
argument_list|,
name|physname
argument_list|)
expr_stmt|;
name|endname
operator|=
name|physname
expr_stmt|;
block|}
else|else
block|{
comment|/* Take care of trailing underscores.  */
if|if
condition|(
name|endname
index|[
literal|1
index|]
operator|!=
literal|'_'
condition|)
name|endname
operator|--
expr_stmt|;
block|}
return|return
name|endname
return|;
block|}
end_function

begin_comment
comment|/* Add a member function to the proper fieldlist.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2_add_member_fn
parameter_list|(
name|fip
parameter_list|,
name|die
parameter_list|,
name|type
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|field_info
modifier|*
name|fip
decl_stmt|;
name|struct
name|die_info
modifier|*
name|die
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|attribute
modifier|*
name|attr
decl_stmt|;
name|struct
name|fnfieldlist
modifier|*
name|flp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|fn_field
modifier|*
name|fnp
decl_stmt|;
name|char
modifier|*
name|fieldname
decl_stmt|;
name|char
modifier|*
name|physname
decl_stmt|;
name|struct
name|nextfnfield
modifier|*
name|new_fnfield
decl_stmt|;
comment|/* Extract member function name from mangled name.  */
name|physname
operator|=
name|dwarf2_linkage_name
argument_list|(
name|die
argument_list|)
expr_stmt|;
if|if
condition|(
name|physname
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|(
name|physname
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|physname
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|strchr
argument_list|(
literal|"0123456789Qt"
argument_list|,
name|physname
index|[
literal|2
index|]
argument_list|)
operator|)
operator|||
name|DESTRUCTOR_PREFIX_P
argument_list|(
name|physname
argument_list|)
condition|)
block|{
comment|/* Constructor and destructor field names are set to the name 	 of the class, but without template parameter lists. 	 The name might be missing for anonymous aggregates.  */
if|if
condition|(
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|strchr
argument_list|(
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
literal|'<'
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|fieldname
operator|=
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
else|else
name|fieldname
operator|=
name|obsavestring
argument_list|(
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
name|p
operator|-
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|anon_name
init|=
literal|""
decl_stmt|;
name|fieldname
operator|=
name|obsavestring
argument_list|(
name|anon_name
argument_list|,
name|strlen
argument_list|(
name|anon_name
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|char
modifier|*
name|endname
init|=
name|skip_member_fn_name
argument_list|(
name|physname
argument_list|)
decl_stmt|;
comment|/* Ignore member function if we were unable not extract the member 	 function name.  */
if|if
condition|(
name|endname
operator|==
name|physname
condition|)
return|return;
name|fieldname
operator|=
name|obsavestring
argument_list|(
name|physname
argument_list|,
name|endname
operator|-
name|physname
argument_list|,
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|)
expr_stmt|;
block|}
comment|/* Look up member function name in fieldlist.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fip
operator|->
name|nfnfields
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|fip
operator|->
name|fnfieldlists
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|fieldname
argument_list|)
condition|)
break|break;
block|}
comment|/* Create new list element if necessary.  */
if|if
condition|(
name|i
operator|<
name|fip
operator|->
name|nfnfields
condition|)
name|flp
operator|=
operator|&
name|fip
operator|->
name|fnfieldlists
index|[
name|i
index|]
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|fip
operator|->
name|nfnfields
operator|%
name|DW_FIELD_ALLOC_CHUNK
operator|)
operator|==
literal|0
condition|)
block|{
name|fip
operator|->
name|fnfieldlists
operator|=
operator|(
expr|struct
name|fnfieldlist
operator|*
operator|)
name|xrealloc
argument_list|(
name|fip
operator|->
name|fnfieldlists
argument_list|,
operator|(
name|fip
operator|->
name|nfnfields
operator|+
name|DW_FIELD_ALLOC_CHUNK
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fnfieldlist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fip
operator|->
name|nfnfields
operator|==
literal|0
condition|)
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_current_contents
argument_list|,
operator|&
name|fip
operator|->
name|fnfieldlists
argument_list|)
expr_stmt|;
block|}
name|flp
operator|=
operator|&
name|fip
operator|->
name|fnfieldlists
index|[
name|fip
operator|->
name|nfnfields
index|]
expr_stmt|;
name|flp
operator|->
name|name
operator|=
name|fieldname
expr_stmt|;
name|flp
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|flp
operator|->
name|head
operator|=
name|NULL
expr_stmt|;
name|fip
operator|->
name|nfnfields
operator|++
expr_stmt|;
block|}
comment|/* Create a new member function field and chain it to the field list      entry. */
name|new_fnfield
operator|=
operator|(
expr|struct
name|nextfnfield
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nextfnfield
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|new_fnfield
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new_fnfield
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|nextfnfield
argument_list|)
argument_list|)
expr_stmt|;
name|new_fnfield
operator|->
name|next
operator|=
name|flp
operator|->
name|head
expr_stmt|;
name|flp
operator|->
name|head
operator|=
name|new_fnfield
expr_stmt|;
name|flp
operator|->
name|length
operator|++
expr_stmt|;
comment|/* Fill in the member function field info.  */
name|fnp
operator|=
operator|&
name|new_fnfield
operator|->
name|fnfield
expr_stmt|;
name|fnp
operator|->
name|physname
operator|=
name|obsavestring
argument_list|(
name|physname
argument_list|,
name|strlen
argument_list|(
name|physname
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|)
expr_stmt|;
name|fnp
operator|->
name|type
operator|=
name|alloc_type
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|die
operator|->
name|type
operator|&&
name|TYPE_CODE
argument_list|(
name|die
operator|->
name|type
argument_list|)
operator|==
name|TYPE_CODE_FUNC
condition|)
block|{
name|struct
name|type
modifier|*
name|return_type
init|=
name|TYPE_TARGET_TYPE
argument_list|(
name|die
operator|->
name|type
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
modifier|*
name|arg_types
decl_stmt|;
name|int
name|nparams
init|=
name|TYPE_NFIELDS
argument_list|(
name|die
operator|->
name|type
argument_list|)
decl_stmt|;
name|int
name|iparams
decl_stmt|;
comment|/* Copy argument types from the subroutine type.  */
name|arg_types
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|fnp
operator|->
name|type
argument_list|,
operator|(
name|nparams
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|iparams
operator|=
literal|0
init|;
name|iparams
operator|<
name|nparams
condition|;
name|iparams
operator|++
control|)
name|arg_types
index|[
name|iparams
index|]
operator|=
name|TYPE_FIELD_TYPE
argument_list|(
name|die
operator|->
name|type
argument_list|,
name|iparams
argument_list|)
expr_stmt|;
comment|/* Set last entry in argument type vector.  */
if|if
condition|(
name|TYPE_FLAGS
argument_list|(
name|die
operator|->
name|type
argument_list|)
operator|&
name|TYPE_FLAG_VARARGS
condition|)
name|arg_types
index|[
name|nparams
index|]
operator|=
name|NULL
expr_stmt|;
else|else
name|arg_types
index|[
name|nparams
index|]
operator|=
name|dwarf2_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_VOID
argument_list|)
expr_stmt|;
name|smash_to_method_type
argument_list|(
name|fnp
operator|->
name|type
argument_list|,
name|type
argument_list|,
name|return_type
argument_list|,
name|arg_types
argument_list|)
expr_stmt|;
comment|/* Handle static member functions. 	 Dwarf2 has no clean way to discern C++ static and non-static 	 member functions. G++ helps GDB by marking the first 	 parameter for non-static member functions (which is the 	 this pointer) as artificial. We obtain this information 	 from read_subroutine_type via TYPE_FIELD_ARTIFICIAL.  */
if|if
condition|(
name|nparams
operator|==
literal|0
operator|||
name|TYPE_FIELD_ARTIFICIAL
argument_list|(
name|die
operator|->
name|type
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
name|fnp
operator|->
name|voffset
operator|=
name|VOFFSET_STATIC
expr_stmt|;
block|}
else|else
name|complain
argument_list|(
operator|&
name|dwarf2_missing_member_fn_type_complaint
argument_list|,
name|physname
argument_list|)
expr_stmt|;
comment|/* Get fcontext from DW_AT_containing_type if present.  */
if|if
condition|(
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_containing_type
argument_list|)
operator|!=
name|NULL
condition|)
name|fnp
operator|->
name|fcontext
operator|=
name|die_containing_type
argument_list|(
name|die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* dwarf2 doesn't have stubbed physical names, so the setting of is_const      and is_volatile is irrelevant, as it is needed by gdb_mangle_name only.  */
comment|/* Get accessibility.  */
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_accessibility
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
switch|switch
condition|(
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
condition|)
block|{
case|case
name|DW_ACCESS_private
case|:
name|fnp
operator|->
name|is_private
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_ACCESS_protected
case|:
name|fnp
operator|->
name|is_protected
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* Get index in virtual function table if it is a virtual member function.  */
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_vtable_elem_location
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
name|fnp
operator|->
name|voffset
operator|=
name|decode_locdesc
argument_list|(
name|DW_BLOCK
argument_list|(
name|attr
argument_list|)
argument_list|,
name|objfile
argument_list|)
operator|+
literal|2
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create the vector of member function fields, and attach it to the type.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2_attach_fn_fields_to_type
parameter_list|(
name|fip
parameter_list|,
name|type
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|field_info
modifier|*
name|fip
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|fnfieldlist
modifier|*
name|flp
decl_stmt|;
name|int
name|total_length
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ALLOCATE_CPLUS_STRUCT_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TYPE_FN_FIELDLISTS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|fn_fieldlist
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fn_fieldlist
argument_list|)
operator|*
name|fip
operator|->
name|nfnfields
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|flp
operator|=
name|fip
operator|->
name|fnfieldlists
init|;
name|i
operator|<
name|fip
operator|->
name|nfnfields
condition|;
name|i
operator|++
operator|,
name|flp
operator|++
control|)
block|{
name|struct
name|nextfnfield
modifier|*
name|nfp
init|=
name|flp
operator|->
name|head
decl_stmt|;
name|struct
name|fn_fieldlist
modifier|*
name|fn_flp
init|=
operator|&
name|TYPE_FN_FIELDLIST
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|k
decl_stmt|;
name|TYPE_FN_FIELDLIST_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|=
name|flp
operator|->
name|name
expr_stmt|;
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|=
name|flp
operator|->
name|length
expr_stmt|;
name|fn_flp
operator|->
name|fn_fields
operator|=
operator|(
expr|struct
name|fn_field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fn_field
argument_list|)
operator|*
name|flp
operator|->
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
name|flp
operator|->
name|length
init|;
operator|(
name|k
operator|--
operator|,
name|nfp
operator|)
condition|;
name|nfp
operator|=
name|nfp
operator|->
name|next
control|)
name|fn_flp
operator|->
name|fn_fields
index|[
name|k
index|]
operator|=
name|nfp
operator|->
name|fnfield
expr_stmt|;
name|total_length
operator|+=
name|flp
operator|->
name|length
expr_stmt|;
block|}
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|fip
operator|->
name|nfnfields
expr_stmt|;
name|TYPE_NFN_FIELDS_TOTAL
argument_list|(
name|type
argument_list|)
operator|=
name|total_length
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Called when we find the DIE that starts a structure or union scope    (definition) to process all dies that define the members of the    structure or union.     NOTE: we need to call struct_type regardless of whether or not the    DIE has an at_name attribute, since it might be an anonymous    structure or union.  This gets the type entered into our set of    user defined types.     However, if the structure is incomplete (an opaque struct/union)    then suppress creating a symbol table entry for it since gdb only    wants to find the one with the complete definition.  Note that if    it is complete, we just call new_symbol, which does it's own    checking about whether the struct/union is anonymous or not (and    suppresses creating a symbol table entry itself).  */
end_comment

begin_function
specifier|static
name|void
name|read_structure_scope
parameter_list|(
name|die
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|die_info
modifier|*
name|die
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|attribute
modifier|*
name|attr
decl_stmt|;
name|type
operator|=
name|alloc_type
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|INIT_CPLUS_SPECIFIC
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|&&
name|DW_STRING
argument_list|(
name|attr
argument_list|)
condition|)
block|{
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|obsavestring
argument_list|(
name|DW_STRING
argument_list|(
name|attr
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|DW_STRING
argument_list|(
name|attr
argument_list|)
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|die
operator|->
name|tag
operator|==
name|DW_TAG_structure_type
condition|)
block|{
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_STRUCT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|die
operator|->
name|tag
operator|==
name|DW_TAG_union_type
condition|)
block|{
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_UNION
expr_stmt|;
block|}
else|else
block|{
comment|/* FIXME: TYPE_CODE_CLASS is currently defined to TYPE_CODE_STRUCT 	 in gdbtypes.h.  */
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_CLASS
expr_stmt|;
block|}
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_byte_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
comment|/* We need to add the type field to the die immediately so we don't      infinitely recurse when dealing with pointers to the structure      type within the structure itself. */
name|die
operator|->
name|type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|die
operator|->
name|has_children
condition|)
block|{
name|struct
name|field_info
name|fi
decl_stmt|;
name|struct
name|die_info
modifier|*
name|child_die
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
init|=
name|make_cleanup
argument_list|(
name|null_cleanup
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|memset
argument_list|(
operator|&
name|fi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field_info
argument_list|)
argument_list|)
expr_stmt|;
name|child_die
operator|=
name|die
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|child_die
operator|&&
name|child_die
operator|->
name|tag
condition|)
block|{
if|if
condition|(
name|child_die
operator|->
name|tag
operator|==
name|DW_TAG_member
condition|)
block|{
name|dwarf2_add_field
argument_list|(
operator|&
name|fi
argument_list|,
name|child_die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|child_die
operator|->
name|tag
operator|==
name|DW_TAG_variable
condition|)
block|{
comment|/* C++ static member.  */
name|dwarf2_add_field
argument_list|(
operator|&
name|fi
argument_list|,
name|child_die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|child_die
operator|->
name|tag
operator|==
name|DW_TAG_subprogram
condition|)
block|{
comment|/* C++ member function. */
name|process_die
argument_list|(
name|child_die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|dwarf2_add_member_fn
argument_list|(
operator|&
name|fi
argument_list|,
name|child_die
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|child_die
operator|->
name|tag
operator|==
name|DW_TAG_inheritance
condition|)
block|{
comment|/* C++ base class field.  */
name|dwarf2_add_field
argument_list|(
operator|&
name|fi
argument_list|,
name|child_die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|process_die
argument_list|(
name|child_die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
name|child_die
operator|=
name|sibling_die
argument_list|(
name|child_die
argument_list|)
expr_stmt|;
block|}
comment|/* Attach fields and member functions to the type.  */
if|if
condition|(
name|fi
operator|.
name|nfields
condition|)
name|dwarf2_attach_fields_to_type
argument_list|(
operator|&
name|fi
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|fi
operator|.
name|nfnfields
condition|)
block|{
name|dwarf2_attach_fn_fields_to_type
argument_list|(
operator|&
name|fi
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Get the type which refers to the base class (possibly this 	     class itself) which contains the vtable pointer for the current 	     class from the DW_AT_containing_type attribute.  */
if|if
condition|(
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_containing_type
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|type
modifier|*
name|t
init|=
name|die_containing_type
argument_list|(
name|die
argument_list|,
name|objfile
argument_list|)
decl_stmt|;
name|TYPE_VPTR_BASETYPE
argument_list|(
name|type
argument_list|)
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|t
condition|)
block|{
specifier|static
specifier|const
name|char
name|vptr_name
index|[]
init|=
block|{
literal|'_'
block|,
literal|'v'
block|,
literal|'p'
block|,
literal|'t'
block|,
literal|'r'
block|,
literal|'\0'
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Our own class provides vtbl ptr.  */
for|for
control|(
name|i
operator|=
name|TYPE_NFIELDS
argument_list|(
name|t
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
name|TYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
condition|;
operator|--
name|i
control|)
block|{
name|char
modifier|*
name|fieldname
init|=
name|TYPE_FIELD_NAME
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|STREQN
argument_list|(
name|fieldname
argument_list|,
name|vptr_name
argument_list|,
name|strlen
argument_list|(
name|vptr_name
argument_list|)
operator|-
literal|1
argument_list|)
operator|&&
name|is_cplus_marker
argument_list|(
name|fieldname
index|[
name|strlen
argument_list|(
name|vptr_name
argument_list|)
index|]
argument_list|)
condition|)
block|{
name|TYPE_VPTR_FIELDNO
argument_list|(
name|type
argument_list|)
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
comment|/* Complain if virtual function table field not found.  */
if|if
condition|(
name|i
operator|<
name|TYPE_N_BASECLASSES
argument_list|(
name|t
argument_list|)
condition|)
name|complain
argument_list|(
operator|&
name|dwarf2_vtbl_not_found_complaint
argument_list|,
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
condition|?
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TYPE_VPTR_FIELDNO
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_VPTR_FIELDNO
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|new_symbol
argument_list|(
name|die
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No children, must be stub. */
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator||=
name|TYPE_FLAG_STUB
expr_stmt|;
block|}
name|die
operator|->
name|type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a pointer to a die which begins an enumeration, process all    the dies that define the members of the enumeration.     This will be much nicer in draft 6 of the DWARF spec when our    members will be dies instead squished into the DW_AT_element_list    attribute.     NOTE: We reverse the order of the element list.  */
end_comment

begin_function
specifier|static
name|void
name|read_enumeration
parameter_list|(
name|die
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|die_info
modifier|*
name|die
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|die_info
modifier|*
name|child_die
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|field
modifier|*
name|fields
decl_stmt|;
name|struct
name|attribute
modifier|*
name|attr
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|int
name|num_fields
decl_stmt|;
name|int
name|unsigned_enum
init|=
literal|1
decl_stmt|;
name|type
operator|=
name|alloc_type
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_ENUM
expr_stmt|;
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|&&
name|DW_STRING
argument_list|(
name|attr
argument_list|)
condition|)
block|{
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|obsavestring
argument_list|(
name|DW_STRING
argument_list|(
name|attr
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|DW_STRING
argument_list|(
name|attr
argument_list|)
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|)
expr_stmt|;
block|}
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_byte_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
name|num_fields
operator|=
literal|0
expr_stmt|;
name|fields
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|die
operator|->
name|has_children
condition|)
block|{
name|child_die
operator|=
name|die
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|child_die
operator|&&
name|child_die
operator|->
name|tag
condition|)
block|{
if|if
condition|(
name|child_die
operator|->
name|tag
operator|!=
name|DW_TAG_enumerator
condition|)
block|{
name|process_die
argument_list|(
name|child_die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|child_die
argument_list|,
name|DW_AT_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|sym
operator|=
name|new_symbol
argument_list|(
name|child_die
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|<
literal|0
condition|)
name|unsigned_enum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|num_fields
operator|%
name|DW_FIELD_ALLOC_CHUNK
operator|)
operator|==
literal|0
condition|)
block|{
name|fields
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|xrealloc
argument_list|(
name|fields
argument_list|,
operator|(
name|num_fields
operator|+
name|DW_FIELD_ALLOC_CHUNK
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|FIELD_NAME
argument_list|(
name|fields
index|[
name|num_fields
index|]
argument_list|)
operator|=
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|FIELD_TYPE
argument_list|(
name|fields
index|[
name|num_fields
index|]
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|FIELD_BITPOS
argument_list|(
name|fields
index|[
name|num_fields
index|]
argument_list|)
operator|=
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
name|FIELD_BITSIZE
argument_list|(
name|fields
index|[
name|num_fields
index|]
argument_list|)
operator|=
literal|0
expr_stmt|;
name|num_fields
operator|++
expr_stmt|;
block|}
block|}
name|child_die
operator|=
name|sibling_die
argument_list|(
name|child_die
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|num_fields
condition|)
block|{
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|num_fields
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|num_fields
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
argument_list|,
name|fields
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|num_fields
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fields
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unsigned_enum
condition|)
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator||=
name|TYPE_FLAG_UNSIGNED
expr_stmt|;
block|}
name|die
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|new_symbol
argument_list|(
name|die
argument_list|,
name|type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Extract all information from a DW_TAG_array_type DIE and put it in    the DIE's type field.  For now, this only handles one dimensional    arrays.  */
end_comment

begin_function
specifier|static
name|void
name|read_array_type
parameter_list|(
name|die
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|die_info
modifier|*
name|die
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|die_info
modifier|*
name|child_die
decl_stmt|;
name|struct
name|type
modifier|*
name|type
init|=
name|NULL
decl_stmt|;
name|struct
name|type
modifier|*
name|element_type
decl_stmt|,
modifier|*
name|range_type
decl_stmt|,
modifier|*
name|index_type
decl_stmt|;
name|struct
name|type
modifier|*
modifier|*
name|range_types
init|=
name|NULL
decl_stmt|;
name|struct
name|attribute
modifier|*
name|attr
decl_stmt|;
name|int
name|ndim
init|=
literal|0
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
decl_stmt|;
comment|/* Return if we've already decoded this type. */
if|if
condition|(
name|die
operator|->
name|type
condition|)
block|{
return|return;
block|}
name|element_type
operator|=
name|die_type
argument_list|(
name|die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Irix 6.2 native cc creates array types without children for      arrays with unspecified length.  */
if|if
condition|(
name|die
operator|->
name|has_children
operator|==
literal|0
condition|)
block|{
name|index_type
operator|=
name|dwarf2_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_INTEGER
argument_list|)
expr_stmt|;
name|range_type
operator|=
name|create_range_type
argument_list|(
name|NULL
argument_list|,
name|index_type
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|die
operator|->
name|type
operator|=
name|create_array_type
argument_list|(
name|NULL
argument_list|,
name|element_type
argument_list|,
name|range_type
argument_list|)
expr_stmt|;
return|return;
block|}
name|back_to
operator|=
name|make_cleanup
argument_list|(
name|null_cleanup
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|child_die
operator|=
name|die
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|child_die
operator|&&
name|child_die
operator|->
name|tag
condition|)
block|{
if|if
condition|(
name|child_die
operator|->
name|tag
operator|==
name|DW_TAG_subrange_type
condition|)
block|{
name|unsigned
name|int
name|low
decl_stmt|,
name|high
decl_stmt|;
comment|/* Default bounds to an array with unspecified length.  */
name|low
operator|=
literal|0
expr_stmt|;
name|high
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|cu_language
operator|==
name|language_fortran
condition|)
block|{
comment|/* FORTRAN implies a lower bound of 1, if not given.  */
name|low
operator|=
literal|1
expr_stmt|;
block|}
name|index_type
operator|=
name|die_type
argument_list|(
name|child_die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|child_die
argument_list|,
name|DW_AT_lower_bound
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
if|if
condition|(
name|attr
operator|->
name|form
operator|==
name|DW_FORM_sdata
condition|)
block|{
name|low
operator|=
name|DW_SND
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|attr
operator|->
name|form
operator|==
name|DW_FORM_udata
operator|||
name|attr
operator|->
name|form
operator|==
name|DW_FORM_data1
operator|||
name|attr
operator|->
name|form
operator|==
name|DW_FORM_data2
operator|||
name|attr
operator|->
name|form
operator|==
name|DW_FORM_data4
condition|)
block|{
name|low
operator|=
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|complain
argument_list|(
operator|&
name|dwarf2_non_const_array_bound_ignored
argument_list|,
name|dwarf_form_name
argument_list|(
name|attr
operator|->
name|form
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FORTRAN_HACK
name|die
operator|->
name|type
operator|=
name|lookup_pointer_type
argument_list|(
name|element_type
argument_list|)
expr_stmt|;
return|return;
else|#
directive|else
name|low
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|child_die
argument_list|,
name|DW_AT_upper_bound
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
if|if
condition|(
name|attr
operator|->
name|form
operator|==
name|DW_FORM_sdata
condition|)
block|{
name|high
operator|=
name|DW_SND
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|attr
operator|->
name|form
operator|==
name|DW_FORM_udata
operator|||
name|attr
operator|->
name|form
operator|==
name|DW_FORM_data1
operator|||
name|attr
operator|->
name|form
operator|==
name|DW_FORM_data2
operator|||
name|attr
operator|->
name|form
operator|==
name|DW_FORM_data4
condition|)
block|{
name|high
operator|=
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|attr
operator|->
name|form
operator|==
name|DW_FORM_block1
condition|)
block|{
comment|/* GCC encodes arrays with unspecified or dynamic length 		     with a DW_FORM_block1 attribute. 		     FIXME: GDB does not yet know how to handle dynamic 		     arrays properly, treat them as arrays with unspecified 		     length for now.  */
name|high
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|complain
argument_list|(
operator|&
name|dwarf2_non_const_array_bound_ignored
argument_list|,
name|dwarf_form_name
argument_list|(
name|attr
operator|->
name|form
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FORTRAN_HACK
name|die
operator|->
name|type
operator|=
name|lookup_pointer_type
argument_list|(
name|element_type
argument_list|)
expr_stmt|;
return|return;
else|#
directive|else
name|high
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* Create a range type and save it for array type creation.  */
if|if
condition|(
operator|(
name|ndim
operator|%
name|DW_FIELD_ALLOC_CHUNK
operator|)
operator|==
literal|0
condition|)
block|{
name|range_types
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|range_types
argument_list|,
operator|(
name|ndim
operator|+
name|DW_FIELD_ALLOC_CHUNK
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndim
operator|==
literal|0
condition|)
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_current_contents
argument_list|,
operator|&
name|range_types
argument_list|)
expr_stmt|;
block|}
name|range_types
index|[
name|ndim
operator|++
index|]
operator|=
name|create_range_type
argument_list|(
name|NULL
argument_list|,
name|index_type
argument_list|,
name|low
argument_list|,
name|high
argument_list|)
expr_stmt|;
block|}
name|child_die
operator|=
name|sibling_die
argument_list|(
name|child_die
argument_list|)
expr_stmt|;
block|}
comment|/* Dwarf2 dimensions are output from left to right, create the      necessary array types in backwards order.  */
name|type
operator|=
name|element_type
expr_stmt|;
while|while
condition|(
name|ndim
operator|--
operator|>
literal|0
condition|)
name|type
operator|=
name|create_array_type
argument_list|(
name|NULL
argument_list|,
name|type
argument_list|,
name|range_types
index|[
name|ndim
index|]
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
comment|/* Install the type in the die. */
name|die
operator|->
name|type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* First cut: install each common block member as a global variable.  */
end_comment

begin_function
specifier|static
name|void
name|read_common_block
parameter_list|(
name|die
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|die_info
modifier|*
name|die
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|die_info
modifier|*
name|child_die
decl_stmt|;
name|struct
name|attribute
modifier|*
name|attr
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|CORE_ADDR
name|base
init|=
operator|(
name|CORE_ADDR
operator|)
literal|0
decl_stmt|;
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_location
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|base
operator|=
name|decode_locdesc
argument_list|(
name|DW_BLOCK
argument_list|(
name|attr
argument_list|)
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|die
operator|->
name|has_children
condition|)
block|{
name|child_die
operator|=
name|die
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|child_die
operator|&&
name|child_die
operator|->
name|tag
condition|)
block|{
name|sym
operator|=
name|new_symbol
argument_list|(
name|child_die
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|child_die
argument_list|,
name|DW_AT_data_member_location
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|=
name|base
operator|+
name|decode_locdesc
argument_list|(
name|DW_BLOCK
argument_list|(
name|attr
argument_list|)
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
block|}
name|child_die
operator|=
name|sibling_die
argument_list|(
name|child_die
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Extract all information from a DW_TAG_pointer_type DIE and add to    the user defined type vector.  */
end_comment

begin_function
specifier|static
name|void
name|read_tag_pointer_type
parameter_list|(
name|die
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|die_info
modifier|*
name|die
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|attribute
modifier|*
name|attr
decl_stmt|;
if|if
condition|(
name|die
operator|->
name|type
condition|)
block|{
return|return;
block|}
name|type
operator|=
name|lookup_pointer_type
argument_list|(
name|die_type
argument_list|(
name|die
argument_list|,
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_byte_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|address_size
expr_stmt|;
block|}
name|die
operator|->
name|type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Extract all information from a DW_TAG_ptr_to_member_type DIE and add to    the user defined type vector.  */
end_comment

begin_function
specifier|static
name|void
name|read_tag_ptr_to_member_type
parameter_list|(
name|die
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|die_info
modifier|*
name|die
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|type
modifier|*
name|to_type
decl_stmt|;
name|struct
name|type
modifier|*
name|domain
decl_stmt|;
if|if
condition|(
name|die
operator|->
name|type
condition|)
block|{
return|return;
block|}
name|type
operator|=
name|alloc_type
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|to_type
operator|=
name|die_type
argument_list|(
name|die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|domain
operator|=
name|die_containing_type
argument_list|(
name|die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|smash_to_member_type
argument_list|(
name|type
argument_list|,
name|domain
argument_list|,
name|to_type
argument_list|)
expr_stmt|;
name|die
operator|->
name|type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Extract all information from a DW_TAG_reference_type DIE and add to    the user defined type vector.  */
end_comment

begin_function
specifier|static
name|void
name|read_tag_reference_type
parameter_list|(
name|die
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|die_info
modifier|*
name|die
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|attribute
modifier|*
name|attr
decl_stmt|;
if|if
condition|(
name|die
operator|->
name|type
condition|)
block|{
return|return;
block|}
name|type
operator|=
name|lookup_reference_type
argument_list|(
name|die_type
argument_list|(
name|die
argument_list|,
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_byte_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|address_size
expr_stmt|;
block|}
name|die
operator|->
name|type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|read_tag_const_type
parameter_list|(
name|die
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|die_info
modifier|*
name|die
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
if|if
condition|(
name|die
operator|->
name|type
condition|)
block|{
return|return;
block|}
name|complain
argument_list|(
operator|&
name|dwarf2_const_ignored
argument_list|)
expr_stmt|;
name|die
operator|->
name|type
operator|=
name|die_type
argument_list|(
name|die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|read_tag_volatile_type
parameter_list|(
name|die
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|die_info
modifier|*
name|die
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
if|if
condition|(
name|die
operator|->
name|type
condition|)
block|{
return|return;
block|}
name|complain
argument_list|(
operator|&
name|dwarf2_volatile_ignored
argument_list|)
expr_stmt|;
name|die
operator|->
name|type
operator|=
name|die_type
argument_list|(
name|die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Extract all information from a DW_TAG_string_type DIE and add to    the user defined type vector.  It isn't really a user defined type,    but it behaves like one, with other DIE's using an AT_user_def_type    attribute to reference it.  */
end_comment

begin_function
specifier|static
name|void
name|read_tag_string_type
parameter_list|(
name|die
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|die_info
modifier|*
name|die
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|,
modifier|*
name|range_type
decl_stmt|,
modifier|*
name|index_type
decl_stmt|,
modifier|*
name|char_type
decl_stmt|;
name|struct
name|attribute
modifier|*
name|attr
decl_stmt|;
name|unsigned
name|int
name|length
decl_stmt|;
if|if
condition|(
name|die
operator|->
name|type
condition|)
block|{
return|return;
block|}
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_string_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|length
operator|=
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|length
operator|=
literal|1
expr_stmt|;
block|}
name|index_type
operator|=
name|dwarf2_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_INTEGER
argument_list|)
expr_stmt|;
name|range_type
operator|=
name|create_range_type
argument_list|(
name|NULL
argument_list|,
name|index_type
argument_list|,
literal|1
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|char_type
operator|=
name|dwarf2_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_CHAR
argument_list|)
expr_stmt|;
name|type
operator|=
name|create_string_type
argument_list|(
name|char_type
argument_list|,
name|range_type
argument_list|)
expr_stmt|;
name|die
operator|->
name|type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle DIES due to C code like:     struct foo      {        int (*funcp)(int a, long l);        int b;      };     ('funcp' generates a DW_TAG_subroutine_type DIE) */
end_comment

begin_function
specifier|static
name|void
name|read_subroutine_type
parameter_list|(
name|die
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|die_info
modifier|*
name|die
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
comment|/* Type that this function returns */
name|struct
name|type
modifier|*
name|ftype
decl_stmt|;
comment|/* Function that returns above type */
name|struct
name|attribute
modifier|*
name|attr
decl_stmt|;
comment|/* Decode the type that this subroutine returns */
if|if
condition|(
name|die
operator|->
name|type
condition|)
block|{
return|return;
block|}
name|type
operator|=
name|die_type
argument_list|(
name|die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|ftype
operator|=
name|lookup_function_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* All functions in C++ have prototypes.  */
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_prototyped
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|attr
operator|&&
operator|(
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
operator|!=
literal|0
operator|)
operator|)
operator|||
name|cu_language
operator|==
name|language_cplus
condition|)
name|TYPE_FLAGS
argument_list|(
name|ftype
argument_list|)
operator||=
name|TYPE_FLAG_PROTOTYPED
expr_stmt|;
if|if
condition|(
name|die
operator|->
name|has_children
condition|)
block|{
name|struct
name|die_info
modifier|*
name|child_die
decl_stmt|;
name|int
name|nparams
init|=
literal|0
decl_stmt|;
name|int
name|iparams
init|=
literal|0
decl_stmt|;
comment|/* Count the number of parameters.          FIXME: GDB currently ignores vararg functions, but knows about          vararg member functions.  */
name|child_die
operator|=
name|die
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|child_die
operator|&&
name|child_die
operator|->
name|tag
condition|)
block|{
if|if
condition|(
name|child_die
operator|->
name|tag
operator|==
name|DW_TAG_formal_parameter
condition|)
name|nparams
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|child_die
operator|->
name|tag
operator|==
name|DW_TAG_unspecified_parameters
condition|)
name|TYPE_FLAGS
argument_list|(
name|ftype
argument_list|)
operator||=
name|TYPE_FLAG_VARARGS
expr_stmt|;
name|child_die
operator|=
name|sibling_die
argument_list|(
name|child_die
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate storage for parameters and fill them in.  */
name|TYPE_NFIELDS
argument_list|(
name|ftype
argument_list|)
operator|=
name|nparams
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|ftype
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|ftype
argument_list|,
name|nparams
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|child_die
operator|=
name|die
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|child_die
operator|&&
name|child_die
operator|->
name|tag
condition|)
block|{
if|if
condition|(
name|child_die
operator|->
name|tag
operator|==
name|DW_TAG_formal_parameter
condition|)
block|{
comment|/* Dwarf2 has no clean way to discern C++ static and non-static 		 member functions. G++ helps GDB by marking the first 		 parameter for non-static member functions (which is the 		 this pointer) as artificial. We pass this information 		 to dwarf2_add_member_fn via TYPE_FIELD_ARTIFICIAL.  */
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|child_die
argument_list|,
name|DW_AT_artificial
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
name|TYPE_FIELD_ARTIFICIAL
argument_list|(
name|ftype
argument_list|,
name|iparams
argument_list|)
operator|=
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
expr_stmt|;
else|else
name|TYPE_FIELD_ARTIFICIAL
argument_list|(
name|ftype
argument_list|,
name|iparams
argument_list|)
operator|=
literal|0
expr_stmt|;
name|TYPE_FIELD_TYPE
argument_list|(
name|ftype
argument_list|,
name|iparams
argument_list|)
operator|=
name|die_type
argument_list|(
name|child_die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|iparams
operator|++
expr_stmt|;
block|}
name|child_die
operator|=
name|sibling_die
argument_list|(
name|child_die
argument_list|)
expr_stmt|;
block|}
block|}
name|die
operator|->
name|type
operator|=
name|ftype
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|read_typedef
parameter_list|(
name|die
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|die_info
modifier|*
name|die
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
if|if
condition|(
operator|!
name|die
operator|->
name|type
condition|)
block|{
name|struct
name|attribute
modifier|*
name|attr
decl_stmt|;
name|struct
name|type
modifier|*
name|xtype
decl_stmt|;
name|xtype
operator|=
name|die_type
argument_list|(
name|die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|type
operator|=
name|alloc_type
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_TYPEDEF
expr_stmt|;
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator||=
name|TYPE_FLAG_TARGET_STUB
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|xtype
expr_stmt|;
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|&&
name|DW_STRING
argument_list|(
name|attr
argument_list|)
condition|)
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|obsavestring
argument_list|(
name|DW_STRING
argument_list|(
name|attr
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|DW_STRING
argument_list|(
name|attr
argument_list|)
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|)
expr_stmt|;
name|die
operator|->
name|type
operator|=
name|type
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Find a representation of a given base type and install    it in the TYPE field of the die.  */
end_comment

begin_function
specifier|static
name|void
name|read_base_type
parameter_list|(
name|die
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|die_info
modifier|*
name|die
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|attribute
modifier|*
name|attr
decl_stmt|;
name|int
name|encoding
init|=
literal|0
decl_stmt|,
name|size
init|=
literal|0
decl_stmt|;
comment|/* If we've already decoded this die, this is a no-op. */
if|if
condition|(
name|die
operator|->
name|type
condition|)
block|{
return|return;
block|}
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_encoding
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|encoding
operator|=
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_byte_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|size
operator|=
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|&&
name|DW_STRING
argument_list|(
name|attr
argument_list|)
condition|)
block|{
name|enum
name|type_code
name|code
init|=
name|TYPE_CODE_INT
decl_stmt|;
name|int
name|is_unsigned
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|encoding
condition|)
block|{
case|case
name|DW_ATE_address
case|:
comment|/* Turn DW_ATE_address into a void * pointer.  */
name|code
operator|=
name|TYPE_CODE_PTR
expr_stmt|;
name|is_unsigned
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_ATE_boolean
case|:
name|code
operator|=
name|TYPE_CODE_BOOL
expr_stmt|;
name|is_unsigned
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_ATE_complex_float
case|:
name|code
operator|=
name|TYPE_CODE_COMPLEX
expr_stmt|;
break|break;
case|case
name|DW_ATE_float
case|:
name|code
operator|=
name|TYPE_CODE_FLT
expr_stmt|;
break|break;
case|case
name|DW_ATE_signed
case|:
case|case
name|DW_ATE_signed_char
case|:
break|break;
case|case
name|DW_ATE_unsigned
case|:
case|case
name|DW_ATE_unsigned_char
case|:
name|is_unsigned
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|complain
argument_list|(
operator|&
name|dwarf2_unsupported_at_encoding
argument_list|,
name|dwarf_type_encoding_name
argument_list|(
name|encoding
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|type
operator|=
name|init_type
argument_list|(
name|code
argument_list|,
name|size
argument_list|,
name|is_unsigned
argument_list|,
name|DW_STRING
argument_list|(
name|attr
argument_list|)
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|encoding
operator|==
name|DW_ATE_address
condition|)
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|dwarf2_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_VOID
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|dwarf_base_type
argument_list|(
name|encoding
argument_list|,
name|size
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
name|die
operator|->
name|type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read a whole compilation unit into a linked list of dies.  */
end_comment

begin_function
name|struct
name|die_info
modifier|*
name|read_comp_unit
parameter_list|(
name|info_ptr
parameter_list|,
name|abfd
parameter_list|)
name|char
modifier|*
name|info_ptr
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|struct
name|die_info
modifier|*
name|first_die
decl_stmt|,
modifier|*
name|last_die
decl_stmt|,
modifier|*
name|die
decl_stmt|;
name|char
modifier|*
name|cur_ptr
decl_stmt|;
name|int
name|nesting_level
decl_stmt|;
comment|/* Reset die reference table, we are building a new one now. */
name|dwarf2_empty_die_ref_table
argument_list|()
expr_stmt|;
name|cur_ptr
operator|=
name|info_ptr
expr_stmt|;
name|nesting_level
operator|=
literal|0
expr_stmt|;
name|first_die
operator|=
name|last_die
operator|=
name|NULL
expr_stmt|;
do|do
block|{
name|cur_ptr
operator|=
name|read_full_die
argument_list|(
operator|&
name|die
argument_list|,
name|abfd
argument_list|,
name|cur_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|die
operator|->
name|has_children
condition|)
block|{
name|nesting_level
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|die
operator|->
name|tag
operator|==
literal|0
condition|)
block|{
name|nesting_level
operator|--
expr_stmt|;
block|}
name|die
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* Enter die in reference hash table */
name|store_in_ref_table
argument_list|(
name|die
operator|->
name|offset
argument_list|,
name|die
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|first_die
condition|)
block|{
name|first_die
operator|=
name|last_die
operator|=
name|die
expr_stmt|;
block|}
else|else
block|{
name|last_die
operator|->
name|next
operator|=
name|die
expr_stmt|;
name|last_die
operator|=
name|die
expr_stmt|;
block|}
block|}
do|while
condition|(
name|nesting_level
operator|>
literal|0
condition|)
do|;
return|return
name|first_die
return|;
block|}
end_function

begin_comment
comment|/* Free a linked list of dies.  */
end_comment

begin_function
specifier|static
name|void
name|free_die_list
parameter_list|(
name|dies
parameter_list|)
name|struct
name|die_info
modifier|*
name|dies
decl_stmt|;
block|{
name|struct
name|die_info
modifier|*
name|die
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|die
operator|=
name|dies
expr_stmt|;
while|while
condition|(
name|die
condition|)
block|{
name|next
operator|=
name|die
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|die
operator|->
name|attrs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|die
argument_list|)
expr_stmt|;
name|die
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Read the contents of the section at OFFSET and of size SIZE from the    object file specified by OBJFILE into the psymbol_obstack and return it.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|dwarf2_read_section
parameter_list|(
name|objfile
parameter_list|,
name|offset
parameter_list|,
name|size
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|file_ptr
name|offset
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|{
name|bfd
modifier|*
name|abfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|bfd_read
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|size
operator|)
condition|)
block|{
name|buf
operator|=
name|NULL
expr_stmt|;
name|error
argument_list|(
literal|"Dwarf Error: Can't read DWARF data from '%s'"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* In DWARF version 2, the description of the debugging information is    stored in a separate .debug_abbrev section.  Before we read any    dies from a section we read in all abbreviations and install them    in a hash table.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2_read_abbrevs
parameter_list|(
name|abfd
parameter_list|,
name|offset
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|char
modifier|*
name|abbrev_ptr
decl_stmt|;
name|struct
name|abbrev_info
modifier|*
name|cur_abbrev
decl_stmt|;
name|unsigned
name|int
name|abbrev_number
decl_stmt|,
name|bytes_read
decl_stmt|,
name|abbrev_name
decl_stmt|;
name|unsigned
name|int
name|abbrev_form
decl_stmt|,
name|hash_number
decl_stmt|;
comment|/* empty the table */
name|dwarf2_empty_abbrev_table
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|=
name|dwarf_abbrev_buffer
operator|+
name|offset
expr_stmt|;
name|abbrev_number
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|abbrev_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|+=
name|bytes_read
expr_stmt|;
comment|/* loop until we reach an abbrev number of 0 */
while|while
condition|(
name|abbrev_number
condition|)
block|{
name|cur_abbrev
operator|=
name|dwarf_alloc_abbrev
argument_list|()
expr_stmt|;
comment|/* read in abbrev header */
name|cur_abbrev
operator|->
name|number
operator|=
name|abbrev_number
expr_stmt|;
name|cur_abbrev
operator|->
name|tag
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|abbrev_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|cur_abbrev
operator|->
name|has_children
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|abbrev_ptr
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|+=
literal|1
expr_stmt|;
comment|/* now read in declarations */
name|abbrev_name
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|abbrev_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|abbrev_form
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|abbrev_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|+=
name|bytes_read
expr_stmt|;
while|while
condition|(
name|abbrev_name
condition|)
block|{
if|if
condition|(
operator|(
name|cur_abbrev
operator|->
name|num_attrs
operator|%
name|ATTR_ALLOC_CHUNK
operator|)
operator|==
literal|0
condition|)
block|{
name|cur_abbrev
operator|->
name|attrs
operator|=
operator|(
expr|struct
name|attr_abbrev
operator|*
operator|)
name|xrealloc
argument_list|(
name|cur_abbrev
operator|->
name|attrs
argument_list|,
operator|(
name|cur_abbrev
operator|->
name|num_attrs
operator|+
name|ATTR_ALLOC_CHUNK
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|attr_abbrev
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cur_abbrev
operator|->
name|attrs
index|[
name|cur_abbrev
operator|->
name|num_attrs
index|]
operator|.
name|name
operator|=
name|abbrev_name
expr_stmt|;
name|cur_abbrev
operator|->
name|attrs
index|[
name|cur_abbrev
operator|->
name|num_attrs
operator|++
index|]
operator|.
name|form
operator|=
name|abbrev_form
expr_stmt|;
name|abbrev_name
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|abbrev_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|abbrev_form
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|abbrev_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|+=
name|bytes_read
expr_stmt|;
block|}
name|hash_number
operator|=
name|abbrev_number
operator|%
name|ABBREV_HASH_SIZE
expr_stmt|;
name|cur_abbrev
operator|->
name|next
operator|=
name|dwarf2_abbrevs
index|[
name|hash_number
index|]
expr_stmt|;
name|dwarf2_abbrevs
index|[
name|hash_number
index|]
operator|=
name|cur_abbrev
expr_stmt|;
comment|/* Get next abbreviation.          Under Irix6 the abbreviations for a compilation unit are not 	 always properly terminated with an abbrev number of 0. 	 Exit loop if we encounter an abbreviation which we have 	 already read (which means we are about to read the abbreviations 	 for the next compile unit) or if the end of the abbreviation 	 table is reached.  */
if|if
condition|(
call|(
name|unsigned
name|int
call|)
argument_list|(
name|abbrev_ptr
operator|-
name|dwarf_abbrev_buffer
argument_list|)
operator|>=
name|dwarf_abbrev_size
condition|)
break|break;
name|abbrev_number
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|abbrev_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|abbrev_ptr
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
name|dwarf2_lookup_abbrev
argument_list|(
name|abbrev_number
argument_list|)
operator|!=
name|NULL
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Empty the abbrev table for a new compilation unit.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|dwarf2_empty_abbrev_table
parameter_list|(
name|ignore
parameter_list|)
name|PTR
name|ignore
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|abbrev_info
modifier|*
name|abbrev
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ABBREV_HASH_SIZE
condition|;
operator|++
name|i
control|)
block|{
name|next
operator|=
name|NULL
expr_stmt|;
name|abbrev
operator|=
name|dwarf2_abbrevs
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|abbrev
condition|)
block|{
name|next
operator|=
name|abbrev
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|abbrev
operator|->
name|attrs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|abbrev
argument_list|)
expr_stmt|;
name|abbrev
operator|=
name|next
expr_stmt|;
block|}
name|dwarf2_abbrevs
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Lookup an abbrev_info structure in the abbrev hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|abbrev_info
modifier|*
name|dwarf2_lookup_abbrev
parameter_list|(
name|number
parameter_list|)
name|unsigned
name|int
name|number
decl_stmt|;
block|{
name|unsigned
name|int
name|hash_number
decl_stmt|;
name|struct
name|abbrev_info
modifier|*
name|abbrev
decl_stmt|;
name|hash_number
operator|=
name|number
operator|%
name|ABBREV_HASH_SIZE
expr_stmt|;
name|abbrev
operator|=
name|dwarf2_abbrevs
index|[
name|hash_number
index|]
expr_stmt|;
while|while
condition|(
name|abbrev
condition|)
block|{
if|if
condition|(
name|abbrev
operator|->
name|number
operator|==
name|number
condition|)
return|return
name|abbrev
return|;
else|else
name|abbrev
operator|=
name|abbrev
operator|->
name|next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Read a minimal amount of information into the minimal die structure.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|read_partial_die
parameter_list|(
name|part_die
parameter_list|,
name|abfd
parameter_list|,
name|info_ptr
parameter_list|,
name|has_pc_info
parameter_list|)
name|struct
name|partial_die_info
modifier|*
name|part_die
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|info_ptr
decl_stmt|;
name|int
modifier|*
name|has_pc_info
decl_stmt|;
block|{
name|unsigned
name|int
name|abbrev_number
decl_stmt|,
name|bytes_read
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|abbrev_info
modifier|*
name|abbrev
decl_stmt|;
name|struct
name|attribute
name|attr
decl_stmt|;
name|struct
name|attribute
name|spec_attr
decl_stmt|;
name|int
name|found_spec_attr
init|=
literal|0
decl_stmt|;
name|int
name|has_low_pc_attr
init|=
literal|0
decl_stmt|;
name|int
name|has_high_pc_attr
init|=
literal|0
decl_stmt|;
operator|*
name|part_die
operator|=
name|zeroed_partial_die
expr_stmt|;
operator|*
name|has_pc_info
operator|=
literal|0
expr_stmt|;
name|abbrev_number
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
operator|!
name|abbrev_number
condition|)
return|return
name|info_ptr
return|;
name|abbrev
operator|=
name|dwarf2_lookup_abbrev
argument_list|(
name|abbrev_number
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abbrev
condition|)
block|{
name|error
argument_list|(
literal|"Dwarf Error: Could not find abbrev number %d."
argument_list|,
name|abbrev_number
argument_list|)
expr_stmt|;
block|}
name|part_die
operator|->
name|offset
operator|=
name|info_ptr
operator|-
name|dwarf_info_buffer
expr_stmt|;
name|part_die
operator|->
name|tag
operator|=
name|abbrev
operator|->
name|tag
expr_stmt|;
name|part_die
operator|->
name|has_children
operator|=
name|abbrev
operator|->
name|has_children
expr_stmt|;
name|part_die
operator|->
name|abbrev
operator|=
name|abbrev_number
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|abbrev
operator|->
name|num_attrs
condition|;
operator|++
name|i
control|)
block|{
name|info_ptr
operator|=
name|read_attribute
argument_list|(
operator|&
name|attr
argument_list|,
operator|&
name|abbrev
operator|->
name|attrs
index|[
name|i
index|]
argument_list|,
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
comment|/* Store the data if it is of an attribute we want to keep in a 	 partial symbol table.  */
switch|switch
condition|(
name|attr
operator|.
name|name
condition|)
block|{
case|case
name|DW_AT_name
case|:
comment|/* Prefer DW_AT_MIPS_linkage_name over DW_AT_name.  */
if|if
condition|(
name|part_die
operator|->
name|name
operator|==
name|NULL
condition|)
name|part_die
operator|->
name|name
operator|=
name|DW_STRING
argument_list|(
operator|&
name|attr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_AT_MIPS_linkage_name
case|:
name|part_die
operator|->
name|name
operator|=
name|DW_STRING
argument_list|(
operator|&
name|attr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_AT_low_pc
case|:
name|has_low_pc_attr
operator|=
literal|1
expr_stmt|;
name|part_die
operator|->
name|lowpc
operator|=
name|DW_ADDR
argument_list|(
operator|&
name|attr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_AT_high_pc
case|:
name|has_high_pc_attr
operator|=
literal|1
expr_stmt|;
name|part_die
operator|->
name|highpc
operator|=
name|DW_ADDR
argument_list|(
operator|&
name|attr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_AT_location
case|:
name|part_die
operator|->
name|locdesc
operator|=
name|DW_BLOCK
argument_list|(
operator|&
name|attr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_AT_language
case|:
name|part_die
operator|->
name|language
operator|=
name|DW_UNSND
argument_list|(
operator|&
name|attr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_AT_external
case|:
name|part_die
operator|->
name|is_external
operator|=
name|DW_UNSND
argument_list|(
operator|&
name|attr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_AT_declaration
case|:
name|part_die
operator|->
name|is_declaration
operator|=
name|DW_UNSND
argument_list|(
operator|&
name|attr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_AT_type
case|:
name|part_die
operator|->
name|has_type
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_AT_abstract_origin
case|:
case|case
name|DW_AT_specification
case|:
name|found_spec_attr
operator|=
literal|1
expr_stmt|;
name|spec_attr
operator|=
name|attr
expr_stmt|;
break|break;
case|case
name|DW_AT_sibling
case|:
comment|/* Ignore absolute siblings, they might point outside of 	     the current compile unit.  */
if|if
condition|(
name|attr
operator|.
name|form
operator|==
name|DW_FORM_ref_addr
condition|)
name|complain
argument_list|(
operator|&
name|dwarf2_absolute_sibling_complaint
argument_list|)
expr_stmt|;
else|else
name|part_die
operator|->
name|sibling
operator|=
name|dwarf_info_buffer
operator|+
name|dwarf2_get_ref_die_offset
argument_list|(
operator|&
name|attr
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
comment|/* If we found a reference attribute and the die has no name, try      to find a name in the referred to die.  */
if|if
condition|(
name|found_spec_attr
operator|&&
name|part_die
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|struct
name|partial_die_info
name|spec_die
decl_stmt|;
name|char
modifier|*
name|spec_ptr
decl_stmt|;
name|int
name|dummy
decl_stmt|;
name|spec_ptr
operator|=
name|dwarf_info_buffer
operator|+
name|dwarf2_get_ref_die_offset
argument_list|(
operator|&
name|spec_attr
argument_list|)
expr_stmt|;
name|read_partial_die
argument_list|(
operator|&
name|spec_die
argument_list|,
name|abfd
argument_list|,
name|spec_ptr
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec_die
operator|.
name|name
condition|)
block|{
name|part_die
operator|->
name|name
operator|=
name|spec_die
operator|.
name|name
expr_stmt|;
comment|/* Copy DW_AT_external attribute if it is set.  */
if|if
condition|(
name|spec_die
operator|.
name|is_external
condition|)
name|part_die
operator|->
name|is_external
operator|=
name|spec_die
operator|.
name|is_external
expr_stmt|;
block|}
block|}
comment|/* When using the GNU linker, .gnu.linkonce. sections are used to      eliminate duplicate copies of functions and vtables and such.      The linker will arbitrarily choose one and discard the others.      The AT_*_pc values for such functions refer to local labels in      these sections.  If the section from that file was discarded, the      labels are not in the output, so the relocs get a value of 0.      If this is a discarded function, mark the pc bounds as invalid,      so that GDB will ignore it.  */
if|if
condition|(
name|has_low_pc_attr
operator|&&
name|has_high_pc_attr
operator|&&
name|part_die
operator|->
name|lowpc
operator|<
name|part_die
operator|->
name|highpc
operator|&&
operator|(
name|part_die
operator|->
name|lowpc
operator|!=
literal|0
operator|||
operator|(
name|bfd_get_file_flags
argument_list|(
name|abfd
argument_list|)
operator|&
name|HAS_RELOC
operator|)
operator|)
condition|)
operator|*
name|has_pc_info
operator|=
literal|1
expr_stmt|;
return|return
name|info_ptr
return|;
block|}
end_function

begin_comment
comment|/* Read the die from the .debug_info section buffer.  And set diep to    point to a newly allocated die with its information.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|read_full_die
parameter_list|(
name|diep
parameter_list|,
name|abfd
parameter_list|,
name|info_ptr
parameter_list|)
name|struct
name|die_info
modifier|*
modifier|*
name|diep
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|info_ptr
decl_stmt|;
block|{
name|unsigned
name|int
name|abbrev_number
decl_stmt|,
name|bytes_read
decl_stmt|,
name|i
decl_stmt|,
name|offset
decl_stmt|;
name|struct
name|abbrev_info
modifier|*
name|abbrev
decl_stmt|;
name|struct
name|die_info
modifier|*
name|die
decl_stmt|;
name|offset
operator|=
name|info_ptr
operator|-
name|dwarf_info_buffer
expr_stmt|;
name|abbrev_number
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
operator|!
name|abbrev_number
condition|)
block|{
name|die
operator|=
name|dwarf_alloc_die
argument_list|()
expr_stmt|;
name|die
operator|->
name|tag
operator|=
literal|0
expr_stmt|;
name|die
operator|->
name|abbrev
operator|=
name|abbrev_number
expr_stmt|;
name|die
operator|->
name|type
operator|=
name|NULL
expr_stmt|;
operator|*
name|diep
operator|=
name|die
expr_stmt|;
return|return
name|info_ptr
return|;
block|}
name|abbrev
operator|=
name|dwarf2_lookup_abbrev
argument_list|(
name|abbrev_number
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abbrev
condition|)
block|{
name|error
argument_list|(
literal|"Dwarf Error: could not find abbrev number %d."
argument_list|,
name|abbrev_number
argument_list|)
expr_stmt|;
block|}
name|die
operator|=
name|dwarf_alloc_die
argument_list|()
expr_stmt|;
name|die
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|die
operator|->
name|tag
operator|=
name|abbrev
operator|->
name|tag
expr_stmt|;
name|die
operator|->
name|has_children
operator|=
name|abbrev
operator|->
name|has_children
expr_stmt|;
name|die
operator|->
name|abbrev
operator|=
name|abbrev_number
expr_stmt|;
name|die
operator|->
name|type
operator|=
name|NULL
expr_stmt|;
name|die
operator|->
name|num_attrs
operator|=
name|abbrev
operator|->
name|num_attrs
expr_stmt|;
name|die
operator|->
name|attrs
operator|=
operator|(
expr|struct
name|attribute
operator|*
operator|)
name|xmalloc
argument_list|(
name|die
operator|->
name|num_attrs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|attribute
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|abbrev
operator|->
name|num_attrs
condition|;
operator|++
name|i
control|)
block|{
name|info_ptr
operator|=
name|read_attribute
argument_list|(
operator|&
name|die
operator|->
name|attrs
index|[
name|i
index|]
argument_list|,
operator|&
name|abbrev
operator|->
name|attrs
index|[
name|i
index|]
argument_list|,
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
block|}
operator|*
name|diep
operator|=
name|die
expr_stmt|;
return|return
name|info_ptr
return|;
block|}
end_function

begin_comment
comment|/* Read an attribute described by an abbreviated attribute.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|read_attribute
parameter_list|(
name|attr
parameter_list|,
name|abbrev
parameter_list|,
name|abfd
parameter_list|,
name|info_ptr
parameter_list|)
name|struct
name|attribute
modifier|*
name|attr
decl_stmt|;
name|struct
name|attr_abbrev
modifier|*
name|abbrev
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|info_ptr
decl_stmt|;
block|{
name|unsigned
name|int
name|bytes_read
decl_stmt|;
name|struct
name|dwarf_block
modifier|*
name|blk
decl_stmt|;
name|attr
operator|->
name|name
operator|=
name|abbrev
operator|->
name|name
expr_stmt|;
name|attr
operator|->
name|form
operator|=
name|abbrev
operator|->
name|form
expr_stmt|;
switch|switch
condition|(
name|abbrev
operator|->
name|form
condition|)
block|{
case|case
name|DW_FORM_addr
case|:
case|case
name|DW_FORM_ref_addr
case|:
name|DW_ADDR
argument_list|(
name|attr
argument_list|)
operator|=
name|read_address
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|address_size
expr_stmt|;
break|break;
case|case
name|DW_FORM_block2
case|:
name|blk
operator|=
name|dwarf_alloc_block
argument_list|()
expr_stmt|;
name|blk
operator|->
name|size
operator|=
name|read_2_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|2
expr_stmt|;
name|blk
operator|->
name|data
operator|=
name|read_n_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
name|blk
operator|->
name|size
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|blk
operator|->
name|size
expr_stmt|;
name|DW_BLOCK
argument_list|(
name|attr
argument_list|)
operator|=
name|blk
expr_stmt|;
break|break;
case|case
name|DW_FORM_block4
case|:
name|blk
operator|=
name|dwarf_alloc_block
argument_list|()
expr_stmt|;
name|blk
operator|->
name|size
operator|=
name|read_4_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|4
expr_stmt|;
name|blk
operator|->
name|data
operator|=
name|read_n_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
name|blk
operator|->
name|size
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|blk
operator|->
name|size
expr_stmt|;
name|DW_BLOCK
argument_list|(
name|attr
argument_list|)
operator|=
name|blk
expr_stmt|;
break|break;
case|case
name|DW_FORM_data2
case|:
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
operator|=
name|read_2_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_FORM_data4
case|:
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
operator|=
name|read_4_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|DW_FORM_data8
case|:
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
operator|=
name|read_8_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
name|DW_FORM_string
case|:
name|DW_STRING
argument_list|(
name|attr
argument_list|)
operator|=
name|read_string
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_FORM_block
case|:
name|blk
operator|=
name|dwarf_alloc_block
argument_list|()
expr_stmt|;
name|blk
operator|->
name|size
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|blk
operator|->
name|data
operator|=
name|read_n_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
name|blk
operator|->
name|size
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|blk
operator|->
name|size
expr_stmt|;
name|DW_BLOCK
argument_list|(
name|attr
argument_list|)
operator|=
name|blk
expr_stmt|;
break|break;
case|case
name|DW_FORM_block1
case|:
name|blk
operator|=
name|dwarf_alloc_block
argument_list|()
expr_stmt|;
name|blk
operator|->
name|size
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|1
expr_stmt|;
name|blk
operator|->
name|data
operator|=
name|read_n_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
name|blk
operator|->
name|size
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|blk
operator|->
name|size
expr_stmt|;
name|DW_BLOCK
argument_list|(
name|attr
argument_list|)
operator|=
name|blk
expr_stmt|;
break|break;
case|case
name|DW_FORM_data1
case|:
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_FORM_flag
case|:
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_FORM_sdata
case|:
name|DW_SND
argument_list|(
name|attr
argument_list|)
operator|=
name|read_signed_leb128
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_FORM_udata
case|:
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_FORM_ref1
case|:
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_FORM_ref2
case|:
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
operator|=
name|read_2_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_FORM_ref4
case|:
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
operator|=
name|read_4_bytes
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|DW_FORM_ref_udata
case|:
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|info_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|info_ptr
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_FORM_strp
case|:
case|case
name|DW_FORM_indirect
case|:
default|default:
name|error
argument_list|(
literal|"Dwarf Error: Cannot handle %s in DWARF reader."
argument_list|,
name|dwarf_form_name
argument_list|(
name|abbrev
operator|->
name|form
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|info_ptr
return|;
block|}
end_function

begin_comment
comment|/* read dwarf information from a buffer */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|read_1_byte
parameter_list|(
name|abfd
parameter_list|,
name|buf
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
return|return
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_1_signed_byte
parameter_list|(
name|abfd
parameter_list|,
name|buf
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
return|return
name|bfd_get_signed_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|read_2_bytes
parameter_list|(
name|abfd
parameter_list|,
name|buf
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
return|return
name|bfd_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_2_signed_bytes
parameter_list|(
name|abfd
parameter_list|,
name|buf
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
return|return
name|bfd_get_signed_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|read_4_bytes
parameter_list|(
name|abfd
parameter_list|,
name|buf
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
return|return
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_4_signed_bytes
parameter_list|(
name|abfd
parameter_list|,
name|buf
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
return|return
name|bfd_get_signed_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|read_8_bytes
parameter_list|(
name|abfd
parameter_list|,
name|buf
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
return|return
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|read_address
parameter_list|(
name|abfd
parameter_list|,
name|buf
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|CORE_ADDR
name|retval
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|address_size
condition|)
block|{
case|case
literal|4
case|:
name|retval
operator|=
name|bfd_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|retval
operator|=
name|bfd_get_64
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* *THE* alternative is 8, right? */
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* If the address being read is larger than the address that is      applicable for the object file format then mask it down to the      correct size.  Take care to avoid unnecessary shift or shift      overflow */
if|if
condition|(
name|address_size
operator|>
name|address_significant_size
operator|&&
name|address_significant_size
operator|<
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
condition|)
block|{
name|CORE_ADDR
name|mask
init|=
operator|(
operator|(
name|CORE_ADDR
operator|)
literal|0
operator|)
operator|-
literal|1
decl_stmt|;
name|retval
operator|&=
operator|~
operator|(
name|mask
operator|<<
operator|(
name|address_significant_size
operator|*
literal|8
operator|)
operator|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|read_n_bytes
parameter_list|(
name|abfd
parameter_list|,
name|buf
parameter_list|,
name|size
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|{
comment|/* If the size of a host char is 8 bits, we can return a pointer      to the buffer, otherwise we have to copy the data to a buffer      allocated on the temporary obstack.  */
if|#
directive|if
name|HOST_CHAR_BIT
operator|==
literal|8
return|return
name|buf
return|;
else|#
directive|else
name|char
modifier|*
name|ret
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|ret
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|dwarf2_tmp_obstack
argument_list|,
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
block|{
name|ret
index|[
name|i
index|]
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|++
expr_stmt|;
block|}
return|return
name|ret
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|read_string
parameter_list|(
name|abfd
parameter_list|,
name|buf
parameter_list|,
name|bytes_read_ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|int
modifier|*
name|bytes_read_ptr
decl_stmt|;
block|{
comment|/* If the size of a host char is 8 bits, we can return a pointer      to the string, otherwise we have to copy the string to a buffer      allocated on the temporary obstack.  */
if|#
directive|if
name|HOST_CHAR_BIT
operator|==
literal|8
if|if
condition|(
operator|*
name|buf
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|bytes_read_ptr
operator|=
literal|1
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|*
name|bytes_read_ptr
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
operator|+
literal|1
expr_stmt|;
return|return
name|buf
return|;
else|#
directive|else
name|int
name|byte
decl_stmt|;
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|byte
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|obstack_1grow
argument_list|(
operator|&
name|dwarf2_tmp_obstack
argument_list|,
name|byte
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|buf
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
operator|*
name|bytes_read_ptr
operator|=
literal|1
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|obstack_1grow
argument_list|(
operator|&
name|dwarf2_tmp_obstack
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
operator|*
name|bytes_read_ptr
operator|=
name|i
operator|+
literal|1
expr_stmt|;
return|return
name|obstack_finish
argument_list|(
operator|&
name|dwarf2_tmp_obstack
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|read_unsigned_leb128
parameter_list|(
name|abfd
parameter_list|,
name|buf
parameter_list|,
name|bytes_read_ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|int
modifier|*
name|bytes_read_ptr
decl_stmt|;
block|{
name|unsigned
name|int
name|result
decl_stmt|,
name|num_read
decl_stmt|;
name|int
name|i
decl_stmt|,
name|shift
decl_stmt|;
name|unsigned
name|char
name|byte
decl_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
name|shift
operator|=
literal|0
expr_stmt|;
name|num_read
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|byte
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|++
expr_stmt|;
name|num_read
operator|++
expr_stmt|;
name|result
operator||=
operator|(
operator|(
name|byte
operator|&
literal|127
operator|)
operator|<<
name|shift
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|byte
operator|&
literal|128
operator|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
name|shift
operator|+=
literal|7
expr_stmt|;
block|}
operator|*
name|bytes_read_ptr
operator|=
name|num_read
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_signed_leb128
parameter_list|(
name|abfd
parameter_list|,
name|buf
parameter_list|,
name|bytes_read_ptr
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|int
modifier|*
name|bytes_read_ptr
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
name|int
name|i
decl_stmt|,
name|shift
decl_stmt|,
name|size
decl_stmt|,
name|num_read
decl_stmt|;
name|unsigned
name|char
name|byte
decl_stmt|;
name|result
operator|=
literal|0
expr_stmt|;
name|shift
operator|=
literal|0
expr_stmt|;
name|size
operator|=
literal|32
expr_stmt|;
name|num_read
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|byte
operator|=
name|bfd_get_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|++
expr_stmt|;
name|num_read
operator|++
expr_stmt|;
name|result
operator||=
operator|(
operator|(
name|byte
operator|&
literal|127
operator|)
operator|<<
name|shift
operator|)
expr_stmt|;
name|shift
operator|+=
literal|7
expr_stmt|;
if|if
condition|(
operator|(
name|byte
operator|&
literal|128
operator|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|shift
operator|<
name|size
operator|)
operator|&&
operator|(
name|byte
operator|&
literal|0x40
operator|)
condition|)
block|{
name|result
operator||=
operator|-
operator|(
literal|1
operator|<<
name|shift
operator|)
expr_stmt|;
block|}
operator|*
name|bytes_read_ptr
operator|=
name|num_read
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_cu_language
parameter_list|(
name|lang
parameter_list|)
name|unsigned
name|int
name|lang
decl_stmt|;
block|{
switch|switch
condition|(
name|lang
condition|)
block|{
case|case
name|DW_LANG_C89
case|:
case|case
name|DW_LANG_C
case|:
name|cu_language
operator|=
name|language_c
expr_stmt|;
break|break;
case|case
name|DW_LANG_C_plus_plus
case|:
name|cu_language
operator|=
name|language_cplus
expr_stmt|;
break|break;
case|case
name|DW_LANG_Fortran77
case|:
case|case
name|DW_LANG_Fortran90
case|:
name|cu_language
operator|=
name|language_fortran
expr_stmt|;
break|break;
case|case
name|DW_LANG_Mips_Assembler
case|:
name|cu_language
operator|=
name|language_asm
expr_stmt|;
break|break;
case|case
name|DW_LANG_Ada83
case|:
case|case
name|DW_LANG_Cobol74
case|:
case|case
name|DW_LANG_Cobol85
case|:
case|case
name|DW_LANG_Pascal83
case|:
case|case
name|DW_LANG_Modula2
case|:
default|default:
name|cu_language
operator|=
name|language_unknown
expr_stmt|;
break|break;
block|}
name|cu_language_defn
operator|=
name|language_def
argument_list|(
name|cu_language
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the named attribute or NULL if not there.  */
end_comment

begin_function
specifier|static
name|struct
name|attribute
modifier|*
name|dwarf_attr
parameter_list|(
name|die
parameter_list|,
name|name
parameter_list|)
name|struct
name|die_info
modifier|*
name|die
decl_stmt|;
name|unsigned
name|int
name|name
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|attribute
modifier|*
name|spec
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|die
operator|->
name|num_attrs
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|die
operator|->
name|attrs
index|[
name|i
index|]
operator|.
name|name
operator|==
name|name
condition|)
block|{
return|return
operator|&
name|die
operator|->
name|attrs
index|[
name|i
index|]
return|;
block|}
if|if
condition|(
name|die
operator|->
name|attrs
index|[
name|i
index|]
operator|.
name|name
operator|==
name|DW_AT_specification
operator|||
name|die
operator|->
name|attrs
index|[
name|i
index|]
operator|.
name|name
operator|==
name|DW_AT_abstract_origin
condition|)
name|spec
operator|=
operator|&
name|die
operator|->
name|attrs
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|spec
condition|)
block|{
name|struct
name|die_info
modifier|*
name|ref_die
init|=
name|follow_die_ref
argument_list|(
name|dwarf2_get_ref_die_offset
argument_list|(
name|spec
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ref_die
condition|)
return|return
name|dwarf_attr
argument_list|(
name|ref_die
argument_list|,
name|name
argument_list|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Decode the line number information for the compilation unit whose    line number info is at OFFSET in the .debug_line section.    The compilation directory of the file is passed in COMP_DIR.  */
end_comment

begin_struct
struct|struct
name|filenames
block|{
name|unsigned
name|int
name|num_files
decl_stmt|;
struct|struct
name|fileinfo
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|dir
decl_stmt|;
name|unsigned
name|int
name|time
decl_stmt|;
name|unsigned
name|int
name|size
decl_stmt|;
block|}
modifier|*
name|files
struct|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|directories
block|{
name|unsigned
name|int
name|num_dirs
decl_stmt|;
name|char
modifier|*
modifier|*
name|dirs
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|dwarf_decode_lines
parameter_list|(
name|offset
parameter_list|,
name|comp_dir
parameter_list|,
name|abfd
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
name|char
modifier|*
name|comp_dir
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|{
name|char
modifier|*
name|line_ptr
decl_stmt|;
name|char
modifier|*
name|line_end
decl_stmt|;
name|struct
name|line_head
name|lh
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|bytes_read
decl_stmt|;
name|char
modifier|*
name|cur_file
decl_stmt|,
modifier|*
name|cur_dir
decl_stmt|;
name|unsigned
name|char
name|op_code
decl_stmt|,
name|extended_op
decl_stmt|,
name|adj_opcode
decl_stmt|;
define|#
directive|define
name|FILE_ALLOC_CHUNK
value|5
define|#
directive|define
name|DIR_ALLOC_CHUNK
value|5
name|struct
name|filenames
name|files
decl_stmt|;
name|struct
name|directories
name|dirs
decl_stmt|;
if|if
condition|(
name|dwarf_line_buffer
operator|==
name|NULL
condition|)
block|{
name|complain
argument_list|(
operator|&
name|dwarf2_missing_line_number_section
argument_list|)
expr_stmt|;
return|return;
block|}
name|files
operator|.
name|num_files
operator|=
literal|0
expr_stmt|;
name|files
operator|.
name|files
operator|=
name|NULL
expr_stmt|;
name|dirs
operator|.
name|num_dirs
operator|=
literal|0
expr_stmt|;
name|dirs
operator|.
name|dirs
operator|=
name|NULL
expr_stmt|;
name|line_ptr
operator|=
name|dwarf_line_buffer
operator|+
name|offset
expr_stmt|;
comment|/* read in the prologue */
name|lh
operator|.
name|total_length
operator|=
name|read_4_bytes
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|4
expr_stmt|;
name|line_end
operator|=
name|line_ptr
operator|+
name|lh
operator|.
name|total_length
expr_stmt|;
name|lh
operator|.
name|version
operator|=
name|read_2_bytes
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|2
expr_stmt|;
name|lh
operator|.
name|prologue_length
operator|=
name|read_4_bytes
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|4
expr_stmt|;
name|lh
operator|.
name|minimum_instruction_length
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|1
expr_stmt|;
name|lh
operator|.
name|default_is_stmt
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|1
expr_stmt|;
name|lh
operator|.
name|line_base
operator|=
name|read_1_signed_byte
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|1
expr_stmt|;
name|lh
operator|.
name|line_range
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|1
expr_stmt|;
name|lh
operator|.
name|opcode_base
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|1
expr_stmt|;
name|lh
operator|.
name|standard_opcode_lengths
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|lh
operator|.
name|opcode_base
operator|*
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
argument_list|)
expr_stmt|;
name|back_to
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_current_contents
argument_list|,
operator|&
name|lh
operator|.
name|standard_opcode_lengths
argument_list|)
expr_stmt|;
name|lh
operator|.
name|standard_opcode_lengths
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|lh
operator|.
name|opcode_base
condition|;
operator|++
name|i
control|)
block|{
name|lh
operator|.
name|standard_opcode_lengths
index|[
name|i
index|]
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|1
expr_stmt|;
block|}
comment|/* Read directory table  */
while|while
condition|(
operator|(
name|cur_dir
operator|=
name|read_string
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
operator|(
name|dirs
operator|.
name|num_dirs
operator|%
name|DIR_ALLOC_CHUNK
operator|)
operator|==
literal|0
condition|)
block|{
name|dirs
operator|.
name|dirs
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
name|dirs
operator|.
name|dirs
argument_list|,
operator|(
name|dirs
operator|.
name|num_dirs
operator|+
name|DIR_ALLOC_CHUNK
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirs
operator|.
name|num_dirs
operator|==
literal|0
condition|)
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_current_contents
argument_list|,
operator|&
name|dirs
operator|.
name|dirs
argument_list|)
expr_stmt|;
block|}
name|dirs
operator|.
name|dirs
index|[
name|dirs
operator|.
name|num_dirs
operator|++
index|]
operator|=
name|cur_dir
expr_stmt|;
block|}
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
comment|/* Read file name table */
while|while
condition|(
operator|(
name|cur_file
operator|=
name|read_string
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
operator|(
name|files
operator|.
name|num_files
operator|%
name|FILE_ALLOC_CHUNK
operator|)
operator|==
literal|0
condition|)
block|{
name|files
operator|.
name|files
operator|=
operator|(
expr|struct
name|fileinfo
operator|*
operator|)
name|xrealloc
argument_list|(
name|files
operator|.
name|files
argument_list|,
operator|(
name|files
operator|.
name|num_files
operator|+
name|FILE_ALLOC_CHUNK
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fileinfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|files
operator|.
name|num_files
operator|==
literal|0
condition|)
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_current_contents
argument_list|,
operator|&
name|files
operator|.
name|files
argument_list|)
expr_stmt|;
block|}
name|files
operator|.
name|files
index|[
name|files
operator|.
name|num_files
index|]
operator|.
name|name
operator|=
name|cur_file
expr_stmt|;
name|files
operator|.
name|files
index|[
name|files
operator|.
name|num_files
index|]
operator|.
name|dir
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|files
operator|.
name|files
index|[
name|files
operator|.
name|num_files
index|]
operator|.
name|time
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|files
operator|.
name|files
index|[
name|files
operator|.
name|num_files
index|]
operator|.
name|size
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|files
operator|.
name|num_files
operator|++
expr_stmt|;
block|}
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
comment|/* Read the statement sequences until there's nothing left.  */
while|while
condition|(
name|line_ptr
operator|<
name|line_end
condition|)
block|{
comment|/* state machine registers  */
name|CORE_ADDR
name|address
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|file
init|=
literal|1
decl_stmt|;
name|unsigned
name|int
name|line
init|=
literal|1
decl_stmt|;
name|unsigned
name|int
name|column
init|=
literal|0
decl_stmt|;
name|int
name|is_stmt
init|=
name|lh
operator|.
name|default_is_stmt
decl_stmt|;
name|int
name|basic_block
init|=
literal|0
decl_stmt|;
name|int
name|end_sequence
init|=
literal|0
decl_stmt|;
comment|/* Start a subfile for the current file of the state machine.  */
if|if
condition|(
name|files
operator|.
name|num_files
operator|>=
name|file
condition|)
block|{
comment|/* The file and directory tables are 0 based, the references 	     are 1 based.  */
name|dwarf2_start_subfile
argument_list|(
name|files
operator|.
name|files
index|[
name|file
operator|-
literal|1
index|]
operator|.
name|name
argument_list|,
operator|(
name|files
operator|.
name|files
index|[
name|file
operator|-
literal|1
index|]
operator|.
name|dir
condition|?
name|dirs
operator|.
name|dirs
index|[
name|files
operator|.
name|files
index|[
name|file
operator|-
literal|1
index|]
operator|.
name|dir
operator|-
literal|1
index|]
else|:
name|comp_dir
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Decode the table. */
while|while
condition|(
operator|!
name|end_sequence
condition|)
block|{
name|op_code
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|1
expr_stmt|;
switch|switch
condition|(
name|op_code
condition|)
block|{
case|case
name|DW_LNS_extended_op
case|:
name|line_ptr
operator|+=
literal|1
expr_stmt|;
comment|/* ignore length */
name|extended_op
operator|=
name|read_1_byte
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|1
expr_stmt|;
switch|switch
condition|(
name|extended_op
condition|)
block|{
case|case
name|DW_LNE_end_sequence
case|:
name|end_sequence
operator|=
literal|1
expr_stmt|;
name|record_line
argument_list|(
name|current_subfile
argument_list|,
name|line
argument_list|,
name|address
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LNE_set_address
case|:
name|address
operator|=
name|read_address
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
operator|+
name|baseaddr
expr_stmt|;
name|line_ptr
operator|+=
name|address_size
expr_stmt|;
break|break;
case|case
name|DW_LNE_define_file
case|:
name|cur_file
operator|=
name|read_string
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
operator|(
name|files
operator|.
name|num_files
operator|%
name|FILE_ALLOC_CHUNK
operator|)
operator|==
literal|0
condition|)
block|{
name|files
operator|.
name|files
operator|=
operator|(
expr|struct
name|fileinfo
operator|*
operator|)
name|xrealloc
argument_list|(
name|files
operator|.
name|files
argument_list|,
operator|(
name|files
operator|.
name|num_files
operator|+
name|FILE_ALLOC_CHUNK
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|fileinfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|files
operator|.
name|num_files
operator|==
literal|0
condition|)
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_current_contents
argument_list|,
operator|&
name|files
operator|.
name|files
argument_list|)
expr_stmt|;
block|}
name|files
operator|.
name|files
index|[
name|files
operator|.
name|num_files
index|]
operator|.
name|name
operator|=
name|cur_file
expr_stmt|;
name|files
operator|.
name|files
index|[
name|files
operator|.
name|num_files
index|]
operator|.
name|dir
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|files
operator|.
name|files
index|[
name|files
operator|.
name|num_files
index|]
operator|.
name|time
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|files
operator|.
name|files
index|[
name|files
operator|.
name|num_files
index|]
operator|.
name|size
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|files
operator|.
name|num_files
operator|++
expr_stmt|;
break|break;
default|default:
name|complain
argument_list|(
operator|&
name|dwarf2_mangled_line_number_section
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
break|break;
case|case
name|DW_LNS_copy
case|:
name|record_line
argument_list|(
name|current_subfile
argument_list|,
name|line
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|basic_block
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DW_LNS_advance_pc
case|:
name|address
operator|+=
name|lh
operator|.
name|minimum_instruction_length
operator|*
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_LNS_advance_line
case|:
name|line
operator|+=
name|read_signed_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_LNS_set_file
case|:
comment|/* The file and directory tables are 0 based, the references 		 are 1 based.  */
name|file
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
name|dwarf2_start_subfile
argument_list|(
name|files
operator|.
name|files
index|[
name|file
operator|-
literal|1
index|]
operator|.
name|name
argument_list|,
operator|(
name|files
operator|.
name|files
index|[
name|file
operator|-
literal|1
index|]
operator|.
name|dir
condition|?
name|dirs
operator|.
name|dirs
index|[
name|files
operator|.
name|files
index|[
name|file
operator|-
literal|1
index|]
operator|.
name|dir
operator|-
literal|1
index|]
else|:
name|comp_dir
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_LNS_set_column
case|:
name|column
operator|=
name|read_unsigned_leb128
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_LNS_negate_stmt
case|:
name|is_stmt
operator|=
operator|(
operator|!
name|is_stmt
operator|)
expr_stmt|;
break|break;
case|case
name|DW_LNS_set_basic_block
case|:
name|basic_block
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_LNS_const_add_pc
case|:
name|address
operator|+=
operator|(
literal|255
operator|-
name|lh
operator|.
name|opcode_base
operator|)
operator|/
name|lh
operator|.
name|line_range
expr_stmt|;
break|break;
case|case
name|DW_LNS_fixed_advance_pc
case|:
name|address
operator|+=
name|read_2_bytes
argument_list|(
name|abfd
argument_list|,
name|line_ptr
argument_list|)
expr_stmt|;
name|line_ptr
operator|+=
literal|2
expr_stmt|;
break|break;
default|default:
comment|/* special operand */
name|adj_opcode
operator|=
name|op_code
operator|-
name|lh
operator|.
name|opcode_base
expr_stmt|;
name|address
operator|+=
operator|(
name|adj_opcode
operator|/
name|lh
operator|.
name|line_range
operator|)
operator|*
name|lh
operator|.
name|minimum_instruction_length
expr_stmt|;
name|line
operator|+=
name|lh
operator|.
name|line_base
operator|+
operator|(
name|adj_opcode
operator|%
name|lh
operator|.
name|line_range
operator|)
expr_stmt|;
comment|/* append row to matrix using current values */
name|record_line
argument_list|(
name|current_subfile
argument_list|,
name|line
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|basic_block
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
name|done
label|:
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start a subfile for DWARF.  FILENAME is the name of the file and    DIRNAME the name of the source directory which contains FILENAME    or NULL if not known.    This routine tries to keep line numbers from identical absolute and    relative file names in a common subfile.     Using the `list' example from the GDB testsuite, which resides in    /srcdir and compiling it with Irix6.2 cc in /compdir using a filename    of /srcdir/list0.c yields the following debugging information for list0.c:  	DW_AT_name:		/srcdir/list0.c 	DW_AT_comp_dir:		/compdir 	files.files[0].name:	list0.h		 	files.files[0].dir:	/srcdir 	files.files[1].name:	list0.c		 	files.files[1].dir:	/srcdir     The line number information for list0.c has to end up in a single    subfile, so that `break /srcdir/list0.c:1' works as expected.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2_start_subfile
parameter_list|(
name|filename
parameter_list|,
name|dirname
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|dirname
decl_stmt|;
block|{
comment|/* If the filename isn't absolute, try to match an existing subfile      with the full pathname.  */
if|if
condition|(
operator|*
name|filename
operator|!=
literal|'/'
operator|&&
name|dirname
operator|!=
name|NULL
condition|)
block|{
name|struct
name|subfile
modifier|*
name|subfile
decl_stmt|;
name|char
modifier|*
name|fullname
init|=
name|concat
argument_list|(
name|dirname
argument_list|,
literal|"/"
argument_list|,
name|filename
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
for|for
control|(
name|subfile
operator|=
name|subfiles
init|;
name|subfile
condition|;
name|subfile
operator|=
name|subfile
operator|->
name|next
control|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|subfile
operator|->
name|name
argument_list|,
name|fullname
argument_list|)
condition|)
block|{
name|current_subfile
operator|=
name|subfile
expr_stmt|;
name|free
argument_list|(
name|fullname
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|free
argument_list|(
name|fullname
argument_list|)
expr_stmt|;
block|}
name|start_subfile
argument_list|(
name|filename
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a pointer to a DWARF information entry, figure out if we need    to make a symbol table entry for it, and if so, create a new entry    and return a pointer to it.    If TYPE is NULL, determine symbol type from the die, otherwise    used the passed type.   */
end_comment

begin_function
specifier|static
name|struct
name|symbol
modifier|*
name|new_symbol
parameter_list|(
name|die
parameter_list|,
name|type
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|die_info
modifier|*
name|die
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|symbol
modifier|*
name|sym
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|attribute
modifier|*
name|attr
init|=
name|NULL
decl_stmt|;
name|struct
name|attribute
modifier|*
name|attr2
init|=
name|NULL
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|name
operator|=
name|dwarf2_linkage_name
argument_list|(
name|die
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|sym
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|OBJSTAT
argument_list|(
name|objfile
argument_list|,
name|n_syms
operator|++
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|obsavestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
comment|/* Default assumptions. 	 Use the passed type or decode it from the die.  */
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_STATIC
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|NULL
condition|)
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|type
expr_stmt|;
else|else
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|die_type
argument_list|(
name|die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_decl_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|SYMBOL_LINE
argument_list|(
name|sym
argument_list|)
operator|=
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
expr_stmt|;
block|}
comment|/* If this symbol is from a C++ compilation, then attempt to          cache the demangled form for future reference.  This is a          typical time versus space tradeoff, that was decided in favor          of time because it sped up C++ symbol lookups by a factor of          about 20. */
name|SYMBOL_LANGUAGE
argument_list|(
name|sym
argument_list|)
operator|=
name|cu_language
expr_stmt|;
name|SYMBOL_INIT_DEMANGLED_NAME
argument_list|(
name|sym
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|die
operator|->
name|tag
condition|)
block|{
case|case
name|DW_TAG_label
case|:
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_low_pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|=
name|DW_ADDR
argument_list|(
name|attr
argument_list|)
operator|+
name|baseaddr
expr_stmt|;
block|}
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_LABEL
expr_stmt|;
break|break;
case|case
name|DW_TAG_subprogram
case|:
comment|/* SYMBOL_BLOCK_VALUE (sym) will be filled in later by 	     finish_block.  */
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_BLOCK
expr_stmt|;
name|attr2
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_external
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr2
operator|&&
operator|(
name|DW_UNSND
argument_list|(
name|attr2
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
name|list_in_scope
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DW_TAG_variable
case|:
comment|/* Compilation with minimal debug info may result in variables 	     with missing type entries. Change the misleading `void' type 	     to something sensible.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_VOID
condition|)
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|HOST_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"<variable, no debug info>"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_const_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|dwarf2_const_value
argument_list|(
name|attr
argument_list|,
name|sym
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|attr2
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_external
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr2
operator|&&
operator|(
name|DW_UNSND
argument_list|(
name|attr2
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
else|else
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
name|list_in_scope
argument_list|)
expr_stmt|;
break|break;
block|}
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_location
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|attr2
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_external
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr2
operator|&&
operator|(
name|DW_UNSND
argument_list|(
name|attr2
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|=
name|decode_locdesc
argument_list|(
name|DW_BLOCK
argument_list|(
name|attr
argument_list|)
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
comment|/* In shared libraries the address of the variable 		     in the location descriptor might still be relocatable, 		     so its value could be zero. 		     Enter the symbol as a LOC_UNRESOLVED symbol, if its 		     value is zero, the address of the variable will then 		     be determined from the minimal symbol table whenever 		     the variable is referenced.  */
if|if
condition|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
condition|)
block|{
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|+=
name|baseaddr
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_STATIC
expr_stmt|;
block|}
else|else
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_UNRESOLVED
expr_stmt|;
block|}
else|else
block|{
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|addr
operator|=
name|decode_locdesc
argument_list|(
name|DW_BLOCK
argument_list|(
name|attr
argument_list|)
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
name|list_in_scope
argument_list|)
expr_stmt|;
if|if
condition|(
name|optimized_out
condition|)
block|{
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_OPTIMIZED_OUT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isreg
condition|)
block|{
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_REGISTER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offreg
condition|)
block|{
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_BASEREG
expr_stmt|;
name|SYMBOL_BASEREG
argument_list|(
name|sym
argument_list|)
operator|=
name|basereg
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|islocal
condition|)
block|{
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_LOCAL
expr_stmt|;
block|}
else|else
block|{
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_STATIC
expr_stmt|;
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|=
name|addr
operator|+
name|baseaddr
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* We do not know the address of this symbol. 		 If it is an external symbol and we have type information 		 for it, enter the symbol as a LOC_UNRESOLVED symbol. 		 The address of the variable will then be determined from 		 the minimal symbol table whenever the variable is 		 referenced.  */
name|attr2
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_external
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr2
operator|&&
operator|(
name|DW_UNSND
argument_list|(
name|attr2
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_type
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_UNRESOLVED
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|DW_TAG_formal_parameter
case|:
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_location
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|decode_locdesc
argument_list|(
name|DW_BLOCK
argument_list|(
name|attr
argument_list|)
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|isreg
condition|)
block|{
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_REGPARM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offreg
condition|)
block|{
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_BASEREG_ARG
expr_stmt|;
name|SYMBOL_BASEREG
argument_list|(
name|sym
argument_list|)
operator|=
name|basereg
expr_stmt|;
block|}
else|else
block|{
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_ARG
expr_stmt|;
block|}
block|}
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_const_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|dwarf2_const_value
argument_list|(
name|attr
argument_list|,
name|sym
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
name|list_in_scope
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_unspecified_parameters
case|:
comment|/* From varargs functions; gdb doesn't seem to have any 	     interest in this information, so just ignore it for now. 	     (FIXME?) */
break|break;
case|case
name|DW_TAG_class_type
case|:
case|case
name|DW_TAG_structure_type
case|:
case|case
name|DW_TAG_union_type
case|:
case|case
name|DW_TAG_enumeration_type
case|:
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_TYPEDEF
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|STRUCT_NAMESPACE
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
name|list_in_scope
argument_list|)
expr_stmt|;
comment|/* The semantics of C++ state that "struct foo { ... }" also 	     defines a typedef for "foo". Synthesize a typedef symbol so 	     that "ptype foo" works as expected.  */
if|if
condition|(
name|cu_language
operator|==
name|language_cplus
condition|)
block|{
name|struct
name|symbol
modifier|*
name|typedef_sym
init|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
decl_stmt|;
operator|*
name|typedef_sym
operator|=
operator|*
name|sym
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|typedef_sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|=
name|obsavestring
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|)
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|typedef_sym
argument_list|,
name|list_in_scope
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DW_TAG_typedef
case|:
case|case
name|DW_TAG_base_type
case|:
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_TYPEDEF
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
name|list_in_scope
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_enumerator
case|:
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_const_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|dwarf2_const_value
argument_list|(
name|attr
argument_list|,
name|sym
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
name|list_in_scope
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Not a tag we recognize.  Hopefully we aren't processing 	     trash data, but since we must specifically ignore things 	     we don't recognize, there is nothing else we should do at 	     this point. */
name|complain
argument_list|(
operator|&
name|dwarf2_unsupported_tag
argument_list|,
name|dwarf_tag_name
argument_list|(
name|die
operator|->
name|tag
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|sym
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Copy constant value from an attribute to a symbol.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf2_const_value
parameter_list|(
name|attr
parameter_list|,
name|sym
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|attribute
modifier|*
name|attr
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|dwarf_block
modifier|*
name|blk
decl_stmt|;
switch|switch
condition|(
name|attr
operator|->
name|form
condition|)
block|{
case|case
name|DW_FORM_addr
case|:
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|!=
operator|(
name|unsigned
name|int
operator|)
name|address_size
condition|)
name|complain
argument_list|(
operator|&
name|dwarf2_const_value_length_mismatch
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|address_size
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE_BYTES
argument_list|(
name|sym
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
name|address_size
argument_list|)
expr_stmt|;
name|store_address
argument_list|(
name|SYMBOL_VALUE_BYTES
argument_list|(
name|sym
argument_list|)
argument_list|,
name|address_size
argument_list|,
name|DW_ADDR
argument_list|(
name|attr
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_CONST_BYTES
expr_stmt|;
break|break;
case|case
name|DW_FORM_block1
case|:
case|case
name|DW_FORM_block2
case|:
case|case
name|DW_FORM_block4
case|:
case|case
name|DW_FORM_block
case|:
name|blk
operator|=
name|DW_BLOCK
argument_list|(
name|attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator|!=
name|blk
operator|->
name|size
condition|)
name|complain
argument_list|(
operator|&
name|dwarf2_const_value_length_mismatch
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|blk
operator|->
name|size
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE_BYTES
argument_list|(
name|sym
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
name|blk
operator|->
name|size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|SYMBOL_VALUE_BYTES
argument_list|(
name|sym
argument_list|)
argument_list|,
name|blk
operator|->
name|data
argument_list|,
name|blk
operator|->
name|size
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_CONST_BYTES
expr_stmt|;
break|break;
case|case
name|DW_FORM_data2
case|:
case|case
name|DW_FORM_data4
case|:
case|case
name|DW_FORM_data8
case|:
case|case
name|DW_FORM_data1
case|:
case|case
name|DW_FORM_sdata
case|:
case|case
name|DW_FORM_udata
case|:
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_CONST
expr_stmt|;
break|break;
default|default:
name|complain
argument_list|(
operator|&
name|dwarf2_unsupported_const_value_attr
argument_list|,
name|dwarf_form_name
argument_list|(
name|attr
operator|->
name|form
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_CONST
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Return the type of the die in question using its DW_AT_type attribute.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|die_type
parameter_list|(
name|die
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|die_info
modifier|*
name|die
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|attribute
modifier|*
name|type_attr
decl_stmt|;
name|struct
name|die_info
modifier|*
name|type_die
decl_stmt|;
name|unsigned
name|int
name|ref
decl_stmt|;
name|type_attr
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type_attr
condition|)
block|{
comment|/* A missing DW_AT_type represents a void type.  */
return|return
name|dwarf2_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_VOID
argument_list|)
return|;
block|}
else|else
block|{
name|ref
operator|=
name|dwarf2_get_ref_die_offset
argument_list|(
name|type_attr
argument_list|)
expr_stmt|;
name|type_die
operator|=
name|follow_die_ref
argument_list|(
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type_die
condition|)
block|{
name|error
argument_list|(
literal|"Dwarf Error: Cannot find referent at offset %d."
argument_list|,
name|ref
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|type
operator|=
name|tag_type_to_type
argument_list|(
name|type_die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type
condition|)
block|{
name|dump_die
argument_list|(
name|type_die
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Dwarf Error: Problem turning type die at offset into gdb type."
argument_list|)
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Return the containing type of the die in question using its    DW_AT_containing_type attribute.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|die_containing_type
parameter_list|(
name|die
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|die_info
modifier|*
name|die
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|NULL
decl_stmt|;
name|struct
name|attribute
modifier|*
name|type_attr
decl_stmt|;
name|struct
name|die_info
modifier|*
name|type_die
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|ref
decl_stmt|;
name|type_attr
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_containing_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_attr
condition|)
block|{
name|ref
operator|=
name|dwarf2_get_ref_die_offset
argument_list|(
name|type_attr
argument_list|)
expr_stmt|;
name|type_die
operator|=
name|follow_die_ref
argument_list|(
name|ref
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|type_die
condition|)
block|{
name|error
argument_list|(
literal|"Dwarf Error: Cannot find referent at offset %d."
argument_list|,
name|ref
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|type
operator|=
name|tag_type_to_type
argument_list|(
name|type_die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|type
condition|)
block|{
if|if
condition|(
name|type_die
condition|)
name|dump_die
argument_list|(
name|type_die
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Dwarf Error: Problem turning containing type into gdb type."
argument_list|)
expr_stmt|;
block|}
return|return
name|type
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static struct type * type_at_offset (offset, objfile)      unsigned int offset;      struct objfile *objfile; {   struct die_info *die;   struct type *type;    die = follow_die_ref (offset);   if (!die)     {       error ("Dwarf Error: Cannot find type referent at offset %d.", offset);       return NULL;     }   type = tag_type_to_type (die, objfile);   return type; }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|struct
name|type
modifier|*
name|tag_type_to_type
parameter_list|(
name|die
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|die_info
modifier|*
name|die
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
if|if
condition|(
name|die
operator|->
name|type
condition|)
block|{
return|return
name|die
operator|->
name|type
return|;
block|}
else|else
block|{
name|read_type_die
argument_list|(
name|die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|die
operator|->
name|type
condition|)
block|{
name|dump_die
argument_list|(
name|die
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Dwarf Error: Cannot find type of die."
argument_list|)
expr_stmt|;
block|}
return|return
name|die
operator|->
name|type
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|read_type_die
parameter_list|(
name|die
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|die_info
modifier|*
name|die
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
switch|switch
condition|(
name|die
operator|->
name|tag
condition|)
block|{
case|case
name|DW_TAG_class_type
case|:
case|case
name|DW_TAG_structure_type
case|:
case|case
name|DW_TAG_union_type
case|:
name|read_structure_scope
argument_list|(
name|die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_enumeration_type
case|:
name|read_enumeration
argument_list|(
name|die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_subprogram
case|:
case|case
name|DW_TAG_subroutine_type
case|:
name|read_subroutine_type
argument_list|(
name|die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_array_type
case|:
name|read_array_type
argument_list|(
name|die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_pointer_type
case|:
name|read_tag_pointer_type
argument_list|(
name|die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_ptr_to_member_type
case|:
name|read_tag_ptr_to_member_type
argument_list|(
name|die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_reference_type
case|:
name|read_tag_reference_type
argument_list|(
name|die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_const_type
case|:
name|read_tag_const_type
argument_list|(
name|die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_volatile_type
case|:
name|read_tag_volatile_type
argument_list|(
name|die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_string_type
case|:
name|read_tag_string_type
argument_list|(
name|die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_typedef
case|:
name|read_typedef
argument_list|(
name|die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_TAG_base_type
case|:
name|read_base_type
argument_list|(
name|die
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
default|default:
name|complain
argument_list|(
operator|&
name|dwarf2_unexpected_tag
argument_list|,
name|dwarf_tag_name
argument_list|(
name|die
operator|->
name|tag
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|type
modifier|*
name|dwarf_base_type
parameter_list|(
name|encoding
parameter_list|,
name|size
parameter_list|,
name|objfile
parameter_list|)
name|int
name|encoding
decl_stmt|;
name|int
name|size
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
comment|/* FIXME - this should not produce a new (struct type *)      every time.  It should cache base types.  */
name|struct
name|type
modifier|*
name|type
decl_stmt|;
switch|switch
condition|(
name|encoding
condition|)
block|{
case|case
name|DW_ATE_address
case|:
name|type
operator|=
name|dwarf2_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_VOID
argument_list|)
expr_stmt|;
return|return
name|type
return|;
case|case
name|DW_ATE_boolean
case|:
name|type
operator|=
name|dwarf2_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_BOOLEAN
argument_list|)
expr_stmt|;
return|return
name|type
return|;
case|case
name|DW_ATE_complex_float
case|:
if|if
condition|(
name|size
operator|==
literal|16
condition|)
block|{
name|type
operator|=
name|dwarf2_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_DBL_PREC_COMPLEX
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|dwarf2_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_COMPLEX
argument_list|)
expr_stmt|;
block|}
return|return
name|type
return|;
case|case
name|DW_ATE_float
case|:
if|if
condition|(
name|size
operator|==
literal|8
condition|)
block|{
name|type
operator|=
name|dwarf2_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_DBL_PREC_FLOAT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|dwarf2_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_FLOAT
argument_list|)
expr_stmt|;
block|}
return|return
name|type
return|;
case|case
name|DW_ATE_signed
case|:
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
name|type
operator|=
name|dwarf2_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_SIGNED_CHAR
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|type
operator|=
name|dwarf2_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_SIGNED_SHORT
argument_list|)
expr_stmt|;
break|break;
default|default:
case|case
literal|4
case|:
name|type
operator|=
name|dwarf2_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_SIGNED_INTEGER
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|type
return|;
case|case
name|DW_ATE_signed_char
case|:
name|type
operator|=
name|dwarf2_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_SIGNED_CHAR
argument_list|)
expr_stmt|;
return|return
name|type
return|;
case|case
name|DW_ATE_unsigned
case|:
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
name|type
operator|=
name|dwarf2_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_UNSIGNED_CHAR
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|type
operator|=
name|dwarf2_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_UNSIGNED_SHORT
argument_list|)
expr_stmt|;
break|break;
default|default:
case|case
literal|4
case|:
name|type
operator|=
name|dwarf2_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_UNSIGNED_INTEGER
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|type
return|;
case|case
name|DW_ATE_unsigned_char
case|:
name|type
operator|=
name|dwarf2_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_UNSIGNED_CHAR
argument_list|)
expr_stmt|;
return|return
name|type
return|;
default|default:
name|type
operator|=
name|dwarf2_fundamental_type
argument_list|(
name|objfile
argument_list|,
name|FT_SIGNED_INTEGER
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|struct die_info * copy_die (old_die)      struct die_info *old_die; {   struct die_info *new_die;   int i, num_attrs;    new_die = (struct die_info *) xmalloc (sizeof (struct die_info));   memset (new_die, 0, sizeof (struct die_info));    new_die->tag = old_die->tag;   new_die->has_children = old_die->has_children;   new_die->abbrev = old_die->abbrev;   new_die->offset = old_die->offset;   new_die->type = NULL;    num_attrs = old_die->num_attrs;   new_die->num_attrs = num_attrs;   new_die->attrs = (struct attribute *)     xmalloc (num_attrs * sizeof (struct attribute));    for (i = 0; i< old_die->num_attrs; ++i)     {       new_die->attrs[i].name = old_die->attrs[i].name;       new_die->attrs[i].form = old_die->attrs[i].form;       new_die->attrs[i].u.addr = old_die->attrs[i].u.addr;     }    new_die->next = NULL;   return new_die; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Return sibling of die, NULL if no sibling.  */
end_comment

begin_function
name|struct
name|die_info
modifier|*
name|sibling_die
parameter_list|(
name|die
parameter_list|)
name|struct
name|die_info
modifier|*
name|die
decl_stmt|;
block|{
name|int
name|nesting_level
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|die
operator|->
name|has_children
condition|)
block|{
if|if
condition|(
name|die
operator|->
name|next
operator|&&
operator|(
name|die
operator|->
name|next
operator|->
name|tag
operator|==
literal|0
operator|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
else|else
block|{
return|return
name|die
operator|->
name|next
return|;
block|}
block|}
else|else
block|{
do|do
block|{
if|if
condition|(
name|die
operator|->
name|has_children
condition|)
block|{
name|nesting_level
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|die
operator|->
name|tag
operator|==
literal|0
condition|)
block|{
name|nesting_level
operator|--
expr_stmt|;
block|}
name|die
operator|=
name|die
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|nesting_level
condition|)
do|;
if|if
condition|(
name|die
operator|&&
operator|(
name|die
operator|->
name|tag
operator|==
literal|0
operator|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
else|else
block|{
return|return
name|die
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Get linkage name of a die, return NULL if not found.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|dwarf2_linkage_name
parameter_list|(
name|die
parameter_list|)
name|struct
name|die_info
modifier|*
name|die
decl_stmt|;
block|{
name|struct
name|attribute
modifier|*
name|attr
decl_stmt|;
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_MIPS_linkage_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|&&
name|DW_STRING
argument_list|(
name|attr
argument_list|)
condition|)
return|return
name|DW_STRING
argument_list|(
name|attr
argument_list|)
return|;
name|attr
operator|=
name|dwarf_attr
argument_list|(
name|die
argument_list|,
name|DW_AT_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
operator|&&
name|DW_STRING
argument_list|(
name|attr
argument_list|)
condition|)
return|return
name|DW_STRING
argument_list|(
name|attr
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Convert a DIE tag into its string name.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|dwarf_tag_name
parameter_list|(
name|tag
parameter_list|)
specifier|register
name|unsigned
name|tag
decl_stmt|;
block|{
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|DW_TAG_padding
case|:
return|return
literal|"DW_TAG_padding"
return|;
case|case
name|DW_TAG_array_type
case|:
return|return
literal|"DW_TAG_array_type"
return|;
case|case
name|DW_TAG_class_type
case|:
return|return
literal|"DW_TAG_class_type"
return|;
case|case
name|DW_TAG_entry_point
case|:
return|return
literal|"DW_TAG_entry_point"
return|;
case|case
name|DW_TAG_enumeration_type
case|:
return|return
literal|"DW_TAG_enumeration_type"
return|;
case|case
name|DW_TAG_formal_parameter
case|:
return|return
literal|"DW_TAG_formal_parameter"
return|;
case|case
name|DW_TAG_imported_declaration
case|:
return|return
literal|"DW_TAG_imported_declaration"
return|;
case|case
name|DW_TAG_label
case|:
return|return
literal|"DW_TAG_label"
return|;
case|case
name|DW_TAG_lexical_block
case|:
return|return
literal|"DW_TAG_lexical_block"
return|;
case|case
name|DW_TAG_member
case|:
return|return
literal|"DW_TAG_member"
return|;
case|case
name|DW_TAG_pointer_type
case|:
return|return
literal|"DW_TAG_pointer_type"
return|;
case|case
name|DW_TAG_reference_type
case|:
return|return
literal|"DW_TAG_reference_type"
return|;
case|case
name|DW_TAG_compile_unit
case|:
return|return
literal|"DW_TAG_compile_unit"
return|;
case|case
name|DW_TAG_string_type
case|:
return|return
literal|"DW_TAG_string_type"
return|;
case|case
name|DW_TAG_structure_type
case|:
return|return
literal|"DW_TAG_structure_type"
return|;
case|case
name|DW_TAG_subroutine_type
case|:
return|return
literal|"DW_TAG_subroutine_type"
return|;
case|case
name|DW_TAG_typedef
case|:
return|return
literal|"DW_TAG_typedef"
return|;
case|case
name|DW_TAG_union_type
case|:
return|return
literal|"DW_TAG_union_type"
return|;
case|case
name|DW_TAG_unspecified_parameters
case|:
return|return
literal|"DW_TAG_unspecified_parameters"
return|;
case|case
name|DW_TAG_variant
case|:
return|return
literal|"DW_TAG_variant"
return|;
case|case
name|DW_TAG_common_block
case|:
return|return
literal|"DW_TAG_common_block"
return|;
case|case
name|DW_TAG_common_inclusion
case|:
return|return
literal|"DW_TAG_common_inclusion"
return|;
case|case
name|DW_TAG_inheritance
case|:
return|return
literal|"DW_TAG_inheritance"
return|;
case|case
name|DW_TAG_inlined_subroutine
case|:
return|return
literal|"DW_TAG_inlined_subroutine"
return|;
case|case
name|DW_TAG_module
case|:
return|return
literal|"DW_TAG_module"
return|;
case|case
name|DW_TAG_ptr_to_member_type
case|:
return|return
literal|"DW_TAG_ptr_to_member_type"
return|;
case|case
name|DW_TAG_set_type
case|:
return|return
literal|"DW_TAG_set_type"
return|;
case|case
name|DW_TAG_subrange_type
case|:
return|return
literal|"DW_TAG_subrange_type"
return|;
case|case
name|DW_TAG_with_stmt
case|:
return|return
literal|"DW_TAG_with_stmt"
return|;
case|case
name|DW_TAG_access_declaration
case|:
return|return
literal|"DW_TAG_access_declaration"
return|;
case|case
name|DW_TAG_base_type
case|:
return|return
literal|"DW_TAG_base_type"
return|;
case|case
name|DW_TAG_catch_block
case|:
return|return
literal|"DW_TAG_catch_block"
return|;
case|case
name|DW_TAG_const_type
case|:
return|return
literal|"DW_TAG_const_type"
return|;
case|case
name|DW_TAG_constant
case|:
return|return
literal|"DW_TAG_constant"
return|;
case|case
name|DW_TAG_enumerator
case|:
return|return
literal|"DW_TAG_enumerator"
return|;
case|case
name|DW_TAG_file_type
case|:
return|return
literal|"DW_TAG_file_type"
return|;
case|case
name|DW_TAG_friend
case|:
return|return
literal|"DW_TAG_friend"
return|;
case|case
name|DW_TAG_namelist
case|:
return|return
literal|"DW_TAG_namelist"
return|;
case|case
name|DW_TAG_namelist_item
case|:
return|return
literal|"DW_TAG_namelist_item"
return|;
case|case
name|DW_TAG_packed_type
case|:
return|return
literal|"DW_TAG_packed_type"
return|;
case|case
name|DW_TAG_subprogram
case|:
return|return
literal|"DW_TAG_subprogram"
return|;
case|case
name|DW_TAG_template_type_param
case|:
return|return
literal|"DW_TAG_template_type_param"
return|;
case|case
name|DW_TAG_template_value_param
case|:
return|return
literal|"DW_TAG_template_value_param"
return|;
case|case
name|DW_TAG_thrown_type
case|:
return|return
literal|"DW_TAG_thrown_type"
return|;
case|case
name|DW_TAG_try_block
case|:
return|return
literal|"DW_TAG_try_block"
return|;
case|case
name|DW_TAG_variant_part
case|:
return|return
literal|"DW_TAG_variant_part"
return|;
case|case
name|DW_TAG_variable
case|:
return|return
literal|"DW_TAG_variable"
return|;
case|case
name|DW_TAG_volatile_type
case|:
return|return
literal|"DW_TAG_volatile_type"
return|;
case|case
name|DW_TAG_MIPS_loop
case|:
return|return
literal|"DW_TAG_MIPS_loop"
return|;
case|case
name|DW_TAG_format_label
case|:
return|return
literal|"DW_TAG_format_label"
return|;
case|case
name|DW_TAG_function_template
case|:
return|return
literal|"DW_TAG_function_template"
return|;
case|case
name|DW_TAG_class_template
case|:
return|return
literal|"DW_TAG_class_template"
return|;
default|default:
return|return
literal|"DW_TAG_<unknown>"
return|;
block|}
block|}
end_function

begin_comment
comment|/* Convert a DWARF attribute code into its string name.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|dwarf_attr_name
parameter_list|(
name|attr
parameter_list|)
specifier|register
name|unsigned
name|attr
decl_stmt|;
block|{
switch|switch
condition|(
name|attr
condition|)
block|{
case|case
name|DW_AT_sibling
case|:
return|return
literal|"DW_AT_sibling"
return|;
case|case
name|DW_AT_location
case|:
return|return
literal|"DW_AT_location"
return|;
case|case
name|DW_AT_name
case|:
return|return
literal|"DW_AT_name"
return|;
case|case
name|DW_AT_ordering
case|:
return|return
literal|"DW_AT_ordering"
return|;
case|case
name|DW_AT_subscr_data
case|:
return|return
literal|"DW_AT_subscr_data"
return|;
case|case
name|DW_AT_byte_size
case|:
return|return
literal|"DW_AT_byte_size"
return|;
case|case
name|DW_AT_bit_offset
case|:
return|return
literal|"DW_AT_bit_offset"
return|;
case|case
name|DW_AT_bit_size
case|:
return|return
literal|"DW_AT_bit_size"
return|;
case|case
name|DW_AT_element_list
case|:
return|return
literal|"DW_AT_element_list"
return|;
case|case
name|DW_AT_stmt_list
case|:
return|return
literal|"DW_AT_stmt_list"
return|;
case|case
name|DW_AT_low_pc
case|:
return|return
literal|"DW_AT_low_pc"
return|;
case|case
name|DW_AT_high_pc
case|:
return|return
literal|"DW_AT_high_pc"
return|;
case|case
name|DW_AT_language
case|:
return|return
literal|"DW_AT_language"
return|;
case|case
name|DW_AT_member
case|:
return|return
literal|"DW_AT_member"
return|;
case|case
name|DW_AT_discr
case|:
return|return
literal|"DW_AT_discr"
return|;
case|case
name|DW_AT_discr_value
case|:
return|return
literal|"DW_AT_discr_value"
return|;
case|case
name|DW_AT_visibility
case|:
return|return
literal|"DW_AT_visibility"
return|;
case|case
name|DW_AT_import
case|:
return|return
literal|"DW_AT_import"
return|;
case|case
name|DW_AT_string_length
case|:
return|return
literal|"DW_AT_string_length"
return|;
case|case
name|DW_AT_common_reference
case|:
return|return
literal|"DW_AT_common_reference"
return|;
case|case
name|DW_AT_comp_dir
case|:
return|return
literal|"DW_AT_comp_dir"
return|;
case|case
name|DW_AT_const_value
case|:
return|return
literal|"DW_AT_const_value"
return|;
case|case
name|DW_AT_containing_type
case|:
return|return
literal|"DW_AT_containing_type"
return|;
case|case
name|DW_AT_default_value
case|:
return|return
literal|"DW_AT_default_value"
return|;
case|case
name|DW_AT_inline
case|:
return|return
literal|"DW_AT_inline"
return|;
case|case
name|DW_AT_is_optional
case|:
return|return
literal|"DW_AT_is_optional"
return|;
case|case
name|DW_AT_lower_bound
case|:
return|return
literal|"DW_AT_lower_bound"
return|;
case|case
name|DW_AT_producer
case|:
return|return
literal|"DW_AT_producer"
return|;
case|case
name|DW_AT_prototyped
case|:
return|return
literal|"DW_AT_prototyped"
return|;
case|case
name|DW_AT_return_addr
case|:
return|return
literal|"DW_AT_return_addr"
return|;
case|case
name|DW_AT_start_scope
case|:
return|return
literal|"DW_AT_start_scope"
return|;
case|case
name|DW_AT_stride_size
case|:
return|return
literal|"DW_AT_stride_size"
return|;
case|case
name|DW_AT_upper_bound
case|:
return|return
literal|"DW_AT_upper_bound"
return|;
case|case
name|DW_AT_abstract_origin
case|:
return|return
literal|"DW_AT_abstract_origin"
return|;
case|case
name|DW_AT_accessibility
case|:
return|return
literal|"DW_AT_accessibility"
return|;
case|case
name|DW_AT_address_class
case|:
return|return
literal|"DW_AT_address_class"
return|;
case|case
name|DW_AT_artificial
case|:
return|return
literal|"DW_AT_artificial"
return|;
case|case
name|DW_AT_base_types
case|:
return|return
literal|"DW_AT_base_types"
return|;
case|case
name|DW_AT_calling_convention
case|:
return|return
literal|"DW_AT_calling_convention"
return|;
case|case
name|DW_AT_count
case|:
return|return
literal|"DW_AT_count"
return|;
case|case
name|DW_AT_data_member_location
case|:
return|return
literal|"DW_AT_data_member_location"
return|;
case|case
name|DW_AT_decl_column
case|:
return|return
literal|"DW_AT_decl_column"
return|;
case|case
name|DW_AT_decl_file
case|:
return|return
literal|"DW_AT_decl_file"
return|;
case|case
name|DW_AT_decl_line
case|:
return|return
literal|"DW_AT_decl_line"
return|;
case|case
name|DW_AT_declaration
case|:
return|return
literal|"DW_AT_declaration"
return|;
case|case
name|DW_AT_discr_list
case|:
return|return
literal|"DW_AT_discr_list"
return|;
case|case
name|DW_AT_encoding
case|:
return|return
literal|"DW_AT_encoding"
return|;
case|case
name|DW_AT_external
case|:
return|return
literal|"DW_AT_external"
return|;
case|case
name|DW_AT_frame_base
case|:
return|return
literal|"DW_AT_frame_base"
return|;
case|case
name|DW_AT_friend
case|:
return|return
literal|"DW_AT_friend"
return|;
case|case
name|DW_AT_identifier_case
case|:
return|return
literal|"DW_AT_identifier_case"
return|;
case|case
name|DW_AT_macro_info
case|:
return|return
literal|"DW_AT_macro_info"
return|;
case|case
name|DW_AT_namelist_items
case|:
return|return
literal|"DW_AT_namelist_items"
return|;
case|case
name|DW_AT_priority
case|:
return|return
literal|"DW_AT_priority"
return|;
case|case
name|DW_AT_segment
case|:
return|return
literal|"DW_AT_segment"
return|;
case|case
name|DW_AT_specification
case|:
return|return
literal|"DW_AT_specification"
return|;
case|case
name|DW_AT_static_link
case|:
return|return
literal|"DW_AT_static_link"
return|;
case|case
name|DW_AT_type
case|:
return|return
literal|"DW_AT_type"
return|;
case|case
name|DW_AT_use_location
case|:
return|return
literal|"DW_AT_use_location"
return|;
case|case
name|DW_AT_variable_parameter
case|:
return|return
literal|"DW_AT_variable_parameter"
return|;
case|case
name|DW_AT_virtuality
case|:
return|return
literal|"DW_AT_virtuality"
return|;
case|case
name|DW_AT_vtable_elem_location
case|:
return|return
literal|"DW_AT_vtable_elem_location"
return|;
ifdef|#
directive|ifdef
name|MIPS
case|case
name|DW_AT_MIPS_fde
case|:
return|return
literal|"DW_AT_MIPS_fde"
return|;
case|case
name|DW_AT_MIPS_loop_begin
case|:
return|return
literal|"DW_AT_MIPS_loop_begin"
return|;
case|case
name|DW_AT_MIPS_tail_loop_begin
case|:
return|return
literal|"DW_AT_MIPS_tail_loop_begin"
return|;
case|case
name|DW_AT_MIPS_epilog_begin
case|:
return|return
literal|"DW_AT_MIPS_epilog_begin"
return|;
case|case
name|DW_AT_MIPS_loop_unroll_factor
case|:
return|return
literal|"DW_AT_MIPS_loop_unroll_factor"
return|;
case|case
name|DW_AT_MIPS_software_pipeline_depth
case|:
return|return
literal|"DW_AT_MIPS_software_pipeline_depth"
return|;
case|case
name|DW_AT_MIPS_linkage_name
case|:
return|return
literal|"DW_AT_MIPS_linkage_name"
return|;
endif|#
directive|endif
case|case
name|DW_AT_sf_names
case|:
return|return
literal|"DW_AT_sf_names"
return|;
case|case
name|DW_AT_src_info
case|:
return|return
literal|"DW_AT_src_info"
return|;
case|case
name|DW_AT_mac_info
case|:
return|return
literal|"DW_AT_mac_info"
return|;
case|case
name|DW_AT_src_coords
case|:
return|return
literal|"DW_AT_src_coords"
return|;
case|case
name|DW_AT_body_begin
case|:
return|return
literal|"DW_AT_body_begin"
return|;
case|case
name|DW_AT_body_end
case|:
return|return
literal|"DW_AT_body_end"
return|;
default|default:
return|return
literal|"DW_AT_<unknown>"
return|;
block|}
block|}
end_function

begin_comment
comment|/* Convert a DWARF value form code into its string name.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|dwarf_form_name
parameter_list|(
name|form
parameter_list|)
specifier|register
name|unsigned
name|form
decl_stmt|;
block|{
switch|switch
condition|(
name|form
condition|)
block|{
case|case
name|DW_FORM_addr
case|:
return|return
literal|"DW_FORM_addr"
return|;
case|case
name|DW_FORM_block2
case|:
return|return
literal|"DW_FORM_block2"
return|;
case|case
name|DW_FORM_block4
case|:
return|return
literal|"DW_FORM_block4"
return|;
case|case
name|DW_FORM_data2
case|:
return|return
literal|"DW_FORM_data2"
return|;
case|case
name|DW_FORM_data4
case|:
return|return
literal|"DW_FORM_data4"
return|;
case|case
name|DW_FORM_data8
case|:
return|return
literal|"DW_FORM_data8"
return|;
case|case
name|DW_FORM_string
case|:
return|return
literal|"DW_FORM_string"
return|;
case|case
name|DW_FORM_block
case|:
return|return
literal|"DW_FORM_block"
return|;
case|case
name|DW_FORM_block1
case|:
return|return
literal|"DW_FORM_block1"
return|;
case|case
name|DW_FORM_data1
case|:
return|return
literal|"DW_FORM_data1"
return|;
case|case
name|DW_FORM_flag
case|:
return|return
literal|"DW_FORM_flag"
return|;
case|case
name|DW_FORM_sdata
case|:
return|return
literal|"DW_FORM_sdata"
return|;
case|case
name|DW_FORM_strp
case|:
return|return
literal|"DW_FORM_strp"
return|;
case|case
name|DW_FORM_udata
case|:
return|return
literal|"DW_FORM_udata"
return|;
case|case
name|DW_FORM_ref_addr
case|:
return|return
literal|"DW_FORM_ref_addr"
return|;
case|case
name|DW_FORM_ref1
case|:
return|return
literal|"DW_FORM_ref1"
return|;
case|case
name|DW_FORM_ref2
case|:
return|return
literal|"DW_FORM_ref2"
return|;
case|case
name|DW_FORM_ref4
case|:
return|return
literal|"DW_FORM_ref4"
return|;
case|case
name|DW_FORM_ref8
case|:
return|return
literal|"DW_FORM_ref8"
return|;
case|case
name|DW_FORM_ref_udata
case|:
return|return
literal|"DW_FORM_ref_udata"
return|;
case|case
name|DW_FORM_indirect
case|:
return|return
literal|"DW_FORM_indirect"
return|;
default|default:
return|return
literal|"DW_FORM_<unknown>"
return|;
block|}
block|}
end_function

begin_comment
comment|/* Convert a DWARF stack opcode into its string name.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|dwarf_stack_op_name
parameter_list|(
name|op
parameter_list|)
specifier|register
name|unsigned
name|op
decl_stmt|;
block|{
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|DW_OP_addr
case|:
return|return
literal|"DW_OP_addr"
return|;
case|case
name|DW_OP_deref
case|:
return|return
literal|"DW_OP_deref"
return|;
case|case
name|DW_OP_const1u
case|:
return|return
literal|"DW_OP_const1u"
return|;
case|case
name|DW_OP_const1s
case|:
return|return
literal|"DW_OP_const1s"
return|;
case|case
name|DW_OP_const2u
case|:
return|return
literal|"DW_OP_const2u"
return|;
case|case
name|DW_OP_const2s
case|:
return|return
literal|"DW_OP_const2s"
return|;
case|case
name|DW_OP_const4u
case|:
return|return
literal|"DW_OP_const4u"
return|;
case|case
name|DW_OP_const4s
case|:
return|return
literal|"DW_OP_const4s"
return|;
case|case
name|DW_OP_const8u
case|:
return|return
literal|"DW_OP_const8u"
return|;
case|case
name|DW_OP_const8s
case|:
return|return
literal|"DW_OP_const8s"
return|;
case|case
name|DW_OP_constu
case|:
return|return
literal|"DW_OP_constu"
return|;
case|case
name|DW_OP_consts
case|:
return|return
literal|"DW_OP_consts"
return|;
case|case
name|DW_OP_dup
case|:
return|return
literal|"DW_OP_dup"
return|;
case|case
name|DW_OP_drop
case|:
return|return
literal|"DW_OP_drop"
return|;
case|case
name|DW_OP_over
case|:
return|return
literal|"DW_OP_over"
return|;
case|case
name|DW_OP_pick
case|:
return|return
literal|"DW_OP_pick"
return|;
case|case
name|DW_OP_swap
case|:
return|return
literal|"DW_OP_swap"
return|;
case|case
name|DW_OP_rot
case|:
return|return
literal|"DW_OP_rot"
return|;
case|case
name|DW_OP_xderef
case|:
return|return
literal|"DW_OP_xderef"
return|;
case|case
name|DW_OP_abs
case|:
return|return
literal|"DW_OP_abs"
return|;
case|case
name|DW_OP_and
case|:
return|return
literal|"DW_OP_and"
return|;
case|case
name|DW_OP_div
case|:
return|return
literal|"DW_OP_div"
return|;
case|case
name|DW_OP_minus
case|:
return|return
literal|"DW_OP_minus"
return|;
case|case
name|DW_OP_mod
case|:
return|return
literal|"DW_OP_mod"
return|;
case|case
name|DW_OP_mul
case|:
return|return
literal|"DW_OP_mul"
return|;
case|case
name|DW_OP_neg
case|:
return|return
literal|"DW_OP_neg"
return|;
case|case
name|DW_OP_not
case|:
return|return
literal|"DW_OP_not"
return|;
case|case
name|DW_OP_or
case|:
return|return
literal|"DW_OP_or"
return|;
case|case
name|DW_OP_plus
case|:
return|return
literal|"DW_OP_plus"
return|;
case|case
name|DW_OP_plus_uconst
case|:
return|return
literal|"DW_OP_plus_uconst"
return|;
case|case
name|DW_OP_shl
case|:
return|return
literal|"DW_OP_shl"
return|;
case|case
name|DW_OP_shr
case|:
return|return
literal|"DW_OP_shr"
return|;
case|case
name|DW_OP_shra
case|:
return|return
literal|"DW_OP_shra"
return|;
case|case
name|DW_OP_xor
case|:
return|return
literal|"DW_OP_xor"
return|;
case|case
name|DW_OP_bra
case|:
return|return
literal|"DW_OP_bra"
return|;
case|case
name|DW_OP_eq
case|:
return|return
literal|"DW_OP_eq"
return|;
case|case
name|DW_OP_ge
case|:
return|return
literal|"DW_OP_ge"
return|;
case|case
name|DW_OP_gt
case|:
return|return
literal|"DW_OP_gt"
return|;
case|case
name|DW_OP_le
case|:
return|return
literal|"DW_OP_le"
return|;
case|case
name|DW_OP_lt
case|:
return|return
literal|"DW_OP_lt"
return|;
case|case
name|DW_OP_ne
case|:
return|return
literal|"DW_OP_ne"
return|;
case|case
name|DW_OP_skip
case|:
return|return
literal|"DW_OP_skip"
return|;
case|case
name|DW_OP_lit0
case|:
return|return
literal|"DW_OP_lit0"
return|;
case|case
name|DW_OP_lit1
case|:
return|return
literal|"DW_OP_lit1"
return|;
case|case
name|DW_OP_lit2
case|:
return|return
literal|"DW_OP_lit2"
return|;
case|case
name|DW_OP_lit3
case|:
return|return
literal|"DW_OP_lit3"
return|;
case|case
name|DW_OP_lit4
case|:
return|return
literal|"DW_OP_lit4"
return|;
case|case
name|DW_OP_lit5
case|:
return|return
literal|"DW_OP_lit5"
return|;
case|case
name|DW_OP_lit6
case|:
return|return
literal|"DW_OP_lit6"
return|;
case|case
name|DW_OP_lit7
case|:
return|return
literal|"DW_OP_lit7"
return|;
case|case
name|DW_OP_lit8
case|:
return|return
literal|"DW_OP_lit8"
return|;
case|case
name|DW_OP_lit9
case|:
return|return
literal|"DW_OP_lit9"
return|;
case|case
name|DW_OP_lit10
case|:
return|return
literal|"DW_OP_lit10"
return|;
case|case
name|DW_OP_lit11
case|:
return|return
literal|"DW_OP_lit11"
return|;
case|case
name|DW_OP_lit12
case|:
return|return
literal|"DW_OP_lit12"
return|;
case|case
name|DW_OP_lit13
case|:
return|return
literal|"DW_OP_lit13"
return|;
case|case
name|DW_OP_lit14
case|:
return|return
literal|"DW_OP_lit14"
return|;
case|case
name|DW_OP_lit15
case|:
return|return
literal|"DW_OP_lit15"
return|;
case|case
name|DW_OP_lit16
case|:
return|return
literal|"DW_OP_lit16"
return|;
case|case
name|DW_OP_lit17
case|:
return|return
literal|"DW_OP_lit17"
return|;
case|case
name|DW_OP_lit18
case|:
return|return
literal|"DW_OP_lit18"
return|;
case|case
name|DW_OP_lit19
case|:
return|return
literal|"DW_OP_lit19"
return|;
case|case
name|DW_OP_lit20
case|:
return|return
literal|"DW_OP_lit20"
return|;
case|case
name|DW_OP_lit21
case|:
return|return
literal|"DW_OP_lit21"
return|;
case|case
name|DW_OP_lit22
case|:
return|return
literal|"DW_OP_lit22"
return|;
case|case
name|DW_OP_lit23
case|:
return|return
literal|"DW_OP_lit23"
return|;
case|case
name|DW_OP_lit24
case|:
return|return
literal|"DW_OP_lit24"
return|;
case|case
name|DW_OP_lit25
case|:
return|return
literal|"DW_OP_lit25"
return|;
case|case
name|DW_OP_lit26
case|:
return|return
literal|"DW_OP_lit26"
return|;
case|case
name|DW_OP_lit27
case|:
return|return
literal|"DW_OP_lit27"
return|;
case|case
name|DW_OP_lit28
case|:
return|return
literal|"DW_OP_lit28"
return|;
case|case
name|DW_OP_lit29
case|:
return|return
literal|"DW_OP_lit29"
return|;
case|case
name|DW_OP_lit30
case|:
return|return
literal|"DW_OP_lit30"
return|;
case|case
name|DW_OP_lit31
case|:
return|return
literal|"DW_OP_lit31"
return|;
case|case
name|DW_OP_reg0
case|:
return|return
literal|"DW_OP_reg0"
return|;
case|case
name|DW_OP_reg1
case|:
return|return
literal|"DW_OP_reg1"
return|;
case|case
name|DW_OP_reg2
case|:
return|return
literal|"DW_OP_reg2"
return|;
case|case
name|DW_OP_reg3
case|:
return|return
literal|"DW_OP_reg3"
return|;
case|case
name|DW_OP_reg4
case|:
return|return
literal|"DW_OP_reg4"
return|;
case|case
name|DW_OP_reg5
case|:
return|return
literal|"DW_OP_reg5"
return|;
case|case
name|DW_OP_reg6
case|:
return|return
literal|"DW_OP_reg6"
return|;
case|case
name|DW_OP_reg7
case|:
return|return
literal|"DW_OP_reg7"
return|;
case|case
name|DW_OP_reg8
case|:
return|return
literal|"DW_OP_reg8"
return|;
case|case
name|DW_OP_reg9
case|:
return|return
literal|"DW_OP_reg9"
return|;
case|case
name|DW_OP_reg10
case|:
return|return
literal|"DW_OP_reg10"
return|;
case|case
name|DW_OP_reg11
case|:
return|return
literal|"DW_OP_reg11"
return|;
case|case
name|DW_OP_reg12
case|:
return|return
literal|"DW_OP_reg12"
return|;
case|case
name|DW_OP_reg13
case|:
return|return
literal|"DW_OP_reg13"
return|;
case|case
name|DW_OP_reg14
case|:
return|return
literal|"DW_OP_reg14"
return|;
case|case
name|DW_OP_reg15
case|:
return|return
literal|"DW_OP_reg15"
return|;
case|case
name|DW_OP_reg16
case|:
return|return
literal|"DW_OP_reg16"
return|;
case|case
name|DW_OP_reg17
case|:
return|return
literal|"DW_OP_reg17"
return|;
case|case
name|DW_OP_reg18
case|:
return|return
literal|"DW_OP_reg18"
return|;
case|case
name|DW_OP_reg19
case|:
return|return
literal|"DW_OP_reg19"
return|;
case|case
name|DW_OP_reg20
case|:
return|return
literal|"DW_OP_reg20"
return|;
case|case
name|DW_OP_reg21
case|:
return|return
literal|"DW_OP_reg21"
return|;
case|case
name|DW_OP_reg22
case|:
return|return
literal|"DW_OP_reg22"
return|;
case|case
name|DW_OP_reg23
case|:
return|return
literal|"DW_OP_reg23"
return|;
case|case
name|DW_OP_reg24
case|:
return|return
literal|"DW_OP_reg24"
return|;
case|case
name|DW_OP_reg25
case|:
return|return
literal|"DW_OP_reg25"
return|;
case|case
name|DW_OP_reg26
case|:
return|return
literal|"DW_OP_reg26"
return|;
case|case
name|DW_OP_reg27
case|:
return|return
literal|"DW_OP_reg27"
return|;
case|case
name|DW_OP_reg28
case|:
return|return
literal|"DW_OP_reg28"
return|;
case|case
name|DW_OP_reg29
case|:
return|return
literal|"DW_OP_reg29"
return|;
case|case
name|DW_OP_reg30
case|:
return|return
literal|"DW_OP_reg30"
return|;
case|case
name|DW_OP_reg31
case|:
return|return
literal|"DW_OP_reg31"
return|;
case|case
name|DW_OP_breg0
case|:
return|return
literal|"DW_OP_breg0"
return|;
case|case
name|DW_OP_breg1
case|:
return|return
literal|"DW_OP_breg1"
return|;
case|case
name|DW_OP_breg2
case|:
return|return
literal|"DW_OP_breg2"
return|;
case|case
name|DW_OP_breg3
case|:
return|return
literal|"DW_OP_breg3"
return|;
case|case
name|DW_OP_breg4
case|:
return|return
literal|"DW_OP_breg4"
return|;
case|case
name|DW_OP_breg5
case|:
return|return
literal|"DW_OP_breg5"
return|;
case|case
name|DW_OP_breg6
case|:
return|return
literal|"DW_OP_breg6"
return|;
case|case
name|DW_OP_breg7
case|:
return|return
literal|"DW_OP_breg7"
return|;
case|case
name|DW_OP_breg8
case|:
return|return
literal|"DW_OP_breg8"
return|;
case|case
name|DW_OP_breg9
case|:
return|return
literal|"DW_OP_breg9"
return|;
case|case
name|DW_OP_breg10
case|:
return|return
literal|"DW_OP_breg10"
return|;
case|case
name|DW_OP_breg11
case|:
return|return
literal|"DW_OP_breg11"
return|;
case|case
name|DW_OP_breg12
case|:
return|return
literal|"DW_OP_breg12"
return|;
case|case
name|DW_OP_breg13
case|:
return|return
literal|"DW_OP_breg13"
return|;
case|case
name|DW_OP_breg14
case|:
return|return
literal|"DW_OP_breg14"
return|;
case|case
name|DW_OP_breg15
case|:
return|return
literal|"DW_OP_breg15"
return|;
case|case
name|DW_OP_breg16
case|:
return|return
literal|"DW_OP_breg16"
return|;
case|case
name|DW_OP_breg17
case|:
return|return
literal|"DW_OP_breg17"
return|;
case|case
name|DW_OP_breg18
case|:
return|return
literal|"DW_OP_breg18"
return|;
case|case
name|DW_OP_breg19
case|:
return|return
literal|"DW_OP_breg19"
return|;
case|case
name|DW_OP_breg20
case|:
return|return
literal|"DW_OP_breg20"
return|;
case|case
name|DW_OP_breg21
case|:
return|return
literal|"DW_OP_breg21"
return|;
case|case
name|DW_OP_breg22
case|:
return|return
literal|"DW_OP_breg22"
return|;
case|case
name|DW_OP_breg23
case|:
return|return
literal|"DW_OP_breg23"
return|;
case|case
name|DW_OP_breg24
case|:
return|return
literal|"DW_OP_breg24"
return|;
case|case
name|DW_OP_breg25
case|:
return|return
literal|"DW_OP_breg25"
return|;
case|case
name|DW_OP_breg26
case|:
return|return
literal|"DW_OP_breg26"
return|;
case|case
name|DW_OP_breg27
case|:
return|return
literal|"DW_OP_breg27"
return|;
case|case
name|DW_OP_breg28
case|:
return|return
literal|"DW_OP_breg28"
return|;
case|case
name|DW_OP_breg29
case|:
return|return
literal|"DW_OP_breg29"
return|;
case|case
name|DW_OP_breg30
case|:
return|return
literal|"DW_OP_breg30"
return|;
case|case
name|DW_OP_breg31
case|:
return|return
literal|"DW_OP_breg31"
return|;
case|case
name|DW_OP_regx
case|:
return|return
literal|"DW_OP_regx"
return|;
case|case
name|DW_OP_fbreg
case|:
return|return
literal|"DW_OP_fbreg"
return|;
case|case
name|DW_OP_bregx
case|:
return|return
literal|"DW_OP_bregx"
return|;
case|case
name|DW_OP_piece
case|:
return|return
literal|"DW_OP_piece"
return|;
case|case
name|DW_OP_deref_size
case|:
return|return
literal|"DW_OP_deref_size"
return|;
case|case
name|DW_OP_xderef_size
case|:
return|return
literal|"DW_OP_xderef_size"
return|;
case|case
name|DW_OP_nop
case|:
return|return
literal|"DW_OP_nop"
return|;
default|default:
return|return
literal|"OP_<unknown>"
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|dwarf_bool_name
parameter_list|(
name|mybool
parameter_list|)
name|unsigned
name|mybool
decl_stmt|;
block|{
if|if
condition|(
name|mybool
condition|)
return|return
literal|"TRUE"
return|;
else|else
return|return
literal|"FALSE"
return|;
block|}
end_function

begin_comment
comment|/* Convert a DWARF type code into its string name.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|dwarf_type_encoding_name
parameter_list|(
name|enc
parameter_list|)
specifier|register
name|unsigned
name|enc
decl_stmt|;
block|{
switch|switch
condition|(
name|enc
condition|)
block|{
case|case
name|DW_ATE_address
case|:
return|return
literal|"DW_ATE_address"
return|;
case|case
name|DW_ATE_boolean
case|:
return|return
literal|"DW_ATE_boolean"
return|;
case|case
name|DW_ATE_complex_float
case|:
return|return
literal|"DW_ATE_complex_float"
return|;
case|case
name|DW_ATE_float
case|:
return|return
literal|"DW_ATE_float"
return|;
case|case
name|DW_ATE_signed
case|:
return|return
literal|"DW_ATE_signed"
return|;
case|case
name|DW_ATE_signed_char
case|:
return|return
literal|"DW_ATE_signed_char"
return|;
case|case
name|DW_ATE_unsigned
case|:
return|return
literal|"DW_ATE_unsigned"
return|;
case|case
name|DW_ATE_unsigned_char
case|:
return|return
literal|"DW_ATE_unsigned_char"
return|;
default|default:
return|return
literal|"DW_ATE_<unknown>"
return|;
block|}
block|}
end_function

begin_comment
comment|/* Convert a DWARF call frame info operation to its string name. */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static char * dwarf_cfi_name (cfi_opc)      register unsigned cfi_opc; {   switch (cfi_opc)     {     case DW_CFA_advance_loc:       return "DW_CFA_advance_loc";     case DW_CFA_offset:       return "DW_CFA_offset";     case DW_CFA_restore:       return "DW_CFA_restore";     case DW_CFA_nop:       return "DW_CFA_nop";     case DW_CFA_set_loc:       return "DW_CFA_set_loc";     case DW_CFA_advance_loc1:       return "DW_CFA_advance_loc1";     case DW_CFA_advance_loc2:       return "DW_CFA_advance_loc2";     case DW_CFA_advance_loc4:       return "DW_CFA_advance_loc4";     case DW_CFA_offset_extended:       return "DW_CFA_offset_extended";     case DW_CFA_restore_extended:       return "DW_CFA_restore_extended";     case DW_CFA_undefined:       return "DW_CFA_undefined";     case DW_CFA_same_value:       return "DW_CFA_same_value";     case DW_CFA_register:       return "DW_CFA_register";     case DW_CFA_remember_state:       return "DW_CFA_remember_state";     case DW_CFA_restore_state:       return "DW_CFA_restore_state";     case DW_CFA_def_cfa:       return "DW_CFA_def_cfa";     case DW_CFA_def_cfa_register:       return "DW_CFA_def_cfa_register";     case DW_CFA_def_cfa_offset:       return "DW_CFA_def_cfa_offset";
comment|/* SGI/MIPS specific */
end_comment

begin_endif
unit|case DW_CFA_MIPS_advance_loc8:       return "DW_CFA_MIPS_advance_loc8";     default:       return "DW_CFA_<unknown>";     } }
endif|#
directive|endif
end_endif

begin_function
name|void
name|dump_die
parameter_list|(
name|die
parameter_list|)
name|struct
name|die_info
modifier|*
name|die
decl_stmt|;
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Die: %s (abbrev = %d, offset = %d)\n"
argument_list|,
name|dwarf_tag_name
argument_list|(
name|die
operator|->
name|tag
argument_list|)
argument_list|,
name|die
operator|->
name|abbrev
argument_list|,
name|die
operator|->
name|offset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\thas children: %s\n"
argument_list|,
name|dwarf_bool_name
argument_list|(
name|die
operator|->
name|has_children
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\tattributes:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|die
operator|->
name|num_attrs
condition|;
operator|++
name|i
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\t\t%s (%s) "
argument_list|,
name|dwarf_attr_name
argument_list|(
name|die
operator|->
name|attrs
index|[
name|i
index|]
operator|.
name|name
argument_list|)
argument_list|,
name|dwarf_form_name
argument_list|(
name|die
operator|->
name|attrs
index|[
name|i
index|]
operator|.
name|form
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|die
operator|->
name|attrs
index|[
name|i
index|]
operator|.
name|form
condition|)
block|{
case|case
name|DW_FORM_ref_addr
case|:
case|case
name|DW_FORM_addr
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"address: "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|DW_ADDR
argument_list|(
operator|&
name|die
operator|->
name|attrs
index|[
name|i
index|]
argument_list|)
argument_list|,
literal|1
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_block2
case|:
case|case
name|DW_FORM_block4
case|:
case|case
name|DW_FORM_block
case|:
case|case
name|DW_FORM_block1
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"block: size %d"
argument_list|,
name|DW_BLOCK
argument_list|(
operator|&
name|die
operator|->
name|attrs
index|[
name|i
index|]
argument_list|)
operator|->
name|size
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_data1
case|:
case|case
name|DW_FORM_data2
case|:
case|case
name|DW_FORM_data4
case|:
case|case
name|DW_FORM_ref1
case|:
case|case
name|DW_FORM_ref2
case|:
case|case
name|DW_FORM_ref4
case|:
case|case
name|DW_FORM_udata
case|:
case|case
name|DW_FORM_sdata
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"constant: %d"
argument_list|,
name|DW_UNSND
argument_list|(
operator|&
name|die
operator|->
name|attrs
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_string
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"string: \"%s\""
argument_list|,
name|DW_STRING
argument_list|(
operator|&
name|die
operator|->
name|attrs
index|[
name|i
index|]
argument_list|)
condition|?
name|DW_STRING
argument_list|(
operator|&
name|die
operator|->
name|attrs
index|[
name|i
index|]
argument_list|)
else|:
literal|""
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_flag
case|:
if|if
condition|(
name|DW_UNSND
argument_list|(
operator|&
name|die
operator|->
name|attrs
index|[
name|i
index|]
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"flag: TRUE"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"flag: FALSE"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_strp
case|:
comment|/* we do not support separate string 				   section yet */
case|case
name|DW_FORM_indirect
case|:
comment|/* we do not handle indirect yet */
case|case
name|DW_FORM_data8
case|:
comment|/* we do not have 64 bit quantities */
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unsupported attribute form: %d."
argument_list|,
name|die
operator|->
name|attrs
index|[
name|i
index|]
operator|.
name|form
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dump_die_list
parameter_list|(
name|die
parameter_list|)
name|struct
name|die_info
modifier|*
name|die
decl_stmt|;
block|{
while|while
condition|(
name|die
condition|)
block|{
name|dump_die
argument_list|(
name|die
argument_list|)
expr_stmt|;
name|die
operator|=
name|die
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|store_in_ref_table
parameter_list|(
name|offset
parameter_list|,
name|die
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
name|struct
name|die_info
modifier|*
name|die
decl_stmt|;
block|{
name|int
name|h
decl_stmt|;
name|struct
name|die_info
modifier|*
name|old
decl_stmt|;
name|h
operator|=
operator|(
name|offset
operator|%
name|REF_HASH_SIZE
operator|)
expr_stmt|;
name|old
operator|=
name|die_ref_table
index|[
name|h
index|]
expr_stmt|;
name|die
operator|->
name|next_ref
operator|=
name|old
expr_stmt|;
name|die_ref_table
index|[
name|h
index|]
operator|=
name|die
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dwarf2_empty_die_ref_table
parameter_list|()
block|{
name|memset
argument_list|(
name|die_ref_table
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|die_ref_table
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|dwarf2_get_ref_die_offset
parameter_list|(
name|attr
parameter_list|)
name|struct
name|attribute
modifier|*
name|attr
decl_stmt|;
block|{
name|unsigned
name|int
name|result
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|attr
operator|->
name|form
condition|)
block|{
case|case
name|DW_FORM_ref_addr
case|:
name|result
operator|=
name|DW_ADDR
argument_list|(
name|attr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DW_FORM_ref1
case|:
case|case
name|DW_FORM_ref2
case|:
case|case
name|DW_FORM_ref4
case|:
case|case
name|DW_FORM_ref_udata
case|:
name|result
operator|=
name|cu_header_offset
operator|+
name|DW_UNSND
argument_list|(
name|attr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|complain
argument_list|(
operator|&
name|dwarf2_unsupported_die_ref_attr
argument_list|,
name|dwarf_form_name
argument_list|(
name|attr
operator|->
name|form
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
name|struct
name|die_info
modifier|*
name|follow_die_ref
parameter_list|(
name|offset
parameter_list|)
name|unsigned
name|int
name|offset
decl_stmt|;
block|{
name|struct
name|die_info
modifier|*
name|die
decl_stmt|;
name|int
name|h
decl_stmt|;
name|h
operator|=
operator|(
name|offset
operator|%
name|REF_HASH_SIZE
operator|)
expr_stmt|;
name|die
operator|=
name|die_ref_table
index|[
name|h
index|]
expr_stmt|;
while|while
condition|(
name|die
condition|)
block|{
if|if
condition|(
name|die
operator|->
name|offset
operator|==
name|offset
condition|)
block|{
return|return
name|die
return|;
block|}
name|die
operator|=
name|die
operator|->
name|next_ref
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|type
modifier|*
name|dwarf2_fundamental_type
parameter_list|(
name|objfile
parameter_list|,
name|typeid
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|int
name|typeid
decl_stmt|;
block|{
if|if
condition|(
name|typeid
operator|<
literal|0
operator|||
name|typeid
operator|>=
name|FT_NUM_MEMBERS
condition|)
block|{
name|error
argument_list|(
literal|"Dwarf Error: internal error - invalid fundamental type id %d."
argument_list|,
name|typeid
argument_list|)
expr_stmt|;
block|}
comment|/* Look for this particular type in the fundamental type vector.  If      one is not found, create and install one appropriate for the      current language and the current target machine. */
if|if
condition|(
name|ftypes
index|[
name|typeid
index|]
operator|==
name|NULL
condition|)
block|{
name|ftypes
index|[
name|typeid
index|]
operator|=
name|cu_language_defn
operator|->
name|la_fund_type
argument_list|(
name|objfile
argument_list|,
name|typeid
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ftypes
index|[
name|typeid
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Decode simple location descriptions.    Given a pointer to a dwarf block that defines a location, compute    the location and return the value.     FIXME: This is a kludge until we figure out a better    way to handle the location descriptions.    Gdb's design does not mesh well with the DWARF2 notion of a location    computing interpreter, which is a shame because the flexibility goes unused.    FIXME: Implement more operations as necessary.     A location description containing no operations indicates that the    object is optimized out. The global optimized_out flag is set for    those, the return value is meaningless.     When the result is a register number, the global isreg flag is set,    otherwise it is cleared.     When the result is a base register offset, the global offreg flag is set    and the register number is returned in basereg, otherwise it is cleared.     When the DW_OP_fbreg operation is encountered without a corresponding    DW_AT_frame_base attribute, the global islocal flag is set.    Hopefully the machine dependent code knows how to set up a virtual    frame pointer for the local references.      Note that stack[0] is unused except as a default error return.    Note that stack overflow is not yet handled.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|decode_locdesc
parameter_list|(
name|blk
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|dwarf_block
modifier|*
name|blk
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|size
init|=
name|blk
operator|->
name|size
decl_stmt|;
name|char
modifier|*
name|data
init|=
name|blk
operator|->
name|data
decl_stmt|;
name|CORE_ADDR
name|stack
index|[
literal|64
index|]
decl_stmt|;
name|int
name|stacki
decl_stmt|;
name|unsigned
name|int
name|bytes_read
decl_stmt|,
name|unsnd
decl_stmt|;
name|unsigned
name|char
name|op
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|stacki
operator|=
literal|0
expr_stmt|;
name|stack
index|[
name|stacki
index|]
operator|=
literal|0
expr_stmt|;
name|isreg
operator|=
literal|0
expr_stmt|;
name|offreg
operator|=
literal|0
expr_stmt|;
name|islocal
operator|=
literal|0
expr_stmt|;
name|optimized_out
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|size
condition|)
block|{
name|optimized_out
operator|=
literal|0
expr_stmt|;
name|op
operator|=
name|data
index|[
name|i
operator|++
index|]
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|DW_OP_reg0
case|:
case|case
name|DW_OP_reg1
case|:
case|case
name|DW_OP_reg2
case|:
case|case
name|DW_OP_reg3
case|:
case|case
name|DW_OP_reg4
case|:
case|case
name|DW_OP_reg5
case|:
case|case
name|DW_OP_reg6
case|:
case|case
name|DW_OP_reg7
case|:
case|case
name|DW_OP_reg8
case|:
case|case
name|DW_OP_reg9
case|:
case|case
name|DW_OP_reg10
case|:
case|case
name|DW_OP_reg11
case|:
case|case
name|DW_OP_reg12
case|:
case|case
name|DW_OP_reg13
case|:
case|case
name|DW_OP_reg14
case|:
case|case
name|DW_OP_reg15
case|:
case|case
name|DW_OP_reg16
case|:
case|case
name|DW_OP_reg17
case|:
case|case
name|DW_OP_reg18
case|:
case|case
name|DW_OP_reg19
case|:
case|case
name|DW_OP_reg20
case|:
case|case
name|DW_OP_reg21
case|:
case|case
name|DW_OP_reg22
case|:
case|case
name|DW_OP_reg23
case|:
case|case
name|DW_OP_reg24
case|:
case|case
name|DW_OP_reg25
case|:
case|case
name|DW_OP_reg26
case|:
case|case
name|DW_OP_reg27
case|:
case|case
name|DW_OP_reg28
case|:
case|case
name|DW_OP_reg29
case|:
case|case
name|DW_OP_reg30
case|:
case|case
name|DW_OP_reg31
case|:
name|isreg
operator|=
literal|1
expr_stmt|;
name|stack
index|[
operator|++
name|stacki
index|]
operator|=
name|op
operator|-
name|DW_OP_reg0
expr_stmt|;
break|break;
case|case
name|DW_OP_regx
case|:
name|isreg
operator|=
literal|1
expr_stmt|;
name|unsnd
operator|=
name|read_unsigned_leb128
argument_list|(
name|NULL
argument_list|,
operator|(
name|data
operator|+
name|i
operator|)
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|i
operator|+=
name|bytes_read
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HARRIS_TARGET
argument_list|)
operator|&&
name|defined
argument_list|(
name|_M88K
argument_list|)
comment|/* The Harris 88110 gdb ports have long kept their special reg 	     numbers between their gp-regs and their x-regs.  This is 	     not how our dwarf is generated.  Punt. */
name|unsnd
operator|+=
literal|6
expr_stmt|;
endif|#
directive|endif
name|stack
index|[
operator|++
name|stacki
index|]
operator|=
name|unsnd
expr_stmt|;
break|break;
case|case
name|DW_OP_breg0
case|:
case|case
name|DW_OP_breg1
case|:
case|case
name|DW_OP_breg2
case|:
case|case
name|DW_OP_breg3
case|:
case|case
name|DW_OP_breg4
case|:
case|case
name|DW_OP_breg5
case|:
case|case
name|DW_OP_breg6
case|:
case|case
name|DW_OP_breg7
case|:
case|case
name|DW_OP_breg8
case|:
case|case
name|DW_OP_breg9
case|:
case|case
name|DW_OP_breg10
case|:
case|case
name|DW_OP_breg11
case|:
case|case
name|DW_OP_breg12
case|:
case|case
name|DW_OP_breg13
case|:
case|case
name|DW_OP_breg14
case|:
case|case
name|DW_OP_breg15
case|:
case|case
name|DW_OP_breg16
case|:
case|case
name|DW_OP_breg17
case|:
case|case
name|DW_OP_breg18
case|:
case|case
name|DW_OP_breg19
case|:
case|case
name|DW_OP_breg20
case|:
case|case
name|DW_OP_breg21
case|:
case|case
name|DW_OP_breg22
case|:
case|case
name|DW_OP_breg23
case|:
case|case
name|DW_OP_breg24
case|:
case|case
name|DW_OP_breg25
case|:
case|case
name|DW_OP_breg26
case|:
case|case
name|DW_OP_breg27
case|:
case|case
name|DW_OP_breg28
case|:
case|case
name|DW_OP_breg29
case|:
case|case
name|DW_OP_breg30
case|:
case|case
name|DW_OP_breg31
case|:
name|offreg
operator|=
literal|1
expr_stmt|;
name|basereg
operator|=
name|op
operator|-
name|DW_OP_breg0
expr_stmt|;
name|stack
index|[
operator|++
name|stacki
index|]
operator|=
name|read_signed_leb128
argument_list|(
name|NULL
argument_list|,
operator|(
name|data
operator|+
name|i
operator|)
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|i
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_OP_fbreg
case|:
name|stack
index|[
operator|++
name|stacki
index|]
operator|=
name|read_signed_leb128
argument_list|(
name|NULL
argument_list|,
operator|(
name|data
operator|+
name|i
operator|)
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|i
operator|+=
name|bytes_read
expr_stmt|;
if|if
condition|(
name|frame_base_reg
operator|>=
literal|0
condition|)
block|{
name|offreg
operator|=
literal|1
expr_stmt|;
name|basereg
operator|=
name|frame_base_reg
expr_stmt|;
name|stack
index|[
name|stacki
index|]
operator|+=
name|frame_base_offset
expr_stmt|;
block|}
else|else
block|{
name|complain
argument_list|(
operator|&
name|dwarf2_missing_at_frame_base
argument_list|)
expr_stmt|;
name|islocal
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|DW_OP_addr
case|:
name|stack
index|[
operator|++
name|stacki
index|]
operator|=
name|read_address
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|+=
name|address_size
expr_stmt|;
break|break;
case|case
name|DW_OP_const1u
case|:
name|stack
index|[
operator|++
name|stacki
index|]
operator|=
name|read_1_byte
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_OP_const1s
case|:
name|stack
index|[
operator|++
name|stacki
index|]
operator|=
name|read_1_signed_byte
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
name|DW_OP_const2u
case|:
name|stack
index|[
operator|++
name|stacki
index|]
operator|=
name|read_2_bytes
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_OP_const2s
case|:
name|stack
index|[
operator|++
name|stacki
index|]
operator|=
name|read_2_signed_bytes
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|DW_OP_const4u
case|:
name|stack
index|[
operator|++
name|stacki
index|]
operator|=
name|read_4_bytes
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|DW_OP_const4s
case|:
name|stack
index|[
operator|++
name|stacki
index|]
operator|=
name|read_4_signed_bytes
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|&
name|data
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|DW_OP_constu
case|:
name|stack
index|[
operator|++
name|stacki
index|]
operator|=
name|read_unsigned_leb128
argument_list|(
name|NULL
argument_list|,
operator|(
name|data
operator|+
name|i
operator|)
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|i
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_OP_consts
case|:
name|stack
index|[
operator|++
name|stacki
index|]
operator|=
name|read_signed_leb128
argument_list|(
name|NULL
argument_list|,
operator|(
name|data
operator|+
name|i
operator|)
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|i
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_OP_plus
case|:
name|stack
index|[
name|stacki
operator|-
literal|1
index|]
operator|+=
name|stack
index|[
name|stacki
index|]
expr_stmt|;
name|stacki
operator|--
expr_stmt|;
break|break;
case|case
name|DW_OP_plus_uconst
case|:
name|stack
index|[
name|stacki
index|]
operator|+=
name|read_unsigned_leb128
argument_list|(
name|NULL
argument_list|,
operator|(
name|data
operator|+
name|i
operator|)
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
name|i
operator|+=
name|bytes_read
expr_stmt|;
break|break;
case|case
name|DW_OP_minus
case|:
name|stack
index|[
name|stacki
operator|-
literal|1
index|]
operator|=
name|stack
index|[
name|stacki
index|]
operator|-
name|stack
index|[
name|stacki
operator|-
literal|1
index|]
expr_stmt|;
name|stacki
operator|--
expr_stmt|;
break|break;
default|default:
name|complain
argument_list|(
operator|&
name|dwarf2_unsupported_stack_op
argument_list|,
name|dwarf_stack_op_name
argument_list|(
name|op
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|stack
index|[
name|stacki
index|]
operator|)
return|;
block|}
block|}
return|return
operator|(
name|stack
index|[
name|stacki
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* memory allocation interface */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|dwarf2_free_tmp_obstack
parameter_list|(
name|ignore
parameter_list|)
name|PTR
name|ignore
decl_stmt|;
block|{
name|obstack_free
argument_list|(
operator|&
name|dwarf2_tmp_obstack
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|dwarf_block
modifier|*
name|dwarf_alloc_block
parameter_list|()
block|{
name|struct
name|dwarf_block
modifier|*
name|blk
decl_stmt|;
name|blk
operator|=
operator|(
expr|struct
name|dwarf_block
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|dwarf2_tmp_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dwarf_block
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|blk
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|abbrev_info
modifier|*
name|dwarf_alloc_abbrev
parameter_list|()
block|{
name|struct
name|abbrev_info
modifier|*
name|abbrev
decl_stmt|;
name|abbrev
operator|=
operator|(
expr|struct
name|abbrev_info
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|abbrev_info
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|abbrev
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|abbrev_info
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|abbrev
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|die_info
modifier|*
name|dwarf_alloc_die
parameter_list|()
block|{
name|struct
name|die_info
modifier|*
name|die
decl_stmt|;
name|die
operator|=
operator|(
expr|struct
name|die_info
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|die_info
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|die
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|die_info
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|die
operator|)
return|;
block|}
end_function

end_unit

