begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Memory-access and commands for remote NINDY process, for GDB.    Copyright 1990, 1991, 1992, 1993 Free Software Foundation, Inc.    Contributed by Intel Corporation.  Modified from remote.c by Chris Benenati.  GDB is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing. Refer to the GDB General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GDB, but only under the conditions described in the GDB General Public License.  A copy of this license is supposed to have been given to you along with GDB so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  In other words, go ahead and share GDB, but don't try to stop anyone else from sharing it farther.  Help stamp out software hoarding! */
end_comment

begin_comment
comment|/* Except for the data cache routines, this file bears little resemblence to remote.c.  A new (although similar) protocol has been specified, and portions of the code are entirely dependent on having an i80960 with a NINDY ROM monitor at the other end of the line. */
end_comment

begin_comment
comment|/*****************************************************************************  *  * REMOTE COMMUNICATION PROTOCOL BETWEEN GDB960 AND THE NINDY ROM MONITOR.  *  *  * MODES OF OPERATION  * ----- -- ---------  *	  * As far as NINDY is concerned, GDB is always in one of two modes: command  * mode or passthrough mode.  *  * In command mode (the default) pre-defined packets containing requests  * are sent by GDB to NINDY.  NINDY never talks except in reponse to a request.  *  * Once the the user program is started, GDB enters passthrough mode, to give  * the user program access to the terminal.  GDB remains in this mode until  * NINDY indicates that the program has stopped.  *  *  * PASSTHROUGH MODE  * ----------- ----  *  * GDB writes all input received from the keyboard directly to NINDY, and writes  * all characters received from NINDY directly to the monitor.  *  * Keyboard input is neither buffered nor echoed to the monitor.  *  * GDB remains in passthrough mode until NINDY sends a single ^P character,  * to indicate that the user process has stopped.  *  * Note:  *	GDB assumes NINDY performs a 'flushreg' when the user program stops.  *  *  * COMMAND MODE  * ------- ----  *  * All info (except for message ack and nak) is transferred between gdb  * and the remote processor in messages of the following format:  *  *<info>#<checksum>  *  * where   *	#	is a literal character  *  *<info>	ASCII information;  all numeric information is in the  *		form of hex digits ('0'-'9' and lowercase 'a'-'f').  *  *<checksum>  *		is a pair of ASCII hex digits representing an 8-bit  *		checksum formed by adding together each of the  *		characters in<info>.  *  * The receiver of a message always sends a single character to the sender  * to indicate that the checksum was good ('+') or bad ('-');  the sender  * re-transmits the entire message over until a '+' is received.  *  * In response to a command NINDY always sends back either data or  * a result code of the form "Xnn", where "nn" are hex digits and "X00"  * means no errors.  (Exceptions: the "s" and "c" commands don't respond.)  *  * SEE THE HEADER OF THE FILE "gdb.c" IN THE NINDY MONITOR SOURCE CODE FOR A  * FULL DESCRIPTION OF LEGAL COMMANDS.  *  * SEE THE FILE "stop.h" IN THE NINDY MONITOR SOURCE CODE FOR A LIST  * OF STOP CODES.  *  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"floatformat.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_include
include|#
directive|include
file|"nindy-share/env.h"
end_include

begin_include
include|#
directive|include
file|"nindy-share/stop.h"
end_include

begin_include
include|#
directive|include
file|"dcache.h"
end_include

begin_include
include|#
directive|include
file|"remote-utils.h"
end_include

begin_decl_stmt
specifier|static
name|DCACHE
modifier|*
name|nindy_dcache
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|unlink
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|mktemp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|generic_mourn_inferior
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|nindy_ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|GDB_FILE
modifier|*
name|instream
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
name|ninStopWhy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|ninMemGet
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|ninMemPut
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|nindy_initial_brk
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nonzero if want to send an initial BREAK to nindy */
end_comment

begin_decl_stmt
name|int
name|nindy_old_protocol
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nonzero if want to use old protocol */
end_comment

begin_decl_stmt
name|char
modifier|*
name|nindy_ttyname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of tty to talk to nindy on, or null */
end_comment

begin_define
define|#
directive|define
name|DLE
value|'\020'
end_define

begin_comment
comment|/* Character NINDY sends to indicate user program has 			 * halted.  */
end_comment

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_comment
comment|/* From nindy-share/nindy.c.  */
end_comment

begin_decl_stmt
specifier|extern
name|serial_t
name|nindy_serial
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|have_regs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 iff regs read since i960 last halted */
end_comment

begin_decl_stmt
specifier|static
name|int
name|regs_changed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 iff regs were modified since last read */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|exists
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|nindy_fetch_registers
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|nindy_store_registers
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|char
modifier|*
name|savename
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|nindy_close
parameter_list|(
name|quitting
parameter_list|)
name|int
name|quitting
decl_stmt|;
block|{
if|if
condition|(
name|nindy_serial
operator|!=
name|NULL
condition|)
name|SERIAL_CLOSE
argument_list|(
name|nindy_serial
argument_list|)
expr_stmt|;
name|nindy_serial
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|savename
condition|)
name|free
argument_list|(
name|savename
argument_list|)
expr_stmt|;
name|savename
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Open a connection to a remote debugger.       FIXME, there should be "set" commands for the options that are    now specified with gdb command-line options (old_protocol,    and initial_brk).  */
end_comment

begin_function
name|void
name|nindy_open
parameter_list|(
name|name
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
comment|/* "/dev/ttyXX", "ttyXX", or "XX": tty to be opened */
name|int
name|from_tty
decl_stmt|;
block|{
name|char
name|baudrate
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
name|error_no_arg
argument_list|(
literal|"serial port device name"
argument_list|)
expr_stmt|;
name|target_preopen
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
name|nindy_close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|have_regs
operator|=
name|regs_changed
operator|=
literal|0
expr_stmt|;
name|nindy_dcache
operator|=
name|dcache_init
argument_list|(
name|ninMemGet
argument_list|,
name|ninMemPut
argument_list|)
expr_stmt|;
comment|/* Allow user to interrupt the following -- we could hang if there's      no NINDY at the other end of the remote tty.  */
name|immediate_quit
operator|++
expr_stmt|;
comment|/* If baud_rate is -1, then ninConnect will not recognize the baud rate      and will deal with the situation in a (more or less) reasonable      fashion.  */
name|sprintf
argument_list|(
name|baudrate
argument_list|,
literal|"%d"
argument_list|,
name|baud_rate
argument_list|)
expr_stmt|;
name|ninConnect
argument_list|(
name|name
argument_list|,
name|baudrate
argument_list|,
name|nindy_initial_brk
argument_list|,
operator|!
name|from_tty
argument_list|,
name|nindy_old_protocol
argument_list|)
expr_stmt|;
name|immediate_quit
operator|--
expr_stmt|;
if|if
condition|(
name|nindy_serial
operator|==
name|NULL
condition|)
block|{
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|savename
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|push_target
argument_list|(
operator|&
name|nindy_ops
argument_list|)
expr_stmt|;
name|target_fetch_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* User-initiated quit of nindy operations.  */
end_comment

begin_function
specifier|static
name|void
name|nindy_detach
parameter_list|(
name|name
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|name
condition|)
name|error
argument_list|(
literal|"Too many arguments"
argument_list|)
expr_stmt|;
name|pop_target
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nindy_files_info
parameter_list|()
block|{
comment|/* FIXME: this lies about the baud rate if we autobauded.  */
name|printf_unfiltered
argument_list|(
literal|"\tAttached to %s at %d bits per second%s%s.\n"
argument_list|,
name|savename
argument_list|,
name|baud_rate
argument_list|,
name|nindy_old_protocol
condition|?
literal|" in old protocol"
else|:
literal|""
argument_list|,
name|nindy_initial_brk
condition|?
literal|" with initial break"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the number of characters in the buffer before    the first DLE character.  */
end_comment

begin_function
specifier|static
name|int
name|non_dle
parameter_list|(
name|buf
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* Character buffer; NOT '\0'-terminated */
name|int
name|n
decl_stmt|;
comment|/* Number of characters in buffer */
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
name|DLE
condition|)
block|{
break|break;
block|}
block|}
return|return
name|i
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Tell the remote machine to resume.  */
end_comment

begin_function
name|void
name|nindy_resume
parameter_list|(
name|pid
parameter_list|,
name|step
parameter_list|,
name|siggnal
parameter_list|)
name|int
name|pid
decl_stmt|,
name|step
decl_stmt|;
name|enum
name|target_signal
name|siggnal
decl_stmt|;
block|{
if|if
condition|(
name|siggnal
operator|!=
name|TARGET_SIGNAL_0
operator|&&
name|siggnal
operator|!=
name|stop_signal
condition|)
name|warning
argument_list|(
literal|"Can't send signals to remote NINDY targets."
argument_list|)
expr_stmt|;
name|dcache_flush
argument_list|(
name|nindy_dcache
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs_changed
condition|)
block|{
name|nindy_store_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|regs_changed
operator|=
literal|0
expr_stmt|;
block|}
name|have_regs
operator|=
literal|0
expr_stmt|;
name|ninGo
argument_list|(
name|step
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* FIXME, we can probably use the normal terminal_inferior stuff here.    We have to do terminal_inferior and then set up the passthrough    settings initially.  Thereafter, terminal_ours and terminal_inferior    will automatically swap the settings around for us.  */
end_comment

begin_struct
struct|struct
name|clean_up_tty_args
block|{
name|serial_ttystate
name|state
decl_stmt|;
name|serial_t
name|serial
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|clean_up_tty_args
name|tty_args
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|clean_up_tty
parameter_list|(
name|ptrarg
parameter_list|)
name|PTR
name|ptrarg
decl_stmt|;
block|{
name|struct
name|clean_up_tty_args
modifier|*
name|args
init|=
operator|(
expr|struct
name|clean_up_tty_args
operator|*
operator|)
name|ptrarg
decl_stmt|;
name|SERIAL_SET_TTY_STATE
argument_list|(
name|args
operator|->
name|serial
argument_list|,
name|args
operator|->
name|state
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|args
operator|->
name|state
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"\n\nYou may need to reset the 80960 and/or reload your program.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Recover from ^Z or ^C while remote process is running */
end_comment

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|old_ctrlc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SIGTSTP
end_ifdef

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|old_ctrlz
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|clean_up_int
parameter_list|()
block|{
name|SERIAL_SET_TTY_STATE
argument_list|(
name|tty_args
operator|.
name|serial
argument_list|,
name|tty_args
operator|.
name|state
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tty_args
operator|.
name|state
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|old_ctrlc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGTSTP
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|old_ctrlz
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
argument_list|(
literal|"\n\nYou may need to reset the 80960 and/or reload your program.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wait until the remote machine stops. While waiting, operate in passthrough  * mode; i.e., pass everything NINDY sends to gdb_stdout, and everything from  * stdin to NINDY.  *  * Return to caller, storing status in 'status' just as `wait' would.  */
end_comment

begin_function
specifier|static
name|int
name|nindy_wait
parameter_list|(
name|pid
parameter_list|,
name|status
parameter_list|)
name|int
name|pid
decl_stmt|;
name|struct
name|target_waitstatus
modifier|*
name|status
decl_stmt|;
block|{
name|fd_set
name|fds
decl_stmt|;
name|int
name|c
decl_stmt|;
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|unsigned
name|char
name|stop_exit
decl_stmt|;
name|unsigned
name|char
name|stop_code
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_cleanups
decl_stmt|;
name|long
name|ip_value
decl_stmt|,
name|fp_value
decl_stmt|,
name|sp_value
decl_stmt|;
comment|/* Reg values from stop */
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|integer
operator|=
literal|0
expr_stmt|;
comment|/* OPERATE IN PASSTHROUGH MODE UNTIL NINDY SENDS A DLE CHARACTER */
comment|/* Save current tty attributes, and restore them when done.  */
name|tty_args
operator|.
name|serial
operator|=
name|SERIAL_FDOPEN
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|tty_args
operator|.
name|state
operator|=
name|SERIAL_GET_TTY_STATE
argument_list|(
name|tty_args
operator|.
name|serial
argument_list|)
expr_stmt|;
name|old_ctrlc
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|clean_up_int
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGTSTP
name|old_ctrlz
operator|=
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|clean_up_int
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|old_cleanups
operator|=
name|make_cleanup
argument_list|(
name|clean_up_tty
argument_list|,
operator|&
name|tty_args
argument_list|)
expr_stmt|;
comment|/* Pass input from keyboard to NINDY as it arrives.  NINDY will interpret<CR> and perform echo.  */
comment|/* This used to set CBREAK and clear ECHO and CRMOD.  I hope this is close      enough.  */
name|SERIAL_RAW
argument_list|(
name|tty_args
operator|.
name|serial
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Input on remote */
name|c
operator|=
name|SERIAL_READCHAR
argument_list|(
name|nindy_serial
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|SERIAL_ERROR
condition|)
block|{
name|error
argument_list|(
literal|"Cannot read from serial line"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|0x1b
condition|)
comment|/* ESC */
block|{
name|c
operator|=
name|SERIAL_READCHAR
argument_list|(
name|nindy_serial
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|c
operator|&=
operator|~
literal|0x40
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
literal|0x10
condition|)
comment|/* DLE */
comment|/* Write out any characters preceding DLE */
block|{
name|buf
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
name|write
argument_list|(
literal|1
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stop_exit
operator|=
name|ninStopWhy
argument_list|(
operator|&
name|stop_code
argument_list|,
operator|&
name|ip_value
argument_list|,
operator|&
name|fp_value
argument_list|,
operator|&
name|sp_value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stop_exit
operator|&&
operator|(
name|stop_code
operator|==
name|STOP_SRQ
operator|)
condition|)
block|{
name|immediate_quit
operator|++
expr_stmt|;
name|ninSrq
argument_list|()
expr_stmt|;
name|immediate_quit
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* Get out of loop */
name|supply_register
argument_list|(
name|IP_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ip_value
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|FP_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|fp_value
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|SP_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sp_value
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|SERIAL_SET_TTY_STATE
argument_list|(
name|tty_args
operator|.
name|serial
argument_list|,
name|tty_args
operator|.
name|state
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tty_args
operator|.
name|state
argument_list|)
expr_stmt|;
name|discard_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
if|if
condition|(
name|stop_exit
condition|)
block|{
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|integer
operator|=
name|stop_code
expr_stmt|;
block|}
else|else
block|{
comment|/* nindy has some special stop code need to be handled */
if|if
condition|(
name|stop_code
operator|==
name|STOP_GDB_BPT
condition|)
name|stop_code
operator|=
name|TRACE_STEP
expr_stmt|;
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|i960_fault_to_signal
argument_list|(
name|stop_code
argument_list|)
expr_stmt|;
block|}
return|return
name|inferior_pid
return|;
block|}
end_function

begin_comment
comment|/* Read the remote registers into the block REGS.  */
end_comment

begin_comment
comment|/* This is the block that ninRegsGet and ninRegsPut handles.  */
end_comment

begin_struct
struct|struct
name|nindy_regs
block|{
name|char
name|local_regs
index|[
literal|16
operator|*
literal|4
index|]
decl_stmt|;
name|char
name|global_regs
index|[
literal|16
operator|*
literal|4
index|]
decl_stmt|;
name|char
name|pcw_acw
index|[
literal|2
operator|*
literal|4
index|]
decl_stmt|;
name|char
name|ip
index|[
literal|4
index|]
decl_stmt|;
name|char
name|tcw
index|[
literal|4
index|]
decl_stmt|;
name|char
name|fp_as_double
index|[
literal|4
operator|*
literal|8
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|nindy_fetch_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|struct
name|nindy_regs
name|nindy_regs
decl_stmt|;
name|int
name|regnum
decl_stmt|,
name|inv
decl_stmt|;
name|double
name|dub
decl_stmt|;
name|immediate_quit
operator|++
expr_stmt|;
name|ninRegsGet
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|nindy_regs
argument_list|)
expr_stmt|;
name|immediate_quit
operator|--
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|R0_REGNUM
argument_list|)
index|]
argument_list|,
name|nindy_regs
operator|.
name|local_regs
argument_list|,
literal|16
operator|*
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|G0_REGNUM
argument_list|)
index|]
argument_list|,
name|nindy_regs
operator|.
name|global_regs
argument_list|,
literal|16
operator|*
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|PCW_REGNUM
argument_list|)
index|]
argument_list|,
name|nindy_regs
operator|.
name|pcw_acw
argument_list|,
literal|2
operator|*
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|IP_REGNUM
argument_list|)
index|]
argument_list|,
name|nindy_regs
operator|.
name|ip
argument_list|,
literal|1
operator|*
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|TCW_REGNUM
argument_list|)
index|]
argument_list|,
name|nindy_regs
operator|.
name|tcw
argument_list|,
literal|1
operator|*
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|regnum
operator|=
name|FP0_REGNUM
init|;
name|regnum
operator|<
name|FP0_REGNUM
operator|+
literal|4
condition|;
name|regnum
operator|++
control|)
block|{
name|dub
operator|=
name|unpack_double
argument_list|(
name|builtin_type_double
argument_list|,
operator|&
name|nindy_regs
operator|.
name|fp_as_double
index|[
literal|8
operator|*
operator|(
name|regnum
operator|-
name|FP0_REGNUM
operator|)
index|]
argument_list|,
operator|&
name|inv
argument_list|)
expr_stmt|;
comment|/* dub now in host byte order */
name|floatformat_from_double
argument_list|(
operator|&
name|floatformat_i960_ext
argument_list|,
operator|&
name|dub
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
name|registers_fetched
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nindy_prepare_to_store
parameter_list|()
block|{
comment|/* Fetch all regs if they aren't already here.  */
name|read_register_bytes
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nindy_store_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|struct
name|nindy_regs
name|nindy_regs
decl_stmt|;
name|int
name|regnum
decl_stmt|;
name|double
name|dub
decl_stmt|;
name|memcpy
argument_list|(
name|nindy_regs
operator|.
name|local_regs
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|R0_REGNUM
argument_list|)
index|]
argument_list|,
literal|16
operator|*
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|nindy_regs
operator|.
name|global_regs
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|G0_REGNUM
argument_list|)
index|]
argument_list|,
literal|16
operator|*
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|nindy_regs
operator|.
name|pcw_acw
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|PCW_REGNUM
argument_list|)
index|]
argument_list|,
literal|2
operator|*
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|nindy_regs
operator|.
name|ip
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|IP_REGNUM
argument_list|)
index|]
argument_list|,
literal|1
operator|*
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|nindy_regs
operator|.
name|tcw
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|TCW_REGNUM
argument_list|)
index|]
argument_list|,
literal|1
operator|*
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|regnum
operator|=
name|FP0_REGNUM
init|;
name|regnum
operator|<
name|FP0_REGNUM
operator|+
literal|4
condition|;
name|regnum
operator|++
control|)
block|{
name|floatformat_to_double
argument_list|(
operator|&
name|floatformat_i960_ext
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
index|]
argument_list|,
operator|&
name|dub
argument_list|)
expr_stmt|;
name|store_floating
argument_list|(
operator|&
name|nindy_regs
operator|.
name|fp_as_double
index|[
literal|8
operator|*
operator|(
name|regnum
operator|-
name|FP0_REGNUM
operator|)
index|]
argument_list|,
name|REGISTER_VIRTUAL_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|,
name|dub
argument_list|)
expr_stmt|;
block|}
name|immediate_quit
operator|++
expr_stmt|;
name|ninRegsPut
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|nindy_regs
argument_list|)
expr_stmt|;
name|immediate_quit
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read a word from remote address ADDR and return it.  * This goes through the data cache.  */
end_comment

begin_function
name|int
name|nindy_fetch_word
parameter_list|(
name|addr
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
return|return
name|dcache_fetch
argument_list|(
name|nindy_dcache
argument_list|,
name|addr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Write a word WORD into remote address ADDR.    This goes through the data cache.  */
end_comment

begin_function
name|void
name|nindy_store_word
parameter_list|(
name|addr
parameter_list|,
name|word
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|word
decl_stmt|;
block|{
name|dcache_poke
argument_list|(
name|nindy_dcache
argument_list|,
name|addr
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy LEN bytes to or from inferior's memory starting at MEMADDR    to debugger memory starting at MYADDR.   Copy to inferior if    WRITE is nonzero.  Returns the length copied.     This is stolen almost directly from infptrace.c's child_xfer_memory,    which also deals with a word-oriented memory interface.  Sometime,    FIXME, rewrite this to not use the word-oriented routines.  */
end_comment

begin_function
name|int
name|nindy_xfer_inferior_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|write
parameter_list|,
name|target
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|write
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
comment|/* ignored */
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Round starting address down to longword boundary.  */
specifier|register
name|CORE_ADDR
name|addr
init|=
name|memaddr
operator|&
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
comment|/* Round ending address up; get number of longwords that makes.  */
specifier|register
name|int
name|count
init|=
operator|(
operator|(
operator|(
name|memaddr
operator|+
name|len
operator|)
operator|-
name|addr
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
decl_stmt|;
comment|/* Allocate buffer of that many longwords.  */
specifier|register
name|int
modifier|*
name|buffer
init|=
operator|(
name|int
operator|*
operator|)
name|alloca
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|write
condition|)
block|{
comment|/* Fill start and end extra bytes of buffer with existing memory data.  */
if|if
condition|(
name|addr
operator|!=
name|memaddr
operator|||
name|len
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
block|{
comment|/* Need part of initial word -- fetch it.  */
name|buffer
index|[
literal|0
index|]
operator|=
name|nindy_fetch_word
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|>
literal|1
condition|)
comment|/* FIXME, avoid if even boundary */
block|{
name|buffer
index|[
name|count
operator|-
literal|1
index|]
operator|=
name|nindy_fetch_word
argument_list|(
name|addr
operator|+
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Copy data to be written over corresponding part of buffer */
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
operator|(
name|memaddr
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Write the entire buffer.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|nindy_store_word
argument_list|(
name|addr
argument_list|,
name|buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
comment|/* Read all the longwords */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|buffer
index|[
name|i
index|]
operator|=
name|nindy_fetch_word
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
condition|)
return|return
literal|0
return|;
name|QUIT
expr_stmt|;
block|}
comment|/* Copy appropriate bytes out of the buffer.  */
name|memcpy
argument_list|(
name|myaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
operator|(
name|memaddr
operator|&
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|nindy_create_inferior
parameter_list|(
name|execfile
parameter_list|,
name|args
parameter_list|,
name|env
parameter_list|)
name|char
modifier|*
name|execfile
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
name|char
modifier|*
modifier|*
name|env
decl_stmt|;
block|{
name|int
name|entry_pt
decl_stmt|;
name|int
name|pid
decl_stmt|;
if|if
condition|(
name|args
operator|&&
operator|*
name|args
condition|)
name|error
argument_list|(
literal|"Can't pass arguments to remote NINDY process"
argument_list|)
expr_stmt|;
if|if
condition|(
name|execfile
operator|==
literal|0
operator|||
name|exec_bfd
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No exec file specified"
argument_list|)
expr_stmt|;
name|entry_pt
operator|=
operator|(
name|int
operator|)
name|bfd_get_start_address
argument_list|(
name|exec_bfd
argument_list|)
expr_stmt|;
name|pid
operator|=
literal|42
expr_stmt|;
comment|/* The "process" (board) is already stopped awaiting our commands, and      the program is already downloaded.  We just set its PC and go.  */
name|inferior_pid
operator|=
name|pid
expr_stmt|;
comment|/* Needed for wait_for_inferior below */
name|clear_proceed_status
argument_list|()
expr_stmt|;
comment|/* Tell wait_for_inferior that we've started a new process.  */
name|init_wait_for_inferior
argument_list|()
expr_stmt|;
comment|/* Set up the "saved terminal modes" of the inferior      based on what modes we are starting it with.  */
name|target_terminal_init
argument_list|()
expr_stmt|;
comment|/* Install inferior's terminal modes.  */
name|target_terminal_inferior
argument_list|()
expr_stmt|;
comment|/* insert_step_breakpoint ();  FIXME, do we need this?  */
comment|/* Let 'er rip... */
name|proceed
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|entry_pt
argument_list|,
name|TARGET_SIGNAL_DEFAULT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|reset_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|nindy_serial
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"No target system to reset -- use 'target nindy' command."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|query
argument_list|(
literal|"Really reset the target system?"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|SERIAL_SEND_BREAK
argument_list|(
name|nindy_serial
argument_list|)
expr_stmt|;
name|tty_flush
argument_list|(
name|nindy_serial
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|nindy_kill
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
return|return;
comment|/* Ignore attempts to kill target system */
block|}
end_function

begin_comment
comment|/* Clean up when a program exits.     The program actually lives on in the remote processor's RAM, and may be    run again without a download.  Don't leave it full of breakpoint    instructions.  */
end_comment

begin_function
name|void
name|nindy_mourn_inferior
parameter_list|()
block|{
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|nindy_ops
argument_list|)
expr_stmt|;
name|generic_mourn_inferior
argument_list|()
expr_stmt|;
comment|/* Do all the proper things now */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Pass the args the way catch_errors wants them.  */
end_comment

begin_function
specifier|static
name|int
name|nindy_open_stub
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|nindy_open
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nindy_load
parameter_list|(
name|filename
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|asection
modifier|*
name|s
decl_stmt|;
comment|/* Can't do unix style forking on a VMS system, so we'll use bfd to do      all the work for us      */
name|bfd
modifier|*
name|file
init|=
name|bfd_openr
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|file
condition|)
block|{
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|file
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"can't prove it's an object file\n"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|s
operator|=
name|file
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
condition|)
block|{
name|char
modifier|*
name|buffer
init|=
name|xmalloc
argument_list|(
name|s
operator|->
name|_raw_size
argument_list|)
decl_stmt|;
name|bfd_get_section_contents
argument_list|(
name|file
argument_list|,
name|s
argument_list|,
name|buffer
argument_list|,
literal|0
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Loading section %s, size %x vma %x\n"
argument_list|,
name|s
operator|->
name|name
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|,
name|s
operator|->
name|vma
argument_list|)
expr_stmt|;
name|ninMemPut
argument_list|(
name|s
operator|->
name|vma
argument_list|,
name|buffer
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
name|bfd_close
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|load_stub
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|target_load
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* This routine is run as a hook, just before the main command loop is    entered.  If gdb is configured for the i960, but has not had its    nindy target specified yet, this will loop prompting the user to do so.     Unlike the loop provided by Intel, we actually let the user get out    of this with a RETURN.  This is useful when e.g. simply examining    an i960 object file on the host system.  */
end_comment

begin_function
name|void
name|nindy_before_main_loop
parameter_list|()
block|{
name|char
name|ttyname
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
while|while
condition|(
name|target_stack
operator|->
name|target_ops
operator|!=
operator|&
name|nindy_ops
condition|)
comment|/* What is this crap??? */
block|{
comment|/* remote tty not specified yet */
if|if
condition|(
name|instream
operator|==
name|stdin
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\nAttach /dev/ttyNN -- specify NN, or \"quit\" to quit:  "
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|fgets
argument_list|(
name|ttyname
argument_list|,
sizeof|sizeof
argument_list|(
name|ttyname
argument_list|)
operator|-
literal|1
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
comment|/* Strip leading and trailing whitespace */
for|for
control|(
name|p
operator|=
name|ttyname
init|;
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
block|{
empty_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
return|return;
comment|/* User just hit spaces or return, wants out */
block|}
for|for
control|(
name|p2
operator|=
name|p
init|;
operator|!
name|isspace
argument_list|(
operator|*
name|p2
argument_list|)
operator|&&
operator|(
operator|*
name|p2
operator|!=
literal|'\0'
operator|)
condition|;
name|p2
operator|++
control|)
block|{
empty_stmt|;
block|}
operator|*
name|p2
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
literal|"quit"
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|catch_errors
argument_list|(
name|nindy_open_stub
argument_list|,
name|p
argument_list|,
literal|""
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
condition|)
block|{
comment|/* Now that we have a tty open for talking to the remote machine, 	       download the executable file if one was specified.  */
if|if
condition|(
name|exec_bfd
condition|)
block|{
name|catch_errors
argument_list|(
name|load_stub
argument_list|,
name|bfd_get_filename
argument_list|(
name|exec_bfd
argument_list|)
argument_list|,
literal|""
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Define the target subroutine names */
end_comment

begin_decl_stmt
name|struct
name|target_ops
name|nindy_ops
init|=
block|{
literal|"nindy"
block|,
literal|"Remote serial target in i960 NINDY-specific protocol"
block|,
literal|"Use a remote i960 system running NINDY connected by a serial line.\n\ Specify the name of the device the serial line is connected to.\n\ The speed (baud rate), whether to use the old NINDY protocol,\n\ and whether to send a break on startup, are controlled by options\n\ specified when you started GDB."
block|,
name|nindy_open
block|,
name|nindy_close
block|,
literal|0
block|,
name|nindy_detach
block|,
name|nindy_resume
block|,
name|nindy_wait
block|,
name|nindy_fetch_registers
block|,
name|nindy_store_registers
block|,
name|nindy_prepare_to_store
block|,
name|nindy_xfer_inferior_memory
block|,
name|nindy_files_info
block|,
name|memory_insert_breakpoint
block|,
name|memory_remove_breakpoint
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* Terminal crud */
name|nindy_kill
block|,
name|nindy_load
block|,
literal|0
block|,
comment|/* lookup_symbol */
name|nindy_create_inferior
block|,
name|nindy_mourn_inferior
block|,
literal|0
block|,
comment|/* can_run */
literal|0
block|,
comment|/* notice_signals */
literal|0
block|,
comment|/* to_thread_alive */
literal|0
block|,
comment|/* to_stop */
name|process_stratum
block|,
literal|0
block|,
comment|/* next */
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
comment|/* all mem, mem, stack, regs, exec */
literal|0
block|,
literal|0
block|,
comment|/* Section pointers */
name|OPS_MAGIC
block|,
comment|/* Always the last thing */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_nindy
parameter_list|()
block|{
name|add_target
argument_list|(
operator|&
name|nindy_ops
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"reset"
argument_list|,
name|class_obscure
argument_list|,
name|reset_command
argument_list|,
literal|"Send a 'break' to the remote target system.\n\ Only useful if the target has been equipped with a circuit\n\ to perform a hard reset when a break is detected."
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

