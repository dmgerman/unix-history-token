begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Memory-access and commands for remote NINDY process, for GDB.     Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999,    2000, 2001, 2002 Free Software Foundation, Inc.     Contributed by Intel Corporation.  Modified from remote.c by Chris Benenati.     GDB is distributed in the hope that it will be useful, but WITHOUT ANY    WARRANTY.  No author or distributor accepts responsibility to anyone    for the consequences of using it or for whether it serves any    particular purpose or works at all, unless he says so in writing.    Refer to the GDB General Public License for full details.     Everyone is granted permission to copy, modify and redistribute GDB,    but only under the conditions described in the GDB General Public    License.  A copy of this license is supposed to have been given to you    along with GDB so you can know your rights and responsibilities.  It    should be in a file named COPYING.  Among other things, the copyright    notice and this notice must be preserved on all copies.     In other words, go ahead and share GDB, but don't try to stop    anyone else from sharing it farther.  Help stamp out software hoarding!  */
end_comment

begin_comment
comment|/*    Except for the data cache routines, this file bears little resemblence    to remote.c.  A new (although similar) protocol has been specified, and    portions of the code are entirely dependent on having an i80960 with a    NINDY ROM monitor at the other end of the line.  */
end_comment

begin_comment
comment|/*****************************************************************************  *  * REMOTE COMMUNICATION PROTOCOL BETWEEN GDB960 AND THE NINDY ROM MONITOR.  *  *  * MODES OF OPERATION  * ----- -- ---------  *	  * As far as NINDY is concerned, GDB is always in one of two modes: command  * mode or passthrough mode.  *  * In command mode (the default) pre-defined packets containing requests  * are sent by GDB to NINDY.  NINDY never talks except in reponse to a request.  *  * Once the the user program is started, GDB enters passthrough mode, to give  * the user program access to the terminal.  GDB remains in this mode until  * NINDY indicates that the program has stopped.  *  *  * PASSTHROUGH MODE  * ----------- ----  *  * GDB writes all input received from the keyboard directly to NINDY, and writes  * all characters received from NINDY directly to the monitor.  *  * Keyboard input is neither buffered nor echoed to the monitor.  *  * GDB remains in passthrough mode until NINDY sends a single ^P character,  * to indicate that the user process has stopped.  *  * Note:  *	GDB assumes NINDY performs a 'flushreg' when the user program stops.  *  *  * COMMAND MODE  * ------- ----  *  * All info (except for message ack and nak) is transferred between gdb  * and the remote processor in messages of the following format:  *  *<info>#<checksum>  *  * where   *	#	is a literal character  *  *<info>	ASCII information;  all numeric information is in the  *		form of hex digits ('0'-'9' and lowercase 'a'-'f').  *  *<checksum>  *		is a pair of ASCII hex digits representing an 8-bit  *		checksum formed by adding together each of the  *		characters in<info>.  *  * The receiver of a message always sends a single character to the sender  * to indicate that the checksum was good ('+') or bad ('-');  the sender  * re-transmits the entire message over until a '+' is received.  *  * In response to a command NINDY always sends back either data or  * a result code of the form "Xnn", where "nn" are hex digits and "X00"  * means no errors.  (Exceptions: the "s" and "c" commands don't respond.)  *  * SEE THE HEADER OF THE FILE "gdb.c" IN THE NINDY MONITOR SOURCE CODE FOR A  * FULL DESCRIPTION OF LEGAL COMMANDS.  *  * SEE THE FILE "stop.h" IN THE NINDY MONITOR SOURCE CODE FOR A LIST  * OF STOP CODES.  *  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"floatformat.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_include
include|#
directive|include
file|"nindy-share/env.h"
end_include

begin_include
include|#
directive|include
file|"nindy-share/stop.h"
end_include

begin_include
include|#
directive|include
file|"remote-utils.h"
end_include

begin_function_decl
specifier|extern
name|int
name|unlink
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|mktemp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|generic_mourn_inferior
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|nindy_ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|instream
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
name|ninStopWhy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|ninMemGet
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|ninMemPut
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|nindy_initial_brk
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nonzero if want to send an initial BREAK to nindy */
end_comment

begin_decl_stmt
name|int
name|nindy_old_protocol
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* nonzero if want to use old protocol */
end_comment

begin_decl_stmt
name|char
modifier|*
name|nindy_ttyname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of tty to talk to nindy on, or null */
end_comment

begin_define
define|#
directive|define
name|DLE
value|'\020'
end_define

begin_comment
comment|/* Character NINDY sends to indicate user program has 				   * halted.  */
end_comment

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_comment
comment|/* From nindy-share/nindy.c.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|serial
modifier|*
name|nindy_serial
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|have_regs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 iff regs read since i960 last halted */
end_comment

begin_decl_stmt
specifier|static
name|int
name|regs_changed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 iff regs were modified since last read */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|exists
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nindy_fetch_registers
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nindy_store_registers
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|char
modifier|*
name|savename
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|nindy_close
parameter_list|(
name|int
name|quitting
parameter_list|)
block|{
if|if
condition|(
name|nindy_serial
operator|!=
name|NULL
condition|)
name|serial_close
argument_list|(
name|nindy_serial
argument_list|)
expr_stmt|;
name|nindy_serial
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|savename
condition|)
name|xfree
argument_list|(
name|savename
argument_list|)
expr_stmt|;
name|savename
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Open a connection to a remote debugger.       FIXME, there should be "set" commands for the options that are    now specified with gdb command-line options (old_protocol,    and initial_brk).  */
end_comment

begin_function
name|void
name|nindy_open
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
comment|/* "/dev/ttyXX", "ttyXX", or "XX": tty to be opened */
name|int
name|from_tty
parameter_list|)
block|{
name|char
name|baudrate
index|[
literal|1024
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
name|error_no_arg
argument_list|(
literal|"serial port device name"
argument_list|)
expr_stmt|;
name|target_preopen
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
name|nindy_close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|have_regs
operator|=
name|regs_changed
operator|=
literal|0
expr_stmt|;
comment|/* Allow user to interrupt the following -- we could hang if there's      no NINDY at the other end of the remote tty.  */
name|immediate_quit
operator|++
expr_stmt|;
comment|/* If baud_rate is -1, then ninConnect will not recognize the baud rate      and will deal with the situation in a (more or less) reasonable      fashion.  */
name|sprintf
argument_list|(
name|baudrate
argument_list|,
literal|"%d"
argument_list|,
name|baud_rate
argument_list|)
expr_stmt|;
name|ninConnect
argument_list|(
name|name
argument_list|,
name|baudrate
argument_list|,
name|nindy_initial_brk
argument_list|,
operator|!
name|from_tty
argument_list|,
name|nindy_old_protocol
argument_list|)
expr_stmt|;
name|immediate_quit
operator|--
expr_stmt|;
if|if
condition|(
name|nindy_serial
operator|==
name|NULL
condition|)
block|{
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|savename
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|push_target
argument_list|(
operator|&
name|nindy_ops
argument_list|)
expr_stmt|;
name|target_fetch_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|init_thread_list
argument_list|()
expr_stmt|;
name|init_wait_for_inferior
argument_list|()
expr_stmt|;
name|clear_proceed_status
argument_list|()
expr_stmt|;
name|normal_stop
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* User-initiated quit of nindy operations.  */
end_comment

begin_function
specifier|static
name|void
name|nindy_detach
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|name
condition|)
name|error
argument_list|(
literal|"Too many arguments"
argument_list|)
expr_stmt|;
name|pop_target
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nindy_files_info
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* FIXME: this lies about the baud rate if we autobauded.  */
name|printf_unfiltered
argument_list|(
literal|"\tAttached to %s at %d bits per second%s%s.\n"
argument_list|,
name|savename
argument_list|,
name|baud_rate
argument_list|,
name|nindy_old_protocol
condition|?
literal|" in old protocol"
else|:
literal|""
argument_list|,
name|nindy_initial_brk
condition|?
literal|" with initial break"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the number of characters in the buffer BUF before    the first DLE character.  N is maximum number of characters to    consider.  */
end_comment

begin_function
specifier|static
name|int
name|non_dle
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
name|DLE
condition|)
block|{
break|break;
block|}
block|}
return|return
name|i
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Tell the remote machine to resume.  */
end_comment

begin_function
name|void
name|nindy_resume
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|step
parameter_list|,
name|enum
name|target_signal
name|siggnal
parameter_list|)
block|{
if|if
condition|(
name|siggnal
operator|!=
name|TARGET_SIGNAL_0
operator|&&
name|siggnal
operator|!=
name|stop_signal
condition|)
name|warning
argument_list|(
literal|"Can't send signals to remote NINDY targets."
argument_list|)
expr_stmt|;
if|if
condition|(
name|regs_changed
condition|)
block|{
name|nindy_store_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|regs_changed
operator|=
literal|0
expr_stmt|;
block|}
name|have_regs
operator|=
literal|0
expr_stmt|;
name|ninGo
argument_list|(
name|step
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* FIXME, we can probably use the normal terminal_inferior stuff here.    We have to do terminal_inferior and then set up the passthrough    settings initially.  Thereafter, terminal_ours and terminal_inferior    will automatically swap the settings around for us.  */
end_comment

begin_struct
struct|struct
name|clean_up_tty_args
block|{
name|serial_ttystate
name|state
decl_stmt|;
name|struct
name|serial
modifier|*
name|serial
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|clean_up_tty_args
name|tty_args
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|clean_up_tty
parameter_list|(
name|PTR
name|ptrarg
parameter_list|)
block|{
name|struct
name|clean_up_tty_args
modifier|*
name|args
init|=
operator|(
expr|struct
name|clean_up_tty_args
operator|*
operator|)
name|ptrarg
decl_stmt|;
name|serial_set_tty_state
argument_list|(
name|args
operator|->
name|serial
argument_list|,
name|args
operator|->
name|state
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|args
operator|->
name|state
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"\n\nYou may need to reset the 80960 and/or reload your program.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Recover from ^Z or ^C while remote process is running */
end_comment

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|old_ctrlc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|SIGTSTP
end_ifdef

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|old_ctrlz
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|clean_up_int
parameter_list|(
name|void
parameter_list|)
block|{
name|serial_set_tty_state
argument_list|(
name|tty_args
operator|.
name|serial
argument_list|,
name|tty_args
operator|.
name|state
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|tty_args
operator|.
name|state
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|old_ctrlc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGTSTP
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|old_ctrlz
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
argument_list|(
literal|"\n\nYou may need to reset the 80960 and/or reload your program.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wait until the remote machine stops. While waiting, operate in passthrough  * mode; i.e., pass everything NINDY sends to gdb_stdout, and everything from  * stdin to NINDY.  *  * Return to caller, storing status in 'status' just as `wait' would.  */
end_comment

begin_function
specifier|static
name|ptid_t
name|nindy_wait
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
name|status
parameter_list|)
block|{
name|fd_set
name|fds
decl_stmt|;
name|int
name|c
decl_stmt|;
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|unsigned
name|char
name|stop_exit
decl_stmt|;
name|unsigned
name|char
name|stop_code
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_cleanups
decl_stmt|;
name|long
name|ip_value
decl_stmt|,
name|fp_value
decl_stmt|,
name|sp_value
decl_stmt|;
comment|/* Reg values from stop */
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|integer
operator|=
literal|0
expr_stmt|;
comment|/* OPERATE IN PASSTHROUGH MODE UNTIL NINDY SENDS A DLE CHARACTER */
comment|/* Save current tty attributes, and restore them when done.  */
name|tty_args
operator|.
name|serial
operator|=
name|serial_fdopen
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|tty_args
operator|.
name|state
operator|=
name|serial_get_tty_state
argument_list|(
name|tty_args
operator|.
name|serial
argument_list|)
expr_stmt|;
name|old_ctrlc
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|clean_up_int
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGTSTP
name|old_ctrlz
operator|=
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|clean_up_int
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|old_cleanups
operator|=
name|make_cleanup
argument_list|(
name|clean_up_tty
argument_list|,
operator|&
name|tty_args
argument_list|)
expr_stmt|;
comment|/* Pass input from keyboard to NINDY as it arrives.  NINDY will interpret<CR> and perform echo.  */
comment|/* This used to set CBREAK and clear ECHO and CRMOD.  I hope this is close      enough.  */
name|serial_raw
argument_list|(
name|tty_args
operator|.
name|serial
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Input on remote */
name|c
operator|=
name|serial_readchar
argument_list|(
name|nindy_serial
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|SERIAL_ERROR
condition|)
block|{
name|error
argument_list|(
literal|"Cannot read from serial line"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|0x1b
condition|)
comment|/* ESC */
block|{
name|c
operator|=
name|serial_readchar
argument_list|(
name|nindy_serial
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|c
operator|&=
operator|~
literal|0x40
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|!=
literal|0x10
condition|)
comment|/* DLE */
comment|/* Write out any characters preceding DLE */
block|{
name|buf
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
name|write
argument_list|(
literal|1
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stop_exit
operator|=
name|ninStopWhy
argument_list|(
operator|&
name|stop_code
argument_list|,
operator|&
name|ip_value
argument_list|,
operator|&
name|fp_value
argument_list|,
operator|&
name|sp_value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stop_exit
operator|&&
operator|(
name|stop_code
operator|==
name|STOP_SRQ
operator|)
condition|)
block|{
name|immediate_quit
operator|++
expr_stmt|;
name|ninSrq
argument_list|()
expr_stmt|;
name|immediate_quit
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* Get out of loop */
name|supply_register
argument_list|(
name|IP_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ip_value
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|FP_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|fp_value
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|SP_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sp_value
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|serial_set_tty_state
argument_list|(
name|tty_args
operator|.
name|serial
argument_list|,
name|tty_args
operator|.
name|state
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|tty_args
operator|.
name|state
argument_list|)
expr_stmt|;
name|discard_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
if|if
condition|(
name|stop_exit
condition|)
block|{
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|integer
operator|=
name|stop_code
expr_stmt|;
block|}
else|else
block|{
comment|/* nindy has some special stop code need to be handled */
if|if
condition|(
name|stop_code
operator|==
name|STOP_GDB_BPT
condition|)
name|stop_code
operator|=
name|TRACE_STEP
expr_stmt|;
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|i960_fault_to_signal
argument_list|(
name|stop_code
argument_list|)
expr_stmt|;
block|}
return|return
name|inferior_ptid
return|;
block|}
end_function

begin_comment
comment|/* Read the remote registers into the block REGS.  */
end_comment

begin_comment
comment|/* This is the block that ninRegsGet and ninRegsPut handles.  */
end_comment

begin_struct
struct|struct
name|nindy_regs
block|{
name|char
name|local_regs
index|[
literal|16
operator|*
literal|4
index|]
decl_stmt|;
name|char
name|global_regs
index|[
literal|16
operator|*
literal|4
index|]
decl_stmt|;
name|char
name|pcw_acw
index|[
literal|2
operator|*
literal|4
index|]
decl_stmt|;
name|char
name|ip
index|[
literal|4
index|]
decl_stmt|;
name|char
name|tcw
index|[
literal|4
index|]
decl_stmt|;
name|char
name|fp_as_double
index|[
literal|4
operator|*
literal|8
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|nindy_fetch_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|struct
name|nindy_regs
name|nindy_regs
decl_stmt|;
name|int
name|regnum
decl_stmt|;
name|immediate_quit
operator|++
expr_stmt|;
name|ninRegsGet
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|nindy_regs
argument_list|)
expr_stmt|;
name|immediate_quit
operator|--
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|R0_REGNUM
argument_list|)
index|]
argument_list|,
name|nindy_regs
operator|.
name|local_regs
argument_list|,
literal|16
operator|*
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|G0_REGNUM
argument_list|)
index|]
argument_list|,
name|nindy_regs
operator|.
name|global_regs
argument_list|,
literal|16
operator|*
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|PCW_REGNUM
argument_list|)
index|]
argument_list|,
name|nindy_regs
operator|.
name|pcw_acw
argument_list|,
literal|2
operator|*
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|IP_REGNUM
argument_list|)
index|]
argument_list|,
name|nindy_regs
operator|.
name|ip
argument_list|,
literal|1
operator|*
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|TCW_REGNUM
argument_list|)
index|]
argument_list|,
name|nindy_regs
operator|.
name|tcw
argument_list|,
literal|1
operator|*
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
argument_list|)
index|]
argument_list|,
name|nindy_regs
operator|.
name|fp_as_double
argument_list|,
literal|4
operator|*
literal|8
argument_list|)
expr_stmt|;
name|registers_fetched
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nindy_prepare_to_store
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Fetch all regs if they aren't already here.  */
name|read_register_bytes
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
name|REGISTER_BYTES
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nindy_store_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|struct
name|nindy_regs
name|nindy_regs
decl_stmt|;
name|int
name|regnum
decl_stmt|;
name|memcpy
argument_list|(
name|nindy_regs
operator|.
name|local_regs
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|R0_REGNUM
argument_list|)
index|]
argument_list|,
literal|16
operator|*
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|nindy_regs
operator|.
name|global_regs
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|G0_REGNUM
argument_list|)
index|]
argument_list|,
literal|16
operator|*
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|nindy_regs
operator|.
name|pcw_acw
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|PCW_REGNUM
argument_list|)
index|]
argument_list|,
literal|2
operator|*
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|nindy_regs
operator|.
name|ip
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|IP_REGNUM
argument_list|)
index|]
argument_list|,
literal|1
operator|*
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|nindy_regs
operator|.
name|tcw
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|TCW_REGNUM
argument_list|)
index|]
argument_list|,
literal|1
operator|*
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|nindy_regs
operator|.
name|fp_as_double
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
argument_list|)
index|]
argument_list|,
literal|8
operator|*
literal|4
argument_list|)
expr_stmt|;
name|immediate_quit
operator|++
expr_stmt|;
name|ninRegsPut
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|nindy_regs
argument_list|)
expr_stmt|;
name|immediate_quit
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy LEN bytes to or from inferior's memory starting at MEMADDR    to debugger memory starting at MYADDR.   Copy to inferior if    SHOULD_WRITE is nonzero.  Returns the length copied.  TARGET is    unused.  */
end_comment

begin_function
name|int
name|nindy_xfer_inferior_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|should_write
parameter_list|,
name|struct
name|mem_attrib
modifier|*
name|attrib
parameter_list|,
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|should_write
condition|)
name|res
operator|=
name|ninMemPut
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|ninMemGet
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|nindy_create_inferior
parameter_list|(
name|char
modifier|*
name|execfile
parameter_list|,
name|char
modifier|*
name|args
parameter_list|,
name|char
modifier|*
modifier|*
name|env
parameter_list|)
block|{
name|int
name|entry_pt
decl_stmt|;
name|int
name|pid
decl_stmt|;
if|if
condition|(
name|args
operator|&&
operator|*
name|args
condition|)
name|error
argument_list|(
literal|"Can't pass arguments to remote NINDY process"
argument_list|)
expr_stmt|;
if|if
condition|(
name|execfile
operator|==
literal|0
operator|||
name|exec_bfd
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No executable file specified"
argument_list|)
expr_stmt|;
name|entry_pt
operator|=
operator|(
name|int
operator|)
name|bfd_get_start_address
argument_list|(
name|exec_bfd
argument_list|)
expr_stmt|;
name|pid
operator|=
literal|42
expr_stmt|;
comment|/* The "process" (board) is already stopped awaiting our commands, and      the program is already downloaded.  We just set its PC and go.  */
name|inferior_ptid
operator|=
name|pid_to_ptid
argument_list|(
name|pid
argument_list|)
expr_stmt|;
comment|/* Needed for wait_for_inferior below */
name|clear_proceed_status
argument_list|()
expr_stmt|;
comment|/* Tell wait_for_inferior that we've started a new process.  */
name|init_wait_for_inferior
argument_list|()
expr_stmt|;
comment|/* Set up the "saved terminal modes" of the inferior      based on what modes we are starting it with.  */
name|target_terminal_init
argument_list|()
expr_stmt|;
comment|/* Install inferior's terminal modes.  */
name|target_terminal_inferior
argument_list|()
expr_stmt|;
comment|/* insert_step_breakpoint ();  FIXME, do we need this?  */
comment|/* Let 'er rip... */
name|proceed
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|entry_pt
argument_list|,
name|TARGET_SIGNAL_DEFAULT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|reset_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|nindy_serial
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"No target system to reset -- use 'target nindy' command."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|query
argument_list|(
literal|"Really reset the target system?"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|serial_send_break
argument_list|(
name|nindy_serial
argument_list|)
expr_stmt|;
name|tty_flush
argument_list|(
name|nindy_serial
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|nindy_kill
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
return|return;
comment|/* Ignore attempts to kill target system */
block|}
end_function

begin_comment
comment|/* Clean up when a program exits.     The program actually lives on in the remote processor's RAM, and may be    run again without a download.  Don't leave it full of breakpoint    instructions.  */
end_comment

begin_function
name|void
name|nindy_mourn_inferior
parameter_list|(
name|void
parameter_list|)
block|{
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|nindy_ops
argument_list|)
expr_stmt|;
name|generic_mourn_inferior
argument_list|()
expr_stmt|;
comment|/* Do all the proper things now */
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Pass the args the way catch_errors wants them.  */
end_comment

begin_function
specifier|static
name|int
name|nindy_open_stub
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|nindy_open
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nindy_load
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|asection
modifier|*
name|s
decl_stmt|;
comment|/* Can't do unix style forking on a VMS system, so we'll use bfd to do      all the work for us    */
name|bfd
modifier|*
name|file
init|=
name|bfd_openr
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|file
condition|)
block|{
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|file
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"can't prove it's an object file\n"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|s
operator|=
name|file
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
condition|)
block|{
name|char
modifier|*
name|buffer
init|=
name|xmalloc
argument_list|(
name|s
operator|->
name|_raw_size
argument_list|)
decl_stmt|;
name|bfd_get_section_contents
argument_list|(
name|file
argument_list|,
name|s
argument_list|,
name|buffer
argument_list|,
literal|0
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Loading section %s, size %x vma %x\n"
argument_list|,
name|s
operator|->
name|name
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|,
name|s
operator|->
name|vma
argument_list|)
expr_stmt|;
name|ninMemPut
argument_list|(
name|s
operator|->
name|vma
argument_list|,
name|buffer
argument_list|,
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
block|}
name|bfd_close
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|load_stub
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|)
block|{
name|target_load
argument_list|(
name|arg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* This routine is run as a hook, just before the main command loop is    entered.  If gdb is configured for the i960, but has not had its    nindy target specified yet, this will loop prompting the user to do so.     Unlike the loop provided by Intel, we actually let the user get out    of this with a RETURN.  This is useful when e.g. simply examining    an i960 object file on the host system.  */
end_comment

begin_function
name|void
name|nindy_before_main_loop
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|ttyname
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|p2
decl_stmt|;
while|while
condition|(
name|target_stack
operator|->
name|target_ops
operator|!=
operator|&
name|nindy_ops
condition|)
comment|/* What is this crap??? */
block|{
comment|/* remote tty not specified yet */
if|if
condition|(
name|instream
operator|==
name|stdin
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"\nAttach /dev/ttyNN -- specify NN, or \"quit\" to quit:  "
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|fgets
argument_list|(
name|ttyname
argument_list|,
sizeof|sizeof
argument_list|(
name|ttyname
argument_list|)
operator|-
literal|1
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
comment|/* Strip leading and trailing whitespace */
for|for
control|(
name|p
operator|=
name|ttyname
init|;
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
block|{
empty_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
return|return;
comment|/* User just hit spaces or return, wants out */
block|}
for|for
control|(
name|p2
operator|=
name|p
init|;
operator|!
name|isspace
argument_list|(
operator|*
name|p2
argument_list|)
operator|&&
operator|(
operator|*
name|p2
operator|!=
literal|'\0'
operator|)
condition|;
name|p2
operator|++
control|)
block|{
empty_stmt|;
block|}
operator|*
name|p2
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
literal|"quit"
argument_list|,
name|p
argument_list|)
condition|)
block|{
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|catch_errors
argument_list|(
name|nindy_open_stub
argument_list|,
name|p
argument_list|,
literal|""
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
condition|)
block|{
comment|/* Now that we have a tty open for talking to the remote machine, 	     download the executable file if one was specified.  */
if|if
condition|(
name|exec_bfd
condition|)
block|{
name|catch_errors
argument_list|(
name|load_stub
argument_list|,
name|bfd_get_filename
argument_list|(
name|exec_bfd
argument_list|)
argument_list|,
literal|""
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Define the target subroutine names */
end_comment

begin_decl_stmt
name|struct
name|target_ops
name|nindy_ops
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|init_nindy_ops
parameter_list|(
name|void
parameter_list|)
block|{
name|nindy_ops
operator|.
name|to_shortname
operator|=
literal|"nindy"
expr_stmt|;
literal|"Remote serial target in i960 NINDY-specific protocol"
operator|,
name|nindy_ops
operator|.
name|to_longname
operator|=
literal|"Use a remote i960 system running NINDY connected by a serial line.\n\ Specify the name of the device the serial line is connected to.\n\ The speed (baud rate), whether to use the old NINDY protocol,\n\ and whether to send a break on startup, are controlled by options\n\ specified when you started GDB."
expr_stmt|;
name|nindy_ops
operator|.
name|to_doc
operator|=
literal|""
expr_stmt|;
name|nindy_ops
operator|.
name|to_open
operator|=
name|nindy_open
expr_stmt|;
name|nindy_ops
operator|.
name|to_close
operator|=
name|nindy_close
expr_stmt|;
name|nindy_ops
operator|.
name|to_attach
operator|=
literal|0
expr_stmt|;
name|nindy_ops
operator|.
name|to_post_attach
operator|=
name|NULL
expr_stmt|;
name|nindy_ops
operator|.
name|to_require_attach
operator|=
name|NULL
expr_stmt|;
name|nindy_ops
operator|.
name|to_detach
operator|=
name|nindy_detach
expr_stmt|;
name|nindy_ops
operator|.
name|to_require_detach
operator|=
name|NULL
expr_stmt|;
name|nindy_ops
operator|.
name|to_resume
operator|=
name|nindy_resume
expr_stmt|;
name|nindy_ops
operator|.
name|to_wait
operator|=
name|nindy_wait
expr_stmt|;
name|nindy_ops
operator|.
name|to_post_wait
operator|=
name|NULL
expr_stmt|;
name|nindy_ops
operator|.
name|to_fetch_registers
operator|=
name|nindy_fetch_registers
expr_stmt|;
name|nindy_ops
operator|.
name|to_store_registers
operator|=
name|nindy_store_registers
expr_stmt|;
name|nindy_ops
operator|.
name|to_prepare_to_store
operator|=
name|nindy_prepare_to_store
expr_stmt|;
name|nindy_ops
operator|.
name|to_xfer_memory
operator|=
name|nindy_xfer_inferior_memory
expr_stmt|;
name|nindy_ops
operator|.
name|to_files_info
operator|=
name|nindy_files_info
expr_stmt|;
name|nindy_ops
operator|.
name|to_insert_breakpoint
operator|=
name|memory_insert_breakpoint
expr_stmt|;
name|nindy_ops
operator|.
name|to_remove_breakpoint
operator|=
name|memory_remove_breakpoint
expr_stmt|;
name|nindy_ops
operator|.
name|to_terminal_init
operator|=
literal|0
expr_stmt|;
name|nindy_ops
operator|.
name|to_terminal_inferior
operator|=
literal|0
expr_stmt|;
name|nindy_ops
operator|.
name|to_terminal_ours_for_output
operator|=
literal|0
expr_stmt|;
name|nindy_ops
operator|.
name|to_terminal_ours
operator|=
literal|0
expr_stmt|;
name|nindy_ops
operator|.
name|to_terminal_info
operator|=
literal|0
expr_stmt|;
comment|/* Terminal crud */
name|nindy_ops
operator|.
name|to_kill
operator|=
name|nindy_kill
expr_stmt|;
name|nindy_ops
operator|.
name|to_load
operator|=
name|nindy_load
expr_stmt|;
name|nindy_ops
operator|.
name|to_lookup_symbol
operator|=
literal|0
expr_stmt|;
comment|/* lookup_symbol */
name|nindy_ops
operator|.
name|to_create_inferior
operator|=
name|nindy_create_inferior
expr_stmt|;
name|nindy_ops
operator|.
name|to_post_startup_inferior
operator|=
name|NULL
expr_stmt|;
name|nindy_ops
operator|.
name|to_acknowledge_created_inferior
operator|=
name|NULL
expr_stmt|;
name|nindy_ops
operator|.
name|to_clone_and_follow_inferior
operator|=
name|NULL
expr_stmt|;
name|nindy_ops
operator|.
name|to_post_follow_inferior_by_clone
operator|=
name|NULL
expr_stmt|;
name|nindy_ops
operator|.
name|to_insert_fork_catchpoint
operator|=
name|NULL
expr_stmt|;
name|nindy_ops
operator|.
name|to_remove_fork_catchpoint
operator|=
name|NULL
expr_stmt|;
name|nindy_ops
operator|.
name|to_insert_vfork_catchpoint
operator|=
name|NULL
expr_stmt|;
name|nindy_ops
operator|.
name|to_remove_vfork_catchpoint
operator|=
name|NULL
expr_stmt|;
name|nindy_ops
operator|.
name|to_has_forked
operator|=
name|NULL
expr_stmt|;
name|nindy_ops
operator|.
name|to_has_vforked
operator|=
name|NULL
expr_stmt|;
name|nindy_ops
operator|.
name|to_can_follow_vfork_prior_to_exec
operator|=
name|NULL
expr_stmt|;
name|nindy_ops
operator|.
name|to_post_follow_vfork
operator|=
name|NULL
expr_stmt|;
name|nindy_ops
operator|.
name|to_insert_exec_catchpoint
operator|=
name|NULL
expr_stmt|;
name|nindy_ops
operator|.
name|to_remove_exec_catchpoint
operator|=
name|NULL
expr_stmt|;
name|nindy_ops
operator|.
name|to_has_execd
operator|=
name|NULL
expr_stmt|;
name|nindy_ops
operator|.
name|to_reported_exec_events_per_exec_call
operator|=
name|NULL
expr_stmt|;
name|nindy_ops
operator|.
name|to_has_exited
operator|=
name|NULL
expr_stmt|;
name|nindy_ops
operator|.
name|to_mourn_inferior
operator|=
name|nindy_mourn_inferior
expr_stmt|;
name|nindy_ops
operator|.
name|to_can_run
operator|=
literal|0
expr_stmt|;
comment|/* can_run */
name|nindy_ops
operator|.
name|to_notice_signals
operator|=
literal|0
expr_stmt|;
comment|/* notice_signals */
name|nindy_ops
operator|.
name|to_thread_alive
operator|=
literal|0
expr_stmt|;
comment|/* to_thread_alive */
name|nindy_ops
operator|.
name|to_stop
operator|=
literal|0
expr_stmt|;
comment|/* to_stop */
name|nindy_ops
operator|.
name|to_pid_to_exec_file
operator|=
name|NULL
expr_stmt|;
name|nindy_ops
operator|.
name|to_stratum
operator|=
name|process_stratum
expr_stmt|;
name|nindy_ops
operator|.
name|DONT_USE
operator|=
literal|0
expr_stmt|;
comment|/* next */
name|nindy_ops
operator|.
name|to_has_all_memory
operator|=
literal|1
expr_stmt|;
name|nindy_ops
operator|.
name|to_has_memory
operator|=
literal|1
expr_stmt|;
name|nindy_ops
operator|.
name|to_has_stack
operator|=
literal|1
expr_stmt|;
name|nindy_ops
operator|.
name|to_has_registers
operator|=
literal|1
expr_stmt|;
name|nindy_ops
operator|.
name|to_has_execution
operator|=
literal|1
expr_stmt|;
comment|/* all mem, mem, stack, regs, exec */
name|nindy_ops
operator|.
name|to_sections
operator|=
literal|0
expr_stmt|;
name|nindy_ops
operator|.
name|to_sections_end
operator|=
literal|0
expr_stmt|;
comment|/* Section pointers */
name|nindy_ops
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
comment|/* Always the last thing */
block|}
end_function

begin_function
name|void
name|_initialize_nindy
parameter_list|(
name|void
parameter_list|)
block|{
name|init_nindy_ops
argument_list|()
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|nindy_ops
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"reset"
argument_list|,
name|class_obscure
argument_list|,
name|reset_command
argument_list|,
literal|"Send a 'break' to the remote target system.\n\ Only useful if the target has been equipped with a circuit\n\ to perform a hard reset when a break is detected."
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

