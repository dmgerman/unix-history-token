begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Support for printing C and C++ types for GDB, the GNU debugger.    Copyright 1986, 1988, 1989, 1991, 1993, 1994, 1995, 1996, 1998, 1999    Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_comment
comment|/* Binary File Description */
end_comment

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"c-lang.h"
end_include

begin_include
include|#
directive|include
file|"typeprint.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/* Flag indicating target was compiled by HP compiler */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|hp_som_som_object_present
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|c_type_print_args
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|,
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cp_type_print_derivation_info
name|PARAMS
argument_list|(
operator|(
name|GDB_FILE
operator|*
operator|,
expr|struct
name|type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|c_type_print_varspec_prefix
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|,
name|GDB_FILE
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|c_type_print_cv_qualifier
name|PARAMS
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|,
name|GDB_FILE
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Print a description of a type in the format of a     typedef for the current language.    NEW is the new name for a type TYPE. */
end_comment

begin_function
name|void
name|c_typedef_print
parameter_list|(
name|type
parameter_list|,
name|new
parameter_list|,
name|stream
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|symbol
modifier|*
name|new
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|current_language
operator|->
name|la_language
condition|)
block|{
ifdef|#
directive|ifdef
name|_LANG_c
case|case
name|language_c
case|:
case|case
name|language_cplus
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"typedef "
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
operator|(
name|SYMBOL_TYPE
argument_list|(
name|new
argument_list|)
operator|)
argument_list|)
operator|==
literal|0
operator|||
operator|!
name|STREQ
argument_list|(
name|TYPE_NAME
argument_list|(
operator|(
name|SYMBOL_TYPE
argument_list|(
name|new
argument_list|)
operator|)
argument_list|)
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|new
argument_list|)
argument_list|)
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" %s"
argument_list|,
name|SYMBOL_SOURCE_NAME
argument_list|(
name|new
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_LANG_m2
case|case
name|language_m2
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"TYPE "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|new
argument_list|)
argument_list|)
operator|||
operator|!
name|STREQ
argument_list|(
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|new
argument_list|)
argument_list|)
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|new
argument_list|)
argument_list|)
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s = "
argument_list|,
name|SYMBOL_SOURCE_NAME
argument_list|(
name|new
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<builtin> = "
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_LANG_chill
case|case
name|language_chill
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"SYNMODE "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|new
argument_list|)
argument_list|)
operator|||
operator|!
name|STREQ
argument_list|(
name|TYPE_NAME
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|new
argument_list|)
argument_list|)
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|new
argument_list|)
argument_list|)
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s = "
argument_list|,
name|SYMBOL_SOURCE_NAME
argument_list|(
name|new
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<builtin> = "
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|error
argument_list|(
literal|"Language not supported."
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* LEVEL is the depth to indent lines by.  */
end_comment

begin_function
name|void
name|c_print_type
parameter_list|(
name|type
parameter_list|,
name|varstring
parameter_list|,
name|stream
parameter_list|,
name|show
parameter_list|,
name|level
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|varstring
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|show
decl_stmt|;
name|int
name|level
decl_stmt|;
block|{
specifier|register
name|enum
name|type_code
name|code
decl_stmt|;
name|int
name|demangled_args
decl_stmt|;
if|if
condition|(
name|show
operator|>
literal|0
condition|)
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|c_type_print_base
argument_list|(
name|type
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|code
operator|=
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|varstring
operator|!=
name|NULL
operator|&&
operator|*
name|varstring
operator|!=
literal|'\0'
operator|)
operator|||
comment|/* Need a space if going to print stars or brackets; 	 but not if we will print just a type name.  */
operator|(
operator|(
name|show
operator|>
literal|0
operator|||
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|code
operator|==
name|TYPE_CODE_PTR
operator|||
name|code
operator|==
name|TYPE_CODE_FUNC
operator|||
name|code
operator|==
name|TYPE_CODE_METHOD
operator|||
name|code
operator|==
name|TYPE_CODE_ARRAY
operator|||
name|code
operator|==
name|TYPE_CODE_MEMBER
operator|||
name|code
operator|==
name|TYPE_CODE_REF
operator|)
operator|)
condition|)
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|c_type_print_varspec_prefix
argument_list|(
name|type
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|varstring
operator|!=
name|NULL
condition|)
block|{
name|fputs_filtered
argument_list|(
name|varstring
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* For demangled function names, we have the arglist as part of the name, 	 so don't print an additional pair of ()'s */
name|demangled_args
operator|=
name|strchr
argument_list|(
name|varstring
argument_list|,
literal|'('
argument_list|)
operator|!=
name|NULL
expr_stmt|;
name|c_type_print_varspec_suffix
argument_list|(
name|type
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
literal|0
argument_list|,
name|demangled_args
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* If TYPE is a derived type, then print out derivation information.    Print only the actual base classes of this type, not the base classes    of the base classes.  I.E.  for the derivation hierarchy:  	class A { int a; }; 	class B : public A {int b; }; 	class C : public B {int c; };     Print the type of class C as:     	class C : public B { 		int c; 	}     Not as the following (like gdb used to), which is not legal C++ syntax for    derived types and may be confused with the multiple inheritance form:  	class C : public B : public A { 		int c; 	}     In general, gdb should try to print the types as closely as possible to    the form that they appear in the source code.     Note that in case of protected derivation gcc will not say 'protected'     but 'private'. The HP's aCC compiler emits specific information for     derivation via protected inheritance, so gdb can print it out */
end_comment

begin_function
specifier|static
name|void
name|cp_type_print_derivation_info
parameter_list|(
name|stream
parameter_list|,
name|type
parameter_list|)
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|fputs_filtered
argument_list|(
name|i
operator|==
literal|0
condition|?
literal|": "
else|:
literal|", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s%s "
argument_list|,
name|BASETYPE_VIA_PUBLIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|?
literal|"public"
else|:
operator|(
name|TYPE_FIELD_PROTECTED
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|?
literal|"protected"
else|:
literal|"private"
operator|)
argument_list|,
name|BASETYPE_VIA_VIRTUAL
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|?
literal|" virtual"
else|:
literal|""
argument_list|)
expr_stmt|;
name|name
operator|=
name|type_name_no_tag
argument_list|(
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|name
condition|?
name|name
else|:
literal|"(null)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print the C++ method arguments ARGS to the file STREAM.  */
end_comment

begin_function
name|void
name|cp_type_print_method_args
parameter_list|(
name|args
parameter_list|,
name|prefix
parameter_list|,
name|varstring
parameter_list|,
name|staticp
parameter_list|,
name|stream
parameter_list|)
name|struct
name|type
modifier|*
modifier|*
name|args
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
name|char
modifier|*
name|varstring
decl_stmt|;
name|int
name|staticp
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|fprintf_symbol_filtered
argument_list|(
name|stream
argument_list|,
name|prefix
argument_list|,
name|language_cplus
argument_list|,
name|DMGL_ANSI
argument_list|)
expr_stmt|;
name|fprintf_symbol_filtered
argument_list|(
name|stream
argument_list|,
name|varstring
argument_list|,
name|language_cplus
argument_list|,
name|DMGL_ANSI
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"("
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|&&
name|args
index|[
operator|!
name|staticp
index|]
operator|&&
name|args
index|[
operator|!
name|staticp
index|]
operator|->
name|code
operator|!=
name|TYPE_CODE_VOID
condition|)
block|{
name|i
operator|=
operator|!
name|staticp
expr_stmt|;
comment|/* skip the class variable */
while|while
condition|(
literal|1
condition|)
block|{
name|type_print
argument_list|(
name|args
index|[
name|i
operator|++
index|]
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|args
index|[
name|i
index|]
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" ..."
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|->
name|code
operator|!=
name|TYPE_CODE_VOID
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|current_language
operator|->
name|la_language
operator|==
name|language_cplus
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"void"
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print any asterisks or open-parentheses needed before the    variable name (to describe its type).     On outermost call, pass 0 for PASSED_A_PTR.    On outermost call, SHOW> 0 means should ignore    any typename for TYPE and show its details.    SHOW is always zero on recursive calls.  */
end_comment

begin_function
name|void
name|c_type_print_varspec_prefix
parameter_list|(
name|type
parameter_list|,
name|stream
parameter_list|,
name|show
parameter_list|,
name|passed_a_ptr
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|show
decl_stmt|;
name|int
name|passed_a_ptr
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|show
operator|<=
literal|0
condition|)
return|return;
name|QUIT
expr_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_PTR
case|:
name|c_type_print_varspec_prefix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
name|c_type_print_cv_qualifier
argument_list|(
name|type
argument_list|,
name|stream
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_MEMBER
case|:
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|c_type_print_varspec_prefix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|name
operator|=
name|type_name_no_tag
argument_list|(
name|TYPE_DOMAIN_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|fputs_filtered
argument_list|(
name|name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|c_type_print_base
argument_list|(
name|TYPE_DOMAIN_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|passed_a_ptr
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_METHOD
case|:
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|c_type_print_varspec_prefix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|passed_a_ptr
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|c_type_print_base
argument_list|(
name|TYPE_DOMAIN_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|passed_a_ptr
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_REF
case|:
name|c_type_print_varspec_prefix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
name|c_type_print_cv_qualifier
argument_list|(
name|type
argument_list|,
name|stream
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_FUNC
case|:
name|c_type_print_varspec_prefix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_ARRAY
case|:
name|c_type_print_varspec_prefix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_UNDEF
case|:
case|case
name|TYPE_CODE_STRUCT
case|:
case|case
name|TYPE_CODE_UNION
case|:
case|case
name|TYPE_CODE_ENUM
case|:
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_FLT
case|:
case|case
name|TYPE_CODE_VOID
case|:
case|case
name|TYPE_CODE_ERROR
case|:
case|case
name|TYPE_CODE_CHAR
case|:
case|case
name|TYPE_CODE_BOOL
case|:
case|case
name|TYPE_CODE_SET
case|:
case|case
name|TYPE_CODE_RANGE
case|:
case|case
name|TYPE_CODE_STRING
case|:
case|case
name|TYPE_CODE_BITSTRING
case|:
case|case
name|TYPE_CODE_COMPLEX
case|:
case|case
name|TYPE_CODE_TYPEDEF
case|:
comment|/* These types need no prefix.  They are listed here so that 	 gcc -Wall will reveal any types that haven't been handled.  */
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Print out "const" and "volatile" attributes.    TYPE is a pointer to the type being printed out.    STREAM is the output destination.    NEED_SPACE = 1 indicates an initial white space is needed */
end_comment

begin_function
specifier|static
name|void
name|c_type_print_cv_qualifier
parameter_list|(
name|type
parameter_list|,
name|stream
parameter_list|,
name|need_pre_space
parameter_list|,
name|need_post_space
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|need_pre_space
decl_stmt|;
name|int
name|need_post_space
decl_stmt|;
block|{
name|int
name|flag
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|TYPE_CONST
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|need_pre_space
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"const"
argument_list|)
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_VOLATILE
argument_list|(
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|flag
operator|||
name|need_pre_space
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"volatile"
argument_list|)
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|flag
operator|&&
name|need_post_space
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|c_type_print_args
parameter_list|(
name|type
parameter_list|,
name|stream
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|type
modifier|*
modifier|*
name|args
decl_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|args
operator|=
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|args
index|[
literal|1
index|]
operator|==
name|NULL
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|args
index|[
literal|1
index|]
operator|->
name|code
operator|==
name|TYPE_CODE_VOID
operator|)
operator|&&
operator|(
name|current_language
operator|->
name|la_language
operator|==
name|language_cplus
operator|)
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"void"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|args
index|[
name|i
index|]
operator|!=
name|NULL
operator|&&
name|args
index|[
name|i
index|]
operator|->
name|code
operator|!=
name|TYPE_CODE_VOID
condition|;
name|i
operator|++
control|)
block|{
name|c_print_type
argument_list|(
name|args
index|[
name|i
index|]
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
index|[
name|i
operator|+
literal|1
index|]
operator|==
name|NULL
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
operator|+
literal|1
index|]
operator|->
name|code
operator|!=
name|TYPE_CODE_VOID
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|current_language
operator|->
name|la_language
operator|==
name|language_cplus
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"void"
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print any array sizes, function arguments or close parentheses    needed after the variable name (to describe its type).    Args work like c_type_print_varspec_prefix.  */
end_comment

begin_function
name|void
name|c_type_print_varspec_suffix
parameter_list|(
name|type
parameter_list|,
name|stream
parameter_list|,
name|show
parameter_list|,
name|passed_a_ptr
parameter_list|,
name|demangled_args
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|show
decl_stmt|;
name|int
name|passed_a_ptr
decl_stmt|;
name|int
name|demangled_args
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|show
operator|<=
literal|0
condition|)
return|return;
name|QUIT
expr_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_ARRAY
case|:
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"["
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|>=
literal|0
operator|&&
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|>
literal|0
operator|&&
name|TYPE_ARRAY_UPPER_BOUND_TYPE
argument_list|(
name|type
argument_list|)
operator|!=
name|BOUND_CANNOT_BE_DETERMINED
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|/
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
name|c_type_print_varspec_suffix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_MEMBER
case|:
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|c_type_print_varspec_suffix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_METHOD
case|:
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|c_type_print_varspec_suffix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|passed_a_ptr
condition|)
block|{
name|c_type_print_args
argument_list|(
name|type
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_PTR
case|:
case|case
name|TYPE_CODE_REF
case|:
name|c_type_print_varspec_suffix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_FUNC
case|:
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|demangled_args
condition|)
block|{
name|int
name|i
decl_stmt|,
name|len
init|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|==
literal|0
operator|)
operator|&&
operator|(
name|current_language
operator|->
name|la_language
operator|==
name|language_cplus
operator|)
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"void"
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
block|}
name|c_print_type
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
name|c_type_print_varspec_suffix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|passed_a_ptr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_UNDEF
case|:
case|case
name|TYPE_CODE_STRUCT
case|:
case|case
name|TYPE_CODE_UNION
case|:
case|case
name|TYPE_CODE_ENUM
case|:
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_FLT
case|:
case|case
name|TYPE_CODE_VOID
case|:
case|case
name|TYPE_CODE_ERROR
case|:
case|case
name|TYPE_CODE_CHAR
case|:
case|case
name|TYPE_CODE_BOOL
case|:
case|case
name|TYPE_CODE_SET
case|:
case|case
name|TYPE_CODE_RANGE
case|:
case|case
name|TYPE_CODE_STRING
case|:
case|case
name|TYPE_CODE_BITSTRING
case|:
case|case
name|TYPE_CODE_COMPLEX
case|:
case|case
name|TYPE_CODE_TYPEDEF
case|:
comment|/* These types do not need a suffix.  They are listed so that 	 gcc -Wall will report types that may not have been considered.  */
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Print the name of the type (or the ultimate pointer target,    function value or array element), or the description of a    structure or union.     SHOW positive means print details about the type (e.g. enum values),    and print structure elements passing SHOW - 1 for show.    SHOW negative means just print the type name or struct tag if there is one.    If there is no name, print something sensible but concise like    "struct {...}".    SHOW zero means just print the type name or struct tag if there is one.    If there is no name, print something sensible but not as concise like    "struct {int x; int y;}".     LEVEL is the number of spaces to indent by.    We increase it for some recursive calls.  */
end_comment

begin_function
name|void
name|c_type_print_base
parameter_list|(
name|type
parameter_list|,
name|stream
parameter_list|,
name|show
parameter_list|,
name|level
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|show
decl_stmt|;
name|int
name|level
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|int
name|lastval
decl_stmt|;
name|char
modifier|*
name|mangled_name
decl_stmt|;
name|char
modifier|*
name|demangled_name
decl_stmt|;
name|char
modifier|*
name|demangled_no_static
decl_stmt|;
enum|enum
block|{
name|s_none
block|,
name|s_public
block|,
name|s_private
block|,
name|s_protected
block|}
name|section_type
enum|;
name|int
name|need_access_label
init|=
literal|0
decl_stmt|;
name|int
name|j
decl_stmt|,
name|len2
decl_stmt|;
name|QUIT
expr_stmt|;
name|wrap_here
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"<type unknown>"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* When SHOW is zero or less, and there is a valid type name, then always      just print the type name directly from the type.  */
comment|/* If we have "typedef struct foo {. . .} bar;" do we want to print it      as "struct foo" or as "bar"?  Pick the latter, because C++ folk tend      to expect things like "class5 *foo" rather than "struct class5 *foo".  */
if|if
condition|(
name|show
operator|<=
literal|0
operator|&&
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|c_type_print_cv_qualifier
argument_list|(
name|type
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
block|}
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_TYPEDEF
case|:
case|case
name|TYPE_CODE_ARRAY
case|:
case|case
name|TYPE_CODE_PTR
case|:
case|case
name|TYPE_CODE_MEMBER
case|:
case|case
name|TYPE_CODE_REF
case|:
case|case
name|TYPE_CODE_FUNC
case|:
case|case
name|TYPE_CODE_METHOD
case|:
name|c_type_print_base
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
name|level
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_STRUCT
case|:
name|c_type_print_cv_qualifier
argument_list|(
name|type
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Note TYPE_CODE_STRUCT and TYPE_CODE_CLASS have the same value,        * so we use another means for distinguishing them.        */
if|if
condition|(
name|HAVE_CPLUS_STRUCT
argument_list|(
name|type
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|TYPE_DECLARED_TYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|DECLARED_TYPE_CLASS
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"class "
argument_list|)
expr_stmt|;
break|break;
case|case
name|DECLARED_TYPE_UNION
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"union "
argument_list|)
expr_stmt|;
break|break;
case|case
name|DECLARED_TYPE_STRUCT
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"struct "
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* If there is a CPLUS_STRUCT, assume class if not              * otherwise specified in the declared_type field.              */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"class "
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* switch */
block|}
else|else
block|{
comment|/* If not CPLUS_STRUCT, then assume it's a C struct */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"struct "
argument_list|)
expr_stmt|;
block|}
goto|goto
name|struct_union
goto|;
case|case
name|TYPE_CODE_UNION
case|:
name|c_type_print_cv_qualifier
argument_list|(
name|type
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"union "
argument_list|)
expr_stmt|;
name|struct_union
label|:
comment|/* Print the tag if it exists.         * The HP aCC compiler emits        * a spurious "{unnamed struct}"/"{unnamed union}"/"{unnamed enum}"        * tag  for unnamed struct/union/enum's, which we don't        * want to print.        */
if|if
condition|(
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
operator|&&
name|strncmp
argument_list|(
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
literal|"{unnamed"
argument_list|,
literal|8
argument_list|)
condition|)
block|{
name|fputs_filtered
argument_list|(
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|show
operator|>
literal|0
condition|)
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|wrap_here
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
if|if
condition|(
name|show
operator|<
literal|0
condition|)
block|{
comment|/* If we just printed a tag name, no need to print anything else.  */
if|if
condition|(
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|==
name|NULL
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{...}"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|show
operator|>
literal|0
operator|||
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|cp_type_print_derivation_info
argument_list|(
name|stream
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&
name|TYPE_FLAG_STUB
condition|)
name|fprintfi_filtered
argument_list|(
name|level
operator|+
literal|4
argument_list|,
name|stream
argument_list|,
literal|"<incomplete type>\n"
argument_list|)
expr_stmt|;
else|else
name|fprintfi_filtered
argument_list|(
name|level
operator|+
literal|4
argument_list|,
name|stream
argument_list|,
literal|"<no data fields>\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Start off with no specific section type, so we can print 	     one for the first field we find, and use that section type 	     thereafter until we find another type. */
name|section_type
operator|=
name|s_none
expr_stmt|;
comment|/* For a class, if all members are private, there's no need              for a "private:" label; similarly, for a struct or union              masquerading as a class, if all members are public, there's              no need for a "public:" label. */
if|if
condition|(
operator|(
name|TYPE_DECLARED_TYPE
argument_list|(
name|type
argument_list|)
operator|==
name|DECLARED_TYPE_CLASS
operator|)
operator|||
operator|(
name|TYPE_DECLARED_TYPE
argument_list|(
name|type
argument_list|)
operator|==
name|DECLARED_TYPE_TEMPLATE
operator|)
condition|)
block|{
name|QUIT
expr_stmt|;
name|len
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|TYPE_FIELD_PRIVATE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|need_access_label
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|QUIT
expr_stmt|;
if|if
condition|(
operator|!
name|need_access_label
condition|)
block|{
name|len2
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len2
condition|;
name|j
operator|++
control|)
block|{
name|len
operator|=
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|type
argument_list|,
name|j
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|TYPE_FN_FIELD_PRIVATE
argument_list|(
name|TYPE_FN_FIELDLIST1
argument_list|(
name|type
argument_list|,
name|j
argument_list|)
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|need_access_label
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|need_access_label
condition|)
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|TYPE_DECLARED_TYPE
argument_list|(
name|type
argument_list|)
operator|==
name|DECLARED_TYPE_STRUCT
operator|)
operator|||
operator|(
name|TYPE_DECLARED_TYPE
argument_list|(
name|type
argument_list|)
operator|==
name|DECLARED_TYPE_UNION
operator|)
condition|)
block|{
name|QUIT
expr_stmt|;
name|len
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TYPE_FIELD_PRIVATE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|||
name|TYPE_FIELD_PROTECTED
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|need_access_label
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|QUIT
expr_stmt|;
if|if
condition|(
operator|!
name|need_access_label
condition|)
block|{
name|len2
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len2
condition|;
name|j
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
name|len
operator|=
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|type
argument_list|,
name|j
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|TYPE_FN_FIELD_PRIVATE
argument_list|(
name|TYPE_FN_FIELDLIST1
argument_list|(
name|type
argument_list|,
name|j
argument_list|)
argument_list|,
name|i
argument_list|)
operator|||
name|TYPE_FN_FIELD_PROTECTED
argument_list|(
name|TYPE_FN_FIELDLIST1
argument_list|(
name|type
argument_list|,
name|j
argument_list|)
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|need_access_label
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|need_access_label
condition|)
break|break;
block|}
block|}
block|}
comment|/* If there is a base class for this type, 	     do not print the field that it occupies.  */
name|len
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
comment|/* Don't print out virtual function table.  */
comment|/* HP ANSI C++ case */
if|if
condition|(
name|TYPE_HAS_VTABLE
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|STREQN
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
literal|"__vfp"
argument_list|,
literal|5
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* Other compilers */
comment|/* pai:: FIXME : check for has_vtable< 0 */
if|if
condition|(
name|STREQN
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
literal|"_vptr"
argument_list|,
literal|5
argument_list|)
operator|&&
name|is_cplus_marker
argument_list|(
operator|(
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|)
index|[
literal|5
index|]
argument_list|)
condition|)
continue|continue;
comment|/* If this is a C++ class we can print the various C++ section 		 labels. */
if|if
condition|(
name|HAVE_CPLUS_STRUCT
argument_list|(
name|type
argument_list|)
operator|&&
name|need_access_label
condition|)
block|{
if|if
condition|(
name|TYPE_FIELD_PROTECTED
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|section_type
operator|!=
name|s_protected
condition|)
block|{
name|section_type
operator|=
name|s_protected
expr_stmt|;
name|fprintfi_filtered
argument_list|(
name|level
operator|+
literal|2
argument_list|,
name|stream
argument_list|,
literal|"protected:\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TYPE_FIELD_PRIVATE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
if|if
condition|(
name|section_type
operator|!=
name|s_private
condition|)
block|{
name|section_type
operator|=
name|s_private
expr_stmt|;
name|fprintfi_filtered
argument_list|(
name|level
operator|+
literal|2
argument_list|,
name|stream
argument_list|,
literal|"private:\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|section_type
operator|!=
name|s_public
condition|)
block|{
name|section_type
operator|=
name|s_public
expr_stmt|;
name|fprintfi_filtered
argument_list|(
name|level
operator|+
literal|2
argument_list|,
name|stream
argument_list|,
literal|"public:\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|print_spaces_filtered
argument_list|(
name|level
operator|+
literal|4
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FIELD_STATIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"static "
argument_list|)
expr_stmt|;
block|}
name|c_print_type
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|stream
argument_list|,
name|show
operator|-
literal|1
argument_list|,
name|level
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_FIELD_STATIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|&&
name|TYPE_FIELD_PACKED
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
comment|/* It is a bitfield.  This code does not attempt 		     to look at the bitpos and reconstruct filler, 		     unnamed fields.  This would lead to misleading 		     results if the compiler does not put out fields 		     for such things (I don't know what it does).  */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" : %d"
argument_list|,
name|TYPE_FIELD_BITSIZE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
block|}
comment|/* If there are both fields and methods, put a space between. */
name|len
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|&&
name|section_type
operator|!=
name|s_none
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* C++: print out the methods */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|fn_field
modifier|*
name|f
init|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|j
decl_stmt|,
name|len2
init|=
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|char
modifier|*
name|method_name
init|=
name|TYPE_FN_FIELDLIST_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|type_name_no_tag
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|is_constructor
init|=
name|name
operator|&&
name|STREQ
argument_list|(
name|method_name
argument_list|,
name|name
argument_list|)
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len2
condition|;
name|j
operator|++
control|)
block|{
name|char
modifier|*
name|physname
init|=
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|int
name|is_full_physname_constructor
init|=
operator|(
operator|(
name|physname
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|physname
index|[
literal|1
index|]
operator|==
literal|'_'
operator|&&
name|strchr
argument_list|(
literal|"0123456789Qt"
argument_list|,
name|physname
index|[
literal|2
index|]
argument_list|)
operator|)
operator|||
name|STREQN
argument_list|(
name|physname
argument_list|,
literal|"__ct__"
argument_list|,
literal|6
argument_list|)
operator|||
name|DESTRUCTOR_PREFIX_P
argument_list|(
name|physname
argument_list|)
operator|||
name|STREQN
argument_list|(
name|physname
argument_list|,
literal|"__dt__"
argument_list|,
literal|6
argument_list|)
operator|)
decl_stmt|;
name|QUIT
expr_stmt|;
if|if
condition|(
name|TYPE_FN_FIELD_PROTECTED
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
block|{
if|if
condition|(
name|section_type
operator|!=
name|s_protected
condition|)
block|{
name|section_type
operator|=
name|s_protected
expr_stmt|;
name|fprintfi_filtered
argument_list|(
name|level
operator|+
literal|2
argument_list|,
name|stream
argument_list|,
literal|"protected:\n"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|TYPE_FN_FIELD_PRIVATE
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
block|{
if|if
condition|(
name|section_type
operator|!=
name|s_private
condition|)
block|{
name|section_type
operator|=
name|s_private
expr_stmt|;
name|fprintfi_filtered
argument_list|(
name|level
operator|+
literal|2
argument_list|,
name|stream
argument_list|,
literal|"private:\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|section_type
operator|!=
name|s_public
condition|)
block|{
name|section_type
operator|=
name|s_public
expr_stmt|;
name|fprintfi_filtered
argument_list|(
name|level
operator|+
literal|2
argument_list|,
name|stream
argument_list|,
literal|"public:\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|print_spaces_filtered
argument_list|(
name|level
operator|+
literal|4
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FN_FIELD_VIRTUAL_P
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"virtual "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_FN_FIELD_STATIC_P
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"static "
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_TARGET_TYPE
argument_list|(
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Keep GDB from crashing here.  */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<undefined type> %s;\n"
argument_list|,
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|!
name|is_constructor
operator|&&
comment|/* constructors don't have declared types */
operator|!
name|is_full_physname_constructor
operator|&&
comment|/*    " "  */
operator|!
name|strstr
argument_list|(
name|method_name
argument_list|,
literal|"operator "
argument_list|)
condition|)
comment|/* Not a type conversion operator */
comment|/* (note space -- other operators don't have it) */
block|{
name|type_print
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|)
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_FN_FIELD_STUB
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
comment|/* Build something we can demangle.  */
name|mangled_name
operator|=
name|gdb_mangle_name
argument_list|(
name|type
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
else|else
name|mangled_name
operator|=
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|demangled_name
operator|=
name|cplus_demangle
argument_list|(
name|mangled_name
argument_list|,
name|DMGL_ANSI
operator||
name|DMGL_PARAMS
argument_list|)
expr_stmt|;
if|if
condition|(
name|demangled_name
operator|==
name|NULL
condition|)
block|{
comment|/* in some cases (for instance with the HP demangling), 			 if a function has more than 10 arguments,  			 the demangling will fail. 			 Let's try to reconstruct the function signature from  			 the symbol information	*/
if|if
condition|(
operator|!
name|TYPE_FN_FIELD_STUB
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
name|cp_type_print_method_args
argument_list|(
name|TYPE_FN_FIELD_ARGS
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|,
literal|""
argument_list|,
name|method_name
argument_list|,
name|TYPE_FN_FIELD_STATIC_P
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<badly mangled name '%s'>"
argument_list|,
name|mangled_name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|demangled_no_class
init|=
name|demangled_name
decl_stmt|;
while|while
condition|(
name|p
operator|=
name|strchr
argument_list|(
name|demangled_no_class
argument_list|,
literal|':'
argument_list|)
condition|)
block|{
name|demangled_no_class
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|*
operator|++
name|demangled_no_class
operator|==
literal|':'
condition|)
operator|++
name|demangled_no_class
expr_stmt|;
block|}
comment|/* get rid of the static word appended by the demangler */
name|p
operator|=
name|strstr
argument_list|(
name|demangled_no_class
argument_list|,
literal|" static"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|int
name|length
init|=
name|p
operator|-
name|demangled_no_class
decl_stmt|;
name|demangled_no_static
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|demangled_no_static
argument_list|,
name|demangled_no_class
argument_list|,
name|length
argument_list|)
expr_stmt|;
operator|*
operator|(
name|demangled_no_static
operator|+
name|length
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|fputs_filtered
argument_list|(
name|demangled_no_static
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|demangled_no_static
argument_list|)
expr_stmt|;
block|}
else|else
name|fputs_filtered
argument_list|(
name|demangled_no_class
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|demangled_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_FN_FIELD_STUB
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
name|free
argument_list|(
name|mangled_name
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TYPE_LOCALTYPE_PTR
argument_list|(
name|type
argument_list|)
operator|&&
name|show
operator|>=
literal|0
condition|)
name|fprintfi_filtered
argument_list|(
name|level
argument_list|,
name|stream
argument_list|,
literal|" (Local at %s:%d)\n"
argument_list|,
name|TYPE_LOCALTYPE_FILE
argument_list|(
name|type
argument_list|)
argument_list|,
name|TYPE_LOCALTYPE_LINE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|fprintfi_filtered
argument_list|(
name|level
argument_list|,
name|stream
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_TEMPLATE
condition|)
goto|goto
name|go_back
goto|;
break|break;
case|case
name|TYPE_CODE_ENUM
case|:
name|c_type_print_cv_qualifier
argument_list|(
name|type
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* HP C supports sized enums */
if|if
condition|(
name|hp_som_som_object_present
condition|)
switch|switch
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
name|fputs_filtered
argument_list|(
literal|"char "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|fputs_filtered
argument_list|(
literal|"short "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"enum "
argument_list|)
expr_stmt|;
comment|/* Print the tag name if it exists.          The aCC compiler emits a spurious           "{unnamed struct}"/"{unnamed union}"/"{unnamed enum}"          tag for unnamed struct/union/enum's, which we don't          want to print. */
if|if
condition|(
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
operator|&&
name|strncmp
argument_list|(
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
literal|"{unnamed"
argument_list|,
literal|8
argument_list|)
condition|)
block|{
name|fputs_filtered
argument_list|(
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|show
operator|>
literal|0
condition|)
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|wrap_here
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
if|if
condition|(
name|show
operator|<
literal|0
condition|)
block|{
comment|/* If we just printed a tag name, no need to print anything else.  */
if|if
condition|(
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|==
name|NULL
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{...}"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|show
operator|>
literal|0
operator|||
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|lastval
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastval
operator|!=
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" = %d"
argument_list|,
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|lastval
operator|=
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|lastval
operator|++
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_VOID
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"void"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_UNDEF
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"struct<unknown>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_ERROR
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<unknown type>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_RANGE
case|:
comment|/* This should not occur */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<range type>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_TEMPLATE
case|:
comment|/* Called on "ptype t" where "t" is a template.          Prints the template header (with args), e.g.:            template<class T1, class T2> class "          and then merges with the struct/union/class code to          print the rest of the definition. */
name|c_type_print_cv_qualifier
argument_list|(
name|type
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"template<"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_NTEMPLATE_ARGS
argument_list|(
name|type
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|template_arg
name|templ_arg
decl_stmt|;
name|templ_arg
operator|=
name|TYPE_TEMPLATE_ARG
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"class %s"
argument_list|,
name|templ_arg
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|TYPE_NTEMPLATE_ARGS
argument_list|(
name|type
argument_list|)
operator|-
literal|1
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"> class "
argument_list|)
expr_stmt|;
comment|/* Yuck, factor this out to a subroutine so we can call          it and return to the point marked with the "goback:" label... - RT */
goto|goto
name|struct_union
goto|;
name|go_back
label|:
if|if
condition|(
name|TYPE_NINSTANTIATIONS
argument_list|(
name|type
argument_list|)
operator|>
literal|0
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\ntemplate instantiations:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_NINSTANTIATIONS
argument_list|(
name|type
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"  "
argument_list|)
expr_stmt|;
name|c_type_print_base
argument_list|(
name|TYPE_INSTANTIATION
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|level
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|TYPE_NINSTANTIATIONS
argument_list|(
name|type
argument_list|)
operator|-
literal|1
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
default|default:
comment|/* Handle types not explicitly handled by the other cases, 	 such as fundamental types.  For these, just print whatever 	 the type name is, as recorded in the type itself.  If there 	 is no type name, then complain. */
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|c_type_print_cv_qualifier
argument_list|(
name|type
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* At least for dump_symtab, it is important that this not be 	     an error ().  */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<invalid type code %d>"
argument_list|,
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

end_unit

