begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Simulate breakpoints by patching locations in the target system, for GDB.    Copyright 1990, 1991, 1995 Free Software Foundation, Inc.    Contributed by Cygnus Support.  Written by John Gilmore.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_comment
comment|/* This file is only useful if BREAKPOINT is set.  If not, we punt.  */
end_comment

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_comment
comment|/* Use the program counter to determine the contents and size    of a breakpoint instruction.  If no target-dependent macro    BREAKPOINT_FROM_PC has been defined to implement this function,    assume that the breakpoint doesn't depend on the PC, and    use the values of the BIG_BREAKPOINT and LITTLE_BREAKPOINT macros.    Return a pointer to a string of bytes that encode a breakpoint    instruction, stores the length of the string to *lenptr,    and optionally adjust the pc to point to the correct memory location    for inserting the breakpoint.  */
end_comment

begin_function
name|unsigned
name|char
modifier|*
name|memory_breakpoint_from_pc
parameter_list|(
name|pcptr
parameter_list|,
name|lenptr
parameter_list|)
name|CORE_ADDR
modifier|*
name|pcptr
decl_stmt|;
name|int
modifier|*
name|lenptr
decl_stmt|;
block|{
comment|/* {BIG_,LITTLE_}BREAKPOINT is the sequence of bytes we insert for a      breakpoint.  On some machines, breakpoints are handled by the      target environment and we don't have to worry about them here.  */
ifdef|#
directive|ifdef
name|BIG_BREAKPOINT
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|==
name|BIG_ENDIAN
condition|)
block|{
specifier|static
name|unsigned
name|char
name|big_break_insn
index|[]
init|=
name|BIG_BREAKPOINT
decl_stmt|;
operator|*
name|lenptr
operator|=
sizeof|sizeof
argument_list|(
name|big_break_insn
argument_list|)
expr_stmt|;
return|return
name|big_break_insn
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LITTLE_BREAKPOINT
if|if
condition|(
name|TARGET_BYTE_ORDER
operator|!=
name|BIG_ENDIAN
condition|)
block|{
specifier|static
name|unsigned
name|char
name|little_break_insn
index|[]
init|=
name|LITTLE_BREAKPOINT
decl_stmt|;
operator|*
name|lenptr
operator|=
sizeof|sizeof
argument_list|(
name|little_break_insn
argument_list|)
expr_stmt|;
return|return
name|little_break_insn
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BREAKPOINT
block|{
specifier|static
name|unsigned
name|char
name|break_insn
index|[]
init|=
name|BREAKPOINT
decl_stmt|;
operator|*
name|lenptr
operator|=
sizeof|sizeof
argument_list|(
name|break_insn
argument_list|)
expr_stmt|;
return|return
name|break_insn
return|;
block|}
endif|#
directive|endif
operator|*
name|lenptr
operator|=
literal|0
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Insert a breakpoint on targets that don't have any better breakpoint    support.  We read the contents of the target location and stash it,    then overwrite it with a breakpoint instruction.  ADDR is the target    location in the target machine.  CONTENTS_CACHE is a pointer to     memory allocated for saving the target contents.  It is guaranteed    by the caller to be long enough to save BREAKPOINT_LEN bytes (this    is accomplished via BREAKPOINT_MAX).  */
end_comment

begin_function
name|int
name|memory_insert_breakpoint
parameter_list|(
name|addr
parameter_list|,
name|contents_cache
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|contents_cache
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
name|unsigned
name|char
modifier|*
name|bp
decl_stmt|;
name|int
name|bplen
decl_stmt|;
comment|/* Determine appropriate breakpoint contents and size for this address.  */
name|bp
operator|=
name|BREAKPOINT_FROM_PC
argument_list|(
operator|&
name|addr
argument_list|,
operator|&
name|bplen
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Software breakpoints not implemented for this target."
argument_list|)
expr_stmt|;
comment|/* Save the memory contents.  */
name|val
operator|=
name|target_read_memory
argument_list|(
name|addr
argument_list|,
name|contents_cache
argument_list|,
name|bplen
argument_list|)
expr_stmt|;
comment|/* Write the breakpoint.  */
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|val
operator|=
name|target_write_memory
argument_list|(
name|addr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|bp
argument_list|,
name|bplen
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
name|int
name|memory_remove_breakpoint
parameter_list|(
name|addr
parameter_list|,
name|contents_cache
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|contents_cache
decl_stmt|;
block|{
name|unsigned
name|char
modifier|*
name|bp
decl_stmt|;
name|int
name|bplen
decl_stmt|;
comment|/* Determine appropriate breakpoint contents and size for this address.  */
name|bp
operator|=
name|BREAKPOINT_FROM_PC
argument_list|(
operator|&
name|addr
argument_list|,
operator|&
name|bplen
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Software breakpoints not implemented for this target."
argument_list|)
expr_stmt|;
return|return
name|target_write_memory
argument_list|(
name|addr
argument_list|,
name|contents_cache
argument_list|,
name|bplen
argument_list|)
return|;
block|}
end_function

end_unit

