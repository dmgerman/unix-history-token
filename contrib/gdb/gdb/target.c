begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Select target systems and architectures at runtime for GDB.    Copyright 1990, 1992-1995, 1998, 1999 Free Software Foundation, Inc.    Contributed by Cygnus Support.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|target_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|cleanup_target
name|PARAMS
argument_list|(
operator|(
expr|struct
name|target_ops
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|maybe_kill_then_create_inferior
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|default_clone_and_follow_inferior
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|maybe_kill_then_attach
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|kill_or_be_killed
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|default_terminal_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nosymbol
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|CORE_ADDR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tcomplain
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nomemory
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
expr|struct
name|target_ops
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|return_zero
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|return_one
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|target_ignore
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|target_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|target_ops
modifier|*
name|find_default_run_target
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|update_current_target
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Transfer LEN bytes between target address MEMADDR and GDB address MYADDR.    Returns 0 for success, errno code for failure (which includes partial    transfers--if you want a more useful response to partial transfers, try    target_read_memory_partial).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|target_xfer_memory
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
name|memaddr
operator|,
name|char
operator|*
name|myaddr
operator|,
name|int
name|len
operator|,
name|int
name|write
operator|,
name|asection
operator|*
name|bfd_section
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_dummy_target
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|debug_to_open
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|debug_to_close
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|debug_to_attach
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|debug_to_detach
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|debug_to_resume
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
expr|enum
name|target_signal
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|debug_to_wait
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|target_waitstatus
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|debug_to_fetch_registers
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|debug_to_store_registers
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|debug_to_prepare_to_store
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|debug_to_xfer_memory
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
expr|struct
name|target_ops
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|debug_to_files_info
name|PARAMS
argument_list|(
operator|(
expr|struct
name|target_ops
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|debug_to_insert_breakpoint
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|debug_to_remove_breakpoint
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|debug_to_terminal_init
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|debug_to_terminal_inferior
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|debug_to_terminal_ours_for_output
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|debug_to_terminal_ours
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|debug_to_terminal_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|debug_to_kill
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|debug_to_load
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|debug_to_lookup_symbol
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|CORE_ADDR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|debug_to_create_inferior
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|debug_to_mourn_inferior
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|debug_to_can_run
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|debug_to_notice_signals
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|debug_to_thread_alive
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|debug_to_stop
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|debug_to_query
name|PARAMS
argument_list|(
operator|(
name|int
comment|/*char*/
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to array of target architecture structures; the size of the    array; the current index into the array; the allocated size of the     array.  */
end_comment

begin_decl_stmt
name|struct
name|target_ops
modifier|*
modifier|*
name|target_structs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|target_struct_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|target_struct_index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|target_struct_allocsize
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DEFAULT_ALLOCSIZE
value|10
end_define

begin_comment
comment|/* The initial current target, so that there is always a semi-valid    current target.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|target_ops
name|dummy_target
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Top of target stack.  */
end_comment

begin_decl_stmt
name|struct
name|target_stack_item
modifier|*
name|target_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The target structure we are currently using to talk to a process    or file or whatever "inferior" we have.  */
end_comment

begin_decl_stmt
name|struct
name|target_ops
name|current_target
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Command list for target.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cmd_list_element
modifier|*
name|targetlist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we are debugging an attached outside process    rather than an inferior.  */
end_comment

begin_decl_stmt
name|int
name|attach_flag
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MAINTENANCE_CMDS
end_ifdef

begin_comment
comment|/* Non-zero if we want to see trace of target level stuff.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|targetdebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|setup_target_debug
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The user just typed 'target' without the name of a target.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|target_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|fputs_filtered
argument_list|(
literal|"Argument required (target name).  Try `help target'\n"
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a possible target architecture to the list.  */
end_comment

begin_function
name|void
name|add_target
parameter_list|(
name|t
parameter_list|)
name|struct
name|target_ops
modifier|*
name|t
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|target_structs
condition|)
block|{
name|target_struct_allocsize
operator|=
name|DEFAULT_ALLOCSIZE
expr_stmt|;
name|target_structs
operator|=
operator|(
expr|struct
name|target_ops
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|target_struct_allocsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|target_structs
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|target_struct_size
operator|>=
name|target_struct_allocsize
condition|)
block|{
name|target_struct_allocsize
operator|*=
literal|2
expr_stmt|;
name|target_structs
operator|=
operator|(
expr|struct
name|target_ops
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|target_structs
argument_list|,
name|target_struct_allocsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|target_structs
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|target_structs
index|[
name|target_struct_size
operator|++
index|]
operator|=
name|t
expr_stmt|;
comment|/*  cleanup_target (t);*/
if|if
condition|(
name|targetlist
operator|==
name|NULL
condition|)
name|add_prefix_cmd
argument_list|(
literal|"target"
argument_list|,
name|class_run
argument_list|,
name|target_command
argument_list|,
literal|"Connect to a target machine or process.\n\ The first argument is the type or protocol of the target machine.\n\ Remaining arguments are interpreted by the target protocol.  For more\n\ information on the arguments for a particular protocol, type\n\ `help target ' followed by the protocol name."
argument_list|,
operator|&
name|targetlist
argument_list|,
literal|"target "
argument_list|,
literal|0
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
name|t
operator|->
name|to_shortname
argument_list|,
name|no_class
argument_list|,
name|t
operator|->
name|to_open
argument_list|,
name|t
operator|->
name|to_doc
argument_list|,
operator|&
name|targetlist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stub functions */
end_comment

begin_function
name|void
name|target_ignore
parameter_list|()
block|{ }
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|nomemory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|write
parameter_list|,
name|t
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|write
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|t
decl_stmt|;
block|{
name|errno
operator|=
name|EIO
expr_stmt|;
comment|/* Can't read/write this location */
return|return
literal|0
return|;
comment|/* No bytes handled */
block|}
end_function

begin_function
specifier|static
name|void
name|tcomplain
parameter_list|()
block|{
name|error
argument_list|(
literal|"You can't do that when your target is `%s'"
argument_list|,
name|current_target
operator|.
name|to_shortname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|noprocess
parameter_list|()
block|{
name|error
argument_list|(
literal|"You can't do that without a process to debug."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|nosymbol
parameter_list|(
name|name
parameter_list|,
name|addrp
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|CORE_ADDR
modifier|*
name|addrp
decl_stmt|;
block|{
return|return
literal|1
return|;
comment|/* Symbol does not exist in target env */
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|nosupport_runtime
parameter_list|()
block|{
if|if
condition|(
operator|!
name|inferior_pid
condition|)
name|noprocess
argument_list|()
expr_stmt|;
else|else
name|error
argument_list|(
literal|"No run-time support for this"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|default_terminal_info
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|printf_unfiltered
argument_list|(
literal|"No saved terminal information.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is the default target_create_inferior and target_attach function.    If the current target is executing, it asks whether to kill it off.    If this function returns without calling error(), it has killed off    the target, and the operation should be attempted.  */
end_comment

begin_function
specifier|static
name|void
name|kill_or_be_killed
parameter_list|(
name|from_tty
parameter_list|)
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|target_has_execution
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"You are already running a program:\n"
argument_list|)
expr_stmt|;
name|target_files_info
argument_list|()
expr_stmt|;
if|if
condition|(
name|query
argument_list|(
literal|"Kill it? "
argument_list|)
condition|)
block|{
name|target_kill
argument_list|()
expr_stmt|;
if|if
condition|(
name|target_has_execution
condition|)
name|error
argument_list|(
literal|"Killing the program did not help."
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|error
argument_list|(
literal|"Program not killed."
argument_list|)
expr_stmt|;
block|}
block|}
name|tcomplain
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|maybe_kill_then_attach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|kill_or_be_killed
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
name|target_attach
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|maybe_kill_then_create_inferior
parameter_list|(
name|exec
parameter_list|,
name|args
parameter_list|,
name|env
parameter_list|)
name|char
modifier|*
name|exec
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
name|char
modifier|*
modifier|*
name|env
decl_stmt|;
block|{
name|kill_or_be_killed
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|target_create_inferior
argument_list|(
name|exec
argument_list|,
name|args
argument_list|,
name|env
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|default_clone_and_follow_inferior
parameter_list|(
name|child_pid
parameter_list|,
name|followed_child
parameter_list|)
name|int
name|child_pid
decl_stmt|;
name|int
modifier|*
name|followed_child
decl_stmt|;
block|{
name|target_clone_and_follow_inferior
argument_list|(
name|child_pid
argument_list|,
name|followed_child
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clean up a target struct so it no longer has any zero pointers in it.    We default entries, at least to stubs that print error messages.  */
end_comment

begin_function
specifier|static
name|void
name|cleanup_target
parameter_list|(
name|t
parameter_list|)
name|struct
name|target_ops
modifier|*
name|t
decl_stmt|;
block|{
define|#
directive|define
name|de_fault
parameter_list|(
name|field
parameter_list|,
name|value
parameter_list|)
define|\
value|if (!t->field)	t->field = value
comment|/*        FIELD			DEFAULT VALUE        */
name|de_fault
argument_list|(
name|to_open
argument_list|,
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
operator|)
name|tcomplain
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_close
argument_list|,
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
operator|)
name|target_ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_attach
argument_list|,
name|maybe_kill_then_attach
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_post_attach
argument_list|,
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
operator|)
name|target_ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_require_attach
argument_list|,
name|maybe_kill_then_attach
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_detach
argument_list|,
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
operator|)
name|target_ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_require_detach
argument_list|,
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
operator|)
name|target_ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_resume
argument_list|,
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
expr|enum
name|target_signal
operator|)
argument_list|)
operator|)
name|noprocess
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_wait
argument_list|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|target_waitstatus
operator|*
operator|)
argument_list|)
operator|)
name|noprocess
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_post_wait
argument_list|,
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
operator|)
name|target_ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_fetch_registers
argument_list|,
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
operator|)
name|target_ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_store_registers
argument_list|,
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
operator|)
name|noprocess
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_prepare_to_store
argument_list|,
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
operator|)
name|noprocess
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_xfer_memory
argument_list|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
expr|struct
name|target_ops
operator|*
operator|)
argument_list|)
operator|)
name|nomemory
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_files_info
argument_list|,
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
expr|struct
name|target_ops
operator|*
operator|)
argument_list|)
operator|)
name|target_ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_insert_breakpoint
argument_list|,
name|memory_insert_breakpoint
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_remove_breakpoint
argument_list|,
name|memory_remove_breakpoint
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_terminal_init
argument_list|,
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
operator|)
name|target_ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_terminal_inferior
argument_list|,
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
operator|)
name|target_ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_terminal_ours_for_output
argument_list|,
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
operator|)
name|target_ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_terminal_ours
argument_list|,
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
operator|)
name|target_ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_terminal_info
argument_list|,
name|default_terminal_info
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_kill
argument_list|,
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
operator|)
name|noprocess
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_load
argument_list|,
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
operator|)
name|tcomplain
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_lookup_symbol
argument_list|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|CORE_ADDR
operator|*
operator|)
argument_list|)
operator|)
name|nosymbol
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_create_inferior
argument_list|,
name|maybe_kill_then_create_inferior
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_post_startup_inferior
argument_list|,
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
operator|)
name|target_ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_acknowledge_created_inferior
argument_list|,
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
operator|)
name|target_ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_clone_and_follow_inferior
argument_list|,
name|default_clone_and_follow_inferior
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_post_follow_inferior_by_clone
argument_list|,
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
operator|)
name|target_ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_insert_fork_catchpoint
argument_list|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
operator|)
name|tcomplain
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_remove_fork_catchpoint
argument_list|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
operator|)
name|tcomplain
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_insert_vfork_catchpoint
argument_list|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
operator|)
name|tcomplain
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_remove_vfork_catchpoint
argument_list|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
operator|)
name|tcomplain
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_has_forked
argument_list|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
operator|)
name|return_zero
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_has_vforked
argument_list|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
operator|)
name|return_zero
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_can_follow_vfork_prior_to_exec
argument_list|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
operator|)
name|return_zero
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_post_follow_vfork
argument_list|,
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
operator|)
name|target_ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_insert_exec_catchpoint
argument_list|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
operator|)
name|tcomplain
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_remove_exec_catchpoint
argument_list|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
operator|)
name|tcomplain
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_has_execd
argument_list|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
operator|)
name|return_zero
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_reported_exec_events_per_exec_call
argument_list|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
operator|)
name|return_one
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_has_syscall_event
argument_list|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
expr|enum
name|target_waitkind
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
operator|)
name|return_zero
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_has_exited
argument_list|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|*
operator|)
argument_list|)
operator|)
name|return_zero
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_mourn_inferior
argument_list|,
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
operator|)
name|noprocess
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_can_run
argument_list|,
name|return_zero
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_notice_signals
argument_list|,
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
operator|)
name|target_ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_thread_alive
argument_list|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
operator|)
name|target_ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_stop
argument_list|,
operator|(
name|void
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
operator|)
name|target_ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_query
argument_list|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|int
comment|/*char*/
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
operator|)
name|target_ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_enable_exception_callback
argument_list|,
operator|(
expr|struct
name|symtab_and_line
operator|*
operator|(
operator|*
operator|)
name|PARAMS
argument_list|(
operator|(
expr|enum
name|exception_event_kind
operator|,
name|int
operator|)
argument_list|)
operator|)
name|nosupport_runtime
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_get_current_exception_event
argument_list|,
operator|(
expr|struct
name|exception_event_record
operator|*
operator|(
operator|*
operator|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
operator|)
name|nosupport_runtime
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_pid_to_exec_file
argument_list|,
operator|(
name|char
operator|*
operator|(
operator|*
operator|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
operator|)
name|return_zero
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_core_file_to_sym_file
argument_list|,
operator|(
name|char
operator|*
operator|(
operator|*
operator|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
operator|)
name|return_zero
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|de_fault
block|}
end_function

begin_comment
comment|/* Go through the target stack from top to bottom, copying over zero entries in    current_target.  In effect, we are doing class inheritance through the    pushed target vectors.  */
end_comment

begin_function
specifier|static
name|void
name|update_current_target
parameter_list|()
block|{
name|struct
name|target_stack_item
modifier|*
name|item
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|t
decl_stmt|;
comment|/* First, reset current_target */
name|memset
argument_list|(
operator|&
name|current_target
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|current_target
argument_list|)
expr_stmt|;
for|for
control|(
name|item
operator|=
name|target_stack
init|;
name|item
condition|;
name|item
operator|=
name|item
operator|->
name|next
control|)
block|{
name|t
operator|=
name|item
operator|->
name|target_ops
expr_stmt|;
define|#
directive|define
name|INHERIT
parameter_list|(
name|FIELD
parameter_list|,
name|TARGET
parameter_list|)
define|\
value|if (!current_target.FIELD) \ 	current_target.FIELD = TARGET->FIELD
name|INHERIT
argument_list|(
name|to_shortname
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_longname
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_doc
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_open
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_close
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_attach
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_post_attach
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_require_attach
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_detach
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_require_detach
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_resume
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_wait
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_post_wait
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_fetch_registers
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_store_registers
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_prepare_to_store
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_xfer_memory
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_files_info
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_insert_breakpoint
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_remove_breakpoint
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_terminal_init
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_terminal_inferior
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_terminal_ours_for_output
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_terminal_ours
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_terminal_info
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_kill
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_load
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_lookup_symbol
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_create_inferior
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_post_startup_inferior
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_acknowledge_created_inferior
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_clone_and_follow_inferior
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_post_follow_inferior_by_clone
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_insert_fork_catchpoint
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_remove_fork_catchpoint
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_insert_vfork_catchpoint
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_remove_vfork_catchpoint
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_has_forked
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_has_vforked
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_can_follow_vfork_prior_to_exec
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_post_follow_vfork
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_insert_exec_catchpoint
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_remove_exec_catchpoint
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_has_execd
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_reported_exec_events_per_exec_call
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_has_syscall_event
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_has_exited
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_mourn_inferior
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_can_run
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_notice_signals
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_thread_alive
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_stop
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_query
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_enable_exception_callback
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_get_current_exception_event
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_pid_to_exec_file
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_core_file_to_sym_file
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_stratum
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|DONT_USE
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_has_all_memory
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_has_memory
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_has_stack
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_has_registers
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_has_execution
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_has_thread_control
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_sections
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_sections_end
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_magic
argument_list|,
name|t
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|INHERIT
block|}
block|}
end_function

begin_comment
comment|/* Push a new target type into the stack of the existing target accessors,    possibly superseding some of the existing accessors.     Result is zero if the pushed target ended up on top of the stack,    nonzero if at least one target is on top of it.     Rather than allow an empty stack, we always have the dummy target at    the bottom stratum, so we can call the function vectors without    checking them.  */
end_comment

begin_function
name|int
name|push_target
parameter_list|(
name|t
parameter_list|)
name|struct
name|target_ops
modifier|*
name|t
decl_stmt|;
block|{
name|struct
name|target_stack_item
modifier|*
name|cur
decl_stmt|,
modifier|*
name|prev
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
comment|/* Check magic number.  If wrong, it probably means someone changed      the struct definition, but not all the places that initialize one.  */
if|if
condition|(
name|t
operator|->
name|to_magic
operator|!=
name|OPS_MAGIC
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Magic number of %s target struct wrong\n"
argument_list|,
name|t
operator|->
name|to_shortname
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Find the proper stratum to install this target in. */
for|for
control|(
name|prev
operator|=
name|NULL
operator|,
name|cur
operator|=
name|target_stack
init|;
name|cur
condition|;
name|prev
operator|=
name|cur
operator|,
name|cur
operator|=
name|cur
operator|->
name|next
control|)
block|{
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|t
operator|->
name|to_stratum
argument_list|)
operator|>=
call|(
name|int
call|)
argument_list|(
name|cur
operator|->
name|target_ops
operator|->
name|to_stratum
argument_list|)
condition|)
break|break;
block|}
comment|/* If there's already targets at this stratum, remove them. */
if|if
condition|(
name|cur
condition|)
while|while
condition|(
name|t
operator|->
name|to_stratum
operator|==
name|cur
operator|->
name|target_ops
operator|->
name|to_stratum
condition|)
block|{
comment|/* There's already something on this stratum.  Close it off.  */
if|if
condition|(
name|cur
operator|->
name|target_ops
operator|->
name|to_close
condition|)
call|(
name|cur
operator|->
name|target_ops
operator|->
name|to_close
call|)
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|cur
operator|->
name|next
expr_stmt|;
comment|/* Unchain old target_ops */
else|else
name|target_stack
operator|=
name|cur
operator|->
name|next
expr_stmt|;
comment|/* Unchain first on list */
name|tmp
operator|=
name|cur
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|cur
argument_list|)
expr_stmt|;
name|cur
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* We have removed all targets in our stratum, now add the new one.  */
name|tmp
operator|=
operator|(
expr|struct
name|target_stack_item
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|target_stack_item
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|next
operator|=
name|cur
expr_stmt|;
name|tmp
operator|->
name|target_ops
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|tmp
expr_stmt|;
else|else
name|target_stack
operator|=
name|tmp
expr_stmt|;
name|update_current_target
argument_list|()
expr_stmt|;
name|cleanup_target
argument_list|(
operator|&
name|current_target
argument_list|)
expr_stmt|;
comment|/* Fill in the gaps */
ifdef|#
directive|ifdef
name|MAINTENANCE_CMDS
if|if
condition|(
name|targetdebug
condition|)
name|setup_target_debug
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
name|prev
operator|!=
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Remove a target_ops vector from the stack, wherever it may be.     Return how many times it was removed (0 or 1).  */
end_comment

begin_function
name|int
name|unpush_target
parameter_list|(
name|t
parameter_list|)
name|struct
name|target_ops
modifier|*
name|t
decl_stmt|;
block|{
name|struct
name|target_stack_item
modifier|*
name|cur
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|to_close
condition|)
name|t
operator|->
name|to_close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Let it clean up */
comment|/* Look for the specified target.  Note that we assume that a target      can only occur once in the target stack. */
for|for
control|(
name|cur
operator|=
name|target_stack
operator|,
name|prev
operator|=
name|NULL
init|;
name|cur
condition|;
name|prev
operator|=
name|cur
operator|,
name|cur
operator|=
name|cur
operator|->
name|next
control|)
if|if
condition|(
name|cur
operator|->
name|target_ops
operator|==
name|t
condition|)
break|break;
if|if
condition|(
operator|!
name|cur
condition|)
return|return
literal|0
return|;
comment|/* Didn't find target_ops, quit now */
comment|/* Unchain the target */
if|if
condition|(
operator|!
name|prev
condition|)
name|target_stack
operator|=
name|cur
operator|->
name|next
expr_stmt|;
else|else
name|prev
operator|->
name|next
operator|=
name|cur
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|cur
argument_list|)
expr_stmt|;
comment|/* Release the target_stack_item */
name|update_current_target
argument_list|()
expr_stmt|;
name|cleanup_target
argument_list|(
operator|&
name|current_target
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|pop_target
parameter_list|()
block|{
call|(
name|current_target
operator|.
name|to_close
call|)
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Let it clean up */
if|if
condition|(
name|unpush_target
argument_list|(
name|target_stack
operator|->
name|target_ops
argument_list|)
operator|==
literal|1
condition|)
return|return;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"pop_target couldn't find target %s\n"
argument_list|,
name|current_target
operator|.
name|to_shortname
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|MIN
end_undef

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|(((A)<= (B)) ? (A) : (B))
end_define

begin_comment
comment|/* target_read_string -- read a null terminated string, up to LEN bytes,    from MEMADDR in target.  Set *ERRNOP to the errno code, or 0 if successful.    Set *STRING to a pointer to malloc'd memory containing the data; the caller    is responsible for freeing it.  Return the number of bytes successfully    read.  */
end_comment

begin_function
name|int
name|target_read_string
parameter_list|(
name|memaddr
parameter_list|,
name|string
parameter_list|,
name|len
parameter_list|,
name|errnop
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
modifier|*
name|string
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
modifier|*
name|errnop
decl_stmt|;
block|{
name|int
name|tlen
decl_stmt|,
name|origlen
decl_stmt|,
name|offset
decl_stmt|,
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|int
name|errcode
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|int
name|buffer_allocated
decl_stmt|;
name|char
modifier|*
name|bufptr
decl_stmt|;
name|unsigned
name|int
name|nbytes_read
init|=
literal|0
decl_stmt|;
comment|/* Small for testing.  */
name|buffer_allocated
operator|=
literal|4
expr_stmt|;
name|buffer
operator|=
name|xmalloc
argument_list|(
name|buffer_allocated
argument_list|)
expr_stmt|;
name|bufptr
operator|=
name|buffer
expr_stmt|;
name|origlen
operator|=
name|len
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|tlen
operator|=
name|MIN
argument_list|(
name|len
argument_list|,
literal|4
operator|-
operator|(
name|memaddr
operator|&
literal|3
operator|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|memaddr
operator|&
literal|3
expr_stmt|;
name|errcode
operator|=
name|target_xfer_memory
argument_list|(
name|memaddr
operator|&
operator|~
literal|3
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
operator|!=
literal|0
condition|)
block|{
comment|/* The transfer request might have crossed the boundary to an 	     unallocated region of memory. Retry the transfer, requesting 	     a single byte.  */
name|tlen
operator|=
literal|1
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|errcode
operator|=
name|target_xfer_memory
argument_list|(
name|memaddr
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|bufptr
operator|-
name|buffer
operator|+
name|tlen
operator|>
name|buffer_allocated
condition|)
block|{
name|unsigned
name|int
name|bytes
decl_stmt|;
name|bytes
operator|=
name|bufptr
operator|-
name|buffer
expr_stmt|;
name|buffer_allocated
operator|*=
literal|2
expr_stmt|;
name|buffer
operator|=
name|xrealloc
argument_list|(
name|buffer
argument_list|,
name|buffer_allocated
argument_list|)
expr_stmt|;
name|bufptr
operator|=
name|buffer
operator|+
name|bytes
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tlen
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|bufptr
operator|++
operator|=
name|buf
index|[
name|i
operator|+
name|offset
index|]
expr_stmt|;
if|if
condition|(
name|buf
index|[
name|i
operator|+
name|offset
index|]
operator|==
literal|'\000'
condition|)
block|{
name|nbytes_read
operator|+=
name|i
operator|+
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|memaddr
operator|+=
name|tlen
expr_stmt|;
name|len
operator|-=
name|tlen
expr_stmt|;
name|nbytes_read
operator|+=
name|tlen
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
name|errnop
operator|!=
name|NULL
condition|)
operator|*
name|errnop
operator|=
name|errcode
expr_stmt|;
if|if
condition|(
name|string
operator|!=
name|NULL
condition|)
operator|*
name|string
operator|=
name|buffer
expr_stmt|;
return|return
name|nbytes_read
return|;
block|}
end_function

begin_comment
comment|/* Read LEN bytes of target memory at address MEMADDR, placing the results in    GDB's memory at MYADDR.  Returns either 0 for success or an errno value    if any error occurs.     If an error occurs, no guarantee is made about the contents of the data at    MYADDR.  In particular, the caller should not depend upon partial reads    filling the buffer with good data.  There is no way for the caller to know    how much good data might have been transfered anyway.  Callers that can    deal with partial reads should call target_read_memory_partial. */
end_comment

begin_function
name|int
name|target_read_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
return|return
name|target_xfer_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|target_read_memory_section
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|bfd_section
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|asection
modifier|*
name|bfd_section
decl_stmt|;
block|{
return|return
name|target_xfer_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|bfd_section
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read LEN bytes of target memory at address MEMADDR, placing the results    in GDB's memory at MYADDR.  Returns a count of the bytes actually read,    and optionally an errno value in the location pointed to by ERRNOPTR    if ERRNOPTR is non-null. */
end_comment

begin_function
name|int
name|target_read_memory_partial
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|errnoptr
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
modifier|*
name|errnoptr
decl_stmt|;
block|{
name|int
name|nread
decl_stmt|;
comment|/* Number of bytes actually read. */
name|int
name|errcode
decl_stmt|;
comment|/* Error from last read. */
comment|/* First try a complete read. */
name|errcode
operator|=
name|target_xfer_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
operator|==
literal|0
condition|)
block|{
comment|/* Got it all. */
name|nread
operator|=
name|len
expr_stmt|;
block|}
else|else
block|{
comment|/* Loop, reading one byte at a time until we get as much as we can. */
for|for
control|(
name|errcode
operator|=
literal|0
operator|,
name|nread
operator|=
literal|0
init|;
name|len
operator|>
literal|0
operator|&&
name|errcode
operator|==
literal|0
condition|;
name|nread
operator|++
operator|,
name|len
operator|--
control|)
block|{
name|errcode
operator|=
name|target_xfer_memory
argument_list|(
name|memaddr
operator|++
argument_list|,
name|myaddr
operator|++
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* If an error, the last read was unsuccessful, so adjust count. */
if|if
condition|(
name|errcode
operator|!=
literal|0
condition|)
block|{
name|nread
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|errnoptr
operator|!=
name|NULL
condition|)
block|{
operator|*
name|errnoptr
operator|=
name|errcode
expr_stmt|;
block|}
return|return
operator|(
name|nread
operator|)
return|;
block|}
end_function

begin_function
name|int
name|target_write_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
return|return
name|target_xfer_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This variable is used to pass section information down to targets.  This    *should* be done by adding an argument to the target_xfer_memory function    of all the targets, but I didn't feel like changing 50+ files.  */
end_comment

begin_decl_stmt
name|asection
modifier|*
name|target_memory_bfd_section
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Move memory to or from the targets.  Iterate until all of it has    been moved, if necessary.  The top target gets priority; anything    it doesn't want, is offered to the next one down, etc.  Note the    business with curlen:  if an early target says "no, but I have a    boundary overlapping this xfer" then we shorten what we offer to    the subsequent targets so the early guy will get a chance at the    tail before the subsequent ones do.      Result is 0 or errno value.  */
end_comment

begin_function
specifier|static
name|int
name|target_xfer_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|write
parameter_list|,
name|bfd_section
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|write
decl_stmt|;
name|asection
modifier|*
name|bfd_section
decl_stmt|;
block|{
name|int
name|curlen
decl_stmt|;
name|int
name|res
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|t
decl_stmt|;
name|struct
name|target_stack_item
modifier|*
name|item
decl_stmt|;
comment|/* Zero length requests are ok and require no work.  */
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|target_memory_bfd_section
operator|=
name|bfd_section
expr_stmt|;
comment|/* to_xfer_memory is not guaranteed to set errno, even when it returns      0.  */
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* The quick case is that the top target does it all.  */
name|res
operator|=
name|current_target
operator|.
name|to_xfer_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|,
name|write
argument_list|,
operator|&
name|current_target
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|len
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|res
operator|>
literal|0
condition|)
goto|goto
name|bump
goto|;
comment|/* If res<= 0 then we call it again in the loop.  Ah well.  */
for|for
control|(
init|;
name|len
operator|>
literal|0
condition|;
control|)
block|{
name|curlen
operator|=
name|len
expr_stmt|;
comment|/* Want to do it all */
for|for
control|(
name|item
operator|=
name|target_stack
init|;
name|item
condition|;
name|item
operator|=
name|item
operator|->
name|next
control|)
block|{
name|t
operator|=
name|item
operator|->
name|target_ops
expr_stmt|;
if|if
condition|(
operator|!
name|t
operator|->
name|to_has_memory
condition|)
continue|continue;
name|res
operator|=
name|t
operator|->
name|to_xfer_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|curlen
argument_list|,
name|write
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|>
literal|0
condition|)
break|break;
comment|/* Handled all or part of xfer */
if|if
condition|(
name|t
operator|->
name|to_has_all_memory
condition|)
break|break;
block|}
if|if
condition|(
name|res
operator|<=
literal|0
condition|)
block|{
comment|/* If this address is for nonexistent memory, 	     read zeros if reading, or do nothing if writing.  Return error. */
if|if
condition|(
operator|!
name|write
condition|)
name|memset
argument_list|(
name|myaddr
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
literal|0
condition|)
return|return
name|EIO
return|;
else|else
return|return
name|errno
return|;
block|}
name|bump
label|:
name|memaddr
operator|+=
name|res
expr_stmt|;
name|myaddr
operator|+=
name|res
expr_stmt|;
name|len
operator|-=
name|res
expr_stmt|;
block|}
return|return
literal|0
return|;
comment|/* We managed to cover it all somehow. */
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|target_info
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|target_ops
modifier|*
name|t
decl_stmt|;
name|struct
name|target_stack_item
modifier|*
name|item
decl_stmt|;
name|int
name|has_all_mem
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|symfile_objfile
operator|!=
name|NULL
condition|)
name|printf_unfiltered
argument_list|(
literal|"Symbols from \"%s\".\n"
argument_list|,
name|symfile_objfile
operator|->
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FILES_INFO_HOOK
if|if
condition|(
name|FILES_INFO_HOOK
argument_list|()
condition|)
return|return;
endif|#
directive|endif
for|for
control|(
name|item
operator|=
name|target_stack
init|;
name|item
condition|;
name|item
operator|=
name|item
operator|->
name|next
control|)
block|{
name|t
operator|=
name|item
operator|->
name|target_ops
expr_stmt|;
if|if
condition|(
operator|!
name|t
operator|->
name|to_has_memory
condition|)
continue|continue;
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|t
operator|->
name|to_stratum
argument_list|)
operator|<=
operator|(
name|int
operator|)
name|dummy_stratum
condition|)
continue|continue;
if|if
condition|(
name|has_all_mem
condition|)
name|printf_unfiltered
argument_list|(
literal|"\tWhile running this, GDB does not access memory from...\n"
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%s:\n"
argument_list|,
name|t
operator|->
name|to_longname
argument_list|)
expr_stmt|;
call|(
name|t
operator|->
name|to_files_info
call|)
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|has_all_mem
operator|=
name|t
operator|->
name|to_has_all_memory
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is to be called by the open routine before it does    anything.  */
end_comment

begin_function
name|void
name|target_preopen
parameter_list|(
name|from_tty
parameter_list|)
name|int
name|from_tty
decl_stmt|;
block|{
name|dont_repeat
argument_list|()
expr_stmt|;
if|if
condition|(
name|target_has_execution
condition|)
block|{
if|if
condition|(
name|query
argument_list|(
literal|"A program is being debugged already.  Kill it? "
argument_list|)
condition|)
name|target_kill
argument_list|()
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Program not killed."
argument_list|)
expr_stmt|;
block|}
comment|/* Calling target_kill may remove the target from the stack.  But if      it doesn't (which seems like a win for UDI), remove it now.  */
if|if
condition|(
name|target_has_execution
condition|)
name|pop_target
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Detach a target after doing deferred register stores.  */
end_comment

begin_function
name|void
name|target_detach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
comment|/* Handle any optimized stores to the inferior.  */
ifdef|#
directive|ifdef
name|DO_DEFERRED_STORES
name|DO_DEFERRED_STORES
expr_stmt|;
endif|#
directive|endif
call|(
name|current_target
operator|.
name|to_detach
call|)
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|target_link
parameter_list|(
name|modname
parameter_list|,
name|t_reloc
parameter_list|)
name|char
modifier|*
name|modname
decl_stmt|;
name|CORE_ADDR
modifier|*
name|t_reloc
decl_stmt|;
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|current_target
operator|.
name|to_shortname
argument_list|,
literal|"rombug"
argument_list|)
condition|)
block|{
call|(
name|current_target
operator|.
name|to_lookup_symbol
call|)
argument_list|(
name|modname
argument_list|,
name|t_reloc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|t_reloc
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Unable to link to %s and get relocation in rombug"
argument_list|,
name|modname
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|t_reloc
operator|=
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Look through the list of possible targets for a target that can    execute a run or attach command without any other data.  This is    used to locate the default process stratum.     Result is always valid (error() is called for errors).  */
end_comment

begin_function
specifier|static
name|struct
name|target_ops
modifier|*
name|find_default_run_target
parameter_list|(
name|do_mesg
parameter_list|)
name|char
modifier|*
name|do_mesg
decl_stmt|;
block|{
name|struct
name|target_ops
modifier|*
modifier|*
name|t
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|runable
init|=
name|NULL
decl_stmt|;
name|int
name|count
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
name|target_structs
init|;
name|t
operator|<
name|target_structs
operator|+
name|target_struct_size
condition|;
operator|++
name|t
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|t
operator|)
operator|->
name|to_can_run
operator|&&
name|target_can_run
argument_list|(
operator|*
name|t
argument_list|)
condition|)
block|{
name|runable
operator|=
operator|*
name|t
expr_stmt|;
operator|++
name|count
expr_stmt|;
block|}
block|}
if|if
condition|(
name|count
operator|!=
literal|1
condition|)
name|error
argument_list|(
literal|"Don't know how to %s.  Try \"help target\"."
argument_list|,
name|do_mesg
argument_list|)
expr_stmt|;
return|return
name|runable
return|;
block|}
end_function

begin_function
name|void
name|find_default_attach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|target_ops
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|find_default_run_target
argument_list|(
literal|"attach"
argument_list|)
expr_stmt|;
call|(
name|t
operator|->
name|to_attach
call|)
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|find_default_require_attach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|target_ops
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|find_default_run_target
argument_list|(
literal|"require_attach"
argument_list|)
expr_stmt|;
call|(
name|t
operator|->
name|to_require_attach
call|)
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|find_default_require_detach
parameter_list|(
name|pid
parameter_list|,
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|int
name|pid
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|target_ops
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|find_default_run_target
argument_list|(
literal|"require_detach"
argument_list|)
expr_stmt|;
call|(
name|t
operator|->
name|to_require_detach
call|)
argument_list|(
name|pid
argument_list|,
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|find_default_create_inferior
parameter_list|(
name|exec_file
parameter_list|,
name|allargs
parameter_list|,
name|env
parameter_list|)
name|char
modifier|*
name|exec_file
decl_stmt|;
name|char
modifier|*
name|allargs
decl_stmt|;
name|char
modifier|*
modifier|*
name|env
decl_stmt|;
block|{
name|struct
name|target_ops
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|find_default_run_target
argument_list|(
literal|"run"
argument_list|)
expr_stmt|;
call|(
name|t
operator|->
name|to_create_inferior
call|)
argument_list|(
name|exec_file
argument_list|,
name|allargs
argument_list|,
name|env
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|find_default_clone_and_follow_inferior
parameter_list|(
name|child_pid
parameter_list|,
name|followed_child
parameter_list|)
name|int
name|child_pid
decl_stmt|;
name|int
modifier|*
name|followed_child
decl_stmt|;
block|{
name|struct
name|target_ops
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|find_default_run_target
argument_list|(
literal|"run"
argument_list|)
expr_stmt|;
call|(
name|t
operator|->
name|to_clone_and_follow_inferior
call|)
argument_list|(
name|child_pid
argument_list|,
name|followed_child
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|return_zero
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|return_one
parameter_list|()
block|{
return|return
literal|1
return|;
block|}
end_function

begin_function
name|struct
name|target_ops
modifier|*
name|find_core_target
parameter_list|()
block|{
name|struct
name|target_ops
modifier|*
modifier|*
name|t
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|runable
init|=
name|NULL
decl_stmt|;
name|int
name|count
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
name|target_structs
init|;
name|t
operator|<
name|target_structs
operator|+
name|target_struct_size
condition|;
operator|++
name|t
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|t
operator|)
operator|->
name|to_stratum
operator|==
operator|(
name|kernel_debugging
condition|?
name|kcore_stratum
else|:
name|core_stratum
operator|)
condition|)
block|{
name|runable
operator|=
operator|*
name|t
expr_stmt|;
operator|++
name|count
expr_stmt|;
block|}
block|}
return|return
operator|(
name|count
operator|==
literal|1
condition|?
name|runable
else|:
name|NULL
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The inferior process has died.  Long live the inferior!  */
end_comment

begin_function
name|void
name|generic_mourn_inferior
parameter_list|()
block|{
specifier|extern
name|int
name|show_breakpoint_hit_counts
decl_stmt|;
name|inferior_pid
operator|=
literal|0
expr_stmt|;
name|attach_flag
operator|=
literal|0
expr_stmt|;
name|breakpoint_init_inferior
argument_list|(
name|inf_exited
argument_list|)
expr_stmt|;
name|registers_changed
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|CLEAR_DEFERRED_STORES
comment|/* Delete any pending stores to the inferior... */
name|CLEAR_DEFERRED_STORES
expr_stmt|;
endif|#
directive|endif
name|reopen_exec_file
argument_list|()
expr_stmt|;
name|reinit_frame_cache
argument_list|()
expr_stmt|;
comment|/* It is confusing to the user for ignore counts to stick around      from previous runs of the inferior.  So clear them.  */
comment|/* However, it is more confusing for the ignore counts to disappear when      using hit counts.  So don't clear them if we're counting hits.  */
if|if
condition|(
operator|!
name|show_breakpoint_hit_counts
condition|)
name|breakpoint_clear_ignore_counts
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This table must match in order and size the signals in enum target_signal    in target.h.  */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
block|}
name|signals
index|[]
init|=
block|{
block|{
literal|"0"
block|,
literal|"Signal 0"
block|}
block|,
block|{
literal|"SIGHUP"
block|,
literal|"Hangup"
block|}
block|,
block|{
literal|"SIGINT"
block|,
literal|"Interrupt"
block|}
block|,
block|{
literal|"SIGQUIT"
block|,
literal|"Quit"
block|}
block|,
block|{
literal|"SIGILL"
block|,
literal|"Illegal instruction"
block|}
block|,
block|{
literal|"SIGTRAP"
block|,
literal|"Trace/breakpoint trap"
block|}
block|,
block|{
literal|"SIGABRT"
block|,
literal|"Aborted"
block|}
block|,
block|{
literal|"SIGEMT"
block|,
literal|"Emulation trap"
block|}
block|,
block|{
literal|"SIGFPE"
block|,
literal|"Arithmetic exception"
block|}
block|,
block|{
literal|"SIGKILL"
block|,
literal|"Killed"
block|}
block|,
block|{
literal|"SIGBUS"
block|,
literal|"Bus error"
block|}
block|,
block|{
literal|"SIGSEGV"
block|,
literal|"Segmentation fault"
block|}
block|,
block|{
literal|"SIGSYS"
block|,
literal|"Bad system call"
block|}
block|,
block|{
literal|"SIGPIPE"
block|,
literal|"Broken pipe"
block|}
block|,
block|{
literal|"SIGALRM"
block|,
literal|"Alarm clock"
block|}
block|,
block|{
literal|"SIGTERM"
block|,
literal|"Terminated"
block|}
block|,
block|{
literal|"SIGURG"
block|,
literal|"Urgent I/O condition"
block|}
block|,
block|{
literal|"SIGSTOP"
block|,
literal|"Stopped (signal)"
block|}
block|,
block|{
literal|"SIGTSTP"
block|,
literal|"Stopped (user)"
block|}
block|,
block|{
literal|"SIGCONT"
block|,
literal|"Continued"
block|}
block|,
block|{
literal|"SIGCHLD"
block|,
literal|"Child status changed"
block|}
block|,
block|{
literal|"SIGTTIN"
block|,
literal|"Stopped (tty input)"
block|}
block|,
block|{
literal|"SIGTTOU"
block|,
literal|"Stopped (tty output)"
block|}
block|,
block|{
literal|"SIGIO"
block|,
literal|"I/O possible"
block|}
block|,
block|{
literal|"SIGXCPU"
block|,
literal|"CPU time limit exceeded"
block|}
block|,
block|{
literal|"SIGXFSZ"
block|,
literal|"File size limit exceeded"
block|}
block|,
block|{
literal|"SIGVTALRM"
block|,
literal|"Virtual timer expired"
block|}
block|,
block|{
literal|"SIGPROF"
block|,
literal|"Profiling timer expired"
block|}
block|,
block|{
literal|"SIGWINCH"
block|,
literal|"Window size changed"
block|}
block|,
block|{
literal|"SIGLOST"
block|,
literal|"Resource lost"
block|}
block|,
block|{
literal|"SIGUSR1"
block|,
literal|"User defined signal 1"
block|}
block|,
block|{
literal|"SIGUSR2"
block|,
literal|"User defined signal 2"
block|}
block|,
block|{
literal|"SIGPWR"
block|,
literal|"Power fail/restart"
block|}
block|,
block|{
literal|"SIGPOLL"
block|,
literal|"Pollable event occurred"
block|}
block|,
block|{
literal|"SIGWIND"
block|,
literal|"SIGWIND"
block|}
block|,
block|{
literal|"SIGPHONE"
block|,
literal|"SIGPHONE"
block|}
block|,
block|{
literal|"SIGWAITING"
block|,
literal|"Process's LWPs are blocked"
block|}
block|,
block|{
literal|"SIGLWP"
block|,
literal|"Signal LWP"
block|}
block|,
block|{
literal|"SIGDANGER"
block|,
literal|"Swap space dangerously low"
block|}
block|,
block|{
literal|"SIGGRANT"
block|,
literal|"Monitor mode granted"
block|}
block|,
block|{
literal|"SIGRETRACT"
block|,
literal|"Need to relinquish monitor mode"
block|}
block|,
block|{
literal|"SIGMSG"
block|,
literal|"Monitor mode data available"
block|}
block|,
block|{
literal|"SIGSOUND"
block|,
literal|"Sound completed"
block|}
block|,
block|{
literal|"SIGSAK"
block|,
literal|"Secure attention"
block|}
block|,
block|{
literal|"SIGPRIO"
block|,
literal|"SIGPRIO"
block|}
block|,
block|{
literal|"SIG33"
block|,
literal|"Real-time event 33"
block|}
block|,
block|{
literal|"SIG34"
block|,
literal|"Real-time event 34"
block|}
block|,
block|{
literal|"SIG35"
block|,
literal|"Real-time event 35"
block|}
block|,
block|{
literal|"SIG36"
block|,
literal|"Real-time event 36"
block|}
block|,
block|{
literal|"SIG37"
block|,
literal|"Real-time event 37"
block|}
block|,
block|{
literal|"SIG38"
block|,
literal|"Real-time event 38"
block|}
block|,
block|{
literal|"SIG39"
block|,
literal|"Real-time event 39"
block|}
block|,
block|{
literal|"SIG40"
block|,
literal|"Real-time event 40"
block|}
block|,
block|{
literal|"SIG41"
block|,
literal|"Real-time event 41"
block|}
block|,
block|{
literal|"SIG42"
block|,
literal|"Real-time event 42"
block|}
block|,
block|{
literal|"SIG43"
block|,
literal|"Real-time event 43"
block|}
block|,
block|{
literal|"SIG44"
block|,
literal|"Real-time event 44"
block|}
block|,
block|{
literal|"SIG45"
block|,
literal|"Real-time event 45"
block|}
block|,
block|{
literal|"SIG46"
block|,
literal|"Real-time event 46"
block|}
block|,
block|{
literal|"SIG47"
block|,
literal|"Real-time event 47"
block|}
block|,
block|{
literal|"SIG48"
block|,
literal|"Real-time event 48"
block|}
block|,
block|{
literal|"SIG49"
block|,
literal|"Real-time event 49"
block|}
block|,
block|{
literal|"SIG50"
block|,
literal|"Real-time event 50"
block|}
block|,
block|{
literal|"SIG51"
block|,
literal|"Real-time event 51"
block|}
block|,
block|{
literal|"SIG52"
block|,
literal|"Real-time event 52"
block|}
block|,
block|{
literal|"SIG53"
block|,
literal|"Real-time event 53"
block|}
block|,
block|{
literal|"SIG54"
block|,
literal|"Real-time event 54"
block|}
block|,
block|{
literal|"SIG55"
block|,
literal|"Real-time event 55"
block|}
block|,
block|{
literal|"SIG56"
block|,
literal|"Real-time event 56"
block|}
block|,
block|{
literal|"SIG57"
block|,
literal|"Real-time event 57"
block|}
block|,
block|{
literal|"SIG58"
block|,
literal|"Real-time event 58"
block|}
block|,
block|{
literal|"SIG59"
block|,
literal|"Real-time event 59"
block|}
block|,
block|{
literal|"SIG60"
block|,
literal|"Real-time event 60"
block|}
block|,
block|{
literal|"SIG61"
block|,
literal|"Real-time event 61"
block|}
block|,
block|{
literal|"SIG62"
block|,
literal|"Real-time event 62"
block|}
block|,
block|{
literal|"SIG63"
block|,
literal|"Real-time event 63"
block|}
block|,
if|#
directive|if
name|defined
argument_list|(
name|MACH
argument_list|)
operator|||
name|defined
argument_list|(
name|__MACH__
argument_list|)
comment|/* Mach exceptions */
block|{
literal|"EXC_BAD_ACCESS"
block|,
literal|"Could not access memory"
block|}
block|,
block|{
literal|"EXC_BAD_INSTRUCTION"
block|,
literal|"Illegal instruction/operand"
block|}
block|,
block|{
literal|"EXC_ARITHMETIC"
block|,
literal|"Arithmetic exception"
block|}
block|,
block|{
literal|"EXC_EMULATION"
block|,
literal|"Emulation instruction"
block|}
block|,
block|{
literal|"EXC_SOFTWARE"
block|,
literal|"Software generated exception"
block|}
block|,
block|{
literal|"EXC_BREAKPOINT"
block|,
literal|"Breakpoint"
block|}
block|,
endif|#
directive|endif
block|{
name|NULL
block|,
literal|"Unknown signal"
block|}
block|,
block|{
name|NULL
block|,
literal|"Internal error: printing TARGET_SIGNAL_DEFAULT"
block|}
block|,
comment|/* Last entry, used to check whether the table is the right size.  */
block|{
name|NULL
block|,
literal|"TARGET_SIGNAL_MAGIC"
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* Return the string for a signal.  */
end_comment

begin_function
name|char
modifier|*
name|target_signal_to_string
parameter_list|(
name|sig
parameter_list|)
name|enum
name|target_signal
name|sig
decl_stmt|;
block|{
return|return
name|signals
index|[
name|sig
index|]
operator|.
name|string
return|;
block|}
end_function

begin_comment
comment|/* Return the name for a signal.  */
end_comment

begin_function
name|char
modifier|*
name|target_signal_to_name
parameter_list|(
name|sig
parameter_list|)
name|enum
name|target_signal
name|sig
decl_stmt|;
block|{
if|if
condition|(
name|sig
operator|==
name|TARGET_SIGNAL_UNKNOWN
condition|)
comment|/* I think the code which prints this will always print it along with        the string, so no need to be verbose.  */
return|return
literal|"?"
return|;
return|return
name|signals
index|[
name|sig
index|]
operator|.
name|name
return|;
block|}
end_function

begin_comment
comment|/* Given a name, return its signal.  */
end_comment

begin_function
name|enum
name|target_signal
name|target_signal_from_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|enum
name|target_signal
name|sig
decl_stmt|;
comment|/* It's possible we also should allow "SIGCLD" as well as "SIGCHLD"      for TARGET_SIGNAL_SIGCHLD.  SIGIOT, on the other hand, is more      questionable; seems like by now people should call it SIGABRT      instead.  */
comment|/* This ugly cast brought to you by the native VAX compiler.  */
for|for
control|(
name|sig
operator|=
name|TARGET_SIGNAL_HUP
init|;
name|signals
index|[
name|sig
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|sig
operator|=
operator|(
expr|enum
name|target_signal
operator|)
operator|(
operator|(
name|int
operator|)
name|sig
operator|+
literal|1
operator|)
control|)
if|if
condition|(
name|STREQ
argument_list|(
name|name
argument_list|,
name|signals
index|[
name|sig
index|]
operator|.
name|name
argument_list|)
condition|)
return|return
name|sig
return|;
return|return
name|TARGET_SIGNAL_UNKNOWN
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following functions are to help certain targets deal    with the signal/waitstatus stuff.  They could just as well be in    a file called native-utils.c or unixwaitstatus-utils.c or whatever.  */
end_comment

begin_comment
comment|/* Convert host signal to our signals.  */
end_comment

begin_function
name|enum
name|target_signal
name|target_signal_from_host
parameter_list|(
name|hostsig
parameter_list|)
name|int
name|hostsig
decl_stmt|;
block|{
comment|/* A switch statement would make sense but would require special kludges      to deal with the cases where more than one signal has the same number.  */
if|if
condition|(
name|hostsig
operator|==
literal|0
condition|)
return|return
name|TARGET_SIGNAL_0
return|;
if|#
directive|if
name|defined
argument_list|(
name|SIGHUP
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGHUP
condition|)
return|return
name|TARGET_SIGNAL_HUP
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGINT
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGINT
condition|)
return|return
name|TARGET_SIGNAL_INT
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGQUIT
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGQUIT
condition|)
return|return
name|TARGET_SIGNAL_QUIT
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGILL
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGILL
condition|)
return|return
name|TARGET_SIGNAL_ILL
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGTRAP
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGTRAP
condition|)
return|return
name|TARGET_SIGNAL_TRAP
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGABRT
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGABRT
condition|)
return|return
name|TARGET_SIGNAL_ABRT
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGEMT
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGEMT
condition|)
return|return
name|TARGET_SIGNAL_EMT
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGFPE
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGFPE
condition|)
return|return
name|TARGET_SIGNAL_FPE
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGKILL
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGKILL
condition|)
return|return
name|TARGET_SIGNAL_KILL
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGBUS
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGBUS
condition|)
return|return
name|TARGET_SIGNAL_BUS
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGSEGV
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGSEGV
condition|)
return|return
name|TARGET_SIGNAL_SEGV
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGSYS
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGSYS
condition|)
return|return
name|TARGET_SIGNAL_SYS
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPIPE
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGPIPE
condition|)
return|return
name|TARGET_SIGNAL_PIPE
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGALRM
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGALRM
condition|)
return|return
name|TARGET_SIGNAL_ALRM
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGTERM
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGTERM
condition|)
return|return
name|TARGET_SIGNAL_TERM
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGUSR1
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGUSR1
condition|)
return|return
name|TARGET_SIGNAL_USR1
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGUSR2
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGUSR2
condition|)
return|return
name|TARGET_SIGNAL_USR2
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGCLD
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGCLD
condition|)
return|return
name|TARGET_SIGNAL_CHLD
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGCHLD
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGCHLD
condition|)
return|return
name|TARGET_SIGNAL_CHLD
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPWR
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGPWR
condition|)
return|return
name|TARGET_SIGNAL_PWR
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGWINCH
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGWINCH
condition|)
return|return
name|TARGET_SIGNAL_WINCH
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGURG
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGURG
condition|)
return|return
name|TARGET_SIGNAL_URG
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGIO
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGIO
condition|)
return|return
name|TARGET_SIGNAL_IO
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPOLL
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGPOLL
condition|)
return|return
name|TARGET_SIGNAL_POLL
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGSTOP
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGSTOP
condition|)
return|return
name|TARGET_SIGNAL_STOP
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGTSTP
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGTSTP
condition|)
return|return
name|TARGET_SIGNAL_TSTP
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGCONT
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGCONT
condition|)
return|return
name|TARGET_SIGNAL_CONT
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGTTIN
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGTTIN
condition|)
return|return
name|TARGET_SIGNAL_TTIN
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGTTOU
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGTTOU
condition|)
return|return
name|TARGET_SIGNAL_TTOU
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGVTALRM
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGVTALRM
condition|)
return|return
name|TARGET_SIGNAL_VTALRM
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPROF
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGPROF
condition|)
return|return
name|TARGET_SIGNAL_PROF
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGXCPU
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGXCPU
condition|)
return|return
name|TARGET_SIGNAL_XCPU
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGXFSZ
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGXFSZ
condition|)
return|return
name|TARGET_SIGNAL_XFSZ
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGWIND
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGWIND
condition|)
return|return
name|TARGET_SIGNAL_WIND
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPHONE
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGPHONE
condition|)
return|return
name|TARGET_SIGNAL_PHONE
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGLOST
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGLOST
condition|)
return|return
name|TARGET_SIGNAL_LOST
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGWAITING
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGWAITING
condition|)
return|return
name|TARGET_SIGNAL_WAITING
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGLWP
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGLWP
condition|)
return|return
name|TARGET_SIGNAL_LWP
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGDANGER
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGDANGER
condition|)
return|return
name|TARGET_SIGNAL_DANGER
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGGRANT
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGGRANT
condition|)
return|return
name|TARGET_SIGNAL_GRANT
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGRETRACT
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGRETRACT
condition|)
return|return
name|TARGET_SIGNAL_RETRACT
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGMSG
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGMSG
condition|)
return|return
name|TARGET_SIGNAL_MSG
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGSOUND
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGSOUND
condition|)
return|return
name|TARGET_SIGNAL_SOUND
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGSAK
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGSAK
condition|)
return|return
name|TARGET_SIGNAL_SAK
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPRIO
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|SIGPRIO
condition|)
return|return
name|TARGET_SIGNAL_PRIO
return|;
endif|#
directive|endif
comment|/* Mach exceptions.  Assumes that the values for EXC_ are positive! */
if|#
directive|if
name|defined
argument_list|(
name|EXC_BAD_ACCESS
argument_list|)
operator|&&
name|defined
argument_list|(
name|_NSIG
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|_NSIG
operator|+
name|EXC_BAD_ACCESS
condition|)
return|return
name|TARGET_EXC_BAD_ACCESS
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EXC_BAD_INSTRUCTION
argument_list|)
operator|&&
name|defined
argument_list|(
name|_NSIG
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|_NSIG
operator|+
name|EXC_BAD_INSTRUCTION
condition|)
return|return
name|TARGET_EXC_BAD_INSTRUCTION
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EXC_ARITHMETIC
argument_list|)
operator|&&
name|defined
argument_list|(
name|_NSIG
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|_NSIG
operator|+
name|EXC_ARITHMETIC
condition|)
return|return
name|TARGET_EXC_ARITHMETIC
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EXC_EMULATION
argument_list|)
operator|&&
name|defined
argument_list|(
name|_NSIG
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|_NSIG
operator|+
name|EXC_EMULATION
condition|)
return|return
name|TARGET_EXC_EMULATION
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EXC_SOFTWARE
argument_list|)
operator|&&
name|defined
argument_list|(
name|_NSIG
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|_NSIG
operator|+
name|EXC_SOFTWARE
condition|)
return|return
name|TARGET_EXC_SOFTWARE
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EXC_BREAKPOINT
argument_list|)
operator|&&
name|defined
argument_list|(
name|_NSIG
argument_list|)
if|if
condition|(
name|hostsig
operator|==
name|_NSIG
operator|+
name|EXC_BREAKPOINT
condition|)
return|return
name|TARGET_EXC_BREAKPOINT
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|REALTIME_LO
argument_list|)
if|if
condition|(
name|hostsig
operator|>=
name|REALTIME_LO
operator|&&
name|hostsig
operator|<
name|REALTIME_HI
condition|)
return|return
operator|(
expr|enum
name|target_signal
operator|)
operator|(
name|hostsig
operator|-
literal|33
operator|+
operator|(
name|int
operator|)
name|TARGET_SIGNAL_REALTIME_33
operator|)
return|;
endif|#
directive|endif
return|return
name|TARGET_SIGNAL_UNKNOWN
return|;
block|}
end_function

begin_function
name|int
name|target_signal_to_host
parameter_list|(
name|oursig
parameter_list|)
name|enum
name|target_signal
name|oursig
decl_stmt|;
block|{
switch|switch
condition|(
name|oursig
condition|)
block|{
case|case
name|TARGET_SIGNAL_0
case|:
return|return
literal|0
return|;
if|#
directive|if
name|defined
argument_list|(
name|SIGHUP
argument_list|)
case|case
name|TARGET_SIGNAL_HUP
case|:
return|return
name|SIGHUP
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGINT
argument_list|)
case|case
name|TARGET_SIGNAL_INT
case|:
return|return
name|SIGINT
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGQUIT
argument_list|)
case|case
name|TARGET_SIGNAL_QUIT
case|:
return|return
name|SIGQUIT
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGILL
argument_list|)
case|case
name|TARGET_SIGNAL_ILL
case|:
return|return
name|SIGILL
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGTRAP
argument_list|)
case|case
name|TARGET_SIGNAL_TRAP
case|:
return|return
name|SIGTRAP
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGABRT
argument_list|)
case|case
name|TARGET_SIGNAL_ABRT
case|:
return|return
name|SIGABRT
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGEMT
argument_list|)
case|case
name|TARGET_SIGNAL_EMT
case|:
return|return
name|SIGEMT
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGFPE
argument_list|)
case|case
name|TARGET_SIGNAL_FPE
case|:
return|return
name|SIGFPE
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGKILL
argument_list|)
case|case
name|TARGET_SIGNAL_KILL
case|:
return|return
name|SIGKILL
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGBUS
argument_list|)
case|case
name|TARGET_SIGNAL_BUS
case|:
return|return
name|SIGBUS
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGSEGV
argument_list|)
case|case
name|TARGET_SIGNAL_SEGV
case|:
return|return
name|SIGSEGV
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGSYS
argument_list|)
case|case
name|TARGET_SIGNAL_SYS
case|:
return|return
name|SIGSYS
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPIPE
argument_list|)
case|case
name|TARGET_SIGNAL_PIPE
case|:
return|return
name|SIGPIPE
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGALRM
argument_list|)
case|case
name|TARGET_SIGNAL_ALRM
case|:
return|return
name|SIGALRM
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGTERM
argument_list|)
case|case
name|TARGET_SIGNAL_TERM
case|:
return|return
name|SIGTERM
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGUSR1
argument_list|)
case|case
name|TARGET_SIGNAL_USR1
case|:
return|return
name|SIGUSR1
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGUSR2
argument_list|)
case|case
name|TARGET_SIGNAL_USR2
case|:
return|return
name|SIGUSR2
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGCHLD
argument_list|)
operator|||
name|defined
argument_list|(
name|SIGCLD
argument_list|)
case|case
name|TARGET_SIGNAL_CHLD
case|:
if|#
directive|if
name|defined
argument_list|(
name|SIGCHLD
argument_list|)
return|return
name|SIGCHLD
return|;
else|#
directive|else
return|return
name|SIGCLD
return|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* SIGCLD or SIGCHLD */
if|#
directive|if
name|defined
argument_list|(
name|SIGPWR
argument_list|)
case|case
name|TARGET_SIGNAL_PWR
case|:
return|return
name|SIGPWR
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGWINCH
argument_list|)
case|case
name|TARGET_SIGNAL_WINCH
case|:
return|return
name|SIGWINCH
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGURG
argument_list|)
case|case
name|TARGET_SIGNAL_URG
case|:
return|return
name|SIGURG
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGIO
argument_list|)
case|case
name|TARGET_SIGNAL_IO
case|:
return|return
name|SIGIO
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPOLL
argument_list|)
case|case
name|TARGET_SIGNAL_POLL
case|:
return|return
name|SIGPOLL
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGSTOP
argument_list|)
case|case
name|TARGET_SIGNAL_STOP
case|:
return|return
name|SIGSTOP
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGTSTP
argument_list|)
case|case
name|TARGET_SIGNAL_TSTP
case|:
return|return
name|SIGTSTP
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGCONT
argument_list|)
case|case
name|TARGET_SIGNAL_CONT
case|:
return|return
name|SIGCONT
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGTTIN
argument_list|)
case|case
name|TARGET_SIGNAL_TTIN
case|:
return|return
name|SIGTTIN
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGTTOU
argument_list|)
case|case
name|TARGET_SIGNAL_TTOU
case|:
return|return
name|SIGTTOU
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGVTALRM
argument_list|)
case|case
name|TARGET_SIGNAL_VTALRM
case|:
return|return
name|SIGVTALRM
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPROF
argument_list|)
case|case
name|TARGET_SIGNAL_PROF
case|:
return|return
name|SIGPROF
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGXCPU
argument_list|)
case|case
name|TARGET_SIGNAL_XCPU
case|:
return|return
name|SIGXCPU
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGXFSZ
argument_list|)
case|case
name|TARGET_SIGNAL_XFSZ
case|:
return|return
name|SIGXFSZ
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGWIND
argument_list|)
case|case
name|TARGET_SIGNAL_WIND
case|:
return|return
name|SIGWIND
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPHONE
argument_list|)
case|case
name|TARGET_SIGNAL_PHONE
case|:
return|return
name|SIGPHONE
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGLOST
argument_list|)
case|case
name|TARGET_SIGNAL_LOST
case|:
return|return
name|SIGLOST
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGWAITING
argument_list|)
case|case
name|TARGET_SIGNAL_WAITING
case|:
return|return
name|SIGWAITING
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGLWP
argument_list|)
case|case
name|TARGET_SIGNAL_LWP
case|:
return|return
name|SIGLWP
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGDANGER
argument_list|)
case|case
name|TARGET_SIGNAL_DANGER
case|:
return|return
name|SIGDANGER
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGGRANT
argument_list|)
case|case
name|TARGET_SIGNAL_GRANT
case|:
return|return
name|SIGGRANT
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGRETRACT
argument_list|)
case|case
name|TARGET_SIGNAL_RETRACT
case|:
return|return
name|SIGRETRACT
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGMSG
argument_list|)
case|case
name|TARGET_SIGNAL_MSG
case|:
return|return
name|SIGMSG
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGSOUND
argument_list|)
case|case
name|TARGET_SIGNAL_SOUND
case|:
return|return
name|SIGSOUND
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGSAK
argument_list|)
case|case
name|TARGET_SIGNAL_SAK
case|:
return|return
name|SIGSAK
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPRIO
argument_list|)
case|case
name|TARGET_SIGNAL_PRIO
case|:
return|return
name|SIGPRIO
return|;
endif|#
directive|endif
comment|/* Mach exceptions.  Assumes that the values for EXC_ are positive! */
if|#
directive|if
name|defined
argument_list|(
name|EXC_BAD_ACCESS
argument_list|)
operator|&&
name|defined
argument_list|(
name|_NSIG
argument_list|)
case|case
name|TARGET_EXC_BAD_ACCESS
case|:
return|return
name|_NSIG
operator|+
name|EXC_BAD_ACCESS
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EXC_BAD_INSTRUCTION
argument_list|)
operator|&&
name|defined
argument_list|(
name|_NSIG
argument_list|)
case|case
name|TARGET_EXC_BAD_INSTRUCTION
case|:
return|return
name|_NSIG
operator|+
name|EXC_BAD_INSTRUCTION
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EXC_ARITHMETIC
argument_list|)
operator|&&
name|defined
argument_list|(
name|_NSIG
argument_list|)
case|case
name|TARGET_EXC_ARITHMETIC
case|:
return|return
name|_NSIG
operator|+
name|EXC_ARITHMETIC
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EXC_EMULATION
argument_list|)
operator|&&
name|defined
argument_list|(
name|_NSIG
argument_list|)
case|case
name|TARGET_EXC_EMULATION
case|:
return|return
name|_NSIG
operator|+
name|EXC_EMULATION
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EXC_SOFTWARE
argument_list|)
operator|&&
name|defined
argument_list|(
name|_NSIG
argument_list|)
case|case
name|TARGET_EXC_SOFTWARE
case|:
return|return
name|_NSIG
operator|+
name|EXC_SOFTWARE
return|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|EXC_BREAKPOINT
argument_list|)
operator|&&
name|defined
argument_list|(
name|_NSIG
argument_list|)
case|case
name|TARGET_EXC_BREAKPOINT
case|:
return|return
name|_NSIG
operator|+
name|EXC_BREAKPOINT
return|;
endif|#
directive|endif
default|default:
if|#
directive|if
name|defined
argument_list|(
name|REALTIME_LO
argument_list|)
if|if
condition|(
name|oursig
operator|>=
name|TARGET_SIGNAL_REALTIME_33
operator|&&
name|oursig
operator|<=
name|TARGET_SIGNAL_REALTIME_63
condition|)
block|{
name|int
name|retsig
init|=
operator|(
name|int
operator|)
name|oursig
operator|-
operator|(
name|int
operator|)
name|TARGET_SIGNAL_REALTIME_33
operator|+
name|REALTIME_LO
decl_stmt|;
if|if
condition|(
name|retsig
operator|<
name|REALTIME_HI
condition|)
return|return
name|retsig
return|;
block|}
endif|#
directive|endif
comment|/* The user might be trying to do "signal SIGSAK" where this system 	 doesn't have SIGSAK.  */
name|warning
argument_list|(
literal|"Signal %s does not exist on this system.\n"
argument_list|,
name|target_signal_to_name
argument_list|(
name|oursig
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Helper function for child_wait and the Lynx derivatives of child_wait.    HOSTSTATUS is the waitstatus from wait() or the equivalent; store our    translation of that in OURSTATUS.  */
end_comment

begin_function
name|void
name|store_waitstatus
parameter_list|(
name|ourstatus
parameter_list|,
name|hoststatus
parameter_list|)
name|struct
name|target_waitstatus
modifier|*
name|ourstatus
decl_stmt|;
name|int
name|hoststatus
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|CHILD_SPECIAL_WAITSTATUS
comment|/* CHILD_SPECIAL_WAITSTATUS should return nonzero and set *OURSTATUS      if it wants to deal with hoststatus.  */
if|if
condition|(
name|CHILD_SPECIAL_WAITSTATUS
argument_list|(
name|ourstatus
argument_list|,
name|hoststatus
argument_list|)
condition|)
return|return;
endif|#
directive|endif
if|if
condition|(
name|WIFEXITED
argument_list|(
name|hoststatus
argument_list|)
condition|)
block|{
name|ourstatus
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|integer
operator|=
name|WEXITSTATUS
argument_list|(
name|hoststatus
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|WIFSTOPPED
argument_list|(
name|hoststatus
argument_list|)
condition|)
block|{
name|ourstatus
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_SIGNALLED
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|target_signal_from_host
argument_list|(
name|WTERMSIG
argument_list|(
name|hoststatus
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ourstatus
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|target_signal_from_host
argument_list|(
name|WSTOPSIG
argument_list|(
name|hoststatus
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* In some circumstances we allow a command to specify a numeric    signal.  The idea is to keep these circumstances limited so that    users (and scripts) develop portable habits.  For comparison,    POSIX.2 `kill' requires that 1,2,3,6,9,14, and 15 work (and using a    numeric signal at all is obscelescent.  We are slightly more    lenient and allow 1-15 which should match host signal numbers on    most systems.  Use of symbolic signal names is strongly encouraged.  */
end_comment

begin_function
name|enum
name|target_signal
name|target_signal_from_command
parameter_list|(
name|num
parameter_list|)
name|int
name|num
decl_stmt|;
block|{
if|if
condition|(
name|num
operator|>=
literal|1
operator|&&
name|num
operator|<=
literal|15
condition|)
return|return
operator|(
expr|enum
name|target_signal
operator|)
name|num
return|;
name|error
argument_list|(
literal|"Only signals 1-15 are valid as numeric signals.\n\ Use \"info signals\" for a list of symbolic signals."
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Returns zero to leave the inferior alone, one to interrupt it.  */
end_comment

begin_macro
name|int
argument_list|(
argument|*target_activity_function
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|target_activity_fd
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Convert a normal process ID to a string.  Returns the string in a static    buffer.  */
end_comment

begin_function
name|char
modifier|*
name|normal_pid_to_str
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|current_target
operator|.
name|to_shortname
argument_list|,
literal|"remote"
argument_list|)
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"thread %d\0"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"process %d\0"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* Some targets (such as ttrace-based HPUX) don't allow us to request    notification of inferior events such as fork and vork immediately    after the inferior is created.  (This because of how gdb gets an    inferior created via invoking a shell to do it.  In such a scenario,    if the shell init file has commands in it, the shell will fork and    exec for each of those commands, and we will see each such fork    event.  Very bad.)        This function is used by all targets that allow us to request    notification of forks, etc at inferior creation time; e.g., in    target_acknowledge_forked_child.    */
end_comment

begin_function
name|void
name|normal_target_post_startup_inferior
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
comment|/* This space intentionally left blank. */
block|}
end_function

begin_comment
comment|/* Set up the handful of non-empty slots needed by the dummy target    vector.  */
end_comment

begin_function
specifier|static
name|void
name|init_dummy_target
parameter_list|()
block|{
name|dummy_target
operator|.
name|to_shortname
operator|=
literal|"None"
expr_stmt|;
name|dummy_target
operator|.
name|to_longname
operator|=
literal|"None"
expr_stmt|;
name|dummy_target
operator|.
name|to_doc
operator|=
literal|""
expr_stmt|;
name|dummy_target
operator|.
name|to_attach
operator|=
name|find_default_attach
expr_stmt|;
name|dummy_target
operator|.
name|to_require_attach
operator|=
name|find_default_require_attach
expr_stmt|;
name|dummy_target
operator|.
name|to_require_detach
operator|=
name|find_default_require_detach
expr_stmt|;
name|dummy_target
operator|.
name|to_create_inferior
operator|=
name|find_default_create_inferior
expr_stmt|;
name|dummy_target
operator|.
name|to_clone_and_follow_inferior
operator|=
name|find_default_clone_and_follow_inferior
expr_stmt|;
name|dummy_target
operator|.
name|to_stratum
operator|=
name|dummy_stratum
expr_stmt|;
name|dummy_target
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|MAINTENANCE_CMDS
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|target_ops
name|debug_target
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|debug_to_open
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|debug_target
operator|.
name|to_open
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_open (%s, %d)\n"
argument_list|,
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_close
parameter_list|(
name|quitting
parameter_list|)
name|int
name|quitting
decl_stmt|;
block|{
name|debug_target
operator|.
name|to_close
argument_list|(
name|quitting
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_close (%d)\n"
argument_list|,
name|quitting
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_attach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|debug_target
operator|.
name|to_attach
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_attach (%s, %d)\n"
argument_list|,
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_post_attach
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|debug_target
operator|.
name|to_post_attach
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_post_attach (%d)\n"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_require_attach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|debug_target
operator|.
name|to_require_attach
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_require_attach (%s, %d)\n"
argument_list|,
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_detach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|debug_target
operator|.
name|to_detach
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_detach (%s, %d)\n"
argument_list|,
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_require_detach
parameter_list|(
name|pid
parameter_list|,
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|int
name|pid
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|debug_target
operator|.
name|to_require_detach
argument_list|(
name|pid
argument_list|,
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_require_detach (%d, %s, %d)\n"
argument_list|,
name|pid
argument_list|,
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_resume
parameter_list|(
name|pid
parameter_list|,
name|step
parameter_list|,
name|siggnal
parameter_list|)
name|int
name|pid
decl_stmt|;
name|int
name|step
decl_stmt|;
name|enum
name|target_signal
name|siggnal
decl_stmt|;
block|{
name|debug_target
operator|.
name|to_resume
argument_list|(
name|pid
argument_list|,
name|step
argument_list|,
name|siggnal
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_resume (%d, %s, %s)\n"
argument_list|,
name|pid
argument_list|,
name|step
condition|?
literal|"step"
else|:
literal|"continue"
argument_list|,
name|target_signal_to_name
argument_list|(
name|siggnal
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_to_wait
parameter_list|(
name|pid
parameter_list|,
name|status
parameter_list|)
name|int
name|pid
decl_stmt|;
name|struct
name|target_waitstatus
modifier|*
name|status
decl_stmt|;
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|debug_target
operator|.
name|to_wait
argument_list|(
name|pid
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_wait (%d, status) = %d,   "
argument_list|,
name|pid
argument_list|,
name|retval
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"status->kind = "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|status
operator|->
name|kind
condition|)
block|{
case|case
name|TARGET_WAITKIND_EXITED
case|:
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"exited, status = %d\n"
argument_list|,
name|status
operator|->
name|value
operator|.
name|integer
argument_list|)
expr_stmt|;
break|break;
case|case
name|TARGET_WAITKIND_STOPPED
case|:
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"stopped, signal = %s\n"
argument_list|,
name|target_signal_to_name
argument_list|(
name|status
operator|->
name|value
operator|.
name|sig
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TARGET_WAITKIND_SIGNALLED
case|:
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"signalled, signal = %s\n"
argument_list|,
name|target_signal_to_name
argument_list|(
name|status
operator|->
name|value
operator|.
name|sig
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TARGET_WAITKIND_LOADED
case|:
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"loaded\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TARGET_WAITKIND_FORKED
case|:
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"forked\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TARGET_WAITKIND_VFORKED
case|:
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"vforked\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TARGET_WAITKIND_EXECD
case|:
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"execd\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TARGET_WAITKIND_SPURIOUS
case|:
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"spurious\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"unknown???\n"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_post_wait
parameter_list|(
name|pid
parameter_list|,
name|status
parameter_list|)
name|int
name|pid
decl_stmt|;
name|int
name|status
decl_stmt|;
block|{
name|debug_target
operator|.
name|to_post_wait
argument_list|(
name|pid
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_post_wait (%d, %d)\n"
argument_list|,
name|pid
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_fetch_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|debug_target
operator|.
name|to_fetch_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_fetch_registers (%s)"
argument_list|,
name|regno
operator|!=
operator|-
literal|1
condition|?
name|REGISTER_NAME
argument_list|(
name|regno
argument_list|)
else|:
literal|"-1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|!=
operator|-
literal|1
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|" = 0x%x %d"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_store_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|debug_target
operator|.
name|to_store_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|0
operator|&&
name|regno
operator|<
name|NUM_REGS
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_store_registers (%s) = 0x%x %d\n"
argument_list|,
name|REGISTER_NAME
argument_list|(
name|regno
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_store_registers (%d)\n"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_prepare_to_store
parameter_list|()
block|{
name|debug_target
operator|.
name|to_prepare_to_store
argument_list|()
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_prepare_to_store ()\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_to_xfer_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|write
parameter_list|,
name|target
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|write
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|debug_target
operator|.
name|to_xfer_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|,
name|write
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_xfer_memory (0x%x, xxx, %d, %s, xxx) = %d"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|memaddr
argument_list|,
comment|/* possable truncate long long */
name|len
argument_list|,
name|write
condition|?
literal|"write"
else|:
literal|"read"
argument_list|,
name|retval
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|>
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|fputs_unfiltered
argument_list|(
literal|", bytes ="
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|retval
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
operator|(
name|long
operator|)
operator|&
operator|(
name|myaddr
index|[
name|i
index|]
operator|)
operator|)
operator|&
literal|0xf
operator|)
operator|==
literal|0
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|" %02x"
argument_list|,
name|myaddr
index|[
name|i
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
block|}
name|fputc_unfiltered
argument_list|(
literal|'\n'
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_files_info
parameter_list|(
name|target
parameter_list|)
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
block|{
name|debug_target
operator|.
name|to_files_info
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_files_info (xxx)\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_to_insert_breakpoint
parameter_list|(
name|addr
parameter_list|,
name|save
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|save
decl_stmt|;
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|debug_target
operator|.
name|to_insert_breakpoint
argument_list|(
name|addr
argument_list|,
name|save
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_insert_breakpoint (0x%x, xxx) = %d\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|addr
argument_list|,
name|retval
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_to_remove_breakpoint
parameter_list|(
name|addr
parameter_list|,
name|save
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|save
decl_stmt|;
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|debug_target
operator|.
name|to_remove_breakpoint
argument_list|(
name|addr
argument_list|,
name|save
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_remove_breakpoint (0x%x, xxx) = %d\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|addr
argument_list|,
name|retval
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_terminal_init
parameter_list|()
block|{
name|debug_target
operator|.
name|to_terminal_init
argument_list|()
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_terminal_init ()\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_terminal_inferior
parameter_list|()
block|{
name|debug_target
operator|.
name|to_terminal_inferior
argument_list|()
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_terminal_inferior ()\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_terminal_ours_for_output
parameter_list|()
block|{
name|debug_target
operator|.
name|to_terminal_ours_for_output
argument_list|()
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_terminal_ours_for_output ()\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_terminal_ours
parameter_list|()
block|{
name|debug_target
operator|.
name|to_terminal_ours
argument_list|()
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_terminal_ours ()\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_terminal_info
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|debug_target
operator|.
name|to_terminal_info
argument_list|(
name|arg
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_terminal_info (%s, %d)\n"
argument_list|,
name|arg
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_kill
parameter_list|()
block|{
name|debug_target
operator|.
name|to_kill
argument_list|()
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_kill ()\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_load
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|debug_target
operator|.
name|to_load
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_load (%s, %d)\n"
argument_list|,
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_to_lookup_symbol
parameter_list|(
name|name
parameter_list|,
name|addrp
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|CORE_ADDR
modifier|*
name|addrp
decl_stmt|;
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|debug_target
operator|.
name|to_lookup_symbol
argument_list|(
name|name
argument_list|,
name|addrp
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_lookup_symbol (%s, xxx)\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_create_inferior
parameter_list|(
name|exec_file
parameter_list|,
name|args
parameter_list|,
name|env
parameter_list|)
name|char
modifier|*
name|exec_file
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
name|char
modifier|*
modifier|*
name|env
decl_stmt|;
block|{
name|debug_target
operator|.
name|to_create_inferior
argument_list|(
name|exec_file
argument_list|,
name|args
argument_list|,
name|env
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_create_inferior (%s, %s, xxx)\n"
argument_list|,
name|exec_file
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_post_startup_inferior
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|debug_target
operator|.
name|to_post_startup_inferior
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_post_startup_inferior (%d)\n"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_acknowledge_created_inferior
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|debug_target
operator|.
name|to_acknowledge_created_inferior
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_acknowledge_created_inferior (%d)\n"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_clone_and_follow_inferior
parameter_list|(
name|child_pid
parameter_list|,
name|followed_child
parameter_list|)
name|int
name|child_pid
decl_stmt|;
name|int
modifier|*
name|followed_child
decl_stmt|;
block|{
name|debug_target
operator|.
name|to_clone_and_follow_inferior
argument_list|(
name|child_pid
argument_list|,
name|followed_child
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_clone_and_follow_inferior (%d, %d)\n"
argument_list|,
name|child_pid
argument_list|,
operator|*
name|followed_child
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_post_follow_inferior_by_clone
parameter_list|()
block|{
name|debug_target
operator|.
name|to_post_follow_inferior_by_clone
argument_list|()
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_post_follow_inferior_by_clone ()\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_to_insert_fork_catchpoint
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|debug_target
operator|.
name|to_insert_fork_catchpoint
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_insert_fork_catchpoint (%d) = %d\n"
argument_list|,
name|pid
argument_list|,
name|retval
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_to_remove_fork_catchpoint
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|debug_target
operator|.
name|to_remove_fork_catchpoint
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_remove_fork_catchpoint (%d) = %d\n"
argument_list|,
name|pid
argument_list|,
name|retval
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_to_insert_vfork_catchpoint
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|debug_target
operator|.
name|to_insert_vfork_catchpoint
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_insert_vfork_catchpoint (%d)= %d\n"
argument_list|,
name|pid
argument_list|,
name|retval
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_to_remove_vfork_catchpoint
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|debug_target
operator|.
name|to_remove_vfork_catchpoint
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_remove_vfork_catchpoint (%d) = %d\n"
argument_list|,
name|pid
argument_list|,
name|retval
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_to_has_forked
parameter_list|(
name|pid
parameter_list|,
name|child_pid
parameter_list|)
name|int
name|pid
decl_stmt|;
name|int
modifier|*
name|child_pid
decl_stmt|;
block|{
name|int
name|has_forked
decl_stmt|;
name|has_forked
operator|=
name|debug_target
operator|.
name|to_has_forked
argument_list|(
name|pid
argument_list|,
name|child_pid
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_has_forked (%d, %d) = %d\n"
argument_list|,
name|pid
argument_list|,
operator|*
name|child_pid
argument_list|,
name|has_forked
argument_list|)
expr_stmt|;
return|return
name|has_forked
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_to_has_vforked
parameter_list|(
name|pid
parameter_list|,
name|child_pid
parameter_list|)
name|int
name|pid
decl_stmt|;
name|int
modifier|*
name|child_pid
decl_stmt|;
block|{
name|int
name|has_vforked
decl_stmt|;
name|has_vforked
operator|=
name|debug_target
operator|.
name|to_has_vforked
argument_list|(
name|pid
argument_list|,
name|child_pid
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_has_vforked (%d, %d) = %d\n"
argument_list|,
name|pid
argument_list|,
operator|*
name|child_pid
argument_list|,
name|has_vforked
argument_list|)
expr_stmt|;
return|return
name|has_vforked
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_to_can_follow_vfork_prior_to_exec
parameter_list|()
block|{
name|int
name|can_immediately_follow_vfork
decl_stmt|;
name|can_immediately_follow_vfork
operator|=
name|debug_target
operator|.
name|to_can_follow_vfork_prior_to_exec
argument_list|()
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_can_follow_vfork_prior_to_exec () = %d\n"
argument_list|,
name|can_immediately_follow_vfork
argument_list|)
expr_stmt|;
return|return
name|can_immediately_follow_vfork
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_post_follow_vfork
parameter_list|(
name|parent_pid
parameter_list|,
name|followed_parent
parameter_list|,
name|child_pid
parameter_list|,
name|followed_child
parameter_list|)
name|int
name|parent_pid
decl_stmt|;
name|int
name|followed_parent
decl_stmt|;
name|int
name|child_pid
decl_stmt|;
name|int
name|followed_child
decl_stmt|;
block|{
name|debug_target
operator|.
name|to_post_follow_vfork
argument_list|(
name|parent_pid
argument_list|,
name|followed_parent
argument_list|,
name|child_pid
argument_list|,
name|followed_child
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_post_follow_vfork (%d, %d, %d, %d)\n"
argument_list|,
name|parent_pid
argument_list|,
name|followed_parent
argument_list|,
name|child_pid
argument_list|,
name|followed_child
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_to_insert_exec_catchpoint
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|debug_target
operator|.
name|to_insert_exec_catchpoint
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_insert_exec_catchpoint (%d) = %d\n"
argument_list|,
name|pid
argument_list|,
name|retval
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_to_remove_exec_catchpoint
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|debug_target
operator|.
name|to_remove_exec_catchpoint
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_remove_exec_catchpoint (%d) = %d\n"
argument_list|,
name|pid
argument_list|,
name|retval
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_to_has_execd
parameter_list|(
name|pid
parameter_list|,
name|execd_pathname
parameter_list|)
name|int
name|pid
decl_stmt|;
name|char
modifier|*
modifier|*
name|execd_pathname
decl_stmt|;
block|{
name|int
name|has_execd
decl_stmt|;
name|has_execd
operator|=
name|debug_target
operator|.
name|to_has_execd
argument_list|(
name|pid
argument_list|,
name|execd_pathname
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_has_execd (%d, %s) = %d\n"
argument_list|,
name|pid
argument_list|,
operator|*
name|execd_pathname
argument_list|,
name|has_execd
argument_list|)
expr_stmt|;
return|return
name|has_execd
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_to_reported_exec_events_per_exec_call
parameter_list|()
block|{
name|int
name|reported_exec_events
decl_stmt|;
name|reported_exec_events
operator|=
name|debug_target
operator|.
name|to_reported_exec_events_per_exec_call
argument_list|()
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_reported_exec_events_per_exec_call () = %d\n"
argument_list|,
name|reported_exec_events
argument_list|)
expr_stmt|;
return|return
name|reported_exec_events
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_to_has_syscall_event
parameter_list|(
name|pid
parameter_list|,
name|kind
parameter_list|,
name|syscall_id
parameter_list|)
name|int
name|pid
decl_stmt|;
name|enum
name|target_waitkind
modifier|*
name|kind
decl_stmt|;
name|int
modifier|*
name|syscall_id
decl_stmt|;
block|{
name|int
name|has_syscall_event
decl_stmt|;
name|char
modifier|*
name|kind_spelling
init|=
literal|"??"
decl_stmt|;
name|has_syscall_event
operator|=
name|debug_target
operator|.
name|to_has_syscall_event
argument_list|(
name|pid
argument_list|,
name|kind
argument_list|,
name|syscall_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_syscall_event
condition|)
block|{
switch|switch
condition|(
operator|*
name|kind
condition|)
block|{
case|case
name|TARGET_WAITKIND_SYSCALL_ENTRY
case|:
name|kind_spelling
operator|=
literal|"SYSCALL_ENTRY"
expr_stmt|;
break|break;
case|case
name|TARGET_WAITKIND_SYSCALL_RETURN
case|:
name|kind_spelling
operator|=
literal|"SYSCALL_RETURN"
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_has_syscall_event (%d, %s, %d) = %d\n"
argument_list|,
name|pid
argument_list|,
name|kind_spelling
argument_list|,
operator|*
name|syscall_id
argument_list|,
name|has_syscall_event
argument_list|)
expr_stmt|;
return|return
name|has_syscall_event
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_to_has_exited
parameter_list|(
name|pid
parameter_list|,
name|wait_status
parameter_list|,
name|exit_status
parameter_list|)
name|int
name|pid
decl_stmt|;
name|int
name|wait_status
decl_stmt|;
name|int
modifier|*
name|exit_status
decl_stmt|;
block|{
name|int
name|has_exited
decl_stmt|;
name|has_exited
operator|=
name|debug_target
operator|.
name|to_has_exited
argument_list|(
name|pid
argument_list|,
name|wait_status
argument_list|,
name|exit_status
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_has_exited (%d, %d, %d) = %d\n"
argument_list|,
name|pid
argument_list|,
name|wait_status
argument_list|,
operator|*
name|exit_status
argument_list|,
name|has_exited
argument_list|)
expr_stmt|;
return|return
name|has_exited
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_mourn_inferior
parameter_list|()
block|{
name|debug_target
operator|.
name|to_mourn_inferior
argument_list|()
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_mourn_inferior ()\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_to_can_run
parameter_list|()
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|debug_target
operator|.
name|to_can_run
argument_list|()
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_can_run () = %d\n"
argument_list|,
name|retval
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_notice_signals
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|debug_target
operator|.
name|to_notice_signals
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_notice_signals (%d)\n"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_to_thread_alive
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|debug_target
operator|.
name|to_thread_alive
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_thread_alive (%d) = %d\n"
argument_list|,
name|pid
argument_list|,
name|retval
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_stop
parameter_list|()
block|{
name|debug_target
operator|.
name|to_stop
argument_list|()
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_stop ()\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_to_query
parameter_list|(
name|type
parameter_list|,
name|req
parameter_list|,
name|resp
parameter_list|,
name|siz
parameter_list|)
name|int
name|type
decl_stmt|;
name|char
modifier|*
name|req
decl_stmt|;
name|char
modifier|*
name|resp
decl_stmt|;
name|int
modifier|*
name|siz
decl_stmt|;
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|debug_target
operator|.
name|to_query
argument_list|(
name|type
argument_list|,
name|req
argument_list|,
name|resp
argument_list|,
name|siz
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_query (%c, %s, %s,  %d) = %d\n"
argument_list|,
name|type
argument_list|,
name|req
argument_list|,
name|resp
argument_list|,
operator|*
name|siz
argument_list|,
name|retval
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|symtab_and_line
modifier|*
name|debug_to_enable_exception_callback
parameter_list|(
name|kind
parameter_list|,
name|enable
parameter_list|)
name|enum
name|exception_event_kind
name|kind
decl_stmt|;
name|int
name|enable
decl_stmt|;
block|{
name|debug_target
operator|.
name|to_enable_exception_callback
argument_list|(
name|kind
argument_list|,
name|enable
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target get_exception_callback_sal (%d, %d)\n"
argument_list|,
name|kind
argument_list|,
name|enable
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|exception_event_record
modifier|*
name|debug_to_get_current_exception_event
parameter_list|()
block|{
name|debug_target
operator|.
name|to_get_current_exception_event
argument_list|()
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target get_current_exception_event ()\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|debug_to_pid_to_exec_file
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|char
modifier|*
name|exec_file
decl_stmt|;
name|exec_file
operator|=
name|debug_target
operator|.
name|to_pid_to_exec_file
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_pid_to_exec_file (%d) = %s\n"
argument_list|,
name|pid
argument_list|,
name|exec_file
argument_list|)
expr_stmt|;
return|return
name|exec_file
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|debug_to_core_file_to_sym_file
parameter_list|(
name|core
parameter_list|)
name|char
modifier|*
name|core
decl_stmt|;
block|{
name|char
modifier|*
name|sym_file
decl_stmt|;
name|sym_file
operator|=
name|debug_target
operator|.
name|to_core_file_to_sym_file
argument_list|(
name|core
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"target_core_file_to_sym_file (%s) = %s\n"
argument_list|,
name|core
argument_list|,
name|sym_file
argument_list|)
expr_stmt|;
return|return
name|sym_file
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|setup_target_debug
parameter_list|()
block|{
name|memcpy
argument_list|(
operator|&
name|debug_target
argument_list|,
operator|&
name|current_target
argument_list|,
sizeof|sizeof
name|debug_target
argument_list|)
expr_stmt|;
name|current_target
operator|.
name|to_open
operator|=
name|debug_to_open
expr_stmt|;
name|current_target
operator|.
name|to_close
operator|=
name|debug_to_close
expr_stmt|;
name|current_target
operator|.
name|to_attach
operator|=
name|debug_to_attach
expr_stmt|;
name|current_target
operator|.
name|to_post_attach
operator|=
name|debug_to_post_attach
expr_stmt|;
name|current_target
operator|.
name|to_require_attach
operator|=
name|debug_to_require_attach
expr_stmt|;
name|current_target
operator|.
name|to_detach
operator|=
name|debug_to_detach
expr_stmt|;
name|current_target
operator|.
name|to_require_detach
operator|=
name|debug_to_require_detach
expr_stmt|;
name|current_target
operator|.
name|to_resume
operator|=
name|debug_to_resume
expr_stmt|;
name|current_target
operator|.
name|to_wait
operator|=
name|debug_to_wait
expr_stmt|;
name|current_target
operator|.
name|to_post_wait
operator|=
name|debug_to_post_wait
expr_stmt|;
name|current_target
operator|.
name|to_fetch_registers
operator|=
name|debug_to_fetch_registers
expr_stmt|;
name|current_target
operator|.
name|to_store_registers
operator|=
name|debug_to_store_registers
expr_stmt|;
name|current_target
operator|.
name|to_prepare_to_store
operator|=
name|debug_to_prepare_to_store
expr_stmt|;
name|current_target
operator|.
name|to_xfer_memory
operator|=
name|debug_to_xfer_memory
expr_stmt|;
name|current_target
operator|.
name|to_files_info
operator|=
name|debug_to_files_info
expr_stmt|;
name|current_target
operator|.
name|to_insert_breakpoint
operator|=
name|debug_to_insert_breakpoint
expr_stmt|;
name|current_target
operator|.
name|to_remove_breakpoint
operator|=
name|debug_to_remove_breakpoint
expr_stmt|;
name|current_target
operator|.
name|to_terminal_init
operator|=
name|debug_to_terminal_init
expr_stmt|;
name|current_target
operator|.
name|to_terminal_inferior
operator|=
name|debug_to_terminal_inferior
expr_stmt|;
name|current_target
operator|.
name|to_terminal_ours_for_output
operator|=
name|debug_to_terminal_ours_for_output
expr_stmt|;
name|current_target
operator|.
name|to_terminal_ours
operator|=
name|debug_to_terminal_ours
expr_stmt|;
name|current_target
operator|.
name|to_terminal_info
operator|=
name|debug_to_terminal_info
expr_stmt|;
name|current_target
operator|.
name|to_kill
operator|=
name|debug_to_kill
expr_stmt|;
name|current_target
operator|.
name|to_load
operator|=
name|debug_to_load
expr_stmt|;
name|current_target
operator|.
name|to_lookup_symbol
operator|=
name|debug_to_lookup_symbol
expr_stmt|;
name|current_target
operator|.
name|to_create_inferior
operator|=
name|debug_to_create_inferior
expr_stmt|;
name|current_target
operator|.
name|to_post_startup_inferior
operator|=
name|debug_to_post_startup_inferior
expr_stmt|;
name|current_target
operator|.
name|to_acknowledge_created_inferior
operator|=
name|debug_to_acknowledge_created_inferior
expr_stmt|;
name|current_target
operator|.
name|to_clone_and_follow_inferior
operator|=
name|debug_to_clone_and_follow_inferior
expr_stmt|;
name|current_target
operator|.
name|to_post_follow_inferior_by_clone
operator|=
name|debug_to_post_follow_inferior_by_clone
expr_stmt|;
name|current_target
operator|.
name|to_insert_fork_catchpoint
operator|=
name|debug_to_insert_fork_catchpoint
expr_stmt|;
name|current_target
operator|.
name|to_remove_fork_catchpoint
operator|=
name|debug_to_remove_fork_catchpoint
expr_stmt|;
name|current_target
operator|.
name|to_insert_vfork_catchpoint
operator|=
name|debug_to_insert_vfork_catchpoint
expr_stmt|;
name|current_target
operator|.
name|to_remove_vfork_catchpoint
operator|=
name|debug_to_remove_vfork_catchpoint
expr_stmt|;
name|current_target
operator|.
name|to_has_forked
operator|=
name|debug_to_has_forked
expr_stmt|;
name|current_target
operator|.
name|to_has_vforked
operator|=
name|debug_to_has_vforked
expr_stmt|;
name|current_target
operator|.
name|to_can_follow_vfork_prior_to_exec
operator|=
name|debug_to_can_follow_vfork_prior_to_exec
expr_stmt|;
name|current_target
operator|.
name|to_post_follow_vfork
operator|=
name|debug_to_post_follow_vfork
expr_stmt|;
name|current_target
operator|.
name|to_insert_exec_catchpoint
operator|=
name|debug_to_insert_exec_catchpoint
expr_stmt|;
name|current_target
operator|.
name|to_remove_exec_catchpoint
operator|=
name|debug_to_remove_exec_catchpoint
expr_stmt|;
name|current_target
operator|.
name|to_has_execd
operator|=
name|debug_to_has_execd
expr_stmt|;
name|current_target
operator|.
name|to_reported_exec_events_per_exec_call
operator|=
name|debug_to_reported_exec_events_per_exec_call
expr_stmt|;
name|current_target
operator|.
name|to_has_syscall_event
operator|=
name|debug_to_has_syscall_event
expr_stmt|;
name|current_target
operator|.
name|to_has_exited
operator|=
name|debug_to_has_exited
expr_stmt|;
name|current_target
operator|.
name|to_mourn_inferior
operator|=
name|debug_to_mourn_inferior
expr_stmt|;
name|current_target
operator|.
name|to_can_run
operator|=
name|debug_to_can_run
expr_stmt|;
name|current_target
operator|.
name|to_notice_signals
operator|=
name|debug_to_notice_signals
expr_stmt|;
name|current_target
operator|.
name|to_thread_alive
operator|=
name|debug_to_thread_alive
expr_stmt|;
name|current_target
operator|.
name|to_stop
operator|=
name|debug_to_stop
expr_stmt|;
name|current_target
operator|.
name|to_query
operator|=
name|debug_to_query
expr_stmt|;
name|current_target
operator|.
name|to_enable_exception_callback
operator|=
name|debug_to_enable_exception_callback
expr_stmt|;
name|current_target
operator|.
name|to_get_current_exception_event
operator|=
name|debug_to_get_current_exception_event
expr_stmt|;
name|current_target
operator|.
name|to_pid_to_exec_file
operator|=
name|debug_to_pid_to_exec_file
expr_stmt|;
name|current_target
operator|.
name|to_core_file_to_sym_file
operator|=
name|debug_to_core_file_to_sym_file
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAINTENANCE_CMDS */
end_comment

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|char
name|targ_desc
index|[]
init|=
literal|"Names of targets and files being debugged.\n\ Shows the entire stack of targets currently in use (including the exec-file,\n\ core-file, and process, if any), as well as the symbol file name."
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|initialize_targets
parameter_list|()
block|{
name|init_dummy_target
argument_list|()
expr_stmt|;
name|push_target
argument_list|(
operator|&
name|dummy_target
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"target"
argument_list|,
name|target_info
argument_list|,
name|targ_desc
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"files"
argument_list|,
name|target_info
argument_list|,
name|targ_desc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAINTENANCE_CMDS
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"targetdebug"
argument_list|,
name|class_maintenance
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|targetdebug
argument_list|,
literal|"Set target debugging.\n\ When non-zero, target debugging is enabled."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|STREQ
argument_list|(
name|signals
index|[
name|TARGET_SIGNAL_LAST
index|]
operator|.
name|string
argument_list|,
literal|"TARGET_SIGNAL_MAGIC"
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

