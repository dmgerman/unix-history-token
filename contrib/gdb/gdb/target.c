begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Select target systems and architectures at runtime for GDB.     Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.     Contributed by Cygnus Support.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdb_wait.h"
end_include

begin_include
include|#
directive|include
file|"dcache.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_function_decl
specifier|static
name|void
name|target_info
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|maybe_kill_then_create_inferior
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|maybe_kill_then_attach
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kill_or_be_killed
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|default_terminal_info
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|default_region_size_ok_for_hw_watchpoint
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nosymbol
parameter_list|(
name|char
modifier|*
parameter_list|,
name|CORE_ADDR
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tcomplain
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nomemory
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|struct
name|target_ops
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|return_zero
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|return_one
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|return_minus_one
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|target_ignore
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|target_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|target_ops
modifier|*
name|find_default_run_target
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nosupport_runtime
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|LONGEST
name|default_xfer_partial
parameter_list|(
name|struct
name|target_ops
modifier|*
name|ops
parameter_list|,
name|enum
name|target_object
name|object
parameter_list|,
specifier|const
name|char
modifier|*
name|annex
parameter_list|,
name|void
modifier|*
name|readbuf
parameter_list|,
specifier|const
name|void
modifier|*
name|writebuf
parameter_list|,
name|ULONGEST
name|offset
parameter_list|,
name|LONGEST
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Transfer LEN bytes between target address MEMADDR and GDB address    MYADDR.  Returns 0 for success, errno code for failure (which    includes partial transfers -- if you want a more useful response to    partial transfers, try either target_read_memory_partial or    target_write_memory_partial).  */
end_comment

begin_function_decl
specifier|static
name|int
name|target_xfer_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|write
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_dummy_target
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|debug_to_open
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|debug_to_close
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|debug_to_attach
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|debug_to_detach
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|debug_to_disconnect
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|debug_to_resume
parameter_list|(
name|ptid_t
parameter_list|,
name|int
parameter_list|,
name|enum
name|target_signal
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ptid_t
name|debug_to_wait
parameter_list|(
name|ptid_t
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|debug_to_fetch_registers
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|debug_to_store_registers
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|debug_to_prepare_to_store
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|debug_to_xfer_memory
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|struct
name|mem_attrib
modifier|*
parameter_list|,
name|struct
name|target_ops
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|debug_to_files_info
parameter_list|(
name|struct
name|target_ops
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|debug_to_insert_breakpoint
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|debug_to_remove_breakpoint
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|debug_to_can_use_hw_breakpoint
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|debug_to_insert_hw_breakpoint
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|debug_to_remove_hw_breakpoint
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|debug_to_insert_watchpoint
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|debug_to_remove_watchpoint
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|debug_to_stopped_by_watchpoint
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|CORE_ADDR
name|debug_to_stopped_data_address
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|debug_to_region_size_ok_for_hw_watchpoint
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|debug_to_terminal_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|debug_to_terminal_inferior
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|debug_to_terminal_ours_for_output
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|debug_to_terminal_save_ours
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|debug_to_terminal_ours
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|debug_to_terminal_info
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|debug_to_kill
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|debug_to_load
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|debug_to_lookup_symbol
parameter_list|(
name|char
modifier|*
parameter_list|,
name|CORE_ADDR
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|debug_to_create_inferior
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|debug_to_mourn_inferior
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|debug_to_can_run
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|debug_to_notice_signals
parameter_list|(
name|ptid_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|debug_to_thread_alive
parameter_list|(
name|ptid_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|debug_to_stop
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Pointer to array of target architecture structures; the size of the    array; the current index into the array; the allocated size of the     array.  */
end_comment

begin_decl_stmt
name|struct
name|target_ops
modifier|*
modifier|*
name|target_structs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|target_struct_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|target_struct_index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|target_struct_allocsize
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DEFAULT_ALLOCSIZE
value|10
end_define

begin_comment
comment|/* The initial current target, so that there is always a semi-valid    current target.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|target_ops
name|dummy_target
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Top of target stack.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|target_ops
modifier|*
name|target_stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The target structure we are currently using to talk to a process    or file or whatever "inferior" we have.  */
end_comment

begin_decl_stmt
name|struct
name|target_ops
name|current_target
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Command list for target.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cmd_list_element
modifier|*
name|targetlist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if we are debugging an attached outside process    rather than an inferior.  */
end_comment

begin_decl_stmt
name|int
name|attach_flag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if we want to see trace of target level stuff.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|targetdebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|setup_target_debug
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|DCACHE
modifier|*
name|target_dcache
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The user just typed 'target' without the name of a target.  */
end_comment

begin_function
specifier|static
name|void
name|target_command
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|fputs_filtered
argument_list|(
literal|"Argument required (target name).  Try `help target'\n"
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a possible target architecture to the list.  */
end_comment

begin_function
name|void
name|add_target
parameter_list|(
name|struct
name|target_ops
modifier|*
name|t
parameter_list|)
block|{
comment|/* Provide default values for all "must have" methods.  */
if|if
condition|(
name|t
operator|->
name|to_xfer_partial
operator|==
name|NULL
condition|)
name|t
operator|->
name|to_xfer_partial
operator|=
name|default_xfer_partial
expr_stmt|;
if|if
condition|(
operator|!
name|target_structs
condition|)
block|{
name|target_struct_allocsize
operator|=
name|DEFAULT_ALLOCSIZE
expr_stmt|;
name|target_structs
operator|=
operator|(
expr|struct
name|target_ops
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|target_struct_allocsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|target_structs
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|target_struct_size
operator|>=
name|target_struct_allocsize
condition|)
block|{
name|target_struct_allocsize
operator|*=
literal|2
expr_stmt|;
name|target_structs
operator|=
operator|(
expr|struct
name|target_ops
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|target_structs
argument_list|,
name|target_struct_allocsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|target_structs
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|target_structs
index|[
name|target_struct_size
operator|++
index|]
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|targetlist
operator|==
name|NULL
condition|)
name|add_prefix_cmd
argument_list|(
literal|"target"
argument_list|,
name|class_run
argument_list|,
name|target_command
argument_list|,
literal|"Connect to a target machine or process.\n\ The first argument is the type or protocol of the target machine.\n\ Remaining arguments are interpreted by the target protocol.  For more\n\ information on the arguments for a particular protocol, type\n\ `help target ' followed by the protocol name."
argument_list|,
operator|&
name|targetlist
argument_list|,
literal|"target "
argument_list|,
literal|0
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
name|t
operator|->
name|to_shortname
argument_list|,
name|no_class
argument_list|,
name|t
operator|->
name|to_open
argument_list|,
name|t
operator|->
name|to_doc
argument_list|,
operator|&
name|targetlist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stub functions */
end_comment

begin_function
name|void
name|target_ignore
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|target_load
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|dcache_invalidate
argument_list|(
name|target_dcache
argument_list|)
expr_stmt|;
call|(
modifier|*
name|current_target
operator|.
name|to_load
call|)
argument_list|(
name|arg
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|nomemory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|write
parameter_list|,
name|struct
name|target_ops
modifier|*
name|t
parameter_list|)
block|{
name|errno
operator|=
name|EIO
expr_stmt|;
comment|/* Can't read/write this location */
return|return
literal|0
return|;
comment|/* No bytes handled */
block|}
end_function

begin_function
specifier|static
name|void
name|tcomplain
parameter_list|(
name|void
parameter_list|)
block|{
name|error
argument_list|(
literal|"You can't do that when your target is `%s'"
argument_list|,
name|current_target
operator|.
name|to_shortname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|noprocess
parameter_list|(
name|void
parameter_list|)
block|{
name|error
argument_list|(
literal|"You can't do that without a process to debug."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|nosymbol
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|CORE_ADDR
modifier|*
name|addrp
parameter_list|)
block|{
return|return
literal|1
return|;
comment|/* Symbol does not exist in target env */
block|}
end_function

begin_function
specifier|static
name|void
name|nosupport_runtime
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|ptid_equal
argument_list|(
name|inferior_ptid
argument_list|,
name|null_ptid
argument_list|)
condition|)
name|noprocess
argument_list|()
expr_stmt|;
else|else
name|error
argument_list|(
literal|"No run-time support for this"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|default_terminal_info
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|printf_unfiltered
argument_list|(
literal|"No saved terminal information.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is the default target_create_inferior and target_attach function.    If the current target is executing, it asks whether to kill it off.    If this function returns without calling error(), it has killed off    the target, and the operation should be attempted.  */
end_comment

begin_function
specifier|static
name|void
name|kill_or_be_killed
parameter_list|(
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|target_has_execution
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"You are already running a program:\n"
argument_list|)
expr_stmt|;
name|target_files_info
argument_list|()
expr_stmt|;
if|if
condition|(
name|query
argument_list|(
literal|"Kill it? "
argument_list|)
condition|)
block|{
name|target_kill
argument_list|()
expr_stmt|;
if|if
condition|(
name|target_has_execution
condition|)
name|error
argument_list|(
literal|"Killing the program did not help."
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|error
argument_list|(
literal|"Program not killed."
argument_list|)
expr_stmt|;
block|}
block|}
name|tcomplain
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|maybe_kill_then_attach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|kill_or_be_killed
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
name|target_attach
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|maybe_kill_then_create_inferior
parameter_list|(
name|char
modifier|*
name|exec
parameter_list|,
name|char
modifier|*
name|args
parameter_list|,
name|char
modifier|*
modifier|*
name|env
parameter_list|)
block|{
name|kill_or_be_killed
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|target_create_inferior
argument_list|(
name|exec
argument_list|,
name|args
argument_list|,
name|env
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Go through the target stack from top to bottom, copying over zero    entries in current_target, then filling in still empty entries.  In    effect, we are doing class inheritance through the pushed target    vectors.     NOTE: cagney/2003-10-17: The problem with this inheritance, as it    is currently implemented, is that it discards any knowledge of    which target an inherited method originally belonged to.    Consequently, new new target methods should instead explicitly and    locally search the target stack for the target that can handle the    request.  */
end_comment

begin_function
specifier|static
name|void
name|update_current_target
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|target_ops
modifier|*
name|t
decl_stmt|;
comment|/* First, reset curren'ts contents.  */
name|memset
argument_list|(
operator|&
name|current_target
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|current_target
argument_list|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|INHERIT
parameter_list|(
name|FIELD
parameter_list|,
name|TARGET
parameter_list|)
define|\
value|if (!current_target.FIELD) \ 	current_target.FIELD = (TARGET)->FIELD
for|for
control|(
name|t
operator|=
name|target_stack
init|;
name|t
condition|;
name|t
operator|=
name|t
operator|->
name|beneath
control|)
block|{
name|INHERIT
argument_list|(
name|to_shortname
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_longname
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_doc
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_open
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_close
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_attach
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_post_attach
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_detach
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_disconnect
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_resume
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_wait
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_post_wait
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_fetch_registers
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_store_registers
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_prepare_to_store
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_xfer_memory
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_files_info
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_insert_breakpoint
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_remove_breakpoint
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_can_use_hw_breakpoint
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_insert_hw_breakpoint
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_remove_hw_breakpoint
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_insert_watchpoint
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_remove_watchpoint
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_stopped_data_address
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_stopped_by_watchpoint
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_have_continuable_watchpoint
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_region_size_ok_for_hw_watchpoint
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_terminal_init
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_terminal_inferior
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_terminal_ours_for_output
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_terminal_ours
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_terminal_save_ours
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_terminal_info
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_kill
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_load
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_lookup_symbol
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_create_inferior
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_post_startup_inferior
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_acknowledge_created_inferior
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_insert_fork_catchpoint
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_remove_fork_catchpoint
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_insert_vfork_catchpoint
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_remove_vfork_catchpoint
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_follow_fork
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_insert_exec_catchpoint
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_remove_exec_catchpoint
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_reported_exec_events_per_exec_call
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_has_exited
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_mourn_inferior
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_can_run
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_notice_signals
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_thread_alive
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_find_new_threads
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_pid_to_str
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_extra_thread_info
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_stop
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* Do not inherit to_xfer_partial.  */
name|INHERIT
argument_list|(
name|to_rcmd
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_enable_exception_callback
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_get_current_exception_event
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_pid_to_exec_file
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_stratum
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_has_all_memory
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_has_memory
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_has_stack
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_has_registers
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_has_execution
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_has_thread_control
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_sections
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_sections_end
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_can_async_p
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_is_async_p
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_async
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_async_mask_value
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_find_memory_regions
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_make_corefile_notes
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_get_thread_local_address
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|INHERIT
argument_list|(
name|to_magic
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
undef|#
directive|undef
name|INHERIT
comment|/* Clean up a target struct so it no longer has any zero pointers in      it.  Some entries are defaulted to a method that print an error,      others are hard-wired to a standard recursive default.  */
define|#
directive|define
name|de_fault
parameter_list|(
name|field
parameter_list|,
name|value
parameter_list|)
define|\
value|if (!current_target.field)               \     current_target.field = value
name|de_fault
argument_list|(
name|to_open
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|char
operator|*
argument_list|,
name|int
argument_list|)
operator|)
name|tcomplain
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_close
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
argument_list|)
operator|)
name|target_ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_attach
argument_list|,
name|maybe_kill_then_attach
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_post_attach
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
argument_list|)
operator|)
name|target_ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_detach
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|char
operator|*
argument_list|,
name|int
argument_list|)
operator|)
name|target_ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_disconnect
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|char
operator|*
argument_list|,
name|int
argument_list|)
operator|)
name|tcomplain
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_resume
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|ptid_t
argument_list|,
name|int
argument_list|,
expr|enum
name|target_signal
argument_list|)
operator|)
name|noprocess
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_wait
argument_list|,
operator|(
name|ptid_t
argument_list|(
operator|*
argument_list|)
argument_list|(
name|ptid_t
argument_list|,
expr|struct
name|target_waitstatus
operator|*
argument_list|)
operator|)
name|noprocess
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_post_wait
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|ptid_t
argument_list|,
name|int
argument_list|)
operator|)
name|target_ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_fetch_registers
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
argument_list|)
operator|)
name|target_ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_store_registers
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
argument_list|)
operator|)
name|noprocess
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_prepare_to_store
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
argument_list|)
operator|)
name|noprocess
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_xfer_memory
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|CORE_ADDR
argument_list|,
name|char
operator|*
argument_list|,
name|int
argument_list|,
name|int
argument_list|,
expr|struct
name|mem_attrib
operator|*
argument_list|,
expr|struct
name|target_ops
operator|*
argument_list|)
operator|)
name|nomemory
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_files_info
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
expr|struct
name|target_ops
operator|*
argument_list|)
operator|)
name|target_ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_insert_breakpoint
argument_list|,
name|memory_insert_breakpoint
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_remove_breakpoint
argument_list|,
name|memory_remove_breakpoint
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_can_use_hw_breakpoint
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
operator|)
name|return_zero
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_insert_hw_breakpoint
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|CORE_ADDR
argument_list|,
name|char
operator|*
argument_list|)
operator|)
name|return_minus_one
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_remove_hw_breakpoint
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|CORE_ADDR
argument_list|,
name|char
operator|*
argument_list|)
operator|)
name|return_minus_one
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_insert_watchpoint
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|CORE_ADDR
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
operator|)
name|return_minus_one
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_remove_watchpoint
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|CORE_ADDR
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
operator|)
name|return_minus_one
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_stopped_by_watchpoint
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
argument_list|)
operator|)
name|return_zero
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_stopped_data_address
argument_list|,
operator|(
name|CORE_ADDR
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
argument_list|)
operator|)
name|return_zero
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_region_size_ok_for_hw_watchpoint
argument_list|,
name|default_region_size_ok_for_hw_watchpoint
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_terminal_init
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
argument_list|)
operator|)
name|target_ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_terminal_inferior
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
argument_list|)
operator|)
name|target_ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_terminal_ours_for_output
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
argument_list|)
operator|)
name|target_ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_terminal_ours
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
argument_list|)
operator|)
name|target_ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_terminal_save_ours
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
argument_list|)
operator|)
name|target_ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_terminal_info
argument_list|,
name|default_terminal_info
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_kill
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
argument_list|)
operator|)
name|noprocess
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_load
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|char
operator|*
argument_list|,
name|int
argument_list|)
operator|)
name|tcomplain
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_lookup_symbol
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|char
operator|*
argument_list|,
name|CORE_ADDR
operator|*
argument_list|)
operator|)
name|nosymbol
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_create_inferior
argument_list|,
name|maybe_kill_then_create_inferior
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_post_startup_inferior
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|ptid_t
argument_list|)
operator|)
name|target_ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_acknowledge_created_inferior
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
argument_list|)
operator|)
name|target_ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_insert_fork_catchpoint
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
argument_list|)
operator|)
name|tcomplain
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_remove_fork_catchpoint
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
argument_list|)
operator|)
name|tcomplain
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_insert_vfork_catchpoint
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
argument_list|)
operator|)
name|tcomplain
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_remove_vfork_catchpoint
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
argument_list|)
operator|)
name|tcomplain
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_follow_fork
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
argument_list|)
operator|)
name|target_ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_insert_exec_catchpoint
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
argument_list|)
operator|)
name|tcomplain
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_remove_exec_catchpoint
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
argument_list|)
operator|)
name|tcomplain
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_reported_exec_events_per_exec_call
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
argument_list|)
operator|)
name|return_one
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_has_exited
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|int
argument_list|,
name|int
argument_list|,
name|int
operator|*
argument_list|)
operator|)
name|return_zero
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_mourn_inferior
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
argument_list|)
operator|)
name|noprocess
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_can_run
argument_list|,
name|return_zero
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_notice_signals
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|ptid_t
argument_list|)
operator|)
name|target_ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_thread_alive
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|ptid_t
argument_list|)
operator|)
name|return_zero
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_find_new_threads
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
argument_list|)
operator|)
name|target_ignore
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_extra_thread_info
argument_list|,
operator|(
name|char
operator|*
call|(
modifier|*
call|)
argument_list|(
expr|struct
name|thread_info
operator|*
argument_list|)
operator|)
name|return_zero
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_stop
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
argument_list|)
operator|)
name|target_ignore
argument_list|)
expr_stmt|;
name|current_target
operator|.
name|to_xfer_partial
operator|=
name|default_xfer_partial
expr_stmt|;
name|de_fault
argument_list|(
name|to_rcmd
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|char
operator|*
argument_list|,
expr|struct
name|ui_file
operator|*
argument_list|)
operator|)
name|tcomplain
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_enable_exception_callback
argument_list|,
operator|(
expr|struct
name|symtab_and_line
operator|*
call|(
modifier|*
call|)
argument_list|(
expr|enum
name|exception_event_kind
argument_list|,
name|int
argument_list|)
operator|)
name|nosupport_runtime
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_get_current_exception_event
argument_list|,
operator|(
expr|struct
name|exception_event_record
operator|*
call|(
modifier|*
call|)
argument_list|(
name|void
argument_list|)
operator|)
name|nosupport_runtime
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_pid_to_exec_file
argument_list|,
operator|(
name|char
operator|*
call|(
modifier|*
call|)
argument_list|(
name|int
argument_list|)
operator|)
name|return_zero
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_can_async_p
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
argument_list|)
operator|)
name|return_zero
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_is_async_p
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
argument_list|)
operator|)
name|return_zero
argument_list|)
expr_stmt|;
name|de_fault
argument_list|(
name|to_async
argument_list|,
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
expr|enum
name|inferior_event_type
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|void
operator|*
argument_list|)
operator|)
name|tcomplain
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|de_fault
comment|/* Finally, position the target-stack beneath the squashed      "current_target".  That way code looking for a non-inherited      target method can quickly and simply find it.  */
name|current_target
operator|.
name|beneath
operator|=
name|target_stack
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Push a new target type into the stack of the existing target accessors,    possibly superseding some of the existing accessors.     Result is zero if the pushed target ended up on top of the stack,    nonzero if at least one target is on top of it.     Rather than allow an empty stack, we always have the dummy target at    the bottom stratum, so we can call the function vectors without    checking them.  */
end_comment

begin_function
name|int
name|push_target
parameter_list|(
name|struct
name|target_ops
modifier|*
name|t
parameter_list|)
block|{
name|struct
name|target_ops
modifier|*
modifier|*
name|cur
decl_stmt|;
comment|/* Check magic number.  If wrong, it probably means someone changed      the struct definition, but not all the places that initialize one.  */
if|if
condition|(
name|t
operator|->
name|to_magic
operator|!=
name|OPS_MAGIC
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Magic number of %s target struct wrong\n"
argument_list|,
name|t
operator|->
name|to_shortname
argument_list|)
expr_stmt|;
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"failed internal consistency check"
argument_list|)
expr_stmt|;
block|}
comment|/* Find the proper stratum to install this target in.  */
for|for
control|(
name|cur
operator|=
operator|&
name|target_stack
init|;
operator|(
operator|*
name|cur
operator|)
operator|!=
name|NULL
condition|;
name|cur
operator|=
operator|&
operator|(
operator|*
name|cur
operator|)
operator|->
name|beneath
control|)
block|{
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|t
operator|->
name|to_stratum
argument_list|)
operator|>=
call|(
name|int
call|)
argument_list|(
operator|*
name|cur
argument_list|)
operator|->
name|to_stratum
condition|)
break|break;
block|}
comment|/* If there's already targets at this stratum, remove them.  */
comment|/* FIXME: cagney/2003-10-15: I think this should be poping all      targets to CUR, and not just those at this stratum level.  */
while|while
condition|(
operator|(
operator|*
name|cur
operator|)
operator|!=
name|NULL
operator|&&
name|t
operator|->
name|to_stratum
operator|==
operator|(
operator|*
name|cur
operator|)
operator|->
name|to_stratum
condition|)
block|{
comment|/* There's already something at this stratum level.  Close it,          and un-hook it from the stack.  */
name|struct
name|target_ops
modifier|*
name|tmp
init|=
operator|(
operator|*
name|cur
operator|)
decl_stmt|;
operator|(
operator|*
name|cur
operator|)
operator|=
operator|(
operator|*
name|cur
operator|)
operator|->
name|beneath
expr_stmt|;
name|tmp
operator|->
name|beneath
operator|=
name|NULL
expr_stmt|;
name|target_close
argument_list|(
name|tmp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* We have removed all targets in our stratum, now add the new one.  */
name|t
operator|->
name|beneath
operator|=
operator|(
operator|*
name|cur
operator|)
expr_stmt|;
operator|(
operator|*
name|cur
operator|)
operator|=
name|t
expr_stmt|;
name|update_current_target
argument_list|()
expr_stmt|;
if|if
condition|(
name|targetdebug
condition|)
name|setup_target_debug
argument_list|()
expr_stmt|;
comment|/* Not on top?  */
return|return
operator|(
name|t
operator|!=
name|target_stack
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Remove a target_ops vector from the stack, wherever it may be.     Return how many times it was removed (0 or 1).  */
end_comment

begin_function
name|int
name|unpush_target
parameter_list|(
name|struct
name|target_ops
modifier|*
name|t
parameter_list|)
block|{
name|struct
name|target_ops
modifier|*
modifier|*
name|cur
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|tmp
decl_stmt|;
comment|/* Look for the specified target.  Note that we assume that a target      can only occur once in the target stack. */
for|for
control|(
name|cur
operator|=
operator|&
name|target_stack
init|;
operator|(
operator|*
name|cur
operator|)
operator|!=
name|NULL
condition|;
name|cur
operator|=
operator|&
operator|(
operator|*
name|cur
operator|)
operator|->
name|beneath
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|cur
operator|)
operator|==
name|t
condition|)
break|break;
block|}
if|if
condition|(
operator|(
operator|*
name|cur
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* Didn't find target_ops, quit now */
comment|/* NOTE: cagney/2003-12-06: In '94 the close call was made      unconditional by moving it to before the above check that the      target was in the target stack (something about "Change the way      pushing and popping of targets work to support target overlays      and inheritance").  This doesn't make much sense - only open      targets should be closed.  */
name|target_close
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Unchain the target */
name|tmp
operator|=
operator|(
operator|*
name|cur
operator|)
expr_stmt|;
operator|(
operator|*
name|cur
operator|)
operator|=
operator|(
operator|*
name|cur
operator|)
operator|->
name|beneath
expr_stmt|;
name|tmp
operator|->
name|beneath
operator|=
name|NULL
expr_stmt|;
name|update_current_target
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|pop_target
parameter_list|(
name|void
parameter_list|)
block|{
name|target_close
argument_list|(
operator|&
name|current_target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Let it clean up */
if|if
condition|(
name|unpush_target
argument_list|(
name|target_stack
argument_list|)
operator|==
literal|1
condition|)
return|return;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"pop_target couldn't find target %s\n"
argument_list|,
name|current_target
operator|.
name|to_shortname
argument_list|)
expr_stmt|;
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"failed internal consistency check"
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|MIN
end_undef

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|(((A)<= (B)) ? (A) : (B))
end_define

begin_comment
comment|/* target_read_string -- read a null terminated string, up to LEN bytes,    from MEMADDR in target.  Set *ERRNOP to the errno code, or 0 if successful.    Set *STRING to a pointer to malloc'd memory containing the data; the caller    is responsible for freeing it.  Return the number of bytes successfully    read.  */
end_comment

begin_function
name|int
name|target_read_string
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
modifier|*
name|string
parameter_list|,
name|int
name|len
parameter_list|,
name|int
modifier|*
name|errnop
parameter_list|)
block|{
name|int
name|tlen
decl_stmt|,
name|origlen
decl_stmt|,
name|offset
decl_stmt|,
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|int
name|errcode
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|int
name|buffer_allocated
decl_stmt|;
name|char
modifier|*
name|bufptr
decl_stmt|;
name|unsigned
name|int
name|nbytes_read
init|=
literal|0
decl_stmt|;
comment|/* Small for testing.  */
name|buffer_allocated
operator|=
literal|4
expr_stmt|;
name|buffer
operator|=
name|xmalloc
argument_list|(
name|buffer_allocated
argument_list|)
expr_stmt|;
name|bufptr
operator|=
name|buffer
expr_stmt|;
name|origlen
operator|=
name|len
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|tlen
operator|=
name|MIN
argument_list|(
name|len
argument_list|,
literal|4
operator|-
operator|(
name|memaddr
operator|&
literal|3
operator|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|memaddr
operator|&
literal|3
expr_stmt|;
name|errcode
operator|=
name|target_xfer_memory
argument_list|(
name|memaddr
operator|&
operator|~
literal|3
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
operator|!=
literal|0
condition|)
block|{
comment|/* The transfer request might have crossed the boundary to an 	     unallocated region of memory. Retry the transfer, requesting 	     a single byte.  */
name|tlen
operator|=
literal|1
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|errcode
operator|=
name|target_xfer_memory
argument_list|(
name|memaddr
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|bufptr
operator|-
name|buffer
operator|+
name|tlen
operator|>
name|buffer_allocated
condition|)
block|{
name|unsigned
name|int
name|bytes
decl_stmt|;
name|bytes
operator|=
name|bufptr
operator|-
name|buffer
expr_stmt|;
name|buffer_allocated
operator|*=
literal|2
expr_stmt|;
name|buffer
operator|=
name|xrealloc
argument_list|(
name|buffer
argument_list|,
name|buffer_allocated
argument_list|)
expr_stmt|;
name|bufptr
operator|=
name|buffer
operator|+
name|bytes
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tlen
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|bufptr
operator|++
operator|=
name|buf
index|[
name|i
operator|+
name|offset
index|]
expr_stmt|;
if|if
condition|(
name|buf
index|[
name|i
operator|+
name|offset
index|]
operator|==
literal|'\000'
condition|)
block|{
name|nbytes_read
operator|+=
name|i
operator|+
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|memaddr
operator|+=
name|tlen
expr_stmt|;
name|len
operator|-=
name|tlen
expr_stmt|;
name|nbytes_read
operator|+=
name|tlen
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
name|errnop
operator|!=
name|NULL
condition|)
operator|*
name|errnop
operator|=
name|errcode
expr_stmt|;
if|if
condition|(
name|string
operator|!=
name|NULL
condition|)
operator|*
name|string
operator|=
name|buffer
expr_stmt|;
return|return
name|nbytes_read
return|;
block|}
end_function

begin_comment
comment|/* Find a section containing ADDR.  */
end_comment

begin_function
name|struct
name|section_table
modifier|*
name|target_section_by_addr
parameter_list|(
name|struct
name|target_ops
modifier|*
name|target
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|)
block|{
name|struct
name|section_table
modifier|*
name|secp
decl_stmt|;
for|for
control|(
name|secp
operator|=
name|target
operator|->
name|to_sections
init|;
name|secp
operator|<
name|target
operator|->
name|to_sections_end
condition|;
name|secp
operator|++
control|)
block|{
if|if
condition|(
name|addr
operator|>=
name|secp
operator|->
name|addr
operator|&&
name|addr
operator|<
name|secp
operator|->
name|endaddr
condition|)
return|return
name|secp
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Read LEN bytes of target memory at address MEMADDR, placing the results in    GDB's memory at MYADDR.  Returns either 0 for success or an errno value    if any error occurs.     If an error occurs, no guarantee is made about the contents of the data at    MYADDR.  In particular, the caller should not depend upon partial reads    filling the buffer with good data.  There is no way for the caller to know    how much good data might have been transfered anyway.  Callers that can    deal with partial reads should call target_read_memory_partial. */
end_comment

begin_function
name|int
name|target_read_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
return|return
name|target_xfer_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|target_write_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
return|return
name|target_xfer_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|trust_readonly
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Move memory to or from the targets.  The top target gets priority;    if it cannot handle it, it is offered to the next one down, etc.     Result is -1 on error, or the number of bytes transfered.  */
end_comment

begin_function
name|int
name|do_xfer_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|write
parameter_list|,
name|struct
name|mem_attrib
modifier|*
name|attrib
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|t
decl_stmt|;
comment|/* Zero length requests are ok and require no work.  */
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* to_xfer_memory is not guaranteed to set errno, even when it returns      0.  */
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|write
operator|&&
name|trust_readonly
condition|)
block|{
name|struct
name|section_table
modifier|*
name|secp
decl_stmt|;
comment|/* User-settable option, "trust-readonly-sections".  If true,          then memory from any SEC_READONLY bfd section may be read          directly from the bfd file.  */
name|secp
operator|=
name|target_section_by_addr
argument_list|(
operator|&
name|current_target
argument_list|,
name|memaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|secp
operator|!=
name|NULL
operator|&&
operator|(
name|bfd_get_section_flags
argument_list|(
name|secp
operator|->
name|bfd
argument_list|,
name|secp
operator|->
name|the_bfd_section
argument_list|)
operator|&
name|SEC_READONLY
operator|)
condition|)
return|return
name|xfer_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|attrib
argument_list|,
operator|&
name|current_target
argument_list|)
return|;
block|}
comment|/* The quick case is that the top target can handle the transfer.  */
name|res
operator|=
name|current_target
operator|.
name|to_xfer_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|,
name|write
argument_list|,
name|attrib
argument_list|,
operator|&
name|current_target
argument_list|)
expr_stmt|;
comment|/* If res<= 0 then we call it again in the loop.  Ah well. */
if|if
condition|(
name|res
operator|<=
literal|0
condition|)
block|{
for|for
control|(
name|t
operator|=
name|target_stack
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|beneath
control|)
block|{
if|if
condition|(
operator|!
name|t
operator|->
name|to_has_memory
condition|)
continue|continue;
name|res
operator|=
name|t
operator|->
name|to_xfer_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|,
name|write
argument_list|,
name|attrib
argument_list|,
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|>
literal|0
condition|)
break|break;
comment|/* Handled all or part of xfer */
if|if
condition|(
name|t
operator|->
name|to_has_all_memory
condition|)
break|break;
block|}
if|if
condition|(
name|res
operator|<=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
block|}
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/* Perform a memory transfer.  Iterate until the entire region has    been transfered.     Result is 0 or errno value.  */
end_comment

begin_function
specifier|static
name|int
name|target_xfer_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|write
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|int
name|reg_len
decl_stmt|;
name|struct
name|mem_region
modifier|*
name|region
decl_stmt|;
comment|/* Zero length requests are ok and require no work.  */
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|region
operator|=
name|lookup_mem_region
argument_list|(
name|memaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|memaddr
operator|+
name|len
operator|<
name|region
operator|->
name|hi
condition|)
name|reg_len
operator|=
name|len
expr_stmt|;
else|else
name|reg_len
operator|=
name|region
operator|->
name|hi
operator|-
name|memaddr
expr_stmt|;
switch|switch
condition|(
name|region
operator|->
name|attrib
operator|.
name|mode
condition|)
block|{
case|case
name|MEM_RO
case|:
if|if
condition|(
name|write
condition|)
return|return
name|EIO
return|;
break|break;
case|case
name|MEM_WO
case|:
if|if
condition|(
operator|!
name|write
condition|)
return|return
name|EIO
return|;
break|break;
block|}
while|while
condition|(
name|reg_len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|region
operator|->
name|attrib
operator|.
name|cache
condition|)
name|res
operator|=
name|dcache_xfer_memory
argument_list|(
name|target_dcache
argument_list|,
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|reg_len
argument_list|,
name|write
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|do_xfer_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|reg_len
argument_list|,
name|write
argument_list|,
operator|&
name|region
operator|->
name|attrib
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|<=
literal|0
condition|)
block|{
comment|/* If this address is for nonexistent memory, read zeros 		 if reading, or do nothing if writing.  Return 		 error. */
if|if
condition|(
operator|!
name|write
condition|)
name|memset
argument_list|(
name|myaddr
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
literal|0
condition|)
return|return
name|EIO
return|;
else|else
return|return
name|errno
return|;
block|}
name|memaddr
operator|+=
name|res
expr_stmt|;
name|myaddr
operator|+=
name|res
expr_stmt|;
name|len
operator|-=
name|res
expr_stmt|;
name|reg_len
operator|-=
name|res
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
comment|/* We managed to cover it all somehow. */
block|}
end_function

begin_comment
comment|/* Perform a partial memory transfer.     Result is -1 on error, or the number of bytes transfered.  */
end_comment

begin_function
specifier|static
name|int
name|target_xfer_memory_partial
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|write_p
parameter_list|,
name|int
modifier|*
name|err
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
name|int
name|reg_len
decl_stmt|;
name|struct
name|mem_region
modifier|*
name|region
decl_stmt|;
comment|/* Zero length requests are ok and require no work.  */
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
operator|*
name|err
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|region
operator|=
name|lookup_mem_region
argument_list|(
name|memaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|memaddr
operator|+
name|len
operator|<
name|region
operator|->
name|hi
condition|)
name|reg_len
operator|=
name|len
expr_stmt|;
else|else
name|reg_len
operator|=
name|region
operator|->
name|hi
operator|-
name|memaddr
expr_stmt|;
switch|switch
condition|(
name|region
operator|->
name|attrib
operator|.
name|mode
condition|)
block|{
case|case
name|MEM_RO
case|:
if|if
condition|(
name|write_p
condition|)
block|{
operator|*
name|err
operator|=
name|EIO
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
break|break;
case|case
name|MEM_WO
case|:
if|if
condition|(
name|write_p
condition|)
block|{
operator|*
name|err
operator|=
name|EIO
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
break|break;
block|}
if|if
condition|(
name|region
operator|->
name|attrib
operator|.
name|cache
condition|)
name|res
operator|=
name|dcache_xfer_memory
argument_list|(
name|target_dcache
argument_list|,
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|reg_len
argument_list|,
name|write_p
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|do_xfer_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|reg_len
argument_list|,
name|write_p
argument_list|,
operator|&
name|region
operator|->
name|attrib
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
operator|*
name|err
operator|=
name|errno
expr_stmt|;
else|else
operator|*
name|err
operator|=
name|EIO
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
operator|*
name|err
operator|=
literal|0
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
name|int
name|target_read_memory_partial
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|,
name|int
modifier|*
name|err
parameter_list|)
block|{
return|return
name|target_xfer_memory_partial
argument_list|(
name|memaddr
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|err
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|target_write_memory_partial
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|,
name|int
modifier|*
name|err
parameter_list|)
block|{
return|return
name|target_xfer_memory_partial
argument_list|(
name|memaddr
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
literal|1
argument_list|,
name|err
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* More generic transfers.  */
end_comment

begin_function
specifier|static
name|LONGEST
name|default_xfer_partial
parameter_list|(
name|struct
name|target_ops
modifier|*
name|ops
parameter_list|,
name|enum
name|target_object
name|object
parameter_list|,
specifier|const
name|char
modifier|*
name|annex
parameter_list|,
name|void
modifier|*
name|readbuf
parameter_list|,
specifier|const
name|void
modifier|*
name|writebuf
parameter_list|,
name|ULONGEST
name|offset
parameter_list|,
name|LONGEST
name|len
parameter_list|)
block|{
if|if
condition|(
name|object
operator|==
name|TARGET_OBJECT_MEMORY
operator|&&
name|ops
operator|->
name|to_xfer_memory
operator|!=
name|NULL
condition|)
comment|/* If available, fall back to the target's "to_xfer_memory"        method.  */
block|{
name|int
name|xfered
init|=
operator|-
literal|1
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|writebuf
operator|!=
name|NULL
condition|)
block|{
name|void
modifier|*
name|buffer
init|=
name|xmalloc
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|cleanup
init|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|buffer
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|writebuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|xfered
operator|=
name|ops
operator|->
name|to_xfer_memory
argument_list|(
name|offset
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|,
literal|1
comment|/*write*/
argument_list|,
name|NULL
argument_list|,
name|ops
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|cleanup
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|readbuf
operator|!=
name|NULL
condition|)
name|xfered
operator|=
name|ops
operator|->
name|to_xfer_memory
argument_list|(
name|offset
argument_list|,
name|readbuf
argument_list|,
name|len
argument_list|,
literal|0
comment|/*read*/
argument_list|,
name|NULL
argument_list|,
name|ops
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfered
operator|>
literal|0
condition|)
return|return
name|xfered
return|;
elseif|else
if|if
condition|(
name|xfered
operator|==
literal|0
operator|&&
name|errno
operator|==
literal|0
condition|)
comment|/* "to_xfer_memory" uses 0, cross checked against ERRNO as one            indication of an error.  */
return|return
literal|0
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|ops
operator|->
name|beneath
operator|!=
name|NULL
condition|)
return|return
name|ops
operator|->
name|beneath
operator|->
name|to_xfer_partial
argument_list|(
name|ops
operator|->
name|beneath
argument_list|,
name|object
argument_list|,
name|annex
argument_list|,
name|readbuf
argument_list|,
name|writebuf
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Target vector read/write partial wrapper functions.     NOTE: cagney/2003-10-21: I wonder if having "to_xfer_partial    (inbuf, outbuf)", instead of separate read/write methods, make life    easier.  */
end_comment

begin_function
name|LONGEST
name|target_read_partial
parameter_list|(
name|struct
name|target_ops
modifier|*
name|ops
parameter_list|,
name|enum
name|target_object
name|object
parameter_list|,
specifier|const
name|char
modifier|*
name|annex
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|ULONGEST
name|offset
parameter_list|,
name|LONGEST
name|len
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|ops
operator|->
name|to_xfer_partial
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
name|ops
operator|->
name|to_xfer_partial
argument_list|(
name|ops
argument_list|,
name|object
argument_list|,
name|annex
argument_list|,
name|buf
argument_list|,
name|NULL
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
name|LONGEST
name|target_write_partial
parameter_list|(
name|struct
name|target_ops
modifier|*
name|ops
parameter_list|,
name|enum
name|target_object
name|object
parameter_list|,
specifier|const
name|char
modifier|*
name|annex
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|ULONGEST
name|offset
parameter_list|,
name|LONGEST
name|len
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|ops
operator|->
name|to_xfer_partial
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
name|ops
operator|->
name|to_xfer_partial
argument_list|(
name|ops
argument_list|,
name|object
argument_list|,
name|annex
argument_list|,
name|NULL
argument_list|,
name|buf
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Wrappers to perform the full transfer.  */
end_comment

begin_function
name|LONGEST
name|target_read
parameter_list|(
name|struct
name|target_ops
modifier|*
name|ops
parameter_list|,
name|enum
name|target_object
name|object
parameter_list|,
specifier|const
name|char
modifier|*
name|annex
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|ULONGEST
name|offset
parameter_list|,
name|LONGEST
name|len
parameter_list|)
block|{
name|LONGEST
name|xfered
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|xfered
operator|<
name|len
condition|)
block|{
name|LONGEST
name|xfer
init|=
name|target_read_partial
argument_list|(
name|ops
argument_list|,
name|object
argument_list|,
name|annex
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
operator|+
name|xfered
argument_list|,
name|offset
operator|+
name|xfered
argument_list|,
name|len
operator|-
name|xfered
argument_list|)
decl_stmt|;
comment|/* Call an observer, notifying them of the xfer progress?  */
if|if
condition|(
name|xfer
operator|<=
literal|0
condition|)
comment|/* Call memory_error?  */
return|return
operator|-
literal|1
return|;
name|xfered
operator|+=
name|xfer
expr_stmt|;
name|QUIT
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_function
name|LONGEST
name|target_write
parameter_list|(
name|struct
name|target_ops
modifier|*
name|ops
parameter_list|,
name|enum
name|target_object
name|object
parameter_list|,
specifier|const
name|char
modifier|*
name|annex
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|ULONGEST
name|offset
parameter_list|,
name|LONGEST
name|len
parameter_list|)
block|{
name|LONGEST
name|xfered
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|xfered
operator|<
name|len
condition|)
block|{
name|LONGEST
name|xfer
init|=
name|target_write_partial
argument_list|(
name|ops
argument_list|,
name|object
argument_list|,
name|annex
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|buf
operator|+
name|xfered
argument_list|,
name|offset
operator|+
name|xfered
argument_list|,
name|len
operator|-
name|xfered
argument_list|)
decl_stmt|;
comment|/* Call an observer, notifying them of the xfer progress?  */
if|if
condition|(
name|xfer
operator|<=
literal|0
condition|)
comment|/* Call memory_error?  */
return|return
operator|-
literal|1
return|;
name|xfered
operator|+=
name|xfer
expr_stmt|;
name|QUIT
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* Memory transfer methods.  */
end_comment

begin_function
name|void
name|get_target_memory
parameter_list|(
name|struct
name|target_ops
modifier|*
name|ops
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|LONGEST
name|len
parameter_list|)
block|{
if|if
condition|(
name|target_read
argument_list|(
name|ops
argument_list|,
name|TARGET_OBJECT_MEMORY
argument_list|,
name|NULL
argument_list|,
name|buf
argument_list|,
name|addr
argument_list|,
name|len
argument_list|)
operator|!=
name|len
condition|)
name|memory_error
argument_list|(
name|EIO
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ULONGEST
name|get_target_memory_unsigned
parameter_list|(
name|struct
name|target_ops
modifier|*
name|ops
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
name|ULONGEST
argument_list|)
index|]
decl_stmt|;
name|gdb_assert
argument_list|(
name|len
operator|<=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|get_target_memory
argument_list|(
name|ops
argument_list|,
name|addr
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|target_info
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|target_ops
modifier|*
name|t
decl_stmt|;
name|int
name|has_all_mem
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|symfile_objfile
operator|!=
name|NULL
condition|)
name|printf_unfiltered
argument_list|(
literal|"Symbols from \"%s\".\n"
argument_list|,
name|symfile_objfile
operator|->
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FILES_INFO_HOOK
if|if
condition|(
name|FILES_INFO_HOOK
argument_list|()
condition|)
return|return;
endif|#
directive|endif
for|for
control|(
name|t
operator|=
name|target_stack
init|;
name|t
operator|!=
name|NULL
condition|;
name|t
operator|=
name|t
operator|->
name|beneath
control|)
block|{
if|if
condition|(
operator|!
name|t
operator|->
name|to_has_memory
condition|)
continue|continue;
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|t
operator|->
name|to_stratum
argument_list|)
operator|<=
operator|(
name|int
operator|)
name|dummy_stratum
condition|)
continue|continue;
if|if
condition|(
name|has_all_mem
condition|)
name|printf_unfiltered
argument_list|(
literal|"\tWhile running this, GDB does not access memory from...\n"
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%s:\n"
argument_list|,
name|t
operator|->
name|to_longname
argument_list|)
expr_stmt|;
call|(
name|t
operator|->
name|to_files_info
call|)
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|has_all_mem
operator|=
name|t
operator|->
name|to_has_all_memory
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This is to be called by the open routine before it does    anything.  */
end_comment

begin_function
name|void
name|target_preopen
parameter_list|(
name|int
name|from_tty
parameter_list|)
block|{
name|dont_repeat
argument_list|()
expr_stmt|;
if|if
condition|(
name|target_has_execution
condition|)
block|{
if|if
condition|(
operator|!
name|from_tty
operator|||
name|query
argument_list|(
literal|"A program is being debugged already.  Kill it? "
argument_list|)
condition|)
name|target_kill
argument_list|()
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Program not killed."
argument_list|)
expr_stmt|;
block|}
comment|/* Calling target_kill may remove the target from the stack.  But if      it doesn't (which seems like a win for UDI), remove it now.  */
if|if
condition|(
name|target_has_execution
condition|)
name|pop_target
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Detach a target after doing deferred register stores.  */
end_comment

begin_function
name|void
name|target_detach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
comment|/* Handle any optimized stores to the inferior.  */
ifdef|#
directive|ifdef
name|DO_DEFERRED_STORES
name|DO_DEFERRED_STORES
expr_stmt|;
endif|#
directive|endif
call|(
name|current_target
operator|.
name|to_detach
call|)
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|target_disconnect
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
comment|/* Handle any optimized stores to the inferior.  */
ifdef|#
directive|ifdef
name|DO_DEFERRED_STORES
name|DO_DEFERRED_STORES
expr_stmt|;
endif|#
directive|endif
call|(
name|current_target
operator|.
name|to_disconnect
call|)
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|target_link
parameter_list|(
name|char
modifier|*
name|modname
parameter_list|,
name|CORE_ADDR
modifier|*
name|t_reloc
parameter_list|)
block|{
if|if
condition|(
name|DEPRECATED_STREQ
argument_list|(
name|current_target
operator|.
name|to_shortname
argument_list|,
literal|"rombug"
argument_list|)
condition|)
block|{
call|(
name|current_target
operator|.
name|to_lookup_symbol
call|)
argument_list|(
name|modname
argument_list|,
name|t_reloc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|t_reloc
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Unable to link to %s and get relocation in rombug"
argument_list|,
name|modname
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|t_reloc
operator|=
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|int
name|target_async_mask
parameter_list|(
name|int
name|mask
parameter_list|)
block|{
name|int
name|saved_async_masked_status
init|=
name|target_async_mask_value
decl_stmt|;
name|target_async_mask_value
operator|=
name|mask
expr_stmt|;
return|return
name|saved_async_masked_status
return|;
block|}
end_function

begin_comment
comment|/* Look through the list of possible targets for a target that can    execute a run or attach command without any other data.  This is    used to locate the default process stratum.     Result is always valid (error() is called for errors).  */
end_comment

begin_function
specifier|static
name|struct
name|target_ops
modifier|*
name|find_default_run_target
parameter_list|(
name|char
modifier|*
name|do_mesg
parameter_list|)
block|{
name|struct
name|target_ops
modifier|*
modifier|*
name|t
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|runable
init|=
name|NULL
decl_stmt|;
name|int
name|count
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
name|target_structs
init|;
name|t
operator|<
name|target_structs
operator|+
name|target_struct_size
condition|;
operator|++
name|t
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|t
operator|)
operator|->
name|to_can_run
operator|&&
name|target_can_run
argument_list|(
operator|*
name|t
argument_list|)
condition|)
block|{
name|runable
operator|=
operator|*
name|t
expr_stmt|;
operator|++
name|count
expr_stmt|;
block|}
block|}
if|if
condition|(
name|count
operator|!=
literal|1
condition|)
name|error
argument_list|(
literal|"Don't know how to %s.  Try \"help target\"."
argument_list|,
name|do_mesg
argument_list|)
expr_stmt|;
return|return
name|runable
return|;
block|}
end_function

begin_function
name|void
name|find_default_attach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|target_ops
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|find_default_run_target
argument_list|(
literal|"attach"
argument_list|)
expr_stmt|;
call|(
name|t
operator|->
name|to_attach
call|)
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|find_default_create_inferior
parameter_list|(
name|char
modifier|*
name|exec_file
parameter_list|,
name|char
modifier|*
name|allargs
parameter_list|,
name|char
modifier|*
modifier|*
name|env
parameter_list|)
block|{
name|struct
name|target_ops
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|find_default_run_target
argument_list|(
literal|"run"
argument_list|)
expr_stmt|;
call|(
name|t
operator|->
name|to_create_inferior
call|)
argument_list|(
name|exec_file
argument_list|,
name|allargs
argument_list|,
name|env
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|default_region_size_ok_for_hw_watchpoint
parameter_list|(
name|int
name|byte_count
parameter_list|)
block|{
return|return
operator|(
name|byte_count
operator|<=
name|TYPE_LENGTH
argument_list|(
name|builtin_type_void_data_ptr
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|return_zero
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|return_one
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|return_minus_one
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Resize the to_sections pointer.  Also make sure that anyone that  * was holding on to an old value of it gets updated.  * Returns the old size.  */
end_comment

begin_function
name|int
name|target_resize_to_sections
parameter_list|(
name|struct
name|target_ops
modifier|*
name|target
parameter_list|,
name|int
name|num_added
parameter_list|)
block|{
name|struct
name|target_ops
modifier|*
modifier|*
name|t
decl_stmt|;
name|struct
name|section_table
modifier|*
name|old_value
decl_stmt|;
name|int
name|old_count
decl_stmt|;
name|old_value
operator|=
name|target
operator|->
name|to_sections
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|to_sections
condition|)
block|{
name|old_count
operator|=
name|target
operator|->
name|to_sections_end
operator|-
name|target
operator|->
name|to_sections
expr_stmt|;
name|target
operator|->
name|to_sections
operator|=
operator|(
expr|struct
name|section_table
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|target
operator|->
name|to_sections
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_table
argument_list|)
operator|)
operator|*
operator|(
name|num_added
operator|+
name|old_count
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|old_count
operator|=
literal|0
expr_stmt|;
name|target
operator|->
name|to_sections
operator|=
operator|(
expr|struct
name|section_table
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_table
argument_list|)
operator|)
operator|*
name|num_added
argument_list|)
expr_stmt|;
block|}
name|target
operator|->
name|to_sections_end
operator|=
name|target
operator|->
name|to_sections
operator|+
operator|(
name|num_added
operator|+
name|old_count
operator|)
expr_stmt|;
comment|/* Check to see if anyone else was pointing to this structure.      If old_value was null, then no one was. */
if|if
condition|(
name|old_value
condition|)
block|{
for|for
control|(
name|t
operator|=
name|target_structs
init|;
name|t
operator|<
name|target_structs
operator|+
name|target_struct_size
condition|;
operator|++
name|t
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|t
operator|)
operator|->
name|to_sections
operator|==
name|old_value
condition|)
block|{
operator|(
operator|*
name|t
operator|)
operator|->
name|to_sections
operator|=
name|target
operator|->
name|to_sections
expr_stmt|;
operator|(
operator|*
name|t
operator|)
operator|->
name|to_sections_end
operator|=
name|target
operator|->
name|to_sections_end
expr_stmt|;
block|}
block|}
block|}
return|return
name|old_count
return|;
block|}
end_function

begin_comment
comment|/* Remove all target sections taken from ABFD.     Scan the current target stack for targets whose section tables    refer to sections from BFD, and remove those sections.  We use this    when we notice that the inferior has unloaded a shared object, for    example.  */
end_comment

begin_function
name|void
name|remove_target_sections
parameter_list|(
name|bfd
modifier|*
name|abfd
parameter_list|)
block|{
name|struct
name|target_ops
modifier|*
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|target_structs
init|;
name|t
operator|<
name|target_structs
operator|+
name|target_struct_size
condition|;
name|t
operator|++
control|)
block|{
name|struct
name|section_table
modifier|*
name|src
decl_stmt|,
modifier|*
name|dest
decl_stmt|;
name|dest
operator|=
operator|(
operator|*
name|t
operator|)
operator|->
name|to_sections
expr_stmt|;
for|for
control|(
name|src
operator|=
operator|(
operator|*
name|t
operator|)
operator|->
name|to_sections
init|;
name|src
operator|<
operator|(
operator|*
name|t
operator|)
operator|->
name|to_sections_end
condition|;
name|src
operator|++
control|)
if|if
condition|(
name|src
operator|->
name|bfd
operator|!=
name|abfd
condition|)
block|{
comment|/* Keep this section.  */
if|if
condition|(
name|dest
operator|<
name|src
condition|)
operator|*
name|dest
operator|=
operator|*
name|src
expr_stmt|;
name|dest
operator|++
expr_stmt|;
block|}
comment|/* If we've dropped any sections, resize the section table.  */
if|if
condition|(
name|dest
operator|<
name|src
condition|)
name|target_resize_to_sections
argument_list|(
operator|*
name|t
argument_list|,
name|dest
operator|-
name|src
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Find a single runnable target in the stack and return it.  If for    some reason there is more than one, return NULL.  */
end_comment

begin_function
name|struct
name|target_ops
modifier|*
name|find_run_target
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|target_ops
modifier|*
modifier|*
name|t
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|runable
init|=
name|NULL
decl_stmt|;
name|int
name|count
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
name|target_structs
init|;
name|t
operator|<
name|target_structs
operator|+
name|target_struct_size
condition|;
operator|++
name|t
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|t
operator|)
operator|->
name|to_can_run
operator|&&
name|target_can_run
argument_list|(
operator|*
name|t
argument_list|)
condition|)
block|{
name|runable
operator|=
operator|*
name|t
expr_stmt|;
operator|++
name|count
expr_stmt|;
block|}
block|}
return|return
operator|(
name|count
operator|==
literal|1
condition|?
name|runable
else|:
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find a single core_stratum target in the list of targets and return it.    If for some reason there is more than one, return NULL.  */
end_comment

begin_function
name|struct
name|target_ops
modifier|*
name|find_core_target
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|target_ops
modifier|*
modifier|*
name|t
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|runable
init|=
name|NULL
decl_stmt|;
name|int
name|count
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
name|target_structs
init|;
name|t
operator|<
name|target_structs
operator|+
name|target_struct_size
condition|;
operator|++
name|t
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|t
operator|)
operator|->
name|to_stratum
operator|==
name|core_stratum
condition|)
block|{
name|runable
operator|=
operator|*
name|t
expr_stmt|;
operator|++
name|count
expr_stmt|;
block|}
block|}
return|return
operator|(
name|count
operator|==
literal|1
condition|?
name|runable
else|:
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the next target down the stack from the specified target.  */
end_comment

begin_function
name|struct
name|target_ops
modifier|*
name|find_target_beneath
parameter_list|(
name|struct
name|target_ops
modifier|*
name|t
parameter_list|)
block|{
return|return
name|t
operator|->
name|beneath
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The inferior process has died.  Long live the inferior!  */
end_comment

begin_function
name|void
name|generic_mourn_inferior
parameter_list|(
name|void
parameter_list|)
block|{
specifier|extern
name|int
name|show_breakpoint_hit_counts
decl_stmt|;
name|inferior_ptid
operator|=
name|null_ptid
expr_stmt|;
name|attach_flag
operator|=
literal|0
expr_stmt|;
name|breakpoint_init_inferior
argument_list|(
name|inf_exited
argument_list|)
expr_stmt|;
name|registers_changed
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|CLEAR_DEFERRED_STORES
comment|/* Delete any pending stores to the inferior... */
name|CLEAR_DEFERRED_STORES
expr_stmt|;
endif|#
directive|endif
name|reopen_exec_file
argument_list|()
expr_stmt|;
name|reinit_frame_cache
argument_list|()
expr_stmt|;
comment|/* It is confusing to the user for ignore counts to stick around      from previous runs of the inferior.  So clear them.  */
comment|/* However, it is more confusing for the ignore counts to disappear when      using hit counts.  So don't clear them if we're counting hits.  */
if|if
condition|(
operator|!
name|show_breakpoint_hit_counts
condition|)
name|breakpoint_clear_ignore_counts
argument_list|()
expr_stmt|;
if|if
condition|(
name|detach_hook
condition|)
name|detach_hook
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Helper function for child_wait and the Lynx derivatives of child_wait.    HOSTSTATUS is the waitstatus from wait() or the equivalent; store our    translation of that in OURSTATUS.  */
end_comment

begin_function
name|void
name|store_waitstatus
parameter_list|(
name|struct
name|target_waitstatus
modifier|*
name|ourstatus
parameter_list|,
name|int
name|hoststatus
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CHILD_SPECIAL_WAITSTATUS
comment|/* CHILD_SPECIAL_WAITSTATUS should return nonzero and set *OURSTATUS      if it wants to deal with hoststatus.  */
if|if
condition|(
name|CHILD_SPECIAL_WAITSTATUS
argument_list|(
name|ourstatus
argument_list|,
name|hoststatus
argument_list|)
condition|)
return|return;
endif|#
directive|endif
if|if
condition|(
name|WIFEXITED
argument_list|(
name|hoststatus
argument_list|)
condition|)
block|{
name|ourstatus
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|integer
operator|=
name|WEXITSTATUS
argument_list|(
name|hoststatus
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|WIFSTOPPED
argument_list|(
name|hoststatus
argument_list|)
condition|)
block|{
name|ourstatus
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_SIGNALLED
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|target_signal_from_host
argument_list|(
name|WTERMSIG
argument_list|(
name|hoststatus
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ourstatus
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|target_signal_from_host
argument_list|(
name|WSTOPSIG
argument_list|(
name|hoststatus
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Returns zero to leave the inferior alone, one to interrupt it.  */
end_comment

begin_function_decl
name|int
function_decl|(
modifier|*
name|target_activity_function
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|target_activity_fd
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Convert a normal process ID to a string.  Returns the string in a static    buffer.  */
end_comment

begin_function
name|char
modifier|*
name|normal_pid_to_str
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"process %d"
argument_list|,
name|PIDGET
argument_list|(
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/* Error-catcher for target_find_memory_regions */
end_comment

begin_function
specifier|static
name|int
name|dummy_find_memory_regions
parameter_list|(
name|int
function_decl|(
modifier|*
name|ignore1
function_decl|)
parameter_list|()
parameter_list|,
name|void
modifier|*
name|ignore2
parameter_list|)
block|{
name|error
argument_list|(
literal|"No target."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Error-catcher for target_make_corefile_notes */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|dummy_make_corefile_notes
parameter_list|(
name|bfd
modifier|*
name|ignore1
parameter_list|,
name|int
modifier|*
name|ignore2
parameter_list|)
block|{
name|error
argument_list|(
literal|"No target."
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Set up the handful of non-empty slots needed by the dummy target    vector.  */
end_comment

begin_function
specifier|static
name|void
name|init_dummy_target
parameter_list|(
name|void
parameter_list|)
block|{
name|dummy_target
operator|.
name|to_shortname
operator|=
literal|"None"
expr_stmt|;
name|dummy_target
operator|.
name|to_longname
operator|=
literal|"None"
expr_stmt|;
name|dummy_target
operator|.
name|to_doc
operator|=
literal|""
expr_stmt|;
name|dummy_target
operator|.
name|to_attach
operator|=
name|find_default_attach
expr_stmt|;
name|dummy_target
operator|.
name|to_create_inferior
operator|=
name|find_default_create_inferior
expr_stmt|;
name|dummy_target
operator|.
name|to_pid_to_str
operator|=
name|normal_pid_to_str
expr_stmt|;
name|dummy_target
operator|.
name|to_stratum
operator|=
name|dummy_stratum
expr_stmt|;
name|dummy_target
operator|.
name|to_find_memory_regions
operator|=
name|dummy_find_memory_regions
expr_stmt|;
name|dummy_target
operator|.
name|to_make_corefile_notes
operator|=
name|dummy_make_corefile_notes
expr_stmt|;
name|dummy_target
operator|.
name|to_xfer_partial
operator|=
name|default_xfer_partial
expr_stmt|;
name|dummy_target
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|struct
name|target_ops
name|debug_target
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|debug_to_open
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|debug_target
operator|.
name|to_open
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_open (%s, %d)\n"
argument_list|,
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_close
parameter_list|(
name|int
name|quitting
parameter_list|)
block|{
name|target_close
argument_list|(
operator|&
name|debug_target
argument_list|,
name|quitting
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_close (%d)\n"
argument_list|,
name|quitting
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|target_close
parameter_list|(
name|struct
name|target_ops
modifier|*
name|targ
parameter_list|,
name|int
name|quitting
parameter_list|)
block|{
if|if
condition|(
name|targ
operator|->
name|to_xclose
operator|!=
name|NULL
condition|)
name|targ
operator|->
name|to_xclose
argument_list|(
name|targ
argument_list|,
name|quitting
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|targ
operator|->
name|to_close
operator|!=
name|NULL
condition|)
name|targ
operator|->
name|to_close
argument_list|(
name|quitting
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_attach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|debug_target
operator|.
name|to_attach
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_attach (%s, %d)\n"
argument_list|,
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_post_attach
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
name|debug_target
operator|.
name|to_post_attach
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_post_attach (%d)\n"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_detach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|debug_target
operator|.
name|to_detach
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_detach (%s, %d)\n"
argument_list|,
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_disconnect
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|debug_target
operator|.
name|to_disconnect
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_disconnect (%s, %d)\n"
argument_list|,
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_resume
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|step
parameter_list|,
name|enum
name|target_signal
name|siggnal
parameter_list|)
block|{
name|debug_target
operator|.
name|to_resume
argument_list|(
name|ptid
argument_list|,
name|step
argument_list|,
name|siggnal
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_resume (%d, %s, %s)\n"
argument_list|,
name|PIDGET
argument_list|(
name|ptid
argument_list|)
argument_list|,
name|step
condition|?
literal|"step"
else|:
literal|"continue"
argument_list|,
name|target_signal_to_name
argument_list|(
name|siggnal
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|ptid_t
name|debug_to_wait
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
name|status
parameter_list|)
block|{
name|ptid_t
name|retval
decl_stmt|;
name|retval
operator|=
name|debug_target
operator|.
name|to_wait
argument_list|(
name|ptid
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_wait (%d, status) = %d,   "
argument_list|,
name|PIDGET
argument_list|(
name|ptid
argument_list|)
argument_list|,
name|PIDGET
argument_list|(
name|retval
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"status->kind = "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|status
operator|->
name|kind
condition|)
block|{
case|case
name|TARGET_WAITKIND_EXITED
case|:
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"exited, status = %d\n"
argument_list|,
name|status
operator|->
name|value
operator|.
name|integer
argument_list|)
expr_stmt|;
break|break;
case|case
name|TARGET_WAITKIND_STOPPED
case|:
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"stopped, signal = %s\n"
argument_list|,
name|target_signal_to_name
argument_list|(
name|status
operator|->
name|value
operator|.
name|sig
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TARGET_WAITKIND_SIGNALLED
case|:
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"signalled, signal = %s\n"
argument_list|,
name|target_signal_to_name
argument_list|(
name|status
operator|->
name|value
operator|.
name|sig
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TARGET_WAITKIND_LOADED
case|:
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"loaded\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TARGET_WAITKIND_FORKED
case|:
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"forked\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TARGET_WAITKIND_VFORKED
case|:
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"vforked\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TARGET_WAITKIND_EXECD
case|:
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"execd\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TARGET_WAITKIND_SPURIOUS
case|:
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"spurious\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"unknown???\n"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_post_wait
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|status
parameter_list|)
block|{
name|debug_target
operator|.
name|to_post_wait
argument_list|(
name|ptid
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_post_wait (%d, %d)\n"
argument_list|,
name|PIDGET
argument_list|(
name|ptid
argument_list|)
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_print_register
parameter_list|(
specifier|const
name|char
modifier|*
name|func
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"%s "
argument_list|,
name|func
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|0
operator|&&
name|regno
operator|<
name|NUM_REGS
operator|+
name|NUM_PSEUDO_REGS
operator|&&
name|REGISTER_NAME
argument_list|(
name|regno
argument_list|)
operator|!=
name|NULL
operator|&&
name|REGISTER_NAME
argument_list|(
name|regno
argument_list|)
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"(%s)"
argument_list|,
name|REGISTER_NAME
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"(%d)"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|>=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|deprecated_read_register_gen
argument_list|(
name|regno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" = "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"%02x"
argument_list|,
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" 0x%s %s"
argument_list|,
name|paddr_nz
argument_list|(
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
argument_list|,
name|paddr_d
argument_list|(
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_fetch_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|debug_target
operator|.
name|to_fetch_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|debug_print_register
argument_list|(
literal|"target_fetch_registers"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_store_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|debug_target
operator|.
name|to_store_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
name|debug_print_register
argument_list|(
literal|"target_store_registers"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_prepare_to_store
parameter_list|(
name|void
parameter_list|)
block|{
name|debug_target
operator|.
name|to_prepare_to_store
argument_list|()
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_prepare_to_store ()\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_to_xfer_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|write
parameter_list|,
name|struct
name|mem_attrib
modifier|*
name|attrib
parameter_list|,
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|debug_target
operator|.
name|to_xfer_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|,
name|write
argument_list|,
name|attrib
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_xfer_memory (0x%x, xxx, %d, %s, xxx) = %d"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|memaddr
argument_list|,
comment|/* possable truncate long long */
name|len
argument_list|,
name|write
condition|?
literal|"write"
else|:
literal|"read"
argument_list|,
name|retval
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|>
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|fputs_unfiltered
argument_list|(
literal|", bytes ="
argument_list|,
name|gdb_stdlog
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|retval
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
operator|(
name|long
operator|)
operator|&
operator|(
name|myaddr
index|[
name|i
index|]
operator|)
operator|)
operator|&
literal|0xf
operator|)
operator|==
literal|0
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|" %02x"
argument_list|,
name|myaddr
index|[
name|i
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
block|}
name|fputc_unfiltered
argument_list|(
literal|'\n'
argument_list|,
name|gdb_stdlog
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_files_info
parameter_list|(
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
block|{
name|debug_target
operator|.
name|to_files_info
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_files_info (xxx)\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_to_insert_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|save
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|debug_target
operator|.
name|to_insert_breakpoint
argument_list|(
name|addr
argument_list|,
name|save
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_insert_breakpoint (0x%lx, xxx) = %ld\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|addr
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|retval
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_to_remove_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|save
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|debug_target
operator|.
name|to_remove_breakpoint
argument_list|(
name|addr
argument_list|,
name|save
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_remove_breakpoint (0x%lx, xxx) = %ld\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|addr
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|retval
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_to_can_use_hw_breakpoint
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|cnt
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|debug_target
operator|.
name|to_can_use_hw_breakpoint
argument_list|(
name|type
argument_list|,
name|cnt
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_can_use_hw_breakpoint (%ld, %ld, %ld) = %ld\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|type
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|cnt
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|from_tty
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|retval
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_to_region_size_ok_for_hw_watchpoint
parameter_list|(
name|int
name|byte_count
parameter_list|)
block|{
name|CORE_ADDR
name|retval
decl_stmt|;
name|retval
operator|=
name|debug_target
operator|.
name|to_region_size_ok_for_hw_watchpoint
argument_list|(
name|byte_count
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"TARGET_REGION_SIZE_OK_FOR_HW_WATCHPOINT (%ld) = 0x%lx\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|byte_count
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|retval
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_to_stopped_by_watchpoint
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|debug_target
operator|.
name|to_stopped_by_watchpoint
argument_list|()
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"STOPPED_BY_WATCHPOINT () = %ld\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|retval
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|debug_to_stopped_data_address
parameter_list|(
name|void
parameter_list|)
block|{
name|CORE_ADDR
name|retval
decl_stmt|;
name|retval
operator|=
name|debug_target
operator|.
name|to_stopped_data_address
argument_list|()
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_stopped_data_address () = 0x%lx\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|retval
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_to_insert_hw_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|save
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|debug_target
operator|.
name|to_insert_hw_breakpoint
argument_list|(
name|addr
argument_list|,
name|save
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_insert_hw_breakpoint (0x%lx, xxx) = %ld\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|addr
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|retval
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_to_remove_hw_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|save
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|debug_target
operator|.
name|to_remove_hw_breakpoint
argument_list|(
name|addr
argument_list|,
name|save
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_remove_hw_breakpoint (0x%lx, xxx) = %ld\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|addr
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|retval
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_to_insert_watchpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|debug_target
operator|.
name|to_insert_watchpoint
argument_list|(
name|addr
argument_list|,
name|len
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_insert_watchpoint (0x%lx, %d, %d) = %ld\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|addr
argument_list|,
name|len
argument_list|,
name|type
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|retval
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_to_remove_watchpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|debug_target
operator|.
name|to_insert_watchpoint
argument_list|(
name|addr
argument_list|,
name|len
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_insert_watchpoint (0x%lx, %d, %d) = %ld\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|addr
argument_list|,
name|len
argument_list|,
name|type
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|retval
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_terminal_init
parameter_list|(
name|void
parameter_list|)
block|{
name|debug_target
operator|.
name|to_terminal_init
argument_list|()
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_terminal_init ()\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_terminal_inferior
parameter_list|(
name|void
parameter_list|)
block|{
name|debug_target
operator|.
name|to_terminal_inferior
argument_list|()
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_terminal_inferior ()\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_terminal_ours_for_output
parameter_list|(
name|void
parameter_list|)
block|{
name|debug_target
operator|.
name|to_terminal_ours_for_output
argument_list|()
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_terminal_ours_for_output ()\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_terminal_ours
parameter_list|(
name|void
parameter_list|)
block|{
name|debug_target
operator|.
name|to_terminal_ours
argument_list|()
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_terminal_ours ()\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_terminal_save_ours
parameter_list|(
name|void
parameter_list|)
block|{
name|debug_target
operator|.
name|to_terminal_save_ours
argument_list|()
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_terminal_save_ours ()\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_terminal_info
parameter_list|(
name|char
modifier|*
name|arg
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|debug_target
operator|.
name|to_terminal_info
argument_list|(
name|arg
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_terminal_info (%s, %d)\n"
argument_list|,
name|arg
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_kill
parameter_list|(
name|void
parameter_list|)
block|{
name|debug_target
operator|.
name|to_kill
argument_list|()
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_kill ()\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_load
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|debug_target
operator|.
name|to_load
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_load (%s, %d)\n"
argument_list|,
name|args
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_to_lookup_symbol
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|CORE_ADDR
modifier|*
name|addrp
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|debug_target
operator|.
name|to_lookup_symbol
argument_list|(
name|name
argument_list|,
name|addrp
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_lookup_symbol (%s, xxx)\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_create_inferior
parameter_list|(
name|char
modifier|*
name|exec_file
parameter_list|,
name|char
modifier|*
name|args
parameter_list|,
name|char
modifier|*
modifier|*
name|env
parameter_list|)
block|{
name|debug_target
operator|.
name|to_create_inferior
argument_list|(
name|exec_file
argument_list|,
name|args
argument_list|,
name|env
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_create_inferior (%s, %s, xxx)\n"
argument_list|,
name|exec_file
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_post_startup_inferior
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
name|debug_target
operator|.
name|to_post_startup_inferior
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_post_startup_inferior (%d)\n"
argument_list|,
name|PIDGET
argument_list|(
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_acknowledge_created_inferior
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
name|debug_target
operator|.
name|to_acknowledge_created_inferior
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_acknowledge_created_inferior (%d)\n"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_to_insert_fork_catchpoint
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|debug_target
operator|.
name|to_insert_fork_catchpoint
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_insert_fork_catchpoint (%d) = %d\n"
argument_list|,
name|pid
argument_list|,
name|retval
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_to_remove_fork_catchpoint
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|debug_target
operator|.
name|to_remove_fork_catchpoint
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_remove_fork_catchpoint (%d) = %d\n"
argument_list|,
name|pid
argument_list|,
name|retval
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_to_insert_vfork_catchpoint
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|debug_target
operator|.
name|to_insert_vfork_catchpoint
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_insert_vfork_catchpoint (%d)= %d\n"
argument_list|,
name|pid
argument_list|,
name|retval
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_to_remove_vfork_catchpoint
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|debug_target
operator|.
name|to_remove_vfork_catchpoint
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_remove_vfork_catchpoint (%d) = %d\n"
argument_list|,
name|pid
argument_list|,
name|retval
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_to_follow_fork
parameter_list|(
name|int
name|follow_child
parameter_list|)
block|{
name|int
name|retval
init|=
name|debug_target
operator|.
name|to_follow_fork
argument_list|(
name|follow_child
argument_list|)
decl_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_follow_fork (%d) = %d\n"
argument_list|,
name|follow_child
argument_list|,
name|retval
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_to_insert_exec_catchpoint
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|debug_target
operator|.
name|to_insert_exec_catchpoint
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_insert_exec_catchpoint (%d) = %d\n"
argument_list|,
name|pid
argument_list|,
name|retval
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_to_remove_exec_catchpoint
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|debug_target
operator|.
name|to_remove_exec_catchpoint
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_remove_exec_catchpoint (%d) = %d\n"
argument_list|,
name|pid
argument_list|,
name|retval
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_to_reported_exec_events_per_exec_call
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|reported_exec_events
decl_stmt|;
name|reported_exec_events
operator|=
name|debug_target
operator|.
name|to_reported_exec_events_per_exec_call
argument_list|()
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_reported_exec_events_per_exec_call () = %d\n"
argument_list|,
name|reported_exec_events
argument_list|)
expr_stmt|;
return|return
name|reported_exec_events
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_to_has_exited
parameter_list|(
name|int
name|pid
parameter_list|,
name|int
name|wait_status
parameter_list|,
name|int
modifier|*
name|exit_status
parameter_list|)
block|{
name|int
name|has_exited
decl_stmt|;
name|has_exited
operator|=
name|debug_target
operator|.
name|to_has_exited
argument_list|(
name|pid
argument_list|,
name|wait_status
argument_list|,
name|exit_status
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_has_exited (%d, %d, %d) = %d\n"
argument_list|,
name|pid
argument_list|,
name|wait_status
argument_list|,
operator|*
name|exit_status
argument_list|,
name|has_exited
argument_list|)
expr_stmt|;
return|return
name|has_exited
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_mourn_inferior
parameter_list|(
name|void
parameter_list|)
block|{
name|debug_target
operator|.
name|to_mourn_inferior
argument_list|()
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_mourn_inferior ()\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_to_can_run
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|debug_target
operator|.
name|to_can_run
argument_list|()
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_can_run () = %d\n"
argument_list|,
name|retval
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_notice_signals
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
name|debug_target
operator|.
name|to_notice_signals
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_notice_signals (%d)\n"
argument_list|,
name|PIDGET
argument_list|(
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|debug_to_thread_alive
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|debug_target
operator|.
name|to_thread_alive
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_thread_alive (%d) = %d\n"
argument_list|,
name|PIDGET
argument_list|(
name|ptid
argument_list|)
argument_list|,
name|retval
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_find_new_threads
parameter_list|(
name|void
parameter_list|)
block|{
name|debug_target
operator|.
name|to_find_new_threads
argument_list|()
expr_stmt|;
name|fputs_unfiltered
argument_list|(
literal|"target_find_new_threads ()\n"
argument_list|,
name|gdb_stdlog
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_stop
parameter_list|(
name|void
parameter_list|)
block|{
name|debug_target
operator|.
name|to_stop
argument_list|()
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_stop ()\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|LONGEST
name|debug_to_xfer_partial
parameter_list|(
name|struct
name|target_ops
modifier|*
name|ops
parameter_list|,
name|enum
name|target_object
name|object
parameter_list|,
specifier|const
name|char
modifier|*
name|annex
parameter_list|,
name|void
modifier|*
name|readbuf
parameter_list|,
specifier|const
name|void
modifier|*
name|writebuf
parameter_list|,
name|ULONGEST
name|offset
parameter_list|,
name|LONGEST
name|len
parameter_list|)
block|{
name|LONGEST
name|retval
decl_stmt|;
name|retval
operator|=
name|debug_target
operator|.
name|to_xfer_partial
argument_list|(
operator|&
name|debug_target
argument_list|,
name|object
argument_list|,
name|annex
argument_list|,
name|readbuf
argument_list|,
name|writebuf
argument_list|,
name|offset
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_xfer_partial (%d, %s, 0x%lx,  0x%lx,  0x%s, %s) = %s\n"
argument_list|,
operator|(
name|int
operator|)
name|object
argument_list|,
operator|(
name|annex
condition|?
name|annex
else|:
literal|"(null)"
operator|)
argument_list|,
operator|(
name|long
operator|)
name|readbuf
argument_list|,
operator|(
name|long
operator|)
name|writebuf
argument_list|,
name|paddr_nz
argument_list|(
name|offset
argument_list|)
argument_list|,
name|paddr_d
argument_list|(
name|len
argument_list|)
argument_list|,
name|paddr_d
argument_list|(
name|retval
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|debug_to_rcmd
parameter_list|(
name|char
modifier|*
name|command
parameter_list|,
name|struct
name|ui_file
modifier|*
name|outbuf
parameter_list|)
block|{
name|debug_target
operator|.
name|to_rcmd
argument_list|(
name|command
argument_list|,
name|outbuf
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_rcmd (%s, ...)\n"
argument_list|,
name|command
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|symtab_and_line
modifier|*
name|debug_to_enable_exception_callback
parameter_list|(
name|enum
name|exception_event_kind
name|kind
parameter_list|,
name|int
name|enable
parameter_list|)
block|{
name|struct
name|symtab_and_line
modifier|*
name|result
decl_stmt|;
name|result
operator|=
name|debug_target
operator|.
name|to_enable_exception_callback
argument_list|(
name|kind
argument_list|,
name|enable
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target get_exception_callback_sal (%d, %d)\n"
argument_list|,
name|kind
argument_list|,
name|enable
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|exception_event_record
modifier|*
name|debug_to_get_current_exception_event
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|exception_event_record
modifier|*
name|result
decl_stmt|;
name|result
operator|=
name|debug_target
operator|.
name|to_get_current_exception_event
argument_list|()
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target get_current_exception_event ()\n"
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|debug_to_pid_to_exec_file
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
name|char
modifier|*
name|exec_file
decl_stmt|;
name|exec_file
operator|=
name|debug_target
operator|.
name|to_pid_to_exec_file
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"target_pid_to_exec_file (%d) = %s\n"
argument_list|,
name|pid
argument_list|,
name|exec_file
argument_list|)
expr_stmt|;
return|return
name|exec_file
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|setup_target_debug
parameter_list|(
name|void
parameter_list|)
block|{
name|memcpy
argument_list|(
operator|&
name|debug_target
argument_list|,
operator|&
name|current_target
argument_list|,
sizeof|sizeof
name|debug_target
argument_list|)
expr_stmt|;
name|current_target
operator|.
name|to_open
operator|=
name|debug_to_open
expr_stmt|;
name|current_target
operator|.
name|to_close
operator|=
name|debug_to_close
expr_stmt|;
name|current_target
operator|.
name|to_attach
operator|=
name|debug_to_attach
expr_stmt|;
name|current_target
operator|.
name|to_post_attach
operator|=
name|debug_to_post_attach
expr_stmt|;
name|current_target
operator|.
name|to_detach
operator|=
name|debug_to_detach
expr_stmt|;
name|current_target
operator|.
name|to_disconnect
operator|=
name|debug_to_disconnect
expr_stmt|;
name|current_target
operator|.
name|to_resume
operator|=
name|debug_to_resume
expr_stmt|;
name|current_target
operator|.
name|to_wait
operator|=
name|debug_to_wait
expr_stmt|;
name|current_target
operator|.
name|to_post_wait
operator|=
name|debug_to_post_wait
expr_stmt|;
name|current_target
operator|.
name|to_fetch_registers
operator|=
name|debug_to_fetch_registers
expr_stmt|;
name|current_target
operator|.
name|to_store_registers
operator|=
name|debug_to_store_registers
expr_stmt|;
name|current_target
operator|.
name|to_prepare_to_store
operator|=
name|debug_to_prepare_to_store
expr_stmt|;
name|current_target
operator|.
name|to_xfer_memory
operator|=
name|debug_to_xfer_memory
expr_stmt|;
name|current_target
operator|.
name|to_files_info
operator|=
name|debug_to_files_info
expr_stmt|;
name|current_target
operator|.
name|to_insert_breakpoint
operator|=
name|debug_to_insert_breakpoint
expr_stmt|;
name|current_target
operator|.
name|to_remove_breakpoint
operator|=
name|debug_to_remove_breakpoint
expr_stmt|;
name|current_target
operator|.
name|to_can_use_hw_breakpoint
operator|=
name|debug_to_can_use_hw_breakpoint
expr_stmt|;
name|current_target
operator|.
name|to_insert_hw_breakpoint
operator|=
name|debug_to_insert_hw_breakpoint
expr_stmt|;
name|current_target
operator|.
name|to_remove_hw_breakpoint
operator|=
name|debug_to_remove_hw_breakpoint
expr_stmt|;
name|current_target
operator|.
name|to_insert_watchpoint
operator|=
name|debug_to_insert_watchpoint
expr_stmt|;
name|current_target
operator|.
name|to_remove_watchpoint
operator|=
name|debug_to_remove_watchpoint
expr_stmt|;
name|current_target
operator|.
name|to_stopped_by_watchpoint
operator|=
name|debug_to_stopped_by_watchpoint
expr_stmt|;
name|current_target
operator|.
name|to_stopped_data_address
operator|=
name|debug_to_stopped_data_address
expr_stmt|;
name|current_target
operator|.
name|to_region_size_ok_for_hw_watchpoint
operator|=
name|debug_to_region_size_ok_for_hw_watchpoint
expr_stmt|;
name|current_target
operator|.
name|to_terminal_init
operator|=
name|debug_to_terminal_init
expr_stmt|;
name|current_target
operator|.
name|to_terminal_inferior
operator|=
name|debug_to_terminal_inferior
expr_stmt|;
name|current_target
operator|.
name|to_terminal_ours_for_output
operator|=
name|debug_to_terminal_ours_for_output
expr_stmt|;
name|current_target
operator|.
name|to_terminal_ours
operator|=
name|debug_to_terminal_ours
expr_stmt|;
name|current_target
operator|.
name|to_terminal_save_ours
operator|=
name|debug_to_terminal_save_ours
expr_stmt|;
name|current_target
operator|.
name|to_terminal_info
operator|=
name|debug_to_terminal_info
expr_stmt|;
name|current_target
operator|.
name|to_kill
operator|=
name|debug_to_kill
expr_stmt|;
name|current_target
operator|.
name|to_load
operator|=
name|debug_to_load
expr_stmt|;
name|current_target
operator|.
name|to_lookup_symbol
operator|=
name|debug_to_lookup_symbol
expr_stmt|;
name|current_target
operator|.
name|to_create_inferior
operator|=
name|debug_to_create_inferior
expr_stmt|;
name|current_target
operator|.
name|to_post_startup_inferior
operator|=
name|debug_to_post_startup_inferior
expr_stmt|;
name|current_target
operator|.
name|to_acknowledge_created_inferior
operator|=
name|debug_to_acknowledge_created_inferior
expr_stmt|;
name|current_target
operator|.
name|to_insert_fork_catchpoint
operator|=
name|debug_to_insert_fork_catchpoint
expr_stmt|;
name|current_target
operator|.
name|to_remove_fork_catchpoint
operator|=
name|debug_to_remove_fork_catchpoint
expr_stmt|;
name|current_target
operator|.
name|to_insert_vfork_catchpoint
operator|=
name|debug_to_insert_vfork_catchpoint
expr_stmt|;
name|current_target
operator|.
name|to_remove_vfork_catchpoint
operator|=
name|debug_to_remove_vfork_catchpoint
expr_stmt|;
name|current_target
operator|.
name|to_follow_fork
operator|=
name|debug_to_follow_fork
expr_stmt|;
name|current_target
operator|.
name|to_insert_exec_catchpoint
operator|=
name|debug_to_insert_exec_catchpoint
expr_stmt|;
name|current_target
operator|.
name|to_remove_exec_catchpoint
operator|=
name|debug_to_remove_exec_catchpoint
expr_stmt|;
name|current_target
operator|.
name|to_reported_exec_events_per_exec_call
operator|=
name|debug_to_reported_exec_events_per_exec_call
expr_stmt|;
name|current_target
operator|.
name|to_has_exited
operator|=
name|debug_to_has_exited
expr_stmt|;
name|current_target
operator|.
name|to_mourn_inferior
operator|=
name|debug_to_mourn_inferior
expr_stmt|;
name|current_target
operator|.
name|to_can_run
operator|=
name|debug_to_can_run
expr_stmt|;
name|current_target
operator|.
name|to_notice_signals
operator|=
name|debug_to_notice_signals
expr_stmt|;
name|current_target
operator|.
name|to_thread_alive
operator|=
name|debug_to_thread_alive
expr_stmt|;
name|current_target
operator|.
name|to_find_new_threads
operator|=
name|debug_to_find_new_threads
expr_stmt|;
name|current_target
operator|.
name|to_stop
operator|=
name|debug_to_stop
expr_stmt|;
name|current_target
operator|.
name|to_xfer_partial
operator|=
name|debug_to_xfer_partial
expr_stmt|;
name|current_target
operator|.
name|to_rcmd
operator|=
name|debug_to_rcmd
expr_stmt|;
name|current_target
operator|.
name|to_enable_exception_callback
operator|=
name|debug_to_enable_exception_callback
expr_stmt|;
name|current_target
operator|.
name|to_get_current_exception_event
operator|=
name|debug_to_get_current_exception_event
expr_stmt|;
name|current_target
operator|.
name|to_pid_to_exec_file
operator|=
name|debug_to_pid_to_exec_file
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|char
name|targ_desc
index|[]
init|=
literal|"Names of targets and files being debugged.\n\ Shows the entire stack of targets currently in use (including the exec-file,\n\ core-file, and process, if any), as well as the symbol file name."
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|do_monitor_command
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
operator|(
name|current_target
operator|.
name|to_rcmd
operator|==
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|char
operator|*
argument_list|,
expr|struct
name|ui_file
operator|*
argument_list|)
operator|)
name|tcomplain
operator|)
operator|||
operator|(
name|current_target
operator|.
name|to_rcmd
operator|==
name|debug_to_rcmd
operator|&&
operator|(
name|debug_target
operator|.
name|to_rcmd
operator|==
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|char
operator|*
argument_list|,
expr|struct
name|ui_file
operator|*
argument_list|)
operator|)
name|tcomplain
operator|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"\"monitor\" command not supported by this target.\n"
argument_list|)
expr_stmt|;
block|}
name|target_rcmd
argument_list|(
name|cmd
argument_list|,
name|gdb_stdtarg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|initialize_targets
parameter_list|(
name|void
parameter_list|)
block|{
name|init_dummy_target
argument_list|()
expr_stmt|;
name|push_target
argument_list|(
operator|&
name|dummy_target
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"target"
argument_list|,
name|target_info
argument_list|,
name|targ_desc
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"files"
argument_list|,
name|target_info
argument_list|,
name|targ_desc
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"target"
argument_list|,
name|class_maintenance
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|targetdebug
argument_list|,
literal|"Set target debugging.\n\ When non-zero, target debugging is enabled."
argument_list|,
operator|&
name|setdebuglist
argument_list|)
argument_list|,
operator|&
name|showdebuglist
argument_list|)
expr_stmt|;
name|add_setshow_boolean_cmd
argument_list|(
literal|"trust-readonly-sections"
argument_list|,
name|class_support
argument_list|,
operator|&
name|trust_readonly
argument_list|,
literal|"\ Set mode for reading from readonly sections.\n\ When this mode is on, memory reads from readonly sections (such as .text)\n\ will be read from the object file instead of from the target.  This will\n\ result in significant performance improvement for remote targets."
argument_list|,
literal|"\ Show mode for reading from readonly sections.\n"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|setlist
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"monitor"
argument_list|,
name|class_obscure
argument_list|,
name|do_monitor_command
argument_list|,
literal|"Send a command to the remote monitor (remote targets only)."
argument_list|)
expr_stmt|;
name|target_dcache
operator|=
name|dcache_init
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

