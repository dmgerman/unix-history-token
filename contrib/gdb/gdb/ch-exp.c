begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Parser for GNU CHILL (CCITT High-Level Language)  -*- C -*-    Copyright 1992, 1993, 1995, 1996, 1997, 1999, 2000, 2001    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Parse a Chill expression from text in a string,    and return the result as a  struct expression  pointer.    That structure contains arithmetic operations in reverse polish,    with constants represented by operations that are followed by special data.    See expression.h for the details of the format.    What is important here is that it can be built up sequentially    during the process of parsing; the lower levels of the tree always    come first in the result.     Note that the language accepted by this parser is more liberal    than the one accepted by an actual Chill compiler.  For example, the    language rule that a simple name string can not be one of the reserved    simple name strings is not enforced (e.g "case" is not treated as a    reserved name).  Another example is that Chill is a strongly typed    language, and certain expressions that violate the type constraints    may still be evaluated if gdb can do so in a meaningful manner, while    such expressions would be rejected by the compiler.  The reason for    this more liberal behavior is the philosophy that the debugger    is intended to be a tool that is used by the programmer when things    go wrong, and as such, it should provide as few artificial barriers    to it's use as possible.  If it can do something meaningful, even    something that violates language contraints that are enforced by the    compiler, it should do so without complaint.   */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"parser-defs.h"
end_include

begin_include
include|#
directive|include
file|"ch-lang.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_comment
comment|/* Required by objfiles.h.  */
end_comment

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_comment
comment|/* Required by objfiles.h.  */
end_comment

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_comment
comment|/* For have_full_symbols and have_partial_symbols */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|INLINE
value|__inline__
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
union|union
block|{
name|LONGEST
name|lval
decl_stmt|;
name|ULONGEST
name|ulval
decl_stmt|;
struct|struct
block|{
name|LONGEST
name|val
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|}
name|typed_val
struct|;
name|double
name|dval
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|struct
name|type
modifier|*
name|tval
decl_stmt|;
name|struct
name|stoken
name|sval
decl_stmt|;
name|struct
name|ttype
name|tsym
decl_stmt|;
name|struct
name|symtoken
name|ssym
decl_stmt|;
block|}
name|YYSTYPE
typedef|;
end_typedef

begin_enum
enum|enum
name|ch_terminal
block|{
name|END_TOKEN
init|=
literal|0
block|,
comment|/* '\001' ... '\xff' come first. */
name|OPEN_PAREN
init|=
literal|'('
block|,
name|TOKEN_NOT_READ
init|=
literal|999
block|,
name|INTEGER_LITERAL
block|,
name|BOOLEAN_LITERAL
block|,
name|CHARACTER_LITERAL
block|,
name|FLOAT_LITERAL
block|,
name|GENERAL_PROCEDURE_NAME
block|,
name|LOCATION_NAME
block|,
name|EMPTINESS_LITERAL
block|,
name|CHARACTER_STRING_LITERAL
block|,
name|BIT_STRING_LITERAL
block|,
name|TYPENAME
block|,
name|DOT_FIELD_NAME
block|,
comment|/* '.' followed by<field name> */
name|CASE
block|,
name|OF
block|,
name|ESAC
block|,
name|LOGIOR
block|,
name|ORIF
block|,
name|LOGXOR
block|,
name|LOGAND
block|,
name|ANDIF
block|,
name|NOTEQUAL
block|,
name|GEQ
block|,
name|LEQ
block|,
name|IN
block|,
name|SLASH_SLASH
block|,
name|MOD
block|,
name|REM
block|,
name|NOT
block|,
name|POINTER
block|,
name|RECEIVE
block|,
name|UP
block|,
name|IF
block|,
name|THEN
block|,
name|ELSE
block|,
name|FI
block|,
name|ELSIF
block|,
name|ILLEGAL_TOKEN
block|,
name|NUM
block|,
name|PRED
block|,
name|SUCC
block|,
name|ABS
block|,
name|CARD
block|,
name|MAX_TOKEN
block|,
name|MIN_TOKEN
block|,
name|ADDR_TOKEN
block|,
name|SIZE
block|,
name|UPPER
block|,
name|LOWER
block|,
name|LENGTH
block|,
name|ARRAY
block|,
name|GDB_VARIABLE
block|,
name|GDB_ASSIGNMENT
block|}
enum|;
end_enum

begin_comment
comment|/* Forward declarations. */
end_comment

begin_function_decl
specifier|static
name|void
name|write_lower_upper_value
parameter_list|(
name|enum
name|exp_opcode
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|ch_terminal
name|match_bitstring_literal
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|ch_terminal
name|match_integer_literal
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|ch_terminal
name|match_character_literal
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|ch_terminal
name|match_string_literal
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|ch_terminal
name|match_float_literal
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|decode_integer_literal
parameter_list|(
name|LONGEST
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|decode_integer_value
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|LONGEST
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|match_simple_name_string
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|growbuf_by_size
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_case_label
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_untyped_expr
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_if_expression
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_if_expression_body
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_else_alternative
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_then_alternative
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_expr
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_operand0
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_operand1
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_operand2
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_operand3
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_operand4
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_operand5
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_operand6
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_primval
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_tuple
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_opt_element_list
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_tuple_element
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_named_record_element
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_call
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|parse_mode_or_normal_call
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static struct type *parse_mode_call (void);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|parse_unary_call
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parse_opt_untyped_expr
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|expect
parameter_list|(
name|enum
name|ch_terminal
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|ch_terminal
name|ch_lex
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|INLINE
specifier|static
name|enum
name|ch_terminal
name|PEEK_TOKEN
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|ch_terminal
name|peek_token_
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|forward_token_
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|require
parameter_list|(
name|enum
name|ch_terminal
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|check_token
parameter_list|(
name|enum
name|ch_terminal
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|MAX_LOOK_AHEAD
value|2
end_define

begin_decl_stmt
specifier|static
name|enum
name|ch_terminal
name|terminal_buffer
index|[
name|MAX_LOOK_AHEAD
operator|+
literal|1
index|]
init|=
block|{
name|TOKEN_NOT_READ
block|,
name|TOKEN_NOT_READ
block|,
name|TOKEN_NOT_READ
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|YYSTYPE
name|yylval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|YYSTYPE
name|val_buffer
index|[
name|MAX_LOOK_AHEAD
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*int current_token, lookahead_token; */
end_comment

begin_function
name|INLINE
specifier|static
name|enum
name|ch_terminal
name|PEEK_TOKEN
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|terminal_buffer
index|[
literal|0
index|]
operator|==
name|TOKEN_NOT_READ
condition|)
block|{
name|terminal_buffer
index|[
literal|0
index|]
operator|=
name|ch_lex
argument_list|()
expr_stmt|;
name|val_buffer
index|[
literal|0
index|]
operator|=
name|yylval
expr_stmt|;
block|}
return|return
name|terminal_buffer
index|[
literal|0
index|]
return|;
block|}
end_function

begin_define
define|#
directive|define
name|PEEK_LVAL
parameter_list|()
value|val_buffer[0]
end_define

begin_define
define|#
directive|define
name|PEEK_TOKEN1
parameter_list|()
value|peek_token_(1)
end_define

begin_define
define|#
directive|define
name|PEEK_TOKEN2
parameter_list|()
value|peek_token_(2)
end_define

begin_function
specifier|static
name|enum
name|ch_terminal
name|peek_token_
parameter_list|(
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
name|i
operator|>
name|MAX_LOOK_AHEAD
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"too much lookahead"
argument_list|)
expr_stmt|;
if|if
condition|(
name|terminal_buffer
index|[
name|i
index|]
operator|==
name|TOKEN_NOT_READ
condition|)
block|{
name|terminal_buffer
index|[
name|i
index|]
operator|=
name|ch_lex
argument_list|()
expr_stmt|;
name|val_buffer
index|[
name|i
index|]
operator|=
name|yylval
expr_stmt|;
block|}
return|return
name|terminal_buffer
index|[
name|i
index|]
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void pushback_token (enum ch_terminal code, YYSTYPE node) {   int i;   if (terminal_buffer[MAX_LOOK_AHEAD] != TOKEN_NOT_READ)     internal_error (__FILE__, __LINE__, 		    "cannot pushback token");   for (i = MAX_LOOK_AHEAD; i> 0; i--)     {       terminal_buffer[i] = terminal_buffer[i - 1];       val_buffer[i] = val_buffer[i - 1];     }   terminal_buffer[0] = code;   val_buffer[0] = node; }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|forward_token_
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_LOOK_AHEAD
condition|;
name|i
operator|++
control|)
block|{
name|terminal_buffer
index|[
name|i
index|]
operator|=
name|terminal_buffer
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|val_buffer
index|[
name|i
index|]
operator|=
name|val_buffer
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
name|terminal_buffer
index|[
name|MAX_LOOK_AHEAD
index|]
operator|=
name|TOKEN_NOT_READ
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|FORWARD_TOKEN
parameter_list|()
value|forward_token_()
end_define

begin_comment
comment|/* Skip the next token.    if it isn't TOKEN, the parser is broken. */
end_comment

begin_function
specifier|static
name|void
name|require
parameter_list|(
name|enum
name|ch_terminal
name|token
parameter_list|)
block|{
if|if
condition|(
name|PEEK_TOKEN
argument_list|()
operator|!=
name|token
condition|)
block|{
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"expected token %d"
argument_list|,
operator|(
name|int
operator|)
name|token
argument_list|)
expr_stmt|;
block|}
name|FORWARD_TOKEN
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_token
parameter_list|(
name|enum
name|ch_terminal
name|token
parameter_list|)
block|{
if|if
condition|(
name|PEEK_TOKEN
argument_list|()
operator|!=
name|token
condition|)
return|return
literal|0
return|;
name|FORWARD_TOKEN
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* return 0 if expected token was not found,    else return 1.  */
end_comment

begin_function
specifier|static
name|int
name|expect
parameter_list|(
name|enum
name|ch_terminal
name|token
parameter_list|,
name|char
modifier|*
name|message
parameter_list|)
block|{
if|if
condition|(
name|PEEK_TOKEN
argument_list|()
operator|!=
name|token
condition|)
block|{
if|if
condition|(
name|message
condition|)
name|error
argument_list|(
name|message
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|token
operator|<
literal|256
condition|)
name|error
argument_list|(
literal|"syntax error - expected a '%c' here \"%s\""
argument_list|,
name|token
argument_list|,
name|lexptr
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"syntax error"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
name|FORWARD_TOKEN
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Parse a name string.  If ALLOW_ALL is 1, ALL is allowed as a postfix. */
end_comment

begin_comment
unit|static tree parse_opt_name_string (int allow_all) {   int token = PEEK_TOKEN ();   tree name;   if (token != NAME)     {       if (token == ALL&& allow_all) 	{ 	  FORWARD_TOKEN (); 	  return ALL_POSTFIX; 	}       return NULL_TREE;     }   name = PEEK_LVAL ();   for (;;)     {       FORWARD_TOKEN ();       token = PEEK_TOKEN ();       if (token != '!') 	return name;       FORWARD_TOKEN ();       token = PEEK_TOKEN ();       if (token == ALL&& allow_all) 	return get_identifier3 (IDENTIFIER_POINTER (name), "!", "*");       if (token != NAME) 	{ 	  if (pass == 1) 	    error ("'%s!' is not followed by an identifier", 		   IDENTIFIER_POINTER (name)); 	  return name; 	}       name = get_identifier3 (IDENTIFIER_POINTER (name), 			      "!", IDENTIFIER_POINTER (PEEK_LVAL ()));     } }  static tree parse_simple_name_string (void) {   int token = PEEK_TOKEN ();   tree name;   if (token != NAME)     {       error ("expected a name here");       return error_mark_node;     }   name = PEEK_LVAL ();   FORWARD_TOKEN ();   return name; }  static tree parse_name_string (void) {   tree name = parse_opt_name_string (0);   if (name)     return name;   if (pass == 1)     error ("expected a name string here");   return error_mark_node; }
comment|/* Matches:<name_string>    Returns if pass 1: the identifier.    Returns if pass 2: a decl or value for identifier. */
end_comment

begin_endif
unit|static tree parse_name (void) {   tree name = parse_name_string ();   if (pass == 1 || ignoring)     return name;   else     {       tree decl = lookup_name (name);       if (decl == NULL_TREE) 	{ 	  error ("`%s' undeclared", IDENTIFIER_POINTER (name)); 	  return error_mark_node; 	}       else if (TREE_CODE (TREE_TYPE (decl)) == ERROR_MARK) 	return error_mark_node;       else if (TREE_CODE (decl) == CONST_DECL) 	return DECL_INITIAL (decl);       else if (TREE_CODE (TREE_TYPE (decl)) == REFERENCE_TYPE) 	return convert_from_reference (decl);       else 	return decl;     } }
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void pushback_paren_expr (tree expr) {   if (pass == 1&& !ignoring)     expr = build1 (PAREN_EXPR, NULL_TREE, expr);   pushback_token (EXPR, expr); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Matches:<case label> */
end_comment

begin_function
specifier|static
name|void
name|parse_case_label
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|check_token
argument_list|(
name|ELSE
argument_list|)
condition|)
name|error
argument_list|(
literal|"ELSE in tuples labels not implemented"
argument_list|)
expr_stmt|;
comment|/* Does not handle the case of a mode name.  FIXME */
name|parse_expr
argument_list|()
expr_stmt|;
if|if
condition|(
name|check_token
argument_list|(
literal|':'
argument_list|)
condition|)
block|{
name|parse_expr
argument_list|()
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|BINOP_RANGE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|parse_opt_untyped_expr
parameter_list|(
name|void
parameter_list|)
block|{
switch|switch
condition|(
name|PEEK_TOKEN
argument_list|()
condition|)
block|{
case|case
literal|','
case|:
case|case
literal|':'
case|:
case|case
literal|')'
case|:
return|return
literal|0
return|;
default|default:
name|parse_untyped_expr
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|parse_unary_call
parameter_list|(
name|void
parameter_list|)
block|{
name|FORWARD_TOKEN
argument_list|()
expr_stmt|;
name|expect
argument_list|(
literal|'('
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|parse_expr
argument_list|()
expr_stmt|;
name|expect
argument_list|(
literal|')'
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse NAME '(' MODENAME ')'. */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static struct type * parse_mode_call (void) {   struct type *type;   FORWARD_TOKEN ();   expect ('(', NULL);   if (PEEK_TOKEN () != TYPENAME)     error ("expect MODENAME here `%s'", lexptr);   type = PEEK_LVAL ().tsym.type;   FORWARD_TOKEN ();   expect (')', NULL);   return type; }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|struct
name|type
modifier|*
name|parse_mode_or_normal_call
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|FORWARD_TOKEN
argument_list|()
expr_stmt|;
name|expect
argument_list|(
literal|'('
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|PEEK_TOKEN
argument_list|()
operator|==
name|TYPENAME
condition|)
block|{
name|type
operator|=
name|PEEK_LVAL
argument_list|()
operator|.
name|tsym
operator|.
name|type
expr_stmt|;
name|FORWARD_TOKEN
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|parse_expr
argument_list|()
expr_stmt|;
name|type
operator|=
name|NULL
expr_stmt|;
block|}
name|expect
argument_list|(
literal|')'
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|type
return|;
block|}
end_function

begin_comment
comment|/* Parse something that looks like a function call.    Assume we have parsed the function, and are at the '('. */
end_comment

begin_function
specifier|static
name|void
name|parse_call
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|arg_count
decl_stmt|;
name|require
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
comment|/* This is to save the value of arglist_len      being accumulated for each dimension. */
name|start_arglist
argument_list|()
expr_stmt|;
if|if
condition|(
name|parse_opt_untyped_expr
argument_list|()
condition|)
block|{
name|int
name|tok
init|=
name|PEEK_TOKEN
argument_list|()
decl_stmt|;
name|arglist_len
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|tok
operator|==
name|UP
operator|||
name|tok
operator|==
literal|':'
condition|)
block|{
name|FORWARD_TOKEN
argument_list|()
expr_stmt|;
name|parse_expr
argument_list|()
expr_stmt|;
name|expect
argument_list|(
literal|')'
argument_list|,
literal|"expected ')' to terminate slice"
argument_list|)
expr_stmt|;
name|end_arglist
argument_list|()
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|tok
operator|==
name|UP
condition|?
name|TERNOP_SLICE_COUNT
else|:
name|TERNOP_SLICE
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|check_token
argument_list|(
literal|','
argument_list|)
condition|)
block|{
name|parse_untyped_expr
argument_list|()
expr_stmt|;
name|arglist_len
operator|++
expr_stmt|;
block|}
block|}
else|else
name|arglist_len
operator|=
literal|0
expr_stmt|;
name|expect
argument_list|(
literal|')'
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|arg_count
operator|=
name|end_arglist
argument_list|()
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|MULTI_SUBSCRIPT
argument_list|)
expr_stmt|;
name|write_exp_elt_longcst
argument_list|(
name|arg_count
argument_list|)
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|MULTI_SUBSCRIPT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|parse_named_record_element
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|stoken
name|label
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|label
operator|=
name|PEEK_LVAL
argument_list|()
operator|.
name|sval
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"expected a field name here `%s'"
argument_list|,
name|lexptr
argument_list|)
expr_stmt|;
name|expect
argument_list|(
name|DOT_FIELD_NAME
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_token
argument_list|(
literal|','
argument_list|)
condition|)
name|parse_named_record_element
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|check_token
argument_list|(
literal|':'
argument_list|)
condition|)
name|parse_expr
argument_list|()
expr_stmt|;
else|else
name|error
argument_list|(
literal|"syntax error near `%s' in named record tuple element"
argument_list|,
name|lexptr
argument_list|)
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|OP_LABELED
argument_list|)
expr_stmt|;
name|write_exp_string
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|OP_LABELED
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Returns one or more TREE_LIST nodes, in reverse order. */
end_comment

begin_function
specifier|static
name|void
name|parse_tuple_element
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
if|if
condition|(
name|PEEK_TOKEN
argument_list|()
operator|==
name|DOT_FIELD_NAME
condition|)
block|{
comment|/* Parse a labelled structure tuple. */
name|parse_named_record_element
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|check_token
argument_list|(
literal|'('
argument_list|)
condition|)
block|{
if|if
condition|(
name|check_token
argument_list|(
literal|'*'
argument_list|)
condition|)
block|{
name|expect
argument_list|(
literal|')'
argument_list|,
literal|"missing ')' after '*' case label list"
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
condition|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
condition|)
block|{
comment|/* do this as a range from low to high */
name|struct
name|type
modifier|*
name|range_type
init|=
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|LONGEST
name|low_bound
decl_stmt|,
name|high_bound
decl_stmt|;
if|if
condition|(
name|get_discrete_bounds
argument_list|(
name|range_type
argument_list|,
operator|&
name|low_bound
argument_list|,
operator|&
name|high_bound
argument_list|)
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"cannot determine bounds for (*)"
argument_list|)
expr_stmt|;
comment|/* lower bound */
name|write_exp_elt_opcode
argument_list|(
name|OP_LONG
argument_list|)
expr_stmt|;
name|write_exp_elt_type
argument_list|(
name|range_type
argument_list|)
expr_stmt|;
name|write_exp_elt_longcst
argument_list|(
name|low_bound
argument_list|)
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|OP_LONG
argument_list|)
expr_stmt|;
comment|/* upper bound */
name|write_exp_elt_opcode
argument_list|(
name|OP_LONG
argument_list|)
expr_stmt|;
name|write_exp_elt_type
argument_list|(
name|range_type
argument_list|)
expr_stmt|;
name|write_exp_elt_longcst
argument_list|(
name|high_bound
argument_list|)
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|OP_LONG
argument_list|)
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|BINOP_RANGE
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"(*) in invalid context"
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"(*) only possible with modename in front of tuple (mode[..])"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|parse_case_label
argument_list|()
expr_stmt|;
while|while
condition|(
name|check_token
argument_list|(
literal|','
argument_list|)
condition|)
block|{
name|parse_case_label
argument_list|()
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|BINOP_COMMA
argument_list|)
expr_stmt|;
block|}
name|expect
argument_list|(
literal|')'
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|parse_untyped_expr
argument_list|()
expr_stmt|;
if|if
condition|(
name|check_token
argument_list|(
literal|':'
argument_list|)
condition|)
block|{
comment|/* A powerset range or a labeled Array. */
name|parse_untyped_expr
argument_list|()
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|BINOP_RANGE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Matches:  a COMMA-separated list of tuple elements.    Returns a list (of TREE_LIST nodes). */
end_comment

begin_function
specifier|static
name|void
name|parse_opt_element_list
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|arglist_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|PEEK_TOKEN
argument_list|()
operator|==
literal|']'
condition|)
return|return;
for|for
control|(
init|;
condition|;
control|)
block|{
name|parse_tuple_element
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|arglist_len
operator|++
expr_stmt|;
if|if
condition|(
name|PEEK_TOKEN
argument_list|()
operator|==
literal|']'
condition|)
break|break;
if|if
condition|(
operator|!
name|check_token
argument_list|(
literal|','
argument_list|)
condition|)
name|error
argument_list|(
literal|"bad syntax in tuple"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Parses: '[' elements ']'    If modename is non-NULL it prefixed the tuple.  */
end_comment

begin_function
specifier|static
name|void
name|parse_tuple
parameter_list|(
name|struct
name|type
modifier|*
name|mode
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
if|if
condition|(
name|mode
condition|)
name|type
operator|=
name|check_typedef
argument_list|(
name|mode
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
literal|0
expr_stmt|;
name|require
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
name|start_arglist
argument_list|()
expr_stmt|;
name|parse_opt_element_list
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|']'
argument_list|,
literal|"missing ']' after tuple"
argument_list|)
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|OP_ARRAY
argument_list|)
expr_stmt|;
name|write_exp_elt_longcst
argument_list|(
operator|(
name|LONGEST
operator|)
literal|0
argument_list|)
expr_stmt|;
name|write_exp_elt_longcst
argument_list|(
operator|(
name|LONGEST
operator|)
name|end_arglist
argument_list|()
operator|-
literal|1
argument_list|)
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|OP_ARRAY
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
condition|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_ARRAY
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_STRUCT
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_SET
condition|)
name|error
argument_list|(
literal|"invalid tuple mode"
argument_list|)
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|UNOP_CAST
argument_list|)
expr_stmt|;
name|write_exp_elt_type
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|UNOP_CAST
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|parse_primval
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|enum
name|exp_opcode
name|op
decl_stmt|;
name|char
modifier|*
name|op_name
decl_stmt|;
switch|switch
condition|(
name|PEEK_TOKEN
argument_list|()
condition|)
block|{
case|case
name|INTEGER_LITERAL
case|:
case|case
name|CHARACTER_LITERAL
case|:
name|write_exp_elt_opcode
argument_list|(
name|OP_LONG
argument_list|)
expr_stmt|;
name|write_exp_elt_type
argument_list|(
name|PEEK_LVAL
argument_list|()
operator|.
name|typed_val
operator|.
name|type
argument_list|)
expr_stmt|;
name|write_exp_elt_longcst
argument_list|(
name|PEEK_LVAL
argument_list|()
operator|.
name|typed_val
operator|.
name|val
argument_list|)
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|OP_LONG
argument_list|)
expr_stmt|;
name|FORWARD_TOKEN
argument_list|()
expr_stmt|;
break|break;
case|case
name|BOOLEAN_LITERAL
case|:
name|write_exp_elt_opcode
argument_list|(
name|OP_BOOL
argument_list|)
expr_stmt|;
name|write_exp_elt_longcst
argument_list|(
operator|(
name|LONGEST
operator|)
name|PEEK_LVAL
argument_list|()
operator|.
name|ulval
argument_list|)
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|OP_BOOL
argument_list|)
expr_stmt|;
name|FORWARD_TOKEN
argument_list|()
expr_stmt|;
break|break;
case|case
name|FLOAT_LITERAL
case|:
name|write_exp_elt_opcode
argument_list|(
name|OP_DOUBLE
argument_list|)
expr_stmt|;
name|write_exp_elt_type
argument_list|(
name|builtin_type_double
argument_list|)
expr_stmt|;
name|write_exp_elt_dblcst
argument_list|(
name|PEEK_LVAL
argument_list|()
operator|.
name|dval
argument_list|)
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|OP_DOUBLE
argument_list|)
expr_stmt|;
name|FORWARD_TOKEN
argument_list|()
expr_stmt|;
break|break;
case|case
name|EMPTINESS_LITERAL
case|:
name|write_exp_elt_opcode
argument_list|(
name|OP_LONG
argument_list|)
expr_stmt|;
name|write_exp_elt_type
argument_list|(
name|lookup_pointer_type
argument_list|(
name|builtin_type_void
argument_list|)
argument_list|)
expr_stmt|;
name|write_exp_elt_longcst
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|OP_LONG
argument_list|)
expr_stmt|;
name|FORWARD_TOKEN
argument_list|()
expr_stmt|;
break|break;
case|case
name|CHARACTER_STRING_LITERAL
case|:
name|write_exp_elt_opcode
argument_list|(
name|OP_STRING
argument_list|)
expr_stmt|;
name|write_exp_string
argument_list|(
name|PEEK_LVAL
argument_list|()
operator|.
name|sval
argument_list|)
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|OP_STRING
argument_list|)
expr_stmt|;
name|FORWARD_TOKEN
argument_list|()
expr_stmt|;
break|break;
case|case
name|BIT_STRING_LITERAL
case|:
name|write_exp_elt_opcode
argument_list|(
name|OP_BITSTRING
argument_list|)
expr_stmt|;
name|write_exp_bitstring
argument_list|(
name|PEEK_LVAL
argument_list|()
operator|.
name|sval
argument_list|)
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|OP_BITSTRING
argument_list|)
expr_stmt|;
name|FORWARD_TOKEN
argument_list|()
expr_stmt|;
break|break;
case|case
name|ARRAY
case|:
name|FORWARD_TOKEN
argument_list|()
expr_stmt|;
comment|/* This is pseudo-Chill, similar to C's '(TYPE[])EXPR'          which casts to an artificial array. */
name|expect
argument_list|(
literal|'('
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|')'
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|PEEK_TOKEN
argument_list|()
operator|!=
name|TYPENAME
condition|)
name|error
argument_list|(
literal|"missing MODENAME after ARRAY()"
argument_list|)
expr_stmt|;
name|type
operator|=
name|PEEK_LVAL
argument_list|()
operator|.
name|tsym
operator|.
name|type
expr_stmt|;
name|FORWARD_TOKEN
argument_list|()
expr_stmt|;
name|expect
argument_list|(
literal|'('
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|parse_expr
argument_list|()
expr_stmt|;
name|expect
argument_list|(
literal|')'
argument_list|,
literal|"missing right parenthesis"
argument_list|)
expr_stmt|;
name|type
operator|=
name|create_array_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|type
argument_list|,
name|create_range_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|builtin_type_int
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|TYPE_ARRAY_UPPER_BOUND_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|BOUND_CANNOT_BE_DETERMINED
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|UNOP_CAST
argument_list|)
expr_stmt|;
name|write_exp_elt_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|UNOP_CAST
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
literal|0
block|case CONST:     case EXPR:       val = PEEK_LVAL ();       FORWARD_TOKEN ();       break;
endif|#
directive|endif
case|case
literal|'('
case|:
name|FORWARD_TOKEN
argument_list|()
expr_stmt|;
name|parse_expr
argument_list|()
expr_stmt|;
name|expect
argument_list|(
literal|')'
argument_list|,
literal|"missing right parenthesis"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'['
case|:
name|parse_tuple
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|GENERAL_PROCEDURE_NAME
case|:
case|case
name|LOCATION_NAME
case|:
name|write_exp_elt_opcode
argument_list|(
name|OP_VAR_VALUE
argument_list|)
expr_stmt|;
name|write_exp_elt_block
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|write_exp_elt_sym
argument_list|(
name|PEEK_LVAL
argument_list|()
operator|.
name|ssym
operator|.
name|sym
argument_list|)
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|OP_VAR_VALUE
argument_list|)
expr_stmt|;
name|FORWARD_TOKEN
argument_list|()
expr_stmt|;
break|break;
case|case
name|GDB_VARIABLE
case|:
comment|/* gdb specific */
name|FORWARD_TOKEN
argument_list|()
expr_stmt|;
break|break;
case|case
name|NUM
case|:
name|parse_unary_call
argument_list|()
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|UNOP_CAST
argument_list|)
expr_stmt|;
name|write_exp_elt_type
argument_list|(
name|builtin_type_int
argument_list|)
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|UNOP_CAST
argument_list|)
expr_stmt|;
break|break;
case|case
name|CARD
case|:
name|parse_unary_call
argument_list|()
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|UNOP_CARD
argument_list|)
expr_stmt|;
break|break;
case|case
name|MAX_TOKEN
case|:
name|parse_unary_call
argument_list|()
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|UNOP_CHMAX
argument_list|)
expr_stmt|;
break|break;
case|case
name|MIN_TOKEN
case|:
name|parse_unary_call
argument_list|()
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|UNOP_CHMIN
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRED
case|:
name|op_name
operator|=
literal|"PRED"
expr_stmt|;
goto|goto
name|unimplemented_unary_builtin
goto|;
case|case
name|SUCC
case|:
name|op_name
operator|=
literal|"SUCC"
expr_stmt|;
goto|goto
name|unimplemented_unary_builtin
goto|;
case|case
name|ABS
case|:
name|op_name
operator|=
literal|"ABS"
expr_stmt|;
goto|goto
name|unimplemented_unary_builtin
goto|;
name|unimplemented_unary_builtin
label|:
name|parse_unary_call
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"not implemented:  %s builtin function"
argument_list|,
name|op_name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ADDR_TOKEN
case|:
name|parse_unary_call
argument_list|()
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|UNOP_ADDR
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIZE
case|:
name|type
operator|=
name|parse_mode_or_normal_call
argument_list|()
expr_stmt|;
if|if
condition|(
name|type
condition|)
block|{
name|write_exp_elt_opcode
argument_list|(
name|OP_LONG
argument_list|)
expr_stmt|;
name|write_exp_elt_type
argument_list|(
name|builtin_type_int
argument_list|)
expr_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|write_exp_elt_longcst
argument_list|(
operator|(
name|LONGEST
operator|)
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|OP_LONG
argument_list|)
expr_stmt|;
block|}
else|else
name|write_exp_elt_opcode
argument_list|(
name|UNOP_SIZEOF
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOWER
case|:
name|op
operator|=
name|UNOP_LOWER
expr_stmt|;
goto|goto
name|lower_upper
goto|;
case|case
name|UPPER
case|:
name|op
operator|=
name|UNOP_UPPER
expr_stmt|;
goto|goto
name|lower_upper
goto|;
name|lower_upper
label|:
name|type
operator|=
name|parse_mode_or_normal_call
argument_list|()
expr_stmt|;
name|write_lower_upper_value
argument_list|(
name|op
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
name|LENGTH
case|:
name|parse_unary_call
argument_list|()
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|UNOP_LENGTH
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPENAME
case|:
name|type
operator|=
name|PEEK_LVAL
argument_list|()
operator|.
name|tsym
operator|.
name|type
expr_stmt|;
name|FORWARD_TOKEN
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|PEEK_TOKEN
argument_list|()
condition|)
block|{
case|case
literal|'['
case|:
name|parse_tuple
argument_list|(
name|type
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'('
case|:
name|FORWARD_TOKEN
argument_list|()
expr_stmt|;
name|parse_expr
argument_list|()
expr_stmt|;
name|expect
argument_list|(
literal|')'
argument_list|,
literal|"missing right parenthesis"
argument_list|)
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|UNOP_CAST
argument_list|)
expr_stmt|;
name|write_exp_elt_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|UNOP_CAST
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"typename in invalid context"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|error
argument_list|(
literal|"invalid expression syntax at `%s'"
argument_list|,
name|lexptr
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|PEEK_TOKEN
argument_list|()
condition|)
block|{
case|case
name|DOT_FIELD_NAME
case|:
name|write_exp_elt_opcode
argument_list|(
name|STRUCTOP_STRUCT
argument_list|)
expr_stmt|;
name|write_exp_string
argument_list|(
name|PEEK_LVAL
argument_list|()
operator|.
name|sval
argument_list|)
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|STRUCTOP_STRUCT
argument_list|)
expr_stmt|;
name|FORWARD_TOKEN
argument_list|()
expr_stmt|;
continue|continue;
case|case
name|POINTER
case|:
name|FORWARD_TOKEN
argument_list|()
expr_stmt|;
if|if
condition|(
name|PEEK_TOKEN
argument_list|()
operator|==
name|TYPENAME
condition|)
block|{
name|type
operator|=
name|PEEK_LVAL
argument_list|()
operator|.
name|tsym
operator|.
name|type
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|UNOP_CAST
argument_list|)
expr_stmt|;
name|write_exp_elt_type
argument_list|(
name|lookup_pointer_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|UNOP_CAST
argument_list|)
expr_stmt|;
name|FORWARD_TOKEN
argument_list|()
expr_stmt|;
block|}
name|write_exp_elt_opcode
argument_list|(
name|UNOP_IND
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|OPEN_PAREN
case|:
name|parse_call
argument_list|()
expr_stmt|;
continue|continue;
case|case
name|CHARACTER_STRING_LITERAL
case|:
case|case
name|CHARACTER_LITERAL
case|:
case|case
name|BIT_STRING_LITERAL
case|:
comment|/* Handle string repetition. (See comment in parse_operand5.) */
name|parse_primval
argument_list|()
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|MULTI_SUBSCRIPT
argument_list|)
expr_stmt|;
name|write_exp_elt_longcst
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|MULTI_SUBSCRIPT
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|END_TOKEN
case|:
case|case
name|TOKEN_NOT_READ
case|:
case|case
name|INTEGER_LITERAL
case|:
case|case
name|BOOLEAN_LITERAL
case|:
case|case
name|FLOAT_LITERAL
case|:
case|case
name|GENERAL_PROCEDURE_NAME
case|:
case|case
name|LOCATION_NAME
case|:
case|case
name|EMPTINESS_LITERAL
case|:
case|case
name|TYPENAME
case|:
case|case
name|CASE
case|:
case|case
name|OF
case|:
case|case
name|ESAC
case|:
case|case
name|LOGIOR
case|:
case|case
name|ORIF
case|:
case|case
name|LOGXOR
case|:
case|case
name|LOGAND
case|:
case|case
name|ANDIF
case|:
case|case
name|NOTEQUAL
case|:
case|case
name|GEQ
case|:
case|case
name|LEQ
case|:
case|case
name|IN
case|:
case|case
name|SLASH_SLASH
case|:
case|case
name|MOD
case|:
case|case
name|REM
case|:
case|case
name|NOT
case|:
case|case
name|RECEIVE
case|:
case|case
name|UP
case|:
case|case
name|IF
case|:
case|case
name|THEN
case|:
case|case
name|ELSE
case|:
case|case
name|FI
case|:
case|case
name|ELSIF
case|:
case|case
name|ILLEGAL_TOKEN
case|:
case|case
name|NUM
case|:
case|case
name|PRED
case|:
case|case
name|SUCC
case|:
case|case
name|ABS
case|:
case|case
name|CARD
case|:
case|case
name|MAX_TOKEN
case|:
case|case
name|MIN_TOKEN
case|:
case|case
name|ADDR_TOKEN
case|:
case|case
name|SIZE
case|:
case|case
name|UPPER
case|:
case|case
name|LOWER
case|:
case|case
name|LENGTH
case|:
case|case
name|ARRAY
case|:
case|case
name|GDB_VARIABLE
case|:
case|case
name|GDB_ASSIGNMENT
case|:
break|break;
block|}
break|break;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|parse_operand6
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|check_token
argument_list|(
name|RECEIVE
argument_list|)
condition|)
block|{
name|parse_primval
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"not implemented:  RECEIVE expression"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|check_token
argument_list|(
name|POINTER
argument_list|)
condition|)
block|{
name|parse_primval
argument_list|()
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|UNOP_ADDR
argument_list|)
expr_stmt|;
block|}
else|else
name|parse_primval
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|parse_operand5
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|exp_opcode
name|op
decl_stmt|;
comment|/* We are supposed to be looking for a<string repetition operator>,      but in general we can't distinguish that from a parenthesized      expression.  This is especially difficult if we allow the      string operand to be a constant expression (as requested by      some users), and not just a string literal.      Consider:  LPRN expr RPRN LPRN expr RPRN      Is that a function call or string repetition?      Instead, we handle string repetition in parse_primval,      and build_generalized_call. */
switch|switch
condition|(
name|PEEK_TOKEN
argument_list|()
condition|)
block|{
case|case
name|NOT
case|:
name|op
operator|=
name|UNOP_LOGICAL_NOT
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|op
operator|=
name|UNOP_NEG
expr_stmt|;
break|break;
default|default:
name|op
operator|=
name|OP_NULL
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|!=
name|OP_NULL
condition|)
name|FORWARD_TOKEN
argument_list|()
expr_stmt|;
name|parse_operand6
argument_list|()
expr_stmt|;
if|if
condition|(
name|op
operator|!=
name|OP_NULL
condition|)
name|write_exp_elt_opcode
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|parse_operand4
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|exp_opcode
name|op
decl_stmt|;
name|parse_operand5
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|PEEK_TOKEN
argument_list|()
condition|)
block|{
case|case
literal|'*'
case|:
name|op
operator|=
name|BINOP_MUL
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
name|op
operator|=
name|BINOP_DIV
expr_stmt|;
break|break;
case|case
name|MOD
case|:
name|op
operator|=
name|BINOP_MOD
expr_stmt|;
break|break;
case|case
name|REM
case|:
name|op
operator|=
name|BINOP_REM
expr_stmt|;
break|break;
default|default:
return|return;
block|}
name|FORWARD_TOKEN
argument_list|()
expr_stmt|;
name|parse_operand5
argument_list|()
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|parse_operand3
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|exp_opcode
name|op
decl_stmt|;
name|parse_operand4
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|PEEK_TOKEN
argument_list|()
condition|)
block|{
case|case
literal|'+'
case|:
name|op
operator|=
name|BINOP_ADD
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|op
operator|=
name|BINOP_SUB
expr_stmt|;
break|break;
case|case
name|SLASH_SLASH
case|:
name|op
operator|=
name|BINOP_CONCAT
expr_stmt|;
break|break;
default|default:
return|return;
block|}
name|FORWARD_TOKEN
argument_list|()
expr_stmt|;
name|parse_operand4
argument_list|()
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|parse_operand2
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|exp_opcode
name|op
decl_stmt|;
name|parse_operand3
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|check_token
argument_list|(
name|IN
argument_list|)
condition|)
block|{
name|parse_operand3
argument_list|()
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|BINOP_IN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|PEEK_TOKEN
argument_list|()
condition|)
block|{
case|case
literal|'>'
case|:
name|op
operator|=
name|BINOP_GTR
expr_stmt|;
break|break;
case|case
name|GEQ
case|:
name|op
operator|=
name|BINOP_GEQ
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|op
operator|=
name|BINOP_LESS
expr_stmt|;
break|break;
case|case
name|LEQ
case|:
name|op
operator|=
name|BINOP_LEQ
expr_stmt|;
break|break;
case|case
literal|'='
case|:
name|op
operator|=
name|BINOP_EQUAL
expr_stmt|;
break|break;
case|case
name|NOTEQUAL
case|:
name|op
operator|=
name|BINOP_NOTEQUAL
expr_stmt|;
break|break;
default|default:
return|return;
block|}
name|FORWARD_TOKEN
argument_list|()
expr_stmt|;
name|parse_operand3
argument_list|()
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|parse_operand1
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|exp_opcode
name|op
decl_stmt|;
name|parse_operand2
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|PEEK_TOKEN
argument_list|()
condition|)
block|{
case|case
name|LOGAND
case|:
name|op
operator|=
name|BINOP_BITWISE_AND
expr_stmt|;
break|break;
case|case
name|ANDIF
case|:
name|op
operator|=
name|BINOP_LOGICAL_AND
expr_stmt|;
break|break;
default|default:
return|return;
block|}
name|FORWARD_TOKEN
argument_list|()
expr_stmt|;
name|parse_operand2
argument_list|()
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|parse_operand0
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|exp_opcode
name|op
decl_stmt|;
name|parse_operand1
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|PEEK_TOKEN
argument_list|()
condition|)
block|{
case|case
name|LOGIOR
case|:
name|op
operator|=
name|BINOP_BITWISE_IOR
expr_stmt|;
break|break;
case|case
name|LOGXOR
case|:
name|op
operator|=
name|BINOP_BITWISE_XOR
expr_stmt|;
break|break;
case|case
name|ORIF
case|:
name|op
operator|=
name|BINOP_LOGICAL_OR
expr_stmt|;
break|break;
default|default:
return|return;
block|}
name|FORWARD_TOKEN
argument_list|()
expr_stmt|;
name|parse_operand1
argument_list|()
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|op
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|parse_expr
parameter_list|(
name|void
parameter_list|)
block|{
name|parse_operand0
argument_list|()
expr_stmt|;
if|if
condition|(
name|check_token
argument_list|(
name|GDB_ASSIGNMENT
argument_list|)
condition|)
block|{
name|parse_expr
argument_list|()
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|BINOP_ASSIGN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|parse_then_alternative
parameter_list|(
name|void
parameter_list|)
block|{
name|expect
argument_list|(
name|THEN
argument_list|,
literal|"missing 'THEN' in 'IF' expression"
argument_list|)
expr_stmt|;
name|parse_expr
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|parse_else_alternative
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|check_token
argument_list|(
name|ELSIF
argument_list|)
condition|)
name|parse_if_expression_body
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|check_token
argument_list|(
name|ELSE
argument_list|)
condition|)
name|parse_expr
argument_list|()
expr_stmt|;
else|else
name|error
argument_list|(
literal|"missing ELSE/ELSIF in IF expression"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Matches:<boolean expression><then alternative><else alternative> */
end_comment

begin_function
specifier|static
name|void
name|parse_if_expression_body
parameter_list|(
name|void
parameter_list|)
block|{
name|parse_expr
argument_list|()
expr_stmt|;
name|parse_then_alternative
argument_list|()
expr_stmt|;
name|parse_else_alternative
argument_list|()
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|TERNOP_COND
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|parse_if_expression
parameter_list|(
name|void
parameter_list|)
block|{
name|require
argument_list|(
name|IF
argument_list|)
expr_stmt|;
name|parse_if_expression_body
argument_list|()
expr_stmt|;
name|expect
argument_list|(
name|FI
argument_list|,
literal|"missing 'FI' at end of conditional expression"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* An<untyped_expr> is a superset of<expr>.  It also includes<conditional expressions> and untyped<tuples>, whose types    are not given by their constituents.  Hence, these are only    allowed in certain contexts that expect a certain type.    You should call convert() to fix up the<untyped_expr>. */
end_comment

begin_function
specifier|static
name|void
name|parse_untyped_expr
parameter_list|(
name|void
parameter_list|)
block|{
switch|switch
condition|(
name|PEEK_TOKEN
argument_list|()
condition|)
block|{
case|case
name|IF
case|:
name|parse_if_expression
argument_list|()
expr_stmt|;
return|return;
case|case
name|CASE
case|:
name|error
argument_list|(
literal|"not implemented:  CASE expression"
argument_list|)
expr_stmt|;
case|case
literal|'('
case|:
switch|switch
condition|(
name|PEEK_TOKEN1
argument_list|()
condition|)
block|{
case|case
name|IF
case|:
case|case
name|CASE
case|:
goto|goto
name|skip_lprn
goto|;
case|case
literal|'['
case|:
name|skip_lprn
label|:
name|FORWARD_TOKEN
argument_list|()
expr_stmt|;
name|parse_untyped_expr
argument_list|()
expr_stmt|;
name|expect
argument_list|(
literal|')'
argument_list|,
literal|"missing ')'"
argument_list|)
expr_stmt|;
return|return;
default|default:
empty_stmt|;
comment|/* fall through */
block|}
default|default:
name|parse_operand0
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|chill_parse
parameter_list|(
name|void
parameter_list|)
block|{
name|terminal_buffer
index|[
literal|0
index|]
operator|=
name|TOKEN_NOT_READ
expr_stmt|;
if|if
condition|(
name|PEEK_TOKEN
argument_list|()
operator|==
name|TYPENAME
operator|&&
name|PEEK_TOKEN1
argument_list|()
operator|==
name|END_TOKEN
condition|)
block|{
name|write_exp_elt_opcode
argument_list|(
name|OP_TYPE
argument_list|)
expr_stmt|;
name|write_exp_elt_type
argument_list|(
name|PEEK_LVAL
argument_list|()
operator|.
name|tsym
operator|.
name|type
argument_list|)
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|OP_TYPE
argument_list|)
expr_stmt|;
name|FORWARD_TOKEN
argument_list|()
expr_stmt|;
block|}
else|else
name|parse_expr
argument_list|()
expr_stmt|;
if|if
condition|(
name|terminal_buffer
index|[
literal|0
index|]
operator|!=
name|END_TOKEN
condition|)
block|{
if|if
condition|(
name|comma_terminates
operator|&&
name|terminal_buffer
index|[
literal|0
index|]
operator|==
literal|','
condition|)
name|lexptr
operator|--
expr_stmt|;
comment|/* Put the comma back.  */
else|else
name|error
argument_list|(
literal|"Junk after end of expression."
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Implementation of a dynamically expandable buffer for processing input    characters acquired through lexptr and building a value to return in    yylval. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tempbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current buffer contents */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tempbufsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of allocated buffer */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tempbufindex
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current index into buffer */
end_comment

begin_define
define|#
directive|define
name|GROWBY_MIN_SIZE
value|64
end_define

begin_comment
comment|/* Minimum amount to grow buffer by */
end_comment

begin_define
define|#
directive|define
name|CHECKBUF
parameter_list|(
name|size
parameter_list|)
define|\
value|do { \     if (tempbufindex + (size)>= tempbufsize) \       { \ 	growbuf_by_size (size); \       } \   } while (0);
end_define

begin_comment
comment|/* Grow the static temp buffer if necessary, including allocating the first one    on demand. */
end_comment

begin_function
specifier|static
name|void
name|growbuf_by_size
parameter_list|(
name|int
name|count
parameter_list|)
block|{
name|int
name|growby
decl_stmt|;
name|growby
operator|=
name|max
argument_list|(
name|count
argument_list|,
name|GROWBY_MIN_SIZE
argument_list|)
expr_stmt|;
name|tempbufsize
operator|+=
name|growby
expr_stmt|;
if|if
condition|(
name|tempbuf
operator|==
name|NULL
condition|)
block|{
name|tempbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|tempbufsize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tempbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|tempbuf
argument_list|,
name|tempbufsize
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Try to consume a simple name string token.  If successful, returns    a pointer to a nullbyte terminated copy of the name that can be used    in symbol table lookups.  If not successful, returns NULL. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|match_simple_name_string
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|tokptr
init|=
name|lexptr
decl_stmt|;
if|if
condition|(
name|isalpha
argument_list|(
operator|*
name|tokptr
argument_list|)
operator|||
operator|*
name|tokptr
operator|==
literal|'_'
condition|)
block|{
name|char
modifier|*
name|result
decl_stmt|;
do|do
block|{
name|tokptr
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|isalnum
argument_list|(
operator|*
name|tokptr
argument_list|)
operator|||
operator|(
operator|*
name|tokptr
operator|==
literal|'_'
operator|)
condition|)
do|;
name|yylval
operator|.
name|sval
operator|.
name|ptr
operator|=
name|lexptr
expr_stmt|;
name|yylval
operator|.
name|sval
operator|.
name|length
operator|=
name|tokptr
operator|-
name|lexptr
expr_stmt|;
name|lexptr
operator|=
name|tokptr
expr_stmt|;
name|result
operator|=
name|copy_name
argument_list|(
name|yylval
operator|.
name|sval
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Start looking for a value composed of valid digits as set by the base    in use.  Note that '_' characters are valid anywhere, in any quantity,    and are simply ignored.  Since we must find at least one valid digit,    or reject this token as an integer literal, we keep track of how many    digits we have encountered. */
end_comment

begin_function
specifier|static
name|int
name|decode_integer_value
parameter_list|(
name|int
name|base
parameter_list|,
name|char
modifier|*
modifier|*
name|tokptrptr
parameter_list|,
name|LONGEST
modifier|*
name|ivalptr
parameter_list|)
block|{
name|char
modifier|*
name|tokptr
init|=
operator|*
name|tokptrptr
decl_stmt|;
name|int
name|temp
decl_stmt|;
name|int
name|digits
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|tokptr
operator|!=
literal|'\0'
condition|)
block|{
name|temp
operator|=
operator|*
name|tokptr
expr_stmt|;
if|if
condition|(
name|isupper
argument_list|(
name|temp
argument_list|)
condition|)
name|temp
operator|=
name|tolower
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|tokptr
operator|++
expr_stmt|;
switch|switch
condition|(
name|temp
condition|)
block|{
case|case
literal|'_'
case|:
continue|continue;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|temp
operator|-=
literal|'0'
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
name|temp
operator|-=
literal|'a'
expr_stmt|;
name|temp
operator|+=
literal|10
expr_stmt|;
break|break;
default|default:
name|temp
operator|=
name|base
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|temp
operator|<
name|base
condition|)
block|{
name|digits
operator|++
expr_stmt|;
operator|*
name|ivalptr
operator|*=
name|base
expr_stmt|;
operator|*
name|ivalptr
operator|+=
name|temp
expr_stmt|;
block|}
else|else
block|{
comment|/* Found something not in domain for current base. */
name|tokptr
operator|--
expr_stmt|;
comment|/* Unconsume what gave us indigestion. */
break|break;
block|}
block|}
comment|/* If we didn't find any digits, then we don't have a valid integer      value, so reject the entire token.  Otherwise, update the lexical      scan pointer, and return non-zero for success. */
if|if
condition|(
name|digits
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
operator|*
name|tokptrptr
operator|=
name|tokptr
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|decode_integer_literal
parameter_list|(
name|LONGEST
modifier|*
name|valptr
parameter_list|,
name|char
modifier|*
modifier|*
name|tokptrptr
parameter_list|)
block|{
name|char
modifier|*
name|tokptr
init|=
operator|*
name|tokptrptr
decl_stmt|;
name|int
name|base
init|=
literal|0
decl_stmt|;
name|LONGEST
name|ival
init|=
literal|0
decl_stmt|;
name|int
name|explicit_base
init|=
literal|0
decl_stmt|;
comment|/* Look for an explicit base specifier, which is optional. */
switch|switch
condition|(
operator|*
name|tokptr
condition|)
block|{
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
name|explicit_base
operator|++
expr_stmt|;
name|base
operator|=
literal|10
expr_stmt|;
name|tokptr
operator|++
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
case|case
literal|'B'
case|:
name|explicit_base
operator|++
expr_stmt|;
name|base
operator|=
literal|2
expr_stmt|;
name|tokptr
operator|++
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
case|case
literal|'H'
case|:
name|explicit_base
operator|++
expr_stmt|;
name|base
operator|=
literal|16
expr_stmt|;
name|tokptr
operator|++
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
case|case
literal|'O'
case|:
name|explicit_base
operator|++
expr_stmt|;
name|base
operator|=
literal|8
expr_stmt|;
name|tokptr
operator|++
expr_stmt|;
break|break;
default|default:
name|base
operator|=
literal|10
expr_stmt|;
break|break;
block|}
comment|/* If we found an explicit base ensure that the character after the      explicit base is a single quote. */
if|if
condition|(
name|explicit_base
operator|&&
operator|(
operator|*
name|tokptr
operator|++
operator|!=
literal|'\''
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Attempt to decode whatever follows as an integer value in the      indicated base, updating the token pointer in the process and      computing the value into ival.  Also, if we have an explicit      base, then the next character must not be a single quote, or we      have a bitstring literal, so reject the entire token in this case.      Otherwise, update the lexical scan pointer, and return non-zero      for success. */
if|if
condition|(
operator|!
name|decode_integer_value
argument_list|(
name|base
argument_list|,
operator|&
name|tokptr
argument_list|,
operator|&
name|ival
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|explicit_base
operator|&&
operator|(
operator|*
name|tokptr
operator|==
literal|'\''
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
operator|*
name|valptr
operator|=
name|ival
expr_stmt|;
operator|*
name|tokptrptr
operator|=
name|tokptr
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  If it wasn't for the fact that floating point values can contain '_'    characters, we could just let strtod do all the hard work by letting it    try to consume as much of the current token buffer as possible and    find a legal conversion.  Unfortunately we need to filter out the '_'    characters before calling strtod, which we do by copying the other    legal chars to a local buffer to be converted.  However since we also    need to keep track of where the last unconsumed character in the input    buffer is, we have transfer only as many characters as may compose a    legal floating point value. */
end_comment

begin_function
specifier|static
name|enum
name|ch_terminal
name|match_float_literal
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|tokptr
init|=
name|lexptr
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|copy
decl_stmt|;
name|double
name|dval
decl_stmt|;
specifier|extern
name|double
name|strtod
parameter_list|()
function_decl|;
comment|/* Make local buffer in which to build the string to convert.  This is      required because underscores are valid in chill floating point numbers      but not in the string passed to strtod to convert.  The string will be      no longer than our input string. */
name|copy
operator|=
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|tokptr
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Transfer all leading digits to the conversion buffer, discarding any      underscores. */
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|tokptr
argument_list|)
operator|||
operator|*
name|tokptr
operator|==
literal|'_'
condition|)
block|{
if|if
condition|(
operator|*
name|tokptr
operator|!=
literal|'_'
condition|)
block|{
operator|*
name|copy
operator|++
operator|=
operator|*
name|tokptr
expr_stmt|;
block|}
name|tokptr
operator|++
expr_stmt|;
block|}
comment|/* Now accept either a '.', or one of [eEdD].  Dot is legal regardless      of whether we found any leading digits, and we simply accept it and      continue on to look for the fractional part and/or exponent.  One of      [eEdD] is legal only if we have seen digits, and means that there      is no fractional part.  If we find neither of these, then this is      not a floating point number, so return failure. */
switch|switch
condition|(
operator|*
name|tokptr
operator|++
condition|)
block|{
case|case
literal|'.'
case|:
comment|/* Accept and then look for fractional part and/or exponent. */
operator|*
name|copy
operator|++
operator|=
literal|'.'
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
if|if
condition|(
name|copy
operator|==
name|buf
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|copy
operator|++
operator|=
literal|'e'
expr_stmt|;
goto|goto
name|collect_exponent
goto|;
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
break|break;
block|}
comment|/* We found a '.', copy any fractional digits to the conversion buffer, up      to the first nondigit, non-underscore character. */
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|tokptr
argument_list|)
operator|||
operator|*
name|tokptr
operator|==
literal|'_'
condition|)
block|{
if|if
condition|(
operator|*
name|tokptr
operator|!=
literal|'_'
condition|)
block|{
operator|*
name|copy
operator|++
operator|=
operator|*
name|tokptr
expr_stmt|;
block|}
name|tokptr
operator|++
expr_stmt|;
block|}
comment|/* Look for an exponent, which must start with one of [eEdD].  If none      is found, jump directly to trying to convert what we have collected      so far. */
switch|switch
condition|(
operator|*
name|tokptr
condition|)
block|{
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
case|case
literal|'d'
case|:
case|case
literal|'D'
case|:
operator|*
name|copy
operator|++
operator|=
literal|'e'
expr_stmt|;
name|tokptr
operator|++
expr_stmt|;
break|break;
default|default:
goto|goto
name|convert_float
goto|;
break|break;
block|}
comment|/* Accept an optional '-' or '+' following one of [eEdD]. */
name|collect_exponent
label|:
if|if
condition|(
operator|*
name|tokptr
operator|==
literal|'+'
operator|||
operator|*
name|tokptr
operator|==
literal|'-'
condition|)
block|{
operator|*
name|copy
operator|++
operator|=
operator|*
name|tokptr
operator|++
expr_stmt|;
block|}
comment|/* Now copy an exponent into the conversion buffer.  Note that at the       moment underscores are *not* allowed in exponents. */
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|tokptr
argument_list|)
condition|)
block|{
operator|*
name|copy
operator|++
operator|=
operator|*
name|tokptr
operator|++
expr_stmt|;
block|}
comment|/* If we transfered any chars to the conversion buffer, try to interpret its      contents as a floating point value.  If any characters remain, then we      must not have a valid floating point string. */
name|convert_float
label|:
operator|*
name|copy
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|copy
operator|!=
name|buf
condition|)
block|{
name|dval
operator|=
name|strtod
argument_list|(
name|buf
argument_list|,
operator|&
name|copy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|copy
operator|==
literal|'\0'
condition|)
block|{
name|yylval
operator|.
name|dval
operator|=
name|dval
expr_stmt|;
name|lexptr
operator|=
name|tokptr
expr_stmt|;
return|return
operator|(
name|FLOAT_LITERAL
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Recognize a string literal.  A string literal is a sequence    of characters enclosed in matching single or double quotes, except that    a single character inside single quotes is a character literal, which    we reject as a string literal.  To embed the terminator character inside    a string, it is simply doubled (I.E. "this""is""one""string") */
end_comment

begin_function
specifier|static
name|enum
name|ch_terminal
name|match_string_literal
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|tokptr
init|=
name|lexptr
decl_stmt|;
name|int
name|in_ctrlseq
init|=
literal|0
decl_stmt|;
name|LONGEST
name|ival
decl_stmt|;
for|for
control|(
name|tempbufindex
operator|=
literal|0
operator|,
name|tokptr
operator|++
init|;
operator|*
name|tokptr
operator|!=
literal|'\0'
condition|;
name|tokptr
operator|++
control|)
block|{
name|CHECKBUF
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|tryagain
label|:
empty_stmt|;
if|if
condition|(
name|in_ctrlseq
condition|)
block|{
comment|/* skip possible whitespaces */
while|while
condition|(
operator|(
operator|*
name|tokptr
operator|==
literal|' '
operator|||
operator|*
name|tokptr
operator|==
literal|'\t'
operator|)
operator|&&
operator|*
name|tokptr
condition|)
name|tokptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|tokptr
operator|==
literal|')'
condition|)
block|{
name|in_ctrlseq
operator|=
literal|0
expr_stmt|;
name|tokptr
operator|++
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
elseif|else
if|if
condition|(
operator|*
name|tokptr
operator|!=
literal|','
condition|)
name|error
argument_list|(
literal|"Invalid control sequence"
argument_list|)
expr_stmt|;
name|tokptr
operator|++
expr_stmt|;
comment|/* skip possible whitespaces */
while|while
condition|(
operator|(
operator|*
name|tokptr
operator|==
literal|' '
operator|||
operator|*
name|tokptr
operator|==
literal|'\t'
operator|)
operator|&&
operator|*
name|tokptr
condition|)
name|tokptr
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|decode_integer_literal
argument_list|(
operator|&
name|ival
argument_list|,
operator|&
name|tokptr
argument_list|)
condition|)
name|error
argument_list|(
literal|"Invalid control sequence"
argument_list|)
expr_stmt|;
name|tokptr
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|tokptr
operator|==
operator|*
name|lexptr
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|tokptr
operator|+
literal|1
operator|)
operator|==
operator|*
name|lexptr
condition|)
block|{
name|ival
operator|=
operator|*
name|tokptr
operator|++
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|tokptr
operator|==
literal|'^'
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|tokptr
operator|+
literal|1
operator|)
operator|==
literal|'('
condition|)
block|{
name|in_ctrlseq
operator|=
literal|1
expr_stmt|;
name|tokptr
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|decode_integer_literal
argument_list|(
operator|&
name|ival
argument_list|,
operator|&
name|tokptr
argument_list|)
condition|)
name|error
argument_list|(
literal|"Invalid control sequence"
argument_list|)
expr_stmt|;
name|tokptr
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|(
name|tokptr
operator|+
literal|1
operator|)
operator|==
literal|'^'
condition|)
name|ival
operator|=
operator|*
name|tokptr
operator|++
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Invalid control sequence"
argument_list|)
expr_stmt|;
block|}
else|else
name|ival
operator|=
operator|*
name|tokptr
expr_stmt|;
name|tempbuf
index|[
name|tempbufindex
operator|++
index|]
operator|=
name|ival
expr_stmt|;
block|}
if|if
condition|(
name|in_ctrlseq
condition|)
name|error
argument_list|(
literal|"Invalid control sequence"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tokptr
operator|==
literal|'\0'
comment|/* no terminator */
operator|||
operator|(
name|tempbufindex
operator|==
literal|1
operator|&&
operator|*
name|tokptr
operator|==
literal|'\''
operator|)
condition|)
comment|/* char literal */
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|tempbuf
index|[
name|tempbufindex
index|]
operator|=
literal|'\0'
expr_stmt|;
name|yylval
operator|.
name|sval
operator|.
name|ptr
operator|=
name|tempbuf
expr_stmt|;
name|yylval
operator|.
name|sval
operator|.
name|length
operator|=
name|tempbufindex
expr_stmt|;
name|lexptr
operator|=
operator|++
name|tokptr
expr_stmt|;
return|return
operator|(
name|CHARACTER_STRING_LITERAL
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Recognize a character literal.  A character literal is single character    or a control sequence, enclosed in single quotes.  A control sequence    is a comma separated list of one or more integer literals, enclosed    in parenthesis and introduced with a circumflex character.     EX:  'a'  '^(7)'  '^(7,8)'     As a GNU chill extension, the syntax C'xx' is also recognized as a     character literal, where xx is a hex value for the character.     Note that more than a single character, enclosed in single quotes, is    a string literal.     Returns CHARACTER_LITERAL if a match is found.  */
end_comment

begin_function
specifier|static
name|enum
name|ch_terminal
name|match_character_literal
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|tokptr
init|=
name|lexptr
decl_stmt|;
name|LONGEST
name|ival
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|tokptr
operator|==
literal|'c'
operator|||
operator|*
name|tokptr
operator|==
literal|'C'
operator|)
operator|&&
operator|(
operator|*
operator|(
name|tokptr
operator|+
literal|1
operator|)
operator|==
literal|'\''
operator|)
condition|)
block|{
comment|/* We have a GNU chill extension form, so skip the leading "C'",          decode the hex value, and then ensure that we have a trailing          single quote character. */
name|tokptr
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|decode_integer_value
argument_list|(
literal|16
argument_list|,
operator|&
name|tokptr
argument_list|,
operator|&
name|ival
argument_list|)
operator|||
operator|(
operator|*
name|tokptr
operator|!=
literal|'\''
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|tokptr
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|tokptr
operator|==
literal|'\''
condition|)
block|{
name|tokptr
operator|++
expr_stmt|;
comment|/* Determine which form we have, either a control sequence or the          single character form. */
if|if
condition|(
operator|*
name|tokptr
operator|==
literal|'^'
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|tokptr
operator|+
literal|1
operator|)
operator|==
literal|'('
condition|)
block|{
comment|/* Match and decode a control sequence.  Return zero if we don't 	         find a valid integer literal, or if the next unconsumed character 	         after the integer literal is not the trailing ')'. */
name|tokptr
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|!
name|decode_integer_literal
argument_list|(
operator|&
name|ival
argument_list|,
operator|&
name|tokptr
argument_list|)
operator|||
operator|(
operator|*
name|tokptr
operator|++
operator|!=
literal|')'
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
operator|(
name|tokptr
operator|+
literal|1
operator|)
operator|==
literal|'^'
condition|)
block|{
name|ival
operator|=
operator|*
name|tokptr
expr_stmt|;
name|tokptr
operator|+=
literal|2
expr_stmt|;
block|}
else|else
comment|/* fail */
name|error
argument_list|(
literal|"Invalid control sequence"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|tokptr
operator|==
literal|'\''
condition|)
block|{
comment|/* this must be duplicated */
name|ival
operator|=
operator|*
name|tokptr
expr_stmt|;
name|tokptr
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|ival
operator|=
operator|*
name|tokptr
operator|++
expr_stmt|;
block|}
comment|/* The trailing quote has not yet been consumed.  If we don't find          it, then we have no match. */
if|if
condition|(
operator|*
name|tokptr
operator|++
operator|!=
literal|'\''
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* Not a character literal. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|yylval
operator|.
name|typed_val
operator|.
name|val
operator|=
name|ival
expr_stmt|;
name|yylval
operator|.
name|typed_val
operator|.
name|type
operator|=
name|builtin_type_chill_char
expr_stmt|;
name|lexptr
operator|=
name|tokptr
expr_stmt|;
return|return
operator|(
name|CHARACTER_LITERAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Recognize an integer literal, as specified in Z.200 sec 5.2.4.2.    Note that according to 5.2.4.2, a single "_" is also a valid integer    literal, however GNU-chill requires there to be at least one "digit"    in any integer literal. */
end_comment

begin_function
specifier|static
name|enum
name|ch_terminal
name|match_integer_literal
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|tokptr
init|=
name|lexptr
decl_stmt|;
name|LONGEST
name|ival
decl_stmt|;
if|if
condition|(
operator|!
name|decode_integer_literal
argument_list|(
operator|&
name|ival
argument_list|,
operator|&
name|tokptr
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|yylval
operator|.
name|typed_val
operator|.
name|val
operator|=
name|ival
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|CC_HAS_LONG_LONG
argument_list|)
if|if
condition|(
name|ival
operator|>
operator|(
name|LONGEST
operator|)
literal|2147483647U
operator|||
name|ival
operator|<
operator|-
operator|(
name|LONGEST
operator|)
literal|2147483648U
condition|)
name|yylval
operator|.
name|typed_val
operator|.
name|type
operator|=
name|builtin_type_long_long
expr_stmt|;
else|else
endif|#
directive|endif
name|yylval
operator|.
name|typed_val
operator|.
name|type
operator|=
name|builtin_type_int
expr_stmt|;
name|lexptr
operator|=
name|tokptr
expr_stmt|;
return|return
operator|(
name|INTEGER_LITERAL
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Recognize a bit-string literal, as specified in Z.200 sec 5.2.4.8    Note that according to 5.2.4.8, a single "_" is also a valid bit-string    literal, however GNU-chill requires there to be at least one "digit"    in any bit-string literal. */
end_comment

begin_function
specifier|static
name|enum
name|ch_terminal
name|match_bitstring_literal
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|tokptr
init|=
name|lexptr
decl_stmt|;
name|int
name|bitoffset
init|=
literal|0
decl_stmt|;
name|int
name|bitcount
init|=
literal|0
decl_stmt|;
name|int
name|bits_per_char
decl_stmt|;
name|int
name|digit
decl_stmt|;
name|tempbufindex
operator|=
literal|0
expr_stmt|;
name|CHECKBUF
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|tempbuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Look for the required explicit base specifier. */
switch|switch
condition|(
operator|*
name|tokptr
operator|++
condition|)
block|{
case|case
literal|'b'
case|:
case|case
literal|'B'
case|:
name|bits_per_char
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
case|case
literal|'O'
case|:
name|bits_per_char
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
case|case
literal|'H'
case|:
name|bits_per_char
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
break|break;
block|}
comment|/* Ensure that the character after the explicit base is a single quote. */
if|if
condition|(
operator|*
name|tokptr
operator|++
operator|!=
literal|'\''
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
while|while
condition|(
operator|*
name|tokptr
operator|!=
literal|'\0'
operator|&&
operator|*
name|tokptr
operator|!=
literal|'\''
condition|)
block|{
name|digit
operator|=
operator|*
name|tokptr
expr_stmt|;
if|if
condition|(
name|isupper
argument_list|(
name|digit
argument_list|)
condition|)
name|digit
operator|=
name|tolower
argument_list|(
name|digit
argument_list|)
expr_stmt|;
name|tokptr
operator|++
expr_stmt|;
switch|switch
condition|(
name|digit
condition|)
block|{
case|case
literal|'_'
case|:
continue|continue;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|digit
operator|-=
literal|'0'
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
name|digit
operator|-=
literal|'a'
expr_stmt|;
name|digit
operator|+=
literal|10
expr_stmt|;
break|break;
default|default:
comment|/* this is not a bitstring literal, probably an integer */
return|return
literal|0
return|;
block|}
if|if
condition|(
name|digit
operator|>=
literal|1
operator|<<
name|bits_per_char
condition|)
block|{
comment|/* Found something not in domain for current base. */
name|error
argument_list|(
literal|"Too-large digit in bitstring or integer."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Extract bits from digit, packing them into the bitstring byte. */
name|int
name|k
init|=
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|?
name|bits_per_char
operator|-
literal|1
else|:
literal|0
decl_stmt|;
for|for
control|(
init|;
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|?
name|k
operator|>=
literal|0
else|:
name|k
operator|<
name|bits_per_char
condition|;
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
condition|?
name|k
operator|--
else|:
name|k
operator|++
control|)
block|{
name|bitcount
operator|++
expr_stmt|;
if|if
condition|(
name|digit
operator|&
operator|(
literal|1
operator|<<
name|k
operator|)
condition|)
block|{
name|tempbuf
index|[
name|tempbufindex
index|]
operator||=
operator|(
name|TARGET_BYTE_ORDER
operator|==
name|BFD_ENDIAN_BIG
operator|)
condition|?
operator|(
literal|1
operator|<<
operator|(
name|HOST_CHAR_BIT
operator|-
literal|1
operator|-
name|bitoffset
operator|)
operator|)
else|:
operator|(
literal|1
operator|<<
name|bitoffset
operator|)
expr_stmt|;
block|}
name|bitoffset
operator|++
expr_stmt|;
if|if
condition|(
name|bitoffset
operator|==
name|HOST_CHAR_BIT
condition|)
block|{
name|bitoffset
operator|=
literal|0
expr_stmt|;
name|tempbufindex
operator|++
expr_stmt|;
name|CHECKBUF
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|tempbuf
index|[
name|tempbufindex
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Verify that we consumed everything up to the trailing single quote,      and that we found some bits (IE not just underbars). */
if|if
condition|(
operator|*
name|tokptr
operator|++
operator|!=
literal|'\''
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|yylval
operator|.
name|sval
operator|.
name|ptr
operator|=
name|tempbuf
expr_stmt|;
name|yylval
operator|.
name|sval
operator|.
name|length
operator|=
name|bitcount
expr_stmt|;
name|lexptr
operator|=
name|tokptr
expr_stmt|;
return|return
operator|(
name|BIT_STRING_LITERAL
operator|)
return|;
block|}
block|}
end_function

begin_struct
struct|struct
name|token
block|{
name|char
modifier|*
name|operator
decl_stmt|;
name|int
name|token
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|token
name|idtokentab
index|[]
init|=
block|{
block|{
literal|"array"
block|,
name|ARRAY
block|}
block|,
block|{
literal|"length"
block|,
name|LENGTH
block|}
block|,
block|{
literal|"lower"
block|,
name|LOWER
block|}
block|,
block|{
literal|"upper"
block|,
name|UPPER
block|}
block|,
block|{
literal|"andif"
block|,
name|ANDIF
block|}
block|,
block|{
literal|"pred"
block|,
name|PRED
block|}
block|,
block|{
literal|"succ"
block|,
name|SUCC
block|}
block|,
block|{
literal|"card"
block|,
name|CARD
block|}
block|,
block|{
literal|"size"
block|,
name|SIZE
block|}
block|,
block|{
literal|"orif"
block|,
name|ORIF
block|}
block|,
block|{
literal|"num"
block|,
name|NUM
block|}
block|,
block|{
literal|"abs"
block|,
name|ABS
block|}
block|,
block|{
literal|"max"
block|,
name|MAX_TOKEN
block|}
block|,
block|{
literal|"min"
block|,
name|MIN_TOKEN
block|}
block|,
block|{
literal|"mod"
block|,
name|MOD
block|}
block|,
block|{
literal|"rem"
block|,
name|REM
block|}
block|,
block|{
literal|"not"
block|,
name|NOT
block|}
block|,
block|{
literal|"xor"
block|,
name|LOGXOR
block|}
block|,
block|{
literal|"and"
block|,
name|LOGAND
block|}
block|,
block|{
literal|"in"
block|,
name|IN
block|}
block|,
block|{
literal|"or"
block|,
name|LOGIOR
block|}
block|,
block|{
literal|"up"
block|,
name|UP
block|}
block|,
block|{
literal|"addr"
block|,
name|ADDR_TOKEN
block|}
block|,
block|{
literal|"null"
block|,
name|EMPTINESS_LITERAL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|token
name|tokentab2
index|[]
init|=
block|{
block|{
literal|":="
block|,
name|GDB_ASSIGNMENT
block|}
block|,
block|{
literal|"//"
block|,
name|SLASH_SLASH
block|}
block|,
block|{
literal|"->"
block|,
name|POINTER
block|}
block|,
block|{
literal|"/="
block|,
name|NOTEQUAL
block|}
block|,
block|{
literal|"<="
block|,
name|LEQ
block|}
block|,
block|{
literal|">="
block|,
name|GEQ
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read one token, getting characters through lexptr.  */
end_comment

begin_comment
comment|/* This is where we will check to make sure that the language and the    operators used are compatible.  */
end_comment

begin_function
specifier|static
name|enum
name|ch_terminal
name|ch_lex
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|enum
name|ch_terminal
name|token
decl_stmt|;
name|char
modifier|*
name|inputname
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
comment|/* Skip over any leading whitespace. */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|lexptr
argument_list|)
condition|)
block|{
name|lexptr
operator|++
expr_stmt|;
block|}
comment|/* Look for special single character cases which can't be the first      character of some other multicharacter token. */
switch|switch
condition|(
operator|*
name|lexptr
condition|)
block|{
case|case
literal|'\0'
case|:
return|return
name|END_TOKEN
return|;
case|case
literal|','
case|:
case|case
literal|'='
case|:
case|case
literal|';'
case|:
case|case
literal|'!'
case|:
case|case
literal|'+'
case|:
case|case
literal|'*'
case|:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
case|case
literal|'['
case|:
case|case
literal|']'
case|:
return|return
operator|(
operator|*
name|lexptr
operator|++
operator|)
return|;
block|}
comment|/* Look for characters which start a particular kind of multicharacter      token, such as a character literal, register name, convenience      variable name, string literal, etc. */
switch|switch
condition|(
operator|*
name|lexptr
condition|)
block|{
case|case
literal|'\''
case|:
case|case
literal|'\"'
case|:
comment|/* First try to match a string literal, which is any          sequence of characters enclosed in matching single or double          quotes, except that a single character inside single quotes          is a character literal, so we have to catch that case also. */
name|token
operator|=
name|match_string_literal
argument_list|()
expr_stmt|;
if|if
condition|(
name|token
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|token
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|lexptr
operator|==
literal|'\''
condition|)
block|{
name|token
operator|=
name|match_character_literal
argument_list|()
expr_stmt|;
if|if
condition|(
name|token
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|token
operator|)
return|;
block|}
block|}
break|break;
case|case
literal|'C'
case|:
case|case
literal|'c'
case|:
name|token
operator|=
name|match_character_literal
argument_list|()
expr_stmt|;
if|if
condition|(
name|token
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|token
operator|)
return|;
block|}
break|break;
case|case
literal|'$'
case|:
name|yylval
operator|.
name|sval
operator|.
name|ptr
operator|=
name|lexptr
expr_stmt|;
do|do
block|{
name|lexptr
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|isalnum
argument_list|(
operator|*
name|lexptr
argument_list|)
operator|||
operator|*
name|lexptr
operator|==
literal|'_'
operator|||
operator|*
name|lexptr
operator|==
literal|'$'
condition|)
do|;
name|yylval
operator|.
name|sval
operator|.
name|length
operator|=
name|lexptr
operator|-
name|yylval
operator|.
name|sval
operator|.
name|ptr
expr_stmt|;
name|write_dollar_variable
argument_list|(
name|yylval
operator|.
name|sval
argument_list|)
expr_stmt|;
return|return
name|GDB_VARIABLE
return|;
break|break;
block|}
comment|/* See if it is a special token of length 2.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|tokentab2
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|tokentab2
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|STREQN
argument_list|(
name|lexptr
argument_list|,
name|tokentab2
index|[
name|i
index|]
operator|.
name|operator
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|lexptr
operator|+=
literal|2
expr_stmt|;
return|return
operator|(
name|tokentab2
index|[
name|i
index|]
operator|.
name|token
operator|)
return|;
block|}
block|}
comment|/* Look for single character cases which which could be the first      character of some other multicharacter token, but aren't, or we      would already have found it. */
switch|switch
condition|(
operator|*
name|lexptr
condition|)
block|{
case|case
literal|'-'
case|:
case|case
literal|':'
case|:
case|case
literal|'/'
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
return|return
operator|(
operator|*
name|lexptr
operator|++
operator|)
return|;
block|}
comment|/* Look for a float literal before looking for an integer literal, so      we match as much of the input stream as possible. */
name|token
operator|=
name|match_float_literal
argument_list|()
expr_stmt|;
if|if
condition|(
name|token
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|token
operator|)
return|;
block|}
name|token
operator|=
name|match_bitstring_literal
argument_list|()
expr_stmt|;
if|if
condition|(
name|token
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|token
operator|)
return|;
block|}
name|token
operator|=
name|match_integer_literal
argument_list|()
expr_stmt|;
if|if
condition|(
name|token
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|token
operator|)
return|;
block|}
comment|/* Try to match a simple name string, and if a match is found, then      further classify what sort of name it is and return an appropriate      token.  Note that attempting to match a simple name string consumes      the token from lexptr, so we can't back out if we later find that      we can't classify what sort of name it is. */
name|inputname
operator|=
name|match_simple_name_string
argument_list|()
expr_stmt|;
if|if
condition|(
name|inputname
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|simplename
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|inputname
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|dptr
init|=
name|simplename
decl_stmt|,
modifier|*
name|sptr
init|=
name|inputname
decl_stmt|;
for|for
control|(
init|;
operator|*
name|sptr
condition|;
name|sptr
operator|++
control|)
operator|*
name|dptr
operator|++
operator|=
name|isupper
argument_list|(
operator|*
name|sptr
argument_list|)
condition|?
name|tolower
argument_list|(
operator|*
name|sptr
argument_list|)
else|:
operator|*
name|sptr
expr_stmt|;
operator|*
name|dptr
operator|=
literal|'\0'
expr_stmt|;
comment|/* See if it is a reserved identifier. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|idtokentab
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|idtokentab
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|simplename
argument_list|,
name|idtokentab
index|[
name|i
index|]
operator|.
name|operator
argument_list|)
condition|)
block|{
return|return
operator|(
name|idtokentab
index|[
name|i
index|]
operator|.
name|token
operator|)
return|;
block|}
block|}
comment|/* Look for other special tokens. */
if|if
condition|(
name|STREQ
argument_list|(
name|simplename
argument_list|,
literal|"true"
argument_list|)
condition|)
block|{
name|yylval
operator|.
name|ulval
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|BOOLEAN_LITERAL
operator|)
return|;
block|}
if|if
condition|(
name|STREQ
argument_list|(
name|simplename
argument_list|,
literal|"false"
argument_list|)
condition|)
block|{
name|yylval
operator|.
name|ulval
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|BOOLEAN_LITERAL
operator|)
return|;
block|}
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|inputname
argument_list|,
name|expression_context_block
argument_list|,
name|VAR_NAMESPACE
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
operator|&&
name|strcmp
argument_list|(
name|inputname
argument_list|,
name|simplename
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sym
operator|=
name|lookup_symbol
argument_list|(
name|simplename
argument_list|,
name|expression_context_block
argument_list|,
name|VAR_NAMESPACE
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|symtab
operator|*
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
block|{
name|yylval
operator|.
name|ssym
operator|.
name|stoken
operator|.
name|ptr
operator|=
name|NULL
expr_stmt|;
name|yylval
operator|.
name|ssym
operator|.
name|stoken
operator|.
name|length
operator|=
literal|0
expr_stmt|;
name|yylval
operator|.
name|ssym
operator|.
name|sym
operator|=
name|sym
expr_stmt|;
name|yylval
operator|.
name|ssym
operator|.
name|is_a_field_of_this
operator|=
literal|0
expr_stmt|;
comment|/* FIXME, C++'ism */
switch|switch
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
condition|)
block|{
case|case
name|LOC_BLOCK
case|:
comment|/* Found a procedure name. */
return|return
operator|(
name|GENERAL_PROCEDURE_NAME
operator|)
return|;
case|case
name|LOC_STATIC
case|:
comment|/* Found a global or local static variable. */
return|return
operator|(
name|LOCATION_NAME
operator|)
return|;
case|case
name|LOC_REGISTER
case|:
case|case
name|LOC_ARG
case|:
case|case
name|LOC_REF_ARG
case|:
case|case
name|LOC_REGPARM
case|:
case|case
name|LOC_REGPARM_ADDR
case|:
case|case
name|LOC_LOCAL
case|:
case|case
name|LOC_LOCAL_ARG
case|:
case|case
name|LOC_BASEREG
case|:
case|case
name|LOC_BASEREG_ARG
case|:
if|if
condition|(
name|innermost_block
operator|==
name|NULL
operator|||
name|contained_in
argument_list|(
name|block_found
argument_list|,
name|innermost_block
argument_list|)
condition|)
block|{
name|innermost_block
operator|=
name|block_found
expr_stmt|;
block|}
return|return
operator|(
name|LOCATION_NAME
operator|)
return|;
break|break;
case|case
name|LOC_CONST
case|:
case|case
name|LOC_LABEL
case|:
return|return
operator|(
name|LOCATION_NAME
operator|)
return|;
break|break;
case|case
name|LOC_TYPEDEF
case|:
name|yylval
operator|.
name|tsym
operator|.
name|type
operator|=
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
expr_stmt|;
return|return
name|TYPENAME
return|;
case|case
name|LOC_UNDEF
case|:
case|case
name|LOC_CONST_BYTES
case|:
case|case
name|LOC_OPTIMIZED_OUT
case|:
name|error
argument_list|(
literal|"Symbol \"%s\" names no location."
argument_list|,
name|inputname
argument_list|)
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"unhandled SYMBOL_CLASS in ch_lex()"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|have_full_symbols
argument_list|()
operator|&&
operator|!
name|have_partial_symbols
argument_list|()
condition|)
block|{
name|error
argument_list|(
literal|"No symbol table is loaded.  Use the \"file\" command."
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"No symbol \"%s\" in current context."
argument_list|,
name|inputname
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Catch single character tokens which are not part of some      longer token. */
switch|switch
condition|(
operator|*
name|lexptr
condition|)
block|{
case|case
literal|'.'
case|:
comment|/* Not float for example. */
name|lexptr
operator|++
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|lexptr
argument_list|)
condition|)
name|lexptr
operator|++
expr_stmt|;
name|inputname
operator|=
name|match_simple_name_string
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|inputname
condition|)
return|return
literal|'.'
return|;
return|return
name|DOT_FIELD_NAME
return|;
block|}
return|return
operator|(
name|ILLEGAL_TOKEN
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|write_lower_upper_value
parameter_list|(
name|enum
name|exp_opcode
name|opcode
parameter_list|,
comment|/* Either UNOP_LOWER or UNOP_UPPER */
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
name|write_exp_elt_opcode
argument_list|(
name|opcode
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|type
modifier|*
name|result_type
decl_stmt|;
name|LONGEST
name|val
init|=
name|type_lower_upper
argument_list|(
name|opcode
argument_list|,
name|type
argument_list|,
operator|&
name|result_type
argument_list|)
decl_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|OP_LONG
argument_list|)
expr_stmt|;
name|write_exp_elt_type
argument_list|(
name|result_type
argument_list|)
expr_stmt|;
name|write_exp_elt_longcst
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|write_exp_elt_opcode
argument_list|(
name|OP_LONG
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|chill_error
parameter_list|(
name|char
modifier|*
name|msg
parameter_list|)
block|{
comment|/* Never used. */
block|}
end_function

end_unit

