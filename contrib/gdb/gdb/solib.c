begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle SunOS and SVR4 shared libraries for GDB, the GNU Debugger.    Copyright 1990, 91, 92, 93, 94, 95, 96, 98, 1999    Free Software Foundation, Inc.     This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_comment
comment|/* This file is only compilable if link.h is available. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LINK_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|SVR4_SHARED_LIBS
end_ifndef

begin_comment
comment|/* SunOS shared libs need the nlist structure.  */
end_comment

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"elf/external.h"
end_include

begin_include
include|#
directive|include
file|"elf/common.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<link.h>
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"gnu-regex.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"environ.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_define
define|#
directive|define
name|MAX_PATH_SIZE
value|512
end_define

begin_comment
comment|/* FIXME: Should be dynamic */
end_comment

begin_comment
comment|/* On SVR4 systems, a list of symbols in the dynamic linker where    GDB can try to place a breakpoint to monitor shared library    events.     If none of these symbols are found, or other errors occur, then    SVR4 systems will fall back to using a symbol as the "startup    mapping complete" breakpoint address.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SVR4_SHARED_LIBS
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|solib_break_names
index|[]
init|=
block|{
literal|"r_debug_state"
block|,
literal|"_r_debug_state"
block|,
literal|"_dl_debug_state"
block|,
literal|"rtld_db_dlactivity"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|BKPT_AT_SYMBOL
value|1
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BKPT_AT_SYMBOL
argument_list|)
operator|&&
name|defined
argument_list|(
name|SVR4_SHARED_LIBS
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
modifier|*
name|bkpt_names
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|SOLIB_BKPT_NAME
name|SOLIB_BKPT_NAME
block|,
comment|/* Prefer configured name if it exists. */
endif|#
directive|endif
literal|"_start"
block|,
literal|"main"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Symbols which are used to locate the base of the link map structures. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SVR4_SHARED_LIBS
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|debug_base_symbols
index|[]
init|=
block|{
literal|"_DYNAMIC"
block|,
literal|"_DYNAMIC__MGC"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
modifier|*
name|main_name_list
index|[]
init|=
block|{
literal|"main_$main"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local data declarations */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SVR4_SHARED_LIBS
end_ifndef

begin_define
define|#
directive|define
name|LM_ADDR
parameter_list|(
name|so
parameter_list|)
value|((so) -> lm.lm_addr)
end_define

begin_define
define|#
directive|define
name|LM_NEXT
parameter_list|(
name|so
parameter_list|)
value|((so) -> lm.lm_next)
end_define

begin_define
define|#
directive|define
name|LM_NAME
parameter_list|(
name|so
parameter_list|)
value|((so) -> lm.lm_name)
end_define

begin_comment
comment|/* Test for first link map entry; first entry is a shared library. */
end_comment

begin_define
define|#
directive|define
name|IGNORE_FIRST_LINK_MAP_ENTRY
parameter_list|(
name|x
parameter_list|)
value|(0)
end_define

begin_decl_stmt
specifier|static
name|struct
name|link_dynamic
name|dynamic_copy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|link_dynamic_2
name|ld_2_copy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ld_debug
name|debug_copy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|debug_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|flag_addr
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* SVR4_SHARED_LIBS */
end_comment

begin_define
define|#
directive|define
name|LM_ADDR
parameter_list|(
name|so
parameter_list|)
value|((so) -> lm.l_addr)
end_define

begin_define
define|#
directive|define
name|LM_NEXT
parameter_list|(
name|so
parameter_list|)
value|((so) -> lm.l_next)
end_define

begin_define
define|#
directive|define
name|LM_NAME
parameter_list|(
name|so
parameter_list|)
value|((so) -> lm.l_name)
end_define

begin_comment
comment|/* Test for first link map entry; first entry is the exec-file. */
end_comment

begin_define
define|#
directive|define
name|IGNORE_FIRST_LINK_MAP_ENTRY
parameter_list|(
name|x
parameter_list|)
value|((x).l_prev == NULL)
end_define

begin_decl_stmt
specifier|static
name|struct
name|r_debug
name|debug_copy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|shadow_contents
index|[
name|BREAKPOINT_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Stash old bkpt addr contents */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SVR4_SHARED_LIBS */
end_comment

begin_struct
struct|struct
name|so_list
block|{
name|struct
name|so_list
modifier|*
name|next
decl_stmt|;
comment|/* next structure in linked list */
name|struct
name|link_map
name|lm
decl_stmt|;
comment|/* copy of link map from inferior */
name|struct
name|link_map
modifier|*
name|lmaddr
decl_stmt|;
comment|/* addr in inferior lm was read from */
name|CORE_ADDR
name|lmend
decl_stmt|;
comment|/* upper addr bound of mapped object */
name|char
name|so_name
index|[
name|MAX_PATH_SIZE
index|]
decl_stmt|;
comment|/* shared object lib name (FIXME) */
name|char
name|symbols_loaded
decl_stmt|;
comment|/* flag: symbols read in yet? */
name|char
name|from_tty
decl_stmt|;
comment|/* flag: print msgs? */
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
comment|/* objfile for loaded lib */
name|struct
name|section_table
modifier|*
name|sections
decl_stmt|;
name|struct
name|section_table
modifier|*
name|sections_end
decl_stmt|;
name|struct
name|section_table
modifier|*
name|textsection
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|so_list
modifier|*
name|so_list_head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of known shared objects */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|debug_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Base of dynamic linker structures */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|breakpoint_addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Address where end bkpt is set */
end_comment

begin_decl_stmt
specifier|static
name|int
name|solib_cleanup_queued
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* make_run_cleanup called */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|fdmatch
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* In libiberty */
end_comment

begin_comment
comment|/* Local function prototypes */
end_comment

begin_decl_stmt
specifier|static
name|void
name|do_clear_solib
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|match_main
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|special_symbol_handling
name|PARAMS
argument_list|(
operator|(
expr|struct
name|so_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sharedlibrary_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|enable_break
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|info_sharedlibrary_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|symbol_add_stub
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|so_list
modifier|*
name|alloc_solib
name|PARAMS
argument_list|(
operator|(
expr|struct
name|link_map
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|free_solib
name|PARAMS
argument_list|(
operator|(
expr|struct
name|so_list
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|so_list
modifier|*
name|find_solib
name|PARAMS
argument_list|(
operator|(
expr|struct
name|so_list
operator|*
operator|,
name|int
name|maybe_changed
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|link_map
modifier|*
name|first_link_map_member
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|locate_base
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|solib_map_sections
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SVR4_SHARED_LIBS
end_ifdef

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|elf_locate_base
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|int
name|disable_break
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|allocate_rt_common_objfile
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|solib_add_common_symbols
name|PARAMS
argument_list|(
operator|(
expr|struct
name|rtc_symb
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|void
name|_initialize_solib
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, this is a prefix that will be added to the front of the name    shared libraries with an absolute filename for loading.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|solib_absolute_prefix
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-empty, this is a search path for loading non-absolute shared library    symbol files.  This takes precedence over the environment variables PATH    and LD_LIBRARY_PATH.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|solib_search_path
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  LOCAL FUNCTION  	solib_map_sections -- open bfd and build sections for shared lib  SYNOPSIS  	static int solib_map_sections (struct so_list *so)  DESCRIPTION  	Given a pointer to one of the shared objects in our list 	of mapped objects, use the recorded name to open a bfd 	descriptor for the object, build a section table, and then 	relocate all the section addresses by the base address at 	which the shared object was mapped.  FIXMES  	In most (all?) cases the shared object file name recorded in the 	dynamic linkage tables will be a fully qualified pathname.  For 	cases where it isn't, do we really mimic the systems search 	mechanism correctly in the below code (particularly the tilde 	expansion stuff?).  */
end_comment

begin_function
specifier|static
name|int
name|solib_map_sections
parameter_list|(
name|arg
parameter_list|)
name|PTR
name|arg
decl_stmt|;
block|{
name|struct
name|so_list
modifier|*
name|so
init|=
operator|(
expr|struct
name|so_list
operator|*
operator|)
name|arg
decl_stmt|;
comment|/* catch_errors bogon */
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|scratch_pathname
decl_stmt|;
name|int
name|scratch_chan
decl_stmt|;
name|struct
name|section_table
modifier|*
name|p
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|filename
operator|=
name|tilde_expand
argument_list|(
name|so
operator|->
name|so_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|solib_absolute_prefix
operator|&&
name|ROOTED_P
argument_list|(
name|filename
argument_list|)
condition|)
comment|/* Prefix shared libraries with absolute filenames with        SOLIB_ABSOLUTE_PREFIX.  */
block|{
name|char
modifier|*
name|pfxed_fn
decl_stmt|;
name|int
name|pfx_len
decl_stmt|;
name|pfx_len
operator|=
name|strlen
argument_list|(
name|solib_absolute_prefix
argument_list|)
expr_stmt|;
comment|/* Remove trailing slashes.  */
while|while
condition|(
name|pfx_len
operator|>
literal|0
operator|&&
name|SLASH_P
argument_list|(
name|solib_absolute_prefix
index|[
name|pfx_len
operator|-
literal|1
index|]
argument_list|)
condition|)
name|pfx_len
operator|--
expr_stmt|;
name|pfxed_fn
operator|=
name|xmalloc
argument_list|(
name|pfx_len
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|pfxed_fn
argument_list|,
name|solib_absolute_prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|pfxed_fn
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|filename
operator|=
name|pfxed_fn
expr_stmt|;
block|}
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|scratch_chan
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|solib_search_path
condition|)
name|scratch_chan
operator|=
name|openp
argument_list|(
name|solib_search_path
argument_list|,
literal|1
argument_list|,
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
operator|&
name|scratch_pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|scratch_chan
operator|<
literal|0
condition|)
name|scratch_chan
operator|=
name|openp
argument_list|(
name|get_in_environ
argument_list|(
name|inferior_environ
argument_list|,
literal|"PATH"
argument_list|)
argument_list|,
literal|1
argument_list|,
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
operator|&
name|scratch_pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|scratch_chan
operator|<
literal|0
condition|)
block|{
name|scratch_chan
operator|=
name|openp
argument_list|(
name|get_in_environ
argument_list|(
name|inferior_environ
argument_list|,
literal|"LD_LIBRARY_PATH"
argument_list|)
argument_list|,
literal|1
argument_list|,
name|filename
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
operator|&
name|scratch_pathname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scratch_chan
operator|<
literal|0
condition|)
block|{
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
comment|/* Leave scratch_pathname allocated.  abfd->name will point to it.  */
name|abfd
operator|=
name|bfd_fdopenr
argument_list|(
name|scratch_pathname
argument_list|,
name|gnutarget
argument_list|,
name|scratch_chan
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abfd
condition|)
block|{
name|close
argument_list|(
name|scratch_chan
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Could not open `%s' as an executable file: %s"
argument_list|,
name|scratch_pathname
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Leave bfd open, core_xfer_memory and "info files" need it.  */
name|so
operator|->
name|abfd
operator|=
name|abfd
expr_stmt|;
name|abfd
operator|->
name|cacheable
operator|=
name|true
expr_stmt|;
comment|/* copy full path name into so_name, so that later symbol_file_add can find      it */
if|if
condition|(
name|strlen
argument_list|(
name|scratch_pathname
argument_list|)
operator|>=
name|MAX_PATH_SIZE
condition|)
name|error
argument_list|(
literal|"Full path name length of shared library exceeds MAX_PATH_SIZE in so_list structure."
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|so
operator|->
name|so_name
argument_list|,
name|scratch_pathname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"\"%s\": not in executable format: %s."
argument_list|,
name|scratch_pathname
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|build_section_table
argument_list|(
name|abfd
argument_list|,
operator|&
name|so
operator|->
name|sections
argument_list|,
operator|&
name|so
operator|->
name|sections_end
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Can't find the file sections in `%s': %s"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|so
operator|->
name|sections
init|;
name|p
operator|<
name|so
operator|->
name|sections_end
condition|;
name|p
operator|++
control|)
block|{
comment|/* Relocate the section binding addresses as recorded in the shared 	 object's file by the base address to which the object was actually 	 mapped. */
name|p
operator|->
name|addr
operator|+=
operator|(
name|CORE_ADDR
operator|)
name|LM_ADDR
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|p
operator|->
name|endaddr
operator|+=
operator|(
name|CORE_ADDR
operator|)
name|LM_ADDR
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|so
operator|->
name|lmend
operator|=
operator|(
name|CORE_ADDR
operator|)
name|max
argument_list|(
name|p
operator|->
name|endaddr
argument_list|,
name|so
operator|->
name|lmend
argument_list|)
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|p
operator|->
name|the_bfd_section
operator|->
name|name
argument_list|,
literal|".text"
argument_list|)
condition|)
block|{
name|so
operator|->
name|textsection
operator|=
name|p
expr_stmt|;
block|}
block|}
comment|/* Free the file names, close the file now.  */
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SVR4_SHARED_LIBS
end_ifndef

begin_comment
comment|/* Allocate the runtime common object file.  */
end_comment

begin_function
specifier|static
name|void
name|allocate_rt_common_objfile
parameter_list|()
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|objfile
modifier|*
name|last_one
decl_stmt|;
name|objfile
operator|=
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|objfile
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|md
operator|=
name|NULL
expr_stmt|;
name|obstack_specify_allocation
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_cache
operator|.
name|cache
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|xmalloc
argument_list|,
name|free
argument_list|)
expr_stmt|;
name|obstack_specify_allocation
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|xmalloc
argument_list|,
name|free
argument_list|)
expr_stmt|;
name|obstack_specify_allocation
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|xmalloc
argument_list|,
name|free
argument_list|)
expr_stmt|;
name|obstack_specify_allocation
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|xmalloc
argument_list|,
name|free
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|name
operator|=
name|mstrsave
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
literal|"rt_common"
argument_list|)
expr_stmt|;
comment|/* Add this file onto the tail of the linked list of other such files. */
name|objfile
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|object_files
operator|==
name|NULL
condition|)
name|object_files
operator|=
name|objfile
expr_stmt|;
else|else
block|{
for|for
control|(
name|last_one
operator|=
name|object_files
init|;
name|last_one
operator|->
name|next
condition|;
name|last_one
operator|=
name|last_one
operator|->
name|next
control|)
empty_stmt|;
name|last_one
operator|->
name|next
operator|=
name|objfile
expr_stmt|;
block|}
name|rt_common_objfile
operator|=
name|objfile
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read all dynamically loaded common symbol definitions from the inferior    and put them into the minimal symbol table for the runtime common    objfile.  */
end_comment

begin_function
specifier|static
name|void
name|solib_add_common_symbols
parameter_list|(
name|rtc_symp
parameter_list|)
name|struct
name|rtc_symb
modifier|*
name|rtc_symp
decl_stmt|;
block|{
name|struct
name|rtc_symb
name|inferior_rtc_symb
decl_stmt|;
name|struct
name|nlist
name|inferior_rtc_nlist
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Remove any runtime common symbols from previous runs.  */
if|if
condition|(
name|rt_common_objfile
operator|!=
name|NULL
operator|&&
name|rt_common_objfile
operator|->
name|minimal_symbol_count
condition|)
block|{
name|obstack_free
argument_list|(
operator|&
name|rt_common_objfile
operator|->
name|symbol_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|obstack_specify_allocation
argument_list|(
operator|&
name|rt_common_objfile
operator|->
name|symbol_obstack
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|xmalloc
argument_list|,
name|free
argument_list|)
expr_stmt|;
name|rt_common_objfile
operator|->
name|minimal_symbol_count
operator|=
literal|0
expr_stmt|;
name|rt_common_objfile
operator|->
name|msymbols
operator|=
name|NULL
expr_stmt|;
block|}
name|init_minimal_symbol_collection
argument_list|()
expr_stmt|;
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|discard_minimal_symbols
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|rtc_symp
condition|)
block|{
name|read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|rtc_symp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|inferior_rtc_symb
argument_list|,
sizeof|sizeof
argument_list|(
name|inferior_rtc_symb
argument_list|)
argument_list|)
expr_stmt|;
name|read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|inferior_rtc_symb
operator|.
name|rtc_sp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|inferior_rtc_nlist
argument_list|,
sizeof|sizeof
argument_list|(
name|inferior_rtc_nlist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inferior_rtc_nlist
operator|.
name|n_type
operator|==
name|N_COMM
condition|)
block|{
comment|/* FIXME: The length of the symbol name is not available, but in the 	     current implementation the common symbol is allocated immediately 	     behind the name of the symbol. */
name|len
operator|=
name|inferior_rtc_nlist
operator|.
name|n_value
operator|-
name|inferior_rtc_nlist
operator|.
name|n_un
operator|.
name|n_strx
expr_stmt|;
name|name
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|inferior_rtc_nlist
operator|.
name|n_un
operator|.
name|n_name
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Allocate the runtime common objfile if necessary. */
if|if
condition|(
name|rt_common_objfile
operator|==
name|NULL
condition|)
name|allocate_rt_common_objfile
argument_list|()
expr_stmt|;
name|prim_record_minimal_symbol
argument_list|(
name|name
argument_list|,
name|inferior_rtc_nlist
operator|.
name|n_value
argument_list|,
name|mst_bss
argument_list|,
name|rt_common_objfile
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|rtc_symp
operator|=
name|inferior_rtc_symb
operator|.
name|rtc_next
expr_stmt|;
block|}
comment|/* Install any minimal symbols that have been collected as the current      minimal symbols for the runtime common objfile.  */
name|install_minimal_symbols
argument_list|(
name|rt_common_objfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SVR4_SHARED_LIBS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SVR4_SHARED_LIBS
end_ifdef

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|bfd_lookup_symbol
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  LOCAL FUNCTION  	bfd_lookup_symbol -- lookup the value for a specific symbol  SYNOPSIS  	CORE_ADDR bfd_lookup_symbol (bfd *abfd, char *symname)  DESCRIPTION  	An expensive way to lookup the value of a single symbol for 	bfd's that are only temporary anyway.  This is used by the 	shared library support to find the address of the debugger 	interface structures in the shared library.  	Note that 0 is specifically allowed as an error return (no 	such symbol). */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|bfd_lookup_symbol
parameter_list|(
name|abfd
parameter_list|,
name|symname
parameter_list|)
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
modifier|*
name|symname
decl_stmt|;
block|{
name|long
name|storage_needed
decl_stmt|;
name|asymbol
modifier|*
name|sym
decl_stmt|;
name|asymbol
modifier|*
modifier|*
name|symbol_table
decl_stmt|;
name|unsigned
name|int
name|number_of_symbols
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
decl_stmt|;
name|CORE_ADDR
name|symaddr
init|=
literal|0
decl_stmt|;
name|storage_needed
operator|=
name|bfd_get_symtab_upper_bound
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|storage_needed
operator|>
literal|0
condition|)
block|{
name|symbol_table
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|storage_needed
argument_list|)
expr_stmt|;
name|back_to
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
operator|(
name|PTR
operator|)
name|symbol_table
argument_list|)
expr_stmt|;
name|number_of_symbols
operator|=
name|bfd_canonicalize_symtab
argument_list|(
name|abfd
argument_list|,
name|symbol_table
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_of_symbols
condition|;
name|i
operator|++
control|)
block|{
name|sym
operator|=
operator|*
name|symbol_table
operator|++
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|sym
operator|->
name|name
argument_list|,
name|symname
argument_list|)
condition|)
block|{
comment|/* Bfd symbols are section relative. */
name|symaddr
operator|=
name|sym
operator|->
name|value
operator|+
name|sym
operator|->
name|section
operator|->
name|vma
expr_stmt|;
break|break;
block|}
block|}
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|symaddr
condition|)
return|return
operator|(
name|symaddr
operator|)
return|;
name|storage_needed
operator|=
name|bfd_get_dynamic_symtab_upper_bound
argument_list|(
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|storage_needed
operator|>
literal|0
condition|)
block|{
name|symbol_table
operator|=
operator|(
name|asymbol
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|storage_needed
argument_list|)
expr_stmt|;
name|back_to
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
operator|(
name|PTR
operator|)
name|symbol_table
argument_list|)
expr_stmt|;
name|number_of_symbols
operator|=
name|bfd_canonicalize_dynamic_symtab
argument_list|(
name|abfd
argument_list|,
name|symbol_table
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_of_symbols
condition|;
name|i
operator|++
control|)
block|{
name|sym
operator|=
operator|*
name|symbol_table
operator|++
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|sym
operator|->
name|name
argument_list|,
name|symname
argument_list|)
condition|)
block|{
comment|/* Bfd symbols are section relative. */
name|symaddr
operator|=
name|sym
operator|->
name|value
operator|+
name|sym
operator|->
name|section
operator|->
name|vma
expr_stmt|;
break|break;
block|}
block|}
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|symaddr
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HANDLE_SVR4_EXEC_EMULATORS
end_ifdef

begin_comment
comment|/* 	Solaris BCP (the part of Solaris which allows it to run SunOS4 	a.out files) throws in another wrinkle. Solaris does not fill 	in the usual a.out link map structures when running BCP programs, 	the only way to get at them is via groping around in the dynamic 	linker. 	The dynamic linker and it's structures are located in the shared 	C library, which gets run as the executable's "interpreter" by 	the kernel.  	Note that we can assume nothing about the process state at the time 	we need to find these structures.  We may be stopped on the first 	instruction of the interpreter (C shared library), the first 	instruction of the executable itself, or somewhere else entirely 	(if we attached to the process for example). */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|debug_base_symbols
index|[]
init|=
block|{
literal|"r_debug"
block|,
comment|/* Solaris 2.3 */
literal|"_r_debug"
block|,
comment|/* Solaris 2.1, 2.2 */
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|look_for_base
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|CORE_ADDR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  LOCAL FUNCTION  	look_for_base -- examine file for each mapped address segment  SYNOPSYS  	static int look_for_base (int fd, CORE_ADDR baseaddr)  DESCRIPTION  	This function is passed to proc_iterate_over_mappings, which 	causes it to get called once for each mapped address space, with 	an open file descriptor for the file mapped to that space, and the 	base address of that mapped space.  	Our job is to find the debug base symbol in the file that this 	fd is open on, if it exists, and if so, initialize the dynamic 	linker structure base address debug_base.  	Note that this is a computationally expensive proposition, since 	we basically have to open a bfd on every call, so we specifically 	avoid opening the exec file.  */
end_comment

begin_function
specifier|static
name|int
name|look_for_base
parameter_list|(
name|fd
parameter_list|,
name|baseaddr
parameter_list|)
name|int
name|fd
decl_stmt|;
name|CORE_ADDR
name|baseaddr
decl_stmt|;
block|{
name|bfd
modifier|*
name|interp_bfd
decl_stmt|;
name|CORE_ADDR
name|address
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|symbolp
decl_stmt|;
comment|/* If the fd is -1, then there is no file that corresponds to this      mapped memory segment, so skip it.  Also, if the fd corresponds      to the exec file, skip it as well. */
if|if
condition|(
name|fd
operator|==
operator|-
literal|1
operator|||
operator|(
name|exec_bfd
operator|!=
name|NULL
operator|&&
name|fdmatch
argument_list|(
name|fileno
argument_list|(
operator|(
name|FILE
operator|*
operator|)
operator|(
name|exec_bfd
operator|->
name|iostream
operator|)
argument_list|)
argument_list|,
name|fd
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Try to open whatever random file this fd corresponds to.  Note that      we have no way currently to find the filename.  Don't gripe about      any problems we might have, just fail. */
if|if
condition|(
operator|(
name|interp_bfd
operator|=
name|bfd_fdopenr
argument_list|(
literal|"unnamed"
argument_list|,
name|gnutarget
argument_list|,
name|fd
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|interp_bfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
comment|/* FIXME-leak: on failure, might not free all memory associated with 	 interp_bfd.  */
name|bfd_close
argument_list|(
name|interp_bfd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Now try to find our debug base symbol in this file, which we at      least know to be a valid ELF executable or shared library. */
for|for
control|(
name|symbolp
operator|=
name|debug_base_symbols
init|;
operator|*
name|symbolp
operator|!=
name|NULL
condition|;
name|symbolp
operator|++
control|)
block|{
name|address
operator|=
name|bfd_lookup_symbol
argument_list|(
name|interp_bfd
argument_list|,
operator|*
name|symbolp
argument_list|)
expr_stmt|;
if|if
condition|(
name|address
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|address
operator|==
literal|0
condition|)
block|{
comment|/* FIXME-leak: on failure, might not free all memory associated with 	 interp_bfd.  */
name|bfd_close
argument_list|(
name|interp_bfd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Eureka!  We found the symbol.  But now we may need to relocate it      by the base address.  If the symbol's value is less than the base      address of the shared library, then it hasn't yet been relocated      by the dynamic linker, and we have to do it ourself.  FIXME: Note      that we make the assumption that the first segment that corresponds      to the shared library has the base address to which the library      was relocated. */
if|if
condition|(
name|address
operator|<
name|baseaddr
condition|)
block|{
name|address
operator|+=
name|baseaddr
expr_stmt|;
block|}
name|debug_base
operator|=
name|address
expr_stmt|;
comment|/* FIXME-leak: on failure, might not free all memory associated with      interp_bfd.  */
name|bfd_close
argument_list|(
name|interp_bfd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HANDLE_SVR4_EXEC_EMULATORS */
end_comment

begin_comment
comment|/*  LOCAL FUNCTION  	elf_locate_base -- locate the base address of dynamic linker structs 	for SVR4 elf targets.  SYNOPSIS  	CORE_ADDR elf_locate_base (void)  DESCRIPTION  	For SVR4 elf targets the address of the dynamic linker's runtime 	structure is contained within the dynamic info section in the 	executable file.  The dynamic section is also mapped into the 	inferior address space.  Because the runtime loader fills in the 	real address before starting the inferior, we have to read in the 	dynamic info section from the inferior address space. 	If there are any errors while trying to find the address, we 	silently return 0, otherwise the found address is returned.   */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|elf_locate_base
parameter_list|()
block|{
name|sec_ptr
name|dyninfo_sect
decl_stmt|;
name|int
name|dyninfo_sect_size
decl_stmt|;
name|CORE_ADDR
name|dyninfo_addr
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|bufend
decl_stmt|;
comment|/* Find the start address of the .dynamic section.  */
name|dyninfo_sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|exec_bfd
argument_list|,
literal|".dynamic"
argument_list|)
expr_stmt|;
if|if
condition|(
name|dyninfo_sect
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|dyninfo_addr
operator|=
name|bfd_section_vma
argument_list|(
name|exec_bfd
argument_list|,
name|dyninfo_sect
argument_list|)
expr_stmt|;
comment|/* Read in .dynamic section, silently ignore errors.  */
name|dyninfo_sect_size
operator|=
name|bfd_section_size
argument_list|(
name|exec_bfd
argument_list|,
name|dyninfo_sect
argument_list|)
expr_stmt|;
name|buf
operator|=
name|alloca
argument_list|(
name|dyninfo_sect_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|dyninfo_addr
argument_list|,
name|buf
argument_list|,
name|dyninfo_sect_size
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Find the DT_DEBUG entry in the the .dynamic section.      For mips elf we look for DT_MIPS_RLD_MAP, mips elf apparently has      no DT_DEBUG entries.  */
ifndef|#
directive|ifndef
name|TARGET_ELF64
for|for
control|(
name|bufend
operator|=
name|buf
operator|+
name|dyninfo_sect_size
init|;
name|buf
operator|<
name|bufend
condition|;
name|buf
operator|+=
sizeof|sizeof
argument_list|(
name|Elf32_External_Dyn
argument_list|)
control|)
block|{
name|Elf32_External_Dyn
modifier|*
name|x_dynp
init|=
operator|(
name|Elf32_External_Dyn
operator|*
operator|)
name|buf
decl_stmt|;
name|long
name|dyn_tag
decl_stmt|;
name|CORE_ADDR
name|dyn_ptr
decl_stmt|;
name|dyn_tag
operator|=
name|bfd_h_get_32
argument_list|(
name|exec_bfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|x_dynp
operator|->
name|d_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|dyn_tag
operator|==
name|DT_NULL
condition|)
break|break;
elseif|else
if|if
condition|(
name|dyn_tag
operator|==
name|DT_DEBUG
condition|)
block|{
name|dyn_ptr
operator|=
name|bfd_h_get_32
argument_list|(
name|exec_bfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|x_dynp
operator|->
name|d_un
operator|.
name|d_ptr
argument_list|)
expr_stmt|;
return|return
name|dyn_ptr
return|;
block|}
ifdef|#
directive|ifdef
name|DT_MIPS_RLD_MAP
elseif|else
if|if
condition|(
name|dyn_tag
operator|==
name|DT_MIPS_RLD_MAP
condition|)
block|{
name|char
name|pbuf
index|[
name|TARGET_PTR_BIT
operator|/
name|HOST_CHAR_BIT
index|]
decl_stmt|;
comment|/* DT_MIPS_RLD_MAP contains a pointer to the address 	     of the dynamic link structure.  */
name|dyn_ptr
operator|=
name|bfd_h_get_32
argument_list|(
name|exec_bfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|x_dynp
operator|->
name|d_un
operator|.
name|d_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_read_memory
argument_list|(
name|dyn_ptr
argument_list|,
name|pbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pbuf
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|extract_unsigned_integer
argument_list|(
name|pbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pbuf
argument_list|)
argument_list|)
return|;
block|}
endif|#
directive|endif
block|}
else|#
directive|else
comment|/* ELF64 */
for|for
control|(
name|bufend
operator|=
name|buf
operator|+
name|dyninfo_sect_size
init|;
name|buf
operator|<
name|bufend
condition|;
name|buf
operator|+=
sizeof|sizeof
argument_list|(
name|Elf64_External_Dyn
argument_list|)
control|)
block|{
name|Elf64_External_Dyn
modifier|*
name|x_dynp
init|=
operator|(
name|Elf64_External_Dyn
operator|*
operator|)
name|buf
decl_stmt|;
name|long
name|dyn_tag
decl_stmt|;
name|CORE_ADDR
name|dyn_ptr
decl_stmt|;
name|dyn_tag
operator|=
name|bfd_h_get_64
argument_list|(
name|exec_bfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|x_dynp
operator|->
name|d_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|dyn_tag
operator|==
name|DT_NULL
condition|)
break|break;
elseif|else
if|if
condition|(
name|dyn_tag
operator|==
name|DT_DEBUG
condition|)
block|{
name|dyn_ptr
operator|=
name|bfd_h_get_64
argument_list|(
name|exec_bfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|x_dynp
operator|->
name|d_un
operator|.
name|d_ptr
argument_list|)
expr_stmt|;
return|return
name|dyn_ptr
return|;
block|}
block|}
endif|#
directive|endif
comment|/* DT_DEBUG entry not found.  */
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SVR4_SHARED_LIBS */
end_comment

begin_comment
comment|/*  LOCAL FUNCTION  	locate_base -- locate the base address of dynamic linker structs  SYNOPSIS  	CORE_ADDR locate_base (void)  DESCRIPTION  	For both the SunOS and SVR4 shared library implementations, if the 	inferior executable has been linked dynamically, there is a single 	address somewhere in the inferior's data space which is the key to 	locating all of the dynamic linker's runtime structures.  This 	address is the value of the debug base symbol.  The job of this 	function is to find and return that address, or to return 0 if there 	is no such address (the executable is statically linked for example).  	For SunOS, the job is almost trivial, since the dynamic linker and 	all of it's structures are statically linked to the executable at 	link time.  Thus the symbol for the address we are looking for has 	already been added to the minimal symbol table for the executable's 	objfile at the time the symbol file's symbols were read, and all we 	have to do is look it up there.  Note that we explicitly do NOT want 	to find the copies in the shared library.  	The SVR4 version is a bit more complicated because the address 	is contained somewhere in the dynamic info section.  We have to go 	to a lot more work to discover the address of the debug base symbol. 	Because of this complexity, we cache the value we find and return that 	value on subsequent invocations.  Note there is no copy in the 	executable symbol tables.   */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|locate_base
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|SVR4_SHARED_LIBS
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|CORE_ADDR
name|address
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|symbolp
decl_stmt|;
comment|/* For SunOS, we want to limit the search for the debug base symbol to the      executable being debugged, since there is a duplicate named symbol in the      shared library.  We don't want the shared library versions. */
for|for
control|(
name|symbolp
operator|=
name|debug_base_symbols
init|;
operator|*
name|symbolp
operator|!=
name|NULL
condition|;
name|symbolp
operator|++
control|)
block|{
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
operator|*
name|symbolp
argument_list|,
name|NULL
argument_list|,
name|symfile_objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|msymbol
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|address
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
return|return
operator|(
name|address
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
else|#
directive|else
comment|/* SVR4_SHARED_LIBS */
comment|/* Check to see if we have a currently valid address, and if so, avoid      doing all this work again and just return the cached address.  If      we have no cached address, try to locate it in the dynamic info      section for ELF executables.  */
if|if
condition|(
name|debug_base
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|exec_bfd
operator|!=
name|NULL
operator|&&
name|bfd_get_flavour
argument_list|(
name|exec_bfd
argument_list|)
operator|==
name|bfd_target_elf_flavour
condition|)
name|debug_base
operator|=
name|elf_locate_base
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|HANDLE_SVR4_EXEC_EMULATORS
comment|/* Try it the hard way for emulated executables.  */
elseif|else
if|if
condition|(
name|inferior_pid
operator|!=
literal|0
operator|&&
name|target_has_execution
condition|)
name|proc_iterate_over_mappings
argument_list|(
name|look_for_base
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
name|debug_base
operator|)
return|;
endif|#
directive|endif
comment|/* !SVR4_SHARED_LIBS */
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	first_link_map_member -- locate first member in dynamic linker's map  SYNOPSIS  	static struct link_map *first_link_map_member (void)  DESCRIPTION  	Read in a copy of the first member in the inferior's dynamic 	link map from the inferior's dynamic linker structures, and return 	a pointer to the copy in our address space. */
end_comment

begin_function
specifier|static
name|struct
name|link_map
modifier|*
name|first_link_map_member
parameter_list|()
block|{
name|struct
name|link_map
modifier|*
name|lm
init|=
name|NULL
decl_stmt|;
ifndef|#
directive|ifndef
name|SVR4_SHARED_LIBS
name|read_memory
argument_list|(
name|debug_base
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dynamic_copy
argument_list|,
sizeof|sizeof
argument_list|(
name|dynamic_copy
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynamic_copy
operator|.
name|ld_version
operator|>=
literal|2
condition|)
block|{
comment|/* It is a version that we can deal with, so read in the secondary 	 structure and find the address of the link map list from it. */
name|read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|dynamic_copy
operator|.
name|ld_un
operator|.
name|ld_2
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ld_2_copy
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|link_dynamic_2
argument_list|)
argument_list|)
expr_stmt|;
name|lm
operator|=
name|ld_2_copy
operator|.
name|ld_loaded
expr_stmt|;
block|}
else|#
directive|else
comment|/* SVR4_SHARED_LIBS */
name|read_memory
argument_list|(
name|debug_base
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|debug_copy
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|r_debug
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FIXME:  Perhaps we should validate the info somehow, perhaps by      checking r_version for a known version number, or r_state for      RT_CONSISTENT. */
name|lm
operator|=
name|debug_copy
operator|.
name|r_map
expr_stmt|;
endif|#
directive|endif
comment|/* !SVR4_SHARED_LIBS */
return|return
operator|(
name|lm
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	free_solib -- free a so_list structure  SYNOPSIS  	void free_solib (struct so_list *so_list_ptr)  DESCRIPTION  	Free the memory used by a struct so_list.   */
end_comment

begin_function
name|void
name|free_solib
parameter_list|(
name|so
parameter_list|)
name|struct
name|so_list
modifier|*
name|so
decl_stmt|;
block|{
name|char
modifier|*
name|bfd_filename
decl_stmt|;
if|if
condition|(
name|so
operator|->
name|sections
condition|)
block|{
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|so
operator|->
name|sections
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|so
operator|->
name|abfd
condition|)
block|{
name|bfd_filename
operator|=
name|bfd_get_filename
argument_list|(
name|so
operator|->
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_close
argument_list|(
name|so
operator|->
name|abfd
argument_list|)
condition|)
name|warning
argument_list|(
literal|"cannot close \"%s\": %s"
argument_list|,
name|bfd_filename
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* This happens for the executable on SVR4.  */
name|bfd_filename
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bfd_filename
condition|)
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|bfd_filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|so
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	alloc_solib -- free a so_list structure  SYNOPSIS  	struct so_list *alloc_solib (struct link_map *lm)  DESCRIPTION  	Allocate the struct so_list to cache debugging information 	for a struct link_map entry in the target.   */
end_comment

begin_function
name|struct
name|so_list
modifier|*
name|alloc_solib
parameter_list|(
name|lm
parameter_list|)
name|struct
name|link_map
modifier|*
name|lm
decl_stmt|;
block|{
name|struct
name|so_list
modifier|*
name|new
decl_stmt|;
comment|/* Get next link map structure from inferior image and build a local 	 abbreviated load_map structure */
name|new
operator|=
operator|(
expr|struct
name|so_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|so_list
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|so_list
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|lmaddr
operator|=
name|lm
expr_stmt|;
name|read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|lm
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|new
operator|->
name|lm
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|link_map
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For SVR4 versions, the first entry in the link map is for the 	 inferior executable, so we must ignore it.  For some versions of 	 SVR4, it has no name.  For others (Solaris 2.3 for example), it 	 does have a name, so we can no longer use a missing name to 	 decide when to ignore it. */
if|if
condition|(
operator|!
name|IGNORE_FIRST_LINK_MAP_ENTRY
argument_list|(
name|new
operator|->
name|lm
argument_list|)
condition|)
block|{
name|int
name|errcode
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|target_read_string
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|LM_NAME
argument_list|(
name|new
argument_list|)
argument_list|,
operator|&
name|buffer
argument_list|,
name|MAX_PATH_SIZE
operator|-
literal|1
argument_list|,
operator|&
name|errcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"find_solib: Can't read pathname for load map: %s\n"
argument_list|,
name|safe_strerror
argument_list|(
name|errcode
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|new
operator|->
name|so_name
argument_list|,
name|buffer
argument_list|,
name|MAX_PATH_SIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
name|new
operator|->
name|so_name
index|[
name|MAX_PATH_SIZE
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|solib_map_sections
argument_list|(
name|new
argument_list|)
expr_stmt|;
block|}
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	find_solib -- step through list of shared objects  SYNOPSIS  	struct so_list *find_solib (struct so_list *so_list_ptr, int maybe_changed)  DESCRIPTION  	This module contains the routine which finds the names of any 	loaded "images" in the current process. The argument in must be 	NULL on the first call, and then the returned value must be passed 	in on subsequent calls. This provides the capability to "step" down 	the list of loaded objects. On the last object, a NULL value is 	returned.  	The arg and return value are "struct link_map" pointers, as defined 	in<link.h>.  	If it is expected that the contents of the shared library list has changed 	(e.g. when the special shared library breakpoint is hit) then pass non-zero 	for maybe_changed, otherwise zero.  */
end_comment

begin_function
specifier|static
name|struct
name|so_list
modifier|*
name|find_solib
parameter_list|(
name|so_list_ptr
parameter_list|,
name|maybe_changed
parameter_list|)
name|struct
name|so_list
modifier|*
name|so_list_ptr
decl_stmt|;
comment|/* Last lm or NULL for first one */
name|int
name|maybe_changed
decl_stmt|;
comment|/* non-zero if shlib list might have changed */
block|{
name|struct
name|link_map
modifier|*
name|lm
init|=
name|NULL
decl_stmt|;
name|struct
name|so_list
modifier|*
name|new
decl_stmt|;
name|struct
name|so_list
modifier|*
name|so_list_next
decl_stmt|;
name|struct
name|so_list
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|prev
decl_stmt|;
if|if
condition|(
name|so_list_ptr
operator|==
name|NULL
condition|)
block|{
name|struct
name|so_list
modifier|*
modifier|*
name|map
decl_stmt|;
comment|/* If we have not already read in the dynamic linking structures 	 from the inferior, lookup the address of the base structure. */
if|if
condition|(
name|debug_base
operator|==
literal|0
condition|)
name|debug_base
operator|=
name|locate_base
argument_list|()
expr_stmt|;
if|if
condition|(
name|debug_base
operator|!=
literal|0
condition|)
block|{
comment|/* Read the base structure in and find the address of the first 	     link map list member. */
name|lm
operator|=
name|first_link_map_member
argument_list|()
expr_stmt|;
block|}
else|else
name|lm
operator|=
name|NULL
expr_stmt|;
name|prev
operator|=
operator|&
name|so_list_head
expr_stmt|;
name|so_list_ptr
operator|=
name|so_list_head
expr_stmt|;
block|}
else|else
block|{
comment|/* We have been called before, and are in the process of walking 	 the shared library list.  Advance to the next shared object.  	 Always read from the target to check to see if any were 	 added, but be quiet if we can't read from the target any more. */
name|int
name|status
init|=
name|target_read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|so_list_ptr
operator|->
name|lmaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|so_list_ptr
operator|->
name|lm
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|link_map
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
name|lm
operator|=
name|LM_NEXT
argument_list|(
name|so_list_ptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lm
operator|=
name|NULL
expr_stmt|;
block|}
name|prev
operator|=
operator|&
name|so_list_ptr
operator|->
name|next
expr_stmt|;
name|so_list_ptr
operator|=
name|so_list_ptr
operator|->
name|next
expr_stmt|;
block|}
comment|/* If we don't believe that the list has changed, just return the cached copy. */
if|if
condition|(
operator|!
name|maybe_changed
condition|)
return|return
operator|(
name|so_list_ptr
operator|)
return|;
comment|/* At this point, lm is the address of the next list element in the target and      so_list_ptr is our cached entry for it. */
if|if
condition|(
name|lm
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|so_list_ptr
operator|==
name|NULL
operator|||
name|so_list_ptr
operator|->
name|lmaddr
operator|!=
name|lm
condition|)
block|{
comment|/* We have detected a change in the list.  Check for a deletion by searching 	     forward in the cached list */
if|if
condition|(
name|so_list_ptr
condition|)
block|{
for|for
control|(
name|p
operator|=
name|so_list_ptr
operator|->
name|next
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
if|if
condition|(
name|p
operator|->
name|lmaddr
operator|==
name|lm
condition|)
break|break;
block|}
else|else
name|p
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
comment|/* This lib has been deleted */
while|while
condition|(
name|so_list_ptr
operator|!=
name|p
condition|)
block|{
operator|*
name|prev
operator|=
name|so_list_ptr
operator|->
name|next
expr_stmt|;
name|free_solib
argument_list|(
name|so_list_ptr
argument_list|)
expr_stmt|;
name|so_list_ptr
operator|=
operator|*
name|prev
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* A new lib has been inserted into the list */
name|new
operator|=
name|alloc_solib
argument_list|(
name|lm
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|so_list_ptr
expr_stmt|;
operator|*
name|prev
operator|=
name|new
expr_stmt|;
name|so_list_ptr
operator|=
name|new
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|so_list_ptr
operator|!=
name|NULL
condition|)
block|{
name|so_list_head
operator|=
name|new
expr_stmt|;
if|if
condition|(
operator|!
name|solib_cleanup_queued
condition|)
block|{
name|make_run_cleanup
argument_list|(
name|do_clear_solib
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|solib_cleanup_queued
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|so_list_next
operator|=
name|new
expr_stmt|;
if|if
condition|(
name|lm
condition|)
name|target_read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|lm
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|new
operator|->
name|lm
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|link_map
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For SVR4 versions, the first entry in the link map is for the 	 inferior executable, so we must ignore it.  For some versions of 	 SVR4, it has no name.  For others (Solaris 2.3 for example), it 	 does have a name, so we can no longer use a missing name to 	 decide when to ignore it. */
if|if
condition|(
name|lm
operator|&&
name|new
operator|&&
operator|!
name|IGNORE_FIRST_LINK_MAP_ENTRY
argument_list|(
name|new
operator|->
name|lm
argument_list|)
condition|)
block|{
name|int
name|errcode
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|target_read_string
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|LM_NAME
argument_list|(
name|new
argument_list|)
argument_list|,
operator|&
name|buffer
argument_list|,
name|MAX_PATH_SIZE
operator|-
literal|1
argument_list|,
operator|&
name|errcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
operator|!=
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"find_solib: Can't read pathname for load map: %s\n"
argument_list|,
name|safe_strerror
argument_list|(
name|errcode
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|so_list_next
operator|)
return|;
block|}
name|strncpy
argument_list|(
name|new
operator|->
name|so_name
argument_list|,
name|buffer
argument_list|,
name|MAX_PATH_SIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
name|new
operator|->
name|so_name
index|[
name|MAX_PATH_SIZE
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|catch_errors
argument_list|(
name|solib_map_sections
argument_list|,
name|new
argument_list|,
literal|"Error while mapping shared library sections:\n"
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|so_list_ptr
operator|)
return|;
block|}
end_function

begin_comment
comment|/* A small stub to get us past the arg-passing pinhole of catch_errors.  */
end_comment

begin_function
specifier|static
name|int
name|symbol_add_stub
parameter_list|(
name|arg
parameter_list|)
name|PTR
name|arg
decl_stmt|;
block|{
specifier|register
name|struct
name|so_list
modifier|*
name|so
init|=
operator|(
expr|struct
name|so_list
operator|*
operator|)
name|arg
decl_stmt|;
comment|/* catch_errs bogon */
name|CORE_ADDR
name|text_addr
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|so
operator|->
name|textsection
condition|)
name|text_addr
operator|=
name|so
operator|->
name|textsection
operator|->
name|addr
expr_stmt|;
elseif|else
if|if
condition|(
name|so
operator|->
name|abfd
operator|!=
name|NULL
condition|)
block|{
name|asection
modifier|*
name|lowest_sect
decl_stmt|;
comment|/* If we didn't find a mapped non zero sized .text section, set up 	 text_addr so that the relocation in symbol_file_add does no harm.  */
name|lowest_sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|so
operator|->
name|abfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lowest_sect
operator|==
name|NULL
condition|)
name|bfd_map_over_sections
argument_list|(
name|so
operator|->
name|abfd
argument_list|,
name|find_lowest_section
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|lowest_sect
argument_list|)
expr_stmt|;
if|if
condition|(
name|lowest_sect
condition|)
name|text_addr
operator|=
name|bfd_section_vma
argument_list|(
name|so
operator|->
name|abfd
argument_list|,
name|lowest_sect
argument_list|)
operator|+
operator|(
name|CORE_ADDR
operator|)
name|LM_ADDR
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
name|ALL_OBJFILES
argument_list|(
argument|so -> objfile
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|so
operator|->
name|objfile
operator|->
name|name
argument_list|,
name|so
operator|->
name|so_name
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
name|so
operator|->
name|objfile
operator|=
name|symbol_file_add
argument_list|(
name|so
operator|->
name|so_name
argument_list|,
name|so
operator|->
name|from_tty
argument_list|,
name|text_addr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This function will check the so name to see if matches the main list.    In some system the main object is in the list, which we want to exclude */
end_comment

begin_function
specifier|static
name|int
name|match_main
parameter_list|(
name|soname
parameter_list|)
name|char
modifier|*
name|soname
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|mainp
decl_stmt|;
for|for
control|(
name|mainp
operator|=
name|main_name_list
init|;
operator|*
name|mainp
operator|!=
name|NULL
condition|;
name|mainp
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|soname
argument_list|,
operator|*
name|mainp
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  GLOBAL FUNCTION  	solib_add -- add a shared library file to the symtab and section list  SYNOPSIS  	void solib_add (char *arg_string, int from_tty, 			struct target_ops *target)  DESCRIPTION  */
end_comment

begin_function
name|void
name|solib_add
parameter_list|(
name|arg_string
parameter_list|,
name|from_tty
parameter_list|,
name|target
parameter_list|)
name|char
modifier|*
name|arg_string
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
block|{
specifier|register
name|struct
name|so_list
modifier|*
name|so
init|=
name|NULL
decl_stmt|;
comment|/* link map state variable */
comment|/* Last shared library that we read.  */
name|struct
name|so_list
modifier|*
name|so_last
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|re_err
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|old
decl_stmt|;
if|if
condition|(
operator|(
name|re_err
operator|=
name|re_comp
argument_list|(
name|arg_string
condition|?
name|arg_string
else|:
literal|"."
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"Invalid regexp: %s"
argument_list|,
name|re_err
argument_list|)
expr_stmt|;
block|}
comment|/* Add the shared library sections to the section table of the      specified target, if any.  */
if|if
condition|(
name|target
condition|)
block|{
comment|/* Count how many new section_table entries there are.  */
name|so
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|so
operator|=
name|find_solib
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_name
index|[
literal|0
index|]
operator|&&
operator|!
name|match_main
argument_list|(
name|so
operator|->
name|so_name
argument_list|)
condition|)
block|{
name|count
operator|+=
name|so
operator|->
name|sections_end
operator|-
name|so
operator|->
name|sections
expr_stmt|;
block|}
block|}
if|if
condition|(
name|count
condition|)
block|{
name|int
name|update_coreops
decl_stmt|;
comment|/* We must update the to_sections field in the core_ops structure 	     here, otherwise we dereference a potential dangling pointer 	     for each call to target_read/write_memory within this routine.  */
name|update_coreops
operator|=
name|core_ops
operator|.
name|to_sections
operator|==
name|target
operator|->
name|to_sections
expr_stmt|;
comment|/* Reallocate the target's section table including the new size.  */
if|if
condition|(
name|target
operator|->
name|to_sections
condition|)
block|{
name|old
operator|=
name|target
operator|->
name|to_sections_end
operator|-
name|target
operator|->
name|to_sections
expr_stmt|;
name|target
operator|->
name|to_sections
operator|=
operator|(
expr|struct
name|section_table
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|target
operator|->
name|to_sections
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_table
argument_list|)
operator|)
operator|*
operator|(
name|count
operator|+
name|old
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|old
operator|=
literal|0
expr_stmt|;
name|target
operator|->
name|to_sections
operator|=
operator|(
expr|struct
name|section_table
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_table
argument_list|)
operator|)
operator|*
name|count
argument_list|)
expr_stmt|;
block|}
name|target
operator|->
name|to_sections_end
operator|=
name|target
operator|->
name|to_sections
operator|+
operator|(
name|count
operator|+
name|old
operator|)
expr_stmt|;
comment|/* Update the to_sections field in the core_ops structure 	     if needed.  */
if|if
condition|(
name|update_coreops
condition|)
block|{
name|core_ops
operator|.
name|to_sections
operator|=
name|target
operator|->
name|to_sections
expr_stmt|;
name|core_ops
operator|.
name|to_sections_end
operator|=
name|target
operator|->
name|to_sections_end
expr_stmt|;
block|}
comment|/* Add these section table entries to the target's table.  */
while|while
condition|(
operator|(
name|so
operator|=
name|find_solib
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_name
index|[
literal|0
index|]
condition|)
block|{
name|count
operator|=
name|so
operator|->
name|sections_end
operator|-
name|so
operator|->
name|sections
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|target
operator|->
name|to_sections
operator|+
name|old
operator|)
argument_list|,
name|so
operator|->
name|sections
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|section_table
argument_list|)
operator|)
operator|*
name|count
argument_list|)
expr_stmt|;
name|old
operator|+=
name|count
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Now add the symbol files.  */
while|while
condition|(
operator|(
name|so
operator|=
name|find_solib
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_name
index|[
literal|0
index|]
operator|&&
name|re_exec
argument_list|(
name|so
operator|->
name|so_name
argument_list|)
operator|&&
operator|!
name|match_main
argument_list|(
name|so
operator|->
name|so_name
argument_list|)
condition|)
block|{
name|so
operator|->
name|from_tty
operator|=
name|from_tty
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|symbols_loaded
condition|)
block|{
if|if
condition|(
name|from_tty
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"Symbols already loaded for %s\n"
argument_list|,
name|so
operator|->
name|so_name
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|catch_errors
argument_list|(
name|symbol_add_stub
argument_list|,
name|so
argument_list|,
literal|"Error while reading shared library symbols:\n"
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
condition|)
block|{
name|so_last
operator|=
name|so
expr_stmt|;
name|so
operator|->
name|symbols_loaded
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* Getting new symbols may change our opinion about what is      frameless.  */
if|if
condition|(
name|so_last
condition|)
name|reinit_frame_cache
argument_list|()
expr_stmt|;
if|if
condition|(
name|so_last
condition|)
name|special_symbol_handling
argument_list|(
name|so_last
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	info_sharedlibrary_command -- code for "info sharedlibrary"  SYNOPSIS  	static void info_sharedlibrary_command ()  DESCRIPTION  	Walk through the shared library list and print information 	about each attached library. */
end_comment

begin_function
specifier|static
name|void
name|info_sharedlibrary_command
parameter_list|(
name|ignore
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|ignore
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
specifier|register
name|struct
name|so_list
modifier|*
name|so
init|=
name|NULL
decl_stmt|;
comment|/* link map state variable */
name|int
name|header_done
init|=
literal|0
decl_stmt|;
name|int
name|addr_width
decl_stmt|;
name|char
modifier|*
name|addr_fmt
decl_stmt|;
if|if
condition|(
name|exec_bfd
operator|==
name|NULL
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"No exec file.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
ifndef|#
directive|ifndef
name|TARGET_ELF64
name|addr_width
operator|=
literal|8
operator|+
literal|4
expr_stmt|;
name|addr_fmt
operator|=
literal|"08l"
expr_stmt|;
else|#
directive|else
name|addr_width
operator|=
literal|16
operator|+
literal|4
expr_stmt|;
name|addr_fmt
operator|=
literal|"016l"
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|(
name|so
operator|=
name|find_solib
argument_list|(
name|so
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_name
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|header_done
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"%-*s%-*s%-12s%s\n"
argument_list|,
name|addr_width
argument_list|,
literal|"From"
argument_list|,
name|addr_width
argument_list|,
literal|"To"
argument_list|,
literal|"Syms Read"
argument_list|,
literal|"Shared Object Library"
argument_list|)
expr_stmt|;
name|header_done
operator|++
expr_stmt|;
block|}
name|printf_unfiltered
argument_list|(
literal|"%-*s"
argument_list|,
name|addr_width
argument_list|,
name|local_hex_string_custom
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|LM_ADDR
argument_list|(
name|so
argument_list|)
argument_list|,
name|addr_fmt
argument_list|)
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%-*s"
argument_list|,
name|addr_width
argument_list|,
name|local_hex_string_custom
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|so
operator|->
name|lmend
argument_list|,
name|addr_fmt
argument_list|)
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%-12s"
argument_list|,
name|so
operator|->
name|symbols_loaded
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%s\n"
argument_list|,
name|so
operator|->
name|so_name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|so_list_head
operator|==
name|NULL
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"No shared libraries loaded at this time.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  GLOBAL FUNCTION  	solib_address -- check to see if an address is in a shared lib  SYNOPSIS  	char * solib_address (CORE_ADDR address)  DESCRIPTION  	Provides a hook for other gdb routines to discover whether or 	not a particular address is within the mapped address space of 	a shared library.  Any address between the base mapping address 	and the first address beyond the end of the last mapping, is 	considered to be within the shared library address space, for 	our purposes.  	For example, this routine is called at one point to disable 	breakpoints which are in shared libraries that are not currently 	mapped in.  */
end_comment

begin_function
name|char
modifier|*
name|solib_address
parameter_list|(
name|address
parameter_list|)
name|CORE_ADDR
name|address
decl_stmt|;
block|{
specifier|register
name|struct
name|so_list
modifier|*
name|so
init|=
literal|0
decl_stmt|;
comment|/* link map state variable */
while|while
condition|(
operator|(
name|so
operator|=
name|find_solib
argument_list|(
name|so
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_name
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|address
operator|>=
operator|(
name|CORE_ADDR
operator|)
name|LM_ADDR
argument_list|(
name|so
argument_list|)
operator|)
operator|&&
operator|(
name|address
operator|<
operator|(
name|CORE_ADDR
operator|)
name|so
operator|->
name|lmend
operator|)
condition|)
return|return
operator|(
name|so
operator|->
name|so_name
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Called by free_all_symtabs */
end_comment

begin_function
name|void
name|clear_solib
parameter_list|()
block|{
name|struct
name|so_list
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|bfd_filename
decl_stmt|;
while|while
condition|(
name|so_list_head
condition|)
block|{
name|next
operator|=
name|so_list_head
operator|->
name|next
expr_stmt|;
name|free_solib
argument_list|(
name|so_list_head
argument_list|)
expr_stmt|;
name|so_list_head
operator|=
name|next
expr_stmt|;
block|}
name|debug_base
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_clear_solib
parameter_list|(
name|dummy
parameter_list|)
name|PTR
name|dummy
decl_stmt|;
block|{
name|solib_cleanup_queued
operator|=
literal|0
expr_stmt|;
name|clear_solib
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SVR4_SHARED_LIBS
end_ifdef

begin_comment
comment|/* Return 1 if PC lies in the dynamic symbol resolution code of the    SVR4 run time loader.  */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|interp_text_sect_low
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|interp_text_sect_high
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|interp_plt_sect_low
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|interp_plt_sect_high
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|in_svr4_dynsym_resolve_code
parameter_list|(
name|pc
parameter_list|)
name|CORE_ADDR
name|pc
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|pc
operator|>=
name|interp_text_sect_low
operator|&&
name|pc
operator|<
name|interp_text_sect_high
operator|)
operator|||
operator|(
name|pc
operator|>=
name|interp_plt_sect_low
operator|&&
name|pc
operator|<
name|interp_plt_sect_high
operator|)
operator|||
name|in_plt_section
argument_list|(
name|pc
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  LOCAL FUNCTION  	disable_break -- remove the "mapping changed" breakpoint  SYNOPSIS  	static int disable_break ()  DESCRIPTION  	Removes the breakpoint that gets hit when the dynamic linker 	completes a mapping change.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SVR4_SHARED_LIBS
end_ifndef

begin_function
specifier|static
name|int
name|disable_break
parameter_list|()
block|{
name|int
name|status
init|=
literal|1
decl_stmt|;
ifndef|#
directive|ifndef
name|SVR4_SHARED_LIBS
name|int
name|in_debugger
init|=
literal|0
decl_stmt|;
comment|/* Read the debugger structure from the inferior to retrieve the      address of the breakpoint and the original contents of the      breakpoint address.  Remove the breakpoint by writing the original      contents back. */
name|read_memory
argument_list|(
name|debug_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|debug_copy
argument_list|,
sizeof|sizeof
argument_list|(
name|debug_copy
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set `in_debugger' to zero now. */
name|write_memory
argument_list|(
name|flag_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|in_debugger
argument_list|,
sizeof|sizeof
argument_list|(
name|in_debugger
argument_list|)
argument_list|)
expr_stmt|;
name|breakpoint_addr
operator|=
operator|(
name|CORE_ADDR
operator|)
name|debug_copy
operator|.
name|ldd_bp_addr
expr_stmt|;
name|write_memory
argument_list|(
name|breakpoint_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|debug_copy
operator|.
name|ldd_bp_inst
argument_list|,
sizeof|sizeof
argument_list|(
name|debug_copy
operator|.
name|ldd_bp_inst
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SVR4_SHARED_LIBS */
comment|/* Note that breakpoint address and original contents are in our address      space, so we just need to write the original contents back. */
if|if
condition|(
name|memory_remove_breakpoint
argument_list|(
name|breakpoint_addr
argument_list|,
name|shadow_contents
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|status
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !SVR4_SHARED_LIBS */
comment|/* For the SVR4 version, we always know the breakpoint address.  For the      SunOS version we don't know it until the above code is executed.      Grumble if we are stopped anywhere besides the breakpoint address. */
if|if
condition|(
name|stop_pc
operator|!=
name|breakpoint_addr
condition|)
block|{
name|warning
argument_list|(
literal|"stopped at unknown breakpoint while handling shared libraries"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* #ifdef SVR4_SHARED_LIBS */
end_comment

begin_comment
comment|/*  LOCAL FUNCTION  	enable_break -- arrange for dynamic linker to hit breakpoint  SYNOPSIS  	int enable_break (void)  DESCRIPTION  	Both the SunOS and the SVR4 dynamic linkers have, as part of their 	debugger interface, support for arranging for the inferior to hit 	a breakpoint after mapping in the shared libraries.  This function 	enables that breakpoint.  	For SunOS, there is a special flag location (in_debugger) which we 	set to 1.  When the dynamic linker sees this flag set, it will set 	a breakpoint at a location known only to itself, after saving the 	original contents of that place and the breakpoint address itself, 	in it's own internal structures.  When we resume the inferior, it 	will eventually take a SIGTRAP when it runs into the breakpoint. 	We handle this (in a different place) by restoring the contents of 	the breakpointed location (which is only known after it stops), 	chasing around to locate the shared libraries that have been 	loaded, then resuming.  	For SVR4, the debugger interface structure contains a member (r_brk) 	which is statically initialized at the time the shared library is 	built, to the offset of a function (_r_debug_state) which is guaran- 	teed to be called once before mapping in a library, and again when 	the mapping is complete.  At the time we are examining this member, 	it contains only the unrelocated offset of the function, so we have 	to do our own relocation.  Later, when the dynamic linker actually 	runs, it relocates r_brk to be the actual address of _r_debug_state().  	The debugger interface structure also contains an enumeration which 	is set to either RT_ADD or RT_DELETE prior to changing the mapping, 	depending upon whether or not the library is being mapped or unmapped, 	and then set to RT_CONSISTENT after the library is mapped/unmapped. */
end_comment

begin_function
specifier|static
name|int
name|enable_break
parameter_list|()
block|{
name|int
name|success
init|=
literal|0
decl_stmt|;
ifndef|#
directive|ifndef
name|SVR4_SHARED_LIBS
name|int
name|j
decl_stmt|;
name|int
name|in_debugger
decl_stmt|;
comment|/* Get link_dynamic structure */
name|j
operator|=
name|target_read_memory
argument_list|(
name|debug_base
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dynamic_copy
argument_list|,
sizeof|sizeof
argument_list|(
name|dynamic_copy
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
condition|)
block|{
comment|/* unreadable */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Calc address of debugger interface structure */
name|debug_addr
operator|=
operator|(
name|CORE_ADDR
operator|)
name|dynamic_copy
operator|.
name|ldd
expr_stmt|;
comment|/* Calc address of `in_debugger' member of debugger interface structure */
name|flag_addr
operator|=
name|debug_addr
operator|+
call|(
name|CORE_ADDR
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|debug_copy
operator|.
name|ldd_in_debugger
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|debug_copy
argument_list|)
expr_stmt|;
comment|/* Write a value of 1 to this member.  */
name|in_debugger
operator|=
literal|1
expr_stmt|;
name|write_memory
argument_list|(
name|flag_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|in_debugger
argument_list|,
sizeof|sizeof
argument_list|(
name|in_debugger
argument_list|)
argument_list|)
expr_stmt|;
name|success
operator|=
literal|1
expr_stmt|;
else|#
directive|else
comment|/* SVR4_SHARED_LIBS */
ifdef|#
directive|ifdef
name|BKPT_AT_SYMBOL
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|char
modifier|*
modifier|*
name|bkpt_namep
decl_stmt|;
name|asection
modifier|*
name|interp_sect
decl_stmt|;
comment|/* First, remove all the solib event breakpoints.  Their addresses      may have changed since the last time we ran the program.  */
name|remove_solib_event_breakpoints
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SVR4_SHARED_LIBS
name|interp_text_sect_low
operator|=
name|interp_text_sect_high
operator|=
literal|0
expr_stmt|;
name|interp_plt_sect_low
operator|=
name|interp_plt_sect_high
operator|=
literal|0
expr_stmt|;
comment|/* Find the .interp section; if not found, warn the user and drop      into the old breakpoint at symbol code.  */
name|interp_sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|exec_bfd
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|interp_sect
condition|)
block|{
name|unsigned
name|int
name|interp_sect_size
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|CORE_ADDR
name|load_addr
decl_stmt|;
name|bfd
modifier|*
name|tmp_bfd
decl_stmt|;
name|CORE_ADDR
name|sym_addr
init|=
literal|0
decl_stmt|;
comment|/* Read the contents of the .interp section into a local buffer; 	 the contents specify the dynamic linker this program uses.  */
name|interp_sect_size
operator|=
name|bfd_section_size
argument_list|(
name|exec_bfd
argument_list|,
name|interp_sect
argument_list|)
expr_stmt|;
name|buf
operator|=
name|alloca
argument_list|(
name|interp_sect_size
argument_list|)
expr_stmt|;
name|bfd_get_section_contents
argument_list|(
name|exec_bfd
argument_list|,
name|interp_sect
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|interp_sect_size
argument_list|)
expr_stmt|;
comment|/* Now we need to figure out where the dynamic linker was 	 loaded so that we can load its symbols and place a breakpoint 	 in the dynamic linker itself.  	 This address is stored on the stack.  However, I've been unable 	 to find any magic formula to find it for Solaris (appears to 	 be trivial on GNU/Linux).  Therefore, we have to try an alternate 	 mechanism to find the dynamic linker's base address.  */
name|tmp_bfd
operator|=
name|bfd_openr
argument_list|(
name|buf
argument_list|,
name|gnutarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_bfd
operator|==
name|NULL
condition|)
goto|goto
name|bkpt_at_symbol
goto|;
comment|/* Make sure the dynamic linker's really a useful object.  */
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|tmp_bfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
name|warning
argument_list|(
literal|"Unable to grok dynamic linker %s as an object file"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|bfd_close
argument_list|(
name|tmp_bfd
argument_list|)
expr_stmt|;
goto|goto
name|bkpt_at_symbol
goto|;
block|}
comment|/* We find the dynamic linker's base address by examining the 	 current pc (which point at the entry point for the dynamic 	 linker) and subtracting the offset of the entry point.  */
name|load_addr
operator|=
name|read_pc
argument_list|()
operator|-
name|tmp_bfd
operator|->
name|start_address
expr_stmt|;
comment|/* Record the relocated start and end address of the dynamic linker 	 text and plt section for in_svr4_dynsym_resolve_code.  */
name|interp_sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|tmp_bfd
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
if|if
condition|(
name|interp_sect
condition|)
block|{
name|interp_text_sect_low
operator|=
name|bfd_section_vma
argument_list|(
name|tmp_bfd
argument_list|,
name|interp_sect
argument_list|)
operator|+
name|load_addr
expr_stmt|;
name|interp_text_sect_high
operator|=
name|interp_text_sect_low
operator|+
name|bfd_section_size
argument_list|(
name|tmp_bfd
argument_list|,
name|interp_sect
argument_list|)
expr_stmt|;
block|}
name|interp_sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|tmp_bfd
argument_list|,
literal|".plt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|interp_sect
condition|)
block|{
name|interp_plt_sect_low
operator|=
name|bfd_section_vma
argument_list|(
name|tmp_bfd
argument_list|,
name|interp_sect
argument_list|)
operator|+
name|load_addr
expr_stmt|;
name|interp_plt_sect_high
operator|=
name|interp_plt_sect_low
operator|+
name|bfd_section_size
argument_list|(
name|tmp_bfd
argument_list|,
name|interp_sect
argument_list|)
expr_stmt|;
block|}
comment|/* Now try to set a breakpoint in the dynamic linker.  */
for|for
control|(
name|bkpt_namep
operator|=
name|solib_break_names
init|;
operator|*
name|bkpt_namep
operator|!=
name|NULL
condition|;
name|bkpt_namep
operator|++
control|)
block|{
name|sym_addr
operator|=
name|bfd_lookup_symbol
argument_list|(
name|tmp_bfd
argument_list|,
operator|*
name|bkpt_namep
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_addr
operator|!=
literal|0
condition|)
break|break;
block|}
comment|/* We're done with the temporary bfd.  */
name|bfd_close
argument_list|(
name|tmp_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_addr
operator|!=
literal|0
condition|)
block|{
name|create_solib_event_breakpoint
argument_list|(
name|load_addr
operator|+
name|sym_addr
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* For whatever reason we couldn't set a breakpoint in the dynamic 	 linker.  Warn and drop into the old code.  */
name|bkpt_at_symbol
label|:
name|warning
argument_list|(
literal|"Unable to find dynamic linker breakpoint function.\nGDB will be unable to debug shared library initializers\nand track explicitly loaded dynamic code."
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Scan through the list of symbols, trying to look up the symbol and      set a breakpoint there.  Terminate loop when we/if we succeed. */
name|breakpoint_addr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bkpt_namep
operator|=
name|bkpt_names
init|;
operator|*
name|bkpt_namep
operator|!=
name|NULL
condition|;
name|bkpt_namep
operator|++
control|)
block|{
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
operator|*
name|bkpt_namep
argument_list|,
name|NULL
argument_list|,
name|symfile_objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|msymbol
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|create_solib_event_breakpoint
argument_list|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* Nothing good happened.  */
name|success
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* BKPT_AT_SYMBOL */
endif|#
directive|endif
comment|/* !SVR4_SHARED_LIBS */
return|return
operator|(
name|success
operator|)
return|;
block|}
end_function

begin_comment
comment|/*    GLOBAL FUNCTION    	solib_create_inferior_hook -- shared library startup support    SYNOPSIS    	void solib_create_inferior_hook()    DESCRIPTION    	When gdb starts up the inferior, it nurses it along (through the 	shell) until it is ready to execute it's first instruction.  At this 	point, this function gets called via expansion of the macro 	SOLIB_CREATE_INFERIOR_HOOK.  	For SunOS executables, this first instruction is typically the 	one at "_start", or a similar text label, regardless of whether 	the executable is statically or dynamically linked.  The runtime 	startup code takes care of dynamically linking in any shared 	libraries, once gdb allows the inferior to continue.  	For SVR4 executables, this first instruction is either the first 	instruction in the dynamic linker (for dynamically linked 	executables) or the instruction at "start" for statically linked 	executables.  For dynamically linked executables, the system 	first exec's /lib/libc.so.N, which contains the dynamic linker, 	and starts it running.  The dynamic linker maps in any needed 	shared libraries, maps in the actual user executable, and then 	jumps to "start" in the user executable.  	For both SunOS shared libraries, and SVR4 shared libraries, we 	can arrange to cooperate with the dynamic linker to discover the 	names of shared libraries that are dynamically linked, and the 	base addresses to which they are linked.  	This function is responsible for discovering those names and 	addresses, and saving sufficient information about them to allow 	their symbols to be read at a later time.  FIXME  	Between enable_break() and disable_break(), this code does not 	properly handle hitting breakpoints which the user might have 	set in the startup code or in the dynamic linker itself.  Proper 	handling will probably have to wait until the implementation is 	changed to use the "breakpoint handler function" method.  	Also, what if child has exit()ed?  Must exit loop somehow.   */
end_comment

begin_function
name|void
name|solib_create_inferior_hook
parameter_list|()
block|{
comment|/* If we are using the BKPT_AT_SYMBOL code, then we don't need the base      yet.  In fact, in the case of a SunOS4 executable being run on      Solaris, we can't get it yet.  find_solib will get it when it needs      it.  */
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|SVR4_SHARED_LIBS
argument_list|)
operator|&&
name|defined
argument_list|(
name|BKPT_AT_SYMBOL
argument_list|)
operator|)
if|if
condition|(
operator|(
name|debug_base
operator|=
name|locate_base
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Can't find the symbol or the executable is statically linked. */
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|enable_break
argument_list|()
condition|)
block|{
name|warning
argument_list|(
literal|"shared library handler failed to enable breakpoint"
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SVR4_SHARED_LIBS
argument_list|)
operator|||
name|defined
argument_list|(
name|_SCO_DS
argument_list|)
comment|/* SCO and SunOS need the loop below, other systems should be using the      special shared library breakpoints and the shared library breakpoint      service routine.       Now run the target.  It will eventually hit the breakpoint, at      which point all of the libraries will have been mapped in and we      can go groveling around in the dynamic linker structures to find      out what we need to know about them. */
name|clear_proceed_status
argument_list|()
expr_stmt|;
name|stop_soon_quietly
operator|=
literal|1
expr_stmt|;
name|stop_signal
operator|=
name|TARGET_SIGNAL_0
expr_stmt|;
do|do
block|{
name|target_resume
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|stop_signal
argument_list|)
expr_stmt|;
name|wait_for_inferior
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|stop_signal
operator|!=
name|TARGET_SIGNAL_TRAP
condition|)
do|;
name|stop_soon_quietly
operator|=
literal|0
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_SCO_DS
argument_list|)
comment|/* We are now either at the "mapping complete" breakpoint (or somewhere      else, a condition we aren't prepared to deal with anyway), so adjust      the PC as necessary after a breakpoint, disable the breakpoint, and      add any shared libraries that were mapped in. */
if|if
condition|(
name|DECR_PC_AFTER_BREAK
condition|)
block|{
name|stop_pc
operator|-=
name|DECR_PC_AFTER_BREAK
expr_stmt|;
name|write_register
argument_list|(
name|PC_REGNUM
argument_list|,
name|stop_pc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|disable_break
argument_list|()
condition|)
block|{
name|warning
argument_list|(
literal|"shared library handler failed to disable breakpoint"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|auto_solib_add
condition|)
name|solib_add
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|target_ops
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ! _SCO_DS */
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	special_symbol_handling -- additional shared library symbol handling  SYNOPSIS  	void special_symbol_handling (struct so_list *so)  DESCRIPTION  	Once the symbols from a shared object have been loaded in the usual 	way, we are called to do any system specific symbol handling that  	is needed.  	For SunOS4, this consists of grunging around in the dynamic 	linkers structures to find symbol definitions for "common" symbols 	and adding them to the minimal symbol table for the runtime common 	objfile.  */
end_comment

begin_function
specifier|static
name|void
name|special_symbol_handling
parameter_list|(
name|so
parameter_list|)
name|struct
name|so_list
modifier|*
name|so
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|SVR4_SHARED_LIBS
name|int
name|j
decl_stmt|;
if|if
condition|(
name|debug_addr
operator|==
literal|0
condition|)
block|{
comment|/* Get link_dynamic structure */
name|j
operator|=
name|target_read_memory
argument_list|(
name|debug_base
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dynamic_copy
argument_list|,
sizeof|sizeof
argument_list|(
name|dynamic_copy
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
condition|)
block|{
comment|/* unreadable */
return|return;
block|}
comment|/* Calc address of debugger interface structure */
comment|/* FIXME, this needs work for cross-debugging of core files 	 (byteorder, size, alignment, etc).  */
name|debug_addr
operator|=
operator|(
name|CORE_ADDR
operator|)
name|dynamic_copy
operator|.
name|ldd
expr_stmt|;
block|}
comment|/* Read the debugger structure from the inferior, just to make sure      we have a current copy. */
name|j
operator|=
name|target_read_memory
argument_list|(
name|debug_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|debug_copy
argument_list|,
sizeof|sizeof
argument_list|(
name|debug_copy
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
condition|)
return|return;
comment|/* unreadable */
comment|/* Get common symbol definitions for the loaded object. */
if|if
condition|(
name|debug_copy
operator|.
name|ldd_cp
condition|)
block|{
name|solib_add_common_symbols
argument_list|(
name|debug_copy
operator|.
name|ldd_cp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !SVR4_SHARED_LIBS */
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	sharedlibrary_command -- handle command to explicitly add library  SYNOPSIS  	static void sharedlibrary_command (char *args, int from_tty)  DESCRIPTION  */
end_comment

begin_function
specifier|static
name|void
name|sharedlibrary_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|dont_repeat
argument_list|()
expr_stmt|;
name|solib_add
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|,
operator|(
expr|struct
name|target_ops
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_LINK_H */
end_comment

begin_function
name|void
name|_initialize_solib
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|HAVE_LINK_H
name|add_com
argument_list|(
literal|"sharedlibrary"
argument_list|,
name|class_files
argument_list|,
name|sharedlibrary_command
argument_list|,
literal|"Load shared object library symbols for files matching REGEXP."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"sharedlibrary"
argument_list|,
name|info_sharedlibrary_command
argument_list|,
literal|"Status of loaded shared object libraries."
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"auto-solib-add"
argument_list|,
name|class_support
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|auto_solib_add
argument_list|,
literal|"Set autoloading of shared library symbols.\n\ If nonzero, symbols from all shared object libraries will be loaded\n\ automatically when the inferior begins execution or when the dynamic linker\n\ informs gdb that a new library has been loaded.  Otherwise, symbols\n\ must be loaded manually, using `sharedlibrary'."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"solib-absolute-prefix"
argument_list|,
name|class_support
argument_list|,
name|var_filename
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|solib_absolute_prefix
argument_list|,
literal|"Set prefix for loading absolute shared library symbol files.\n\ For other (relative) files, you can add values using `set solib-search-path'."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"solib-search-path"
argument_list|,
name|class_support
argument_list|,
name|var_string
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|solib_search_path
argument_list|,
literal|"Set the search path for loading non-absolute shared library symbol files.\n\ This takes precedence over the environment variables PATH and LD_LIBRARY_PATH."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* HAVE_LINK_H */
block|}
end_function

end_unit

