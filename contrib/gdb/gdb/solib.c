begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle shared libraries for GDB, the GNU Debugger.    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,    2000, 2001    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"gdb_regex.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"environ.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"completer.h"
end_include

begin_include
include|#
directive|include
file|"filenames.h"
end_include

begin_comment
comment|/* for DOSish file names */
end_comment

begin_include
include|#
directive|include
file|"solist.h"
end_include

begin_comment
comment|/* external data declarations */
end_comment

begin_comment
comment|/* FIXME: gdbarch needs to control this variable */
end_comment

begin_decl_stmt
name|struct
name|target_so_ops
modifier|*
name|current_target_so_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* local data declarations */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|so_list
modifier|*
name|so_list_head
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of known shared objects */
end_comment

begin_decl_stmt
specifier|static
name|int
name|solib_cleanup_queued
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* make_run_cleanup called */
end_comment

begin_comment
comment|/* Local function prototypes */
end_comment

begin_function_decl
specifier|static
name|void
name|do_clear_solib
parameter_list|(
name|PTR
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* If non-zero, this is a prefix that will be added to the front of the name    shared libraries with an absolute filename for loading.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|solib_absolute_prefix
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-empty, this is a search path for loading non-absolute shared library    symbol files.  This takes precedence over the environment variables PATH    and LD_LIBRARY_PATH.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|solib_search_path
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*     GLOBAL FUNCTION     solib_open -- Find a shared library file and open it.     SYNOPSIS     int solib_open (char *in_patname, char **found_pathname);     DESCRIPTION     Global variable SOLIB_ABSOLUTE_PREFIX is used as a prefix directory    to search for shared libraries if they have an absolute path.     Global variable SOLIB_SEARCH_PATH is used as a prefix directory    (or set of directories, as in LD_LIBRARY_PATH) to search for all    shared libraries if not found in SOLIB_ABSOLUTE_PREFIX.     Search order:    * If path is absolute, look in SOLIB_ABSOLUTE_PREFIX.    * If path is absolute or relative, look for it literally (unmodified).    * Look in SOLIB_SEARCH_PATH.    * Look in inferior's $PATH.    * Look in inferior's $LD_LIBRARY_PATH.     RETURNS     file handle for opened solib, or -1 for failure.  */
end_comment

begin_function
name|int
name|solib_open
parameter_list|(
name|char
modifier|*
name|in_pathname
parameter_list|,
name|char
modifier|*
modifier|*
name|found_pathname
parameter_list|)
block|{
name|int
name|found_file
init|=
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|temp_pathname
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|in_pathname
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|!
name|IS_DIR_SEPARATOR
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|!
name|IS_ABSOLUTE_PATH
argument_list|(
name|in_pathname
argument_list|)
operator|||
name|solib_absolute_prefix
operator|==
name|NULL
condition|)
name|temp_pathname
operator|=
name|in_pathname
expr_stmt|;
else|else
block|{
name|int
name|prefix_len
init|=
name|strlen
argument_list|(
name|solib_absolute_prefix
argument_list|)
decl_stmt|;
comment|/* Remove trailing slashes from absolute prefix.  */
while|while
condition|(
name|prefix_len
operator|>
literal|0
operator|&&
name|IS_DIR_SEPARATOR
argument_list|(
name|solib_absolute_prefix
index|[
name|prefix_len
operator|-
literal|1
index|]
argument_list|)
condition|)
name|prefix_len
operator|--
expr_stmt|;
comment|/* Cat the prefixed pathname together.  */
name|temp_pathname
operator|=
name|alloca
argument_list|(
name|prefix_len
operator|+
name|strlen
argument_list|(
name|in_pathname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|temp_pathname
argument_list|,
name|solib_absolute_prefix
argument_list|,
name|prefix_len
argument_list|)
expr_stmt|;
name|temp_pathname
index|[
name|prefix_len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|temp_pathname
argument_list|,
name|in_pathname
argument_list|)
expr_stmt|;
block|}
comment|/* Now see if we can open it.  */
name|found_file
operator|=
name|open
argument_list|(
name|temp_pathname
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* If the search in solib_absolute_prefix failed, and the path name is      absolute at this point, make it relative.  (openp will try and open the      file according to its absolute path otherwise, which is not what we want.)      Affects subsequent searches for this solib.  */
if|if
condition|(
name|found_file
operator|<
literal|0
operator|&&
name|IS_ABSOLUTE_PATH
argument_list|(
name|in_pathname
argument_list|)
condition|)
block|{
comment|/* First, get rid of any drive letters etc.  */
while|while
condition|(
operator|!
name|IS_DIR_SEPARATOR
argument_list|(
operator|*
name|in_pathname
argument_list|)
condition|)
name|in_pathname
operator|++
expr_stmt|;
comment|/* Next, get rid of all leading dir separators.  */
while|while
condition|(
name|IS_DIR_SEPARATOR
argument_list|(
operator|*
name|in_pathname
argument_list|)
condition|)
name|in_pathname
operator|++
expr_stmt|;
block|}
comment|/* If not found, next search the solib_search_path (if any).  */
if|if
condition|(
name|found_file
operator|<
literal|0
operator|&&
name|solib_search_path
operator|!=
name|NULL
condition|)
name|found_file
operator|=
name|openp
argument_list|(
name|solib_search_path
argument_list|,
literal|1
argument_list|,
name|in_pathname
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
operator|&
name|temp_pathname
argument_list|)
expr_stmt|;
comment|/* If not found, next search the solib_search_path (if any) for the basename      only (ignoring the path).  This is to allow reading solibs from a path      that differs from the opened path.  */
if|if
condition|(
name|found_file
operator|<
literal|0
operator|&&
name|solib_search_path
operator|!=
name|NULL
condition|)
name|found_file
operator|=
name|openp
argument_list|(
name|solib_search_path
argument_list|,
literal|1
argument_list|,
name|lbasename
argument_list|(
name|in_pathname
argument_list|)
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
operator|&
name|temp_pathname
argument_list|)
expr_stmt|;
comment|/* If not found, next search the inferior's $PATH environment variable. */
if|if
condition|(
name|found_file
operator|<
literal|0
operator|&&
name|solib_search_path
operator|!=
name|NULL
condition|)
name|found_file
operator|=
name|openp
argument_list|(
name|get_in_environ
argument_list|(
name|inferior_environ
argument_list|,
literal|"PATH"
argument_list|)
argument_list|,
literal|1
argument_list|,
name|in_pathname
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
operator|&
name|temp_pathname
argument_list|)
expr_stmt|;
comment|/* If not found, next search the inferior's $LD_LIBRARY_PATH       environment variable. */
if|if
condition|(
name|found_file
operator|<
literal|0
operator|&&
name|solib_search_path
operator|!=
name|NULL
condition|)
name|found_file
operator|=
name|openp
argument_list|(
name|get_in_environ
argument_list|(
name|inferior_environ
argument_list|,
literal|"LD_LIBRARY_PATH"
argument_list|)
argument_list|,
literal|1
argument_list|,
name|in_pathname
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
operator|&
name|temp_pathname
argument_list|)
expr_stmt|;
comment|/* Done.  If not found, tough luck.  Return found_file and       (optionally) found_pathname.  */
if|if
condition|(
name|found_pathname
operator|!=
name|NULL
operator|&&
name|temp_pathname
operator|!=
name|NULL
condition|)
operator|*
name|found_pathname
operator|=
name|xstrdup
argument_list|(
name|temp_pathname
argument_list|)
expr_stmt|;
return|return
name|found_file
return|;
block|}
end_function

begin_comment
comment|/*     LOCAL FUNCTION     solib_map_sections -- open bfd and build sections for shared lib     SYNOPSIS     static int solib_map_sections (struct so_list *so)     DESCRIPTION     Given a pointer to one of the shared objects in our list    of mapped objects, use the recorded name to open a bfd    descriptor for the object, build a section table, and then    relocate all the section addresses by the base address at    which the shared object was mapped.     FIXMES     In most (all?) cases the shared object file name recorded in the    dynamic linkage tables will be a fully qualified pathname.  For    cases where it isn't, do we really mimic the systems search    mechanism correctly in the below code (particularly the tilde    expansion stuff?).  */
end_comment

begin_function
specifier|static
name|int
name|solib_map_sections
parameter_list|(
name|PTR
name|arg
parameter_list|)
block|{
name|struct
name|so_list
modifier|*
name|so
init|=
operator|(
expr|struct
name|so_list
operator|*
operator|)
name|arg
decl_stmt|;
comment|/* catch_errors bogon */
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|scratch_pathname
decl_stmt|;
name|int
name|scratch_chan
decl_stmt|;
name|struct
name|section_table
modifier|*
name|p
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|filename
operator|=
name|tilde_expand
argument_list|(
name|so
operator|->
name|so_name
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|scratch_chan
operator|=
name|solib_open
argument_list|(
name|filename
argument_list|,
operator|&
name|scratch_pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|scratch_chan
operator|<
literal|0
condition|)
block|{
name|perror_with_name
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
comment|/* Leave scratch_pathname allocated.  abfd->name will point to it.  */
name|abfd
operator|=
name|bfd_fdopenr
argument_list|(
name|scratch_pathname
argument_list|,
name|gnutarget
argument_list|,
name|scratch_chan
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abfd
condition|)
block|{
name|close
argument_list|(
name|scratch_chan
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Could not open `%s' as an executable file: %s"
argument_list|,
name|scratch_pathname
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Leave bfd open, core_xfer_memory and "info files" need it.  */
name|so
operator|->
name|abfd
operator|=
name|abfd
expr_stmt|;
name|abfd
operator|->
name|cacheable
operator|=
literal|1
expr_stmt|;
comment|/* copy full path name into so_name, so that later symbol_file_add      can find it */
if|if
condition|(
name|strlen
argument_list|(
name|scratch_pathname
argument_list|)
operator|>=
name|SO_NAME_MAX_PATH_SIZE
condition|)
name|error
argument_list|(
literal|"Full path name length of shared library exceeds SO_NAME_MAX_PATH_SIZE in so_list structure."
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|so
operator|->
name|so_name
argument_list|,
name|scratch_pathname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_check_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"\"%s\": not in executable format: %s."
argument_list|,
name|scratch_pathname
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|build_section_table
argument_list|(
name|abfd
argument_list|,
operator|&
name|so
operator|->
name|sections
argument_list|,
operator|&
name|so
operator|->
name|sections_end
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"Can't find the file sections in `%s': %s"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|p
operator|=
name|so
operator|->
name|sections
init|;
name|p
operator|<
name|so
operator|->
name|sections_end
condition|;
name|p
operator|++
control|)
block|{
comment|/* Relocate the section binding addresses as recorded in the shared          object's file by the base address to which the object was actually          mapped. */
name|TARGET_SO_RELOCATE_SECTION_ADDRESSES
argument_list|(
name|so
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|p
operator|->
name|the_bfd_section
operator|->
name|name
argument_list|,
literal|".text"
argument_list|)
condition|)
block|{
name|so
operator|->
name|textsection
operator|=
name|p
expr_stmt|;
block|}
block|}
comment|/* Free the file names, close the file now.  */
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* LOCAL FUNCTION     free_so --- free a `struct so_list' object     SYNOPSIS     void free_so (struct so_list *so)     DESCRIPTION     Free the storage associated with the `struct so_list' object SO.    If we have opened a BFD for SO, close it.       The caller is responsible for removing SO from whatever list it is    a member of.  If we have placed SO's sections in some target's    section table, the caller is responsible for removing them.     This function doesn't mess with objfiles at all.  If there is an    objfile associated with SO that needs to be removed, the caller is    responsible for taking care of that.  */
end_comment

begin_function
name|void
name|free_so
parameter_list|(
name|struct
name|so_list
modifier|*
name|so
parameter_list|)
block|{
name|char
modifier|*
name|bfd_filename
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|so
operator|->
name|sections
condition|)
name|xfree
argument_list|(
name|so
operator|->
name|sections
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|abfd
condition|)
block|{
name|bfd_filename
operator|=
name|bfd_get_filename
argument_list|(
name|so
operator|->
name|abfd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_close
argument_list|(
name|so
operator|->
name|abfd
argument_list|)
condition|)
name|warning
argument_list|(
literal|"cannot close \"%s\": %s"
argument_list|,
name|bfd_filename
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bfd_filename
condition|)
name|xfree
argument_list|(
name|bfd_filename
argument_list|)
expr_stmt|;
name|TARGET_SO_FREE_SO
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A small stub to get us past the arg-passing pinhole of catch_errors.  */
end_comment

begin_function
specifier|static
name|int
name|symbol_add_stub
parameter_list|(
name|PTR
name|arg
parameter_list|)
block|{
specifier|register
name|struct
name|so_list
modifier|*
name|so
init|=
operator|(
expr|struct
name|so_list
operator|*
operator|)
name|arg
decl_stmt|;
comment|/* catch_errs bogon */
name|struct
name|section_addr_info
modifier|*
name|sap
decl_stmt|;
comment|/* Have we already loaded this shared object?  */
name|ALL_OBJFILES
argument_list|(
argument|so->objfile
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|so
operator|->
name|objfile
operator|->
name|name
argument_list|,
name|so
operator|->
name|so_name
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
name|sap
operator|=
name|build_section_addr_info_from_section_table
argument_list|(
name|so
operator|->
name|sections
argument_list|,
name|so
operator|->
name|sections_end
argument_list|)
expr_stmt|;
name|so
operator|->
name|objfile
operator|=
name|symbol_file_add
argument_list|(
name|so
operator|->
name|so_name
argument_list|,
name|so
operator|->
name|from_tty
argument_list|,
name|sap
argument_list|,
literal|0
argument_list|,
name|OBJF_SHARED
argument_list|)
expr_stmt|;
name|free_section_addr_info
argument_list|(
name|sap
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* LOCAL FUNCTION     update_solib_list --- synchronize GDB's shared object list with inferior's     SYNOPSIS     void update_solib_list (int from_tty, struct target_ops *TARGET)     Extract the list of currently loaded shared objects from the    inferior, and compare it with the list of shared objects currently    in GDB's so_list_head list.  Edit so_list_head to bring it in sync    with the inferior's new list.     If we notice that the inferior has unloaded some shared objects,    free any symbolic info GDB had read about those shared objects.     Don't load symbolic info for any new shared objects; just add them    to the list, and leave their symbols_loaded flag clear.     If FROM_TTY is non-null, feel free to print messages about what    we're doing.     If TARGET is non-null, add the sections of all new shared objects    to TARGET's section table.  Note that this doesn't remove any    sections for shared objects that have been unloaded, and it    doesn't check to see if the new shared objects are already present in    the section table.  But we only use this for core files and    processes we've just attached to, so that's okay.  */
end_comment

begin_function
name|void
name|update_solib_list
parameter_list|(
name|int
name|from_tty
parameter_list|,
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
block|{
name|struct
name|so_list
modifier|*
name|inferior
init|=
name|TARGET_SO_CURRENT_SOS
argument_list|()
decl_stmt|;
name|struct
name|so_list
modifier|*
name|gdb
decl_stmt|,
modifier|*
modifier|*
name|gdb_link
decl_stmt|;
comment|/* If we are attaching to a running process for which we       have not opened a symbol file, we may be able to get its       symbols now!  */
if|if
condition|(
name|attach_flag
operator|&&
name|symfile_objfile
operator|==
name|NULL
condition|)
name|catch_errors
argument_list|(
name|TARGET_SO_OPEN_SYMBOL_FILE_OBJECT
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|from_tty
argument_list|,
literal|"Error reading attached process's symbol file.\n"
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
comment|/* Since this function might actually add some elements to the      so_list_head list, arrange for it to be cleaned up when      appropriate.  */
if|if
condition|(
operator|!
name|solib_cleanup_queued
condition|)
block|{
name|make_run_cleanup
argument_list|(
name|do_clear_solib
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|solib_cleanup_queued
operator|=
literal|1
expr_stmt|;
block|}
comment|/* GDB and the inferior's dynamic linker each maintain their own      list of currently loaded shared objects; we want to bring the      former in sync with the latter.  Scan both lists, seeing which      shared objects appear where.  There are three cases:       - A shared object appears on both lists.  This means that GDB      knows about it already, and it's still loaded in the inferior.      Nothing needs to happen.       - A shared object appears only on GDB's list.  This means that      the inferior has unloaded it.  We should remove the shared      object from GDB's tables.       - A shared object appears only on the inferior's list.  This      means that it's just been loaded.  We should add it to GDB's      tables.       So we walk GDB's list, checking each entry to see if it appears      in the inferior's list too.  If it does, no action is needed, and      we remove it from the inferior's list.  If it doesn't, the      inferior has unloaded it, and we remove it from GDB's list.  By      the time we're done walking GDB's list, the inferior's list      contains only the new shared objects, which we then add.  */
name|gdb
operator|=
name|so_list_head
expr_stmt|;
name|gdb_link
operator|=
operator|&
name|so_list_head
expr_stmt|;
while|while
condition|(
name|gdb
condition|)
block|{
name|struct
name|so_list
modifier|*
name|i
init|=
name|inferior
decl_stmt|;
name|struct
name|so_list
modifier|*
modifier|*
name|i_link
init|=
operator|&
name|inferior
decl_stmt|;
comment|/* Check to see whether the shared object *gdb also appears in 	 the inferior's current list.  */
while|while
condition|(
name|i
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|gdb
operator|->
name|so_original_name
argument_list|,
name|i
operator|->
name|so_original_name
argument_list|)
condition|)
break|break;
name|i_link
operator|=
operator|&
name|i
operator|->
name|next
expr_stmt|;
name|i
operator|=
operator|*
name|i_link
expr_stmt|;
block|}
comment|/* If the shared object appears on the inferior's list too, then          it's still loaded, so we don't need to do anything.  Delete          it from the inferior's list, and leave it on GDB's list.  */
if|if
condition|(
name|i
condition|)
block|{
operator|*
name|i_link
operator|=
name|i
operator|->
name|next
expr_stmt|;
name|free_so
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|gdb_link
operator|=
operator|&
name|gdb
operator|->
name|next
expr_stmt|;
name|gdb
operator|=
operator|*
name|gdb_link
expr_stmt|;
block|}
comment|/* If it's not on the inferior's list, remove it from GDB's tables.  */
else|else
block|{
operator|*
name|gdb_link
operator|=
name|gdb
operator|->
name|next
expr_stmt|;
comment|/* Unless the user loaded it explicitly, free SO's objfile.  */
if|if
condition|(
name|gdb
operator|->
name|objfile
operator|&&
operator|!
operator|(
name|gdb
operator|->
name|objfile
operator|->
name|flags
operator|&
name|OBJF_USERLOADED
operator|)
condition|)
name|free_objfile
argument_list|(
name|gdb
operator|->
name|objfile
argument_list|)
expr_stmt|;
comment|/* Some targets' section tables might be referring to 	     sections from so->abfd; remove them.  */
name|remove_target_sections
argument_list|(
name|gdb
operator|->
name|abfd
argument_list|)
expr_stmt|;
name|free_so
argument_list|(
name|gdb
argument_list|)
expr_stmt|;
name|gdb
operator|=
operator|*
name|gdb_link
expr_stmt|;
block|}
block|}
comment|/* Now the inferior's list contains only shared objects that don't      appear in GDB's list --- those that are newly loaded.  Add them      to GDB's shared object list.  */
if|if
condition|(
name|inferior
condition|)
block|{
name|struct
name|so_list
modifier|*
name|i
decl_stmt|;
comment|/* Add the new shared objects to GDB's list.  */
operator|*
name|gdb_link
operator|=
name|inferior
expr_stmt|;
comment|/* Fill in the rest of each of the `struct so_list' nodes.  */
for|for
control|(
name|i
operator|=
name|inferior
init|;
name|i
condition|;
name|i
operator|=
name|i
operator|->
name|next
control|)
block|{
name|i
operator|->
name|from_tty
operator|=
name|from_tty
expr_stmt|;
comment|/* Fill in the rest of the `struct so_list' node.  */
name|catch_errors
argument_list|(
name|solib_map_sections
argument_list|,
name|i
argument_list|,
literal|"Error while mapping shared library sections:\n"
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
comment|/* If requested, add the shared object's sections to the TARGET's 	     section table.  Do this immediately after mapping the object so 	     that later nodes in the list can query this object, as is needed 	     in solib-osf.c.  */
if|if
condition|(
name|target
condition|)
block|{
name|int
name|count
init|=
operator|(
name|i
operator|->
name|sections_end
operator|-
name|i
operator|->
name|sections
operator|)
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
name|int
name|space
init|=
name|target_resize_to_sections
argument_list|(
name|target
argument_list|,
name|count
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|target
operator|->
name|to_sections
operator|+
name|space
argument_list|,
name|i
operator|->
name|sections
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|i
operator|->
name|sections
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* GLOBAL FUNCTION     solib_add -- read in symbol info for newly added shared libraries     SYNOPSIS     void solib_add (char *pattern, int from_tty, struct target_ops    *TARGET, int readsyms)     DESCRIPTION     Read in symbolic information for any shared objects whose names    match PATTERN.  (If we've already read a shared object's symbol    info, leave it alone.)  If PATTERN is zero, read them all.     If READSYMS is 0, defer reading symbolic information until later    but still do any needed low level processing.     FROM_TTY and TARGET are as described for update_solib_list, above.  */
end_comment

begin_function
name|void
name|solib_add
parameter_list|(
name|char
modifier|*
name|pattern
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|target_ops
modifier|*
name|target
parameter_list|,
name|int
name|readsyms
parameter_list|)
block|{
name|struct
name|so_list
modifier|*
name|gdb
decl_stmt|;
if|if
condition|(
name|pattern
condition|)
block|{
name|char
modifier|*
name|re_err
init|=
name|re_comp
argument_list|(
name|pattern
argument_list|)
decl_stmt|;
if|if
condition|(
name|re_err
condition|)
name|error
argument_list|(
literal|"Invalid regexp: %s"
argument_list|,
name|re_err
argument_list|)
expr_stmt|;
block|}
name|update_solib_list
argument_list|(
name|from_tty
argument_list|,
name|target
argument_list|)
expr_stmt|;
comment|/* Walk the list of currently loaded shared libraries, and read      symbols for any that match the pattern --- or any whose symbols      aren't already loaded, if no pattern was given.  */
block|{
name|int
name|any_matches
init|=
literal|0
decl_stmt|;
name|int
name|loaded_any_symbols
init|=
literal|0
decl_stmt|;
for|for
control|(
name|gdb
operator|=
name|so_list_head
init|;
name|gdb
condition|;
name|gdb
operator|=
name|gdb
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|pattern
operator|||
name|re_exec
argument_list|(
name|gdb
operator|->
name|so_name
argument_list|)
condition|)
block|{
name|any_matches
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|gdb
operator|->
name|symbols_loaded
condition|)
block|{
if|if
condition|(
name|from_tty
condition|)
name|printf_unfiltered
argument_list|(
literal|"Symbols already loaded for %s\n"
argument_list|,
name|gdb
operator|->
name|so_name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|readsyms
condition|)
block|{
if|if
condition|(
name|catch_errors
argument_list|(
name|symbol_add_stub
argument_list|,
name|gdb
argument_list|,
literal|"Error while reading shared library symbols:\n"
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
condition|)
block|{
if|if
condition|(
name|from_tty
condition|)
name|printf_unfiltered
argument_list|(
literal|"Loaded symbols for %s\n"
argument_list|,
name|gdb
operator|->
name|so_name
argument_list|)
expr_stmt|;
name|gdb
operator|->
name|symbols_loaded
operator|=
literal|1
expr_stmt|;
name|loaded_any_symbols
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|from_tty
operator|&&
name|pattern
operator|&&
operator|!
name|any_matches
condition|)
name|printf_unfiltered
argument_list|(
literal|"No loaded shared libraries match the pattern `%s'.\n"
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|loaded_any_symbols
condition|)
block|{
comment|/* Getting new symbols may change our opinion about what is 	   frameless.  */
name|reinit_frame_cache
argument_list|()
expr_stmt|;
name|TARGET_SO_SPECIAL_SYMBOL_HANDLING
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*     LOCAL FUNCTION     info_sharedlibrary_command -- code for "info sharedlibrary"     SYNOPSIS     static void info_sharedlibrary_command ()     DESCRIPTION     Walk through the shared library list and print information    about each attached library.  */
end_comment

begin_function
specifier|static
name|void
name|info_sharedlibrary_command
parameter_list|(
name|char
modifier|*
name|ignore
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
specifier|register
name|struct
name|so_list
modifier|*
name|so
init|=
name|NULL
decl_stmt|;
comment|/* link map state variable */
name|int
name|header_done
init|=
literal|0
decl_stmt|;
name|int
name|addr_width
decl_stmt|;
name|char
modifier|*
name|addr_fmt
decl_stmt|;
if|if
condition|(
name|TARGET_PTR_BIT
operator|==
literal|32
condition|)
block|{
name|addr_width
operator|=
literal|8
operator|+
literal|4
expr_stmt|;
name|addr_fmt
operator|=
literal|"08l"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TARGET_PTR_BIT
operator|==
literal|64
condition|)
block|{
name|addr_width
operator|=
literal|16
operator|+
literal|4
expr_stmt|;
name|addr_fmt
operator|=
literal|"016l"
expr_stmt|;
block|}
else|else
block|{
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"TARGET_PTR_BIT returned unknown size %d"
argument_list|,
name|TARGET_PTR_BIT
argument_list|)
expr_stmt|;
block|}
name|update_solib_list
argument_list|(
name|from_tty
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|so
operator|=
name|so_list_head
init|;
name|so
condition|;
name|so
operator|=
name|so
operator|->
name|next
control|)
block|{
if|if
condition|(
name|so
operator|->
name|so_name
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|header_done
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"%-*s%-*s%-12s%s\n"
argument_list|,
name|addr_width
argument_list|,
literal|"From"
argument_list|,
name|addr_width
argument_list|,
literal|"To"
argument_list|,
literal|"Syms Read"
argument_list|,
literal|"Shared Object Library"
argument_list|)
expr_stmt|;
name|header_done
operator|++
expr_stmt|;
block|}
name|printf_unfiltered
argument_list|(
literal|"%-*s"
argument_list|,
name|addr_width
argument_list|,
name|so
operator|->
name|textsection
operator|!=
name|NULL
condition|?
name|longest_local_hex_string_custom
argument_list|(
operator|(
name|LONGEST
operator|)
name|so
operator|->
name|textsection
operator|->
name|addr
argument_list|,
name|addr_fmt
argument_list|)
else|:
literal|""
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%-*s"
argument_list|,
name|addr_width
argument_list|,
name|so
operator|->
name|textsection
operator|!=
name|NULL
condition|?
name|longest_local_hex_string_custom
argument_list|(
operator|(
name|LONGEST
operator|)
name|so
operator|->
name|textsection
operator|->
name|endaddr
argument_list|,
name|addr_fmt
argument_list|)
else|:
literal|""
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%-12s"
argument_list|,
name|so
operator|->
name|symbols_loaded
condition|?
literal|"Yes"
else|:
literal|"No"
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%s\n"
argument_list|,
name|so
operator|->
name|so_name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|so_list_head
operator|==
name|NULL
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"No shared libraries loaded at this time.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*     GLOBAL FUNCTION     solib_address -- check to see if an address is in a shared lib     SYNOPSIS     char * solib_address (CORE_ADDR address)     DESCRIPTION     Provides a hook for other gdb routines to discover whether or    not a particular address is within the mapped address space of    a shared library.     For example, this routine is called at one point to disable    breakpoints which are in shared libraries that are not currently    mapped in.  */
end_comment

begin_function
name|char
modifier|*
name|solib_address
parameter_list|(
name|CORE_ADDR
name|address
parameter_list|)
block|{
specifier|register
name|struct
name|so_list
modifier|*
name|so
init|=
literal|0
decl_stmt|;
comment|/* link map state variable */
for|for
control|(
name|so
operator|=
name|so_list_head
init|;
name|so
condition|;
name|so
operator|=
name|so
operator|->
name|next
control|)
block|{
name|struct
name|section_table
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|so
operator|->
name|sections
init|;
name|p
operator|<
name|so
operator|->
name|sections_end
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|addr
operator|<=
name|address
operator|&&
name|address
operator|<
name|p
operator|->
name|endaddr
condition|)
return|return
operator|(
name|so
operator|->
name|so_name
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Called by free_all_symtabs */
end_comment

begin_function
name|void
name|clear_solib
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* This function is expected to handle ELF shared libraries.  It is      also used on Solaris, which can run either ELF or a.out binaries      (for compatibility with SunOS 4), both of which can use shared      libraries.  So we don't know whether we have an ELF executable or      an a.out executable until the user chooses an executable file.       ELF shared libraries don't get mapped into the address space      until after the program starts, so we'd better not try to insert      breakpoints in them immediately.  We have to wait until the      dynamic linker has loaded them; we'll hit a bp_shlib_event      breakpoint (look for calls to create_solib_event_breakpoint) when      it's ready.       SunOS shared libraries seem to be different --- they're present      as soon as the process begins execution, so there's no need to      put off inserting breakpoints.  There's also nowhere to put a      bp_shlib_event breakpoint, so if we put it off, we'll never get      around to it.       So: disable breakpoints only if we're using ELF shared libs.  */
if|if
condition|(
name|exec_bfd
operator|!=
name|NULL
operator|&&
name|bfd_get_flavour
argument_list|(
name|exec_bfd
argument_list|)
operator|!=
name|bfd_target_aout_flavour
condition|)
name|disable_breakpoints_in_shlibs
argument_list|(
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|so_list_head
condition|)
block|{
name|struct
name|so_list
modifier|*
name|so
init|=
name|so_list_head
decl_stmt|;
name|so_list_head
operator|=
name|so
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|abfd
condition|)
name|remove_target_sections
argument_list|(
name|so
operator|->
name|abfd
argument_list|)
expr_stmt|;
name|free_so
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
name|TARGET_SO_CLEAR_SOLIB
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_clear_solib
parameter_list|(
name|PTR
name|dummy
parameter_list|)
block|{
name|solib_cleanup_queued
operator|=
literal|0
expr_stmt|;
name|clear_solib
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* GLOBAL FUNCTION     solib_create_inferior_hook -- shared library startup support     SYNOPSIS     void solib_create_inferior_hook()     DESCRIPTION     When gdb starts up the inferior, it nurses it along (through the    shell) until it is ready to execute it's first instruction.  At this    point, this function gets called via expansion of the macro    SOLIB_CREATE_INFERIOR_HOOK.  */
end_comment

begin_function
name|void
name|solib_create_inferior_hook
parameter_list|(
name|void
parameter_list|)
block|{
name|TARGET_SO_SOLIB_CREATE_INFERIOR_HOOK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* GLOBAL FUNCTION     in_solib_dynsym_resolve_code -- check to see if an address is in                                    dynamic loader's dynamic symbol 				   resolution code     SYNOPSIS     int in_solib_dynsym_resolve_code (CORE_ADDR pc)     DESCRIPTION     Determine if PC is in the dynamic linker's symbol resolution    code.  Return 1 if so, 0 otherwise. */
end_comment

begin_function
name|int
name|in_solib_dynsym_resolve_code
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
return|return
name|TARGET_SO_IN_DYNSYM_RESOLVE_CODE
argument_list|(
name|pc
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*     LOCAL FUNCTION     sharedlibrary_command -- handle command to explicitly add library     SYNOPSIS     static void sharedlibrary_command (char *args, int from_tty)     DESCRIPTION   */
end_comment

begin_function
specifier|static
name|void
name|sharedlibrary_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|dont_repeat
argument_list|()
expr_stmt|;
name|solib_add
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|,
operator|(
expr|struct
name|target_ops
operator|*
operator|)
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* LOCAL FUNCTION     no_shared_libraries -- handle command to explicitly discard symbols    from shared libraries.     DESCRIPTION     Implements the command "nosharedlibrary", which discards symbols    that have been auto-loaded from shared libraries.  Symbols from    shared libraries that were added by explicit request of the user    are not discarded.  Also called from remote.c.  */
end_comment

begin_function
name|void
name|no_shared_libraries
parameter_list|(
name|char
modifier|*
name|ignored
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|objfile_purge_solibs
argument_list|()
expr_stmt|;
name|do_clear_solib
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_solib
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|add_com
argument_list|(
literal|"sharedlibrary"
argument_list|,
name|class_files
argument_list|,
name|sharedlibrary_command
argument_list|,
literal|"Load shared object library symbols for files matching REGEXP."
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"sharedlibrary"
argument_list|,
name|info_sharedlibrary_command
argument_list|,
literal|"Status of loaded shared object libraries."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"nosharedlibrary"
argument_list|,
name|class_files
argument_list|,
name|no_shared_libraries
argument_list|,
literal|"Unload all shared object library symbols."
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"auto-solib-add"
argument_list|,
name|class_support
argument_list|,
name|var_boolean
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|auto_solib_add
argument_list|,
literal|"Set autoloading of shared library symbols.\n\ If \"on\", symbols from all shared object libraries will be loaded\n\ automatically when the inferior begins execution, when the dynamic linker\n\ informs gdb that a new library has been loaded, or when attaching to the\n\ inferior.  Otherwise, symbols must be loaded manually, using `sharedlibrary'."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"solib-absolute-prefix"
argument_list|,
name|class_support
argument_list|,
name|var_filename
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|solib_absolute_prefix
argument_list|,
literal|"Set prefix for loading absolute shared library symbol files.\n\ For other (relative) files, you can add values using `set solib-search-path'."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|c
operator|->
name|completer
operator|=
name|filename_completer
expr_stmt|;
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"solib-search-path"
argument_list|,
name|class_support
argument_list|,
name|var_string
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|solib_search_path
argument_list|,
literal|"Set the search path for loading non-absolute shared library symbol files.\n\ This takes precedence over the environment variables PATH and LD_LIBRARY_PATH."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|c
operator|->
name|completer
operator|=
name|filename_completer
expr_stmt|;
block|}
end_function

end_unit

