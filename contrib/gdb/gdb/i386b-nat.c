begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Native-dependent code for BSD Unix running on i386's, for GDB.    Copyright 1988, 1989, 1991, 1992, 1994, 1996 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|FETCH_INFERIOR_REGISTERS
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_function
name|void
name|fetch_inferior_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|struct
name|reg
name|inferior_registers
decl_stmt|;
name|ptrace
argument_list|(
name|PT_GETREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|inferior_registers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|0
argument_list|)
index|]
argument_list|,
operator|&
name|inferior_registers
argument_list|,
literal|4
operator|*
name|NUM_REGS
argument_list|)
expr_stmt|;
name|registers_fetched
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|store_inferior_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|struct
name|reg
name|inferior_registers
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|inferior_registers
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|0
argument_list|)
index|]
argument_list|,
literal|4
operator|*
name|NUM_REGS
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
name|PT_SETREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|inferior_registers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|md_core
block|{
name|struct
name|reg
name|intreg
decl_stmt|;
name|struct
name|fpreg
name|freg
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|void
name|fetch_core_registers
parameter_list|(
name|core_reg_sect
parameter_list|,
name|core_reg_size
parameter_list|,
name|which
parameter_list|,
name|ignore
parameter_list|)
name|char
modifier|*
name|core_reg_sect
decl_stmt|;
name|unsigned
name|core_reg_size
decl_stmt|;
name|int
name|which
decl_stmt|;
name|CORE_ADDR
name|ignore
decl_stmt|;
block|{
name|struct
name|md_core
modifier|*
name|core_reg
init|=
operator|(
expr|struct
name|md_core
operator|*
operator|)
name|core_reg_sect
decl_stmt|;
comment|/* integer registers */
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|0
argument_list|)
index|]
argument_list|,
operator|&
name|core_reg
operator|->
name|intreg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|reg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* floating point registers */
comment|/* XXX */
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_comment
comment|/* Some systems don't provide all the registers on a trap.  Use SS as a    default if so.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|tDS
end_ifndef

begin_define
define|#
directive|define
name|tDS
value|tSS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|tES
end_ifndef

begin_define
define|#
directive|define
name|tES
value|tSS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|tFS
end_ifndef

begin_define
define|#
directive|define
name|tFS
value|tSS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|tGS
end_ifndef

begin_define
define|#
directive|define
name|tGS
value|tSS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* These tables map between the registers on a trap frame, and the register    order used by the rest of GDB.  */
end_comment

begin_comment
comment|/* this table must line up with REGISTER_NAMES in tm-i386.h */
end_comment

begin_comment
comment|/* symbols like 'tEAX' come from<machine/reg.h> */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tregmap
index|[]
init|=
block|{
name|tEAX
block|,
name|tECX
block|,
name|tEDX
block|,
name|tEBX
block|,
name|tESP
block|,
name|tEBP
block|,
name|tESI
block|,
name|tEDI
block|,
name|tEIP
block|,
name|tEFLAGS
block|,
name|tCS
block|,
name|tSS
block|,
name|tDS
block|,
name|tES
block|,
name|tFS
block|,
name|tGS
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|sEAX
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|sregmap
index|[]
init|=
block|{
name|sEAX
block|,
name|sECX
block|,
name|sEDX
block|,
name|sEBX
block|,
name|sESP
block|,
name|sEBP
block|,
name|sESI
block|,
name|sEDI
block|,
name|sEIP
block|,
name|sEFLAGS
block|,
name|sCS
block|,
name|sSS
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* No sEAX */
end_comment

begin_comment
comment|/* FreeBSD has decided to collapse the s* and t* symbols.  So if the s*    ones aren't around, use the t* ones for sregmap too.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sregmap
index|[]
init|=
block|{
name|tEAX
block|,
name|tECX
block|,
name|tEDX
block|,
name|tEBX
block|,
name|tESP
block|,
name|tEBP
block|,
name|tESI
block|,
name|tEDI
block|,
name|tEIP
block|,
name|tEFLAGS
block|,
name|tCS
block|,
name|tSS
block|,
name|tDS
block|,
name|tES
block|,
name|tFS
block|,
name|tGS
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* No sEAX */
end_comment

begin_comment
comment|/* blockend is the value of u.u_ar0, and points to the    place where ES is stored.  */
end_comment

begin_function
name|int
name|i386_register_u_addr
parameter_list|(
name|blockend
parameter_list|,
name|regnum
parameter_list|)
name|int
name|blockend
decl_stmt|;
name|int
name|regnum
decl_stmt|;
block|{
comment|/* The following condition is a kludge to get at the proper register map      depending upon the state of pcb_flag.      The proper condition would be      if (u.u_pcb.pcb_flag& FM_TRAP)      but that would require a ptrace call here and wouldn't work      for corefiles.  */
if|if
condition|(
name|blockend
operator|<
literal|0x1fcc
condition|)
return|return
operator|(
name|blockend
operator|+
literal|4
operator|*
name|tregmap
index|[
name|regnum
index|]
operator|)
return|;
else|else
return|return
operator|(
name|blockend
operator|+
literal|4
operator|*
name|sregmap
index|[
name|regnum
index|]
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !FETCH_INFERIOR_REGISTERS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FLOAT_INFO
end_ifdef

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_comment
comment|/* for local_hex_string */
end_comment

begin_include
include|#
directive|include
file|"floatformat.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_define
define|#
directive|define
name|curpcb
value|Xcurpcb
end_define

begin_comment
comment|/* XXX avoid leaking declaration from pcb.h */
end_comment

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_undef
undef|#
directive|undef
name|curpcb
end_undef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_function_decl
specifier|extern
name|void
name|print_387_control_word
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* i387-tdep.h */
end_comment

begin_function_decl
specifier|extern
name|void
name|print_387_status_word
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|fpstate
value|save87
end_define

begin_define
define|#
directive|define
name|U_FPSTATE
parameter_list|(
name|u
parameter_list|)
value|u.u_pcb.pcb_savefpu
end_define

begin_function
specifier|static
name|void
name|i387_to_double
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|char
modifier|*
name|from
decl_stmt|;
name|char
modifier|*
name|to
decl_stmt|;
block|{
name|long
modifier|*
name|lp
decl_stmt|;
comment|/* push extended mode on 387 stack, then pop in double mode    *    * first, set exception masks so no error is generated -    * number will be rounded to inf or 0, if necessary    */
asm|asm ("pushl %eax");
comment|/* grab a stack slot */
asm|asm ("fstcw (%esp)");
comment|/* get 387 control word */
asm|asm ("movl (%esp),%eax");
comment|/* save old value */
asm|asm ("orl $0x3f,%eax");
comment|/* mask all exceptions */
asm|asm ("pushl %eax");
asm|asm ("fldcw (%esp)");
comment|/* load new value into 387 */
asm|asm ("movl 8(%ebp),%eax");
asm|asm ("fldt (%eax)");
comment|/* push extended number on 387 stack */
asm|asm ("fwait");
asm|asm ("movl 12(%ebp),%eax");
asm|asm ("fstpl (%eax)");
comment|/* pop double */
asm|asm ("fwait");
asm|asm ("popl %eax");
comment|/* flush modified control word */
asm|asm ("fnclex");
comment|/* clear exceptions */
asm|asm ("fldcw (%esp)");
comment|/* restore original control word */
asm|asm ("popl %eax");
comment|/* flush saved copy */
block|}
end_function

begin_struct
struct|struct
name|env387
block|{
name|unsigned
name|short
name|control
decl_stmt|;
name|unsigned
name|short
name|r0
decl_stmt|;
name|unsigned
name|short
name|status
decl_stmt|;
name|unsigned
name|short
name|r1
decl_stmt|;
name|unsigned
name|short
name|tag
decl_stmt|;
name|unsigned
name|short
name|r2
decl_stmt|;
name|unsigned
name|long
name|eip
decl_stmt|;
name|unsigned
name|short
name|code_seg
decl_stmt|;
name|unsigned
name|short
name|opcode
decl_stmt|;
name|unsigned
name|long
name|operand
decl_stmt|;
name|unsigned
name|short
name|operand_seg
decl_stmt|;
name|unsigned
name|short
name|r3
decl_stmt|;
name|unsigned
name|char
name|regs
index|[
literal|8
index|]
index|[
literal|10
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|print_387_status
parameter_list|(
name|status
parameter_list|,
name|ep
parameter_list|)
name|unsigned
name|short
name|status
decl_stmt|;
name|struct
name|env387
modifier|*
name|ep
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|bothstatus
decl_stmt|;
name|int
name|top
decl_stmt|;
name|int
name|fpreg
decl_stmt|;
name|bothstatus
operator|=
operator|(
operator|(
name|status
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ep
operator|->
name|status
operator|!=
literal|0
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bothstatus
condition|)
name|printf_unfiltered
argument_list|(
literal|"u: "
argument_list|)
expr_stmt|;
name|print_387_status_word
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|status
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ep
operator|->
name|status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bothstatus
condition|)
name|printf_unfiltered
argument_list|(
literal|"e: "
argument_list|)
expr_stmt|;
name|print_387_status_word
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|ep
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
name|print_387_control_word
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|ep
operator|->
name|control
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"last instruction: "
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"opcode %s; "
argument_list|,
name|local_hex_string
argument_list|(
name|ep
operator|->
name|opcode
argument_list|)
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"pc %s:"
argument_list|,
name|local_hex_string
argument_list|(
name|ep
operator|->
name|code_seg
argument_list|)
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%s; "
argument_list|,
name|local_hex_string
argument_list|(
name|ep
operator|->
name|eip
argument_list|)
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"operand %s"
argument_list|,
name|local_hex_string
argument_list|(
name|ep
operator|->
name|operand_seg
argument_list|)
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|":%s\n"
argument_list|,
name|local_hex_string
argument_list|(
name|ep
operator|->
name|operand
argument_list|)
argument_list|)
expr_stmt|;
name|top
operator|=
operator|(
name|ep
operator|->
name|status
operator|>>
literal|11
operator|)
operator|&
literal|7
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|" regno     tag  msb              lsb  value\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|fpreg
operator|=
literal|7
init|;
name|fpreg
operator|>=
literal|0
condition|;
name|fpreg
operator|--
control|)
block|{
name|int
name|st_regno
decl_stmt|;
name|double
name|val
decl_stmt|;
comment|/* The physical regno `fpreg' is only relevant as an index into the        * tag word.  Logical `%st' numbers are required for indexing ep->regs.        */
name|st_regno
operator|=
operator|(
name|fpreg
operator|+
literal|8
operator|-
name|top
operator|)
operator|&
literal|7
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%%st(%d) %s "
argument_list|,
name|st_regno
argument_list|,
name|fpreg
operator|==
name|top
condition|?
literal|"=>"
else|:
literal|"  "
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|ep
operator|->
name|tag
operator|>>
operator|(
name|fpreg
operator|*
literal|2
operator|)
operator|)
operator|&
literal|3
condition|)
block|{
case|case
literal|0
case|:
name|printf_unfiltered
argument_list|(
literal|"valid "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|printf_unfiltered
argument_list|(
literal|"zero  "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printf_unfiltered
argument_list|(
literal|"trap  "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|printf_unfiltered
argument_list|(
literal|"empty "
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|9
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|printf_unfiltered
argument_list|(
literal|"%02x"
argument_list|,
name|ep
operator|->
name|regs
index|[
name|st_regno
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i387_to_double
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ep
operator|->
name|regs
index|[
name|st_regno
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|val
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"  %g\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|i386_float_info
parameter_list|()
block|{
name|struct
name|user
name|u
decl_stmt|;
comment|/* just for address computations */
name|int
name|i
decl_stmt|;
comment|/* fpstate defined in<sys/user.h> */
name|struct
name|fpstate
modifier|*
name|fpstatep
decl_stmt|;
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|fpstate
argument_list|)
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
index|]
decl_stmt|;
name|unsigned
name|int
name|uaddr
decl_stmt|;
name|char
name|fpvalid
decl_stmt|;
name|unsigned
name|int
name|rounded_addr
decl_stmt|;
name|unsigned
name|int
name|rounded_size
decl_stmt|;
comment|/*extern int corechan;*/
name|int
name|skip
decl_stmt|;
specifier|extern
name|int
name|inferior_pid
decl_stmt|;
name|uaddr
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|U_FPSTATE
argument_list|(
name|u
argument_list|)
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|u
expr_stmt|;
if|if
condition|(
name|inferior_pid
condition|)
block|{
name|int
modifier|*
name|ip
decl_stmt|;
name|rounded_addr
operator|=
name|uaddr
operator|&
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|rounded_size
operator|=
operator|(
operator|(
operator|(
name|uaddr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|fpstate
argument_list|)
operator|)
operator|-
name|uaddr
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|skip
operator|=
name|uaddr
operator|-
name|rounded_addr
expr_stmt|;
name|ip
operator|=
operator|(
name|int
operator|*
operator|)
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rounded_size
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|ip
operator|++
operator|=
name|ptrace
argument_list|(
name|PT_READ_U
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|caddr_t
operator|)
name|rounded_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rounded_addr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"float info: can't do a core file (yet)\n"
argument_list|)
expr_stmt|;
return|return;
if|#
directive|if
literal|0
block|if (lseek (corechan, uaddr, 0)< 0) 	perror_with_name ("seek on core file");       if (myread (corechan, buf, sizeof (struct fpstate))< 0)  	perror_with_name ("read from core file");       skip = 0;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|__FreeBSD__
name|fpstatep
operator|=
operator|(
expr|struct
name|fpstate
operator|*
operator|)
operator|(
name|buf
operator|+
name|skip
operator|)
expr_stmt|;
name|print_387_status
argument_list|(
name|fpstatep
operator|->
name|sv_ex_sw
argument_list|,
operator|(
expr|struct
name|env387
operator|*
operator|)
name|fpstatep
argument_list|)
expr_stmt|;
else|#
directive|else
name|print_387_status
argument_list|(
literal|0
argument_list|,
operator|(
expr|struct
name|env387
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FLOAT_INFO */
end_comment

begin_function
name|int
name|kernel_u_size
parameter_list|()
block|{
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|user
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SETUP_ARBITRARY_FRAME
end_ifdef

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_function
name|struct
name|frame_info
modifier|*
name|setup_arbitrary_frame
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|CORE_ADDR
modifier|*
name|argv
decl_stmt|;
block|{
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
name|error
argument_list|(
literal|"i386 frame specifications require two arguments: sp and pc"
argument_list|)
expr_stmt|;
return|return
name|create_new_frame
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SETUP_ARBITRARY_FRAME */
end_comment

end_unit

