begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Native-dependent code for BSD Unix running on i386's, for GDB.    Copyright 1988, 1989, 1991, 1992, 1994, 1996 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|FETCH_INFERIOR_REGISTERS
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_function
name|void
name|fetch_inferior_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|struct
name|reg
name|inferior_registers
decl_stmt|;
name|ptrace
argument_list|(
name|PT_GETREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|inferior_registers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|0
argument_list|)
index|]
argument_list|,
operator|&
name|inferior_registers
argument_list|,
literal|4
operator|*
name|NUM_REGS
argument_list|)
expr_stmt|;
name|registers_fetched
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|store_inferior_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|struct
name|reg
name|inferior_registers
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|inferior_registers
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|0
argument_list|)
index|]
argument_list|,
literal|4
operator|*
name|NUM_REGS
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
name|PT_SETREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|inferior_registers
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|md_core
block|{
name|struct
name|reg
name|intreg
decl_stmt|;
name|struct
name|fpreg
name|freg
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|void
name|fetch_core_registers
parameter_list|(
name|core_reg_sect
parameter_list|,
name|core_reg_size
parameter_list|,
name|which
parameter_list|,
name|ignore
parameter_list|)
name|char
modifier|*
name|core_reg_sect
decl_stmt|;
name|unsigned
name|core_reg_size
decl_stmt|;
name|int
name|which
decl_stmt|;
name|unsigned
name|int
name|ignore
decl_stmt|;
block|{
name|struct
name|md_core
modifier|*
name|core_reg
init|=
operator|(
expr|struct
name|md_core
operator|*
operator|)
name|core_reg_sect
decl_stmt|;
comment|/* integer registers */
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
literal|0
argument_list|)
index|]
argument_list|,
operator|&
name|core_reg
operator|->
name|intreg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|reg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* floating point registers */
comment|/* XXX */
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_comment
comment|/* this table must line up with REGISTER_NAMES in tm-i386.h */
end_comment

begin_comment
comment|/* symbols like 'tEAX' come from<machine/reg.h> */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tregmap
index|[]
init|=
block|{
name|tEAX
block|,
name|tECX
block|,
name|tEDX
block|,
name|tEBX
block|,
name|tESP
block|,
name|tEBP
block|,
name|tESI
block|,
name|tEDI
block|,
name|tEIP
block|,
name|tEFLAGS
block|,
name|tCS
block|,
name|tSS
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|sEAX
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|sregmap
index|[]
init|=
block|{
name|sEAX
block|,
name|sECX
block|,
name|sEDX
block|,
name|sEBX
block|,
name|sESP
block|,
name|sEBP
block|,
name|sESI
block|,
name|sEDI
block|,
name|sEIP
block|,
name|sEFLAGS
block|,
name|sCS
block|,
name|sSS
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* No sEAX */
end_comment

begin_comment
comment|/* FreeBSD has decided to collapse the s* and t* symbols.  So if the s*    ones aren't around, use the t* ones for sregmap too.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sregmap
index|[]
init|=
block|{
name|tEAX
block|,
name|tECX
block|,
name|tEDX
block|,
name|tEBX
block|,
name|tESP
block|,
name|tEBP
block|,
name|tESI
block|,
name|tEDI
block|,
name|tEIP
block|,
name|tEFLAGS
block|,
name|tCS
block|,
name|tSS
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* No sEAX */
end_comment

begin_comment
comment|/* blockend is the value of u.u_ar0, and points to the    place where ES is stored.  */
end_comment

begin_function
name|int
name|i386_register_u_addr
parameter_list|(
name|blockend
parameter_list|,
name|regnum
parameter_list|)
name|int
name|blockend
decl_stmt|;
name|int
name|regnum
decl_stmt|;
block|{
comment|/* The following condition is a kludge to get at the proper register map      depending upon the state of pcb_flag.      The proper condition would be      if (u.u_pcb.pcb_flag& FM_TRAP)      but that would require a ptrace call here and wouldn't work      for corefiles.  */
if|if
condition|(
name|blockend
operator|<
literal|0x1fcc
condition|)
return|return
operator|(
name|blockend
operator|+
literal|4
operator|*
name|tregmap
index|[
name|regnum
index|]
operator|)
return|;
else|else
return|return
operator|(
name|blockend
operator|+
literal|4
operator|*
name|sregmap
index|[
name|regnum
index|]
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !FETCH_INFERIOR_REGISTERS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FLOAT_INFO
end_ifdef

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_comment
comment|/* for local_hex_string */
end_comment

begin_include
include|#
directive|include
file|"floatformat.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_define
define|#
directive|define
name|curpcb
value|Xcurpcb
end_define

begin_comment
comment|/* XXX avoid leaking declaration from pcb.h */
end_comment

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_undef
undef|#
directive|undef
name|curpcb
end_undef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_function_decl
specifier|extern
name|void
name|print_387_control_word
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* i387-tdep.h */
end_comment

begin_function_decl
specifier|extern
name|void
name|print_387_status_word
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|fpstate
value|save87
end_define

begin_define
define|#
directive|define
name|U_FPSTATE
parameter_list|(
name|u
parameter_list|)
value|u.u_pcb.pcb_savefpu
end_define

begin_struct
struct|struct
name|env387
block|{
name|unsigned
name|short
name|control
decl_stmt|;
name|unsigned
name|short
name|r0
decl_stmt|;
name|unsigned
name|short
name|status
decl_stmt|;
name|unsigned
name|short
name|r1
decl_stmt|;
name|unsigned
name|short
name|tag
decl_stmt|;
name|unsigned
name|short
name|r2
decl_stmt|;
name|unsigned
name|long
name|eip
decl_stmt|;
name|unsigned
name|short
name|code_seg
decl_stmt|;
name|unsigned
name|short
name|opcode
decl_stmt|;
name|unsigned
name|long
name|operand
decl_stmt|;
name|unsigned
name|short
name|operand_seg
decl_stmt|;
name|unsigned
name|short
name|r3
decl_stmt|;
name|unsigned
name|char
name|regs
index|[
literal|8
index|]
index|[
literal|10
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|print_387_status
parameter_list|(
name|status
parameter_list|,
name|ep
parameter_list|)
name|unsigned
name|short
name|status
decl_stmt|;
name|struct
name|env387
modifier|*
name|ep
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|bothstatus
decl_stmt|;
name|int
name|top
decl_stmt|;
name|int
name|fpreg
decl_stmt|;
name|bothstatus
operator|=
operator|(
operator|(
name|status
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ep
operator|->
name|status
operator|!=
literal|0
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bothstatus
condition|)
name|printf_unfiltered
argument_list|(
literal|"u: "
argument_list|)
expr_stmt|;
name|print_387_status_word
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|status
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ep
operator|->
name|status
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bothstatus
condition|)
name|printf_unfiltered
argument_list|(
literal|"e: "
argument_list|)
expr_stmt|;
name|print_387_status_word
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|ep
operator|->
name|status
argument_list|)
expr_stmt|;
block|}
name|print_387_control_word
argument_list|(
operator|(
name|unsigned
name|int
operator|)
name|ep
operator|->
name|control
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"last exception: "
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"opcode %s; "
argument_list|,
name|local_hex_string
argument_list|(
name|ep
operator|->
name|opcode
argument_list|)
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"pc %s:"
argument_list|,
name|local_hex_string
argument_list|(
name|ep
operator|->
name|code_seg
argument_list|)
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%s; "
argument_list|,
name|local_hex_string
argument_list|(
name|ep
operator|->
name|eip
argument_list|)
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"operand %s"
argument_list|,
name|local_hex_string
argument_list|(
name|ep
operator|->
name|operand_seg
argument_list|)
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|":%s\n"
argument_list|,
name|local_hex_string
argument_list|(
name|ep
operator|->
name|operand
argument_list|)
argument_list|)
expr_stmt|;
name|top
operator|=
operator|(
name|ep
operator|->
name|status
operator|>>
literal|11
operator|)
operator|&
literal|7
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"regno     tag  msb              lsb  value\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|fpreg
operator|=
literal|7
init|;
name|fpreg
operator|>=
literal|0
condition|;
name|fpreg
operator|--
control|)
block|{
name|double
name|val
decl_stmt|;
name|printf_unfiltered
argument_list|(
literal|"%s %d: "
argument_list|,
name|fpreg
operator|==
name|top
condition|?
literal|"=>"
else|:
literal|"  "
argument_list|,
name|fpreg
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|ep
operator|->
name|tag
operator|>>
operator|(
name|fpreg
operator|*
literal|2
operator|)
operator|)
operator|&
literal|3
condition|)
block|{
case|case
literal|0
case|:
name|printf_unfiltered
argument_list|(
literal|"valid "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|printf_unfiltered
argument_list|(
literal|"zero  "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|printf_unfiltered
argument_list|(
literal|"trap  "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|printf_unfiltered
argument_list|(
literal|"empty "
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|9
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|printf_unfiltered
argument_list|(
literal|"%02x"
argument_list|,
name|ep
operator|->
name|regs
index|[
name|fpreg
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|floatformat_to_double
argument_list|(
operator|&
name|floatformat_i387_ext
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ep
operator|->
name|regs
index|[
name|fpreg
index|]
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"  %g\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|i386_float_info
argument_list|()
end_macro

begin_block
block|{
name|struct
name|user
name|u
decl_stmt|;
comment|/* just for address computations */
name|int
name|i
decl_stmt|;
comment|/* fpstate defined in<sys/user.h> */
name|struct
name|fpstate
modifier|*
name|fpstatep
decl_stmt|;
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|fpstate
argument_list|)
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
index|]
decl_stmt|;
name|unsigned
name|int
name|uaddr
decl_stmt|;
name|char
name|fpvalid
decl_stmt|;
name|unsigned
name|int
name|rounded_addr
decl_stmt|;
name|unsigned
name|int
name|rounded_size
decl_stmt|;
comment|/*extern int corechan;*/
name|int
name|skip
decl_stmt|;
specifier|extern
name|int
name|inferior_pid
decl_stmt|;
name|uaddr
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|U_FPSTATE
argument_list|(
name|u
argument_list|)
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|u
expr_stmt|;
if|if
condition|(
name|inferior_pid
condition|)
block|{
name|int
modifier|*
name|ip
decl_stmt|;
name|rounded_addr
operator|=
name|uaddr
operator|&
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|rounded_size
operator|=
operator|(
operator|(
operator|(
name|uaddr
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|fpstate
argument_list|)
operator|)
operator|-
name|uaddr
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|skip
operator|=
name|uaddr
operator|-
name|rounded_addr
expr_stmt|;
name|ip
operator|=
operator|(
name|int
operator|*
operator|)
name|buf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rounded_size
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|ip
operator|++
operator|=
name|ptrace
argument_list|(
name|PT_READ_U
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|caddr_t
operator|)
name|rounded_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rounded_addr
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"float info: can't do a core file (yet)\n"
argument_list|)
expr_stmt|;
return|return;
if|#
directive|if
literal|0
block|if (lseek (corechan, uaddr, 0)< 0) 	perror_with_name ("seek on core file");       if (myread (corechan, buf, sizeof (struct fpstate))< 0)  	perror_with_name ("read from core file");       skip = 0;
endif|#
directive|endif
block|}
name|print_387_status
argument_list|(
literal|0
argument_list|,
operator|(
expr|struct
name|env387
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|int
name|kernel_u_size
parameter_list|()
block|{
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|user
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

