begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Support for complaint handling during symbol reading in GDB.     Copyright 1990, 1991, 1992, 1993, 1995, 1998, 1999, 2000, 2002 Free    Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"complaints.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_function_decl
specifier|extern
name|void
name|_initialize_complaints
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Should each complaint message be self explanatory, or should we assume that    a series of complaints is being produced?  */
end_comment

begin_comment
comment|/* case 1: First message of a series that must    start off with explanation.  case 2: Subsequent message of a series    that needs no explanation (the user already knows we have a problem    so we can just state our piece).  */
end_comment

begin_enum
enum|enum
name|complaint_series
block|{
comment|/* Isolated self explanatory message.  */
name|ISOLATED_MESSAGE
block|,
comment|/* First message of a series, includes an explanation.  */
name|FIRST_MESSAGE
block|,
comment|/* First message of a series, but does not need to include any sort      of explanation.  */
name|SHORT_FIRST_MESSAGE
block|,
comment|/* Subsequent message of a series that needs no explanation (the      user already knows we have a problem so we can just state our      piece).  */
name|SUBSEQUENT_MESSAGE
block|}
enum|;
end_enum

begin_comment
comment|/* Structure to manage complaints about symbol file contents.  */
end_comment

begin_struct
struct|struct
name|complain
block|{
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|counter
decl_stmt|;
name|struct
name|complain
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The explanatory message that should accompany the complaint.  The    message is in two parts - pre and post - that are printed around    the complaint text.  */
end_comment

begin_struct
struct|struct
name|explanation
block|{
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
specifier|const
name|char
modifier|*
name|postfix
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|complaints
block|{
name|struct
name|complain
modifier|*
name|root
decl_stmt|;
comment|/* Should each complaint be self explanatory, or should we assume      that a series of complaints is being produced?  case 0: Isolated      self explanatory message.  case 1: First message of a series that      must start off with explanation.  case 2: Subsequent message of a      series that needs no explanation (the user already knows we have      a problem so we can just state our piece).  */
name|int
name|series
decl_stmt|;
comment|/* The explanatory messages that should accompany the complaint.      NOTE: cagney/2002-08-14: In a desperate attempt at being vaguely      i18n friendly, this is an array of two messages.  When present,      the PRE and POST EXPLANATION[SERIES] are used to wrap the      message.  */
specifier|const
name|struct
name|explanation
modifier|*
name|explanation
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|complain
name|complaint_sentinel
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The symbol table complaint table.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|explanation
name|symfile_explanations
index|[]
init|=
block|{
block|{
literal|"During symbol reading, "
block|,
literal|"."
block|}
block|,
block|{
literal|"During symbol reading..."
block|,
literal|"..."
block|}
block|,
block|{
literal|""
block|,
literal|"..."
block|}
block|,
block|{
literal|""
block|,
literal|"..."
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|complaints
name|symfile_complaint_book
init|=
block|{
operator|&
name|complaint_sentinel
block|,
literal|0
block|,
name|symfile_explanations
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaints
modifier|*
name|symfile_complaints
init|=
operator|&
name|symfile_complaint_book
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Wrapper function to, on-demand, fill in a complaints object.  */
end_comment

begin_function
specifier|static
name|struct
name|complaints
modifier|*
name|get_complaints
parameter_list|(
name|struct
name|complaints
modifier|*
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|*
name|c
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
operator|*
name|c
operator|)
return|;
operator|(
operator|*
name|c
operator|)
operator|=
name|XMALLOC
argument_list|(
expr|struct
name|complaints
argument_list|)
expr_stmt|;
operator|(
operator|*
name|c
operator|)
operator|->
name|root
operator|=
operator|&
name|complaint_sentinel
expr_stmt|;
operator|(
operator|*
name|c
operator|)
operator|->
name|series
operator|=
name|ISOLATED_MESSAGE
expr_stmt|;
operator|(
operator|*
name|c
operator|)
operator|->
name|explanation
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
operator|*
name|c
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|complain
modifier|*
name|find_complaint
parameter_list|(
name|struct
name|complaints
modifier|*
name|complaints
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|)
block|{
name|struct
name|complain
modifier|*
name|complaint
decl_stmt|;
comment|/* Find the complaint in the table.  A more efficient search      algorithm (based on hash table or something) could be used.  But      that can wait until someone shows evidence that this lookup is      a real bottle neck.  */
for|for
control|(
name|complaint
operator|=
name|complaints
operator|->
name|root
init|;
name|complaint
operator|!=
name|NULL
condition|;
name|complaint
operator|=
name|complaint
operator|->
name|next
control|)
block|{
if|if
condition|(
name|complaint
operator|->
name|fmt
operator|==
name|fmt
operator|&&
name|complaint
operator|->
name|file
operator|==
name|file
operator|&&
name|complaint
operator|->
name|line
operator|==
name|line
condition|)
return|return
name|complaint
return|;
block|}
comment|/* Oops not seen before, fill in a new complaint.  */
name|complaint
operator|=
name|XMALLOC
argument_list|(
expr|struct
name|complain
argument_list|)
expr_stmt|;
name|complaint
operator|->
name|fmt
operator|=
name|fmt
expr_stmt|;
name|complaint
operator|->
name|file
operator|=
name|file
expr_stmt|;
name|complaint
operator|->
name|line
operator|=
name|line
expr_stmt|;
name|complaint
operator|->
name|counter
operator|=
literal|0
expr_stmt|;
name|complaint
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* File it, return it.  */
name|complaint
operator|->
name|next
operator|=
name|complaints
operator|->
name|root
expr_stmt|;
name|complaints
operator|->
name|root
operator|=
name|complaint
expr_stmt|;
return|return
name|complaint
return|;
block|}
end_function

begin_comment
comment|/* How many complaints about a particular thing should be printed    before we stop whining about it?  Default is no whining at all,    since so many systems have ill-constructed symbol files.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|stop_whining
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print a complaint, and link the complaint block into a chain for    later handling.  */
end_comment

begin_function
specifier|static
name|void
name|vcomplaint
parameter_list|(
name|struct
name|complaints
modifier|*
modifier|*
name|c
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|args
parameter_list|)
block|{
name|struct
name|complaints
modifier|*
name|complaints
init|=
name|get_complaints
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|struct
name|complain
modifier|*
name|complaint
init|=
name|find_complaint
argument_list|(
name|complaints
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|fmt
argument_list|)
decl_stmt|;
name|enum
name|complaint_series
name|series
decl_stmt|;
name|gdb_assert
argument_list|(
name|complaints
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|complaint
operator|->
name|counter
operator|++
expr_stmt|;
if|if
condition|(
name|complaint
operator|->
name|counter
operator|>
name|stop_whining
condition|)
return|return;
if|if
condition|(
name|info_verbose
condition|)
name|series
operator|=
name|SUBSEQUENT_MESSAGE
expr_stmt|;
else|else
name|series
operator|=
name|complaints
operator|->
name|series
expr_stmt|;
if|if
condition|(
name|complaint
operator|->
name|file
operator|!=
name|NULL
condition|)
name|internal_vwarning
argument_list|(
name|complaint
operator|->
name|file
argument_list|,
name|complaint
operator|->
name|line
argument_list|,
name|complaint
operator|->
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|warning_hook
condition|)
call|(
modifier|*
name|warning_hook
call|)
argument_list|(
name|complaint
operator|->
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|complaints
operator|->
name|explanation
operator|==
name|NULL
condition|)
comment|/* A [v]warning() call always appends a newline.  */
name|vwarning
argument_list|(
name|complaint
operator|->
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|msg
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|cleanups
decl_stmt|;
name|xvasprintf
argument_list|(
operator|&
name|msg
argument_list|,
name|complaint
operator|->
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|cleanups
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|series
operator|!=
name|SUBSEQUENT_MESSAGE
condition|)
name|begin_line
argument_list|()
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"%s%s%s"
argument_list|,
name|complaints
operator|->
name|explanation
index|[
name|series
index|]
operator|.
name|prefix
argument_list|,
name|msg
argument_list|,
name|complaints
operator|->
name|explanation
index|[
name|series
index|]
operator|.
name|postfix
argument_list|)
expr_stmt|;
comment|/* Force a line-break after any isolated message.  For the              other cases, clear_complaints() takes care of any missing              trailing newline, the wrap_here() is just a hint.  */
if|if
condition|(
name|series
operator|==
name|ISOLATED_MESSAGE
condition|)
comment|/* It would be really nice to use begin_line() here. 	       Unfortunately that function doesn't track GDB_STDERR and 	       consequently will sometimes supress a line when it 	       shouldn't.  */
name|fputs_filtered
argument_list|(
literal|"\n"
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
else|else
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|cleanups
argument_list|)
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|series
condition|)
block|{
case|case
name|ISOLATED_MESSAGE
case|:
break|break;
case|case
name|FIRST_MESSAGE
case|:
name|complaints
operator|->
name|series
operator|=
name|SUBSEQUENT_MESSAGE
expr_stmt|;
break|break;
case|case
name|SUBSEQUENT_MESSAGE
case|:
case|case
name|SHORT_FIRST_MESSAGE
case|:
name|complaints
operator|->
name|series
operator|=
name|SUBSEQUENT_MESSAGE
expr_stmt|;
break|break;
block|}
comment|/* If GDB dumps core, we'd like to see the complaints first.      Presumably GDB will not be sending so many complaints that this      becomes a performance hog.  */
name|gdb_flush
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|complaint
parameter_list|(
name|struct
name|complaints
modifier|*
modifier|*
name|complaints
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vcomplaint
argument_list|(
name|complaints
argument_list|,
name|NULL
comment|/*file*/
argument_list|,
literal|0
comment|/*line*/
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|internal_complaint
parameter_list|(
name|struct
name|complaints
modifier|*
modifier|*
name|complaints
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vcomplaint
argument_list|(
name|complaints
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clear out / initialize all complaint counters that have ever been    incremented.  If LESS_VERBOSE is 1, be less verbose about    successive complaints, since the messages are appearing all    together during a command that is reporting a contiguous block of    complaints (rather than being interleaved with other messages).  If    noisy is 1, we are in a noisy command, and our caller will print    enough context for the user to figure it out.  */
end_comment

begin_function
name|void
name|clear_complaints
parameter_list|(
name|struct
name|complaints
modifier|*
modifier|*
name|c
parameter_list|,
name|int
name|less_verbose
parameter_list|,
name|int
name|noisy
parameter_list|)
block|{
name|struct
name|complaints
modifier|*
name|complaints
init|=
name|get_complaints
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|struct
name|complain
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|complaints
operator|->
name|root
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
block|{
name|p
operator|->
name|counter
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|complaints
operator|->
name|series
condition|)
block|{
case|case
name|FIRST_MESSAGE
case|:
comment|/* Haven't yet printed anything.  */
break|break;
case|case
name|SHORT_FIRST_MESSAGE
case|:
comment|/* Haven't yet printed anything.  */
break|break;
case|case
name|ISOLATED_MESSAGE
case|:
comment|/* The code above, always forces a line-break.  No need to do it          here.  */
break|break;
case|case
name|SUBSEQUENT_MESSAGE
case|:
comment|/* It would be really nice to use begin_line() here.          Unfortunately that function doesn't track GDB_STDERR and          consequently will sometimes supress a line when it shouldn't.  */
name|fputs_unfiltered
argument_list|(
literal|"\n"
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"bad switch"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|less_verbose
condition|)
name|complaints
operator|->
name|series
operator|=
name|ISOLATED_MESSAGE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|noisy
condition|)
name|complaints
operator|->
name|series
operator|=
name|FIRST_MESSAGE
expr_stmt|;
else|else
name|complaints
operator|->
name|series
operator|=
name|SHORT_FIRST_MESSAGE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_complaints
parameter_list|(
name|void
parameter_list|)
block|{
name|add_setshow_cmd
argument_list|(
literal|"complaints"
argument_list|,
name|class_support
argument_list|,
name|var_zinteger
argument_list|,
operator|&
name|stop_whining
argument_list|,
literal|"Set max number of complaints about incorrect symbols."
argument_list|,
literal|"Show max number of complaints about incorrect symbols."
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|setlist
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

