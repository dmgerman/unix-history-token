begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Remote debugging interface for MIPS remote debugging protocol.    Copyright 1993, 1994, 1995 Free Software Foundation, Inc.    Contributed by Cygnus Support.  Written by Ian Lance Taylor<ian@cygnus.com>.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"remote-utils.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|mips_read_processor_type
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|mips_set_processor_type_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Prototypes for local functions.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_readchar
name|PARAMS
argument_list|(
operator|(
name|int
name|timeout
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mips_receive_header
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|char
operator|*
name|hdr
operator|,
name|int
operator|*
name|pgarbage
operator|,
name|int
name|ch
operator|,
name|int
name|timeout
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mips_receive_trailer
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|char
operator|*
name|trlr
operator|,
name|int
operator|*
name|pgarbage
operator|,
name|int
operator|*
name|pch
operator|,
name|int
name|timeout
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mips_cksum
name|PARAMS
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
name|hdr
operator|,
specifier|const
name|unsigned
name|char
operator|*
name|data
operator|,
name|int
name|len
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_send_packet
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|s
operator|,
name|int
name|get_ack
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_send_command
name|PARAMS
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|cmd
operator|,
name|int
name|prompt
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mips_receive_packet
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|buff
operator|,
name|int
name|throw_error
operator|,
name|int
name|timeout
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mips_request
name|PARAMS
argument_list|(
operator|(
name|int
name|cmd
operator|,
name|unsigned
name|int
name|addr
operator|,
name|unsigned
name|int
name|data
operator|,
name|int
operator|*
name|perr
operator|,
name|int
name|timeout
operator|,
name|char
operator|*
name|buff
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_initialize
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_open
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|name
operator|,
name|int
name|from_tty
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pmon_open
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|name
operator|,
name|int
name|from_tty
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_close
name|PARAMS
argument_list|(
operator|(
name|int
name|quitting
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_detach
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|args
operator|,
name|int
name|from_tty
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_resume
name|PARAMS
argument_list|(
operator|(
name|int
name|pid
operator|,
name|int
name|step
operator|,
expr|enum
name|target_signal
name|siggnal
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mips_wait
name|PARAMS
argument_list|(
operator|(
name|int
name|pid
operator|,
expr|struct
name|target_waitstatus
operator|*
name|status
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pmon_wait
name|PARAMS
argument_list|(
operator|(
name|int
name|pid
operator|,
expr|struct
name|target_waitstatus
operator|*
name|status
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mips_map_regno
name|PARAMS
argument_list|(
operator|(
name|int
name|regno
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_fetch_registers
name|PARAMS
argument_list|(
operator|(
name|int
name|regno
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_prepare_to_store
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_store_registers
name|PARAMS
argument_list|(
operator|(
name|int
name|regno
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mips_fetch_word
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
name|addr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mips_store_word
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
name|addr
operator|,
name|int
name|value
operator|,
name|char
operator|*
name|old_contents
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mips_xfer_memory
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
name|memaddr
operator|,
name|char
operator|*
name|myaddr
operator|,
name|int
name|len
operator|,
name|int
name|write
operator|,
expr|struct
name|target_ops
operator|*
name|ignore
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_files_info
name|PARAMS
argument_list|(
operator|(
expr|struct
name|target_ops
operator|*
name|ignore
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_create_inferior
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|execfile
operator|,
name|char
operator|*
name|args
operator|,
name|char
operator|*
operator|*
name|env
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_mourn_inferior
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pmon_makeb64
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|long
name|v
operator|,
name|char
operator|*
name|p
operator|,
name|int
name|n
operator|,
name|int
operator|*
name|chksum
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pmon_zeroset
name|PARAMS
argument_list|(
operator|(
name|int
name|recsize
operator|,
name|char
operator|*
operator|*
name|buff
operator|,
name|int
operator|*
name|amount
operator|,
name|unsigned
name|int
operator|*
name|chksum
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pmon_checkset
name|PARAMS
argument_list|(
operator|(
name|int
name|recsize
operator|,
name|char
operator|*
operator|*
name|buff
operator|,
name|int
operator|*
name|value
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pmon_make_fastrec
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
name|outbuf
operator|,
name|unsigned
name|char
operator|*
name|inbuf
operator|,
name|int
operator|*
name|inptr
operator|,
name|int
name|inamount
operator|,
name|int
operator|*
name|recsize
operator|,
name|unsigned
name|int
operator|*
name|csum
operator|,
name|unsigned
name|int
operator|*
name|zerofill
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pmon_check_ack
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pmon_load_fast
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|file
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mips_load
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|file
operator|,
name|int
name|from_tty
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mips_make_srec
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|buffer
operator|,
name|int
name|type
operator|,
name|CORE_ADDR
name|memaddr
operator|,
name|unsigned
name|char
operator|*
name|myaddr
operator|,
name|int
name|len
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|common_breakpoint
name|PARAMS
argument_list|(
operator|(
name|int
name|cmd
operator|,
name|CORE_ADDR
name|addr
operator|,
name|CORE_ADDR
name|mask
operator|,
name|char
operator|*
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|common_open
name|PARAMS
argument_list|(
operator|(
expr|struct
name|target_ops
operator|*
name|ops
operator|,
name|char
operator|*
name|name
operator|,
name|int
name|from_tty
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|mips_ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|pmon_ops
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* The MIPS remote debugging interface is built on top of a simple    packet protocol.  Each packet is organized as follows:     SYN	The first character is always a SYN (ASCII 026, or ^V).  SYN 	may not appear anywhere else in the packet.  Any time a SYN is 	seen, a new packet should be assumed to have begun.     TYPE_LEN 	This byte contains the upper five bits of the logical length 	of the data section, plus a single bit indicating whether this 	is a data packet or an acknowledgement.  The documentation 	indicates that this bit is 1 for a data packet, but the actual 	board uses 1 for an acknowledgement.  The value of the byte is 		0x40 + (ack ? 0x20 : 0) + (len>> 6) 	(we always have 0<= len< 1024).  Acknowledgement packets do 	not carry data, and must have a data length of 0.     LEN1 This byte contains the lower six bits of the logical length of 	the data section.  The value is 	 	0x40 + (len& 0x3f)     SEQ	This byte contains the six bit sequence number of the packet. 	The value is 		0x40 + seq 	An acknowlegment packet contains the sequence number of the 	packet being acknowledged plus 1 modulo 64.  Data packets are 	transmitted in sequence.  There may only be one outstanding 	unacknowledged data packet at a time.  The sequence numbers 	are independent in each direction.  If an acknowledgement for 	the previous packet is received (i.e., an acknowledgement with 	the sequence number of the packet just sent) the packet just 	sent should be retransmitted.  If no acknowledgement is 	received within a timeout period, the packet should be 	retransmitted.  This has an unfortunate failure condition on a 	high-latency line, as a delayed acknowledgement may lead to an 	endless series of duplicate packets.     DATA	The actual data bytes follow.  The following characters are 	escaped inline with DLE (ASCII 020, or ^P): 		SYN (026)	DLE S 		DLE (020)	DLE D 		^C  (003)	DLE C 		^S  (023)	DLE s 		^Q  (021)	DLE q 	The additional DLE characters are not counted in the logical 	length stored in the TYPE_LEN and LEN1 bytes.     CSUM1    CSUM2    CSUM3 	These bytes contain an 18 bit checksum of the complete 	contents of the packet excluding the SEQ byte and the 	CSUM[123] bytes.  The checksum is simply the twos complement 	addition of all the bytes treated as unsigned characters.  The 	values of the checksum bytes are: 		CSUM1: 0x40 + ((cksum>> 12)& 0x3f) 		CSUM2: 0x40 + ((cksum>> 6)& 0x3f) 		CSUM3: 0x40 + (cksum& 0x3f)     It happens that the MIPS remote debugging protocol always    communicates with ASCII strings.  Because of this, this    implementation doesn't bother to handle the DLE quoting mechanism,    since it will never be required.  */
end_comment

begin_comment
comment|/* The SYN character which starts each packet.  */
end_comment

begin_define
define|#
directive|define
name|SYN
value|'\026'
end_define

begin_comment
comment|/* The 0x40 used to offset each packet (this value ensures that all of    the header and trailer bytes, other than SYN, are printable ASCII    characters).  */
end_comment

begin_define
define|#
directive|define
name|HDR_OFFSET
value|0x40
end_define

begin_comment
comment|/* The indices of the bytes in the packet header.  */
end_comment

begin_define
define|#
directive|define
name|HDR_INDX_SYN
value|0
end_define

begin_define
define|#
directive|define
name|HDR_INDX_TYPE_LEN
value|1
end_define

begin_define
define|#
directive|define
name|HDR_INDX_LEN1
value|2
end_define

begin_define
define|#
directive|define
name|HDR_INDX_SEQ
value|3
end_define

begin_define
define|#
directive|define
name|HDR_LENGTH
value|4
end_define

begin_comment
comment|/* The data/ack bit in the TYPE_LEN header byte.  */
end_comment

begin_define
define|#
directive|define
name|TYPE_LEN_DA_BIT
value|0x20
end_define

begin_define
define|#
directive|define
name|TYPE_LEN_DATA
value|0
end_define

begin_define
define|#
directive|define
name|TYPE_LEN_ACK
value|TYPE_LEN_DA_BIT
end_define

begin_comment
comment|/* How to compute the header bytes.  */
end_comment

begin_define
define|#
directive|define
name|HDR_SET_SYN
parameter_list|(
name|data
parameter_list|,
name|len
parameter_list|,
name|seq
parameter_list|)
value|(SYN)
end_define

begin_define
define|#
directive|define
name|HDR_SET_TYPE_LEN
parameter_list|(
name|data
parameter_list|,
name|len
parameter_list|,
name|seq
parameter_list|)
define|\
value|(HDR_OFFSET \    + ((data) ? TYPE_LEN_DATA : TYPE_LEN_ACK) \    + (((len)>> 6)& 0x1f))
end_define

begin_define
define|#
directive|define
name|HDR_SET_LEN1
parameter_list|(
name|data
parameter_list|,
name|len
parameter_list|,
name|seq
parameter_list|)
value|(HDR_OFFSET + ((len)& 0x3f))
end_define

begin_define
define|#
directive|define
name|HDR_SET_SEQ
parameter_list|(
name|data
parameter_list|,
name|len
parameter_list|,
name|seq
parameter_list|)
value|(HDR_OFFSET + (seq))
end_define

begin_comment
comment|/* Check that a header byte is reasonable.  */
end_comment

begin_define
define|#
directive|define
name|HDR_CHECK
parameter_list|(
name|ch
parameter_list|)
value|(((ch)& HDR_OFFSET) == HDR_OFFSET)
end_define

begin_comment
comment|/* Get data from the header.  These macros evaluate their argument    multiple times.  */
end_comment

begin_define
define|#
directive|define
name|HDR_IS_DATA
parameter_list|(
name|hdr
parameter_list|)
define|\
value|(((hdr)[HDR_INDX_TYPE_LEN]& TYPE_LEN_DA_BIT) == TYPE_LEN_DATA)
end_define

begin_define
define|#
directive|define
name|HDR_GET_LEN
parameter_list|(
name|hdr
parameter_list|)
define|\
value|((((hdr)[HDR_INDX_TYPE_LEN]& 0x1f)<< 6) + (((hdr)[HDR_INDX_LEN1]& 0x3f)))
end_define

begin_define
define|#
directive|define
name|HDR_GET_SEQ
parameter_list|(
name|hdr
parameter_list|)
value|((hdr)[HDR_INDX_SEQ]& 0x3f)
end_define

begin_comment
comment|/* The maximum data length.  */
end_comment

begin_define
define|#
directive|define
name|DATA_MAXLEN
value|1023
end_define

begin_comment
comment|/* The trailer offset.  */
end_comment

begin_define
define|#
directive|define
name|TRLR_OFFSET
value|HDR_OFFSET
end_define

begin_comment
comment|/* The indices of the bytes in the packet trailer.  */
end_comment

begin_define
define|#
directive|define
name|TRLR_INDX_CSUM1
value|0
end_define

begin_define
define|#
directive|define
name|TRLR_INDX_CSUM2
value|1
end_define

begin_define
define|#
directive|define
name|TRLR_INDX_CSUM3
value|2
end_define

begin_define
define|#
directive|define
name|TRLR_LENGTH
value|3
end_define

begin_comment
comment|/* How to compute the trailer bytes.  */
end_comment

begin_define
define|#
directive|define
name|TRLR_SET_CSUM1
parameter_list|(
name|cksum
parameter_list|)
value|(TRLR_OFFSET + (((cksum)>> 12)& 0x3f))
end_define

begin_define
define|#
directive|define
name|TRLR_SET_CSUM2
parameter_list|(
name|cksum
parameter_list|)
value|(TRLR_OFFSET + (((cksum)>>  6)& 0x3f))
end_define

begin_define
define|#
directive|define
name|TRLR_SET_CSUM3
parameter_list|(
name|cksum
parameter_list|)
value|(TRLR_OFFSET + (((cksum)      )& 0x3f))
end_define

begin_comment
comment|/* Check that a trailer byte is reasonable.  */
end_comment

begin_define
define|#
directive|define
name|TRLR_CHECK
parameter_list|(
name|ch
parameter_list|)
value|(((ch)& TRLR_OFFSET) == TRLR_OFFSET)
end_define

begin_comment
comment|/* Get data from the trailer.  This evaluates its argument multiple    times.  */
end_comment

begin_define
define|#
directive|define
name|TRLR_GET_CKSUM
parameter_list|(
name|trlr
parameter_list|)
define|\
value|((((trlr)[TRLR_INDX_CSUM1]& 0x3f)<< 12) \    + (((trlr)[TRLR_INDX_CSUM2]& 0x3f)<<  6) \    + ((trlr)[TRLR_INDX_CSUM3]& 0x3f))
end_define

begin_comment
comment|/* The sequence number modulos.  */
end_comment

begin_define
define|#
directive|define
name|SEQ_MODULOS
value|(64)
end_define

begin_enum
enum|enum
name|mips_monitor_type
block|{
comment|/* IDT/SIM monitor being used: */
name|MON_IDT
block|,
comment|/* PMON monitor being used: */
name|MON_PMON
block|,
comment|/* Last and unused value, for sizing vectors, etc. */
name|MON_LAST
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|enum
name|mips_monitor_type
name|mips_monitor
init|=
name|MON_LAST
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The default monitor prompt text: */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mips_monitor_prompt
init|=
name|TARGET_MONITOR_PROMPT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For the Cogent PMON world this is still not ideal. The default    prompt is "PMON> ", unfortunately the user can change the prompt    and the new prompt will survive over a power-cycle (EEPROM). This    means that the code should really force the monitor prompt to a    known value as the very first action, and that the    "mips_monitor_prompt" support is not needed... since the prompt    could be explicitly set to TARGET_MONITOR_PROMPT (even though it    may be the prompt for a different monitor). However, this will    require changing the mips_initialize reset sequence. (TODO) */
end_comment

begin_comment
comment|/* Set to 1 if the target is open.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_is_open
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Currently active target description (if mips_is_open == 1) */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|target_ops
modifier|*
name|current_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 1 while the connection is being initialized.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_initializing
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The next sequence number to send.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|mips_send_seq
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The next sequence number we expect to receive.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|mips_receive_seq
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The time to wait before retransmitting a packet, in seconds.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_retransmit_wait
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of times to try retransmitting a packet before giving up.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_send_retries
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of garbage characters to accept when looking for an    SYN for the next packet.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_syn_garbage
init|=
literal|1050
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The time to wait for a packet, in seconds.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_receive_wait
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set if we have sent a packet to the board but have not yet received    a reply.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_need_reply
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Handle used to access serial I/O stream.  */
end_comment

begin_decl_stmt
specifier|static
name|serial_t
name|mips_desc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Counts the number of times the user tried to interrupt the target (usually    via ^C.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|interrupt_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, means that the target is running. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_wait_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, monitor supports breakpoint commands. */
end_comment

begin_expr_stmt
specifier|static
name|monitor_supports_breakpoints
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Data cache header.  */
end_comment

begin_decl_stmt
specifier|static
name|DCACHE
modifier|*
name|mips_dcache
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means that we've just hit a read or write watchpoint */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hit_watchpoint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Handle low-level error that we can't recover from.  Note that just    error()ing out from target_wait or some such low-level place will cause    all hell to break loose--the rest of GDB will tend to get left in an    inconsistent state.  */
end_comment

begin_function
specifier|static
name|NORETURN
name|void
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|mips_error
parameter_list|(
name|char
modifier|*
name|string
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|mips_error
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|args
decl_stmt|;
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|va_start
argument_list|(
name|args
argument_list|,
name|string
argument_list|)
expr_stmt|;
else|#
directive|else
name|char
modifier|*
name|string
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|string
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|target_terminal_ours
argument_list|()
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* Force out any buffered output */
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_pre_print
condition|)
name|fprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
name|error_pre_print
argument_list|)
expr_stmt|;
name|vfprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
name|string
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
comment|/* Clean up in such a way that mips_close won't try to talk to the      board (it almost surely won't work since we weren't able to talk to      it).  */
name|mips_is_open
operator|=
literal|0
expr_stmt|;
name|SERIAL_CLOSE
argument_list|(
name|mips_desc
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"Ending remote MIPS debugging.\n"
argument_list|)
expr_stmt|;
name|target_mourn_inferior
argument_list|()
expr_stmt|;
name|return_to_top_level
argument_list|(
name|RETURN_ERROR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wait until STRING shows up in mips_desc.  Returns 1 if successful, else 0 if    timed out.  */
end_comment

begin_function
name|int
name|mips_expect
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|string
decl_stmt|;
name|immediate_quit
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|c
decl_stmt|;
comment|/* Must use SERIAL_READCHAR here cuz mips_readchar would get confused if we    were waiting for the mips_monitor_prompt... */
name|c
operator|=
name|SERIAL_READCHAR
argument_list|(
name|mips_desc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|SERIAL_TIMEOUT
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|c
operator|==
operator|*
name|p
operator|++
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|immediate_quit
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
else|else
block|{
name|p
operator|=
name|string
expr_stmt|;
if|if
condition|(
name|c
operator|==
operator|*
name|p
condition|)
name|p
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Read the required number of characters into the given buffer (which    is assumed to be large enough). The only failure is a timeout. */
end_comment

begin_function
name|int
name|mips_getstring
parameter_list|(
name|string
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|string
decl_stmt|;
name|int
name|c
decl_stmt|;
name|immediate_quit
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|c
operator|=
name|SERIAL_READCHAR
argument_list|(
name|mips_desc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|SERIAL_TIMEOUT
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|stderr
argument_list|,
literal|"Failed to read %d characters from target (TIMEOUT)\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|n
operator|--
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Read a character from the remote, aborting on error.  Returns    SERIAL_TIMEOUT on timeout (since that's what SERIAL_READCHAR    returns).  FIXME: If we see the string mips_monitor_prompt from    the board, then we are debugging on the main console port, and we    have somehow dropped out of remote debugging mode.  In this case,    we automatically go back in to remote debugging mode.  This is a    hack, put in because I can't find any way for a program running on    the remote board to terminate without also ending remote debugging    mode.  I assume users won't have any trouble with this; for one    thing, the IDT documentation generally assumes that the remote    debugging port is not the console port.  This is, however, very    convenient for DejaGnu when you only have one connected serial    port.  */
end_comment

begin_function
specifier|static
name|int
name|mips_readchar
parameter_list|(
name|timeout
parameter_list|)
name|int
name|timeout
decl_stmt|;
block|{
name|int
name|ch
decl_stmt|;
specifier|static
name|int
name|state
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|mips_monitor_prompt_len
init|=
operator|-
literal|1
decl_stmt|;
comment|/* NASTY, since we assume that the prompt does not change after the      first mips_readchar call: */
if|if
condition|(
name|mips_monitor_prompt_len
operator|=
operator|-
literal|1
condition|)
name|mips_monitor_prompt_len
operator|=
name|strlen
argument_list|(
name|mips_monitor_prompt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAINTENANCE_CMDS
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
name|timeout
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
operator|&&
name|watchdog
operator|>
literal|0
condition|)
name|i
operator|=
name|watchdog
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|state
operator|==
name|mips_monitor_prompt_len
condition|)
name|timeout
operator|=
literal|1
expr_stmt|;
name|ch
operator|=
name|SERIAL_READCHAR
argument_list|(
name|mips_desc
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAINTENANCE_CMDS
if|if
condition|(
name|ch
operator|==
name|SERIAL_TIMEOUT
operator|&&
name|timeout
operator|==
operator|-
literal|1
condition|)
comment|/* Watchdog went off */
block|{
name|target_mourn_inferior
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"Watchdog has expired.  Target detached.\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|ch
operator|==
name|SERIAL_EOF
condition|)
name|mips_error
argument_list|(
literal|"End of file from remote"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|SERIAL_ERROR
condition|)
name|mips_error
argument_list|(
literal|"Error reading from remote: %s"
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_debug
operator|>
literal|1
condition|)
block|{
comment|/* Don't use _filtered; we can't deal with a QUIT out of 	 target_wait, and I think this might be called from there.  */
if|if
condition|(
name|ch
operator|!=
name|SERIAL_TIMEOUT
condition|)
name|printf_unfiltered
argument_list|(
literal|"Read '%c' %d 0x%x\n"
argument_list|,
name|ch
argument_list|,
name|ch
argument_list|,
name|ch
argument_list|)
expr_stmt|;
else|else
name|printf_unfiltered
argument_list|(
literal|"Timed out in read\n"
argument_list|)
expr_stmt|;
block|}
comment|/* If we have seen mips_monitor_prompt and we either time out, or      we see a @ (which was echoed from a packet we sent), reset the      board as described above.  The first character in a packet after      the SYN (which is not echoed) is always an @ unless the packet is      more than 64 characters long, which ours never are.  */
if|if
condition|(
operator|(
name|ch
operator|==
name|SERIAL_TIMEOUT
operator|||
name|ch
operator|==
literal|'@'
operator|)
operator|&&
name|state
operator|==
name|mips_monitor_prompt_len
operator|&&
operator|!
name|mips_initializing
condition|)
block|{
if|if
condition|(
name|remote_debug
operator|>
literal|0
condition|)
comment|/* Don't use _filtered; we can't deal with a QUIT out of 	   target_wait, and I think this might be called from there.  */
name|printf_unfiltered
argument_list|(
literal|"Reinitializing MIPS debugging mode\n"
argument_list|)
expr_stmt|;
name|mips_need_reply
operator|=
literal|0
expr_stmt|;
name|mips_initialize
argument_list|()
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
comment|/* At this point, about the only thing we can do is abort the command 	 in progress and get back to command level as quickly as possible. */
name|error
argument_list|(
literal|"Remote board reset, debug protocol re-initialized."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|==
name|mips_monitor_prompt
index|[
name|state
index|]
condition|)
operator|++
name|state
expr_stmt|;
else|else
name|state
operator|=
literal|0
expr_stmt|;
return|return
name|ch
return|;
block|}
end_function

begin_comment
comment|/* Get a packet header, putting the data in the supplied buffer.    PGARBAGE is a pointer to the number of garbage characters received    so far.  CH is the last character received.  Returns 0 for success,    or -1 for timeout.  */
end_comment

begin_function
specifier|static
name|int
name|mips_receive_header
parameter_list|(
name|hdr
parameter_list|,
name|pgarbage
parameter_list|,
name|ch
parameter_list|,
name|timeout
parameter_list|)
name|unsigned
name|char
modifier|*
name|hdr
decl_stmt|;
name|int
modifier|*
name|pgarbage
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|int
name|timeout
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Wait for a SYN.  mips_syn_garbage is intended to prevent 	 sitting here indefinitely if the board sends us one garbage 	 character per second.  ch may already have a value from the 	 last time through the loop.  */
while|while
condition|(
name|ch
operator|!=
name|SYN
condition|)
block|{
name|ch
operator|=
name|mips_readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|SERIAL_TIMEOUT
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ch
operator|!=
name|SYN
condition|)
block|{
comment|/* Printing the character here lets the user of gdb see 		 what the program is outputting, if the debugging is 		 being done on the console port.  Don't use _filtered; 		 we can't deal with a QUIT out of target_wait.  */
if|if
condition|(
operator|!
name|mips_initializing
operator|||
name|remote_debug
operator|>
literal|0
condition|)
block|{
comment|/* Note that the host's idea of newline may not 		     correspond to the target's idea, so recognize 		     newline by its actual ASCII code, but write it 		     out using the \n notation.  */
if|if
condition|(
name|ch
operator|<
literal|0x20
operator|&&
name|ch
operator|!=
literal|'\012'
condition|)
block|{
name|putchar_unfiltered
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|putchar_unfiltered
argument_list|(
name|ch
operator|+
literal|0x40
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\012'
condition|)
name|putchar_unfiltered
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
else|else
name|putchar_unfiltered
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
operator|++
operator|*
name|pgarbage
expr_stmt|;
if|if
condition|(
name|mips_syn_garbage
operator|>
literal|0
operator|&&
operator|*
name|pgarbage
operator|>
name|mips_syn_garbage
condition|)
name|mips_error
argument_list|(
literal|"Debug protocol failure:  more than %d characters before a sync."
argument_list|,
name|mips_syn_garbage
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Get the packet header following the SYN.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|HDR_LENGTH
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|=
name|mips_readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|SERIAL_TIMEOUT
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Make sure this is a header byte.  */
if|if
condition|(
name|ch
operator|==
name|SYN
operator|||
operator|!
name|HDR_CHECK
argument_list|(
name|ch
argument_list|)
condition|)
break|break;
name|hdr
index|[
name|i
index|]
operator|=
name|ch
expr_stmt|;
block|}
comment|/* If we got the complete header, we can return.  Otherwise we 	 loop around and keep looking for SYN.  */
if|if
condition|(
name|i
operator|>=
name|HDR_LENGTH
condition|)
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Get a packet header, putting the data in the supplied buffer.    PGARBAGE is a pointer to the number of garbage characters received    so far.  The last character read is returned in *PCH.  Returns 0    for success, -1 for timeout, -2 for error.  */
end_comment

begin_function
specifier|static
name|int
name|mips_receive_trailer
parameter_list|(
name|trlr
parameter_list|,
name|pgarbage
parameter_list|,
name|pch
parameter_list|,
name|timeout
parameter_list|)
name|unsigned
name|char
modifier|*
name|trlr
decl_stmt|;
name|int
modifier|*
name|pgarbage
decl_stmt|;
name|int
modifier|*
name|pch
decl_stmt|;
name|int
name|timeout
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|ch
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TRLR_LENGTH
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|=
name|mips_readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
operator|*
name|pch
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|SERIAL_TIMEOUT
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|TRLR_CHECK
argument_list|(
name|ch
argument_list|)
condition|)
return|return
operator|-
literal|2
return|;
name|trlr
index|[
name|i
index|]
operator|=
name|ch
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Get the checksum of a packet.  HDR points to the packet header.    DATA points to the packet data.  LEN is the length of DATA.  */
end_comment

begin_function
specifier|static
name|int
name|mips_cksum
parameter_list|(
name|hdr
parameter_list|,
name|data
parameter_list|,
name|len
parameter_list|)
specifier|const
name|unsigned
name|char
modifier|*
name|hdr
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|data
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|int
name|cksum
decl_stmt|;
name|cksum
operator|=
literal|0
expr_stmt|;
comment|/* The initial SYN is not included in the checksum.  */
name|c
operator|=
name|HDR_LENGTH
operator|-
literal|1
expr_stmt|;
name|p
operator|=
name|hdr
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|c
operator|--
operator|!=
literal|0
condition|)
name|cksum
operator|+=
operator|*
name|p
operator|++
expr_stmt|;
name|c
operator|=
name|len
expr_stmt|;
name|p
operator|=
name|data
expr_stmt|;
while|while
condition|(
name|c
operator|--
operator|!=
literal|0
condition|)
name|cksum
operator|+=
operator|*
name|p
operator|++
expr_stmt|;
return|return
name|cksum
return|;
block|}
end_function

begin_comment
comment|/* Send a packet containing the given ASCII string.  */
end_comment

begin_function
specifier|static
name|void
name|mips_send_packet
parameter_list|(
name|s
parameter_list|,
name|get_ack
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|get_ack
decl_stmt|;
block|{
name|unsigned
name|int
name|len
decl_stmt|;
name|unsigned
name|char
modifier|*
name|packet
decl_stmt|;
specifier|register
name|int
name|cksum
decl_stmt|;
name|int
name|try
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|DATA_MAXLEN
condition|)
name|mips_error
argument_list|(
literal|"MIPS protocol data packet too long: %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|packet
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|HDR_LENGTH
operator|+
name|len
operator|+
name|TRLR_LENGTH
operator|+
literal|1
argument_list|)
expr_stmt|;
name|packet
index|[
name|HDR_INDX_SYN
index|]
operator|=
name|HDR_SET_SYN
argument_list|(
literal|1
argument_list|,
name|len
argument_list|,
name|mips_send_seq
argument_list|)
expr_stmt|;
name|packet
index|[
name|HDR_INDX_TYPE_LEN
index|]
operator|=
name|HDR_SET_TYPE_LEN
argument_list|(
literal|1
argument_list|,
name|len
argument_list|,
name|mips_send_seq
argument_list|)
expr_stmt|;
name|packet
index|[
name|HDR_INDX_LEN1
index|]
operator|=
name|HDR_SET_LEN1
argument_list|(
literal|1
argument_list|,
name|len
argument_list|,
name|mips_send_seq
argument_list|)
expr_stmt|;
name|packet
index|[
name|HDR_INDX_SEQ
index|]
operator|=
name|HDR_SET_SEQ
argument_list|(
literal|1
argument_list|,
name|len
argument_list|,
name|mips_send_seq
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|packet
operator|+
name|HDR_LENGTH
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cksum
operator|=
name|mips_cksum
argument_list|(
name|packet
argument_list|,
name|packet
operator|+
name|HDR_LENGTH
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|packet
index|[
name|HDR_LENGTH
operator|+
name|len
operator|+
name|TRLR_INDX_CSUM1
index|]
operator|=
name|TRLR_SET_CSUM1
argument_list|(
name|cksum
argument_list|)
expr_stmt|;
name|packet
index|[
name|HDR_LENGTH
operator|+
name|len
operator|+
name|TRLR_INDX_CSUM2
index|]
operator|=
name|TRLR_SET_CSUM2
argument_list|(
name|cksum
argument_list|)
expr_stmt|;
name|packet
index|[
name|HDR_LENGTH
operator|+
name|len
operator|+
name|TRLR_INDX_CSUM3
index|]
operator|=
name|TRLR_SET_CSUM3
argument_list|(
name|cksum
argument_list|)
expr_stmt|;
comment|/* Increment the sequence number.  This will set mips_send_seq to      the sequence number we expect in the acknowledgement.  */
name|mips_send_seq
operator|=
operator|(
name|mips_send_seq
operator|+
literal|1
operator|)
operator|%
name|SEQ_MODULOS
expr_stmt|;
comment|/* We can only have one outstanding data packet, so we just wait for      the acknowledgement here.  Keep retransmitting the packet until      we get one, or until we've tried too many times.  */
for|for
control|(
name|try
operator|=
literal|0
init|;
name|try
operator|<
name|mips_send_retries
condition|;
name|try
operator|++
control|)
block|{
name|int
name|garbage
decl_stmt|;
name|int
name|ch
decl_stmt|;
if|if
condition|(
name|remote_debug
operator|>
literal|0
condition|)
block|{
comment|/* Don't use _filtered; we can't deal with a QUIT out of 	     target_wait, and I think this might be called from there.  */
name|packet
index|[
name|HDR_LENGTH
operator|+
name|len
operator|+
name|TRLR_LENGTH
index|]
operator|=
literal|'\0'
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"Writing \"%s\"\n"
argument_list|,
name|packet
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SERIAL_WRITE
argument_list|(
name|mips_desc
argument_list|,
name|packet
argument_list|,
name|HDR_LENGTH
operator|+
name|len
operator|+
name|TRLR_LENGTH
argument_list|)
operator|!=
literal|0
condition|)
name|mips_error
argument_list|(
literal|"write to target failed: %s"
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_ack
condition|)
return|return;
name|garbage
operator|=
literal|0
expr_stmt|;
name|ch
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|unsigned
name|char
name|hdr
index|[
name|HDR_LENGTH
operator|+
literal|1
index|]
decl_stmt|;
name|unsigned
name|char
name|trlr
index|[
name|TRLR_LENGTH
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|seq
decl_stmt|;
comment|/* Get the packet header.  If we time out, resend the data 	     packet.  */
name|err
operator|=
name|mips_receive_header
argument_list|(
name|hdr
argument_list|,
operator|&
name|garbage
argument_list|,
name|ch
argument_list|,
name|mips_retransmit_wait
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
break|break;
name|ch
operator|=
literal|0
expr_stmt|;
comment|/* If we get a data packet, assume it is a duplicate and 	     ignore it.  FIXME: If the acknowledgement is lost, this 	     data packet may be the packet the remote sends after the 	     acknowledgement.  */
if|if
condition|(
name|HDR_IS_DATA
argument_list|(
name|hdr
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Ignore any errors raised whilst attempting to ignore                packet. */
name|len
operator|=
name|HDR_GET_LEN
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|int
name|rch
decl_stmt|;
name|rch
operator|=
name|mips_readchar
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rch
operator|==
name|SYN
condition|)
block|{
name|ch
operator|=
name|SYN
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rch
operator|==
name|SERIAL_TIMEOUT
condition|)
break|break;
comment|/* ignore the character */
block|}
if|if
condition|(
name|i
operator|==
name|len
condition|)
operator|(
name|void
operator|)
name|mips_receive_trailer
argument_list|(
name|trlr
argument_list|,
operator|&
name|garbage
argument_list|,
operator|&
name|ch
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* We don't bother checking the checksum, or providing an                ACK to the packet. */
continue|continue;
block|}
comment|/* If the length is not 0, this is a garbled packet.  */
if|if
condition|(
name|HDR_GET_LEN
argument_list|(
name|hdr
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* Get the packet trailer.  */
name|err
operator|=
name|mips_receive_trailer
argument_list|(
name|trlr
argument_list|,
operator|&
name|garbage
argument_list|,
operator|&
name|ch
argument_list|,
name|mips_retransmit_wait
argument_list|)
expr_stmt|;
comment|/* If we timed out, resend the data packet.  */
if|if
condition|(
name|err
operator|==
operator|-
literal|1
condition|)
break|break;
comment|/* If we got a bad character, reread the header.  */
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
continue|continue;
comment|/* If the checksum does not match the trailer checksum, this 	     is a bad packet; ignore it.  */
if|if
condition|(
name|mips_cksum
argument_list|(
name|hdr
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
name|TRLR_GET_CKSUM
argument_list|(
name|trlr
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|remote_debug
operator|>
literal|0
condition|)
block|{
name|hdr
index|[
name|HDR_LENGTH
index|]
operator|=
literal|'\0'
expr_stmt|;
name|trlr
index|[
name|TRLR_LENGTH
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Don't use _filtered; we can't deal with a QUIT out of 		 target_wait, and I think this might be called from there.  */
name|printf_unfiltered
argument_list|(
literal|"Got ack %d \"%s%s\"\n"
argument_list|,
name|HDR_GET_SEQ
argument_list|(
name|hdr
argument_list|)
argument_list|,
name|hdr
operator|+
literal|1
argument_list|,
name|trlr
argument_list|)
expr_stmt|;
block|}
comment|/* If this ack is for the current packet, we're done.  */
name|seq
operator|=
name|HDR_GET_SEQ
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|seq
operator|==
name|mips_send_seq
condition|)
return|return;
comment|/* If this ack is for the last packet, resend the current 	     packet.  */
if|if
condition|(
operator|(
name|seq
operator|+
literal|1
operator|)
operator|%
name|SEQ_MODULOS
operator|==
name|mips_send_seq
condition|)
break|break;
comment|/* Otherwise this is a bad ack; ignore it.  Increment the 	     garbage count to ensure that we do not stay in this loop 	     forever.  */
operator|++
name|garbage
expr_stmt|;
block|}
block|}
name|mips_error
argument_list|(
literal|"Remote did not acknowledge packet"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Receive and acknowledge a packet, returning the data in BUFF (which    should be DATA_MAXLEN + 1 bytes).  The protocol documentation    implies that only the sender retransmits packets, so this code just    waits silently for a packet.  It returns the length of the received    packet.  If THROW_ERROR is nonzero, call error() on errors.  If not,    don't print an error message and return -1.  */
end_comment

begin_function
specifier|static
name|int
name|mips_receive_packet
parameter_list|(
name|buff
parameter_list|,
name|throw_error
parameter_list|,
name|timeout
parameter_list|)
name|char
modifier|*
name|buff
decl_stmt|;
name|int
name|throw_error
decl_stmt|;
name|int
name|timeout
decl_stmt|;
block|{
name|int
name|ch
decl_stmt|;
name|int
name|garbage
decl_stmt|;
name|int
name|len
decl_stmt|;
name|unsigned
name|char
name|ack
index|[
name|HDR_LENGTH
operator|+
name|TRLR_LENGTH
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|cksum
decl_stmt|;
name|ch
operator|=
literal|0
expr_stmt|;
name|garbage
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|unsigned
name|char
name|hdr
index|[
name|HDR_LENGTH
index|]
decl_stmt|;
name|unsigned
name|char
name|trlr
index|[
name|TRLR_LENGTH
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|mips_receive_header
argument_list|(
name|hdr
argument_list|,
operator|&
name|garbage
argument_list|,
name|ch
argument_list|,
name|timeout
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|throw_error
condition|)
name|mips_error
argument_list|(
literal|"Timed out waiting for remote packet"
argument_list|)
expr_stmt|;
else|else
return|return
operator|-
literal|1
return|;
block|}
name|ch
operator|=
literal|0
expr_stmt|;
comment|/* An acknowledgement is probably a duplicate; ignore it.  */
if|if
condition|(
operator|!
name|HDR_IS_DATA
argument_list|(
name|hdr
argument_list|)
condition|)
block|{
name|len
operator|=
name|HDR_GET_LEN
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
comment|/* Check if the length is valid for an ACK, we may aswell              try and read the remainder of the packet: */
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
comment|/* Ignore the error condition, since we are going to                  ignore the packet anyway. */
operator|(
name|void
operator|)
name|mips_receive_trailer
argument_list|(
name|trlr
argument_list|,
operator|&
name|garbage
argument_list|,
operator|&
name|ch
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
comment|/* Don't use _filtered; we can't deal with a QUIT out of 	     target_wait, and I think this might be called from there.  */
if|if
condition|(
name|remote_debug
operator|>
literal|0
condition|)
name|printf_unfiltered
argument_list|(
literal|"Ignoring unexpected ACK\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|len
operator|=
name|HDR_GET_LEN
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|int
name|rch
decl_stmt|;
name|rch
operator|=
name|mips_readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|rch
operator|==
name|SYN
condition|)
block|{
name|ch
operator|=
name|SYN
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rch
operator|==
name|SERIAL_TIMEOUT
condition|)
block|{
if|if
condition|(
name|throw_error
condition|)
name|mips_error
argument_list|(
literal|"Timed out waiting for remote packet"
argument_list|)
expr_stmt|;
else|else
return|return
operator|-
literal|1
return|;
block|}
name|buff
index|[
name|i
index|]
operator|=
name|rch
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|len
condition|)
block|{
comment|/* Don't use _filtered; we can't deal with a QUIT out of 	     target_wait, and I think this might be called from there.  */
if|if
condition|(
name|remote_debug
operator|>
literal|0
condition|)
name|printf_unfiltered
argument_list|(
literal|"Got new SYN after %d chars (wanted %d)\n"
argument_list|,
name|i
argument_list|,
name|len
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|err
operator|=
name|mips_receive_trailer
argument_list|(
name|trlr
argument_list|,
operator|&
name|garbage
argument_list|,
operator|&
name|ch
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|throw_error
condition|)
name|mips_error
argument_list|(
literal|"Timed out waiting for packet"
argument_list|)
expr_stmt|;
else|else
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|err
operator|==
operator|-
literal|2
condition|)
block|{
comment|/* Don't use _filtered; we can't deal with a QUIT out of 	     target_wait, and I think this might be called from there.  */
if|if
condition|(
name|remote_debug
operator|>
literal|0
condition|)
name|printf_unfiltered
argument_list|(
literal|"Got SYN when wanted trailer\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If this is the wrong sequence number, ignore it.  */
if|if
condition|(
name|HDR_GET_SEQ
argument_list|(
name|hdr
argument_list|)
operator|!=
name|mips_receive_seq
condition|)
block|{
comment|/* Don't use _filtered; we can't deal with a QUIT out of 	     target_wait, and I think this might be called from there.  */
if|if
condition|(
name|remote_debug
operator|>
literal|0
condition|)
name|printf_unfiltered
argument_list|(
literal|"Ignoring sequence number %d (want %d)\n"
argument_list|,
name|HDR_GET_SEQ
argument_list|(
name|hdr
argument_list|)
argument_list|,
name|mips_receive_seq
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|mips_cksum
argument_list|(
name|hdr
argument_list|,
name|buff
argument_list|,
name|len
argument_list|)
operator|==
name|TRLR_GET_CKSUM
argument_list|(
name|trlr
argument_list|)
condition|)
break|break;
if|if
condition|(
name|remote_debug
operator|>
literal|0
condition|)
comment|/* Don't use _filtered; we can't deal with a QUIT out of 	   target_wait, and I think this might be called from there.  */
name|printf_unfiltered
argument_list|(
literal|"Bad checksum; data %d, trailer %d\n"
argument_list|,
name|mips_cksum
argument_list|(
name|hdr
argument_list|,
name|buff
argument_list|,
name|len
argument_list|)
argument_list|,
name|TRLR_GET_CKSUM
argument_list|(
name|trlr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The checksum failed.  Send an acknowledgement for the 	 previous packet to tell the remote to resend the packet.  */
name|ack
index|[
name|HDR_INDX_SYN
index|]
operator|=
name|HDR_SET_SYN
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|mips_receive_seq
argument_list|)
expr_stmt|;
name|ack
index|[
name|HDR_INDX_TYPE_LEN
index|]
operator|=
name|HDR_SET_TYPE_LEN
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|mips_receive_seq
argument_list|)
expr_stmt|;
name|ack
index|[
name|HDR_INDX_LEN1
index|]
operator|=
name|HDR_SET_LEN1
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|mips_receive_seq
argument_list|)
expr_stmt|;
name|ack
index|[
name|HDR_INDX_SEQ
index|]
operator|=
name|HDR_SET_SEQ
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|mips_receive_seq
argument_list|)
expr_stmt|;
name|cksum
operator|=
name|mips_cksum
argument_list|(
name|ack
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ack
index|[
name|HDR_LENGTH
operator|+
name|TRLR_INDX_CSUM1
index|]
operator|=
name|TRLR_SET_CSUM1
argument_list|(
name|cksum
argument_list|)
expr_stmt|;
name|ack
index|[
name|HDR_LENGTH
operator|+
name|TRLR_INDX_CSUM2
index|]
operator|=
name|TRLR_SET_CSUM2
argument_list|(
name|cksum
argument_list|)
expr_stmt|;
name|ack
index|[
name|HDR_LENGTH
operator|+
name|TRLR_INDX_CSUM3
index|]
operator|=
name|TRLR_SET_CSUM3
argument_list|(
name|cksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_debug
operator|>
literal|0
condition|)
block|{
name|ack
index|[
name|HDR_LENGTH
operator|+
name|TRLR_LENGTH
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Don't use _filtered; we can't deal with a QUIT out of 	     target_wait, and I think this might be called from there.  */
name|printf_unfiltered
argument_list|(
literal|"Writing ack %d \"%s\"\n"
argument_list|,
name|mips_receive_seq
argument_list|,
name|ack
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SERIAL_WRITE
argument_list|(
name|mips_desc
argument_list|,
name|ack
argument_list|,
name|HDR_LENGTH
operator|+
name|TRLR_LENGTH
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|throw_error
condition|)
name|mips_error
argument_list|(
literal|"write to target failed: %s"
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
operator|-
literal|1
return|;
block|}
block|}
if|if
condition|(
name|remote_debug
operator|>
literal|0
condition|)
block|{
name|buff
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Don't use _filtered; we can't deal with a QUIT out of 	 target_wait, and I think this might be called from there.  */
name|printf_unfiltered
argument_list|(
literal|"Got packet \"%s\"\n"
argument_list|,
name|buff
argument_list|)
expr_stmt|;
block|}
comment|/* We got the packet.  Send an acknowledgement.  */
name|mips_receive_seq
operator|=
operator|(
name|mips_receive_seq
operator|+
literal|1
operator|)
operator|%
name|SEQ_MODULOS
expr_stmt|;
name|ack
index|[
name|HDR_INDX_SYN
index|]
operator|=
name|HDR_SET_SYN
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|mips_receive_seq
argument_list|)
expr_stmt|;
name|ack
index|[
name|HDR_INDX_TYPE_LEN
index|]
operator|=
name|HDR_SET_TYPE_LEN
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|mips_receive_seq
argument_list|)
expr_stmt|;
name|ack
index|[
name|HDR_INDX_LEN1
index|]
operator|=
name|HDR_SET_LEN1
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|mips_receive_seq
argument_list|)
expr_stmt|;
name|ack
index|[
name|HDR_INDX_SEQ
index|]
operator|=
name|HDR_SET_SEQ
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|mips_receive_seq
argument_list|)
expr_stmt|;
name|cksum
operator|=
name|mips_cksum
argument_list|(
name|ack
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ack
index|[
name|HDR_LENGTH
operator|+
name|TRLR_INDX_CSUM1
index|]
operator|=
name|TRLR_SET_CSUM1
argument_list|(
name|cksum
argument_list|)
expr_stmt|;
name|ack
index|[
name|HDR_LENGTH
operator|+
name|TRLR_INDX_CSUM2
index|]
operator|=
name|TRLR_SET_CSUM2
argument_list|(
name|cksum
argument_list|)
expr_stmt|;
name|ack
index|[
name|HDR_LENGTH
operator|+
name|TRLR_INDX_CSUM3
index|]
operator|=
name|TRLR_SET_CSUM3
argument_list|(
name|cksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_debug
operator|>
literal|0
condition|)
block|{
name|ack
index|[
name|HDR_LENGTH
operator|+
name|TRLR_LENGTH
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Don't use _filtered; we can't deal with a QUIT out of 	 target_wait, and I think this might be called from there.  */
name|printf_unfiltered
argument_list|(
literal|"Writing ack %d \"%s\"\n"
argument_list|,
name|mips_receive_seq
argument_list|,
name|ack
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SERIAL_WRITE
argument_list|(
name|mips_desc
argument_list|,
name|ack
argument_list|,
name|HDR_LENGTH
operator|+
name|TRLR_LENGTH
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|throw_error
condition|)
name|mips_error
argument_list|(
literal|"write to target failed: %s"
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
operator|-
literal|1
return|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Optionally send a request to the remote system and optionally wait    for the reply.  This implements the remote debugging protocol,    which is built on top of the packet protocol defined above.  Each    request has an ADDR argument and a DATA argument.  The following    requests are defined:     \0	don't send a request; just wait for a reply    i	read word from instruction space at ADDR    d	read word from data space at ADDR    I	write DATA to instruction space at ADDR    D	write DATA to data space at ADDR    r	read register number ADDR    R	set register number ADDR to value DATA    c	continue execution (if ADDR != 1, set pc to ADDR)    s	single step (if ADDR != 1, set pc to ADDR)     The read requests return the value requested.  The write requests    return the previous value in the changed location.  The execution    requests return a UNIX wait value (the approximate signal which    caused execution to stop is in the upper eight bits).     If PERR is not NULL, this function waits for a reply.  If an error    occurs, it sets *PERR to 1 and sets errno according to what the    target board reports.  */
end_comment

begin_function
specifier|static
name|int
name|mips_request
parameter_list|(
name|cmd
parameter_list|,
name|addr
parameter_list|,
name|data
parameter_list|,
name|perr
parameter_list|,
name|timeout
parameter_list|,
name|buff
parameter_list|)
name|int
name|cmd
decl_stmt|;
name|unsigned
name|int
name|addr
decl_stmt|;
name|unsigned
name|int
name|data
decl_stmt|;
name|int
modifier|*
name|perr
decl_stmt|;
name|int
name|timeout
decl_stmt|;
name|char
modifier|*
name|buff
decl_stmt|;
block|{
name|char
name|myBuff
index|[
name|DATA_MAXLEN
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|rpid
decl_stmt|;
name|char
name|rcmd
decl_stmt|;
name|int
name|rerrflg
decl_stmt|;
name|int
name|rresponse
decl_stmt|;
if|if
condition|(
name|buff
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|buff
operator|=
name|myBuff
expr_stmt|;
if|if
condition|(
name|cmd
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|mips_need_reply
condition|)
name|fatal
argument_list|(
literal|"mips_request: Trying to send command before reply"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"0x0 %c 0x%x 0x%x"
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|mips_send_packet
argument_list|(
name|buff
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mips_need_reply
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|perr
operator|==
operator|(
name|int
operator|*
operator|)
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|mips_need_reply
condition|)
name|fatal
argument_list|(
literal|"mips_request: Trying to get reply before command"
argument_list|)
expr_stmt|;
name|mips_need_reply
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|mips_receive_packet
argument_list|(
name|buff
argument_list|,
literal|1
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|buff
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|buff
argument_list|,
literal|"0x%x %c 0x%x 0x%x"
argument_list|,
operator|&
name|rpid
argument_list|,
operator|&
name|rcmd
argument_list|,
operator|&
name|rerrflg
argument_list|,
operator|&
name|rresponse
argument_list|)
operator|!=
literal|4
operator|||
operator|(
name|cmd
operator|!=
literal|'\0'
operator|&&
name|rcmd
operator|!=
name|cmd
operator|)
condition|)
name|mips_error
argument_list|(
literal|"Bad response from remote board"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rerrflg
operator|!=
literal|0
condition|)
block|{
operator|*
name|perr
operator|=
literal|1
expr_stmt|;
comment|/* FIXME: This will returns MIPS errno numbers, which may or may 	 not be the same as errno values used on other systems.  If 	 they stick to common errno values, they will be the same, but 	 if they don't, they must be translated.  */
name|errno
operator|=
name|rresponse
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|perr
operator|=
literal|0
expr_stmt|;
return|return
name|rresponse
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mips_initialize_cleanups
parameter_list|(
name|arg
parameter_list|)
name|PTR
name|arg
decl_stmt|;
block|{
name|mips_initializing
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mips_send_command
parameter_list|(
name|cmd
parameter_list|,
name|prompt
parameter_list|)
specifier|const
name|char
modifier|*
name|cmd
decl_stmt|;
name|int
name|prompt
decl_stmt|;
block|{
name|SERIAL_WRITE
argument_list|(
name|mips_desc
argument_list|,
name|cmd
argument_list|,
name|strlen
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|mips_expect
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|mips_expect
argument_list|(
literal|"\012"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prompt
condition|)
name|mips_expect
argument_list|(
name|mips_monitor_prompt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Enter remote (dbx) debug mode: */
end_comment

begin_function
specifier|static
name|void
name|mips_enter_debug
parameter_list|()
block|{
comment|/* Reset the sequence numbers, ready for the new debug sequence: */
name|mips_send_seq
operator|=
literal|0
expr_stmt|;
name|mips_receive_seq
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mips_monitor
operator|==
name|MON_PMON
condition|)
name|mips_send_command
argument_list|(
literal|"debug\015"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
comment|/* assume IDT monitor by default */
name|mips_send_command
argument_list|(
literal|"db tty0\015"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SERIAL_WRITE
argument_list|(
name|mips_desc
argument_list|,
literal|"\015"
argument_list|,
sizeof|sizeof
expr|"\015"
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* We don't need to absorb any spurious characters here, since the      mips_receive_header will eat up a reasonable number of characters      whilst looking for the SYN, however this avoids the "garbage"      being displayed to the user. */
if|if
condition|(
name|mips_monitor
operator|==
name|MON_PMON
condition|)
name|mips_expect
argument_list|(
literal|"\015"
argument_list|)
expr_stmt|;
block|{
name|char
name|buff
index|[
name|DATA_MAXLEN
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|mips_receive_packet
argument_list|(
name|buff
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|)
operator|<
literal|0
condition|)
name|mips_error
argument_list|(
literal|"Failed to initialize (didn't receive packet)."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Exit remote (dbx) debug mode, returning to the monitor prompt: */
end_comment

begin_function
specifier|static
name|int
name|mips_exit_debug
parameter_list|()
block|{
name|int
name|err
decl_stmt|;
name|mips_request
argument_list|(
literal|'x'
argument_list|,
operator|(
name|unsigned
name|int
operator|)
literal|0
argument_list|,
operator|(
name|unsigned
name|int
operator|)
literal|0
argument_list|,
operator|&
name|err
argument_list|,
name|mips_receive_wait
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_monitor
operator|==
name|MON_PMON
operator|&&
operator|!
name|mips_expect
argument_list|(
literal|"Exiting remote debug mode"
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|mips_expect
argument_list|(
literal|"\015\012"
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|mips_expect
argument_list|(
name|mips_monitor_prompt
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Initialize a new connection to the MIPS board, and make sure we are    really connected.  */
end_comment

begin_function
specifier|static
name|void
name|mips_initialize
parameter_list|()
block|{
name|int
name|err
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_cleanups
init|=
name|make_cleanup
argument_list|(
name|mips_initialize_cleanups
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* What is this code doing here?  I don't see any way it can happen, and      it might mean mips_initializing didn't get cleared properly.      So I'll make it a warning.  */
if|if
condition|(
name|mips_initializing
condition|)
block|{
name|warning
argument_list|(
literal|"internal error: mips_initialize called twice"
argument_list|)
expr_stmt|;
return|return;
block|}
name|mips_wait_flag
operator|=
literal|0
expr_stmt|;
name|mips_initializing
operator|=
literal|1
expr_stmt|;
comment|/* At this point, the packit protocol isn't responding.  We'll try getting      into the monitor, and restarting the protocol.  */
comment|/* Force the system into the monitor.  After this we *should* be at      the mips_monitor_prompt.  */
if|if
condition|(
name|mips_monitor
operator|==
name|MON_PMON
condition|)
name|j
operator|=
literal|0
expr_stmt|;
comment|/* start by checking if we are already at the prompt */
else|else
name|j
operator|=
literal|1
expr_stmt|;
comment|/* start by sending a break */
for|for
control|(
init|;
name|j
operator|<=
literal|4
condition|;
name|j
operator|++
control|)
block|{
switch|switch
condition|(
name|j
condition|)
block|{
case|case
literal|0
case|:
comment|/* First, try sending a CR */
name|SERIAL_FLUSH_INPUT
argument_list|(
name|mips_desc
argument_list|)
expr_stmt|;
name|SERIAL_WRITE
argument_list|(
name|mips_desc
argument_list|,
literal|"\015"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* First, try sending a break */
name|SERIAL_SEND_BREAK
argument_list|(
name|mips_desc
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Then, try a ^C */
name|SERIAL_WRITE
argument_list|(
name|mips_desc
argument_list|,
literal|"\003"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* Then, try escaping from download */
block|{
if|if
condition|(
name|mips_monitor
operator|==
name|MON_PMON
condition|)
block|{
name|char
name|tbuff
index|[
literal|7
index|]
decl_stmt|;
comment|/* We shouldn't need to send multiple termination                    sequences, since the target performs line (or                    block) reads, and then processes those                    packets. In-case we were downloading a large packet                    we flush the output buffer before inserting a                    termination sequence. */
name|SERIAL_FLUSH_OUTPUT
argument_list|(
name|mips_desc
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tbuff
argument_list|,
literal|"\015/E/E\015"
argument_list|)
expr_stmt|;
name|SERIAL_WRITE
argument_list|(
name|mips_desc
argument_list|,
name|tbuff
argument_list|,
literal|6
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|srec
index|[
literal|10
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* We are possibly in binary download mode, having                    aborted in the middle of an S-record.  ^C won't                    work because of binary mode.  The only reliable way                    out is to send enough termination packets (8 bytes)                    to fill up and then overflow the largest size                    S-record (255 bytes in this case).  This amounts to                    256/8 + 1 packets.                    */
name|mips_make_srec
argument_list|(
name|srec
argument_list|,
literal|'7'
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|33
condition|;
name|i
operator|++
control|)
block|{
name|SERIAL_WRITE
argument_list|(
name|mips_desc
argument_list|,
name|srec
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|SERIAL_READCHAR
argument_list|(
name|mips_desc
argument_list|,
literal|0
argument_list|)
operator|>=
literal|0
condition|)
break|break;
comment|/* Break immediatly if we get something from 				   the board. */
block|}
block|}
block|}
break|break;
case|case
literal|4
case|:
name|mips_error
argument_list|(
literal|"Failed to initialize."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mips_expect
argument_list|(
name|mips_monitor_prompt
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|mips_monitor
operator|==
name|MON_PMON
condition|)
block|{
comment|/* Ensure the correct target state: */
name|mips_send_command
argument_list|(
literal|"set regsize 64\015"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mips_send_command
argument_list|(
literal|"set hostport tty0\015"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mips_send_command
argument_list|(
literal|"set brkcmd \"\"\015"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Delete all the current breakpoints: */
name|mips_send_command
argument_list|(
literal|"db *\015"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTE: PMON does not have breakpoint support through the          "debug" mode, only at the monitor command-line. */
block|}
name|mips_enter_debug
argument_list|()
expr_stmt|;
comment|/* Clear all breakpoints: */
if|if
condition|(
name|common_breakpoint
argument_list|(
literal|'b'
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
name|monitor_supports_breakpoints
operator|=
literal|0
expr_stmt|;
else|else
name|monitor_supports_breakpoints
operator|=
literal|1
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
comment|/* If this doesn't call error, we have connected; we don't care if      the request itself succeeds or fails.  */
name|mips_request
argument_list|(
literal|'r'
argument_list|,
operator|(
name|unsigned
name|int
operator|)
literal|0
argument_list|,
operator|(
name|unsigned
name|int
operator|)
literal|0
argument_list|,
operator|&
name|err
argument_list|,
name|mips_receive_wait
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
name|read_fp
argument_list|()
argument_list|,
name|read_pc
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Open a connection to the remote board.  */
end_comment

begin_function
specifier|static
name|void
name|common_open
parameter_list|(
name|ops
parameter_list|,
name|name
parameter_list|,
name|from_tty
parameter_list|)
name|struct
name|target_ops
modifier|*
name|ops
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
name|ptype
decl_stmt|;
if|if
condition|(
name|name
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"To open a MIPS remote debugging connection, you need to specify what serial\n\ device is attached to the target board (e.g., /dev/ttya)."
argument_list|)
expr_stmt|;
name|target_preopen
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_is_open
condition|)
name|unpush_target
argument_list|(
name|current_ops
argument_list|)
expr_stmt|;
name|mips_desc
operator|=
name|SERIAL_OPEN
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_desc
operator|==
operator|(
name|serial_t
operator|)
name|NULL
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|baud_rate
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|SERIAL_SETBAUDRATE
argument_list|(
name|mips_desc
argument_list|,
name|baud_rate
argument_list|)
condition|)
block|{
name|SERIAL_CLOSE
argument_list|(
name|mips_desc
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|SERIAL_RAW
argument_list|(
name|mips_desc
argument_list|)
expr_stmt|;
name|current_ops
operator|=
name|ops
expr_stmt|;
name|mips_is_open
operator|=
literal|1
expr_stmt|;
name|mips_initialize
argument_list|()
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf_unfiltered
argument_list|(
literal|"Remote MIPS debugging using %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Switch to using remote target now.  */
name|push_target
argument_list|(
name|ops
argument_list|)
expr_stmt|;
comment|/* FIXME: Should we call start_remote here?  */
comment|/* Try to figure out the processor model if possible.  */
name|ptype
operator|=
name|mips_read_processor_type
argument_list|()
expr_stmt|;
if|if
condition|(
name|ptype
condition|)
name|mips_set_processor_type_command
argument_list|(
name|strsave
argument_list|(
name|ptype
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* This is really the job of start_remote however, that makes an assumption    that the target is about to print out a status message of some sort.  That    doesn't happen here (in fact, it may not be possible to get the monitor to    send the appropriate packet).  */
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|registers_changed
argument_list|()
expr_stmt|;
name|stop_pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
name|set_current_frame
argument_list|(
name|create_new_frame
argument_list|(
name|read_fp
argument_list|()
argument_list|,
name|stop_pc
argument_list|)
argument_list|)
expr_stmt|;
name|select_frame
argument_list|(
name|get_current_frame
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|print_stack_frame
argument_list|(
name|selected_frame
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mips_open
parameter_list|(
name|name
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|mips_monitor
operator|=
name|MON_IDT
expr_stmt|;
name|common_open
argument_list|(
operator|&
name|mips_ops
argument_list|,
name|name
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmon_open
parameter_list|(
name|name
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
comment|/* The PMON monitor has a prompt different from the default      "TARGET_MONITOR_PROMPT": */
name|mips_monitor_prompt
operator|=
literal|"PMON> "
expr_stmt|;
name|mips_monitor
operator|=
name|MON_PMON
expr_stmt|;
name|common_open
argument_list|(
operator|&
name|pmon_ops
argument_list|,
name|name
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Close a connection to the remote board.  */
end_comment

begin_function
specifier|static
name|void
name|mips_close
parameter_list|(
name|quitting
parameter_list|)
name|int
name|quitting
decl_stmt|;
block|{
if|if
condition|(
name|mips_is_open
condition|)
block|{
name|int
name|err
decl_stmt|;
name|mips_is_open
operator|=
literal|0
expr_stmt|;
comment|/* Get the board out of remote debugging mode.  */
operator|(
name|void
operator|)
name|mips_exit_debug
argument_list|()
expr_stmt|;
name|SERIAL_CLOSE
argument_list|(
name|mips_desc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Detach from the remote board.  */
end_comment

begin_function
specifier|static
name|void
name|mips_detach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|args
condition|)
name|error
argument_list|(
literal|"Argument given to \"detach\" when remotely debugging."
argument_list|)
expr_stmt|;
name|pop_target
argument_list|()
expr_stmt|;
name|mips_close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf_unfiltered
argument_list|(
literal|"Ending remote MIPS debugging.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Tell the target board to resume.  This does not wait for a reply    from the board.  */
end_comment

begin_function
specifier|static
name|void
name|mips_resume
parameter_list|(
name|pid
parameter_list|,
name|step
parameter_list|,
name|siggnal
parameter_list|)
name|int
name|pid
decl_stmt|,
name|step
decl_stmt|;
name|enum
name|target_signal
name|siggnal
decl_stmt|;
block|{
name|mips_request
argument_list|(
name|step
condition|?
literal|'s'
else|:
literal|'c'
argument_list|,
operator|(
name|unsigned
name|int
operator|)
literal|1
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|siggnal
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
name|mips_receive_wait
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the signal corresponding to SIG, where SIG is the number which    the MIPS protocol uses for the signal.  */
end_comment

begin_function
name|enum
name|target_signal
name|mips_signal_from_protocol
parameter_list|(
name|sig
parameter_list|)
name|int
name|sig
decl_stmt|;
block|{
comment|/* We allow a few more signals than the IDT board actually returns, on      the theory that there is at least *some* hope that perhaps the numbering      for these signals is widely agreed upon.  */
if|if
condition|(
name|sig
operator|<=
literal|0
operator|||
name|sig
operator|>
literal|31
condition|)
return|return
name|TARGET_SIGNAL_UNKNOWN
return|;
comment|/* Don't want to use target_signal_from_host because we are converting      from MIPS signal numbers, not host ones.  Our internal numbers      match the MIPS numbers for the signals the board can return, which      are: SIGINT, SIGSEGV, SIGBUS, SIGILL, SIGFPE, SIGTRAP.  */
return|return
operator|(
expr|enum
name|target_signal
operator|)
name|sig
return|;
block|}
end_function

begin_comment
comment|/* Wait until the remote stops, and return a wait status.  */
end_comment

begin_function
specifier|static
name|int
name|mips_wait
parameter_list|(
name|pid
parameter_list|,
name|status
parameter_list|)
name|int
name|pid
decl_stmt|;
name|struct
name|target_waitstatus
modifier|*
name|status
decl_stmt|;
block|{
name|int
name|rstatus
decl_stmt|;
name|int
name|err
decl_stmt|;
name|char
name|buff
index|[
name|DATA_MAXLEN
index|]
decl_stmt|;
name|int
name|rpc
decl_stmt|,
name|rfp
decl_stmt|,
name|rsp
decl_stmt|;
name|char
name|flags
index|[
literal|20
index|]
decl_stmt|;
name|int
name|nfields
decl_stmt|;
name|interrupt_count
operator|=
literal|0
expr_stmt|;
name|hit_watchpoint
operator|=
literal|0
expr_stmt|;
comment|/* If we have not sent a single step or continue command, then the      board is waiting for us to do something.  Return a status      indicating that it is stopped.  */
if|if
condition|(
operator|!
name|mips_need_reply
condition|)
block|{
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* No timeout; we sit here as long as the program continues to execute.  */
name|mips_wait_flag
operator|=
literal|1
expr_stmt|;
name|rstatus
operator|=
name|mips_request
argument_list|(
literal|'\000'
argument_list|,
operator|(
name|unsigned
name|int
operator|)
literal|0
argument_list|,
operator|(
name|unsigned
name|int
operator|)
literal|0
argument_list|,
operator|&
name|err
argument_list|,
operator|-
literal|1
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|mips_wait_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mips_error
argument_list|(
literal|"Remote failure: %s"
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|nfields
operator|=
name|sscanf
argument_list|(
name|buff
argument_list|,
literal|"0x%*x %*c 0x%*x 0x%*x 0x%x 0x%x 0x%x 0x%*x %s"
argument_list|,
operator|&
name|rpc
argument_list|,
operator|&
name|rfp
argument_list|,
operator|&
name|rsp
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* See if we got back extended status.  If so, pick out the pc, fp, sp, etc... */
if|if
condition|(
name|nfields
operator|==
literal|7
operator|||
name|nfields
operator|==
literal|9
condition|)
block|{
name|char
name|buf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|PC_REGNUM
argument_list|)
argument_list|,
name|rpc
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|PC_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|PC_REGNUM
argument_list|)
argument_list|,
name|rfp
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
literal|30
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* This register they are avoiding and so it is unnamed */
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|SP_REGNUM
argument_list|)
argument_list|,
name|rsp
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|FP_REGNUM
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|FP_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfields
operator|==
literal|9
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|2
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|flags
index|[
name|i
index|]
operator|==
literal|'r'
operator|||
name|flags
index|[
name|i
index|]
operator|==
literal|'w'
condition|)
name|hit_watchpoint
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
index|[
name|i
index|]
operator|==
literal|'\000'
condition|)
break|break;
block|}
block|}
comment|/* Translate a MIPS waitstatus.  We use constants here rather than WTERMSIG      and so on, because the constants we want here are determined by the      MIPS protocol and have nothing to do with what host we are running on.  */
if|if
condition|(
operator|(
name|rstatus
operator|&
literal|0377
operator|)
operator|==
literal|0
condition|)
block|{
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|integer
operator|=
operator|(
operator|(
operator|(
name|rstatus
operator|)
operator|>>
literal|8
operator|)
operator|&
literal|0377
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|rstatus
operator|&
literal|0377
operator|)
operator|==
literal|0177
condition|)
block|{
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|mips_signal_from_protocol
argument_list|(
operator|(
operator|(
name|rstatus
operator|)
operator|>>
literal|8
operator|)
operator|&
literal|0377
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_SIGNALLED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|mips_signal_from_protocol
argument_list|(
name|rstatus
operator|&
literal|0177
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pmon_wait
parameter_list|(
name|pid
parameter_list|,
name|status
parameter_list|)
name|int
name|pid
decl_stmt|;
name|struct
name|target_waitstatus
modifier|*
name|status
decl_stmt|;
block|{
name|int
name|rstatus
decl_stmt|;
name|int
name|err
decl_stmt|;
name|char
name|buff
index|[
name|DATA_MAXLEN
index|]
decl_stmt|;
name|interrupt_count
operator|=
literal|0
expr_stmt|;
name|hit_watchpoint
operator|=
literal|0
expr_stmt|;
comment|/* If we have not sent a single step or continue command, then the      board is waiting for us to do something.  Return a status      indicating that it is stopped.  */
if|if
condition|(
operator|!
name|mips_need_reply
condition|)
block|{
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Sit, polling the serial until the target decides to talk to      us. NOTE: the timeout value we use is used not just for the      first character, but for all the characters. */
name|mips_wait_flag
operator|=
literal|1
expr_stmt|;
name|rstatus
operator|=
name|mips_request
argument_list|(
literal|'\000'
argument_list|,
operator|(
name|unsigned
name|int
operator|)
literal|0
argument_list|,
operator|(
name|unsigned
name|int
operator|)
literal|0
argument_list|,
operator|&
name|err
argument_list|,
operator|-
literal|1
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|mips_wait_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mips_error
argument_list|(
literal|"Remote failure: %s"
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTE: The following (sig) numbers are defined by PMON:      	SPP_SIGTRAP     5       breakpoint         SPP_SIGINT      2         SPP_SIGSEGV     11         SPP_SIGBUS      10         SPP_SIGILL      4         SPP_SIGFPE      8         SPP_SIGTERM     15 */
comment|/* On returning from a continue, the PMON monitor seems to start      echoing back the messages we send prior to sending back the      ACK. The code can cope with this, but to try and avoid the      unnecessary serial traffic, and "spurious" characters displayed      to the user, we cheat and reset the debug protocol. The problems      seems to be caused by a check on the number of arguments, and the      command length, within the monitor causing it to echo the command      as a bad packet. */
name|mips_exit_debug
argument_list|()
expr_stmt|;
name|mips_enter_debug
argument_list|()
expr_stmt|;
comment|/* Translate a MIPS waitstatus.  We use constants here rather than WTERMSIG      and so on, because the constants we want here are determined by the      MIPS protocol and have nothing to do with what host we are running on.  */
if|if
condition|(
operator|(
name|rstatus
operator|&
literal|0377
operator|)
operator|==
literal|0
condition|)
block|{
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|integer
operator|=
operator|(
operator|(
operator|(
name|rstatus
operator|)
operator|>>
literal|8
operator|)
operator|&
literal|0377
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|rstatus
operator|&
literal|0377
operator|)
operator|==
literal|0177
condition|)
block|{
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|mips_signal_from_protocol
argument_list|(
operator|(
operator|(
name|rstatus
operator|)
operator|>>
literal|8
operator|)
operator|&
literal|0377
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_SIGNALLED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|mips_signal_from_protocol
argument_list|(
name|rstatus
operator|&
literal|0177
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* We have to map between the register numbers used by gdb and the    register numbers used by the debugging protocol.  This function    assumes that we are using tm-mips.h.  */
end_comment

begin_define
define|#
directive|define
name|REGNO_OFFSET
value|96
end_define

begin_function
specifier|static
name|int
name|mips_map_regno
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
if|if
condition|(
name|regno
operator|<
literal|32
condition|)
return|return
name|regno
return|;
if|if
condition|(
name|regno
operator|>=
name|FP0_REGNUM
operator|&&
name|regno
operator|<
name|FP0_REGNUM
operator|+
literal|32
condition|)
return|return
name|regno
operator|-
name|FP0_REGNUM
operator|+
literal|32
return|;
switch|switch
condition|(
name|regno
condition|)
block|{
case|case
name|PC_REGNUM
case|:
return|return
name|REGNO_OFFSET
operator|+
literal|0
return|;
case|case
name|CAUSE_REGNUM
case|:
return|return
name|REGNO_OFFSET
operator|+
literal|1
return|;
case|case
name|HI_REGNUM
case|:
return|return
name|REGNO_OFFSET
operator|+
literal|2
return|;
case|case
name|LO_REGNUM
case|:
return|return
name|REGNO_OFFSET
operator|+
literal|3
return|;
case|case
name|FCRCS_REGNUM
case|:
return|return
name|REGNO_OFFSET
operator|+
literal|4
return|;
case|case
name|FCRIR_REGNUM
case|:
return|return
name|REGNO_OFFSET
operator|+
literal|5
return|;
default|default:
comment|/* FIXME: Is there a way to get the status register?  */
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Fetch the remote registers.  */
end_comment

begin_function
specifier|static
name|void
name|mips_fetch_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|unsigned
name|LONGEST
name|val
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
name|mips_fetch_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|regno
operator|==
name|FP_REGNUM
operator|||
name|regno
operator|==
name|ZERO_REGNUM
condition|)
comment|/* FP_REGNUM on the mips is a hack which is just supposed to read        zero (see also mips-nat.c).  */
name|val
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|#
directive|if
literal|0
comment|/* Unfortunately the PMON version in the Vr4300 board has been          compiled without the 64bit register access commands. This          means we cannot get hold of the full register width. */
block|if (mips_monitor == MON_PMON)         val = mips_request ('t', (unsigned int) mips_map_regno (regno),                             (unsigned int) 0,&err, mips_receive_wait, NULL);       else
endif|#
directive|endif
name|val
operator|=
name|mips_request
argument_list|(
literal|'r'
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|mips_map_regno
argument_list|(
name|regno
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
literal|0
argument_list|,
operator|&
name|err
argument_list|,
name|mips_receive_wait
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mips_error
argument_list|(
literal|"Can't read register %d: %s"
argument_list|,
name|regno
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|{
name|char
name|buf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
comment|/* We got the number the register holds, but gdb expects to see a        value in the target byte ordering.  */
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Prepare to store registers.  The MIPS protocol can store individual    registers, so this function doesn't have to do anything.  */
end_comment

begin_function
specifier|static
name|void
name|mips_prepare_to_store
parameter_list|()
block|{ }
end_function

begin_comment
comment|/* Store remote register(s).  */
end_comment

begin_function
specifier|static
name|void
name|mips_store_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|int
name|err
decl_stmt|;
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
name|mips_store_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
return|return;
block|}
name|mips_request
argument_list|(
literal|'R'
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|mips_map_regno
argument_list|(
name|regno
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|,
operator|&
name|err
argument_list|,
name|mips_receive_wait
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mips_error
argument_list|(
literal|"Can't write register %d: %s"
argument_list|,
name|regno
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fetch a word from the target board.  */
end_comment

begin_function
specifier|static
name|int
name|mips_fetch_word
parameter_list|(
name|addr
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
name|int
name|err
decl_stmt|;
name|val
operator|=
name|mips_request
argument_list|(
literal|'d'
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|addr
argument_list|,
operator|(
name|unsigned
name|int
operator|)
literal|0
argument_list|,
operator|&
name|err
argument_list|,
name|mips_receive_wait
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* Data space failed; try instruction space.  */
name|val
operator|=
name|mips_request
argument_list|(
literal|'i'
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|addr
argument_list|,
operator|(
name|unsigned
name|int
operator|)
literal|0
argument_list|,
operator|&
name|err
argument_list|,
name|mips_receive_wait
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mips_error
argument_list|(
literal|"Can't read address 0x%x: %s"
argument_list|,
name|addr
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Store a word to the target board.  Returns errno code or zero for    success.  If OLD_CONTENTS is non-NULL, put the old contents of that    memory location there.  */
end_comment

begin_function
specifier|static
name|int
name|mips_store_word
parameter_list|(
name|addr
parameter_list|,
name|val
parameter_list|,
name|old_contents
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|val
decl_stmt|;
name|char
modifier|*
name|old_contents
decl_stmt|;
block|{
name|int
name|err
decl_stmt|;
name|unsigned
name|int
name|oldcontents
decl_stmt|;
name|oldcontents
operator|=
name|mips_request
argument_list|(
literal|'D'
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|addr
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|val
argument_list|,
operator|&
name|err
argument_list|,
name|mips_receive_wait
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* Data space failed; try instruction space.  */
name|oldcontents
operator|=
name|mips_request
argument_list|(
literal|'I'
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|addr
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|val
argument_list|,
operator|&
name|err
argument_list|,
name|mips_receive_wait
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|errno
return|;
block|}
if|if
condition|(
name|old_contents
operator|!=
name|NULL
condition|)
name|store_unsigned_integer
argument_list|(
name|old_contents
argument_list|,
literal|4
argument_list|,
name|oldcontents
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Read or write LEN bytes from inferior memory at MEMADDR,    transferring to or from debugger address MYADDR.  Write to inferior    if SHOULD_WRITE is nonzero.  Returns length of data written or    read; 0 for error.  Note that protocol gives us the correct value    for a longword, since it transfers values in ASCII.  We want the    byte values, so we have to swap the longword values.  */
end_comment

begin_function
specifier|static
name|int
name|mips_xfer_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|write
parameter_list|,
name|ignore
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|write
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|ignore
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Round starting address down to longword boundary.  */
specifier|register
name|CORE_ADDR
name|addr
init|=
name|memaddr
operator|&
operator|~
literal|3
decl_stmt|;
comment|/* Round ending address up; get number of longwords that makes.  */
specifier|register
name|int
name|count
init|=
operator|(
operator|(
operator|(
name|memaddr
operator|+
name|len
operator|)
operator|-
name|addr
operator|)
operator|+
literal|3
operator|)
operator|/
literal|4
decl_stmt|;
comment|/* Allocate buffer of that many longwords.  */
specifier|register
name|char
modifier|*
name|buffer
init|=
name|alloca
argument_list|(
name|count
operator|*
literal|4
argument_list|)
decl_stmt|;
name|int
name|status
decl_stmt|;
if|if
condition|(
name|write
condition|)
block|{
comment|/* Fill start and end extra bytes of buffer with existing data.  */
if|if
condition|(
name|addr
operator|!=
name|memaddr
operator|||
name|len
operator|<
literal|4
condition|)
block|{
comment|/* Need part of initial word -- fetch it.  */
name|store_unsigned_integer
argument_list|(
operator|&
name|buffer
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|,
name|mips_fetch_word
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|>
literal|1
condition|)
block|{
comment|/* Need part of last word -- fetch it.  FIXME: we do this even 	     if we don't need it.  */
name|store_unsigned_integer
argument_list|(
operator|&
name|buffer
index|[
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
literal|4
index|]
argument_list|,
literal|4
argument_list|,
name|mips_fetch_word
argument_list|(
name|addr
operator|+
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
literal|4
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Copy data to be written over corresponding part of buffer */
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
operator|(
name|memaddr
operator|&
literal|3
operator|)
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Write the entire buffer.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|addr
operator|+=
literal|4
control|)
block|{
name|status
operator|=
name|mips_store_word
argument_list|(
name|addr
argument_list|,
name|extract_unsigned_integer
argument_list|(
operator|&
name|buffer
index|[
name|i
operator|*
literal|4
index|]
argument_list|,
literal|4
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Report each kilobyte (we download 32-bit words at a time) */
if|if
condition|(
name|i
operator|%
literal|256
operator|==
literal|255
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
condition|)
block|{
name|errno
operator|=
name|status
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* FIXME: Do we want a QUIT here?  */
block|}
if|if
condition|(
name|count
operator|>=
literal|256
condition|)
name|printf_unfiltered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Read all the longwords */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|addr
operator|+=
literal|4
control|)
block|{
name|store_unsigned_integer
argument_list|(
operator|&
name|buffer
index|[
name|i
operator|*
literal|4
index|]
argument_list|,
literal|4
argument_list|,
name|mips_fetch_word
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|QUIT
expr_stmt|;
block|}
comment|/* Copy appropriate bytes out of the buffer.  */
name|memcpy
argument_list|(
name|myaddr
argument_list|,
name|buffer
operator|+
operator|(
name|memaddr
operator|&
literal|3
operator|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* Print info on this target.  */
end_comment

begin_function
specifier|static
name|void
name|mips_files_info
parameter_list|(
name|ignore
parameter_list|)
name|struct
name|target_ops
modifier|*
name|ignore
decl_stmt|;
block|{
name|printf_unfiltered
argument_list|(
literal|"Debugging a MIPS board over a serial line.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Kill the process running on the board.  This will actually only    work if we are doing remote debugging over the console input.  I    think that if IDT/sim had the remote debug interrupt enabled on the    right port, we could interrupt the process with a break signal.  */
end_comment

begin_function
specifier|static
name|void
name|mips_kill
parameter_list|()
block|{
if|if
condition|(
operator|!
name|mips_wait_flag
condition|)
return|return;
name|interrupt_count
operator|++
expr_stmt|;
if|if
condition|(
name|interrupt_count
operator|>=
literal|2
condition|)
block|{
name|interrupt_count
operator|=
literal|0
expr_stmt|;
name|target_terminal_ours
argument_list|()
expr_stmt|;
if|if
condition|(
name|query
argument_list|(
literal|"Interrupted while waiting for the program.\n\ Give up (and stop debugging it)? "
argument_list|)
condition|)
block|{
comment|/* Clean up in such a way that mips_close won't try to talk to the 	     board (it almost surely won't work since we weren't able to talk to 	     it).  */
name|mips_wait_flag
operator|=
literal|0
expr_stmt|;
name|mips_is_open
operator|=
literal|0
expr_stmt|;
name|SERIAL_CLOSE
argument_list|(
name|mips_desc
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"Ending remote MIPS debugging.\n"
argument_list|)
expr_stmt|;
name|target_mourn_inferior
argument_list|()
expr_stmt|;
name|return_to_top_level
argument_list|(
name|RETURN_QUIT
argument_list|)
expr_stmt|;
block|}
name|target_terminal_inferior
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|remote_debug
operator|>
literal|0
condition|)
name|printf_unfiltered
argument_list|(
literal|"Sending break\n"
argument_list|)
expr_stmt|;
name|SERIAL_SEND_BREAK
argument_list|(
name|mips_desc
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (mips_is_open)     {       char cc;
comment|/* Send a ^C.  */
block|cc = '\003';       SERIAL_WRITE (mips_desc,&cc, 1);       sleep (1);       target_mourn_inferior ();     }
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Start running on the target board.  */
end_comment

begin_function
specifier|static
name|void
name|mips_create_inferior
parameter_list|(
name|execfile
parameter_list|,
name|args
parameter_list|,
name|env
parameter_list|)
name|char
modifier|*
name|execfile
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
name|char
modifier|*
modifier|*
name|env
decl_stmt|;
block|{
name|CORE_ADDR
name|entry_pt
decl_stmt|;
if|if
condition|(
name|args
operator|&&
operator|*
name|args
condition|)
block|{
name|warning
argument_list|(
literal|"\ Can't pass arguments to remote MIPS board; arguments ignored."
argument_list|)
expr_stmt|;
comment|/* And don't try to use them on the next "run" command.  */
name|execute_command
argument_list|(
literal|"set args"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|execfile
operator|==
literal|0
operator|||
name|exec_bfd
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No executable file specified"
argument_list|)
expr_stmt|;
name|entry_pt
operator|=
operator|(
name|CORE_ADDR
operator|)
name|bfd_get_start_address
argument_list|(
name|exec_bfd
argument_list|)
expr_stmt|;
name|init_wait_for_inferior
argument_list|()
expr_stmt|;
comment|/* FIXME: Should we set inferior_pid here?  */
name|proceed
argument_list|(
name|entry_pt
argument_list|,
name|TARGET_SIGNAL_DEFAULT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clean up after a process.  Actually nothing to do.  */
end_comment

begin_function
specifier|static
name|void
name|mips_mourn_inferior
parameter_list|()
block|{
if|if
condition|(
name|current_ops
operator|!=
name|NULL
condition|)
name|unpush_target
argument_list|(
name|current_ops
argument_list|)
expr_stmt|;
name|generic_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* We can write a breakpoint and read the shadow contents in one    operation.  */
end_comment

begin_comment
comment|/* The IDT board uses an unusual breakpoint value, and sometimes gets    confused when it sees the usual MIPS breakpoint instruction.  */
end_comment

begin_define
define|#
directive|define
name|BREAK_INSN
value|(0x00000a0d)
end_define

begin_define
define|#
directive|define
name|BREAK_INSN_SIZE
value|(4)
end_define

begin_comment
comment|/* Insert a breakpoint on targets that don't have any better breakpoint    support.  We read the contents of the target location and stash it,    then overwrite it with a breakpoint instruction.  ADDR is the target    location in the target machine.  CONTENTS_CACHE is a pointer to     memory allocated for saving the target contents.  It is guaranteed    by the caller to be long enough to save sizeof BREAKPOINT bytes (this    is accomplished via BREAKPOINT_MAX).  */
end_comment

begin_function
specifier|static
name|int
name|mips_insert_breakpoint
parameter_list|(
name|addr
parameter_list|,
name|contents_cache
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|contents_cache
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
if|if
condition|(
name|monitor_supports_breakpoints
condition|)
return|return
name|common_breakpoint
argument_list|(
literal|'B'
argument_list|,
name|addr
argument_list|,
literal|0x3
argument_list|,
literal|"f"
argument_list|)
return|;
return|return
name|mips_store_word
argument_list|(
name|addr
argument_list|,
name|BREAK_INSN
argument_list|,
name|contents_cache
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mips_remove_breakpoint
parameter_list|(
name|addr
parameter_list|,
name|contents_cache
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|contents_cache
decl_stmt|;
block|{
if|if
condition|(
name|monitor_supports_breakpoints
condition|)
return|return
name|common_breakpoint
argument_list|(
literal|'b'
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
return|;
return|return
name|target_write_memory
argument_list|(
name|addr
argument_list|,
name|contents_cache
argument_list|,
name|BREAK_INSN_SIZE
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* currently not used */
end_comment

begin_comment
comment|/* PMON does not currently provide support for the debug mode 'b'    commands to manipulate breakpoints. However, if we wanted to use    the monitor breakpoints (rather than the GDB BREAK_INSN version)    then this code performs the work needed to leave debug mode,    set/clear the breakpoint, and then return to debug mode. */
end_comment

begin_define
define|#
directive|define
name|PMON_MAX_BP
value|(33)
end_define

begin_comment
comment|/* 32 SW, 1 HW */
end_comment

begin_comment
unit|static CORE_ADDR mips_pmon_bp_info[PMON_MAX_BP];
comment|/* NOTE: The code relies on this vector being zero-initialised by the system */
end_comment

begin_comment
unit|static int pmon_insert_breakpoint (addr, contents_cache)      CORE_ADDR addr;      char *contents_cache; {   int status;    if (monitor_supports_breakpoints)     {       char tbuff[12];
comment|/* space for breakpoint command */
end_comment

begin_comment
unit|int bpnum;       CORE_ADDR bpaddr;
comment|/* PMON does not support debug level breakpoint set/remove: */
end_comment

begin_comment
unit|if (mips_exit_debug ())         mips_error ("Failed to exit debug mode");        sprintf (tbuff, "b %08x\015", addr);       mips_send_command (tbuff, 0);        mips_expect ("Bpt ");        if (!mips_getstring (tbuff, 2))         return 1;       tbuff[2] = '\0';
comment|/* terminate the string */
end_comment

begin_comment
unit|if (sscanf (tbuff, "%d",&bpnum) != 1)         {           fprintf_unfiltered (stderr, "Invalid decimal breakpoint number from target: %s\n", tbuff);           return 1;         }        mips_expect (" = ");
comment|/* Lead in the hex number we are expecting: */
end_comment

begin_comment
unit|tbuff[0] = '0';       tbuff[1] = 'x';        if (!mips_getstring (&tbuff[2], 8))         return 1;       tbuff[10] = '\0';
comment|/* terminate the string */
end_comment

begin_comment
unit|if (sscanf (tbuff, "0x%08x",&bpaddr) != 1)         {           fprintf_unfiltered (stderr, "Invalid hex address from target: %s\n", tbuff);           return 1;         }        if (bpnum>= PMON_MAX_BP)         {           fprintf_unfiltered (stderr, "Error: Returned breakpoint number %d outside acceptable range (0..%d)\n",                               bpnum, PMON_MAX_BP - 1);           return 1;         }        if (bpaddr != addr)         fprintf_unfiltered (stderr, "Warning: Breakpoint addresses do not match: 0x%x != 0x%x\n", addr, bpaddr);        mips_pmon_bp_info[bpnum] = bpaddr;        mips_expect ("\015\012");       mips_expect (mips_monitor_prompt);        mips_enter_debug ();        return 0;     }    return mips_store_word (addr, BREAK_INSN, contents_cache); }  static int pmon_remove_breakpoint (addr, contents_cache)      CORE_ADDR addr;      char *contents_cache; {   if (monitor_supports_breakpoints)     {       int bpnum;       char tbuff[7];
comment|/* enough for delete breakpoint command */
end_comment

begin_comment
unit|for (bpnum = 0; bpnum< PMON_MAX_BP; bpnum++)         if (mips_pmon_bp_info[bpnum] == addr)           break;        if (bpnum>= PMON_MAX_BP)         {           fprintf_unfiltered (stderr, "pmon_remove_breakpoint: Failed to find breakpoint at address 0x%x\n", addr);           return 1;         }        if (mips_exit_debug ())         mips_error ("Failed to exit debug mode");        sprintf (tbuff, "db %02d\015", bpnum);        mips_send_command (tbuff, -1);
comment|/* NOTE: If the breakpoint does not exist then a "Bpt<dd> not          set" message will be returned. */
end_comment

begin_endif
unit|mips_enter_debug ();        return 0;     }    return target_write_memory (addr, contents_cache, BREAK_INSN_SIZE); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Compute a don't care mask for the region bounding ADDR and ADDR + LEN - 1.    This is used for memory ref breakpoints.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|calculate_mask
parameter_list|(
name|addr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|unsigned
name|long
name|mask
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mask
operator|=
name|addr
operator|^
operator|(
name|addr
operator|+
name|len
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|32
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
break|break;
else|else
name|mask
operator|>>=
literal|1
expr_stmt|;
name|mask
operator|=
operator|(
name|unsigned
name|long
operator|)
literal|0xffffffff
operator|>>
name|i
expr_stmt|;
return|return
name|mask
return|;
block|}
end_function

begin_comment
comment|/* Set a data watchpoint.  ADDR and LEN should be obvious.  TYPE is either 1    for a read watchpoint, or 2 for a read/write watchpoint. */
end_comment

begin_function
name|int
name|remote_mips_set_watchpoint
parameter_list|(
name|addr
parameter_list|,
name|len
parameter_list|,
name|type
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
name|CORE_ADDR
name|first_addr
decl_stmt|;
name|unsigned
name|long
name|mask
decl_stmt|;
name|char
modifier|*
name|flags
decl_stmt|;
name|mask
operator|=
name|calculate_mask
argument_list|(
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|first_addr
operator|=
name|addr
operator|&
operator|~
name|mask
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
literal|0
case|:
comment|/* write */
name|flags
operator|=
literal|"w"
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* read */
name|flags
operator|=
literal|"r"
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* read/write */
name|flags
operator|=
literal|"rw"
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|common_breakpoint
argument_list|(
literal|'B'
argument_list|,
name|first_addr
argument_list|,
name|mask
argument_list|,
name|flags
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|remote_mips_remove_watchpoint
parameter_list|(
name|addr
parameter_list|,
name|len
parameter_list|,
name|type
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
name|CORE_ADDR
name|first_addr
decl_stmt|;
name|unsigned
name|long
name|mask
decl_stmt|;
name|mask
operator|=
name|calculate_mask
argument_list|(
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|first_addr
operator|=
name|addr
operator|&
operator|~
name|mask
expr_stmt|;
if|if
condition|(
name|common_breakpoint
argument_list|(
literal|'b'
argument_list|,
name|first_addr
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|remote_mips_stopped_by_watchpoint
parameter_list|()
block|{
return|return
name|hit_watchpoint
return|;
block|}
end_function

begin_comment
comment|/* This routine generates the a breakpoint command of the form:     0x0<CMD><ADDR><MASK><FLAGS>     Where<CMD> is one of: `B' to set, or `b' to clear a breakpoint.<ADDR> is    the address of the breakpoint.<MASK> is a don't care mask for addresses.<FLAGS> is any combination of `r', `w', or `f' for read/write/or fetch.  */
end_comment

begin_function
specifier|static
name|int
name|common_breakpoint
parameter_list|(
name|cmd
parameter_list|,
name|addr
parameter_list|,
name|mask
parameter_list|,
name|flags
parameter_list|)
name|int
name|cmd
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|CORE_ADDR
name|mask
decl_stmt|;
name|char
modifier|*
name|flags
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|char
name|buf
index|[
name|DATA_MAXLEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|rcmd
decl_stmt|;
name|int
name|rpid
decl_stmt|,
name|rerrflg
decl_stmt|,
name|rresponse
decl_stmt|;
name|int
name|nfields
decl_stmt|;
if|if
condition|(
name|flags
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"0x0 %c 0x%x 0x%x %s"
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|,
name|mask
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"0x0 %c 0x%x"
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|mips_send_packet
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|len
operator|=
name|mips_receive_packet
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|mips_receive_wait
argument_list|)
expr_stmt|;
name|buf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|nfields
operator|=
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"0x%x %c 0x%x 0x%x"
argument_list|,
operator|&
name|rpid
argument_list|,
operator|&
name|rcmd
argument_list|,
operator|&
name|rerrflg
argument_list|,
operator|&
name|rresponse
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfields
operator|!=
literal|4
operator|||
name|rcmd
operator|!=
name|cmd
condition|)
name|mips_error
argument_list|(
literal|"common_breakpoint: Bad response from remote board: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|rerrflg
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rresponse
operator|!=
name|EINVAL
condition|)
name|fprintf_unfiltered
argument_list|(
name|stderr
argument_list|,
literal|"common_breakpoint (0x%x):  Got error: 0x%x\n"
argument_list|,
name|addr
argument_list|,
name|rresponse
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|send_srec
parameter_list|(
name|srec
parameter_list|,
name|len
parameter_list|,
name|addr
parameter_list|)
name|char
modifier|*
name|srec
decl_stmt|;
name|int
name|len
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|ch
decl_stmt|;
name|SERIAL_WRITE
argument_list|(
name|mips_desc
argument_list|,
name|srec
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ch
operator|=
name|mips_readchar
argument_list|(
literal|2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|SERIAL_TIMEOUT
case|:
name|error
argument_list|(
literal|"Timeout during download."
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x6
case|:
comment|/* ACK */
return|return;
case|case
literal|0x15
case|:
comment|/* NACK */
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Download got a NACK at byte %d!  Retrying.\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
continue|continue;
default|default:
name|error
argument_list|(
literal|"Download got unexpected ack char: 0x%x, retrying.\n"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  Download a binary file by converting it to S records. */
end_comment

begin_function
specifier|static
name|void
name|mips_load_srec
parameter_list|(
name|args
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|,
name|srec
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|srec_frame
init|=
literal|200
decl_stmt|;
name|int
name|reclen
decl_stmt|;
specifier|static
name|int
name|hashmark
init|=
literal|1
decl_stmt|;
name|buffer
operator|=
name|alloca
argument_list|(
name|srec_frame
operator|*
literal|2
operator|+
literal|256
argument_list|)
expr_stmt|;
name|abfd
operator|=
name|bfd_openr
argument_list|(
name|args
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abfd
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Unable to open file %s\n"
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bfd_check_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"File is not an object file\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* This actually causes a download in the IDT binary format: */
define|#
directive|define
name|LOAD_CMD
value|"load -b -s tty0\015"
name|mips_send_command
argument_list|(
name|LOAD_CMD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
condition|)
block|{
name|int
name|numbytes
decl_stmt|;
name|printf_filtered
argument_list|(
literal|"%s\t: 0x%4x .. 0x%4x  "
argument_list|,
name|s
operator|->
name|name
argument_list|,
name|s
operator|->
name|vma
argument_list|,
name|s
operator|->
name|vma
operator|+
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|_raw_size
condition|;
name|i
operator|+=
name|numbytes
control|)
block|{
name|numbytes
operator|=
name|min
argument_list|(
name|srec_frame
argument_list|,
name|s
operator|->
name|_raw_size
operator|-
name|i
argument_list|)
expr_stmt|;
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|buffer
argument_list|,
name|i
argument_list|,
name|numbytes
argument_list|)
expr_stmt|;
name|reclen
operator|=
name|mips_make_srec
argument_list|(
name|srec
argument_list|,
literal|'3'
argument_list|,
name|s
operator|->
name|vma
operator|+
name|i
argument_list|,
name|buffer
argument_list|,
name|numbytes
argument_list|)
expr_stmt|;
name|send_srec
argument_list|(
name|srec
argument_list|,
name|reclen
argument_list|,
name|s
operator|->
name|vma
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|hashmark
condition|)
block|{
name|putchar_unfiltered
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Per-packet (or S-record) loop */
name|putchar_unfiltered
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
comment|/* Loadable sections */
block|}
if|if
condition|(
name|hashmark
condition|)
name|putchar_unfiltered
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* Write a type 7 terminator record. no data for a type 7, and there      is no data, so len is 0.  */
name|reclen
operator|=
name|mips_make_srec
argument_list|(
name|srec
argument_list|,
literal|'7'
argument_list|,
name|abfd
operator|->
name|start_address
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_srec
argument_list|(
name|srec
argument_list|,
name|reclen
argument_list|,
name|abfd
operator|->
name|start_address
argument_list|)
expr_stmt|;
name|SERIAL_FLUSH_INPUT
argument_list|(
name|mips_desc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * mips_make_srec -- make an srecord. This writes each line, one at a  *	time, each with it's own header and trailer line.  *	An srecord looks like this:  *  * byte count-+     address  * start ---+ |        |       data        +- checksum  *	    | |        |                   |  *	  S01000006F6B692D746573742E73726563E4  *	  S315000448600000000000000000FC00005900000000E9  *	  S31A0004000023C1400037DE00F023604000377B009020825000348D  *	  S30B0004485A0000000000004E  *	  S70500040000F6  *  *	S<type><length><address><data><checksum>  *  *      Where  *      - length  *        is the number of bytes following upto the checksum. Note that  *        this is not the number of chars following, since it takes two  *        chars to represent a byte.  *      - type  *        is one of:  *        0) header record  *        1) two byte address data record  *        2) three byte address data record  *        3) four byte address data record  *        7) four byte address termination record  *        8) three byte address termination record  *        9) two byte address termination record  *         *      - address  *        is the start address of the data following, or in the case of  *        a termination record, the start address of the image  *      - data  *        is the data.  *      - checksum  *	  is the sum of all the raw byte data in the record, from the length  *        upwards, modulo 256 and subtracted from 255.  *  * This routine returns the length of the S-record.  *  */
end_comment

begin_function
specifier|static
name|int
name|mips_make_srec
parameter_list|(
name|buf
parameter_list|,
name|type
parameter_list|,
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|type
decl_stmt|;
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|unsigned
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|unsigned
name|char
name|checksum
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Create the header for the srec. addr_size is the number of bytes in the address,      and 1 is the number of bytes in the count.  */
name|buf
index|[
literal|0
index|]
operator|=
literal|'S'
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|type
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|len
operator|+
literal|4
operator|+
literal|1
expr_stmt|;
comment|/* len + 4 byte address + 1 byte checksum */
comment|/* This assumes S3 style downloads (4byte addresses). There should      probably be a check, or the code changed to make it more      explicit. */
name|buf
index|[
literal|3
index|]
operator|=
name|memaddr
operator|>>
literal|24
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
name|memaddr
operator|>>
literal|16
expr_stmt|;
name|buf
index|[
literal|5
index|]
operator|=
name|memaddr
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
literal|6
index|]
operator|=
name|memaddr
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|buf
index|[
literal|7
index|]
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Note that the checksum is calculated on the raw data, not the      hexified data.  It includes the length, address and the data      portions of the packet.  */
name|checksum
operator|=
literal|0
expr_stmt|;
name|buf
operator|+=
literal|2
expr_stmt|;
comment|/* Point at length byte */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
operator|+
literal|4
operator|+
literal|1
condition|;
name|i
operator|++
control|)
name|checksum
operator|+=
operator|*
name|buf
operator|++
expr_stmt|;
operator|*
name|buf
operator|=
operator|~
name|checksum
expr_stmt|;
return|return
name|len
operator|+
literal|8
return|;
block|}
end_function

begin_comment
comment|/* The following manifest controls whether we enable the simple flow    control support provided by the monitor. If enabled the code will    wait for an affirmative ACK between transmitting packets. */
end_comment

begin_define
define|#
directive|define
name|DOETXACK
value|(1)
end_define

begin_comment
comment|/* The PMON fast-download uses an encoded packet format constructed of    3byte data packets (encoded as 4 printable ASCII characters), and    escape sequences (preceded by a '/'):  	'K'     clear checksum 	'C'     compare checksum (12bit value, not included in checksum calculation) 	'S'     define symbol name (for addr) terminated with "," and padded to 4char boundary 	'Z'     zero fill multiple of 3bytes 	'B'     byte (12bit encoded value, of 8bit data) 	'A'     address (36bit encoded value) 	'E'     define entry as original address, and exit load     The packets are processed in 4 character chunks, so the escape    sequences that do not have any data (or variable length data)    should be padded to a 4 character boundary.  The decoder will give    an error if the complete message block size is not a multiple of    4bytes (size of record).     The encoding of numbers is done in 6bit fields.  The 6bit value is    used to index into this string to get the specific character    encoding for the value: */
end_comment

begin_decl_stmt
specifier|static
name|char
name|encoding
index|[
literal|64
index|]
init|=
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789,."
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Convert the number of bits required into an encoded number, 6bits    at a time (range 0..63).  Keep a checksum if required (passed    pointer non-NULL). The function returns the number of encoded    characters written into the buffer. */
end_comment

begin_function
specifier|static
name|int
name|pmon_makeb64
parameter_list|(
name|v
parameter_list|,
name|p
parameter_list|,
name|n
parameter_list|,
name|chksum
parameter_list|)
name|unsigned
name|long
name|v
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
modifier|*
name|chksum
decl_stmt|;
block|{
name|int
name|count
init|=
operator|(
name|n
operator|/
literal|6
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|n
operator|%
literal|12
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|stderr
argument_list|,
literal|"Fast encoding bitcount must be a multiple of 12bits: %dbit%s\n"
argument_list|,
name|n
argument_list|,
operator|(
name|n
operator|==
literal|1
operator|)
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|n
operator|>
literal|36
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|stderr
argument_list|,
literal|"Fast encoding cannot process more than 36bits at the moment: %dbits\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Deal with the checksum: */
if|if
condition|(
name|chksum
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|36
case|:
operator|*
name|chksum
operator|+=
operator|(
operator|(
name|v
operator|>>
literal|24
operator|)
operator|&
literal|0xFFF
operator|)
expr_stmt|;
case|case
literal|24
case|:
operator|*
name|chksum
operator|+=
operator|(
operator|(
name|v
operator|>>
literal|12
operator|)
operator|&
literal|0xFFF
operator|)
expr_stmt|;
case|case
literal|12
case|:
operator|*
name|chksum
operator|+=
operator|(
operator|(
name|v
operator|>>
literal|0
operator|)
operator|&
literal|0xFFF
operator|)
expr_stmt|;
block|}
block|}
do|do
block|{
name|n
operator|-=
literal|6
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|encoding
index|[
operator|(
name|v
operator|>>
name|n
operator|)
operator|&
literal|0x3F
index|]
expr_stmt|;
block|}
do|while
condition|(
name|n
operator|>
literal|0
condition|)
do|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Shorthand function (that could be in-lined) to output the zero-fill    escape sequence into the data stream. */
end_comment

begin_function
specifier|static
name|int
name|pmon_zeroset
parameter_list|(
name|recsize
parameter_list|,
name|buff
parameter_list|,
name|amount
parameter_list|,
name|chksum
parameter_list|)
name|int
name|recsize
decl_stmt|;
name|char
modifier|*
modifier|*
name|buff
decl_stmt|;
name|int
modifier|*
name|amount
decl_stmt|;
name|unsigned
name|int
modifier|*
name|chksum
decl_stmt|;
block|{
name|int
name|count
decl_stmt|;
name|sprintf
argument_list|(
operator|*
name|buff
argument_list|,
literal|"/Z"
argument_list|)
expr_stmt|;
name|count
operator|=
name|pmon_makeb64
argument_list|(
operator|*
name|amount
argument_list|,
operator|(
operator|*
name|buff
operator|+
literal|2
operator|)
argument_list|,
literal|12
argument_list|,
name|chksum
argument_list|)
expr_stmt|;
operator|*
name|buff
operator|+=
operator|(
name|count
operator|+
literal|2
operator|)
expr_stmt|;
operator|*
name|amount
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|recsize
operator|+
name|count
operator|+
literal|2
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pmon_checkset
parameter_list|(
name|recsize
parameter_list|,
name|buff
parameter_list|,
name|value
parameter_list|)
name|int
name|recsize
decl_stmt|;
name|char
modifier|*
modifier|*
name|buff
decl_stmt|;
name|int
modifier|*
name|value
decl_stmt|;
block|{
name|int
name|count
decl_stmt|;
comment|/* Add the checksum (without updating the value): */
name|sprintf
argument_list|(
operator|*
name|buff
argument_list|,
literal|"/C"
argument_list|)
expr_stmt|;
name|count
operator|=
name|pmon_makeb64
argument_list|(
operator|*
name|value
argument_list|,
operator|(
operator|*
name|buff
operator|+
literal|2
operator|)
argument_list|,
literal|12
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|buff
operator|+=
operator|(
name|count
operator|+
literal|2
operator|)
expr_stmt|;
name|sprintf
argument_list|(
operator|*
name|buff
argument_list|,
literal|"\015"
argument_list|)
expr_stmt|;
operator|*
name|buff
operator|+=
literal|2
expr_stmt|;
comment|/* include zero terminator */
comment|/* Forcing a checksum validation clears the sum: */
operator|*
name|value
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|recsize
operator|+
name|count
operator|+
literal|3
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Amount of padding we leave after at the end of the output buffer,    for the checksum and line termination characters: */
end_comment

begin_define
define|#
directive|define
name|CHECKSIZE
value|(4 + 4 + 4 + 2)
end_define

begin_comment
comment|/* zero-fill, checksum, transfer end and line termination space. */
end_comment

begin_comment
comment|/* The amount of binary data loaded from the object file in a single    operation: */
end_comment

begin_define
define|#
directive|define
name|BINCHUNK
value|(1024)
end_define

begin_comment
comment|/* Maximum line of data accepted by the monitor: */
end_comment

begin_define
define|#
directive|define
name|MAXRECSIZE
value|(550)
end_define

begin_comment
comment|/* NOTE: This constant depends on the monitor being used. This value    is for PMON 5.x on the Cogent Vr4300 board. */
end_comment

begin_function
specifier|static
name|void
name|pmon_make_fastrec
parameter_list|(
name|outbuf
parameter_list|,
name|inbuf
parameter_list|,
name|inptr
parameter_list|,
name|inamount
parameter_list|,
name|recsize
parameter_list|,
name|csum
parameter_list|,
name|zerofill
parameter_list|)
name|char
modifier|*
modifier|*
name|outbuf
decl_stmt|;
name|unsigned
name|char
modifier|*
name|inbuf
decl_stmt|;
name|int
modifier|*
name|inptr
decl_stmt|;
name|int
name|inamount
decl_stmt|;
name|int
modifier|*
name|recsize
decl_stmt|;
name|unsigned
name|int
modifier|*
name|csum
decl_stmt|;
name|unsigned
name|int
modifier|*
name|zerofill
decl_stmt|;
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
init|=
operator|*
name|outbuf
decl_stmt|;
comment|/* This is a simple check to ensure that our data will fit within      the maximum allowable record size. Each record output is 4bytes      in length. We must allow space for a pending zero fill command,      the record, and a checksum record. */
while|while
condition|(
operator|(
operator|*
name|recsize
operator|<
operator|(
name|MAXRECSIZE
operator|-
name|CHECKSIZE
operator|)
operator|)
operator|&&
operator|(
operator|(
name|inamount
operator|-
operator|*
name|inptr
operator|)
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* Process the binary data: */
if|if
condition|(
operator|(
name|inamount
operator|-
operator|*
name|inptr
operator|)
operator|<
literal|3
condition|)
block|{
if|if
condition|(
operator|*
name|zerofill
operator|!=
literal|0
condition|)
operator|*
name|recsize
operator|=
name|pmon_zeroset
argument_list|(
operator|*
name|recsize
argument_list|,
operator|&
name|p
argument_list|,
name|zerofill
argument_list|,
name|csum
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"/B"
argument_list|)
expr_stmt|;
name|count
operator|=
name|pmon_makeb64
argument_list|(
name|inbuf
index|[
operator|*
name|inptr
index|]
argument_list|,
operator|&
name|p
index|[
literal|2
index|]
argument_list|,
literal|12
argument_list|,
name|csum
argument_list|)
expr_stmt|;
name|p
operator|+=
operator|(
literal|2
operator|+
name|count
operator|)
expr_stmt|;
operator|*
name|recsize
operator|+=
operator|(
literal|2
operator|+
name|count
operator|)
expr_stmt|;
operator|(
operator|*
name|inptr
operator|)
operator|++
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|int
name|value
init|=
operator|(
operator|(
name|inbuf
index|[
operator|*
name|inptr
operator|+
literal|0
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|inbuf
index|[
operator|*
name|inptr
operator|+
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|inbuf
index|[
operator|*
name|inptr
operator|+
literal|2
index|]
operator|)
decl_stmt|;
comment|/* Simple check for zero data. TODO: A better check would be          to check the last, and then the middle byte for being zero          (if the first byte is not). We could then check for          following runs of zeros, and if above a certain size it is          worth the 4 or 8 character hit of the byte insertions used          to pad to the start of the zeroes. NOTE: This also depends          on the alignment at the end of the zero run. */
if|if
condition|(
name|value
operator|==
literal|0x00000000
condition|)
block|{
operator|(
operator|*
name|zerofill
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|zerofill
operator|==
literal|0xFFF
condition|)
comment|/* 12bit counter */
operator|*
name|recsize
operator|=
name|pmon_zeroset
argument_list|(
operator|*
name|recsize
argument_list|,
operator|&
name|p
argument_list|,
name|zerofill
argument_list|,
name|csum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|zerofill
operator|!=
literal|0
condition|)
operator|*
name|recsize
operator|=
name|pmon_zeroset
argument_list|(
operator|*
name|recsize
argument_list|,
operator|&
name|p
argument_list|,
name|zerofill
argument_list|,
name|csum
argument_list|)
expr_stmt|;
name|count
operator|=
name|pmon_makeb64
argument_list|(
name|value
argument_list|,
name|p
argument_list|,
literal|24
argument_list|,
name|csum
argument_list|)
expr_stmt|;
name|p
operator|+=
name|count
expr_stmt|;
operator|*
name|recsize
operator|+=
name|count
expr_stmt|;
block|}
operator|*
name|inptr
operator|+=
literal|3
expr_stmt|;
block|}
block|}
operator|*
name|outbuf
operator|=
name|p
expr_stmt|;
return|return;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DOETXACK
argument_list|)
end_if

begin_function
specifier|static
name|int
name|pmon_check_ack
parameter_list|()
block|{
name|int
name|c
init|=
name|SERIAL_READCHAR
argument_list|(
name|mips_desc
argument_list|,
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
name|SERIAL_TIMEOUT
operator|)
operator|||
operator|(
name|c
operator|!=
literal|0x06
operator|)
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Failed to receive valid ACK\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* terminate the download */
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DOETXACK */
end_comment

begin_function
specifier|static
name|void
name|pmon_load_fast
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|unsigned
name|char
modifier|*
name|binbuf
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|int
name|reclen
decl_stmt|;
name|unsigned
name|int
name|csum
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|hashmark
init|=
literal|1
decl_stmt|;
name|int
name|bintotal
init|=
literal|0
decl_stmt|;
name|int
name|final
decl_stmt|;
name|int
name|finished
init|=
literal|0
decl_stmt|;
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|MAXRECSIZE
operator|+
literal|1
argument_list|)
expr_stmt|;
name|binbuf
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|BINCHUNK
argument_list|)
expr_stmt|;
name|abfd
operator|=
name|bfd_openr
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abfd
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Unable to open file %s\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bfd_check_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"File is not an object file\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Setup the required download state: */
name|mips_send_command
argument_list|(
literal|"set dlproto etxack\015"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mips_send_command
argument_list|(
literal|"set dlecho off\015"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTE: We get a "cannot set variable" message if the variable is      already defined to have the argument we give. The code doesn't      care, since it just scans to the next prompt anyway. */
comment|/* Start the download: */
name|mips_send_command
argument_list|(
name|LOAD_CMD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mips_expect
argument_list|(
literal|"Downloading from tty0, ^C to abort\015\012"
argument_list|)
expr_stmt|;
comment|/* Zero the checksum */
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"/Kxx\015"
argument_list|)
expr_stmt|;
name|reclen
operator|=
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|SERIAL_WRITE
argument_list|(
name|mips_desc
argument_list|,
name|buffer
argument_list|,
name|reclen
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DOETXACK
argument_list|)
name|finished
operator|=
name|pmon_check_ack
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* DOETXACK */
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|&&
operator|!
name|finished
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
condition|)
comment|/* only deal with loadable sections */
block|{
name|bintotal
operator|+=
name|s
operator|->
name|_raw_size
expr_stmt|;
name|final
operator|=
operator|(
name|s
operator|->
name|vma
operator|+
name|s
operator|->
name|_raw_size
operator|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s\t: 0x%4x .. 0x%4x  "
argument_list|,
name|s
operator|->
name|name
argument_list|,
name|s
operator|->
name|vma
argument_list|,
name|s
operator|->
name|vma
operator|+
name|s
operator|->
name|_raw_size
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
comment|/* Output the starting address */
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"/A"
argument_list|)
expr_stmt|;
name|reclen
operator|=
name|pmon_makeb64
argument_list|(
name|s
operator|->
name|vma
argument_list|,
operator|&
name|buffer
index|[
literal|2
index|]
argument_list|,
literal|36
argument_list|,
operator|&
name|csum
argument_list|)
expr_stmt|;
name|buffer
index|[
literal|2
operator|+
name|reclen
index|]
operator|=
literal|'\015'
expr_stmt|;
name|buffer
index|[
literal|3
operator|+
name|reclen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|reclen
operator|+=
literal|3
expr_stmt|;
comment|/* for the initial escape code and carriage return */
name|SERIAL_WRITE
argument_list|(
name|mips_desc
argument_list|,
name|buffer
argument_list|,
name|reclen
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DOETXACK
argument_list|)
name|finished
operator|=
name|pmon_check_ack
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* DOETXACK */
if|if
condition|(
operator|!
name|finished
condition|)
block|{
name|int
name|binamount
decl_stmt|;
name|unsigned
name|int
name|zerofill
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|bp
init|=
name|buffer
decl_stmt|;
name|int
name|i
decl_stmt|;
name|reclen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|(
name|i
operator|<
name|s
operator|->
name|_raw_size
operator|)
operator|&&
operator|!
name|finished
operator|)
condition|;
name|i
operator|+=
name|binamount
control|)
block|{
name|int
name|binptr
init|=
literal|0
decl_stmt|;
name|binamount
operator|=
name|min
argument_list|(
name|BINCHUNK
argument_list|,
name|s
operator|->
name|_raw_size
operator|-
name|i
argument_list|)
expr_stmt|;
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|binbuf
argument_list|,
name|i
argument_list|,
name|binamount
argument_list|)
expr_stmt|;
comment|/* This keeps a rolling checksum, until we decide to output               the line: */
for|for
control|(
init|;
operator|(
operator|(
name|binamount
operator|-
name|binptr
operator|)
operator|>
literal|0
operator|)
condition|;
control|)
block|{
name|pmon_make_fastrec
argument_list|(
operator|&
name|bp
argument_list|,
name|binbuf
argument_list|,
operator|&
name|binptr
argument_list|,
name|binamount
argument_list|,
operator|&
name|reclen
argument_list|,
operator|&
name|csum
argument_list|,
operator|&
name|zerofill
argument_list|)
expr_stmt|;
if|if
condition|(
name|reclen
operator|>=
operator|(
name|MAXRECSIZE
operator|-
name|CHECKSIZE
operator|)
condition|)
block|{
name|reclen
operator|=
name|pmon_checkset
argument_list|(
name|reclen
argument_list|,
operator|&
name|bp
argument_list|,
operator|&
name|csum
argument_list|)
expr_stmt|;
name|SERIAL_WRITE
argument_list|(
name|mips_desc
argument_list|,
name|buffer
argument_list|,
name|reclen
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DOETXACK
argument_list|)
name|finished
operator|=
name|pmon_check_ack
argument_list|()
expr_stmt|;
if|if
condition|(
name|finished
condition|)
block|{
name|zerofill
operator|=
literal|0
expr_stmt|;
comment|/* do not transmit pending zerofills */
break|break;
block|}
endif|#
directive|endif
comment|/* DOETXACK */
if|if
condition|(
name|hashmark
condition|)
block|{
name|putchar_unfiltered
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|bp
operator|=
name|buffer
expr_stmt|;
name|reclen
operator|=
literal|0
expr_stmt|;
comment|/* buffer processed */
block|}
block|}
block|}
comment|/* Ensure no out-standing zerofill requests: */
if|if
condition|(
name|zerofill
operator|!=
literal|0
condition|)
name|reclen
operator|=
name|pmon_zeroset
argument_list|(
name|reclen
argument_list|,
operator|&
name|bp
argument_list|,
operator|&
name|zerofill
argument_list|,
operator|&
name|csum
argument_list|)
expr_stmt|;
comment|/* and then flush the line: */
if|if
condition|(
name|reclen
operator|>
literal|0
condition|)
block|{
name|reclen
operator|=
name|pmon_checkset
argument_list|(
name|reclen
argument_list|,
operator|&
name|bp
argument_list|,
operator|&
name|csum
argument_list|)
expr_stmt|;
comment|/* Currently pmon_checkset outputs the line terminator by               default, so we write out the buffer so far: */
name|SERIAL_WRITE
argument_list|(
name|mips_desc
argument_list|,
name|buffer
argument_list|,
name|reclen
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DOETXACK
argument_list|)
name|finished
operator|=
name|pmon_check_ack
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* DOETXACK */
block|}
block|}
if|if
condition|(
name|hashmark
condition|)
name|putchar_unfiltered
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
comment|/* Terminate the transfer. We know that we have an empty output      buffer at this point. */
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"/E/E\015"
argument_list|)
expr_stmt|;
comment|/* include dummy padding characters */
name|reclen
operator|=
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|SERIAL_WRITE
argument_list|(
name|mips_desc
argument_list|,
name|buffer
argument_list|,
name|reclen
argument_list|)
expr_stmt|;
if|if
condition|(
name|finished
condition|)
block|{
comment|/* Ignore the termination message: */
name|SERIAL_FLUSH_INPUT
argument_list|(
name|mips_desc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Deal with termination message: */
name|char
name|hexnumber
index|[
literal|9
index|]
decl_stmt|;
comment|/* includes '\0' space */
name|mips_expect
argument_list|(
literal|"Entry Address  = "
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hexnumber
argument_list|,
literal|"%x"
argument_list|,
name|final
argument_list|)
expr_stmt|;
name|mips_expect
argument_list|(
name|hexnumber
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|DOETXACK
argument_list|)
name|mips_expect
argument_list|(
literal|"\015\012\006\015\012total = 0x"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* normal termination */
name|mips_expect
argument_list|(
literal|"\015\012\015\012total = 0x"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !DOETXACK */
name|sprintf
argument_list|(
name|hexnumber
argument_list|,
literal|"%x"
argument_list|,
name|bintotal
argument_list|)
expr_stmt|;
name|mips_expect
argument_list|(
name|hexnumber
argument_list|)
expr_stmt|;
name|mips_expect
argument_list|(
literal|" bytes\015\012"
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* mips_load -- download a file. */
end_comment

begin_function
specifier|static
name|void
name|mips_load
parameter_list|(
name|file
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
comment|/* Get the board out of remote debugging mode.  */
if|if
condition|(
name|mips_exit_debug
argument_list|()
condition|)
name|error
argument_list|(
literal|"mips_load:  Couldn't get into monitor mode."
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_monitor
operator|==
name|MON_PMON
condition|)
name|pmon_load_fast
argument_list|(
name|file
argument_list|)
expr_stmt|;
else|else
name|mips_load_srec
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|mips_initialize
argument_list|()
expr_stmt|;
comment|/* Finally, make the PC point at the start address */
if|if
condition|(
name|exec_bfd
condition|)
name|write_pc
argument_list|(
name|bfd_get_start_address
argument_list|(
name|exec_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
literal|0
expr_stmt|;
comment|/* No process now */
comment|/* This is necessary because many things were based on the PC at the time that    we attached to the monitor, which is no longer valid now that we have loaded    new code (and just changed the PC).  Another way to do this might be to call    normal_stop, except that the stack may not be valid, and things would get    horribly confused... */
name|clear_symtab_users
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The target vector.  */
end_comment

begin_decl_stmt
name|struct
name|target_ops
name|mips_ops
init|=
block|{
literal|"mips"
block|,
comment|/* to_shortname */
literal|"Remote MIPS debugging over serial line"
block|,
comment|/* to_longname */
literal|"\ Debug a board using the MIPS remote debugging protocol over a serial line.\n\ The argument is the device it is connected to or, if it contains a colon,\n\ HOST:PORT to access a board over a network"
block|,
comment|/* to_doc */
name|mips_open
block|,
comment|/* to_open */
name|mips_close
block|,
comment|/* to_close */
name|NULL
block|,
comment|/* to_attach */
name|mips_detach
block|,
comment|/* to_detach */
name|mips_resume
block|,
comment|/* to_resume */
name|mips_wait
block|,
comment|/* to_wait */
name|mips_fetch_registers
block|,
comment|/* to_fetch_registers */
name|mips_store_registers
block|,
comment|/* to_store_registers */
name|mips_prepare_to_store
block|,
comment|/* to_prepare_to_store */
name|mips_xfer_memory
block|,
comment|/* to_xfer_memory */
name|mips_files_info
block|,
comment|/* to_files_info */
name|mips_insert_breakpoint
block|,
comment|/* to_insert_breakpoint */
name|mips_remove_breakpoint
block|,
comment|/* to_remove_breakpoint */
name|NULL
block|,
comment|/* to_terminal_init */
name|NULL
block|,
comment|/* to_terminal_inferior */
name|NULL
block|,
comment|/* to_terminal_ours_for_output */
name|NULL
block|,
comment|/* to_terminal_ours */
name|NULL
block|,
comment|/* to_terminal_info */
name|mips_kill
block|,
comment|/* to_kill */
name|mips_load
block|,
comment|/* to_load */
name|NULL
block|,
comment|/* to_lookup_symbol */
name|mips_create_inferior
block|,
comment|/* to_create_inferior */
name|mips_mourn_inferior
block|,
comment|/* to_mourn_inferior */
name|NULL
block|,
comment|/* to_can_run */
name|NULL
block|,
comment|/* to_notice_signals */
literal|0
block|,
comment|/* to_thread_alive */
literal|0
block|,
comment|/* to_stop */
name|process_stratum
block|,
comment|/* to_stratum */
name|NULL
block|,
comment|/* to_next */
literal|1
block|,
comment|/* to_has_all_memory */
literal|1
block|,
comment|/* to_has_memory */
literal|1
block|,
comment|/* to_has_stack */
literal|1
block|,
comment|/* to_has_registers */
literal|1
block|,
comment|/* to_has_execution */
name|NULL
block|,
comment|/* sections */
name|NULL
block|,
comment|/* sections_end */
name|OPS_MAGIC
comment|/* to_magic */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* An alternative target vector: */
end_comment

begin_decl_stmt
name|struct
name|target_ops
name|pmon_ops
init|=
block|{
literal|"pmon"
block|,
comment|/* to_shortname */
literal|"Remote MIPS debugging over serial line"
block|,
comment|/* to_longname */
literal|"\ Debug a board using the PMON MIPS remote debugging protocol over a serial\n\ line. The argument is the device it is connected to or, if it contains a\n\ colon, HOST:PORT to access a board over a network"
block|,
comment|/* to_doc */
name|pmon_open
block|,
comment|/* to_open */
name|mips_close
block|,
comment|/* to_close */
name|NULL
block|,
comment|/* to_attach */
name|mips_detach
block|,
comment|/* to_detach */
name|mips_resume
block|,
comment|/* to_resume */
name|pmon_wait
block|,
comment|/* to_wait */
name|mips_fetch_registers
block|,
comment|/* to_fetch_registers */
name|mips_store_registers
block|,
comment|/* to_store_registers */
name|mips_prepare_to_store
block|,
comment|/* to_prepare_to_store */
name|mips_xfer_memory
block|,
comment|/* to_xfer_memory */
name|mips_files_info
block|,
comment|/* to_files_info */
name|mips_insert_breakpoint
block|,
comment|/* to_insert_breakpoint */
name|mips_remove_breakpoint
block|,
comment|/* to_remove_breakpoint */
name|NULL
block|,
comment|/* to_terminal_init */
name|NULL
block|,
comment|/* to_terminal_inferior */
name|NULL
block|,
comment|/* to_terminal_ours_for_output */
name|NULL
block|,
comment|/* to_terminal_ours */
name|NULL
block|,
comment|/* to_terminal_info */
name|mips_kill
block|,
comment|/* to_kill */
name|mips_load
block|,
comment|/* to_load */
name|NULL
block|,
comment|/* to_lookup_symbol */
name|mips_create_inferior
block|,
comment|/* to_create_inferior */
name|mips_mourn_inferior
block|,
comment|/* to_mourn_inferior */
name|NULL
block|,
comment|/* to_can_run */
name|NULL
block|,
comment|/* to_notice_signals */
literal|0
block|,
comment|/* to_thread_alive */
literal|0
block|,
comment|/* to_stop */
name|process_stratum
block|,
comment|/* to_stratum */
name|NULL
block|,
comment|/* to_next */
literal|1
block|,
comment|/* to_has_all_memory */
literal|1
block|,
comment|/* to_has_memory */
literal|1
block|,
comment|/* to_has_stack */
literal|1
block|,
comment|/* to_has_registers */
literal|1
block|,
comment|/* to_has_execution */
name|NULL
block|,
comment|/* sections */
name|NULL
block|,
comment|/* sections_end */
name|OPS_MAGIC
comment|/* to_magic */
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
name|void
name|_initialize_remote_mips
parameter_list|()
block|{
name|add_target
argument_list|(
operator|&
name|mips_ops
argument_list|)
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|pmon_ops
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"timeout"
argument_list|,
name|no_class
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mips_receive_wait
argument_list|,
literal|"Set timeout in seconds for remote MIPS serial I/O."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"retransmit-timeout"
argument_list|,
name|no_class
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mips_retransmit_wait
argument_list|,
literal|"Set retransmit timeout in seconds for remote MIPS serial I/O.\n\ This is the number of seconds to wait for an acknowledgement to a packet\n\ before resending the packet."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"syn-garbage-limit"
argument_list|,
name|no_class
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mips_syn_garbage
argument_list|,
literal|"Set the maximum number of characters to ignore when scanning for a SYN.\n\ This is the maximum number of characters GDB will ignore when trying to\n\ synchronize with the remote system.  A value of -1 means that there is no limit\n\ (Note that these characters are printed out even though they are ignored.)"
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

