begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Remote debugging interface for MIPS remote debugging protocol.     Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,    2002 Free Software Foundation, Inc.     Contributed by Cygnus Support.  Written by Ian Lance Taylor<ian@cygnus.com>.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"remote-utils.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"mips-tdep.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Breakpoint types.  Values 0, 1, and 2 must agree with the watch    types passed by breakpoint.c to target_insert_watchpoint.    Value 3 is our own invention, and is used for ordinary instruction    breakpoints.  Value 4 is used to mark an unused watchpoint in tables.  */
end_comment

begin_enum
enum|enum
name|break_type
block|{
name|BREAK_WRITE
block|,
comment|/* 0 */
name|BREAK_READ
block|,
comment|/* 1 */
name|BREAK_ACCESS
block|,
comment|/* 2 */
name|BREAK_FETCH
block|,
comment|/* 3 */
name|BREAK_UNUSED
comment|/* 4 */
block|}
enum|;
end_enum

begin_comment
comment|/* Prototypes for local functions.  */
end_comment

begin_function_decl
specifier|static
name|int
name|mips_readchar
parameter_list|(
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mips_receive_header
parameter_list|(
name|unsigned
name|char
modifier|*
name|hdr
parameter_list|,
name|int
modifier|*
name|pgarbage
parameter_list|,
name|int
name|ch
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mips_receive_trailer
parameter_list|(
name|unsigned
name|char
modifier|*
name|trlr
parameter_list|,
name|int
modifier|*
name|pgarbage
parameter_list|,
name|int
modifier|*
name|pch
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mips_cksum
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|hdr
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_send_packet
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|get_ack
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_send_command
parameter_list|(
specifier|const
name|char
modifier|*
name|cmd
parameter_list|,
name|int
name|prompt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mips_receive_packet
parameter_list|(
name|char
modifier|*
name|buff
parameter_list|,
name|int
name|throw_error
parameter_list|,
name|int
name|timeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ULONGEST
name|mips_request
parameter_list|(
name|int
name|cmd
parameter_list|,
name|ULONGEST
name|addr
parameter_list|,
name|ULONGEST
name|data
parameter_list|,
name|int
modifier|*
name|perr
parameter_list|,
name|int
name|timeout
parameter_list|,
name|char
modifier|*
name|buff
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_initialize
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_open
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmon_open
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ddb_open
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lsi_open
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_close
parameter_list|(
name|int
name|quitting
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_detach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_resume
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|step
parameter_list|,
name|enum
name|target_signal
name|siggnal
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ptid_t
name|mips_wait
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mips_map_regno
parameter_list|(
name|int
name|regno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_fetch_registers
parameter_list|(
name|int
name|regno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_prepare_to_store
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_store_registers
parameter_list|(
name|int
name|regno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|mips_fetch_word
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mips_store_word
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|unsigned
name|int
name|value
parameter_list|,
name|char
modifier|*
name|old_contents
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mips_xfer_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|write
parameter_list|,
name|struct
name|mem_attrib
modifier|*
name|attrib
parameter_list|,
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_files_info
parameter_list|(
name|struct
name|target_ops
modifier|*
name|ignore
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_create_inferior
parameter_list|(
name|char
modifier|*
name|execfile
parameter_list|,
name|char
modifier|*
name|args
parameter_list|,
name|char
modifier|*
modifier|*
name|env
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_mourn_inferior
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmon_makeb64
parameter_list|(
name|unsigned
name|long
name|v
parameter_list|,
name|char
modifier|*
name|p
parameter_list|,
name|int
name|n
parameter_list|,
name|int
modifier|*
name|chksum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmon_zeroset
parameter_list|(
name|int
name|recsize
parameter_list|,
name|char
modifier|*
modifier|*
name|buff
parameter_list|,
name|int
modifier|*
name|amount
parameter_list|,
name|unsigned
name|int
modifier|*
name|chksum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmon_checkset
parameter_list|(
name|int
name|recsize
parameter_list|,
name|char
modifier|*
modifier|*
name|buff
parameter_list|,
name|int
modifier|*
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmon_make_fastrec
parameter_list|(
name|char
modifier|*
modifier|*
name|outbuf
parameter_list|,
name|unsigned
name|char
modifier|*
name|inbuf
parameter_list|,
name|int
modifier|*
name|inptr
parameter_list|,
name|int
name|inamount
parameter_list|,
name|int
modifier|*
name|recsize
parameter_list|,
name|unsigned
name|int
modifier|*
name|csum
parameter_list|,
name|unsigned
name|int
modifier|*
name|zerofill
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmon_check_ack
parameter_list|(
name|char
modifier|*
name|mesg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmon_start_download
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmon_end_download
parameter_list|(
name|int
name|final
parameter_list|,
name|int
name|bintotal
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmon_download
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|length
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmon_load_fast
parameter_list|(
name|char
modifier|*
name|file
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mips_load
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mips_make_srec
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|type
parameter_list|,
name|CORE_ADDR
name|memaddr
parameter_list|,
name|unsigned
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|int
name|len
parameter_list|,
name|enum
name|break_type
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|clear_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|int
name|len
parameter_list|,
name|enum
name|break_type
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|common_breakpoint
parameter_list|(
name|int
name|set
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|,
name|int
name|len
parameter_list|,
name|enum
name|break_type
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|mips_ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|pmon_ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|ddb_ops
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* *INDENT-OFF* */
end_comment

begin_comment
comment|/* The MIPS remote debugging interface is built on top of a simple    packet protocol.  Each packet is organized as follows:     SYN  The first character is always a SYN (ASCII 026, or ^V).  SYN    may not appear anywhere else in the packet.  Any time a SYN is    seen, a new packet should be assumed to have begun.     TYPE_LEN    This byte contains the upper five bits of the logical length    of the data section, plus a single bit indicating whether this    is a data packet or an acknowledgement.  The documentation    indicates that this bit is 1 for a data packet, but the actual    board uses 1 for an acknowledgement.  The value of the byte is    0x40 + (ack ? 0x20 : 0) + (len>> 6)    (we always have 0<= len< 1024).  Acknowledgement packets do    not carry data, and must have a data length of 0.     LEN1 This byte contains the lower six bits of the logical length of    the data section.  The value is    0x40 + (len& 0x3f)     SEQ  This byte contains the six bit sequence number of the packet.    The value is    0x40 + seq    An acknowlegment packet contains the sequence number of the    packet being acknowledged plus 1 modulo 64.  Data packets are    transmitted in sequence.  There may only be one outstanding    unacknowledged data packet at a time.  The sequence numbers    are independent in each direction.  If an acknowledgement for    the previous packet is received (i.e., an acknowledgement with    the sequence number of the packet just sent) the packet just    sent should be retransmitted.  If no acknowledgement is    received within a timeout period, the packet should be    retransmitted.  This has an unfortunate failure condition on a    high-latency line, as a delayed acknowledgement may lead to an    endless series of duplicate packets.     DATA The actual data bytes follow.  The following characters are    escaped inline with DLE (ASCII 020, or ^P):    SYN (026)    DLE S    DLE (020)    DLE D    ^C  (003)    DLE C    ^S  (023)    DLE s    ^Q  (021)    DLE q    The additional DLE characters are not counted in the logical    length stored in the TYPE_LEN and LEN1 bytes.     CSUM1    CSUM2    CSUM3    These bytes contain an 18 bit checksum of the complete    contents of the packet excluding the SEQ byte and the    CSUM[123] bytes.  The checksum is simply the twos complement    addition of all the bytes treated as unsigned characters.  The    values of the checksum bytes are:    CSUM1: 0x40 + ((cksum>> 12)& 0x3f)    CSUM2: 0x40 + ((cksum>> 6)& 0x3f)    CSUM3: 0x40 + (cksum& 0x3f)     It happens that the MIPS remote debugging protocol always    communicates with ASCII strings.  Because of this, this    implementation doesn't bother to handle the DLE quoting mechanism,    since it will never be required.  */
end_comment

begin_comment
comment|/* *INDENT-ON* */
end_comment

begin_comment
comment|/* The SYN character which starts each packet.  */
end_comment

begin_define
define|#
directive|define
name|SYN
value|'\026'
end_define

begin_comment
comment|/* The 0x40 used to offset each packet (this value ensures that all of    the header and trailer bytes, other than SYN, are printable ASCII    characters).  */
end_comment

begin_define
define|#
directive|define
name|HDR_OFFSET
value|0x40
end_define

begin_comment
comment|/* The indices of the bytes in the packet header.  */
end_comment

begin_define
define|#
directive|define
name|HDR_INDX_SYN
value|0
end_define

begin_define
define|#
directive|define
name|HDR_INDX_TYPE_LEN
value|1
end_define

begin_define
define|#
directive|define
name|HDR_INDX_LEN1
value|2
end_define

begin_define
define|#
directive|define
name|HDR_INDX_SEQ
value|3
end_define

begin_define
define|#
directive|define
name|HDR_LENGTH
value|4
end_define

begin_comment
comment|/* The data/ack bit in the TYPE_LEN header byte.  */
end_comment

begin_define
define|#
directive|define
name|TYPE_LEN_DA_BIT
value|0x20
end_define

begin_define
define|#
directive|define
name|TYPE_LEN_DATA
value|0
end_define

begin_define
define|#
directive|define
name|TYPE_LEN_ACK
value|TYPE_LEN_DA_BIT
end_define

begin_comment
comment|/* How to compute the header bytes.  */
end_comment

begin_define
define|#
directive|define
name|HDR_SET_SYN
parameter_list|(
name|data
parameter_list|,
name|len
parameter_list|,
name|seq
parameter_list|)
value|(SYN)
end_define

begin_define
define|#
directive|define
name|HDR_SET_TYPE_LEN
parameter_list|(
name|data
parameter_list|,
name|len
parameter_list|,
name|seq
parameter_list|)
define|\
value|(HDR_OFFSET \    + ((data) ? TYPE_LEN_DATA : TYPE_LEN_ACK) \    + (((len)>> 6)& 0x1f))
end_define

begin_define
define|#
directive|define
name|HDR_SET_LEN1
parameter_list|(
name|data
parameter_list|,
name|len
parameter_list|,
name|seq
parameter_list|)
value|(HDR_OFFSET + ((len)& 0x3f))
end_define

begin_define
define|#
directive|define
name|HDR_SET_SEQ
parameter_list|(
name|data
parameter_list|,
name|len
parameter_list|,
name|seq
parameter_list|)
value|(HDR_OFFSET + (seq))
end_define

begin_comment
comment|/* Check that a header byte is reasonable.  */
end_comment

begin_define
define|#
directive|define
name|HDR_CHECK
parameter_list|(
name|ch
parameter_list|)
value|(((ch)& HDR_OFFSET) == HDR_OFFSET)
end_define

begin_comment
comment|/* Get data from the header.  These macros evaluate their argument    multiple times.  */
end_comment

begin_define
define|#
directive|define
name|HDR_IS_DATA
parameter_list|(
name|hdr
parameter_list|)
define|\
value|(((hdr)[HDR_INDX_TYPE_LEN]& TYPE_LEN_DA_BIT) == TYPE_LEN_DATA)
end_define

begin_define
define|#
directive|define
name|HDR_GET_LEN
parameter_list|(
name|hdr
parameter_list|)
define|\
value|((((hdr)[HDR_INDX_TYPE_LEN]& 0x1f)<< 6) + (((hdr)[HDR_INDX_LEN1]& 0x3f)))
end_define

begin_define
define|#
directive|define
name|HDR_GET_SEQ
parameter_list|(
name|hdr
parameter_list|)
value|((unsigned int)(hdr)[HDR_INDX_SEQ]& 0x3f)
end_define

begin_comment
comment|/* The maximum data length.  */
end_comment

begin_define
define|#
directive|define
name|DATA_MAXLEN
value|1023
end_define

begin_comment
comment|/* The trailer offset.  */
end_comment

begin_define
define|#
directive|define
name|TRLR_OFFSET
value|HDR_OFFSET
end_define

begin_comment
comment|/* The indices of the bytes in the packet trailer.  */
end_comment

begin_define
define|#
directive|define
name|TRLR_INDX_CSUM1
value|0
end_define

begin_define
define|#
directive|define
name|TRLR_INDX_CSUM2
value|1
end_define

begin_define
define|#
directive|define
name|TRLR_INDX_CSUM3
value|2
end_define

begin_define
define|#
directive|define
name|TRLR_LENGTH
value|3
end_define

begin_comment
comment|/* How to compute the trailer bytes.  */
end_comment

begin_define
define|#
directive|define
name|TRLR_SET_CSUM1
parameter_list|(
name|cksum
parameter_list|)
value|(TRLR_OFFSET + (((cksum)>> 12)& 0x3f))
end_define

begin_define
define|#
directive|define
name|TRLR_SET_CSUM2
parameter_list|(
name|cksum
parameter_list|)
value|(TRLR_OFFSET + (((cksum)>>  6)& 0x3f))
end_define

begin_define
define|#
directive|define
name|TRLR_SET_CSUM3
parameter_list|(
name|cksum
parameter_list|)
value|(TRLR_OFFSET + (((cksum)      )& 0x3f))
end_define

begin_comment
comment|/* Check that a trailer byte is reasonable.  */
end_comment

begin_define
define|#
directive|define
name|TRLR_CHECK
parameter_list|(
name|ch
parameter_list|)
value|(((ch)& TRLR_OFFSET) == TRLR_OFFSET)
end_define

begin_comment
comment|/* Get data from the trailer.  This evaluates its argument multiple    times.  */
end_comment

begin_define
define|#
directive|define
name|TRLR_GET_CKSUM
parameter_list|(
name|trlr
parameter_list|)
define|\
value|((((trlr)[TRLR_INDX_CSUM1]& 0x3f)<< 12) \    + (((trlr)[TRLR_INDX_CSUM2]& 0x3f)<<  6) \    + ((trlr)[TRLR_INDX_CSUM3]& 0x3f))
end_define

begin_comment
comment|/* The sequence number modulos.  */
end_comment

begin_define
define|#
directive|define
name|SEQ_MODULOS
value|(64)
end_define

begin_comment
comment|/* PMON commands to load from the serial port or UDP socket.  */
end_comment

begin_define
define|#
directive|define
name|LOAD_CMD
value|"load -b -s tty0\r"
end_define

begin_define
define|#
directive|define
name|LOAD_CMD_UDP
value|"load -b -s udp\r"
end_define

begin_comment
comment|/* The target vectors for the four different remote MIPS targets.    These are initialized with code in _initialize_remote_mips instead    of static initializers, to make it easier to extend the target_ops    vector later.  */
end_comment

begin_decl_stmt
name|struct
name|target_ops
name|mips_ops
decl_stmt|,
name|pmon_ops
decl_stmt|,
name|ddb_ops
decl_stmt|,
name|lsi_ops
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|mips_monitor_type
block|{
comment|/* IDT/SIM monitor being used: */
name|MON_IDT
block|,
comment|/* PMON monitor being used: */
name|MON_PMON
block|,
comment|/* 3.0.83 [COGENT,EB,FP,NET] Algorithmics Ltd. Nov  9 1995 17:19:50 */
name|MON_DDB
block|,
comment|/* 2.7.473 [DDBVR4300,EL,FP,NET] Risq Modular Systems,  Thu Jun 6 09:28:40 PDT 1996 */
name|MON_LSI
block|,
comment|/* 4.3.12 [EB,FP], LSI LOGIC Corp. Tue Feb 25 13:22:14 1997 */
comment|/* Last and unused value, for sizing vectors, etc. */
name|MON_LAST
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|enum
name|mips_monitor_type
name|mips_monitor
init|=
name|MON_LAST
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The monitor prompt text.  If the user sets the PMON prompt    to some new value, the GDB `set monitor-prompt' command must also    be used to inform GDB about the expected prompt.  Otherwise, GDB    will not be able to connect to PMON in mips_initialize().    If the `set monitor-prompt' command is not used, the expected    default prompt will be set according the target:    target               prompt    -----                -----    pmon         PMON>     ddb          NEC010>    lsi          PMON>  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mips_monitor_prompt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 1 if the target is open.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_is_open
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Currently active target description (if mips_is_open == 1) */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|target_ops
modifier|*
name|current_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 1 while the connection is being initialized.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_initializing
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 1 while the connection is being brought down.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_exiting
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The next sequence number to send.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|mips_send_seq
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The next sequence number we expect to receive.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|mips_receive_seq
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The time to wait before retransmitting a packet, in seconds.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_retransmit_wait
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of times to try retransmitting a packet before giving up.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_send_retries
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The number of garbage characters to accept when looking for an    SYN for the next packet.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_syn_garbage
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The time to wait for a packet, in seconds.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_receive_wait
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set if we have sent a packet to the board but have not yet received    a reply.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_need_reply
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Handle used to access serial I/O stream.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|serial
modifier|*
name|mips_desc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* UDP handle used to download files to target.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|serial
modifier|*
name|udp_desc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|udp_in_use
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TFTP filename used to download files to DDB board, in the form    host:filename.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tftp_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* host:filename */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tftp_localname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* filename portion of above */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tftp_in_use
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|tftp_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Counts the number of times the user tried to interrupt the target (usually    via ^C.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|interrupt_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, means that the target is running. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mips_wait_flag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If non-zero, monitor supports breakpoint commands. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|monitor_supports_breakpoints
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Data cache header.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* not used (yet?) */
end_comment

begin_endif
unit|static DCACHE *mips_dcache;
endif|#
directive|endif
end_endif

begin_comment
comment|/* Non-zero means that we've just hit a read or write watchpoint */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hit_watchpoint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table of breakpoints/watchpoints (used only on LSI PMON target).    The table is indexed by a breakpoint number, which is an integer    from 0 to 255 returned by the LSI PMON when a breakpoint is set.  */
end_comment

begin_define
define|#
directive|define
name|MAX_LSI_BREAKPOINTS
value|256
end_define

begin_struct
struct|struct
name|lsi_breakpoint_info
block|{
name|enum
name|break_type
name|type
decl_stmt|;
comment|/* type of breakpoint */
name|CORE_ADDR
name|addr
decl_stmt|;
comment|/* address of breakpoint */
name|int
name|len
decl_stmt|;
comment|/* length of region being watched */
name|unsigned
name|long
name|value
decl_stmt|;
comment|/* value to watch */
block|}
name|lsi_breakpoints
index|[
name|MAX_LSI_BREAKPOINTS
index|]
struct|;
end_struct

begin_comment
comment|/* Error/warning codes returned by LSI PMON for breakpoint commands.    Warning values may be ORed together; error values may not.  */
end_comment

begin_define
define|#
directive|define
name|W_WARN
value|0x100
end_define

begin_comment
comment|/* This bit is set if the error code is a warning */
end_comment

begin_define
define|#
directive|define
name|W_MSK
value|0x101
end_define

begin_comment
comment|/* warning: Range feature is supported via mask */
end_comment

begin_define
define|#
directive|define
name|W_VAL
value|0x102
end_define

begin_comment
comment|/* warning: Value check is not supported in hardware */
end_comment

begin_define
define|#
directive|define
name|W_QAL
value|0x104
end_define

begin_comment
comment|/* warning: Requested qualifiers are not supported in hardware */
end_comment

begin_define
define|#
directive|define
name|E_ERR
value|0x200
end_define

begin_comment
comment|/* This bit is set if the error code is an error */
end_comment

begin_define
define|#
directive|define
name|E_BPT
value|0x200
end_define

begin_comment
comment|/* error: No such breakpoint number */
end_comment

begin_define
define|#
directive|define
name|E_RGE
value|0x201
end_define

begin_comment
comment|/* error: Range is not supported */
end_comment

begin_define
define|#
directive|define
name|E_QAL
value|0x202
end_define

begin_comment
comment|/* error: The requested qualifiers can not be used */
end_comment

begin_define
define|#
directive|define
name|E_OUT
value|0x203
end_define

begin_comment
comment|/* error: Out of hardware resources */
end_comment

begin_define
define|#
directive|define
name|E_NON
value|0x204
end_define

begin_comment
comment|/* error: Hardware breakpoint not supported */
end_comment

begin_struct
struct|struct
name|lsi_error
block|{
name|int
name|code
decl_stmt|;
comment|/* error code */
name|char
modifier|*
name|string
decl_stmt|;
comment|/* string associated with this code */
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|lsi_error
name|lsi_warning_table
index|[]
init|=
block|{
block|{
name|W_MSK
block|,
literal|"Range feature is supported via mask"
block|}
block|,
block|{
name|W_VAL
block|,
literal|"Value check is not supported in hardware"
block|}
block|,
block|{
name|W_QAL
block|,
literal|"Requested qualifiers are not supported in hardware"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|lsi_error
name|lsi_error_table
index|[]
init|=
block|{
block|{
name|E_BPT
block|,
literal|"No such breakpoint number"
block|}
block|,
block|{
name|E_RGE
block|,
literal|"Range is not supported"
block|}
block|,
block|{
name|E_QAL
block|,
literal|"The requested qualifiers can not be used"
block|}
block|,
block|{
name|E_OUT
block|,
literal|"Out of hardware resources"
block|}
block|,
block|{
name|E_NON
block|,
literal|"Hardware breakpoint not supported"
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set to 1 with the 'set monitor-warnings' command to enable printing    of warnings returned by PMON when hardware breakpoints are used.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|monitor_warnings
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|close_ports
parameter_list|(
name|void
parameter_list|)
block|{
name|mips_is_open
operator|=
literal|0
expr_stmt|;
name|serial_close
argument_list|(
name|mips_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|udp_in_use
condition|)
block|{
name|serial_close
argument_list|(
name|udp_desc
argument_list|)
expr_stmt|;
name|udp_in_use
operator|=
literal|0
expr_stmt|;
block|}
name|tftp_in_use
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle low-level error that we can't recover from.  Note that just    error()ing out from target_wait or some such low-level place will cause    all hell to break loose--the rest of GDB will tend to get left in an    inconsistent state.  */
end_comment

begin_function
specifier|static
name|NORETURN
name|void
name|mips_error
parameter_list|(
name|char
modifier|*
name|string
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|target_terminal_ours
argument_list|()
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
comment|/* Force out any buffered output */
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_pre_print
condition|)
name|fputs_filtered
argument_list|(
name|error_pre_print
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
name|vfprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
name|string
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
comment|/* Clean up in such a way that mips_close won't try to talk to the      board (it almost surely won't work since we weren't able to talk to      it).  */
name|close_ports
argument_list|()
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"Ending remote MIPS debugging.\n"
argument_list|)
expr_stmt|;
name|target_mourn_inferior
argument_list|()
expr_stmt|;
name|throw_exception
argument_list|(
name|RETURN_ERROR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* putc_readable - print a character, displaying non-printable chars in    ^x notation or in hex.  */
end_comment

begin_function
specifier|static
name|void
name|fputc_readable
parameter_list|(
name|int
name|ch
parameter_list|,
name|struct
name|ui_file
modifier|*
name|file
parameter_list|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
name|fputc_unfiltered
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\r'
condition|)
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"\\r"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|<
literal|0x20
condition|)
comment|/* ASCII control character */
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"^%c"
argument_list|,
name|ch
operator|+
literal|'@'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|0x7f
condition|)
comment|/* non-ASCII characters (rubout or greater) */
name|fprintf_unfiltered
argument_list|(
name|file
argument_list|,
literal|"[%02x]"
argument_list|,
name|ch
operator|&
literal|0xff
argument_list|)
expr_stmt|;
else|else
name|fputc_unfiltered
argument_list|(
name|ch
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* puts_readable - print a string, displaying non-printable chars in    ^x notation or in hex.  */
end_comment

begin_function
specifier|static
name|void
name|fputs_readable
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|struct
name|ui_file
modifier|*
name|file
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|string
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
name|fputc_readable
argument_list|(
name|c
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wait until STRING shows up in mips_desc.  Returns 1 if successful, else 0 if    timed out.  TIMEOUT specifies timeout value in seconds.  */
end_comment

begin_function
specifier|static
name|int
name|mips_expect_timeout
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
init|=
name|string
decl_stmt|;
if|if
condition|(
name|remote_debug
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"Expected \""
argument_list|)
expr_stmt|;
name|fputs_readable
argument_list|(
name|string
argument_list|,
name|gdb_stdlog
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"\", got \""
argument_list|)
expr_stmt|;
block|}
name|immediate_quit
operator|++
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|c
decl_stmt|;
comment|/* Must use serial_readchar() here cuz mips_readchar would get 	 confused if we were waiting for the mips_monitor_prompt... */
name|c
operator|=
name|serial_readchar
argument_list|(
name|mips_desc
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|SERIAL_TIMEOUT
condition|)
block|{
if|if
condition|(
name|remote_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"\": FAIL\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|remote_debug
condition|)
name|fputc_readable
argument_list|(
name|c
argument_list|,
name|gdb_stdlog
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
operator|*
name|p
operator|++
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|immediate_quit
operator|--
expr_stmt|;
if|if
condition|(
name|remote_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"\": OK\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
else|else
block|{
name|p
operator|=
name|string
expr_stmt|;
if|if
condition|(
name|c
operator|==
operator|*
name|p
condition|)
name|p
operator|++
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Wait until STRING shows up in mips_desc.  Returns 1 if successful, else 0 if    timed out.  The timeout value is hard-coded to 2 seconds.  Use    mips_expect_timeout if a different timeout value is needed.  */
end_comment

begin_function
specifier|static
name|int
name|mips_expect
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
return|return
name|mips_expect_timeout
argument_list|(
name|string
argument_list|,
name|remote_timeout
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read a character from the remote, aborting on error.  Returns    SERIAL_TIMEOUT on timeout (since that's what serial_readchar()    returns).  FIXME: If we see the string mips_monitor_prompt from the    board, then we are debugging on the main console port, and we have    somehow dropped out of remote debugging mode.  In this case, we    automatically go back in to remote debugging mode.  This is a hack,    put in because I can't find any way for a program running on the    remote board to terminate without also ending remote debugging    mode.  I assume users won't have any trouble with this; for one    thing, the IDT documentation generally assumes that the remote    debugging port is not the console port.  This is, however, very    convenient for DejaGnu when you only have one connected serial    port.  */
end_comment

begin_function
specifier|static
name|int
name|mips_readchar
parameter_list|(
name|int
name|timeout
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
specifier|static
name|int
name|state
init|=
literal|0
decl_stmt|;
name|int
name|mips_monitor_prompt_len
init|=
name|strlen
argument_list|(
name|mips_monitor_prompt
argument_list|)
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
name|timeout
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
operator|&&
name|watchdog
operator|>
literal|0
condition|)
name|i
operator|=
name|watchdog
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|==
name|mips_monitor_prompt_len
condition|)
name|timeout
operator|=
literal|1
expr_stmt|;
name|ch
operator|=
name|serial_readchar
argument_list|(
name|mips_desc
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|SERIAL_TIMEOUT
operator|&&
name|timeout
operator|==
operator|-
literal|1
condition|)
comment|/* Watchdog went off */
block|{
name|target_mourn_inferior
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"Watchdog has expired.  Target detached.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|==
name|SERIAL_EOF
condition|)
name|mips_error
argument_list|(
literal|"End of file from remote"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|SERIAL_ERROR
condition|)
name|mips_error
argument_list|(
literal|"Error reading from remote: %s"
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_debug
operator|>
literal|1
condition|)
block|{
comment|/* Don't use _filtered; we can't deal with a QUIT out of          target_wait, and I think this might be called from there.  */
if|if
condition|(
name|ch
operator|!=
name|SERIAL_TIMEOUT
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"Read '%c' %d 0x%x\n"
argument_list|,
name|ch
argument_list|,
name|ch
argument_list|,
name|ch
argument_list|)
expr_stmt|;
else|else
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"Timed out in read\n"
argument_list|)
expr_stmt|;
block|}
comment|/* If we have seen mips_monitor_prompt and we either time out, or      we see a @ (which was echoed from a packet we sent), reset the      board as described above.  The first character in a packet after      the SYN (which is not echoed) is always an @ unless the packet is      more than 64 characters long, which ours never are.  */
if|if
condition|(
operator|(
name|ch
operator|==
name|SERIAL_TIMEOUT
operator|||
name|ch
operator|==
literal|'@'
operator|)
operator|&&
name|state
operator|==
name|mips_monitor_prompt_len
operator|&&
operator|!
name|mips_initializing
operator|&&
operator|!
name|mips_exiting
condition|)
block|{
if|if
condition|(
name|remote_debug
operator|>
literal|0
condition|)
comment|/* Don't use _filtered; we can't deal with a QUIT out of 	   target_wait, and I think this might be called from there.  */
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"Reinitializing MIPS debugging mode\n"
argument_list|)
expr_stmt|;
name|mips_need_reply
operator|=
literal|0
expr_stmt|;
name|mips_initialize
argument_list|()
expr_stmt|;
name|state
operator|=
literal|0
expr_stmt|;
comment|/* At this point, about the only thing we can do is abort the command          in progress and get back to command level as quickly as possible. */
name|error
argument_list|(
literal|"Remote board reset, debug protocol re-initialized."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|==
name|mips_monitor_prompt
index|[
name|state
index|]
condition|)
operator|++
name|state
expr_stmt|;
else|else
name|state
operator|=
literal|0
expr_stmt|;
return|return
name|ch
return|;
block|}
end_function

begin_comment
comment|/* Get a packet header, putting the data in the supplied buffer.    PGARBAGE is a pointer to the number of garbage characters received    so far.  CH is the last character received.  Returns 0 for success,    or -1 for timeout.  */
end_comment

begin_function
specifier|static
name|int
name|mips_receive_header
parameter_list|(
name|unsigned
name|char
modifier|*
name|hdr
parameter_list|,
name|int
modifier|*
name|pgarbage
parameter_list|,
name|int
name|ch
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Wait for a SYN.  mips_syn_garbage is intended to prevent          sitting here indefinitely if the board sends us one garbage          character per second.  ch may already have a value from the          last time through the loop.  */
while|while
condition|(
name|ch
operator|!=
name|SYN
condition|)
block|{
name|ch
operator|=
name|mips_readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|SERIAL_TIMEOUT
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|ch
operator|!=
name|SYN
condition|)
block|{
comment|/* Printing the character here lets the user of gdb see 	         what the program is outputting, if the debugging is 	         being done on the console port.  Don't use _filtered: 	         we can't deal with a QUIT out of target_wait and 	         buffered target output confuses the user. */
if|if
condition|(
operator|!
name|mips_initializing
operator|||
name|remote_debug
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|isprint
argument_list|(
name|ch
argument_list|)
operator|||
name|isspace
argument_list|(
name|ch
argument_list|)
condition|)
block|{
name|fputc_unfiltered
argument_list|(
name|ch
argument_list|,
name|gdb_stdtarg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fputc_readable
argument_list|(
name|ch
argument_list|,
name|gdb_stdtarg
argument_list|)
expr_stmt|;
block|}
name|gdb_flush
argument_list|(
name|gdb_stdtarg
argument_list|)
expr_stmt|;
block|}
comment|/* Only count unprintable characters. */
if|if
condition|(
operator|!
operator|(
name|isprint
argument_list|(
name|ch
argument_list|)
operator|||
name|isspace
argument_list|(
name|ch
argument_list|)
operator|)
condition|)
operator|(
operator|*
name|pgarbage
operator|)
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|mips_syn_garbage
operator|>
literal|0
operator|&&
operator|*
name|pgarbage
operator|>
name|mips_syn_garbage
condition|)
name|mips_error
argument_list|(
literal|"Debug protocol failure:  more than %d characters before a sync."
argument_list|,
name|mips_syn_garbage
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Get the packet header following the SYN.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|HDR_LENGTH
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|=
name|mips_readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|SERIAL_TIMEOUT
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Make sure this is a header byte.  */
if|if
condition|(
name|ch
operator|==
name|SYN
operator|||
operator|!
name|HDR_CHECK
argument_list|(
name|ch
argument_list|)
condition|)
break|break;
name|hdr
index|[
name|i
index|]
operator|=
name|ch
expr_stmt|;
block|}
comment|/* If we got the complete header, we can return.  Otherwise we          loop around and keep looking for SYN.  */
if|if
condition|(
name|i
operator|>=
name|HDR_LENGTH
condition|)
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Get a packet header, putting the data in the supplied buffer.    PGARBAGE is a pointer to the number of garbage characters received    so far.  The last character read is returned in *PCH.  Returns 0    for success, -1 for timeout, -2 for error.  */
end_comment

begin_function
specifier|static
name|int
name|mips_receive_trailer
parameter_list|(
name|unsigned
name|char
modifier|*
name|trlr
parameter_list|,
name|int
modifier|*
name|pgarbage
parameter_list|,
name|int
modifier|*
name|pch
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|ch
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TRLR_LENGTH
condition|;
name|i
operator|++
control|)
block|{
name|ch
operator|=
name|mips_readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
operator|*
name|pch
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|SERIAL_TIMEOUT
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|TRLR_CHECK
argument_list|(
name|ch
argument_list|)
condition|)
return|return
operator|-
literal|2
return|;
name|trlr
index|[
name|i
index|]
operator|=
name|ch
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Get the checksum of a packet.  HDR points to the packet header.    DATA points to the packet data.  LEN is the length of DATA.  */
end_comment

begin_function
specifier|static
name|int
name|mips_cksum
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|hdr
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|cksum
decl_stmt|;
name|cksum
operator|=
literal|0
expr_stmt|;
comment|/* The initial SYN is not included in the checksum.  */
name|c
operator|=
name|HDR_LENGTH
operator|-
literal|1
expr_stmt|;
name|p
operator|=
name|hdr
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|c
operator|--
operator|!=
literal|0
condition|)
name|cksum
operator|+=
operator|*
name|p
operator|++
expr_stmt|;
name|c
operator|=
name|len
expr_stmt|;
name|p
operator|=
name|data
expr_stmt|;
while|while
condition|(
name|c
operator|--
operator|!=
literal|0
condition|)
name|cksum
operator|+=
operator|*
name|p
operator|++
expr_stmt|;
return|return
name|cksum
return|;
block|}
end_function

begin_comment
comment|/* Send a packet containing the given ASCII string.  */
end_comment

begin_function
specifier|static
name|void
name|mips_send_packet
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
name|get_ack
parameter_list|)
block|{
comment|/* unsigned */
name|int
name|len
decl_stmt|;
name|unsigned
name|char
modifier|*
name|packet
decl_stmt|;
name|int
name|cksum
decl_stmt|;
name|int
name|try
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|DATA_MAXLEN
condition|)
name|mips_error
argument_list|(
literal|"MIPS protocol data packet too long: %s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|packet
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|HDR_LENGTH
operator|+
name|len
operator|+
name|TRLR_LENGTH
operator|+
literal|1
argument_list|)
expr_stmt|;
name|packet
index|[
name|HDR_INDX_SYN
index|]
operator|=
name|HDR_SET_SYN
argument_list|(
literal|1
argument_list|,
name|len
argument_list|,
name|mips_send_seq
argument_list|)
expr_stmt|;
name|packet
index|[
name|HDR_INDX_TYPE_LEN
index|]
operator|=
name|HDR_SET_TYPE_LEN
argument_list|(
literal|1
argument_list|,
name|len
argument_list|,
name|mips_send_seq
argument_list|)
expr_stmt|;
name|packet
index|[
name|HDR_INDX_LEN1
index|]
operator|=
name|HDR_SET_LEN1
argument_list|(
literal|1
argument_list|,
name|len
argument_list|,
name|mips_send_seq
argument_list|)
expr_stmt|;
name|packet
index|[
name|HDR_INDX_SEQ
index|]
operator|=
name|HDR_SET_SEQ
argument_list|(
literal|1
argument_list|,
name|len
argument_list|,
name|mips_send_seq
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|packet
operator|+
name|HDR_LENGTH
argument_list|,
name|s
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cksum
operator|=
name|mips_cksum
argument_list|(
name|packet
argument_list|,
name|packet
operator|+
name|HDR_LENGTH
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|packet
index|[
name|HDR_LENGTH
operator|+
name|len
operator|+
name|TRLR_INDX_CSUM1
index|]
operator|=
name|TRLR_SET_CSUM1
argument_list|(
name|cksum
argument_list|)
expr_stmt|;
name|packet
index|[
name|HDR_LENGTH
operator|+
name|len
operator|+
name|TRLR_INDX_CSUM2
index|]
operator|=
name|TRLR_SET_CSUM2
argument_list|(
name|cksum
argument_list|)
expr_stmt|;
name|packet
index|[
name|HDR_LENGTH
operator|+
name|len
operator|+
name|TRLR_INDX_CSUM3
index|]
operator|=
name|TRLR_SET_CSUM3
argument_list|(
name|cksum
argument_list|)
expr_stmt|;
comment|/* Increment the sequence number.  This will set mips_send_seq to      the sequence number we expect in the acknowledgement.  */
name|mips_send_seq
operator|=
operator|(
name|mips_send_seq
operator|+
literal|1
operator|)
operator|%
name|SEQ_MODULOS
expr_stmt|;
comment|/* We can only have one outstanding data packet, so we just wait for      the acknowledgement here.  Keep retransmitting the packet until      we get one, or until we've tried too many times.  */
for|for
control|(
name|try
operator|=
literal|0
init|;
name|try
operator|<
name|mips_send_retries
condition|;
name|try
operator|++
control|)
block|{
name|int
name|garbage
decl_stmt|;
name|int
name|ch
decl_stmt|;
if|if
condition|(
name|remote_debug
operator|>
literal|0
condition|)
block|{
comment|/* Don't use _filtered; we can't deal with a QUIT out of 	     target_wait, and I think this might be called from there.  */
name|packet
index|[
name|HDR_LENGTH
operator|+
name|len
operator|+
name|TRLR_LENGTH
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"Writing \"%s\"\n"
argument_list|,
name|packet
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|serial_write
argument_list|(
name|mips_desc
argument_list|,
name|packet
argument_list|,
name|HDR_LENGTH
operator|+
name|len
operator|+
name|TRLR_LENGTH
argument_list|)
operator|!=
literal|0
condition|)
name|mips_error
argument_list|(
literal|"write to target failed: %s"
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_ack
condition|)
return|return;
name|garbage
operator|=
literal|0
expr_stmt|;
name|ch
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|unsigned
name|char
name|hdr
index|[
name|HDR_LENGTH
operator|+
literal|1
index|]
decl_stmt|;
name|unsigned
name|char
name|trlr
index|[
name|TRLR_LENGTH
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|err
decl_stmt|;
name|unsigned
name|int
name|seq
decl_stmt|;
comment|/* Get the packet header.  If we time out, resend the data 	     packet.  */
name|err
operator|=
name|mips_receive_header
argument_list|(
name|hdr
argument_list|,
operator|&
name|garbage
argument_list|,
name|ch
argument_list|,
name|mips_retransmit_wait
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
break|break;
name|ch
operator|=
literal|0
expr_stmt|;
comment|/* If we get a data packet, assume it is a duplicate and 	     ignore it.  FIXME: If the acknowledgement is lost, this 	     data packet may be the packet the remote sends after the 	     acknowledgement.  */
if|if
condition|(
name|HDR_IS_DATA
argument_list|(
name|hdr
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Ignore any errors raised whilst attempting to ignore 	         packet. */
name|len
operator|=
name|HDR_GET_LEN
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|int
name|rch
decl_stmt|;
name|rch
operator|=
name|mips_readchar
argument_list|(
name|remote_timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|rch
operator|==
name|SYN
condition|)
block|{
name|ch
operator|=
name|SYN
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rch
operator|==
name|SERIAL_TIMEOUT
condition|)
break|break;
comment|/* ignore the character */
block|}
if|if
condition|(
name|i
operator|==
name|len
condition|)
operator|(
name|void
operator|)
name|mips_receive_trailer
argument_list|(
name|trlr
argument_list|,
operator|&
name|garbage
argument_list|,
operator|&
name|ch
argument_list|,
name|remote_timeout
argument_list|)
expr_stmt|;
comment|/* We don't bother checking the checksum, or providing an 	         ACK to the packet. */
continue|continue;
block|}
comment|/* If the length is not 0, this is a garbled packet.  */
if|if
condition|(
name|HDR_GET_LEN
argument_list|(
name|hdr
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* Get the packet trailer.  */
name|err
operator|=
name|mips_receive_trailer
argument_list|(
name|trlr
argument_list|,
operator|&
name|garbage
argument_list|,
operator|&
name|ch
argument_list|,
name|mips_retransmit_wait
argument_list|)
expr_stmt|;
comment|/* If we timed out, resend the data packet.  */
if|if
condition|(
name|err
operator|==
operator|-
literal|1
condition|)
break|break;
comment|/* If we got a bad character, reread the header.  */
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
continue|continue;
comment|/* If the checksum does not match the trailer checksum, this 	     is a bad packet; ignore it.  */
if|if
condition|(
name|mips_cksum
argument_list|(
name|hdr
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
name|TRLR_GET_CKSUM
argument_list|(
name|trlr
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|remote_debug
operator|>
literal|0
condition|)
block|{
name|hdr
index|[
name|HDR_LENGTH
index|]
operator|=
literal|'\0'
expr_stmt|;
name|trlr
index|[
name|TRLR_LENGTH
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Don't use _filtered; we can't deal with a QUIT out of 	         target_wait, and I think this might be called from there.  */
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"Got ack %d \"%s%s\"\n"
argument_list|,
name|HDR_GET_SEQ
argument_list|(
name|hdr
argument_list|)
argument_list|,
name|hdr
operator|+
literal|1
argument_list|,
name|trlr
argument_list|)
expr_stmt|;
block|}
comment|/* If this ack is for the current packet, we're done.  */
name|seq
operator|=
name|HDR_GET_SEQ
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|seq
operator|==
name|mips_send_seq
condition|)
return|return;
comment|/* If this ack is for the last packet, resend the current 	     packet.  */
if|if
condition|(
operator|(
name|seq
operator|+
literal|1
operator|)
operator|%
name|SEQ_MODULOS
operator|==
name|mips_send_seq
condition|)
break|break;
comment|/* Otherwise this is a bad ack; ignore it.  Increment the 	     garbage count to ensure that we do not stay in this loop 	     forever.  */
operator|++
name|garbage
expr_stmt|;
block|}
block|}
name|mips_error
argument_list|(
literal|"Remote did not acknowledge packet"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Receive and acknowledge a packet, returning the data in BUFF (which    should be DATA_MAXLEN + 1 bytes).  The protocol documentation    implies that only the sender retransmits packets, so this code just    waits silently for a packet.  It returns the length of the received    packet.  If THROW_ERROR is nonzero, call error() on errors.  If not,    don't print an error message and return -1.  */
end_comment

begin_function
specifier|static
name|int
name|mips_receive_packet
parameter_list|(
name|char
modifier|*
name|buff
parameter_list|,
name|int
name|throw_error
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
name|int
name|garbage
decl_stmt|;
name|int
name|len
decl_stmt|;
name|unsigned
name|char
name|ack
index|[
name|HDR_LENGTH
operator|+
name|TRLR_LENGTH
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|cksum
decl_stmt|;
name|ch
operator|=
literal|0
expr_stmt|;
name|garbage
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|unsigned
name|char
name|hdr
index|[
name|HDR_LENGTH
index|]
decl_stmt|;
name|unsigned
name|char
name|trlr
index|[
name|TRLR_LENGTH
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|mips_receive_header
argument_list|(
name|hdr
argument_list|,
operator|&
name|garbage
argument_list|,
name|ch
argument_list|,
name|timeout
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|throw_error
condition|)
name|mips_error
argument_list|(
literal|"Timed out waiting for remote packet"
argument_list|)
expr_stmt|;
else|else
return|return
operator|-
literal|1
return|;
block|}
name|ch
operator|=
literal|0
expr_stmt|;
comment|/* An acknowledgement is probably a duplicate; ignore it.  */
if|if
condition|(
operator|!
name|HDR_IS_DATA
argument_list|(
name|hdr
argument_list|)
condition|)
block|{
name|len
operator|=
name|HDR_GET_LEN
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
comment|/* Check if the length is valid for an ACK, we may aswell 	     try and read the remainder of the packet: */
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
comment|/* Ignore the error condition, since we are going to 	         ignore the packet anyway. */
operator|(
name|void
operator|)
name|mips_receive_trailer
argument_list|(
name|trlr
argument_list|,
operator|&
name|garbage
argument_list|,
operator|&
name|ch
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
comment|/* Don't use _filtered; we can't deal with a QUIT out of 	     target_wait, and I think this might be called from there.  */
if|if
condition|(
name|remote_debug
operator|>
literal|0
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"Ignoring unexpected ACK\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|len
operator|=
name|HDR_GET_LEN
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|int
name|rch
decl_stmt|;
name|rch
operator|=
name|mips_readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|rch
operator|==
name|SYN
condition|)
block|{
name|ch
operator|=
name|SYN
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rch
operator|==
name|SERIAL_TIMEOUT
condition|)
block|{
if|if
condition|(
name|throw_error
condition|)
name|mips_error
argument_list|(
literal|"Timed out waiting for remote packet"
argument_list|)
expr_stmt|;
else|else
return|return
operator|-
literal|1
return|;
block|}
name|buff
index|[
name|i
index|]
operator|=
name|rch
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|len
condition|)
block|{
comment|/* Don't use _filtered; we can't deal with a QUIT out of 	     target_wait, and I think this might be called from there.  */
if|if
condition|(
name|remote_debug
operator|>
literal|0
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"Got new SYN after %d chars (wanted %d)\n"
argument_list|,
name|i
argument_list|,
name|len
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|err
operator|=
name|mips_receive_trailer
argument_list|(
name|trlr
argument_list|,
operator|&
name|garbage
argument_list|,
operator|&
name|ch
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|throw_error
condition|)
name|mips_error
argument_list|(
literal|"Timed out waiting for packet"
argument_list|)
expr_stmt|;
else|else
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|err
operator|==
operator|-
literal|2
condition|)
block|{
comment|/* Don't use _filtered; we can't deal with a QUIT out of 	     target_wait, and I think this might be called from there.  */
if|if
condition|(
name|remote_debug
operator|>
literal|0
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"Got SYN when wanted trailer\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If this is the wrong sequence number, ignore it.  */
if|if
condition|(
name|HDR_GET_SEQ
argument_list|(
name|hdr
argument_list|)
operator|!=
name|mips_receive_seq
condition|)
block|{
comment|/* Don't use _filtered; we can't deal with a QUIT out of 	     target_wait, and I think this might be called from there.  */
if|if
condition|(
name|remote_debug
operator|>
literal|0
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"Ignoring sequence number %d (want %d)\n"
argument_list|,
name|HDR_GET_SEQ
argument_list|(
name|hdr
argument_list|)
argument_list|,
name|mips_receive_seq
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|mips_cksum
argument_list|(
name|hdr
argument_list|,
name|buff
argument_list|,
name|len
argument_list|)
operator|==
name|TRLR_GET_CKSUM
argument_list|(
name|trlr
argument_list|)
condition|)
break|break;
if|if
condition|(
name|remote_debug
operator|>
literal|0
condition|)
comment|/* Don't use _filtered; we can't deal with a QUIT out of 	   target_wait, and I think this might be called from there.  */
name|printf_unfiltered
argument_list|(
literal|"Bad checksum; data %d, trailer %d\n"
argument_list|,
name|mips_cksum
argument_list|(
name|hdr
argument_list|,
name|buff
argument_list|,
name|len
argument_list|)
argument_list|,
name|TRLR_GET_CKSUM
argument_list|(
name|trlr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The checksum failed.  Send an acknowledgement for the          previous packet to tell the remote to resend the packet.  */
name|ack
index|[
name|HDR_INDX_SYN
index|]
operator|=
name|HDR_SET_SYN
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|mips_receive_seq
argument_list|)
expr_stmt|;
name|ack
index|[
name|HDR_INDX_TYPE_LEN
index|]
operator|=
name|HDR_SET_TYPE_LEN
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|mips_receive_seq
argument_list|)
expr_stmt|;
name|ack
index|[
name|HDR_INDX_LEN1
index|]
operator|=
name|HDR_SET_LEN1
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|mips_receive_seq
argument_list|)
expr_stmt|;
name|ack
index|[
name|HDR_INDX_SEQ
index|]
operator|=
name|HDR_SET_SEQ
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|mips_receive_seq
argument_list|)
expr_stmt|;
name|cksum
operator|=
name|mips_cksum
argument_list|(
name|ack
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ack
index|[
name|HDR_LENGTH
operator|+
name|TRLR_INDX_CSUM1
index|]
operator|=
name|TRLR_SET_CSUM1
argument_list|(
name|cksum
argument_list|)
expr_stmt|;
name|ack
index|[
name|HDR_LENGTH
operator|+
name|TRLR_INDX_CSUM2
index|]
operator|=
name|TRLR_SET_CSUM2
argument_list|(
name|cksum
argument_list|)
expr_stmt|;
name|ack
index|[
name|HDR_LENGTH
operator|+
name|TRLR_INDX_CSUM3
index|]
operator|=
name|TRLR_SET_CSUM3
argument_list|(
name|cksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_debug
operator|>
literal|0
condition|)
block|{
name|ack
index|[
name|HDR_LENGTH
operator|+
name|TRLR_LENGTH
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Don't use _filtered; we can't deal with a QUIT out of 	     target_wait, and I think this might be called from there.  */
name|printf_unfiltered
argument_list|(
literal|"Writing ack %d \"%s\"\n"
argument_list|,
name|mips_receive_seq
argument_list|,
name|ack
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|serial_write
argument_list|(
name|mips_desc
argument_list|,
name|ack
argument_list|,
name|HDR_LENGTH
operator|+
name|TRLR_LENGTH
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|throw_error
condition|)
name|mips_error
argument_list|(
literal|"write to target failed: %s"
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
operator|-
literal|1
return|;
block|}
block|}
if|if
condition|(
name|remote_debug
operator|>
literal|0
condition|)
block|{
name|buff
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Don't use _filtered; we can't deal with a QUIT out of          target_wait, and I think this might be called from there.  */
name|printf_unfiltered
argument_list|(
literal|"Got packet \"%s\"\n"
argument_list|,
name|buff
argument_list|)
expr_stmt|;
block|}
comment|/* We got the packet.  Send an acknowledgement.  */
name|mips_receive_seq
operator|=
operator|(
name|mips_receive_seq
operator|+
literal|1
operator|)
operator|%
name|SEQ_MODULOS
expr_stmt|;
name|ack
index|[
name|HDR_INDX_SYN
index|]
operator|=
name|HDR_SET_SYN
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|mips_receive_seq
argument_list|)
expr_stmt|;
name|ack
index|[
name|HDR_INDX_TYPE_LEN
index|]
operator|=
name|HDR_SET_TYPE_LEN
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|mips_receive_seq
argument_list|)
expr_stmt|;
name|ack
index|[
name|HDR_INDX_LEN1
index|]
operator|=
name|HDR_SET_LEN1
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|mips_receive_seq
argument_list|)
expr_stmt|;
name|ack
index|[
name|HDR_INDX_SEQ
index|]
operator|=
name|HDR_SET_SEQ
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|mips_receive_seq
argument_list|)
expr_stmt|;
name|cksum
operator|=
name|mips_cksum
argument_list|(
name|ack
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ack
index|[
name|HDR_LENGTH
operator|+
name|TRLR_INDX_CSUM1
index|]
operator|=
name|TRLR_SET_CSUM1
argument_list|(
name|cksum
argument_list|)
expr_stmt|;
name|ack
index|[
name|HDR_LENGTH
operator|+
name|TRLR_INDX_CSUM2
index|]
operator|=
name|TRLR_SET_CSUM2
argument_list|(
name|cksum
argument_list|)
expr_stmt|;
name|ack
index|[
name|HDR_LENGTH
operator|+
name|TRLR_INDX_CSUM3
index|]
operator|=
name|TRLR_SET_CSUM3
argument_list|(
name|cksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_debug
operator|>
literal|0
condition|)
block|{
name|ack
index|[
name|HDR_LENGTH
operator|+
name|TRLR_LENGTH
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Don't use _filtered; we can't deal with a QUIT out of          target_wait, and I think this might be called from there.  */
name|printf_unfiltered
argument_list|(
literal|"Writing ack %d \"%s\"\n"
argument_list|,
name|mips_receive_seq
argument_list|,
name|ack
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|serial_write
argument_list|(
name|mips_desc
argument_list|,
name|ack
argument_list|,
name|HDR_LENGTH
operator|+
name|TRLR_LENGTH
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|throw_error
condition|)
name|mips_error
argument_list|(
literal|"write to target failed: %s"
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
operator|-
literal|1
return|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Optionally send a request to the remote system and optionally wait    for the reply.  This implements the remote debugging protocol,    which is built on top of the packet protocol defined above.  Each    request has an ADDR argument and a DATA argument.  The following    requests are defined:     \0   don't send a request; just wait for a reply    i    read word from instruction space at ADDR    d    read word from data space at ADDR    I    write DATA to instruction space at ADDR    D    write DATA to data space at ADDR    r    read register number ADDR    R    set register number ADDR to value DATA    c    continue execution (if ADDR != 1, set pc to ADDR)    s    single step (if ADDR != 1, set pc to ADDR)     The read requests return the value requested.  The write requests    return the previous value in the changed location.  The execution    requests return a UNIX wait value (the approximate signal which    caused execution to stop is in the upper eight bits).     If PERR is not NULL, this function waits for a reply.  If an error    occurs, it sets *PERR to 1 and sets errno according to what the    target board reports.  */
end_comment

begin_function
specifier|static
name|ULONGEST
name|mips_request
parameter_list|(
name|int
name|cmd
parameter_list|,
name|ULONGEST
name|addr
parameter_list|,
name|ULONGEST
name|data
parameter_list|,
name|int
modifier|*
name|perr
parameter_list|,
name|int
name|timeout
parameter_list|,
name|char
modifier|*
name|buff
parameter_list|)
block|{
name|char
name|myBuff
index|[
name|DATA_MAXLEN
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|rpid
decl_stmt|;
name|char
name|rcmd
decl_stmt|;
name|int
name|rerrflg
decl_stmt|;
name|unsigned
name|long
name|rresponse
decl_stmt|;
if|if
condition|(
name|buff
operator|==
operator|(
name|char
operator|*
operator|)
name|NULL
condition|)
name|buff
operator|=
name|myBuff
expr_stmt|;
if|if
condition|(
name|cmd
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|mips_need_reply
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"mips_request: Trying to send command before reply"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"0x0 %c 0x%s 0x%s"
argument_list|,
name|cmd
argument_list|,
name|paddr_nz
argument_list|(
name|addr
argument_list|)
argument_list|,
name|paddr_nz
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|mips_send_packet
argument_list|(
name|buff
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mips_need_reply
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|perr
operator|==
operator|(
name|int
operator|*
operator|)
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|mips_need_reply
condition|)
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"mips_request: Trying to get reply before command"
argument_list|)
expr_stmt|;
name|mips_need_reply
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|mips_receive_packet
argument_list|(
name|buff
argument_list|,
literal|1
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|buff
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|buff
argument_list|,
literal|"0x%x %c 0x%x 0x%lx"
argument_list|,
operator|&
name|rpid
argument_list|,
operator|&
name|rcmd
argument_list|,
operator|&
name|rerrflg
argument_list|,
operator|&
name|rresponse
argument_list|)
operator|!=
literal|4
operator|||
operator|(
name|cmd
operator|!=
literal|'\0'
operator|&&
name|rcmd
operator|!=
name|cmd
operator|)
condition|)
name|mips_error
argument_list|(
literal|"Bad response from remote board"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rerrflg
operator|!=
literal|0
condition|)
block|{
operator|*
name|perr
operator|=
literal|1
expr_stmt|;
comment|/* FIXME: This will returns MIPS errno numbers, which may or may          not be the same as errno values used on other systems.  If          they stick to common errno values, they will be the same, but          if they don't, they must be translated.  */
name|errno
operator|=
name|rresponse
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|perr
operator|=
literal|0
expr_stmt|;
return|return
name|rresponse
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mips_initialize_cleanups
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|mips_initializing
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mips_exit_cleanups
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|mips_exiting
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mips_send_command
parameter_list|(
specifier|const
name|char
modifier|*
name|cmd
parameter_list|,
name|int
name|prompt
parameter_list|)
block|{
name|serial_write
argument_list|(
name|mips_desc
argument_list|,
name|cmd
argument_list|,
name|strlen
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|mips_expect
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|mips_expect
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prompt
condition|)
name|mips_expect
argument_list|(
name|mips_monitor_prompt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Enter remote (dbx) debug mode: */
end_comment

begin_function
specifier|static
name|void
name|mips_enter_debug
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Reset the sequence numbers, ready for the new debug sequence: */
name|mips_send_seq
operator|=
literal|0
expr_stmt|;
name|mips_receive_seq
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mips_monitor
operator|!=
name|MON_IDT
condition|)
name|mips_send_command
argument_list|(
literal|"debug\r"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
comment|/* assume IDT monitor by default */
name|mips_send_command
argument_list|(
literal|"db tty0\r"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|serial_write
argument_list|(
name|mips_desc
argument_list|,
literal|"\r"
argument_list|,
sizeof|sizeof
expr|"\r"
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* We don't need to absorb any spurious characters here, since the      mips_receive_header will eat up a reasonable number of characters      whilst looking for the SYN, however this avoids the "garbage"      being displayed to the user. */
if|if
condition|(
name|mips_monitor
operator|!=
name|MON_IDT
condition|)
name|mips_expect
argument_list|(
literal|"\r"
argument_list|)
expr_stmt|;
block|{
name|char
name|buff
index|[
name|DATA_MAXLEN
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|mips_receive_packet
argument_list|(
name|buff
argument_list|,
literal|1
argument_list|,
literal|3
argument_list|)
operator|<
literal|0
condition|)
name|mips_error
argument_list|(
literal|"Failed to initialize (didn't receive packet)."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Exit remote (dbx) debug mode, returning to the monitor prompt: */
end_comment

begin_function
specifier|static
name|int
name|mips_exit_debug
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_cleanups
init|=
name|make_cleanup
argument_list|(
name|mips_exit_cleanups
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|mips_exiting
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|mips_monitor
operator|!=
name|MON_IDT
condition|)
block|{
comment|/* The DDB (NEC) and MiniRISC (LSI) versions of PMON exit immediately,          so we do not get a reply to this command: */
name|mips_request
argument_list|(
literal|'x'
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|mips_receive_wait
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mips_need_reply
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|mips_expect
argument_list|(
literal|" break!"
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
else|else
name|mips_request
argument_list|(
literal|'x'
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|err
argument_list|,
name|mips_receive_wait
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mips_expect
argument_list|(
name|mips_monitor_prompt
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|do_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Initialize a new connection to the MIPS board, and make sure we are    really connected.  */
end_comment

begin_function
specifier|static
name|void
name|mips_initialize
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_cleanups
init|=
name|make_cleanup
argument_list|(
name|mips_initialize_cleanups
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* What is this code doing here?  I don't see any way it can happen, and      it might mean mips_initializing didn't get cleared properly.      So I'll make it a warning.  */
if|if
condition|(
name|mips_initializing
condition|)
block|{
name|warning
argument_list|(
literal|"internal error: mips_initialize called twice"
argument_list|)
expr_stmt|;
return|return;
block|}
name|mips_wait_flag
operator|=
literal|0
expr_stmt|;
name|mips_initializing
operator|=
literal|1
expr_stmt|;
comment|/* At this point, the packit protocol isn't responding.  We'll try getting      into the monitor, and restarting the protocol.  */
comment|/* Force the system into the monitor.  After this we *should* be at      the mips_monitor_prompt.  */
if|if
condition|(
name|mips_monitor
operator|!=
name|MON_IDT
condition|)
name|j
operator|=
literal|0
expr_stmt|;
comment|/* start by checking if we are already at the prompt */
else|else
name|j
operator|=
literal|1
expr_stmt|;
comment|/* start by sending a break */
for|for
control|(
init|;
name|j
operator|<=
literal|4
condition|;
name|j
operator|++
control|)
block|{
switch|switch
condition|(
name|j
condition|)
block|{
case|case
literal|0
case|:
comment|/* First, try sending a CR */
name|serial_flush_input
argument_list|(
name|mips_desc
argument_list|)
expr_stmt|;
name|serial_write
argument_list|(
name|mips_desc
argument_list|,
literal|"\r"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* First, try sending a break */
name|serial_send_break
argument_list|(
name|mips_desc
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* Then, try a ^C */
name|serial_write
argument_list|(
name|mips_desc
argument_list|,
literal|"\003"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* Then, try escaping from download */
block|{
if|if
condition|(
name|mips_monitor
operator|!=
name|MON_IDT
condition|)
block|{
name|char
name|tbuff
index|[
literal|7
index|]
decl_stmt|;
comment|/* We shouldn't need to send multiple termination 		   sequences, since the target performs line (or 		   block) reads, and then processes those 		   packets. In-case we were downloading a large packet 		   we flush the output buffer before inserting a 		   termination sequence. */
name|serial_flush_output
argument_list|(
name|mips_desc
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|tbuff
argument_list|,
literal|"\r/E/E\r"
argument_list|)
expr_stmt|;
name|serial_write
argument_list|(
name|mips_desc
argument_list|,
name|tbuff
argument_list|,
literal|6
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|srec
index|[
literal|10
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* We are possibly in binary download mode, having 		   aborted in the middle of an S-record.  ^C won't 		   work because of binary mode.  The only reliable way 		   out is to send enough termination packets (8 bytes) 		   to fill up and then overflow the largest size 		   S-record (255 bytes in this case).  This amounts to 		   256/8 + 1 packets. 		 */
name|mips_make_srec
argument_list|(
name|srec
argument_list|,
literal|'7'
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|33
condition|;
name|i
operator|++
control|)
block|{
name|serial_write
argument_list|(
name|mips_desc
argument_list|,
name|srec
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|serial_readchar
argument_list|(
name|mips_desc
argument_list|,
literal|0
argument_list|)
operator|>=
literal|0
condition|)
break|break;
comment|/* Break immediatly if we get something from 				   the board. */
block|}
block|}
block|}
break|break;
case|case
literal|4
case|:
name|mips_error
argument_list|(
literal|"Failed to initialize."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mips_expect
argument_list|(
name|mips_monitor_prompt
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|mips_monitor
operator|!=
name|MON_IDT
condition|)
block|{
comment|/* Sometimes PMON ignores the first few characters in the first          command sent after a load.  Sending a blank command gets          around that.  */
name|mips_send_command
argument_list|(
literal|"\r"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Ensure the correct target state: */
if|if
condition|(
name|mips_monitor
operator|!=
name|MON_LSI
condition|)
name|mips_send_command
argument_list|(
literal|"set regsize 64\r"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mips_send_command
argument_list|(
literal|"set hostport tty0\r"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mips_send_command
argument_list|(
literal|"set brkcmd \"\"\r"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Delete all the current breakpoints: */
name|mips_send_command
argument_list|(
literal|"db *\r"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTE: PMON does not have breakpoint support through the          "debug" mode, only at the monitor command-line. */
block|}
name|mips_enter_debug
argument_list|()
expr_stmt|;
comment|/* Clear all breakpoints: */
if|if
condition|(
operator|(
name|mips_monitor
operator|==
name|MON_IDT
operator|&&
name|clear_breakpoint
argument_list|(
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|BREAK_UNUSED
argument_list|)
operator|==
literal|0
operator|)
operator|||
name|mips_monitor
operator|==
name|MON_LSI
condition|)
name|monitor_supports_breakpoints
operator|=
literal|1
expr_stmt|;
else|else
name|monitor_supports_breakpoints
operator|=
literal|0
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_cleanups
argument_list|)
expr_stmt|;
comment|/* If this doesn't call error, we have connected; we don't care if      the request itself succeeds or fails.  */
name|mips_request
argument_list|(
literal|'r'
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|err
argument_list|,
name|mips_receive_wait
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Open a connection to the remote board.  */
end_comment

begin_function
specifier|static
name|void
name|common_open
parameter_list|(
name|struct
name|target_ops
modifier|*
name|ops
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|enum
name|mips_monitor_type
name|new_monitor
parameter_list|,
specifier|const
name|char
modifier|*
name|new_monitor_prompt
parameter_list|)
block|{
name|char
modifier|*
name|ptype
decl_stmt|;
name|char
modifier|*
name|serial_port_name
decl_stmt|;
name|char
modifier|*
name|remote_name
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|local_name
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
if|if
condition|(
name|name
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"To open a MIPS remote debugging connection, you need to specify what serial\n\ device is attached to the target board (e.g., /dev/ttya).\n"
literal|"If you want to use TFTP to download to the board, specify the name of a\n"
literal|"temporary file to be used by GDB for downloads as the second argument.\n"
literal|"This filename must be in the form host:filename, where host is the name\n"
literal|"of the host running the TFTP server, and the file must be readable by the\n"
literal|"world.  If the local name of the temporary file differs from the name as\n"
literal|"seen from the board via TFTP, specify that name as the third parameter.\n"
argument_list|)
expr_stmt|;
comment|/* Parse the serial port name, the optional TFTP name, and the      optional local TFTP name.  */
if|if
condition|(
operator|(
name|argv
operator|=
name|buildargv
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|nomem
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|make_cleanup_freeargv
argument_list|(
name|argv
argument_list|)
expr_stmt|;
name|serial_port_name
operator|=
name|xstrdup
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
index|[
literal|1
index|]
condition|)
comment|/* remote TFTP name specified? */
block|{
name|remote_name
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|argv
index|[
literal|2
index|]
condition|)
comment|/* local TFTP filename specified? */
name|local_name
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
block|}
name|target_preopen
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_is_open
condition|)
name|unpush_target
argument_list|(
name|current_ops
argument_list|)
expr_stmt|;
comment|/* Open and initialize the serial port.  */
name|mips_desc
operator|=
name|serial_open
argument_list|(
name|serial_port_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_desc
operator|==
name|NULL
condition|)
name|perror_with_name
argument_list|(
name|serial_port_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|baud_rate
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|serial_setbaudrate
argument_list|(
name|mips_desc
argument_list|,
name|baud_rate
argument_list|)
condition|)
block|{
name|serial_close
argument_list|(
name|mips_desc
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|serial_port_name
argument_list|)
expr_stmt|;
block|}
block|}
name|serial_raw
argument_list|(
name|mips_desc
argument_list|)
expr_stmt|;
comment|/* Open and initialize the optional download port.  If it is in the form      hostname#portnumber, it's a UDP socket.  If it is in the form      hostname:filename, assume it's the TFTP filename that must be      passed to the DDB board to tell it where to get the load file.  */
if|if
condition|(
name|remote_name
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|remote_name
argument_list|,
literal|'#'
argument_list|)
condition|)
block|{
name|udp_desc
operator|=
name|serial_open
argument_list|(
name|remote_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|udp_desc
condition|)
name|perror_with_name
argument_list|(
literal|"Unable to open UDP port"
argument_list|)
expr_stmt|;
name|udp_in_use
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Save the remote and local names of the TFTP temp file.  If 	     the user didn't specify a local name, assume it's the same 	     as the part of the remote name after the "host:".  */
if|if
condition|(
name|tftp_name
condition|)
name|xfree
argument_list|(
name|tftp_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tftp_localname
condition|)
name|xfree
argument_list|(
name|tftp_localname
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_name
operator|==
name|NULL
condition|)
if|if
condition|(
operator|(
name|local_name
operator|=
name|strchr
argument_list|(
name|remote_name
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|local_name
operator|++
expr_stmt|;
comment|/* skip over the colon */
if|if
condition|(
name|local_name
operator|==
name|NULL
condition|)
name|local_name
operator|=
name|remote_name
expr_stmt|;
comment|/* local name same as remote name */
name|tftp_name
operator|=
name|xstrdup
argument_list|(
name|remote_name
argument_list|)
expr_stmt|;
name|tftp_localname
operator|=
name|xstrdup
argument_list|(
name|local_name
argument_list|)
expr_stmt|;
name|tftp_in_use
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|current_ops
operator|=
name|ops
expr_stmt|;
name|mips_is_open
operator|=
literal|1
expr_stmt|;
comment|/* Reset the expected monitor prompt if it's never been set before.  */
if|if
condition|(
name|mips_monitor_prompt
operator|==
name|NULL
condition|)
name|mips_monitor_prompt
operator|=
name|xstrdup
argument_list|(
name|new_monitor_prompt
argument_list|)
expr_stmt|;
name|mips_monitor
operator|=
name|new_monitor
expr_stmt|;
name|mips_initialize
argument_list|()
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf_unfiltered
argument_list|(
literal|"Remote MIPS debugging using %s\n"
argument_list|,
name|serial_port_name
argument_list|)
expr_stmt|;
comment|/* Switch to using remote target now.  */
name|push_target
argument_list|(
name|ops
argument_list|)
expr_stmt|;
comment|/* FIXME: Should we call start_remote here?  */
comment|/* Try to figure out the processor model if possible.  */
name|deprecated_mips_set_processor_regs_hack
argument_list|()
expr_stmt|;
comment|/* This is really the job of start_remote however, that makes an      assumption that the target is about to print out a status message      of some sort.  That doesn't happen here (in fact, it may not be      possible to get the monitor to send the appropriate packet).  */
name|flush_cached_frames
argument_list|()
expr_stmt|;
name|registers_changed
argument_list|()
expr_stmt|;
name|stop_pc
operator|=
name|read_pc
argument_list|()
expr_stmt|;
name|print_stack_frame
argument_list|(
name|get_selected_frame
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|serial_port_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mips_open
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|monitor_prompt
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|TARGET_ARCHITECTURE
operator|!=
name|NULL
operator|&&
name|TARGET_ARCHITECTURE
operator|->
name|arch
operator|==
name|bfd_arch_mips
condition|)
block|{
switch|switch
condition|(
name|TARGET_ARCHITECTURE
operator|->
name|mach
condition|)
block|{
case|case
name|bfd_mach_mips4100
case|:
case|case
name|bfd_mach_mips4300
case|:
case|case
name|bfd_mach_mips4600
case|:
case|case
name|bfd_mach_mips4650
case|:
case|case
name|bfd_mach_mips5000
case|:
name|monitor_prompt
operator|=
literal|"<RISQ> "
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|monitor_prompt
operator|==
name|NULL
condition|)
name|monitor_prompt
operator|=
literal|"<IDT>"
expr_stmt|;
name|common_open
argument_list|(
operator|&
name|mips_ops
argument_list|,
name|name
argument_list|,
name|from_tty
argument_list|,
name|MON_IDT
argument_list|,
name|monitor_prompt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmon_open
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|common_open
argument_list|(
operator|&
name|pmon_ops
argument_list|,
name|name
argument_list|,
name|from_tty
argument_list|,
name|MON_PMON
argument_list|,
literal|"PMON> "
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ddb_open
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|common_open
argument_list|(
operator|&
name|ddb_ops
argument_list|,
name|name
argument_list|,
name|from_tty
argument_list|,
name|MON_DDB
argument_list|,
literal|"NEC010>"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lsi_open
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Clear the LSI breakpoint table.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_LSI_BREAKPOINTS
condition|;
name|i
operator|++
control|)
name|lsi_breakpoints
index|[
name|i
index|]
operator|.
name|type
operator|=
name|BREAK_UNUSED
expr_stmt|;
name|common_open
argument_list|(
operator|&
name|lsi_ops
argument_list|,
name|name
argument_list|,
name|from_tty
argument_list|,
name|MON_LSI
argument_list|,
literal|"PMON> "
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Close a connection to the remote board.  */
end_comment

begin_function
specifier|static
name|void
name|mips_close
parameter_list|(
name|int
name|quitting
parameter_list|)
block|{
if|if
condition|(
name|mips_is_open
condition|)
block|{
comment|/* Get the board out of remote debugging mode.  */
operator|(
name|void
operator|)
name|mips_exit_debug
argument_list|()
expr_stmt|;
name|close_ports
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Detach from the remote board.  */
end_comment

begin_function
specifier|static
name|void
name|mips_detach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|args
condition|)
name|error
argument_list|(
literal|"Argument given to \"detach\" when remotely debugging."
argument_list|)
expr_stmt|;
name|pop_target
argument_list|()
expr_stmt|;
name|mips_close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|printf_unfiltered
argument_list|(
literal|"Ending remote MIPS debugging.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Tell the target board to resume.  This does not wait for a reply    from the board, except in the case of single-stepping on LSI boards,    where PMON does return a reply.  */
end_comment

begin_function
specifier|static
name|void
name|mips_resume
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|step
parameter_list|,
name|enum
name|target_signal
name|siggnal
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
comment|/* LSI PMON requires returns a reply packet "0x1 s 0x0 0x57f" after      a single step, so we wait for that.  */
name|mips_request
argument_list|(
name|step
condition|?
literal|'s'
else|:
literal|'c'
argument_list|,
literal|1
argument_list|,
name|siggnal
argument_list|,
name|mips_monitor
operator|==
name|MON_LSI
operator|&&
name|step
condition|?
operator|&
name|err
else|:
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
name|mips_receive_wait
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the signal corresponding to SIG, where SIG is the number which    the MIPS protocol uses for the signal.  */
end_comment

begin_function
specifier|static
name|enum
name|target_signal
name|mips_signal_from_protocol
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
comment|/* We allow a few more signals than the IDT board actually returns, on      the theory that there is at least *some* hope that perhaps the numbering      for these signals is widely agreed upon.  */
if|if
condition|(
name|sig
operator|<=
literal|0
operator|||
name|sig
operator|>
literal|31
condition|)
return|return
name|TARGET_SIGNAL_UNKNOWN
return|;
comment|/* Don't want to use target_signal_from_host because we are converting      from MIPS signal numbers, not host ones.  Our internal numbers      match the MIPS numbers for the signals the board can return, which      are: SIGINT, SIGSEGV, SIGBUS, SIGILL, SIGFPE, SIGTRAP.  */
return|return
operator|(
expr|enum
name|target_signal
operator|)
name|sig
return|;
block|}
end_function

begin_comment
comment|/* Wait until the remote stops, and return a wait status.  */
end_comment

begin_function
specifier|static
name|ptid_t
name|mips_wait
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
name|status
parameter_list|)
block|{
name|int
name|rstatus
decl_stmt|;
name|int
name|err
decl_stmt|;
name|char
name|buff
index|[
name|DATA_MAXLEN
index|]
decl_stmt|;
name|int
name|rpc
decl_stmt|,
name|rfp
decl_stmt|,
name|rsp
decl_stmt|;
name|char
name|flags
index|[
literal|20
index|]
decl_stmt|;
name|int
name|nfields
decl_stmt|;
name|int
name|i
decl_stmt|;
name|interrupt_count
operator|=
literal|0
expr_stmt|;
name|hit_watchpoint
operator|=
literal|0
expr_stmt|;
comment|/* If we have not sent a single step or continue command, then the      board is waiting for us to do something.  Return a status      indicating that it is stopped.  */
if|if
condition|(
operator|!
name|mips_need_reply
condition|)
block|{
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
return|return
name|inferior_ptid
return|;
block|}
comment|/* No timeout; we sit here as long as the program continues to execute.  */
name|mips_wait_flag
operator|=
literal|1
expr_stmt|;
name|rstatus
operator|=
name|mips_request
argument_list|(
literal|'\000'
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|err
argument_list|,
operator|-
literal|1
argument_list|,
name|buff
argument_list|)
expr_stmt|;
name|mips_wait_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mips_error
argument_list|(
literal|"Remote failure: %s"
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* On returning from a continue, the PMON monitor seems to start      echoing back the messages we send prior to sending back the      ACK. The code can cope with this, but to try and avoid the      unnecessary serial traffic, and "spurious" characters displayed      to the user, we cheat and reset the debug protocol. The problems      seems to be caused by a check on the number of arguments, and the      command length, within the monitor causing it to echo the command      as a bad packet. */
if|if
condition|(
name|mips_monitor
operator|==
name|MON_PMON
condition|)
block|{
name|mips_exit_debug
argument_list|()
expr_stmt|;
name|mips_enter_debug
argument_list|()
expr_stmt|;
block|}
comment|/* See if we got back extended status.  If so, pick out the pc, fp, sp, etc... */
name|nfields
operator|=
name|sscanf
argument_list|(
name|buff
argument_list|,
literal|"0x%*x %*c 0x%*x 0x%*x 0x%x 0x%x 0x%x 0x%*x %s"
argument_list|,
operator|&
name|rpc
argument_list|,
operator|&
name|rfp
argument_list|,
operator|&
name|rsp
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfields
operator|>=
literal|3
condition|)
block|{
name|char
name|buf
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|PC_REGNUM
argument_list|)
argument_list|,
name|rpc
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|PC_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|PC_REGNUM
argument_list|)
argument_list|,
name|rfp
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
literal|30
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* This register they are avoiding and so it is unnamed */
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|SP_REGNUM
argument_list|)
argument_list|,
name|rsp
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|DEPRECATED_FP_REGNUM
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|DEPRECATED_FP_REGNUM
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfields
operator|==
literal|9
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|2
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|flags
index|[
name|i
index|]
operator|==
literal|'r'
operator|||
name|flags
index|[
name|i
index|]
operator|==
literal|'w'
condition|)
name|hit_watchpoint
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
index|[
name|i
index|]
operator|==
literal|'\000'
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|target_shortname
argument_list|,
literal|"lsi"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
literal|0
comment|/* If this is an LSI PMON target, see if we just hit a hardrdware watchpoint.          Right now, PMON doesn't give us enough information to determine which          breakpoint we hit.  So we have to look up the PC in our own table          of breakpoints, and if found, assume it's just a normal instruction          fetch breakpoint, not a data watchpoint.  FIXME when PMON          provides some way to tell us what type of breakpoint it is.  */
block|int i;       CORE_ADDR pc = read_pc ();        hit_watchpoint = 1;       for (i = 0; i< MAX_LSI_BREAKPOINTS; i++) 	{ 	  if (lsi_breakpoints[i].addr == pc&& lsi_breakpoints[i].type == BREAK_FETCH) 	    { 	      hit_watchpoint = 0; 	      break; 	    } 	}
else|#
directive|else
comment|/* If a data breakpoint was hit, PMON returns the following packet:          0x1 c 0x0 0x57f 0x1          The return packet from an ordinary breakpoint doesn't have the          extra 0x01 field tacked onto the end.  */
if|if
condition|(
name|nfields
operator|==
literal|1
operator|&&
name|rpc
operator|==
literal|1
condition|)
name|hit_watchpoint
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* NOTE: The following (sig) numbers are defined by PMON:      SPP_SIGTRAP     5       breakpoint      SPP_SIGINT      2      SPP_SIGSEGV     11      SPP_SIGBUS      10      SPP_SIGILL      4      SPP_SIGFPE      8      SPP_SIGTERM     15 */
comment|/* Translate a MIPS waitstatus.  We use constants here rather than WTERMSIG      and so on, because the constants we want here are determined by the      MIPS protocol and have nothing to do with what host we are running on.  */
if|if
condition|(
operator|(
name|rstatus
operator|&
literal|0xff
operator|)
operator|==
literal|0
condition|)
block|{
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|integer
operator|=
operator|(
operator|(
operator|(
name|rstatus
operator|)
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|rstatus
operator|&
literal|0xff
operator|)
operator|==
literal|0x7f
condition|)
block|{
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|mips_signal_from_protocol
argument_list|(
operator|(
operator|(
name|rstatus
operator|)
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
comment|/* If the stop PC is in the _exit function, assume          we hit the 'break 0x3ff' instruction in _exit, so this          is not a normal breakpoint.  */
if|if
condition|(
name|strcmp
argument_list|(
name|target_shortname
argument_list|,
literal|"lsi"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|func_name
decl_stmt|;
name|CORE_ADDR
name|func_start
decl_stmt|;
name|CORE_ADDR
name|pc
init|=
name|read_pc
argument_list|()
decl_stmt|;
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
operator|&
name|func_name
argument_list|,
operator|&
name|func_start
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|func_name
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|func_name
argument_list|,
literal|"_exit"
argument_list|)
operator|==
literal|0
operator|&&
name|func_start
operator|==
name|pc
condition|)
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
block|}
block|}
else|else
block|{
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_SIGNALLED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|mips_signal_from_protocol
argument_list|(
name|rstatus
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
block|}
return|return
name|inferior_ptid
return|;
block|}
end_function

begin_comment
comment|/* We have to map between the register numbers used by gdb and the    register numbers used by the debugging protocol.  This function    assumes that we are using tm-mips.h.  */
end_comment

begin_define
define|#
directive|define
name|REGNO_OFFSET
value|96
end_define

begin_function
specifier|static
name|int
name|mips_map_regno
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
name|regno
operator|<
literal|32
condition|)
return|return
name|regno
return|;
if|if
condition|(
name|regno
operator|>=
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|fp0
operator|&&
name|regno
operator|<
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|fp0
operator|+
literal|32
condition|)
return|return
name|regno
operator|-
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|fp0
operator|+
literal|32
return|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|pc
condition|)
return|return
name|REGNO_OFFSET
operator|+
literal|0
return|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|cause
condition|)
return|return
name|REGNO_OFFSET
operator|+
literal|1
return|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|hi
condition|)
return|return
name|REGNO_OFFSET
operator|+
literal|2
return|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|lo
condition|)
return|return
name|REGNO_OFFSET
operator|+
literal|3
return|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|fp_control_status
condition|)
return|return
name|REGNO_OFFSET
operator|+
literal|4
return|;
elseif|else
if|if
condition|(
name|regno
operator|==
name|mips_regnum
argument_list|(
name|current_gdbarch
argument_list|)
operator|->
name|fp_implementation_revision
condition|)
return|return
name|REGNO_OFFSET
operator|+
literal|5
return|;
else|else
comment|/* FIXME: Is there a way to get the status register?  */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Fetch the remote registers.  */
end_comment

begin_function
specifier|static
name|void
name|mips_fetch_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|unsigned
name|LONGEST
name|val
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
name|mips_fetch_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|regno
operator|==
name|DEPRECATED_FP_REGNUM
operator|||
name|regno
operator|==
name|ZERO_REGNUM
condition|)
comment|/* DEPRECATED_FP_REGNUM on the mips is a hack which is just        supposed to read zero (see also mips-nat.c).  */
name|val
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* If PMON doesn't support this register, don't waste serial          bandwidth trying to read it.  */
name|int
name|pmon_reg
init|=
name|mips_map_regno
argument_list|(
name|regno
argument_list|)
decl_stmt|;
if|if
condition|(
name|regno
operator|!=
literal|0
operator|&&
name|pmon_reg
operator|==
literal|0
condition|)
name|val
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* Unfortunately the PMON version in the Vr4300 board has been 	     compiled without the 64bit register access commands. This 	     means we cannot get hold of the full register width. */
if|if
condition|(
name|mips_monitor
operator|==
name|MON_DDB
condition|)
name|val
operator|=
operator|(
name|unsigned
operator|)
name|mips_request
argument_list|(
literal|'t'
argument_list|,
name|pmon_reg
argument_list|,
literal|0
argument_list|,
operator|&
name|err
argument_list|,
name|mips_receive_wait
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
name|mips_request
argument_list|(
literal|'r'
argument_list|,
name|pmon_reg
argument_list|,
literal|0
argument_list|,
operator|&
name|err
argument_list|,
name|mips_receive_wait
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mips_error
argument_list|(
literal|"Can't read register %d: %s"
argument_list|,
name|regno
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|{
name|char
name|buf
index|[
name|MAX_REGISTER_SIZE
index|]
decl_stmt|;
comment|/* We got the number the register holds, but gdb expects to see a        value in the target byte ordering.  */
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|DEPRECATED_REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Prepare to store registers.  The MIPS protocol can store individual    registers, so this function doesn't have to do anything.  */
end_comment

begin_function
specifier|static
name|void
name|mips_prepare_to_store
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_comment
comment|/* Store remote register(s).  */
end_comment

begin_function
specifier|static
name|void
name|mips_store_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
name|mips_store_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
return|return;
block|}
name|mips_request
argument_list|(
literal|'R'
argument_list|,
name|mips_map_regno
argument_list|(
name|regno
argument_list|)
argument_list|,
name|read_register
argument_list|(
name|regno
argument_list|)
argument_list|,
operator|&
name|err
argument_list|,
name|mips_receive_wait
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mips_error
argument_list|(
literal|"Can't write register %d: %s"
argument_list|,
name|regno
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fetch a word from the target board.  */
end_comment

begin_function
specifier|static
name|unsigned
name|int
name|mips_fetch_word
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|)
block|{
name|unsigned
name|int
name|val
decl_stmt|;
name|int
name|err
decl_stmt|;
name|val
operator|=
name|mips_request
argument_list|(
literal|'d'
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|,
operator|&
name|err
argument_list|,
name|mips_receive_wait
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* Data space failed; try instruction space.  */
name|val
operator|=
name|mips_request
argument_list|(
literal|'i'
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|,
operator|&
name|err
argument_list|,
name|mips_receive_wait
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mips_error
argument_list|(
literal|"Can't read address 0x%s: %s"
argument_list|,
name|paddr_nz
argument_list|(
name|addr
argument_list|)
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Store a word to the target board.  Returns errno code or zero for    success.  If OLD_CONTENTS is non-NULL, put the old contents of that    memory location there.  */
end_comment

begin_comment
comment|/* FIXME! make sure only 32-bit quantities get stored! */
end_comment

begin_function
specifier|static
name|int
name|mips_store_word
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|unsigned
name|int
name|val
parameter_list|,
name|char
modifier|*
name|old_contents
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|unsigned
name|int
name|oldcontents
decl_stmt|;
name|oldcontents
operator|=
name|mips_request
argument_list|(
literal|'D'
argument_list|,
name|addr
argument_list|,
name|val
argument_list|,
operator|&
name|err
argument_list|,
name|mips_receive_wait
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* Data space failed; try instruction space.  */
name|oldcontents
operator|=
name|mips_request
argument_list|(
literal|'I'
argument_list|,
name|addr
argument_list|,
name|val
argument_list|,
operator|&
name|err
argument_list|,
name|mips_receive_wait
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|errno
return|;
block|}
if|if
condition|(
name|old_contents
operator|!=
name|NULL
condition|)
name|store_unsigned_integer
argument_list|(
name|old_contents
argument_list|,
literal|4
argument_list|,
name|oldcontents
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Read or write LEN bytes from inferior memory at MEMADDR,    transferring to or from debugger address MYADDR.  Write to inferior    if SHOULD_WRITE is nonzero.  Returns length of data written or    read; 0 for error.  Note that protocol gives us the correct value    for a longword, since it transfers values in ASCII.  We want the    byte values, so we have to swap the longword values.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mask_address_p
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|mips_xfer_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|write
parameter_list|,
name|struct
name|mem_attrib
modifier|*
name|attrib
parameter_list|,
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|count
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|int
name|status
decl_stmt|;
comment|/* PMON targets do not cope well with 64 bit addresses.  Mask the      value down to 32 bits. */
if|if
condition|(
name|mask_address_p
condition|)
name|memaddr
operator|&=
operator|(
name|CORE_ADDR
operator|)
literal|0xffffffff
expr_stmt|;
comment|/* Round starting address down to longword boundary.  */
name|addr
operator|=
name|memaddr
operator|&
operator|~
literal|3
expr_stmt|;
comment|/* Round ending address up; get number of longwords that makes.  */
name|count
operator|=
operator|(
operator|(
operator|(
name|memaddr
operator|+
name|len
operator|)
operator|-
name|addr
operator|)
operator|+
literal|3
operator|)
operator|/
literal|4
expr_stmt|;
comment|/* Allocate buffer of that many longwords.  */
name|buffer
operator|=
name|alloca
argument_list|(
name|count
operator|*
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
condition|)
block|{
comment|/* Fill start and end extra bytes of buffer with existing data.  */
if|if
condition|(
name|addr
operator|!=
name|memaddr
operator|||
name|len
operator|<
literal|4
condition|)
block|{
comment|/* Need part of initial word -- fetch it.  */
name|store_unsigned_integer
argument_list|(
operator|&
name|buffer
index|[
literal|0
index|]
argument_list|,
literal|4
argument_list|,
name|mips_fetch_word
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|>
literal|1
condition|)
block|{
comment|/* Need part of last word -- fetch it.  FIXME: we do this even 	     if we don't need it.  */
name|store_unsigned_integer
argument_list|(
operator|&
name|buffer
index|[
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
literal|4
index|]
argument_list|,
literal|4
argument_list|,
name|mips_fetch_word
argument_list|(
name|addr
operator|+
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
literal|4
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Copy data to be written over corresponding part of buffer */
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buffer
operator|+
operator|(
name|memaddr
operator|&
literal|3
operator|)
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Write the entire buffer.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|addr
operator|+=
literal|4
control|)
block|{
name|status
operator|=
name|mips_store_word
argument_list|(
name|addr
argument_list|,
name|extract_unsigned_integer
argument_list|(
operator|&
name|buffer
index|[
name|i
operator|*
literal|4
index|]
argument_list|,
literal|4
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Report each kilobyte (we download 32-bit words at a time) */
if|if
condition|(
name|i
operator|%
literal|256
operator|==
literal|255
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"*"
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
condition|)
block|{
name|errno
operator|=
name|status
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* FIXME: Do we want a QUIT here?  */
block|}
if|if
condition|(
name|count
operator|>=
literal|256
condition|)
name|printf_unfiltered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Read all the longwords */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|addr
operator|+=
literal|4
control|)
block|{
name|store_unsigned_integer
argument_list|(
operator|&
name|buffer
index|[
name|i
operator|*
literal|4
index|]
argument_list|,
literal|4
argument_list|,
name|mips_fetch_word
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|QUIT
expr_stmt|;
block|}
comment|/* Copy appropriate bytes out of the buffer.  */
name|memcpy
argument_list|(
name|myaddr
argument_list|,
name|buffer
operator|+
operator|(
name|memaddr
operator|&
literal|3
operator|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* Print info on this target.  */
end_comment

begin_function
specifier|static
name|void
name|mips_files_info
parameter_list|(
name|struct
name|target_ops
modifier|*
name|ignore
parameter_list|)
block|{
name|printf_unfiltered
argument_list|(
literal|"Debugging a MIPS board over a serial line.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Kill the process running on the board.  This will actually only    work if we are doing remote debugging over the console input.  I    think that if IDT/sim had the remote debug interrupt enabled on the    right port, we could interrupt the process with a break signal.  */
end_comment

begin_function
specifier|static
name|void
name|mips_kill
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mips_wait_flag
condition|)
return|return;
name|interrupt_count
operator|++
expr_stmt|;
if|if
condition|(
name|interrupt_count
operator|>=
literal|2
condition|)
block|{
name|interrupt_count
operator|=
literal|0
expr_stmt|;
name|target_terminal_ours
argument_list|()
expr_stmt|;
if|if
condition|(
name|query
argument_list|(
literal|"Interrupted while waiting for the program.\n\ Give up (and stop debugging it)? "
argument_list|)
condition|)
block|{
comment|/* Clean up in such a way that mips_close won't try to talk to the 	     board (it almost surely won't work since we weren't able to talk to 	     it).  */
name|mips_wait_flag
operator|=
literal|0
expr_stmt|;
name|close_ports
argument_list|()
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"Ending remote MIPS debugging.\n"
argument_list|)
expr_stmt|;
name|target_mourn_inferior
argument_list|()
expr_stmt|;
name|throw_exception
argument_list|(
name|RETURN_QUIT
argument_list|)
expr_stmt|;
block|}
name|target_terminal_inferior
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|remote_debug
operator|>
literal|0
condition|)
name|printf_unfiltered
argument_list|(
literal|"Sending break\n"
argument_list|)
expr_stmt|;
name|serial_send_break
argument_list|(
name|mips_desc
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (mips_is_open)     {       char cc;
comment|/* Send a ^C.  */
block|cc = '\003';       serial_write (mips_desc,&cc, 1);       sleep (1);       target_mourn_inferior ();     }
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Start running on the target board.  */
end_comment

begin_function
specifier|static
name|void
name|mips_create_inferior
parameter_list|(
name|char
modifier|*
name|execfile
parameter_list|,
name|char
modifier|*
name|args
parameter_list|,
name|char
modifier|*
modifier|*
name|env
parameter_list|)
block|{
name|CORE_ADDR
name|entry_pt
decl_stmt|;
if|if
condition|(
name|args
operator|&&
operator|*
name|args
condition|)
block|{
name|warning
argument_list|(
literal|"\ Can't pass arguments to remote MIPS board; arguments ignored."
argument_list|)
expr_stmt|;
comment|/* And don't try to use them on the next "run" command.  */
name|execute_command
argument_list|(
literal|"set args"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|execfile
operator|==
literal|0
operator|||
name|exec_bfd
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No executable file specified"
argument_list|)
expr_stmt|;
name|entry_pt
operator|=
operator|(
name|CORE_ADDR
operator|)
name|bfd_get_start_address
argument_list|(
name|exec_bfd
argument_list|)
expr_stmt|;
name|init_wait_for_inferior
argument_list|()
expr_stmt|;
comment|/* FIXME: Should we set inferior_ptid here?  */
name|proceed
argument_list|(
name|entry_pt
argument_list|,
name|TARGET_SIGNAL_DEFAULT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clean up after a process.  Actually nothing to do.  */
end_comment

begin_function
specifier|static
name|void
name|mips_mourn_inferior
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|current_ops
operator|!=
name|NULL
condition|)
name|unpush_target
argument_list|(
name|current_ops
argument_list|)
expr_stmt|;
name|generic_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* We can write a breakpoint and read the shadow contents in one    operation.  */
end_comment

begin_comment
comment|/* Insert a breakpoint.  On targets that don't have built-in    breakpoint support, we read the contents of the target location and    stash it, then overwrite it with a breakpoint instruction.  ADDR is    the target location in the target machine.  CONTENTS_CACHE is a    pointer to memory allocated for saving the target contents.  It is    guaranteed by the caller to be long enough to save the breakpoint    length returned by BREAKPOINT_FROM_PC.  */
end_comment

begin_function
specifier|static
name|int
name|mips_insert_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|contents_cache
parameter_list|)
block|{
if|if
condition|(
name|monitor_supports_breakpoints
condition|)
return|return
name|set_breakpoint
argument_list|(
name|addr
argument_list|,
name|MIPS_INSTLEN
argument_list|,
name|BREAK_FETCH
argument_list|)
return|;
else|else
return|return
name|memory_insert_breakpoint
argument_list|(
name|addr
argument_list|,
name|contents_cache
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mips_remove_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|contents_cache
parameter_list|)
block|{
if|if
condition|(
name|monitor_supports_breakpoints
condition|)
return|return
name|clear_breakpoint
argument_list|(
name|addr
argument_list|,
name|MIPS_INSTLEN
argument_list|,
name|BREAK_FETCH
argument_list|)
return|;
else|else
return|return
name|memory_remove_breakpoint
argument_list|(
name|addr
argument_list|,
name|contents_cache
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Tell whether this target can support a hardware breakpoint.  CNT    is the number of hardware breakpoints already installed.  This    implements the TARGET_CAN_USE_HARDWARE_WATCHPOINT macro.  */
end_comment

begin_function
name|int
name|mips_can_use_watchpoint
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|cnt
parameter_list|,
name|int
name|othertype
parameter_list|)
block|{
return|return
name|cnt
operator|<
name|MAX_LSI_BREAKPOINTS
operator|&&
name|strcmp
argument_list|(
name|target_shortname
argument_list|,
literal|"lsi"
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Compute a don't care mask for the region bounding ADDR and ADDR + LEN - 1.    This is used for memory ref breakpoints.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|calculate_mask
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|unsigned
name|long
name|mask
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mask
operator|=
name|addr
operator|^
operator|(
name|addr
operator|+
name|len
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|32
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
break|break;
else|else
name|mask
operator|>>=
literal|1
expr_stmt|;
name|mask
operator|=
operator|(
name|unsigned
name|long
operator|)
literal|0xffffffff
operator|>>
name|i
expr_stmt|;
return|return
name|mask
return|;
block|}
end_function

begin_comment
comment|/* Set a data watchpoint.  ADDR and LEN should be obvious.  TYPE is 0    for a write watchpoint, 1 for a read watchpoint, or 2 for a read/write    watchpoint. */
end_comment

begin_function
name|int
name|mips_insert_watchpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|type
parameter_list|)
block|{
if|if
condition|(
name|set_breakpoint
argument_list|(
name|addr
argument_list|,
name|len
argument_list|,
name|type
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mips_remove_watchpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|type
parameter_list|)
block|{
if|if
condition|(
name|clear_breakpoint
argument_list|(
name|addr
argument_list|,
name|len
argument_list|,
name|type
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mips_stopped_by_watchpoint
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|hit_watchpoint
return|;
block|}
end_function

begin_comment
comment|/* Insert a breakpoint.  */
end_comment

begin_function
specifier|static
name|int
name|set_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|int
name|len
parameter_list|,
name|enum
name|break_type
name|type
parameter_list|)
block|{
return|return
name|common_breakpoint
argument_list|(
literal|1
argument_list|,
name|addr
argument_list|,
name|len
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Clear a breakpoint.  */
end_comment

begin_function
specifier|static
name|int
name|clear_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|int
name|len
parameter_list|,
name|enum
name|break_type
name|type
parameter_list|)
block|{
return|return
name|common_breakpoint
argument_list|(
literal|0
argument_list|,
name|addr
argument_list|,
name|len
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Check the error code from the return packet for an LSI breakpoint    command.  If there's no error, just return 0.  If it's a warning,    print the warning text and return 0.  If it's an error, print    the error text and return 1.<ADDR> is the address of the breakpoint    that was being set.<RERRFLG> is the error code returned by PMON.     This is a helper function for common_breakpoint.  */
end_comment

begin_function
specifier|static
name|int
name|check_lsi_error
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|int
name|rerrflg
parameter_list|)
block|{
name|struct
name|lsi_error
modifier|*
name|err
decl_stmt|;
name|char
modifier|*
name|saddr
init|=
name|paddr_nz
argument_list|(
name|addr
argument_list|)
decl_stmt|;
comment|/* printable address string */
if|if
condition|(
name|rerrflg
operator|==
literal|0
condition|)
comment|/* no error */
return|return
literal|0
return|;
comment|/* Warnings can be ORed together, so check them all.  */
if|if
condition|(
name|rerrflg
operator|&
name|W_WARN
condition|)
block|{
if|if
condition|(
name|monitor_warnings
condition|)
block|{
name|int
name|found
init|=
literal|0
decl_stmt|;
for|for
control|(
name|err
operator|=
name|lsi_warning_table
init|;
name|err
operator|->
name|code
operator|!=
literal|0
condition|;
name|err
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|err
operator|->
name|code
operator|&
name|rerrflg
operator|)
operator|==
name|err
operator|->
name|code
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"common_breakpoint (0x%s): Warning: %s\n"
argument_list|,
name|saddr
argument_list|,
name|err
operator|->
name|string
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"common_breakpoint (0x%s): Unknown warning: 0x%x\n"
argument_list|,
name|saddr
argument_list|,
name|rerrflg
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/* Errors are unique, i.e. can't be ORed together.  */
for|for
control|(
name|err
operator|=
name|lsi_error_table
init|;
name|err
operator|->
name|code
operator|!=
literal|0
condition|;
name|err
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|err
operator|->
name|code
operator|&
name|rerrflg
operator|)
operator|==
name|err
operator|->
name|code
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"common_breakpoint (0x%s): Error: %s\n"
argument_list|,
name|saddr
argument_list|,
name|err
operator|->
name|string
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"common_breakpoint (0x%s): Unknown error: 0x%x\n"
argument_list|,
name|saddr
argument_list|,
name|rerrflg
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* This routine sends a breakpoint command to the remote target.<SET> is 1 if setting a breakpoint, or 0 if clearing a breakpoint.<ADDR> is the address of the breakpoint.<LEN> the length of the region to break on.<TYPE> is the type of breakpoint:    0 = write                    (BREAK_WRITE)    1 = read                     (BREAK_READ)    2 = read/write               (BREAK_ACCESS)    3 = instruction fetch        (BREAK_FETCH)     Return 0 if successful; otherwise 1.  */
end_comment

begin_function
specifier|static
name|int
name|common_breakpoint
parameter_list|(
name|int
name|set
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|,
name|int
name|len
parameter_list|,
name|enum
name|break_type
name|type
parameter_list|)
block|{
name|char
name|buf
index|[
name|DATA_MAXLEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|cmd
decl_stmt|,
name|rcmd
decl_stmt|;
name|int
name|rpid
decl_stmt|,
name|rerrflg
decl_stmt|,
name|rresponse
decl_stmt|,
name|rlen
decl_stmt|;
name|int
name|nfields
decl_stmt|;
name|addr
operator|=
name|ADDR_BITS_REMOVE
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_monitor
operator|==
name|MON_LSI
condition|)
block|{
if|if
condition|(
name|set
operator|==
literal|0
condition|)
comment|/* clear breakpoint */
block|{
comment|/* The LSI PMON "clear breakpoint" has this form:<pid> 'b'<bptn> 0x0 	     reply:<pid> 'b' 0x0<code><bptn> is a breakpoint number returned by an earlier 'B' command. 	     Possible return codes: OK, E_BPT.  */
name|int
name|i
decl_stmt|;
comment|/* Search for the breakpoint in the table.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_LSI_BREAKPOINTS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|lsi_breakpoints
index|[
name|i
index|]
operator|.
name|type
operator|==
name|type
operator|&&
name|lsi_breakpoints
index|[
name|i
index|]
operator|.
name|addr
operator|==
name|addr
operator|&&
name|lsi_breakpoints
index|[
name|i
index|]
operator|.
name|len
operator|==
name|len
condition|)
break|break;
comment|/* Clear the table entry and tell PMON to clear the breakpoint.  */
if|if
condition|(
name|i
operator|==
name|MAX_LSI_BREAKPOINTS
condition|)
block|{
name|warning
argument_list|(
literal|"common_breakpoint: Attempt to clear bogus breakpoint at %s\n"
argument_list|,
name|paddr_nz
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|lsi_breakpoints
index|[
name|i
index|]
operator|.
name|type
operator|=
name|BREAK_UNUSED
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"0x0 b 0x%x 0x0"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|mips_send_packet
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rlen
operator|=
name|mips_receive_packet
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|mips_receive_wait
argument_list|)
expr_stmt|;
name|buf
index|[
name|rlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|nfields
operator|=
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"0x%x b 0x0 0x%x"
argument_list|,
operator|&
name|rpid
argument_list|,
operator|&
name|rerrflg
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfields
operator|!=
literal|2
condition|)
name|mips_error
argument_list|(
literal|"common_breakpoint: Bad response from remote board: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|check_lsi_error
argument_list|(
name|addr
argument_list|,
name|rerrflg
argument_list|)
operator|)
return|;
block|}
else|else
comment|/* set a breakpoint */
block|{
comment|/* The LSI PMON "set breakpoint" command has this form:<pid> 'B'<addr> 0x0 	     reply:<pid> 'B'<bptn><code>  	     The "set data breakpoint" command has this form:<pid> 'A'<addr1><type> [<addr2>  [<value>]]  	     where: type= "0x1" = read 	     "0x2" = write 	     "0x3" = access (read or write)  	     The reply returns two values: 	     bptn - a breakpoint number, which is a small integer with 	     possible values of zero through 255. 	     code - an error return code, a value of zero indicates a 	     succesful completion, other values indicate various 	     errors and warnings.  	     Possible return codes: OK, W_QAL, E_QAL, E_OUT, E_NON.    	   */
if|if
condition|(
name|type
operator|==
name|BREAK_FETCH
condition|)
comment|/* instruction breakpoint */
block|{
name|cmd
operator|=
literal|'B'
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"0x0 B 0x%s 0x0"
argument_list|,
name|paddr_nz
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* watchpoint */
block|{
name|cmd
operator|=
literal|'A'
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"0x0 A 0x%s 0x%x 0x%s"
argument_list|,
name|paddr_nz
argument_list|(
name|addr
argument_list|)
argument_list|,
name|type
operator|==
name|BREAK_READ
condition|?
literal|1
else|:
operator|(
name|type
operator|==
name|BREAK_WRITE
condition|?
literal|2
else|:
literal|3
operator|)
argument_list|,
name|paddr_nz
argument_list|(
name|addr
operator|+
name|len
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mips_send_packet
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rlen
operator|=
name|mips_receive_packet
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|mips_receive_wait
argument_list|)
expr_stmt|;
name|buf
index|[
name|rlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|nfields
operator|=
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"0x%x %c 0x%x 0x%x"
argument_list|,
operator|&
name|rpid
argument_list|,
operator|&
name|rcmd
argument_list|,
operator|&
name|rresponse
argument_list|,
operator|&
name|rerrflg
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfields
operator|!=
literal|4
operator|||
name|rcmd
operator|!=
name|cmd
operator|||
name|rresponse
operator|>
literal|255
condition|)
name|mips_error
argument_list|(
literal|"common_breakpoint: Bad response from remote board: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|rerrflg
operator|!=
literal|0
condition|)
if|if
condition|(
name|check_lsi_error
argument_list|(
name|addr
argument_list|,
name|rerrflg
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* rresponse contains PMON's breakpoint number.  Record the 	     information for this breakpoint so we can clear it later.  */
name|lsi_breakpoints
index|[
name|rresponse
index|]
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|lsi_breakpoints
index|[
name|rresponse
index|]
operator|.
name|addr
operator|=
name|addr
expr_stmt|;
name|lsi_breakpoints
index|[
name|rresponse
index|]
operator|.
name|len
operator|=
name|len
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
comment|/* On non-LSI targets, the breakpoint command has this form:          0x0<CMD><ADDR><MASK><FLAGS><MASK> is a don't care mask for addresses.<FLAGS> is any combination of `r', `w', or `f' for read/write/fetch.        */
name|unsigned
name|long
name|mask
decl_stmt|;
name|mask
operator|=
name|calculate_mask
argument_list|(
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|addr
operator|&=
operator|~
name|mask
expr_stmt|;
if|if
condition|(
name|set
condition|)
comment|/* set a breakpoint */
block|{
name|char
modifier|*
name|flags
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|BREAK_WRITE
case|:
comment|/* write */
name|flags
operator|=
literal|"w"
expr_stmt|;
break|break;
case|case
name|BREAK_READ
case|:
comment|/* read */
name|flags
operator|=
literal|"r"
expr_stmt|;
break|break;
case|case
name|BREAK_ACCESS
case|:
comment|/* read/write */
name|flags
operator|=
literal|"rw"
expr_stmt|;
break|break;
case|case
name|BREAK_FETCH
case|:
comment|/* fetch */
name|flags
operator|=
literal|"f"
expr_stmt|;
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"failed internal consistency check"
argument_list|)
expr_stmt|;
block|}
name|cmd
operator|=
literal|'B'
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"0x0 B 0x%s 0x%s %s"
argument_list|,
name|paddr_nz
argument_list|(
name|addr
argument_list|)
argument_list|,
name|paddr_nz
argument_list|(
name|mask
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cmd
operator|=
literal|'b'
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"0x0 b 0x%s"
argument_list|,
name|paddr_nz
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mips_send_packet
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rlen
operator|=
name|mips_receive_packet
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|mips_receive_wait
argument_list|)
expr_stmt|;
name|buf
index|[
name|rlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|nfields
operator|=
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"0x%x %c 0x%x 0x%x"
argument_list|,
operator|&
name|rpid
argument_list|,
operator|&
name|rcmd
argument_list|,
operator|&
name|rerrflg
argument_list|,
operator|&
name|rresponse
argument_list|)
expr_stmt|;
if|if
condition|(
name|nfields
operator|!=
literal|4
operator|||
name|rcmd
operator|!=
name|cmd
condition|)
name|mips_error
argument_list|(
literal|"common_breakpoint: Bad response from remote board: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|rerrflg
operator|!=
literal|0
condition|)
block|{
comment|/* Ddb returns "0x0 b 0x16 0x0\000", whereas 	     Cogent returns "0x0 b 0xffffffff 0x16\000": */
if|if
condition|(
name|mips_monitor
operator|==
name|MON_DDB
condition|)
name|rresponse
operator|=
name|rerrflg
expr_stmt|;
if|if
condition|(
name|rresponse
operator|!=
literal|22
condition|)
comment|/* invalid argument */
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"common_breakpoint (0x%s):  Got error: 0x%x\n"
argument_list|,
name|paddr_nz
argument_list|(
name|addr
argument_list|)
argument_list|,
name|rresponse
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|send_srec
parameter_list|(
name|char
modifier|*
name|srec
parameter_list|,
name|int
name|len
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|ch
decl_stmt|;
name|serial_write
argument_list|(
name|mips_desc
argument_list|,
name|srec
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ch
operator|=
name|mips_readchar
argument_list|(
name|remote_timeout
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|SERIAL_TIMEOUT
case|:
name|error
argument_list|(
literal|"Timeout during download."
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x6
case|:
comment|/* ACK */
return|return;
case|case
literal|0x15
case|:
comment|/* NACK */
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Download got a NACK at byte %s!  Retrying.\n"
argument_list|,
name|paddr_u
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
default|default:
name|error
argument_list|(
literal|"Download got unexpected ack char: 0x%x, retrying.\n"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  Download a binary file by converting it to S records. */
end_comment

begin_function
specifier|static
name|void
name|mips_load_srec
parameter_list|(
name|char
modifier|*
name|args
parameter_list|)
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|,
name|srec
index|[
literal|1024
index|]
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|srec_frame
init|=
literal|200
decl_stmt|;
name|int
name|reclen
decl_stmt|;
specifier|static
name|int
name|hashmark
init|=
literal|1
decl_stmt|;
name|buffer
operator|=
name|alloca
argument_list|(
name|srec_frame
operator|*
literal|2
operator|+
literal|256
argument_list|)
expr_stmt|;
name|abfd
operator|=
name|bfd_openr
argument_list|(
name|args
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abfd
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Unable to open file %s\n"
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bfd_check_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"File is not an object file\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* This actually causes a download in the IDT binary format: */
name|mips_send_command
argument_list|(
name|LOAD_CMD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
block|{
if|if
condition|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
condition|)
block|{
name|unsigned
name|int
name|numbytes
decl_stmt|;
comment|/* FIXME!  vma too small????? */
name|printf_filtered
argument_list|(
literal|"%s\t: 0x%4lx .. 0x%4lx  "
argument_list|,
name|s
operator|->
name|name
argument_list|,
operator|(
name|long
operator|)
name|s
operator|->
name|vma
argument_list|,
call|(
name|long
call|)
argument_list|(
name|s
operator|->
name|vma
operator|+
name|s
operator|->
name|_raw_size
argument_list|)
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
operator|->
name|_raw_size
condition|;
name|i
operator|+=
name|numbytes
control|)
block|{
name|numbytes
operator|=
name|min
argument_list|(
name|srec_frame
argument_list|,
name|s
operator|->
name|_raw_size
operator|-
name|i
argument_list|)
expr_stmt|;
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|buffer
argument_list|,
name|i
argument_list|,
name|numbytes
argument_list|)
expr_stmt|;
name|reclen
operator|=
name|mips_make_srec
argument_list|(
name|srec
argument_list|,
literal|'3'
argument_list|,
name|s
operator|->
name|vma
operator|+
name|i
argument_list|,
name|buffer
argument_list|,
name|numbytes
argument_list|)
expr_stmt|;
name|send_srec
argument_list|(
name|srec
argument_list|,
name|reclen
argument_list|,
name|s
operator|->
name|vma
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ui_load_progress_hook
condition|)
name|ui_load_progress_hook
argument_list|(
name|s
operator|->
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|hashmark
condition|)
block|{
name|putchar_unfiltered
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Per-packet (or S-record) loop */
name|putchar_unfiltered
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
comment|/* Loadable sections */
block|}
if|if
condition|(
name|hashmark
condition|)
name|putchar_unfiltered
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* Write a type 7 terminator record. no data for a type 7, and there      is no data, so len is 0.  */
name|reclen
operator|=
name|mips_make_srec
argument_list|(
name|srec
argument_list|,
literal|'7'
argument_list|,
name|abfd
operator|->
name|start_address
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_srec
argument_list|(
name|srec
argument_list|,
name|reclen
argument_list|,
name|abfd
operator|->
name|start_address
argument_list|)
expr_stmt|;
name|serial_flush_input
argument_list|(
name|mips_desc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * mips_make_srec -- make an srecord. This writes each line, one at a  *      time, each with it's own header and trailer line.  *      An srecord looks like this:  *  * byte count-+     address  * start ---+ |        |       data        +- checksum  *          | |        |                   |  *        S01000006F6B692D746573742E73726563E4  *        S315000448600000000000000000FC00005900000000E9  *        S31A0004000023C1400037DE00F023604000377B009020825000348D  *        S30B0004485A0000000000004E  *        S70500040000F6  *  *      S<type><length><address><data><checksum>  *  *      Where  *      - length  *        is the number of bytes following upto the checksum. Note that  *        this is not the number of chars following, since it takes two  *        chars to represent a byte.  *      - type  *        is one of:  *        0) header record  *        1) two byte address data record  *        2) three byte address data record  *        3) four byte address data record  *        7) four byte address termination record  *        8) three byte address termination record  *        9) two byte address termination record  *         *      - address  *        is the start address of the data following, or in the case of  *        a termination record, the start address of the image  *      - data  *        is the data.  *      - checksum  *        is the sum of all the raw byte data in the record, from the length  *        upwards, modulo 256 and subtracted from 255.  *  * This routine returns the length of the S-record.  *  */
end_comment

begin_function
specifier|static
name|int
name|mips_make_srec
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|type
parameter_list|,
name|CORE_ADDR
name|memaddr
parameter_list|,
name|unsigned
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|unsigned
name|char
name|checksum
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Create the header for the srec. addr_size is the number of bytes in the address,      and 1 is the number of bytes in the count.  */
comment|/* FIXME!! bigger buf required for 64-bit! */
name|buf
index|[
literal|0
index|]
operator|=
literal|'S'
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|type
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|len
operator|+
literal|4
operator|+
literal|1
expr_stmt|;
comment|/* len + 4 byte address + 1 byte checksum */
comment|/* This assumes S3 style downloads (4byte addresses). There should      probably be a check, or the code changed to make it more      explicit. */
name|buf
index|[
literal|3
index|]
operator|=
name|memaddr
operator|>>
literal|24
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
name|memaddr
operator|>>
literal|16
expr_stmt|;
name|buf
index|[
literal|5
index|]
operator|=
name|memaddr
operator|>>
literal|8
expr_stmt|;
name|buf
index|[
literal|6
index|]
operator|=
name|memaddr
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|buf
index|[
literal|7
index|]
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Note that the checksum is calculated on the raw data, not the      hexified data.  It includes the length, address and the data      portions of the packet.  */
name|checksum
operator|=
literal|0
expr_stmt|;
name|buf
operator|+=
literal|2
expr_stmt|;
comment|/* Point at length byte */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
operator|+
literal|4
operator|+
literal|1
condition|;
name|i
operator|++
control|)
name|checksum
operator|+=
operator|*
name|buf
operator|++
expr_stmt|;
operator|*
name|buf
operator|=
operator|~
name|checksum
expr_stmt|;
return|return
name|len
operator|+
literal|8
return|;
block|}
end_function

begin_comment
comment|/* The following manifest controls whether we enable the simple flow    control support provided by the monitor. If enabled the code will    wait for an affirmative ACK between transmitting packets. */
end_comment

begin_define
define|#
directive|define
name|DOETXACK
value|(1)
end_define

begin_comment
comment|/* The PMON fast-download uses an encoded packet format constructed of    3byte data packets (encoded as 4 printable ASCII characters), and    escape sequences (preceded by a '/'):     'K'     clear checksum    'C'     compare checksum (12bit value, not included in checksum calculation)    'S'     define symbol name (for addr) terminated with "," and padded to 4char boundary    'Z'     zero fill multiple of 3bytes    'B'     byte (12bit encoded value, of 8bit data)    'A'     address (36bit encoded value)    'E'     define entry as original address, and exit load     The packets are processed in 4 character chunks, so the escape    sequences that do not have any data (or variable length data)    should be padded to a 4 character boundary.  The decoder will give    an error if the complete message block size is not a multiple of    4bytes (size of record).     The encoding of numbers is done in 6bit fields.  The 6bit value is    used to index into this string to get the specific character    encoding for the value: */
end_comment

begin_decl_stmt
specifier|static
name|char
name|encoding
index|[]
init|=
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789,."
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Convert the number of bits required into an encoded number, 6bits    at a time (range 0..63).  Keep a checksum if required (passed    pointer non-NULL). The function returns the number of encoded    characters written into the buffer. */
end_comment

begin_function
specifier|static
name|int
name|pmon_makeb64
parameter_list|(
name|unsigned
name|long
name|v
parameter_list|,
name|char
modifier|*
name|p
parameter_list|,
name|int
name|n
parameter_list|,
name|int
modifier|*
name|chksum
parameter_list|)
block|{
name|int
name|count
init|=
operator|(
name|n
operator|/
literal|6
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|n
operator|%
literal|12
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Fast encoding bitcount must be a multiple of 12bits: %dbit%s\n"
argument_list|,
name|n
argument_list|,
operator|(
name|n
operator|==
literal|1
operator|)
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|n
operator|>
literal|36
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Fast encoding cannot process more than 36bits at the moment: %dbits\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Deal with the checksum: */
if|if
condition|(
name|chksum
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|36
case|:
operator|*
name|chksum
operator|+=
operator|(
operator|(
name|v
operator|>>
literal|24
operator|)
operator|&
literal|0xFFF
operator|)
expr_stmt|;
case|case
literal|24
case|:
operator|*
name|chksum
operator|+=
operator|(
operator|(
name|v
operator|>>
literal|12
operator|)
operator|&
literal|0xFFF
operator|)
expr_stmt|;
case|case
literal|12
case|:
operator|*
name|chksum
operator|+=
operator|(
operator|(
name|v
operator|>>
literal|0
operator|)
operator|&
literal|0xFFF
operator|)
expr_stmt|;
block|}
block|}
do|do
block|{
name|n
operator|-=
literal|6
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|encoding
index|[
operator|(
name|v
operator|>>
name|n
operator|)
operator|&
literal|0x3F
index|]
expr_stmt|;
block|}
do|while
condition|(
name|n
operator|>
literal|0
condition|)
do|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Shorthand function (that could be in-lined) to output the zero-fill    escape sequence into the data stream. */
end_comment

begin_function
specifier|static
name|int
name|pmon_zeroset
parameter_list|(
name|int
name|recsize
parameter_list|,
name|char
modifier|*
modifier|*
name|buff
parameter_list|,
name|int
modifier|*
name|amount
parameter_list|,
name|unsigned
name|int
modifier|*
name|chksum
parameter_list|)
block|{
name|int
name|count
decl_stmt|;
name|sprintf
argument_list|(
operator|*
name|buff
argument_list|,
literal|"/Z"
argument_list|)
expr_stmt|;
name|count
operator|=
name|pmon_makeb64
argument_list|(
operator|*
name|amount
argument_list|,
operator|(
operator|*
name|buff
operator|+
literal|2
operator|)
argument_list|,
literal|12
argument_list|,
name|chksum
argument_list|)
expr_stmt|;
operator|*
name|buff
operator|+=
operator|(
name|count
operator|+
literal|2
operator|)
expr_stmt|;
operator|*
name|amount
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|recsize
operator|+
name|count
operator|+
literal|2
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pmon_checkset
parameter_list|(
name|int
name|recsize
parameter_list|,
name|char
modifier|*
modifier|*
name|buff
parameter_list|,
name|int
modifier|*
name|value
parameter_list|)
block|{
name|int
name|count
decl_stmt|;
comment|/* Add the checksum (without updating the value): */
name|sprintf
argument_list|(
operator|*
name|buff
argument_list|,
literal|"/C"
argument_list|)
expr_stmt|;
name|count
operator|=
name|pmon_makeb64
argument_list|(
operator|*
name|value
argument_list|,
operator|(
operator|*
name|buff
operator|+
literal|2
operator|)
argument_list|,
literal|12
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|buff
operator|+=
operator|(
name|count
operator|+
literal|2
operator|)
expr_stmt|;
name|sprintf
argument_list|(
operator|*
name|buff
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
operator|*
name|buff
operator|+=
literal|2
expr_stmt|;
comment|/* include zero terminator */
comment|/* Forcing a checksum validation clears the sum: */
operator|*
name|value
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|recsize
operator|+
name|count
operator|+
literal|3
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Amount of padding we leave after at the end of the output buffer,    for the checksum and line termination characters: */
end_comment

begin_define
define|#
directive|define
name|CHECKSIZE
value|(4 + 4 + 4 + 2)
end_define

begin_comment
comment|/* zero-fill, checksum, transfer end and line termination space. */
end_comment

begin_comment
comment|/* The amount of binary data loaded from the object file in a single    operation: */
end_comment

begin_define
define|#
directive|define
name|BINCHUNK
value|(1024)
end_define

begin_comment
comment|/* Maximum line of data accepted by the monitor: */
end_comment

begin_define
define|#
directive|define
name|MAXRECSIZE
value|(550)
end_define

begin_comment
comment|/* NOTE: This constant depends on the monitor being used. This value    is for PMON 5.x on the Cogent Vr4300 board. */
end_comment

begin_function
specifier|static
name|void
name|pmon_make_fastrec
parameter_list|(
name|char
modifier|*
modifier|*
name|outbuf
parameter_list|,
name|unsigned
name|char
modifier|*
name|inbuf
parameter_list|,
name|int
modifier|*
name|inptr
parameter_list|,
name|int
name|inamount
parameter_list|,
name|int
modifier|*
name|recsize
parameter_list|,
name|unsigned
name|int
modifier|*
name|csum
parameter_list|,
name|unsigned
name|int
modifier|*
name|zerofill
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
init|=
operator|*
name|outbuf
decl_stmt|;
comment|/* This is a simple check to ensure that our data will fit within      the maximum allowable record size. Each record output is 4bytes      in length. We must allow space for a pending zero fill command,      the record, and a checksum record. */
while|while
condition|(
operator|(
operator|*
name|recsize
operator|<
operator|(
name|MAXRECSIZE
operator|-
name|CHECKSIZE
operator|)
operator|)
operator|&&
operator|(
operator|(
name|inamount
operator|-
operator|*
name|inptr
operator|)
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* Process the binary data: */
if|if
condition|(
operator|(
name|inamount
operator|-
operator|*
name|inptr
operator|)
operator|<
literal|3
condition|)
block|{
if|if
condition|(
operator|*
name|zerofill
operator|!=
literal|0
condition|)
operator|*
name|recsize
operator|=
name|pmon_zeroset
argument_list|(
operator|*
name|recsize
argument_list|,
operator|&
name|p
argument_list|,
name|zerofill
argument_list|,
name|csum
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|p
argument_list|,
literal|"/B"
argument_list|)
expr_stmt|;
name|count
operator|=
name|pmon_makeb64
argument_list|(
name|inbuf
index|[
operator|*
name|inptr
index|]
argument_list|,
operator|&
name|p
index|[
literal|2
index|]
argument_list|,
literal|12
argument_list|,
name|csum
argument_list|)
expr_stmt|;
name|p
operator|+=
operator|(
literal|2
operator|+
name|count
operator|)
expr_stmt|;
operator|*
name|recsize
operator|+=
operator|(
literal|2
operator|+
name|count
operator|)
expr_stmt|;
operator|(
operator|*
name|inptr
operator|)
operator|++
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|int
name|value
init|=
operator|(
operator|(
name|inbuf
index|[
operator|*
name|inptr
operator|+
literal|0
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|inbuf
index|[
operator|*
name|inptr
operator|+
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|inbuf
index|[
operator|*
name|inptr
operator|+
literal|2
index|]
operator|)
decl_stmt|;
comment|/* Simple check for zero data. TODO: A better check would be 	     to check the last, and then the middle byte for being zero 	     (if the first byte is not). We could then check for 	     following runs of zeros, and if above a certain size it is 	     worth the 4 or 8 character hit of the byte insertions used 	     to pad to the start of the zeroes. NOTE: This also depends 	     on the alignment at the end of the zero run. */
if|if
condition|(
name|value
operator|==
literal|0x00000000
condition|)
block|{
operator|(
operator|*
name|zerofill
operator|)
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|zerofill
operator|==
literal|0xFFF
condition|)
comment|/* 12bit counter */
operator|*
name|recsize
operator|=
name|pmon_zeroset
argument_list|(
operator|*
name|recsize
argument_list|,
operator|&
name|p
argument_list|,
name|zerofill
argument_list|,
name|csum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|zerofill
operator|!=
literal|0
condition|)
operator|*
name|recsize
operator|=
name|pmon_zeroset
argument_list|(
operator|*
name|recsize
argument_list|,
operator|&
name|p
argument_list|,
name|zerofill
argument_list|,
name|csum
argument_list|)
expr_stmt|;
name|count
operator|=
name|pmon_makeb64
argument_list|(
name|value
argument_list|,
name|p
argument_list|,
literal|24
argument_list|,
name|csum
argument_list|)
expr_stmt|;
name|p
operator|+=
name|count
expr_stmt|;
operator|*
name|recsize
operator|+=
name|count
expr_stmt|;
block|}
operator|*
name|inptr
operator|+=
literal|3
expr_stmt|;
block|}
block|}
operator|*
name|outbuf
operator|=
name|p
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|pmon_check_ack
parameter_list|(
name|char
modifier|*
name|mesg
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|DOETXACK
argument_list|)
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|tftp_in_use
condition|)
block|{
name|c
operator|=
name|serial_readchar
argument_list|(
name|udp_in_use
condition|?
name|udp_desc
else|:
name|mips_desc
argument_list|,
name|remote_timeout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
name|SERIAL_TIMEOUT
operator|)
operator|||
operator|(
name|c
operator|!=
literal|0x06
operator|)
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Failed to receive valid ACK for %s\n"
argument_list|,
name|mesg
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* terminate the download */
block|}
block|}
endif|#
directive|endif
comment|/* DOETXACK */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* pmon_download - Send a sequence of characters to the PMON download port,    which is either a serial port or a UDP socket.  */
end_comment

begin_function
specifier|static
name|void
name|pmon_start_download
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|tftp_in_use
condition|)
block|{
comment|/* Create the temporary download file.  */
if|if
condition|(
operator|(
name|tftp_file
operator|=
name|fopen
argument_list|(
name|tftp_localname
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|perror_with_name
argument_list|(
name|tftp_localname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mips_send_command
argument_list|(
name|udp_in_use
condition|?
name|LOAD_CMD_UDP
else|:
name|LOAD_CMD
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mips_expect
argument_list|(
literal|"Downloading from "
argument_list|)
expr_stmt|;
name|mips_expect
argument_list|(
name|udp_in_use
condition|?
literal|"udp"
else|:
literal|"tty0"
argument_list|)
expr_stmt|;
name|mips_expect
argument_list|(
literal|", ^C to abort\r\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mips_expect_download
parameter_list|(
name|char
modifier|*
name|string
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mips_expect
argument_list|(
name|string
argument_list|)
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Load did not complete successfully.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tftp_in_use
condition|)
name|remove
argument_list|(
name|tftp_localname
argument_list|)
expr_stmt|;
comment|/* Remove temporary file */
return|return
literal|0
return|;
block|}
else|else
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmon_check_entry_address
parameter_list|(
name|char
modifier|*
name|entry_address
parameter_list|,
name|int
name|final
parameter_list|)
block|{
name|char
name|hexnumber
index|[
literal|9
index|]
decl_stmt|;
comment|/* includes '\0' space */
name|mips_expect_timeout
argument_list|(
name|entry_address
argument_list|,
name|tftp_in_use
condition|?
literal|15
else|:
name|remote_timeout
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hexnumber
argument_list|,
literal|"%x"
argument_list|,
name|final
argument_list|)
expr_stmt|;
name|mips_expect
argument_list|(
name|hexnumber
argument_list|)
expr_stmt|;
name|mips_expect
argument_list|(
literal|"\r\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pmon_check_total
parameter_list|(
name|int
name|bintotal
parameter_list|)
block|{
name|char
name|hexnumber
index|[
literal|9
index|]
decl_stmt|;
comment|/* includes '\0' space */
name|mips_expect
argument_list|(
literal|"\r\ntotal = 0x"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|hexnumber
argument_list|,
literal|"%x"
argument_list|,
name|bintotal
argument_list|)
expr_stmt|;
name|mips_expect
argument_list|(
name|hexnumber
argument_list|)
expr_stmt|;
return|return
name|mips_expect_download
argument_list|(
literal|" bytes\r\n"
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmon_end_download
parameter_list|(
name|int
name|final
parameter_list|,
name|int
name|bintotal
parameter_list|)
block|{
name|char
name|hexnumber
index|[
literal|9
index|]
decl_stmt|;
comment|/* includes '\0' space */
if|if
condition|(
name|tftp_in_use
condition|)
block|{
specifier|static
name|char
modifier|*
name|load_cmd_prefix
init|=
literal|"load -b -s "
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
comment|/* Close off the temporary file containing the load data.  */
name|fclose
argument_list|(
name|tftp_file
argument_list|)
expr_stmt|;
name|tftp_file
operator|=
name|NULL
expr_stmt|;
comment|/* Make the temporary file readable by the world.  */
if|if
condition|(
name|stat
argument_list|(
name|tftp_localname
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|==
literal|0
condition|)
name|chmod
argument_list|(
name|tftp_localname
argument_list|,
name|stbuf
operator|.
name|st_mode
operator||
name|S_IROTH
argument_list|)
expr_stmt|;
comment|/* Must reinitialize the board to prevent PMON from crashing.  */
name|mips_send_command
argument_list|(
literal|"initEther\r"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Send the load command.  */
name|cmd
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|load_cmd_prefix
argument_list|)
operator|+
name|strlen
argument_list|(
name|tftp_name
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cmd
argument_list|,
name|load_cmd_prefix
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|cmd
argument_list|,
name|tftp_name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|cmd
argument_list|,
literal|"\r"
argument_list|)
expr_stmt|;
name|mips_send_command
argument_list|(
name|cmd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mips_expect_download
argument_list|(
literal|"Downloading from "
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|mips_expect_download
argument_list|(
name|tftp_name
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|mips_expect_download
argument_list|(
literal|", ^C to abort\r\n"
argument_list|)
condition|)
return|return;
block|}
comment|/* Wait for the stuff that PMON prints after the load has completed.      The timeout value for use in the tftp case (15 seconds) was picked      arbitrarily but might be too small for really large downloads. FIXME. */
switch|switch
condition|(
name|mips_monitor
condition|)
block|{
case|case
name|MON_LSI
case|:
name|pmon_check_ack
argument_list|(
literal|"termination"
argument_list|)
expr_stmt|;
name|pmon_check_entry_address
argument_list|(
literal|"Entry address is "
argument_list|,
name|final
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pmon_check_total
argument_list|(
name|bintotal
argument_list|)
condition|)
return|return;
break|break;
default|default:
name|pmon_check_entry_address
argument_list|(
literal|"Entry Address  = "
argument_list|,
name|final
argument_list|)
expr_stmt|;
name|pmon_check_ack
argument_list|(
literal|"termination"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pmon_check_total
argument_list|(
name|bintotal
argument_list|)
condition|)
return|return;
break|break;
block|}
if|if
condition|(
name|tftp_in_use
condition|)
name|remove
argument_list|(
name|tftp_localname
argument_list|)
expr_stmt|;
comment|/* Remove temporary file */
block|}
end_function

begin_function
specifier|static
name|void
name|pmon_download
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|length
parameter_list|)
block|{
if|if
condition|(
name|tftp_in_use
condition|)
name|fwrite
argument_list|(
name|buffer
argument_list|,
literal|1
argument_list|,
name|length
argument_list|,
name|tftp_file
argument_list|)
expr_stmt|;
else|else
name|serial_write
argument_list|(
name|udp_in_use
condition|?
name|udp_desc
else|:
name|mips_desc
argument_list|,
name|buffer
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmon_load_fast
parameter_list|(
name|char
modifier|*
name|file
parameter_list|)
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|unsigned
name|char
modifier|*
name|binbuf
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|int
name|reclen
decl_stmt|;
name|unsigned
name|int
name|csum
init|=
literal|0
decl_stmt|;
name|int
name|hashmark
init|=
operator|!
name|tftp_in_use
decl_stmt|;
name|int
name|bintotal
init|=
literal|0
decl_stmt|;
name|int
name|final
init|=
literal|0
decl_stmt|;
name|int
name|finished
init|=
literal|0
decl_stmt|;
name|buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|MAXRECSIZE
operator|+
literal|1
argument_list|)
expr_stmt|;
name|binbuf
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|BINCHUNK
argument_list|)
expr_stmt|;
name|abfd
operator|=
name|bfd_openr
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abfd
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Unable to open file %s\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bfd_check_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"File is not an object file\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Setup the required download state: */
name|mips_send_command
argument_list|(
literal|"set dlproto etxack\r"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mips_send_command
argument_list|(
literal|"set dlecho off\r"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* NOTE: We get a "cannot set variable" message if the variable is      already defined to have the argument we give. The code doesn't      care, since it just scans to the next prompt anyway. */
comment|/* Start the download: */
name|pmon_start_download
argument_list|()
expr_stmt|;
comment|/* Zero the checksum */
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"/Kxx\n"
argument_list|)
expr_stmt|;
name|reclen
operator|=
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|pmon_download
argument_list|(
name|buffer
argument_list|,
name|reclen
argument_list|)
expr_stmt|;
name|finished
operator|=
name|pmon_check_ack
argument_list|(
literal|"/Kxx"
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
operator|&&
operator|!
name|finished
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
condition|)
comment|/* only deal with loadable sections */
block|{
name|bintotal
operator|+=
name|s
operator|->
name|_raw_size
expr_stmt|;
name|final
operator|=
operator|(
name|s
operator|->
name|vma
operator|+
name|s
operator|->
name|_raw_size
operator|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s\t: 0x%4x .. 0x%4x  "
argument_list|,
name|s
operator|->
name|name
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|s
operator|->
name|vma
argument_list|,
call|(
name|unsigned
name|int
call|)
argument_list|(
name|s
operator|->
name|vma
operator|+
name|s
operator|->
name|_raw_size
argument_list|)
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
comment|/* Output the starting address */
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"/A"
argument_list|)
expr_stmt|;
name|reclen
operator|=
name|pmon_makeb64
argument_list|(
name|s
operator|->
name|vma
argument_list|,
operator|&
name|buffer
index|[
literal|2
index|]
argument_list|,
literal|36
argument_list|,
operator|&
name|csum
argument_list|)
expr_stmt|;
name|buffer
index|[
literal|2
operator|+
name|reclen
index|]
operator|=
literal|'\n'
expr_stmt|;
name|buffer
index|[
literal|3
operator|+
name|reclen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|reclen
operator|+=
literal|3
expr_stmt|;
comment|/* for the initial escape code and carriage return */
name|pmon_download
argument_list|(
name|buffer
argument_list|,
name|reclen
argument_list|)
expr_stmt|;
name|finished
operator|=
name|pmon_check_ack
argument_list|(
literal|"/A"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|finished
condition|)
block|{
name|unsigned
name|int
name|binamount
decl_stmt|;
name|unsigned
name|int
name|zerofill
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|bp
init|=
name|buffer
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|reclen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
operator|(
name|i
operator|<
name|s
operator|->
name|_raw_size
operator|)
operator|&&
operator|!
name|finished
operator|)
condition|;
name|i
operator|+=
name|binamount
control|)
block|{
name|int
name|binptr
init|=
literal|0
decl_stmt|;
name|binamount
operator|=
name|min
argument_list|(
name|BINCHUNK
argument_list|,
name|s
operator|->
name|_raw_size
operator|-
name|i
argument_list|)
expr_stmt|;
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|,
name|binbuf
argument_list|,
name|i
argument_list|,
name|binamount
argument_list|)
expr_stmt|;
comment|/* This keeps a rolling checksum, until we decide to output 		   the line: */
for|for
control|(
init|;
operator|(
operator|(
name|binamount
operator|-
name|binptr
operator|)
operator|>
literal|0
operator|)
condition|;
control|)
block|{
name|pmon_make_fastrec
argument_list|(
operator|&
name|bp
argument_list|,
name|binbuf
argument_list|,
operator|&
name|binptr
argument_list|,
name|binamount
argument_list|,
operator|&
name|reclen
argument_list|,
operator|&
name|csum
argument_list|,
operator|&
name|zerofill
argument_list|)
expr_stmt|;
if|if
condition|(
name|reclen
operator|>=
operator|(
name|MAXRECSIZE
operator|-
name|CHECKSIZE
operator|)
condition|)
block|{
name|reclen
operator|=
name|pmon_checkset
argument_list|(
name|reclen
argument_list|,
operator|&
name|bp
argument_list|,
operator|&
name|csum
argument_list|)
expr_stmt|;
name|pmon_download
argument_list|(
name|buffer
argument_list|,
name|reclen
argument_list|)
expr_stmt|;
name|finished
operator|=
name|pmon_check_ack
argument_list|(
literal|"data record"
argument_list|)
expr_stmt|;
if|if
condition|(
name|finished
condition|)
block|{
name|zerofill
operator|=
literal|0
expr_stmt|;
comment|/* do not transmit pending zerofills */
break|break;
block|}
if|if
condition|(
name|ui_load_progress_hook
condition|)
name|ui_load_progress_hook
argument_list|(
name|s
operator|->
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|hashmark
condition|)
block|{
name|putchar_unfiltered
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|bp
operator|=
name|buffer
expr_stmt|;
name|reclen
operator|=
literal|0
expr_stmt|;
comment|/* buffer processed */
block|}
block|}
block|}
comment|/* Ensure no out-standing zerofill requests: */
if|if
condition|(
name|zerofill
operator|!=
literal|0
condition|)
name|reclen
operator|=
name|pmon_zeroset
argument_list|(
name|reclen
argument_list|,
operator|&
name|bp
argument_list|,
operator|&
name|zerofill
argument_list|,
operator|&
name|csum
argument_list|)
expr_stmt|;
comment|/* and then flush the line: */
if|if
condition|(
name|reclen
operator|>
literal|0
condition|)
block|{
name|reclen
operator|=
name|pmon_checkset
argument_list|(
name|reclen
argument_list|,
operator|&
name|bp
argument_list|,
operator|&
name|csum
argument_list|)
expr_stmt|;
comment|/* Currently pmon_checkset outputs the line terminator by 		   default, so we write out the buffer so far: */
name|pmon_download
argument_list|(
name|buffer
argument_list|,
name|reclen
argument_list|)
expr_stmt|;
name|finished
operator|=
name|pmon_check_ack
argument_list|(
literal|"record remnant"
argument_list|)
expr_stmt|;
block|}
block|}
name|putchar_unfiltered
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
comment|/* Terminate the transfer. We know that we have an empty output      buffer at this point. */
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"/E/E\n"
argument_list|)
expr_stmt|;
comment|/* include dummy padding characters */
name|reclen
operator|=
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|pmon_download
argument_list|(
name|buffer
argument_list|,
name|reclen
argument_list|)
expr_stmt|;
if|if
condition|(
name|finished
condition|)
block|{
comment|/* Ignore the termination message: */
name|serial_flush_input
argument_list|(
name|udp_in_use
condition|?
name|udp_desc
else|:
name|mips_desc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Deal with termination message: */
name|pmon_end_download
argument_list|(
name|final
argument_list|,
name|bintotal
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* mips_load -- download a file. */
end_comment

begin_function
specifier|static
name|void
name|mips_load
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
comment|/* Get the board out of remote debugging mode.  */
if|if
condition|(
name|mips_exit_debug
argument_list|()
condition|)
name|error
argument_list|(
literal|"mips_load:  Couldn't get into monitor mode."
argument_list|)
expr_stmt|;
if|if
condition|(
name|mips_monitor
operator|!=
name|MON_IDT
condition|)
name|pmon_load_fast
argument_list|(
name|file
argument_list|)
expr_stmt|;
else|else
name|mips_load_srec
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|mips_initialize
argument_list|()
expr_stmt|;
comment|/* Finally, make the PC point at the start address */
if|if
condition|(
name|mips_monitor
operator|!=
name|MON_IDT
condition|)
block|{
comment|/* Work around problem where PMON monitor updates the PC after a load          to a different value than GDB thinks it has. The following ensures          that the write_pc() WILL update the PC value: */
name|deprecated_register_valid
index|[
name|PC_REGNUM
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|exec_bfd
condition|)
name|write_pc
argument_list|(
name|bfd_get_start_address
argument_list|(
name|exec_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|inferior_ptid
operator|=
name|null_ptid
expr_stmt|;
comment|/* No process now */
comment|/* This is necessary because many things were based on the PC at the time that    we attached to the monitor, which is no longer valid now that we have loaded    new code (and just changed the PC).  Another way to do this might be to call    normal_stop, except that the stack may not be valid, and things would get    horribly confused... */
name|clear_symtab_users
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Pass the command argument as a packet to PMON verbatim.  */
end_comment

begin_function
specifier|static
name|void
name|pmon_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
name|buf
index|[
name|DATA_MAXLEN
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|rlen
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"0x0 %s"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|mips_send_packet
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Send packet: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|rlen
operator|=
name|mips_receive_packet
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|mips_receive_wait
argument_list|)
expr_stmt|;
name|buf
index|[
name|rlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Received packet: %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|extern
name|initialize_file_ftype
name|_initialize_remote_mips
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -Wmissing-prototypes */
end_comment

begin_function
name|void
name|_initialize_remote_mips
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Initialize the fields in mips_ops that are common to all four targets.  */
name|mips_ops
operator|.
name|to_longname
operator|=
literal|"Remote MIPS debugging over serial line"
expr_stmt|;
name|mips_ops
operator|.
name|to_close
operator|=
name|mips_close
expr_stmt|;
name|mips_ops
operator|.
name|to_detach
operator|=
name|mips_detach
expr_stmt|;
name|mips_ops
operator|.
name|to_resume
operator|=
name|mips_resume
expr_stmt|;
name|mips_ops
operator|.
name|to_fetch_registers
operator|=
name|mips_fetch_registers
expr_stmt|;
name|mips_ops
operator|.
name|to_store_registers
operator|=
name|mips_store_registers
expr_stmt|;
name|mips_ops
operator|.
name|to_prepare_to_store
operator|=
name|mips_prepare_to_store
expr_stmt|;
name|mips_ops
operator|.
name|to_xfer_memory
operator|=
name|mips_xfer_memory
expr_stmt|;
name|mips_ops
operator|.
name|to_files_info
operator|=
name|mips_files_info
expr_stmt|;
name|mips_ops
operator|.
name|to_insert_breakpoint
operator|=
name|mips_insert_breakpoint
expr_stmt|;
name|mips_ops
operator|.
name|to_remove_breakpoint
operator|=
name|mips_remove_breakpoint
expr_stmt|;
name|mips_ops
operator|.
name|to_insert_watchpoint
operator|=
name|mips_insert_watchpoint
expr_stmt|;
name|mips_ops
operator|.
name|to_remove_watchpoint
operator|=
name|mips_remove_watchpoint
expr_stmt|;
name|mips_ops
operator|.
name|to_stopped_by_watchpoint
operator|=
name|mips_stopped_by_watchpoint
expr_stmt|;
name|mips_ops
operator|.
name|to_can_use_hw_breakpoint
operator|=
name|mips_can_use_watchpoint
expr_stmt|;
name|mips_ops
operator|.
name|to_kill
operator|=
name|mips_kill
expr_stmt|;
name|mips_ops
operator|.
name|to_load
operator|=
name|mips_load
expr_stmt|;
name|mips_ops
operator|.
name|to_create_inferior
operator|=
name|mips_create_inferior
expr_stmt|;
name|mips_ops
operator|.
name|to_mourn_inferior
operator|=
name|mips_mourn_inferior
expr_stmt|;
name|mips_ops
operator|.
name|to_stratum
operator|=
name|process_stratum
expr_stmt|;
name|mips_ops
operator|.
name|to_has_all_memory
operator|=
literal|1
expr_stmt|;
name|mips_ops
operator|.
name|to_has_memory
operator|=
literal|1
expr_stmt|;
name|mips_ops
operator|.
name|to_has_stack
operator|=
literal|1
expr_stmt|;
name|mips_ops
operator|.
name|to_has_registers
operator|=
literal|1
expr_stmt|;
name|mips_ops
operator|.
name|to_has_execution
operator|=
literal|1
expr_stmt|;
name|mips_ops
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
comment|/* Copy the common fields to all four target vectors.  */
name|pmon_ops
operator|=
name|ddb_ops
operator|=
name|lsi_ops
operator|=
name|mips_ops
expr_stmt|;
comment|/* Initialize target-specific fields in the target vectors.  */
name|mips_ops
operator|.
name|to_shortname
operator|=
literal|"mips"
expr_stmt|;
name|mips_ops
operator|.
name|to_doc
operator|=
literal|"\ Debug a board using the MIPS remote debugging protocol over a serial line.\n\ The argument is the device it is connected to or, if it contains a colon,\n\ HOST:PORT to access a board over a network"
expr_stmt|;
name|mips_ops
operator|.
name|to_open
operator|=
name|mips_open
expr_stmt|;
name|mips_ops
operator|.
name|to_wait
operator|=
name|mips_wait
expr_stmt|;
name|pmon_ops
operator|.
name|to_shortname
operator|=
literal|"pmon"
expr_stmt|;
name|pmon_ops
operator|.
name|to_doc
operator|=
literal|"\ Debug a board using the PMON MIPS remote debugging protocol over a serial\n\ line. The argument is the device it is connected to or, if it contains a\n\ colon, HOST:PORT to access a board over a network"
expr_stmt|;
name|pmon_ops
operator|.
name|to_open
operator|=
name|pmon_open
expr_stmt|;
name|pmon_ops
operator|.
name|to_wait
operator|=
name|mips_wait
expr_stmt|;
name|ddb_ops
operator|.
name|to_shortname
operator|=
literal|"ddb"
expr_stmt|;
name|ddb_ops
operator|.
name|to_doc
operator|=
literal|"\ Debug a board using the PMON MIPS remote debugging protocol over a serial\n\ line. The first argument is the device it is connected to or, if it contains\n\ a colon, HOST:PORT to access a board over a network.  The optional second\n\ parameter is the temporary file in the form HOST:FILENAME to be used for\n\ TFTP downloads to the board.  The optional third parameter is the local name\n\ of the TFTP temporary file, if it differs from the filename seen by the board."
expr_stmt|;
name|ddb_ops
operator|.
name|to_open
operator|=
name|ddb_open
expr_stmt|;
name|ddb_ops
operator|.
name|to_wait
operator|=
name|mips_wait
expr_stmt|;
name|lsi_ops
operator|.
name|to_shortname
operator|=
literal|"lsi"
expr_stmt|;
name|lsi_ops
operator|.
name|to_doc
operator|=
name|pmon_ops
operator|.
name|to_doc
expr_stmt|;
name|lsi_ops
operator|.
name|to_open
operator|=
name|lsi_open
expr_stmt|;
name|lsi_ops
operator|.
name|to_wait
operator|=
name|mips_wait
expr_stmt|;
comment|/* Add the targets.  */
name|add_target
argument_list|(
operator|&
name|mips_ops
argument_list|)
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|pmon_ops
argument_list|)
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|ddb_ops
argument_list|)
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|lsi_ops
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"timeout"
argument_list|,
name|no_class
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mips_receive_wait
argument_list|,
literal|"Set timeout in seconds for remote MIPS serial I/O."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"retransmit-timeout"
argument_list|,
name|no_class
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mips_retransmit_wait
argument_list|,
literal|"Set retransmit timeout in seconds for remote MIPS serial I/O.\n\ This is the number of seconds to wait for an acknowledgement to a packet\n\ before resending the packet."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"syn-garbage-limit"
argument_list|,
name|no_class
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mips_syn_garbage
argument_list|,
literal|"Set the maximum number of characters to ignore when scanning for a SYN.\n\ This is the maximum number of characters GDB will ignore when trying to\n\ synchronize with the remote system.  A value of -1 means that there is no limit\n\ (Note that these characters are printed out even though they are ignored.)"
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"monitor-prompt"
argument_list|,
name|class_obscure
argument_list|,
name|var_string
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mips_monitor_prompt
argument_list|,
literal|"Set the prompt that GDB expects from the monitor."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"monitor-warnings"
argument_list|,
name|class_obscure
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|monitor_warnings
argument_list|,
literal|"Set printing of monitor warnings.\n"
literal|"When enabled, monitor warnings about hardware breakpoints "
literal|"will be displayed."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"pmon<command>"
argument_list|,
name|class_obscure
argument_list|,
name|pmon_command
argument_list|,
literal|"Send a packet to PMON (must be in debug mode)."
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"mask-address"
argument_list|,
name|no_class
argument_list|,
name|var_boolean
argument_list|,
operator|&
name|mask_address_p
argument_list|,
literal|"Set zeroing of upper 32 bits of 64-bit addresses when talking to PMON targets.\n\ Use \"on\" to enable the masking and \"off\" to disable it.\n"
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

