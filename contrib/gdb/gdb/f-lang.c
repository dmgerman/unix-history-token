begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Fortran language support routines for GDB, the GNU debugger.    Copyright 1993, 1994, 1996 Free Software Foundation, Inc.    Contributed by Motorola.  Adapted from the C parser by Farooq Butt    (fmbutt@engage.sps.mot.com).  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"parser-defs.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"f-lang.h"
end_include

begin_comment
comment|/* The built-in types of F77.  FIXME: integer*4 is missing, plain    logical is missing (builtin_type_logical is logical*4).  */
end_comment

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_f_character
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_f_logical
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_f_logical_s1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_f_logical_s2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_f_integer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_f_integer_s2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_f_real
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_f_real_s8
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_f_real_s16
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_f_complex_s8
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_f_complex_s16
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_f_complex_s32
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_f_void
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Following is dubious stuff that had been in the xcoff reader. */
end_comment

begin_struct
struct|struct
name|saved_fcn
block|{
name|long
name|line_offset
decl_stmt|;
comment|/* Line offset for function */
name|struct
name|saved_fcn
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|saved_bf_symnum
block|{
name|long
name|symnum_fcn
decl_stmt|;
comment|/* Symnum of function (i.e. .function directive) */
name|long
name|symnum_bf
decl_stmt|;
comment|/* Symnum of .bf for this function */
name|struct
name|saved_bf_symnum
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|saved_fcn
name|SAVED_FUNCTION
typedef|,
modifier|*
name|SAVED_FUNCTION_PTR
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|saved_bf_symnum
name|SAVED_BF
typedef|,
modifier|*
name|SAVED_BF_PTR
typedef|;
end_typedef

begin_comment
comment|/* Local functions */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void clear_function_list PARAMS ((void)); static long get_bf_for_fcn PARAMS ((long)); static void clear_bf_list PARAMS ((void)); static void patch_all_commons_by_name PARAMS ((char *, CORE_ADDR, int)); static SAVED_F77_COMMON_PTR find_first_common_named PARAMS ((char *)); static void add_common_entry PARAMS ((struct symbol *)); static void add_common_block PARAMS ((char *, CORE_ADDR, int, char *)); static SAVED_FUNCTION *allocate_saved_function_node PARAMS ((void)); static SAVED_BF_PTR allocate_saved_bf_node PARAMS ((void)); static COMMON_ENTRY_PTR allocate_common_entry_node PARAMS ((void)); static SAVED_F77_COMMON_PTR allocate_saved_f77_common_node PARAMS ((void)); static void patch_common_entries PARAMS ((SAVED_F77_COMMON_PTR, CORE_ADDR, int));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|f_create_fundamental_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|f_printstr
name|PARAMS
argument_list|(
operator|(
name|GDB_FILE
operator|*
name|stream
operator|,
name|char
operator|*
name|string
operator|,
name|unsigned
name|int
name|length
operator|,
name|int
name|width
operator|,
name|int
name|force_ellipses
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|f_printchar
name|PARAMS
argument_list|(
operator|(
name|int
name|c
operator|,
name|GDB_FILE
operator|*
name|stream
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|f_emit_char
name|PARAMS
argument_list|(
operator|(
name|int
name|c
operator|,
name|GDB_FILE
operator|*
name|stream
operator|,
name|int
name|quoter
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print the character C on STREAM as part of the contents of a literal    string whose delimiter is QUOTER.  Note that that format for printing    characters and strings is language specific.    FIXME:  This is a copy of the same function from c-exp.y.  It should    be replaced with a true F77 version.  */
end_comment

begin_function
specifier|static
name|void
name|f_emit_char
parameter_list|(
name|c
parameter_list|,
name|stream
parameter_list|,
name|quoter
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|quoter
decl_stmt|;
block|{
name|c
operator|&=
literal|0xFF
expr_stmt|;
comment|/* Avoid sign bit follies */
if|if
condition|(
name|PRINT_LITERAL_FORM
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|||
name|c
operator|==
name|quoter
condition|)
name|fputs_filtered
argument_list|(
literal|"\\"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|fputs_filtered
argument_list|(
literal|"\\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|fputs_filtered
argument_list|(
literal|"\\b"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|fputs_filtered
argument_list|(
literal|"\\t"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
name|fputs_filtered
argument_list|(
literal|"\\f"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|fputs_filtered
argument_list|(
literal|"\\r"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\033'
case|:
name|fputs_filtered
argument_list|(
literal|"\\e"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\007'
case|:
name|fputs_filtered
argument_list|(
literal|"\\a"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\\%.3o"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* FIXME:  This is a copy of the same function from c-exp.y.  It should    be replaced with a true F77version. */
end_comment

begin_function
specifier|static
name|void
name|f_printchar
parameter_list|(
name|c
parameter_list|,
name|stream
parameter_list|)
name|int
name|c
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fputs_filtered
argument_list|(
literal|"'"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|LA_EMIT_CHAR
argument_list|(
name|c
argument_list|,
name|stream
argument_list|,
literal|'\''
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"'"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the character string STRING, printing at most LENGTH characters.    Printing stops early if the number hits print_max; repeat counts    are printed as appropriate.  Print ellipses at the end if we    had to stop before printing LENGTH characters, or if FORCE_ELLIPSES.    FIXME:  This is a copy of the same function from c-exp.y.  It should    be replaced with a true F77 version. */
end_comment

begin_function
specifier|static
name|void
name|f_printstr
parameter_list|(
name|stream
parameter_list|,
name|string
parameter_list|,
name|length
parameter_list|,
name|width
parameter_list|,
name|force_ellipses
parameter_list|)
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|unsigned
name|int
name|length
decl_stmt|;
name|int
name|width
decl_stmt|;
name|int
name|force_ellipses
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|things_printed
init|=
literal|0
decl_stmt|;
name|int
name|in_quotes
init|=
literal|0
decl_stmt|;
name|int
name|need_comma
init|=
literal|0
decl_stmt|;
specifier|extern
name|int
name|inspect_it
decl_stmt|;
specifier|extern
name|int
name|repeat_count_threshold
decl_stmt|;
specifier|extern
name|int
name|print_max
decl_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"''"
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
operator|&&
name|things_printed
operator|<
name|print_max
condition|;
operator|++
name|i
control|)
block|{
comment|/* Position of the character we are examining 	 to see whether it is repeated.  */
name|unsigned
name|int
name|rep1
decl_stmt|;
comment|/* Number of repetitions we have detected so far.  */
name|unsigned
name|int
name|reps
decl_stmt|;
name|QUIT
expr_stmt|;
if|if
condition|(
name|need_comma
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|0
expr_stmt|;
block|}
name|rep1
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|reps
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|rep1
operator|<
name|length
operator|&&
name|string
index|[
name|rep1
index|]
operator|==
name|string
index|[
name|i
index|]
condition|)
block|{
operator|++
name|rep1
expr_stmt|;
operator|++
name|reps
expr_stmt|;
block|}
if|if
condition|(
name|reps
operator|>
name|repeat_count_threshold
condition|)
block|{
if|if
condition|(
name|in_quotes
condition|)
block|{
if|if
condition|(
name|inspect_it
condition|)
name|fputs_filtered
argument_list|(
literal|"\\', "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|"', "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|in_quotes
operator|=
literal|0
expr_stmt|;
block|}
name|f_printchar
argument_list|(
name|string
index|[
name|i
index|]
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<repeats %u times>"
argument_list|,
name|reps
argument_list|)
expr_stmt|;
name|i
operator|=
name|rep1
operator|-
literal|1
expr_stmt|;
name|things_printed
operator|+=
name|repeat_count_threshold
expr_stmt|;
name|need_comma
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|in_quotes
condition|)
block|{
if|if
condition|(
name|inspect_it
condition|)
name|fputs_filtered
argument_list|(
literal|"\\'"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|"'"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|in_quotes
operator|=
literal|1
expr_stmt|;
block|}
name|LA_EMIT_CHAR
argument_list|(
name|string
index|[
name|i
index|]
argument_list|,
name|stream
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
operator|++
name|things_printed
expr_stmt|;
block|}
block|}
comment|/* Terminate the quotes if necessary.  */
if|if
condition|(
name|in_quotes
condition|)
block|{
if|if
condition|(
name|inspect_it
condition|)
name|fputs_filtered
argument_list|(
literal|"\\'"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|"'"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|force_ellipses
operator|||
name|i
operator|<
name|length
condition|)
name|fputs_filtered
argument_list|(
literal|"..."
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* FIXME:  This is a copy of c_create_fundamental_type(), before    all the non-C types were stripped from it.  Needs to be fixed    by an experienced F77 programmer. */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|f_create_fundamental_type
parameter_list|(
name|objfile
parameter_list|,
name|typeid
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|int
name|typeid
decl_stmt|;
block|{
specifier|register
name|struct
name|type
modifier|*
name|type
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|typeid
condition|)
block|{
case|case
name|FT_VOID
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_VOID
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"VOID"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_BOOLEAN
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_BOOL
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"boolean"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_STRING
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_STRING
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"string"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_CHAR
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"character"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SIGNED_CHAR
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"integer*1"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_UNSIGNED_CHAR
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_BOOL
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"logical*1"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SHORT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_SHORT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"integer*2"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SIGNED_SHORT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_SHORT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"short"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* FIXME-fnf */
break|break;
case|case
name|FT_UNSIGNED_SHORT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_BOOL
argument_list|,
name|TARGET_SHORT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"logical*2"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_INTEGER
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"integer*4"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SIGNED_INTEGER
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"integer"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* FIXME -fnf */
break|break;
case|case
name|FT_UNSIGNED_INTEGER
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_BOOL
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"logical*4"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_FIXED_DECIMAL
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"fixed decimal"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SIGNED_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* FIXME -fnf */
break|break;
case|case
name|FT_UNSIGNED_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_LONG_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"long long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SIGNED_LONG_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"signed long long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_UNSIGNED_LONG_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned long long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_FLOAT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_FLOAT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"real"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_DBL_PREC_FLOAT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"real*8"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_FLOAT_DECIMAL
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"floating decimal"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_EXT_PREC_FLOAT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_LONG_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"real*16"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_COMPLEX
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_COMPLEX
argument_list|,
literal|2
operator|*
name|TARGET_FLOAT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"complex*8"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|builtin_type_f_real
expr_stmt|;
break|break;
case|case
name|FT_DBL_PREC_COMPLEX
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_COMPLEX
argument_list|,
literal|2
operator|*
name|TARGET_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"complex*16"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|builtin_type_f_real_s8
expr_stmt|;
break|break;
case|case
name|FT_EXT_PREC_COMPLEX
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_COMPLEX
argument_list|,
literal|2
operator|*
name|TARGET_LONG_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"complex*32"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|builtin_type_f_real_s16
expr_stmt|;
break|break;
default|default:
comment|/* FIXME:  For now, if we are asked to produce a type not in this 	 language, create the equivalent of a C integer type with the 	 name "<?type?>".  When all the dust settles from the type 	 reconstruction work, this should probably become an error. */
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"<?type?>"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"internal error: no F77 fundamental type %d"
argument_list|,
name|typeid
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Table of operators and their precedences for printing expressions.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|op_print
name|f_op_print_tab
index|[]
init|=
block|{
block|{
literal|"+"
block|,
name|BINOP_ADD
block|,
name|PREC_ADD
block|,
literal|0
block|}
block|,
block|{
literal|"+"
block|,
name|UNOP_PLUS
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"-"
block|,
name|BINOP_SUB
block|,
name|PREC_ADD
block|,
literal|0
block|}
block|,
block|{
literal|"-"
block|,
name|UNOP_NEG
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"*"
block|,
name|BINOP_MUL
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"/"
block|,
name|BINOP_DIV
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"DIV"
block|,
name|BINOP_INTDIV
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"MOD"
block|,
name|BINOP_REM
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"="
block|,
name|BINOP_ASSIGN
block|,
name|PREC_ASSIGN
block|,
literal|1
block|}
block|,
block|{
literal|".OR."
block|,
name|BINOP_LOGICAL_OR
block|,
name|PREC_LOGICAL_OR
block|,
literal|0
block|}
block|,
block|{
literal|".AND."
block|,
name|BINOP_LOGICAL_AND
block|,
name|PREC_LOGICAL_AND
block|,
literal|0
block|}
block|,
block|{
literal|".NOT."
block|,
name|UNOP_LOGICAL_NOT
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|".EQ."
block|,
name|BINOP_EQUAL
block|,
name|PREC_EQUAL
block|,
literal|0
block|}
block|,
block|{
literal|".NE."
block|,
name|BINOP_NOTEQUAL
block|,
name|PREC_EQUAL
block|,
literal|0
block|}
block|,
block|{
literal|".LE."
block|,
name|BINOP_LEQ
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|".GE."
block|,
name|BINOP_GEQ
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|".GT."
block|,
name|BINOP_GTR
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|".LT."
block|,
name|BINOP_LESS
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|"**"
block|,
name|UNOP_IND
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"@"
block|,
name|BINOP_REPEAT
block|,
name|PREC_REPEAT
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function_decl
name|struct
name|type
modifier|*
modifier|*
name|CONST_PTR
parameter_list|(
name|f_builtin_types
index|[]
parameter_list|)
init|=
block|{
operator|&
name|builtin_type_f_character
operator|,
function_decl|&builtin_type_f_logical
operator|,
function_decl|&builtin_type_f_logical_s1
operator|,
function_decl|&builtin_type_f_logical_s2
operator|,
function_decl|&builtin_type_f_integer
operator|,
function_decl|&builtin_type_f_integer_s2
operator|,
function_decl|&builtin_type_f_real
operator|,
function_decl|&builtin_type_f_real_s8
operator|,
function_decl|&builtin_type_f_real_s16
operator|,
function_decl|&builtin_type_f_complex_s8
operator|,
function_decl|&builtin_type_f_complex_s16
operator|,
if|#
directive|if
literal|0
function_decl|&builtin_type_f_complex_s32,
endif|#
directive|endif
function_decl|&builtin_type_f_void
operator|,
function_decl|0
end_function_decl

begin_comment
unit|};
comment|/* This is declared in c-lang.h but it is silly to import that file for what    is already just a hack. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|c_value_print
name|PARAMS
argument_list|(
operator|(
expr|struct
name|value
operator|*
operator|,
name|GDB_FILE
operator|*
operator|,
name|int
operator|,
expr|enum
name|val_prettyprint
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|struct
name|language_defn
name|f_language_defn
init|=
block|{
literal|"fortran"
block|,
name|language_fortran
block|,
name|f_builtin_types
block|,
name|range_check_on
block|,
name|type_check_on
block|,
name|f_parse
block|,
comment|/* parser */
name|f_error
block|,
comment|/* parser error function */
name|evaluate_subexp_standard
block|,
name|f_printchar
block|,
comment|/* Print character constant */
name|f_printstr
block|,
comment|/* function to print string constant */
name|f_emit_char
block|,
comment|/* Function to print a single character */
name|f_create_fundamental_type
block|,
comment|/* Create fundamental type in this language */
name|f_print_type
block|,
comment|/* Print a type using appropriate syntax */
name|f_val_print
block|,
comment|/* Print a value using appropriate syntax */
name|c_value_print
block|,
comment|/* FIXME */
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
comment|/* Binary format info */
block|{
literal|"0%o"
block|,
literal|"0"
block|,
literal|"o"
block|,
literal|""
block|}
block|,
comment|/* Octal format info */
block|{
literal|"%d"
block|,
literal|""
block|,
literal|"d"
block|,
literal|""
block|}
block|,
comment|/* Decimal format info */
block|{
literal|"0x%x"
block|,
literal|"0x"
block|,
literal|"x"
block|,
literal|""
block|}
block|,
comment|/* Hex format info */
name|f_op_print_tab
block|,
comment|/* expression operators for printing */
literal|0
block|,
comment|/* arrays are first-class (not c-style) */
literal|1
block|,
comment|/* String lower bound */
operator|&
name|builtin_type_f_character
block|,
comment|/* Type of string elements */
name|LANG_MAGIC
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_f_language
parameter_list|()
block|{
name|builtin_type_f_void
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_VOID
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"VOID"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_f_character
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"character"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_f_logical_s1
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_BOOL
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"logical*1"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_f_integer_s2
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_SHORT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"integer*2"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_f_logical_s2
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_BOOL
argument_list|,
name|TARGET_SHORT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"logical*2"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_f_integer
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"integer"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_f_logical
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_BOOL
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"logical*4"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_f_real
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_FLOAT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"real"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_f_real_s8
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"real*8"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_f_real_s16
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_LONG_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"real*16"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_f_complex_s8
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_COMPLEX
argument_list|,
literal|2
operator|*
name|TARGET_FLOAT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"complex*8"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|builtin_type_f_complex_s8
argument_list|)
operator|=
name|builtin_type_f_real
expr_stmt|;
name|builtin_type_f_complex_s16
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_COMPLEX
argument_list|,
literal|2
operator|*
name|TARGET_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"complex*16"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|builtin_type_f_complex_s16
argument_list|)
operator|=
name|builtin_type_f_real_s8
expr_stmt|;
comment|/* We have a new size == 4 double floats for the      complex*32 data type */
name|builtin_type_f_complex_s32
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_COMPLEX
argument_list|,
literal|2
operator|*
name|TARGET_LONG_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"complex*32"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|builtin_type_f_complex_s32
argument_list|)
operator|=
name|builtin_type_f_real_s16
expr_stmt|;
name|builtin_type_string
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_STRING
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"character string"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|add_language
argument_list|(
operator|&
name|f_language_defn
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static SAVED_BF_PTR allocate_saved_bf_node() {   SAVED_BF_PTR new;      new = (SAVED_BF_PTR) xmalloc (sizeof (SAVED_BF));   return(new); }  static SAVED_FUNCTION * allocate_saved_function_node() {   SAVED_FUNCTION *new;      new = (SAVED_FUNCTION *) xmalloc (sizeof (SAVED_FUNCTION));   return(new); }  static SAVED_F77_COMMON_PTR allocate_saved_f77_common_node() {   SAVED_F77_COMMON_PTR new;      new = (SAVED_F77_COMMON_PTR) xmalloc (sizeof (SAVED_F77_COMMON));   return(new); }  static COMMON_ENTRY_PTR allocate_common_entry_node() {   COMMON_ENTRY_PTR new;      new = (COMMON_ENTRY_PTR) xmalloc (sizeof (COMMON_ENTRY));   return(new); }
endif|#
directive|endif
end_endif

begin_decl_stmt
name|SAVED_F77_COMMON_PTR
name|head_common_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Ptr to 1st saved COMMON  */
end_comment

begin_decl_stmt
name|SAVED_F77_COMMON_PTR
name|tail_common_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Ptr to last saved COMMON  */
end_comment

begin_decl_stmt
name|SAVED_F77_COMMON_PTR
name|current_common
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Ptr to current COMMON */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static SAVED_BF_PTR saved_bf_list=NULL;
comment|/* Ptr to (.bf,function)                                                      list*/
end_comment

begin_comment
unit|static SAVED_BF_PTR saved_bf_list_end=NULL;
comment|/* Ptr to above list's end */
end_comment

begin_comment
unit|static SAVED_BF_PTR current_head_bf_list=NULL;
comment|/* Current head of above list 						  */
end_comment

begin_comment
unit|static SAVED_BF_PTR tmp_bf_ptr;
comment|/* Generic temporary for use                                                      in macros */
end_comment

begin_comment
comment|/* The following function simply enters a given common block onto     the global common block chain */
end_comment

begin_comment
unit|static void add_common_block(name,offset,secnum,func_stab)      char *name;      CORE_ADDR offset;      int secnum;      char *func_stab; {   SAVED_F77_COMMON_PTR tmp;   char *c,*local_copy_func_stab;
comment|/* If the COMMON block we are trying to add has a blank       name (i.e. "#BLNK_COM") then we set it to __BLANK      because the darn "#" character makes GDB's input       parser have fits. */
end_comment

begin_comment
unit|if (STREQ(name,BLANK_COMMON_NAME_ORIGINAL) ||       STREQ(name,BLANK_COMMON_NAME_MF77))     {              free(name);       name = alloca(strlen(BLANK_COMMON_NAME_LOCAL) + 1);        strcpy(name,BLANK_COMMON_NAME_LOCAL);      }      tmp = allocate_saved_f77_common_node();      local_copy_func_stab = xmalloc (strlen(func_stab) + 1);   strcpy(local_copy_func_stab,func_stab);       tmp->name = xmalloc(strlen(name) + 1);
comment|/* local_copy_func_stab is a stabstring, let us first extract the       function name from the stab by NULLing out the ':' character. */
end_comment

begin_endif
unit|c = NULL;    c = strchr(local_copy_func_stab,':');      if (c)     *c = '\0';   else     error("Malformed function STAB found in add_common_block()");         tmp->owning_function = xmalloc (strlen(local_copy_func_stab) + 1);       strcpy(tmp->owning_function,local_copy_func_stab);       strcpy(tmp->name,name);   tmp->offset = offset;    tmp->next = NULL;   tmp->entries = NULL;   tmp->secnum = secnum;       current_common = tmp;      if (head_common_list == NULL)     {       head_common_list = tail_common_list = tmp;     }   else     {       tail_common_list->next = tmp;        tail_common_list = tmp;     } }
endif|#
directive|endif
end_endif

begin_comment
comment|/* The following function simply enters a given common entry onto     the "current_common" block that has been saved away. */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static void add_common_entry(entry_sym_ptr)      struct symbol *entry_sym_ptr;  {   COMMON_ENTRY_PTR tmp;
comment|/* The order of this list is important, since       we expect the entries to appear in decl.      order when we later issue "info common" calls */
end_comment

begin_endif
unit|tmp = allocate_common_entry_node();      tmp->next = NULL;   tmp->symbol = entry_sym_ptr;      if (current_common == NULL)     error("Attempt to add COMMON entry with no block open!");   else              {       if (current_common->entries == NULL) 	{ 	  current_common->entries = tmp; 	  current_common->end_of_entries = tmp;  	}       else 	{ 	  current_common->end_of_entries->next = tmp;  	  current_common->end_of_entries = tmp;  	}     } }
endif|#
directive|endif
end_endif

begin_comment
comment|/* This routine finds the first encountred COMMON block named "name" */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static SAVED_F77_COMMON_PTR find_first_common_named(name)      char *name;  {      SAVED_F77_COMMON_PTR tmp;      tmp = head_common_list;      while (tmp != NULL)     {       if (STREQ(tmp->name,name)) 	return(tmp);       else 	tmp = tmp->next;     }   return(NULL);  }
endif|#
directive|endif
end_endif

begin_comment
comment|/* This routine finds the first encountred COMMON block named "name"     that belongs to function funcname */
end_comment

begin_function
name|SAVED_F77_COMMON_PTR
name|find_common_for_function
parameter_list|(
name|name
parameter_list|,
name|funcname
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|funcname
decl_stmt|;
block|{
name|SAVED_F77_COMMON_PTR
name|tmp
decl_stmt|;
name|tmp
operator|=
name|head_common_list
expr_stmt|;
while|while
condition|(
name|tmp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|tmp
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|&&
name|STREQ
argument_list|(
name|tmp
operator|->
name|owning_function
argument_list|,
name|funcname
argument_list|)
condition|)
return|return
operator|(
name|tmp
operator|)
return|;
else|else
name|tmp
operator|=
name|tmp
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* The following function is called to patch up the offsets     for the statics contained in the COMMON block named    "name."  */
end_comment

begin_comment
unit|static void patch_common_entries (blk, offset, secnum)      SAVED_F77_COMMON_PTR blk;      CORE_ADDR offset;      int secnum; {   COMMON_ENTRY_PTR entry;      blk->offset = offset;
comment|/* Keep this around for future use. */
end_comment

begin_comment
unit|entry = blk->entries;      while (entry != NULL)     {       SYMBOL_VALUE (entry->symbol) += offset;        SYMBOL_SECTION (entry->symbol) = secnum;              entry = entry->next;     }   blk->secnum = secnum;  }
comment|/* Patch all commons named "name" that need patching.Since COMMON    blocks occur with relative infrequency, we simply do a linear scan on    the name.  Eventually, the best way to do this will be a    hashed-lookup.  Secnum is the section number for the .bss section    (which is where common data lives). */
end_comment

begin_comment
unit|static void patch_all_commons_by_name (name, offset, secnum)      char *name;      CORE_ADDR offset;      int secnum; {      SAVED_F77_COMMON_PTR tmp;
comment|/* For blank common blocks, change the canonical reprsentation       of a blank name */
end_comment

begin_endif
unit|if ((STREQ(name,BLANK_COMMON_NAME_ORIGINAL)) ||       (STREQ(name,BLANK_COMMON_NAME_MF77)))     {       free(name);       name = alloca(strlen(BLANK_COMMON_NAME_LOCAL) + 1);        strcpy(name,BLANK_COMMON_NAME_LOCAL);      }      tmp = head_common_list;      while (tmp != NULL)     {       if (COMMON_NEEDS_PATCHING(tmp)) 	if (STREQ(tmp->name,name)) 	  patch_common_entries(tmp,offset,secnum);               tmp = tmp->next;     }    }
endif|#
directive|endif
end_endif

begin_comment
comment|/* This macro adds the symbol-number for the start of the function     (the symbol number of the .bf) referenced by symnum_fcn to a     list.  This list, in reality should be a FIFO queue but since     #line pragmas sometimes cause line ranges to get messed up     we simply create a linear list.  This list can then be searched     first by a queueing algorithm and upon failure fall back to     a linear scan. */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|ADD_BF_SYMNUM
parameter_list|(
name|bf_sym
parameter_list|,
name|fcn_sym
parameter_list|)
define|\   \
value|if (saved_bf_list == NULL) \ { \     tmp_bf_ptr = allocate_saved_bf_node(); \       \ 	tmp_bf_ptr->symnum_bf = (bf_sym); \ 	  tmp_bf_ptr->symnum_fcn = (fcn_sym);  \ 	    tmp_bf_ptr->next = NULL; \ 	      \ 		current_head_bf_list = saved_bf_list = tmp_bf_ptr; \ 		  saved_bf_list_end = tmp_bf_ptr; \ 		  } \ else \ {  \      tmp_bf_ptr = allocate_saved_bf_node(); \        \          tmp_bf_ptr->symnum_bf = (bf_sym);  \ 	   tmp_bf_ptr->symnum_fcn = (fcn_sym);  \ 	     tmp_bf_ptr->next = NULL;  \ 	       \ 		 saved_bf_list_end->next = tmp_bf_ptr;  \ 		   saved_bf_list_end = tmp_bf_ptr; \ 		   }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This function frees the entire (.bf,function) list */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void    clear_bf_list() {      SAVED_BF_PTR tmp = saved_bf_list;   SAVED_BF_PTR next = NULL;       while (tmp != NULL)     {       next = tmp->next;       free(tmp);       tmp=next;     }   saved_bf_list = NULL; }
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|global_remote_debug
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static long get_bf_for_fcn (the_function)      long the_function; {   SAVED_BF_PTR tmp;   int nprobes = 0;
comment|/* First use a simple queuing algorithm (i.e. look and see if the       item at the head of the queue is the one you want)  */
end_comment

begin_comment
unit|if (saved_bf_list == NULL)     fatal ("cannot get .bf node off empty list");       if (current_head_bf_list != NULL)      if (current_head_bf_list->symnum_fcn == the_function)       { 	if (global_remote_debug)  	  fprintf(stderr,"*");   	tmp = current_head_bf_list;  	current_head_bf_list = current_head_bf_list->next; 	return(tmp->symnum_bf);        }
comment|/* If the above did not work (probably because #line directives were       used in the sourcefile and they messed up our internal tables) we now do      the ugly linear scan */
end_comment

begin_endif
unit|if (global_remote_debug)      fprintf(stderr,"\ndefaulting to linear scan\n");       nprobes = 0;    tmp = saved_bf_list;   while (tmp != NULL)     {       nprobes++;        if (tmp->symnum_fcn == the_function) 	{  	  if (global_remote_debug) 	    fprintf(stderr,"Found in %d probes\n",nprobes); 	  current_head_bf_list = tmp->next; 	  return(tmp->symnum_bf); 	}        tmp= tmp->next;      }      return(-1);  }  static SAVED_FUNCTION_PTR saved_function_list=NULL;  static SAVED_FUNCTION_PTR saved_function_list_end=NULL;   static void clear_function_list() {   SAVED_FUNCTION_PTR tmp = saved_function_list;   SAVED_FUNCTION_PTR next = NULL;       while (tmp != NULL)     {       next = tmp->next;       free(tmp);       tmp = next;     }      saved_function_list = NULL; }
endif|#
directive|endif
end_endif

end_unit

