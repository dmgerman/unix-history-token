begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Fortran language support routines for GDB, the GNU debugger.    Copyright 1993, 1994, 1996 Free Software Foundation, Inc.    Contributed by Motorola.  Adapted from the C parser by Farooq Butt    (fmbutt@engage.sps.mot.com).  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"parser-defs.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"f-lang.h"
end_include

begin_comment
comment|/* The built-in types of F77.  FIXME: integer*4 is missing, plain    logical is missing (builtin_type_logical is logical*4).  */
end_comment

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_f_character
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_f_logical
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_f_logical_s1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_f_logical_s2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_f_integer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_f_integer_s2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_f_real
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_f_real_s8
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_f_real_s16
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_f_complex_s8
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_f_complex_s16
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_f_complex_s32
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_f_void
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print the character C on STREAM as part of the contents of a literal    string whose delimiter is QUOTER.  Note that that format for printing    characters and strings is language specific.    FIXME:  This is a copy of the same function from c-exp.y.  It should    be replaced with a true F77 version.  */
end_comment

begin_function
specifier|static
name|void
name|emit_char
parameter_list|(
name|c
parameter_list|,
name|stream
parameter_list|,
name|quoter
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|quoter
decl_stmt|;
block|{
name|c
operator|&=
literal|0xFF
expr_stmt|;
comment|/* Avoid sign bit follies */
if|if
condition|(
name|PRINT_LITERAL_FORM
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|||
name|c
operator|==
name|quoter
condition|)
name|fputs_filtered
argument_list|(
literal|"\\"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|fputs_filtered
argument_list|(
literal|"\\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|fputs_filtered
argument_list|(
literal|"\\b"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|fputs_filtered
argument_list|(
literal|"\\t"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
name|fputs_filtered
argument_list|(
literal|"\\f"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|fputs_filtered
argument_list|(
literal|"\\r"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\033'
case|:
name|fputs_filtered
argument_list|(
literal|"\\e"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\007'
case|:
name|fputs_filtered
argument_list|(
literal|"\\a"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\\%.3o"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* FIXME:  This is a copy of the same function from c-exp.y.  It should    be replaced with a true F77version. */
end_comment

begin_function
specifier|static
name|void
name|f_printchar
parameter_list|(
name|c
parameter_list|,
name|stream
parameter_list|)
name|int
name|c
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|fputs_filtered
argument_list|(
literal|"'"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|emit_char
argument_list|(
name|c
argument_list|,
name|stream
argument_list|,
literal|'\''
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"'"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the character string STRING, printing at most LENGTH characters.    Printing stops early if the number hits print_max; repeat counts    are printed as appropriate.  Print ellipses at the end if we    had to stop before printing LENGTH characters, or if FORCE_ELLIPSES.    FIXME:  This is a copy of the same function from c-exp.y.  It should    be replaced with a true F77 version. */
end_comment

begin_function
specifier|static
name|void
name|f_printstr
parameter_list|(
name|stream
parameter_list|,
name|string
parameter_list|,
name|length
parameter_list|,
name|force_ellipses
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|unsigned
name|int
name|length
decl_stmt|;
name|int
name|force_ellipses
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|things_printed
init|=
literal|0
decl_stmt|;
name|int
name|in_quotes
init|=
literal|0
decl_stmt|;
name|int
name|need_comma
init|=
literal|0
decl_stmt|;
specifier|extern
name|int
name|inspect_it
decl_stmt|;
specifier|extern
name|int
name|repeat_count_threshold
decl_stmt|;
specifier|extern
name|int
name|print_max
decl_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"''"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
operator|&&
name|things_printed
operator|<
name|print_max
condition|;
operator|++
name|i
control|)
block|{
comment|/* Position of the character we are examining 	 to see whether it is repeated.  */
name|unsigned
name|int
name|rep1
decl_stmt|;
comment|/* Number of repetitions we have detected so far.  */
name|unsigned
name|int
name|reps
decl_stmt|;
name|QUIT
expr_stmt|;
if|if
condition|(
name|need_comma
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|0
expr_stmt|;
block|}
name|rep1
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|reps
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|rep1
operator|<
name|length
operator|&&
name|string
index|[
name|rep1
index|]
operator|==
name|string
index|[
name|i
index|]
condition|)
block|{
operator|++
name|rep1
expr_stmt|;
operator|++
name|reps
expr_stmt|;
block|}
if|if
condition|(
name|reps
operator|>
name|repeat_count_threshold
condition|)
block|{
if|if
condition|(
name|in_quotes
condition|)
block|{
if|if
condition|(
name|inspect_it
condition|)
name|fputs_filtered
argument_list|(
literal|"\\', "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|"', "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|in_quotes
operator|=
literal|0
expr_stmt|;
block|}
name|f_printchar
argument_list|(
name|string
index|[
name|i
index|]
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<repeats %u times>"
argument_list|,
name|reps
argument_list|)
expr_stmt|;
name|i
operator|=
name|rep1
operator|-
literal|1
expr_stmt|;
name|things_printed
operator|+=
name|repeat_count_threshold
expr_stmt|;
name|need_comma
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|in_quotes
condition|)
block|{
if|if
condition|(
name|inspect_it
condition|)
name|fputs_filtered
argument_list|(
literal|"\\'"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|"'"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|in_quotes
operator|=
literal|1
expr_stmt|;
block|}
name|emit_char
argument_list|(
name|string
index|[
name|i
index|]
argument_list|,
name|stream
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
operator|++
name|things_printed
expr_stmt|;
block|}
block|}
comment|/* Terminate the quotes if necessary.  */
if|if
condition|(
name|in_quotes
condition|)
block|{
if|if
condition|(
name|inspect_it
condition|)
name|fputs_filtered
argument_list|(
literal|"\\'"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|"'"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|force_ellipses
operator|||
name|i
operator|<
name|length
condition|)
name|fputs_filtered
argument_list|(
literal|"..."
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* FIXME:  This is a copy of c_create_fundamental_type(), before    all the non-C types were stripped from it.  Needs to be fixed    by an experienced F77 programmer. */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|f_create_fundamental_type
parameter_list|(
name|objfile
parameter_list|,
name|typeid
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|int
name|typeid
decl_stmt|;
block|{
specifier|register
name|struct
name|type
modifier|*
name|type
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|typeid
condition|)
block|{
case|case
name|FT_VOID
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_VOID
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"VOID"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_BOOLEAN
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_BOOL
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"boolean"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_STRING
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_STRING
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"string"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_CHAR
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"character"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SIGNED_CHAR
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"integer*1"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_UNSIGNED_CHAR
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_BOOL
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"logical*1"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SHORT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_SHORT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"integer*2"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SIGNED_SHORT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_SHORT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"short"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* FIXME-fnf */
break|break;
case|case
name|FT_UNSIGNED_SHORT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_BOOL
argument_list|,
name|TARGET_SHORT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"logical*2"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_INTEGER
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"integer*4"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SIGNED_INTEGER
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"integer"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* FIXME -fnf */
break|break;
case|case
name|FT_UNSIGNED_INTEGER
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_BOOL
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"logical*4"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_FIXED_DECIMAL
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"fixed decimal"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SIGNED_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* FIXME -fnf */
break|break;
case|case
name|FT_UNSIGNED_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_LONG_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"long long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SIGNED_LONG_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"signed long long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_UNSIGNED_LONG_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned long long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_FLOAT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_FLOAT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"real"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_DBL_PREC_FLOAT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"real*8"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_FLOAT_DECIMAL
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"floating decimal"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_EXT_PREC_FLOAT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_LONG_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"real*16"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_COMPLEX
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_COMPLEX
argument_list|,
literal|2
operator|*
name|TARGET_FLOAT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"complex*8"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|builtin_type_f_real
expr_stmt|;
break|break;
case|case
name|FT_DBL_PREC_COMPLEX
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_COMPLEX
argument_list|,
literal|2
operator|*
name|TARGET_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"complex*16"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|builtin_type_f_real_s8
expr_stmt|;
break|break;
case|case
name|FT_EXT_PREC_COMPLEX
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_COMPLEX
argument_list|,
literal|2
operator|*
name|TARGET_LONG_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"complex*32"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|builtin_type_f_real_s16
expr_stmt|;
break|break;
default|default:
comment|/* FIXME:  For now, if we are asked to produce a type not in this 	 language, create the equivalent of a C integer type with the 	 name "<?type?>".  When all the dust settles from the type 	 reconstruction work, this should probably become an error. */
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"<?type?>"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"internal error: no F77 fundamental type %d"
argument_list|,
name|typeid
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Table of operators and their precedences for printing expressions.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|op_print
name|f_op_print_tab
index|[]
init|=
block|{
block|{
literal|"+"
block|,
name|BINOP_ADD
block|,
name|PREC_ADD
block|,
literal|0
block|}
block|,
block|{
literal|"+"
block|,
name|UNOP_PLUS
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"-"
block|,
name|BINOP_SUB
block|,
name|PREC_ADD
block|,
literal|0
block|}
block|,
block|{
literal|"-"
block|,
name|UNOP_NEG
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"*"
block|,
name|BINOP_MUL
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"/"
block|,
name|BINOP_DIV
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"DIV"
block|,
name|BINOP_INTDIV
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"MOD"
block|,
name|BINOP_REM
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"="
block|,
name|BINOP_ASSIGN
block|,
name|PREC_ASSIGN
block|,
literal|1
block|}
block|,
block|{
literal|".OR."
block|,
name|BINOP_LOGICAL_OR
block|,
name|PREC_LOGICAL_OR
block|,
literal|0
block|}
block|,
block|{
literal|".AND."
block|,
name|BINOP_LOGICAL_AND
block|,
name|PREC_LOGICAL_AND
block|,
literal|0
block|}
block|,
block|{
literal|".NOT."
block|,
name|UNOP_LOGICAL_NOT
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|".EQ."
block|,
name|BINOP_EQUAL
block|,
name|PREC_EQUAL
block|,
literal|0
block|}
block|,
block|{
literal|".NE."
block|,
name|BINOP_NOTEQUAL
block|,
name|PREC_EQUAL
block|,
literal|0
block|}
block|,
block|{
literal|".LE."
block|,
name|BINOP_LEQ
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|".GE."
block|,
name|BINOP_GEQ
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|".GT."
block|,
name|BINOP_GTR
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|".LT."
block|,
name|BINOP_LESS
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|"**"
block|,
name|UNOP_IND
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"@"
block|,
name|BINOP_REPEAT
block|,
name|PREC_REPEAT
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function_decl
name|struct
name|type
modifier|*
modifier|*
function_decl|const (
name|f_builtin_types
function_decl|[]
end_function_decl

begin_expr_stmt
unit|)
operator|=
block|{
operator|&
name|builtin_type_f_character
block|,
operator|&
name|builtin_type_f_logical
block|,
operator|&
name|builtin_type_f_logical_s1
block|,
operator|&
name|builtin_type_f_logical_s2
block|,
operator|&
name|builtin_type_f_integer
block|,
operator|&
name|builtin_type_f_integer_s2
block|,
operator|&
name|builtin_type_f_real
block|,
operator|&
name|builtin_type_f_real_s8
block|,
operator|&
name|builtin_type_f_real_s16
block|,
operator|&
name|builtin_type_f_complex_s8
block|,
operator|&
name|builtin_type_f_complex_s16
block|,
if|#
directive|if
literal|0
block|&builtin_type_f_complex_s32,
endif|#
directive|endif
operator|&
name|builtin_type_f_void
block|,
literal|0
block|}
expr_stmt|;
end_expr_stmt

begin_function_decl
name|int
name|c_value_print
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|const
name|struct
name|language_defn
name|f_language_defn
init|=
block|{
literal|"fortran"
block|,
name|language_fortran
block|,
name|f_builtin_types
block|,
name|range_check_on
block|,
name|type_check_on
block|,
name|f_parse
block|,
comment|/* parser */
name|f_error
block|,
comment|/* parser error function */
name|evaluate_subexp_standard
block|,
name|f_printchar
block|,
comment|/* Print character constant */
name|f_printstr
block|,
comment|/* function to print string constant */
name|f_create_fundamental_type
block|,
comment|/* Create fundamental type in this language */
name|f_print_type
block|,
comment|/* Print a type using appropriate syntax */
name|f_val_print
block|,
comment|/* Print a value using appropriate syntax */
name|c_value_print
block|,
comment|/* FIXME */
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
comment|/* Binary format info */
block|{
literal|"0%o"
block|,
literal|"0"
block|,
literal|"o"
block|,
literal|""
block|}
block|,
comment|/* Octal format info */
block|{
literal|"%d"
block|,
literal|""
block|,
literal|"d"
block|,
literal|""
block|}
block|,
comment|/* Decimal format info */
block|{
literal|"0x%x"
block|,
literal|"0x"
block|,
literal|"x"
block|,
literal|""
block|}
block|,
comment|/* Hex format info */
name|f_op_print_tab
block|,
comment|/* expression operators for printing */
literal|0
block|,
comment|/* arrays are first-class (not c-style) */
literal|1
block|,
comment|/* String lower bound */
operator|&
name|builtin_type_f_character
block|,
comment|/* Type of string elements */
name|LANG_MAGIC
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_f_language
parameter_list|()
block|{
name|builtin_type_f_void
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_VOID
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"VOID"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_f_character
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"character"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_f_logical_s1
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_BOOL
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"logical*1"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_f_integer_s2
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_SHORT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"integer*2"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_f_logical_s2
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_BOOL
argument_list|,
name|TARGET_SHORT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"logical*2"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_f_integer
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"integer"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_f_logical
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_BOOL
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"logical*4"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_f_real
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_FLOAT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"real"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_f_real_s8
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"real*8"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_f_real_s16
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_LONG_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"real*16"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_f_complex_s8
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_COMPLEX
argument_list|,
literal|2
operator|*
name|TARGET_FLOAT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"complex*8"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|builtin_type_f_complex_s8
argument_list|)
operator|=
name|builtin_type_f_real
expr_stmt|;
name|builtin_type_f_complex_s16
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_COMPLEX
argument_list|,
literal|2
operator|*
name|TARGET_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"complex*16"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|builtin_type_f_complex_s16
argument_list|)
operator|=
name|builtin_type_f_real_s8
expr_stmt|;
comment|/* We have a new size == 4 double floats for the      complex*32 data type */
name|builtin_type_f_complex_s32
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_COMPLEX
argument_list|,
literal|2
operator|*
name|TARGET_LONG_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"complex*32"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|builtin_type_f_complex_s32
argument_list|)
operator|=
name|builtin_type_f_real_s16
expr_stmt|;
name|builtin_type_string
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_STRING
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"character string"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|add_language
argument_list|(
operator|&
name|f_language_defn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Following is dubious stuff that had been in the xcoff reader. */
end_comment

begin_struct
struct|struct
name|saved_fcn
block|{
name|long
name|line_offset
decl_stmt|;
comment|/* Line offset for function */
name|struct
name|saved_fcn
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|saved_bf_symnum
block|{
name|long
name|symnum_fcn
decl_stmt|;
comment|/* Symnum of function (i.e. .function directive) */
name|long
name|symnum_bf
decl_stmt|;
comment|/* Symnum of .bf for this function */
name|struct
name|saved_bf_symnum
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|saved_fcn
name|SAVED_FUNCTION
typedef|,
modifier|*
name|SAVED_FUNCTION_PTR
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|saved_bf_symnum
name|SAVED_BF
typedef|,
modifier|*
name|SAVED_BF_PTR
typedef|;
end_typedef

begin_function
name|SAVED_BF_PTR
name|allocate_saved_bf_node
parameter_list|()
block|{
name|SAVED_BF_PTR
name|new
decl_stmt|;
name|new
operator|=
operator|(
name|SAVED_BF_PTR
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|SAVED_BF
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_function
name|SAVED_FUNCTION
modifier|*
name|allocate_saved_function_node
parameter_list|()
block|{
name|SAVED_FUNCTION
modifier|*
name|new
decl_stmt|;
name|new
operator|=
operator|(
name|SAVED_FUNCTION
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|SAVED_FUNCTION
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_function
name|SAVED_F77_COMMON_PTR
name|allocate_saved_f77_common_node
parameter_list|()
block|{
name|SAVED_F77_COMMON_PTR
name|new
decl_stmt|;
name|new
operator|=
operator|(
name|SAVED_F77_COMMON_PTR
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|SAVED_F77_COMMON
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_function
name|COMMON_ENTRY_PTR
name|allocate_common_entry_node
parameter_list|()
block|{
name|COMMON_ENTRY_PTR
name|new
decl_stmt|;
name|new
operator|=
operator|(
name|COMMON_ENTRY_PTR
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|COMMON_ENTRY
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|SAVED_F77_COMMON_PTR
name|head_common_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Ptr to 1st saved COMMON  */
end_comment

begin_decl_stmt
name|SAVED_F77_COMMON_PTR
name|tail_common_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Ptr to last saved COMMON  */
end_comment

begin_decl_stmt
name|SAVED_F77_COMMON_PTR
name|current_common
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Ptr to current COMMON */
end_comment

begin_decl_stmt
specifier|static
name|SAVED_BF_PTR
name|saved_bf_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Ptr to (.bf,function)                                                      list*/
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static SAVED_BF_PTR saved_bf_list_end=NULL;
comment|/* Ptr to above list's end */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|SAVED_BF_PTR
name|current_head_bf_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current head of above list 						  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static SAVED_BF_PTR tmp_bf_ptr;
comment|/* Generic temporary for use                                                      in macros */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The following function simply enters a given common block onto     the global common block chain */
end_comment

begin_function
name|void
name|add_common_block
parameter_list|(
name|name
parameter_list|,
name|offset
parameter_list|,
name|secnum
parameter_list|,
name|func_stab
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|CORE_ADDR
name|offset
decl_stmt|;
name|int
name|secnum
decl_stmt|;
name|char
modifier|*
name|func_stab
decl_stmt|;
block|{
name|SAVED_F77_COMMON_PTR
name|tmp
decl_stmt|;
name|char
modifier|*
name|c
decl_stmt|,
modifier|*
name|local_copy_func_stab
decl_stmt|;
comment|/* If the COMMON block we are trying to add has a blank       name (i.e. "#BLNK_COM") then we set it to __BLANK      because the darn "#" character makes GDB's input       parser have fits. */
if|if
condition|(
name|STREQ
argument_list|(
name|name
argument_list|,
name|BLANK_COMMON_NAME_ORIGINAL
argument_list|)
operator|||
name|STREQ
argument_list|(
name|name
argument_list|,
name|BLANK_COMMON_NAME_MF77
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|BLANK_COMMON_NAME_LOCAL
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|BLANK_COMMON_NAME_LOCAL
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|allocate_saved_f77_common_node
argument_list|()
expr_stmt|;
name|local_copy_func_stab
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|func_stab
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|local_copy_func_stab
argument_list|,
name|func_stab
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|name
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* local_copy_func_stab is a stabstring, let us first extract the       function name from the stab by NULLing out the ':' character. */
name|c
operator|=
name|NULL
expr_stmt|;
name|c
operator|=
name|strchr
argument_list|(
name|local_copy_func_stab
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
condition|)
operator|*
name|c
operator|=
literal|'\0'
expr_stmt|;
else|else
name|error
argument_list|(
literal|"Malformed function STAB found in add_common_block()"
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|owning_function
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|local_copy_func_stab
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmp
operator|->
name|owning_function
argument_list|,
name|local_copy_func_stab
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmp
operator|->
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|tmp
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|tmp
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|tmp
operator|->
name|entries
operator|=
name|NULL
expr_stmt|;
name|tmp
operator|->
name|secnum
operator|=
name|secnum
expr_stmt|;
name|current_common
operator|=
name|tmp
expr_stmt|;
if|if
condition|(
name|head_common_list
operator|==
name|NULL
condition|)
block|{
name|head_common_list
operator|=
name|tail_common_list
operator|=
name|tmp
expr_stmt|;
block|}
else|else
block|{
name|tail_common_list
operator|->
name|next
operator|=
name|tmp
expr_stmt|;
name|tail_common_list
operator|=
name|tmp
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The following function simply enters a given common entry onto     the "current_common" block that has been saved away. */
end_comment

begin_function
name|void
name|add_common_entry
parameter_list|(
name|entry_sym_ptr
parameter_list|)
name|struct
name|symbol
modifier|*
name|entry_sym_ptr
decl_stmt|;
block|{
name|COMMON_ENTRY_PTR
name|tmp
decl_stmt|;
comment|/* The order of this list is important, since       we expect the entries to appear in decl.      order when we later issue "info common" calls */
name|tmp
operator|=
name|allocate_common_entry_node
argument_list|()
expr_stmt|;
name|tmp
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|tmp
operator|->
name|symbol
operator|=
name|entry_sym_ptr
expr_stmt|;
if|if
condition|(
name|current_common
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Attempt to add COMMON entry with no block open!"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|current_common
operator|->
name|entries
operator|==
name|NULL
condition|)
block|{
name|current_common
operator|->
name|entries
operator|=
name|tmp
expr_stmt|;
name|current_common
operator|->
name|end_of_entries
operator|=
name|tmp
expr_stmt|;
block|}
else|else
block|{
name|current_common
operator|->
name|end_of_entries
operator|->
name|next
operator|=
name|tmp
expr_stmt|;
name|current_common
operator|->
name|end_of_entries
operator|=
name|tmp
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* This routine finds the first encountred COMMON block named "name" */
end_comment

begin_function
name|SAVED_F77_COMMON_PTR
name|find_first_common_named
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|SAVED_F77_COMMON_PTR
name|tmp
decl_stmt|;
name|tmp
operator|=
name|head_common_list
expr_stmt|;
while|while
condition|(
name|tmp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|tmp
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
return|return
operator|(
name|tmp
operator|)
return|;
else|else
name|tmp
operator|=
name|tmp
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This routine finds the first encountred COMMON block named "name"     that belongs to function funcname */
end_comment

begin_function
name|SAVED_F77_COMMON_PTR
name|find_common_for_function
parameter_list|(
name|name
parameter_list|,
name|funcname
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|funcname
decl_stmt|;
block|{
name|SAVED_F77_COMMON_PTR
name|tmp
decl_stmt|;
name|tmp
operator|=
name|head_common_list
expr_stmt|;
while|while
condition|(
name|tmp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|tmp
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|&&
name|STREQ
argument_list|(
name|tmp
operator|->
name|owning_function
argument_list|,
name|funcname
argument_list|)
condition|)
return|return
operator|(
name|tmp
operator|)
return|;
else|else
name|tmp
operator|=
name|tmp
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The following function is called to patch up the offsets     for the statics contained in the COMMON block named    "name."  */
end_comment

begin_function
name|void
name|patch_common_entries
parameter_list|(
name|blk
parameter_list|,
name|offset
parameter_list|,
name|secnum
parameter_list|)
name|SAVED_F77_COMMON_PTR
name|blk
decl_stmt|;
name|CORE_ADDR
name|offset
decl_stmt|;
name|int
name|secnum
decl_stmt|;
block|{
name|COMMON_ENTRY_PTR
name|entry
decl_stmt|;
name|blk
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
comment|/* Keep this around for future use. */
name|entry
operator|=
name|blk
operator|->
name|entries
expr_stmt|;
while|while
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
name|SYMBOL_VALUE
argument_list|(
name|entry
operator|->
name|symbol
argument_list|)
operator|+=
name|offset
expr_stmt|;
name|SYMBOL_SECTION
argument_list|(
name|entry
operator|->
name|symbol
argument_list|)
operator|=
name|secnum
expr_stmt|;
name|entry
operator|=
name|entry
operator|->
name|next
expr_stmt|;
block|}
name|blk
operator|->
name|secnum
operator|=
name|secnum
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Patch all commons named "name" that need patching.Since COMMON    blocks occur with relative infrequency, we simply do a linear scan on    the name.  Eventually, the best way to do this will be a    hashed-lookup.  Secnum is the section number for the .bss section    (which is where common data lives). */
end_comment

begin_function
name|void
name|patch_all_commons_by_name
parameter_list|(
name|name
parameter_list|,
name|offset
parameter_list|,
name|secnum
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|CORE_ADDR
name|offset
decl_stmt|;
name|int
name|secnum
decl_stmt|;
block|{
name|SAVED_F77_COMMON_PTR
name|tmp
decl_stmt|;
comment|/* For blank common blocks, change the canonical reprsentation       of a blank name */
if|if
condition|(
operator|(
name|STREQ
argument_list|(
name|name
argument_list|,
name|BLANK_COMMON_NAME_ORIGINAL
argument_list|)
operator|)
operator|||
operator|(
name|STREQ
argument_list|(
name|name
argument_list|,
name|BLANK_COMMON_NAME_MF77
argument_list|)
operator|)
condition|)
block|{
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|name
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|BLANK_COMMON_NAME_LOCAL
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name
argument_list|,
name|BLANK_COMMON_NAME_LOCAL
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|head_common_list
expr_stmt|;
while|while
condition|(
name|tmp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|COMMON_NEEDS_PATCHING
argument_list|(
name|tmp
argument_list|)
condition|)
if|if
condition|(
name|STREQ
argument_list|(
name|tmp
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
name|patch_common_entries
argument_list|(
name|tmp
argument_list|,
name|offset
argument_list|,
name|secnum
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|tmp
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This macro adds the symbol-number for the start of the function     (the symbol number of the .bf) referenced by symnum_fcn to a     list.  This list, in reality should be a FIFO queue but since     #line pragmas sometimes cause line ranges to get messed up     we simply create a linear list.  This list can then be searched     first by a queueing algorithm and upon failure fall back to     a linear scan. */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|ADD_BF_SYMNUM
parameter_list|(
name|bf_sym
parameter_list|,
name|fcn_sym
parameter_list|)
define|\   \
value|if (saved_bf_list == NULL) \ { \     tmp_bf_ptr = allocate_saved_bf_node(); \       \ 	tmp_bf_ptr->symnum_bf = (bf_sym); \ 	  tmp_bf_ptr->symnum_fcn = (fcn_sym);  \ 	    tmp_bf_ptr->next = NULL; \ 	      \ 		current_head_bf_list = saved_bf_list = tmp_bf_ptr; \ 		  saved_bf_list_end = tmp_bf_ptr; \ 		  } \ else \ {  \      tmp_bf_ptr = allocate_saved_bf_node(); \        \          tmp_bf_ptr->symnum_bf = (bf_sym);  \ 	   tmp_bf_ptr->symnum_fcn = (fcn_sym);  \ 	     tmp_bf_ptr->next = NULL;  \ 	       \ 		 saved_bf_list_end->next = tmp_bf_ptr;  \ 		   saved_bf_list_end = tmp_bf_ptr; \ 		   }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This function frees the entire (.bf,function) list */
end_comment

begin_function
name|void
name|clear_bf_list
parameter_list|()
block|{
name|SAVED_BF_PTR
name|tmp
init|=
name|saved_bf_list
decl_stmt|;
name|SAVED_BF_PTR
name|next
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|tmp
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|tmp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|next
expr_stmt|;
block|}
name|saved_bf_list
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|global_remote_debug
decl_stmt|;
end_decl_stmt

begin_function
name|long
name|get_bf_for_fcn
parameter_list|(
name|the_function
parameter_list|)
name|long
name|the_function
decl_stmt|;
block|{
name|SAVED_BF_PTR
name|tmp
decl_stmt|;
name|int
name|nprobes
init|=
literal|0
decl_stmt|;
comment|/* First use a simple queuing algorithm (i.e. look and see if the       item at the head of the queue is the one you want)  */
if|if
condition|(
name|saved_bf_list
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"cannot get .bf node off empty list"
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_head_bf_list
operator|!=
name|NULL
condition|)
if|if
condition|(
name|current_head_bf_list
operator|->
name|symnum_fcn
operator|==
name|the_function
condition|)
block|{
if|if
condition|(
name|global_remote_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|current_head_bf_list
expr_stmt|;
name|current_head_bf_list
operator|=
name|current_head_bf_list
operator|->
name|next
expr_stmt|;
return|return
operator|(
name|tmp
operator|->
name|symnum_bf
operator|)
return|;
block|}
comment|/* If the above did not work (probably because #line directives were       used in the sourcefile and they messed up our internal tables) we now do      the ugly linear scan */
if|if
condition|(
name|global_remote_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ndefaulting to linear scan\n"
argument_list|)
expr_stmt|;
name|nprobes
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
name|saved_bf_list
expr_stmt|;
while|while
condition|(
name|tmp
operator|!=
name|NULL
condition|)
block|{
name|nprobes
operator|++
expr_stmt|;
if|if
condition|(
name|tmp
operator|->
name|symnum_fcn
operator|==
name|the_function
condition|)
block|{
if|if
condition|(
name|global_remote_debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Found in %d probes\n"
argument_list|,
name|nprobes
argument_list|)
expr_stmt|;
name|current_head_bf_list
operator|=
name|tmp
operator|->
name|next
expr_stmt|;
return|return
operator|(
name|tmp
operator|->
name|symnum_bf
operator|)
return|;
block|}
name|tmp
operator|=
name|tmp
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|SAVED_FUNCTION_PTR
name|saved_function_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Currently unused */
end_comment

begin_endif
unit|static SAVED_FUNCTION_PTR saved_function_list_end=NULL;
endif|#
directive|endif
end_endif

begin_function
name|void
name|clear_function_list
parameter_list|()
block|{
name|SAVED_FUNCTION_PTR
name|tmp
init|=
name|saved_function_list
decl_stmt|;
name|SAVED_FUNCTION_PTR
name|next
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|tmp
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|tmp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|next
expr_stmt|;
block|}
name|saved_function_list
operator|=
name|NULL
expr_stmt|;
block|}
end_function

end_unit

