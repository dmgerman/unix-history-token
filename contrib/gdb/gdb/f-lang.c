begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Fortran language support routines for GDB, the GNU debugger.    Copyright 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2002, 2003, 2004    Free Software Foundation, Inc.    Contributed by Motorola.  Adapted from the C parser by Farooq Butt    (fmbutt@engage.sps.mot.com).     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"parser-defs.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"f-lang.h"
end_include

begin_include
include|#
directive|include
file|"valprint.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_comment
comment|/* The built-in types of F77.  FIXME: integer*4 is missing, plain    logical is missing (builtin_type_logical is logical*4).  */
end_comment

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_f_character
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_f_logical
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_f_logical_s1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_f_logical_s2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_f_integer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_f_integer_s2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_f_real
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_f_real_s8
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_f_real_s16
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_f_complex_s8
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_f_complex_s16
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_f_complex_s32
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|type
modifier|*
name|builtin_type_f_void
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Following is dubious stuff that had been in the xcoff reader. */
end_comment

begin_struct
struct|struct
name|saved_fcn
block|{
name|long
name|line_offset
decl_stmt|;
comment|/* Line offset for function */
name|struct
name|saved_fcn
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|saved_bf_symnum
block|{
name|long
name|symnum_fcn
decl_stmt|;
comment|/* Symnum of function (i.e. .function directive) */
name|long
name|symnum_bf
decl_stmt|;
comment|/* Symnum of .bf for this function */
name|struct
name|saved_bf_symnum
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|saved_fcn
name|SAVED_FUNCTION
typedef|,
modifier|*
name|SAVED_FUNCTION_PTR
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|saved_bf_symnum
name|SAVED_BF
typedef|,
modifier|*
name|SAVED_BF_PTR
typedef|;
end_typedef

begin_comment
comment|/* Local functions */
end_comment

begin_function_decl
specifier|extern
name|void
name|_initialize_f_language
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void clear_function_list (void); static long get_bf_for_fcn (long); static void clear_bf_list (void); static void patch_all_commons_by_name (char *, CORE_ADDR, int); static SAVED_F77_COMMON_PTR find_first_common_named (char *); static void add_common_entry (struct symbol *); static void add_common_block (char *, CORE_ADDR, int, char *); static SAVED_FUNCTION *allocate_saved_function_node (void); static SAVED_BF_PTR allocate_saved_bf_node (void); static COMMON_ENTRY_PTR allocate_common_entry_node (void); static SAVED_F77_COMMON_PTR allocate_saved_f77_common_node (void); static void patch_common_entries (SAVED_F77_COMMON_PTR, CORE_ADDR, int);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|struct
name|type
modifier|*
name|f_create_fundamental_type
parameter_list|(
name|struct
name|objfile
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|f_printstr
parameter_list|(
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|char
modifier|*
name|string
parameter_list|,
name|unsigned
name|int
name|length
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|force_ellipses
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|f_printchar
parameter_list|(
name|int
name|c
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|f_emit_char
parameter_list|(
name|int
name|c
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|quoter
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Print the character C on STREAM as part of the contents of a literal    string whose delimiter is QUOTER.  Note that that format for printing    characters and strings is language specific.    FIXME:  This is a copy of the same function from c-exp.y.  It should    be replaced with a true F77 version.  */
end_comment

begin_function
specifier|static
name|void
name|f_emit_char
parameter_list|(
name|int
name|c
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|quoter
parameter_list|)
block|{
name|c
operator|&=
literal|0xFF
expr_stmt|;
comment|/* Avoid sign bit follies */
if|if
condition|(
name|PRINT_LITERAL_FORM
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|||
name|c
operator|==
name|quoter
condition|)
name|fputs_filtered
argument_list|(
literal|"\\"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
name|fputs_filtered
argument_list|(
literal|"\\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|fputs_filtered
argument_list|(
literal|"\\b"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|fputs_filtered
argument_list|(
literal|"\\t"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\f'
case|:
name|fputs_filtered
argument_list|(
literal|"\\f"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|fputs_filtered
argument_list|(
literal|"\\r"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\033'
case|:
name|fputs_filtered
argument_list|(
literal|"\\e"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\007'
case|:
name|fputs_filtered
argument_list|(
literal|"\\a"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\\%.3o"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/* FIXME:  This is a copy of the same function from c-exp.y.  It should    be replaced with a true F77version. */
end_comment

begin_function
specifier|static
name|void
name|f_printchar
parameter_list|(
name|int
name|c
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|fputs_filtered
argument_list|(
literal|"'"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|LA_EMIT_CHAR
argument_list|(
name|c
argument_list|,
name|stream
argument_list|,
literal|'\''
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"'"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the character string STRING, printing at most LENGTH characters.    Printing stops early if the number hits print_max; repeat counts    are printed as appropriate.  Print ellipses at the end if we    had to stop before printing LENGTH characters, or if FORCE_ELLIPSES.    FIXME:  This is a copy of the same function from c-exp.y.  It should    be replaced with a true F77 version. */
end_comment

begin_function
specifier|static
name|void
name|f_printstr
parameter_list|(
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|char
modifier|*
name|string
parameter_list|,
name|unsigned
name|int
name|length
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|force_ellipses
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|things_printed
init|=
literal|0
decl_stmt|;
name|int
name|in_quotes
init|=
literal|0
decl_stmt|;
name|int
name|need_comma
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"''"
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
operator|&&
name|things_printed
operator|<
name|print_max
condition|;
operator|++
name|i
control|)
block|{
comment|/* Position of the character we are examining          to see whether it is repeated.  */
name|unsigned
name|int
name|rep1
decl_stmt|;
comment|/* Number of repetitions we have detected so far.  */
name|unsigned
name|int
name|reps
decl_stmt|;
name|QUIT
expr_stmt|;
if|if
condition|(
name|need_comma
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|0
expr_stmt|;
block|}
name|rep1
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|reps
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|rep1
operator|<
name|length
operator|&&
name|string
index|[
name|rep1
index|]
operator|==
name|string
index|[
name|i
index|]
condition|)
block|{
operator|++
name|rep1
expr_stmt|;
operator|++
name|reps
expr_stmt|;
block|}
if|if
condition|(
name|reps
operator|>
name|repeat_count_threshold
condition|)
block|{
if|if
condition|(
name|in_quotes
condition|)
block|{
if|if
condition|(
name|inspect_it
condition|)
name|fputs_filtered
argument_list|(
literal|"\\', "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|"', "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|in_quotes
operator|=
literal|0
expr_stmt|;
block|}
name|f_printchar
argument_list|(
name|string
index|[
name|i
index|]
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<repeats %u times>"
argument_list|,
name|reps
argument_list|)
expr_stmt|;
name|i
operator|=
name|rep1
operator|-
literal|1
expr_stmt|;
name|things_printed
operator|+=
name|repeat_count_threshold
expr_stmt|;
name|need_comma
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|in_quotes
condition|)
block|{
if|if
condition|(
name|inspect_it
condition|)
name|fputs_filtered
argument_list|(
literal|"\\'"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|"'"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|in_quotes
operator|=
literal|1
expr_stmt|;
block|}
name|LA_EMIT_CHAR
argument_list|(
name|string
index|[
name|i
index|]
argument_list|,
name|stream
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
operator|++
name|things_printed
expr_stmt|;
block|}
block|}
comment|/* Terminate the quotes if necessary.  */
if|if
condition|(
name|in_quotes
condition|)
block|{
if|if
condition|(
name|inspect_it
condition|)
name|fputs_filtered
argument_list|(
literal|"\\'"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|"'"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|force_ellipses
operator|||
name|i
operator|<
name|length
condition|)
name|fputs_filtered
argument_list|(
literal|"..."
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* FIXME:  This is a copy of c_create_fundamental_type(), before    all the non-C types were stripped from it.  Needs to be fixed    by an experienced F77 programmer. */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|f_create_fundamental_type
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|int
name|typeid
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|typeid
condition|)
block|{
case|case
name|FT_VOID
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_VOID
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"VOID"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_BOOLEAN
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_BOOL
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"boolean"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_STRING
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_STRING
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"string"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_CHAR
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"character"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SIGNED_CHAR
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"integer*1"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_UNSIGNED_CHAR
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_BOOL
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"logical*1"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SHORT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_SHORT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"integer*2"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SIGNED_SHORT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_SHORT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"short"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* FIXME-fnf */
break|break;
case|case
name|FT_UNSIGNED_SHORT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_BOOL
argument_list|,
name|TARGET_SHORT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"logical*2"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_INTEGER
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"integer*4"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SIGNED_INTEGER
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"integer"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* FIXME -fnf */
break|break;
case|case
name|FT_UNSIGNED_INTEGER
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_BOOL
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"logical*4"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_FIXED_DECIMAL
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"fixed decimal"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SIGNED_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* FIXME -fnf */
break|break;
case|case
name|FT_UNSIGNED_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_LONG_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"long long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SIGNED_LONG_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"signed long long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_UNSIGNED_LONG_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned long long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_FLOAT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_FLOAT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"real"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_DBL_PREC_FLOAT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"real*8"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_FLOAT_DECIMAL
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"floating decimal"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_EXT_PREC_FLOAT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_LONG_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"real*16"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_COMPLEX
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_COMPLEX
argument_list|,
literal|2
operator|*
name|TARGET_FLOAT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"complex*8"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|builtin_type_f_real
expr_stmt|;
break|break;
case|case
name|FT_DBL_PREC_COMPLEX
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_COMPLEX
argument_list|,
literal|2
operator|*
name|TARGET_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"complex*16"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|builtin_type_f_real_s8
expr_stmt|;
break|break;
case|case
name|FT_EXT_PREC_COMPLEX
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_COMPLEX
argument_list|,
literal|2
operator|*
name|TARGET_LONG_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"complex*32"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|builtin_type_f_real_s16
expr_stmt|;
break|break;
default|default:
comment|/* FIXME:  For now, if we are asked to produce a type not in this          language, create the equivalent of a C integer type with the          name "<?type?>".  When all the dust settles from the type          reconstruction work, this should probably become an error. */
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"<?type?>"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"internal error: no F77 fundamental type %d"
argument_list|,
name|typeid
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Table of operators and their precedences for printing expressions.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|op_print
name|f_op_print_tab
index|[]
init|=
block|{
block|{
literal|"+"
block|,
name|BINOP_ADD
block|,
name|PREC_ADD
block|,
literal|0
block|}
block|,
block|{
literal|"+"
block|,
name|UNOP_PLUS
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"-"
block|,
name|BINOP_SUB
block|,
name|PREC_ADD
block|,
literal|0
block|}
block|,
block|{
literal|"-"
block|,
name|UNOP_NEG
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"*"
block|,
name|BINOP_MUL
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"/"
block|,
name|BINOP_DIV
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"DIV"
block|,
name|BINOP_INTDIV
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"MOD"
block|,
name|BINOP_REM
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"="
block|,
name|BINOP_ASSIGN
block|,
name|PREC_ASSIGN
block|,
literal|1
block|}
block|,
block|{
literal|".OR."
block|,
name|BINOP_LOGICAL_OR
block|,
name|PREC_LOGICAL_OR
block|,
literal|0
block|}
block|,
block|{
literal|".AND."
block|,
name|BINOP_LOGICAL_AND
block|,
name|PREC_LOGICAL_AND
block|,
literal|0
block|}
block|,
block|{
literal|".NOT."
block|,
name|UNOP_LOGICAL_NOT
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|".EQ."
block|,
name|BINOP_EQUAL
block|,
name|PREC_EQUAL
block|,
literal|0
block|}
block|,
block|{
literal|".NE."
block|,
name|BINOP_NOTEQUAL
block|,
name|PREC_EQUAL
block|,
literal|0
block|}
block|,
block|{
literal|".LE."
block|,
name|BINOP_LEQ
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|".GE."
block|,
name|BINOP_GEQ
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|".GT."
block|,
name|BINOP_GTR
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|".LT."
block|,
name|BINOP_LESS
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|"**"
block|,
name|UNOP_IND
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"@"
block|,
name|BINOP_REPEAT
block|,
name|PREC_REPEAT
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function_decl
name|struct
name|type
modifier|*
modifier|*
function_decl|const (
name|f_builtin_types
function_decl|[]
end_function_decl

begin_expr_stmt
unit|)
operator|=
block|{
operator|&
name|builtin_type_f_character
block|,
operator|&
name|builtin_type_f_logical
block|,
operator|&
name|builtin_type_f_logical_s1
block|,
operator|&
name|builtin_type_f_logical_s2
block|,
operator|&
name|builtin_type_f_integer
block|,
operator|&
name|builtin_type_f_integer_s2
block|,
operator|&
name|builtin_type_f_real
block|,
operator|&
name|builtin_type_f_real_s8
block|,
operator|&
name|builtin_type_f_real_s16
block|,
operator|&
name|builtin_type_f_complex_s8
block|,
operator|&
name|builtin_type_f_complex_s16
block|,
if|#
directive|if
literal|0
block|&builtin_type_f_complex_s32,
endif|#
directive|endif
operator|&
name|builtin_type_f_void
block|,
literal|0
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* This is declared in c-lang.h but it is silly to import that file for what    is already just a hack. */
end_comment

begin_function_decl
specifier|extern
name|int
name|c_value_print
parameter_list|(
name|struct
name|value
modifier|*
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|,
name|int
parameter_list|,
name|enum
name|val_prettyprint
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|const
name|struct
name|language_defn
name|f_language_defn
init|=
block|{
literal|"fortran"
block|,
name|language_fortran
block|,
name|f_builtin_types
block|,
name|range_check_on
block|,
name|type_check_on
block|,
name|case_sensitive_off
block|,
operator|&
name|exp_descriptor_standard
block|,
name|f_parse
block|,
comment|/* parser */
name|f_error
block|,
comment|/* parser error function */
name|f_printchar
block|,
comment|/* Print character constant */
name|f_printstr
block|,
comment|/* function to print string constant */
name|f_emit_char
block|,
comment|/* Function to print a single character */
name|f_create_fundamental_type
block|,
comment|/* Create fundamental type in this language */
name|f_print_type
block|,
comment|/* Print a type using appropriate syntax */
name|f_val_print
block|,
comment|/* Print a value using appropriate syntax */
name|c_value_print
block|,
comment|/* FIXME */
name|NULL
block|,
comment|/* Language specific skip_trampoline */
name|value_of_this
block|,
comment|/* value_of_this */
name|basic_lookup_symbol_nonlocal
block|,
comment|/* lookup_symbol_nonlocal */
name|basic_lookup_transparent_type
block|,
comment|/* lookup_transparent_type */
name|NULL
block|,
comment|/* Language specific symbol demangler */
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|}
block|,
comment|/* Binary format info */
block|{
literal|"0%o"
block|,
literal|"0"
block|,
literal|"o"
block|,
literal|""
block|}
block|,
comment|/* Octal format info */
block|{
literal|"%d"
block|,
literal|""
block|,
literal|"d"
block|,
literal|""
block|}
block|,
comment|/* Decimal format info */
block|{
literal|"0x%x"
block|,
literal|"0x"
block|,
literal|"x"
block|,
literal|""
block|}
block|,
comment|/* Hex format info */
name|f_op_print_tab
block|,
comment|/* expression operators for printing */
literal|0
block|,
comment|/* arrays are first-class (not c-style) */
literal|1
block|,
comment|/* String lower bound */
operator|&
name|builtin_type_f_character
block|,
comment|/* Type of string elements */
name|default_word_break_characters
block|,
name|LANG_MAGIC
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|build_fortran_types
parameter_list|(
name|void
parameter_list|)
block|{
name|builtin_type_f_void
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_VOID
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|"VOID"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_f_character
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"character"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_f_logical_s1
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_BOOL
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"logical*1"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_f_integer_s2
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_SHORT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"integer*2"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_f_logical_s2
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_BOOL
argument_list|,
name|TARGET_SHORT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"logical*2"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_f_integer
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"integer"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_f_logical
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_BOOL
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"logical*4"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_f_real
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_FLOAT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"real"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_f_real_s8
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"real*8"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_f_real_s16
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_LONG_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"real*16"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|builtin_type_f_complex_s8
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_COMPLEX
argument_list|,
literal|2
operator|*
name|TARGET_FLOAT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"complex*8"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|builtin_type_f_complex_s8
argument_list|)
operator|=
name|builtin_type_f_real
expr_stmt|;
name|builtin_type_f_complex_s16
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_COMPLEX
argument_list|,
literal|2
operator|*
name|TARGET_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"complex*16"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|builtin_type_f_complex_s16
argument_list|)
operator|=
name|builtin_type_f_real_s8
expr_stmt|;
comment|/* We have a new size == 4 double floats for the      complex*32 data type */
name|builtin_type_f_complex_s32
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_COMPLEX
argument_list|,
literal|2
operator|*
name|TARGET_LONG_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"complex*32"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|TYPE_TARGET_TYPE
argument_list|(
name|builtin_type_f_complex_s32
argument_list|)
operator|=
name|builtin_type_f_real_s16
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_f_language
parameter_list|(
name|void
parameter_list|)
block|{
name|build_fortran_types
argument_list|()
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_f_character
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_f_logical
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_f_logical_s1
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_f_logical_s2
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_f_integer
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_f_integer_s2
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_f_real
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_f_real_s8
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_f_real_s16
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_f_complex_s8
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_f_complex_s16
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_f_complex_s32
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_f_void
argument_list|)
expr_stmt|;
name|DEPRECATED_REGISTER_GDBARCH_SWAP
argument_list|(
name|builtin_type_string
argument_list|)
expr_stmt|;
name|deprecated_register_gdbarch_swap
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|build_fortran_types
argument_list|)
expr_stmt|;
name|builtin_type_string
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_STRING
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"character string"
argument_list|,
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|add_language
argument_list|(
operator|&
name|f_language_defn
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static SAVED_BF_PTR allocate_saved_bf_node (void) {   SAVED_BF_PTR new;    new = (SAVED_BF_PTR) xmalloc (sizeof (SAVED_BF));   return (new); }  static SAVED_FUNCTION * allocate_saved_function_node (void) {   SAVED_FUNCTION *new;    new = (SAVED_FUNCTION *) xmalloc (sizeof (SAVED_FUNCTION));   return (new); }  static SAVED_F77_COMMON_PTR allocate_saved_f77_common_node (void) {   SAVED_F77_COMMON_PTR new;    new = (SAVED_F77_COMMON_PTR) xmalloc (sizeof (SAVED_F77_COMMON));   return (new); }  static COMMON_ENTRY_PTR allocate_common_entry_node (void) {   COMMON_ENTRY_PTR new;    new = (COMMON_ENTRY_PTR) xmalloc (sizeof (COMMON_ENTRY));   return (new); }
endif|#
directive|endif
end_endif

begin_decl_stmt
name|SAVED_F77_COMMON_PTR
name|head_common_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Ptr to 1st saved COMMON  */
end_comment

begin_decl_stmt
name|SAVED_F77_COMMON_PTR
name|tail_common_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Ptr to last saved COMMON  */
end_comment

begin_decl_stmt
name|SAVED_F77_COMMON_PTR
name|current_common
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Ptr to current COMMON */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static SAVED_BF_PTR saved_bf_list = NULL;
comment|/* Ptr to (.bf,function)  						   list */
end_comment

begin_comment
unit|static SAVED_BF_PTR saved_bf_list_end = NULL;
comment|/* Ptr to above list's end */
end_comment

begin_comment
unit|static SAVED_BF_PTR current_head_bf_list = NULL;
comment|/* Current head of above list 							 */
end_comment

begin_comment
unit|static SAVED_BF_PTR tmp_bf_ptr;
comment|/* Generic temporary for use  				   in macros */
end_comment

begin_comment
comment|/* The following function simply enters a given common block onto     the global common block chain */
end_comment

begin_comment
unit|static void add_common_block (char *name, CORE_ADDR offset, int secnum, char *func_stab) {   SAVED_F77_COMMON_PTR tmp;   char *c, *local_copy_func_stab;
comment|/* If the COMMON block we are trying to add has a blank       name (i.e. "#BLNK_COM") then we set it to __BLANK      because the darn "#" character makes GDB's input       parser have fits. */
end_comment

begin_comment
unit|if (strcmp (name, BLANK_COMMON_NAME_ORIGINAL) == 0       || strcmp (name, BLANK_COMMON_NAME_MF77) == 0)     {        xfree (name);       name = alloca (strlen (BLANK_COMMON_NAME_LOCAL) + 1);       strcpy (name, BLANK_COMMON_NAME_LOCAL);     }    tmp = allocate_saved_f77_common_node ();    local_copy_func_stab = xmalloc (strlen (func_stab) + 1);   strcpy (local_copy_func_stab, func_stab);    tmp->name = xmalloc (strlen (name) + 1);
comment|/* local_copy_func_stab is a stabstring, let us first extract the       function name from the stab by NULLing out the ':' character. */
end_comment

begin_endif
unit|c = NULL;   c = strchr (local_copy_func_stab, ':');    if (c)     *c = '\0';   else     error ("Malformed function STAB found in add_common_block()");     tmp->owning_function = xmalloc (strlen (local_copy_func_stab) + 1);    strcpy (tmp->owning_function, local_copy_func_stab);    strcpy (tmp->name, name);   tmp->offset = offset;   tmp->next = NULL;   tmp->entries = NULL;   tmp->secnum = secnum;    current_common = tmp;    if (head_common_list == NULL)     {       head_common_list = tail_common_list = tmp;     }   else     {       tail_common_list->next = tmp;       tail_common_list = tmp;     } }
endif|#
directive|endif
end_endif

begin_comment
comment|/* The following function simply enters a given common entry onto     the "current_common" block that has been saved away. */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static void add_common_entry (struct symbol *entry_sym_ptr) {   COMMON_ENTRY_PTR tmp;
comment|/* The order of this list is important, since       we expect the entries to appear in decl.      order when we later issue "info common" calls */
end_comment

begin_endif
unit|tmp = allocate_common_entry_node ();    tmp->next = NULL;   tmp->symbol = entry_sym_ptr;    if (current_common == NULL)     error ("Attempt to add COMMON entry with no block open!");   else     {       if (current_common->entries == NULL) 	{ 	  current_common->entries = tmp; 	  current_common->end_of_entries = tmp; 	}       else 	{ 	  current_common->end_of_entries->next = tmp; 	  current_common->end_of_entries = tmp; 	}     } }
endif|#
directive|endif
end_endif

begin_comment
comment|/* This routine finds the first encountred COMMON block named "name" */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static SAVED_F77_COMMON_PTR find_first_common_named (char *name) {    SAVED_F77_COMMON_PTR tmp;    tmp = head_common_list;    while (tmp != NULL)     {       if (strcmp (tmp->name, name) == 0) 	return (tmp);       else 	tmp = tmp->next;     }   return (NULL); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* This routine finds the first encountred COMMON block named "name"     that belongs to function funcname */
end_comment

begin_function
name|SAVED_F77_COMMON_PTR
name|find_common_for_function
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|funcname
parameter_list|)
block|{
name|SAVED_F77_COMMON_PTR
name|tmp
decl_stmt|;
name|tmp
operator|=
name|head_common_list
expr_stmt|;
while|while
condition|(
name|tmp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|DEPRECATED_STREQ
argument_list|(
name|tmp
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|&&
name|DEPRECATED_STREQ
argument_list|(
name|tmp
operator|->
name|owning_function
argument_list|,
name|funcname
argument_list|)
condition|)
return|return
operator|(
name|tmp
operator|)
return|;
else|else
name|tmp
operator|=
name|tmp
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* The following function is called to patch up the offsets     for the statics contained in the COMMON block named    "name."  */
end_comment

begin_comment
unit|static void patch_common_entries (SAVED_F77_COMMON_PTR blk, CORE_ADDR offset, int secnum) {   COMMON_ENTRY_PTR entry;    blk->offset = offset;
comment|/* Keep this around for future use. */
end_comment

begin_comment
unit|entry = blk->entries;    while (entry != NULL)     {       SYMBOL_VALUE (entry->symbol) += offset;       SYMBOL_SECTION (entry->symbol) = secnum;        entry = entry->next;     }   blk->secnum = secnum; }
comment|/* Patch all commons named "name" that need patching.Since COMMON    blocks occur with relative infrequency, we simply do a linear scan on    the name.  Eventually, the best way to do this will be a    hashed-lookup.  Secnum is the section number for the .bss section    (which is where common data lives). */
end_comment

begin_comment
unit|static void patch_all_commons_by_name (char *name, CORE_ADDR offset, int secnum) {    SAVED_F77_COMMON_PTR tmp;
comment|/* For blank common blocks, change the canonical reprsentation       of a blank name */
end_comment

begin_endif
unit|if (strcmp (name, BLANK_COMMON_NAME_ORIGINAL) == 0       || strcmp (name, BLANK_COMMON_NAME_MF77) == 0)     {       xfree (name);       name = alloca (strlen (BLANK_COMMON_NAME_LOCAL) + 1);       strcpy (name, BLANK_COMMON_NAME_LOCAL);     }    tmp = head_common_list;    while (tmp != NULL)     {       if (COMMON_NEEDS_PATCHING (tmp)) 	if (strcmp (tmp->name, name) == 0) 	  patch_common_entries (tmp, offset, secnum);        tmp = tmp->next;     } }
endif|#
directive|endif
end_endif

begin_comment
comment|/* This macro adds the symbol-number for the start of the function     (the symbol number of the .bf) referenced by symnum_fcn to a     list.  This list, in reality should be a FIFO queue but since     #line pragmas sometimes cause line ranges to get messed up     we simply create a linear list.  This list can then be searched     first by a queueing algorithm and upon failure fall back to     a linear scan. */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|ADD_BF_SYMNUM
parameter_list|(
name|bf_sym
parameter_list|,
name|fcn_sym
parameter_list|)
define|\   \
value|if (saved_bf_list == NULL) \ { \     tmp_bf_ptr = allocate_saved_bf_node(); \       \ 	tmp_bf_ptr->symnum_bf = (bf_sym); \ 	  tmp_bf_ptr->symnum_fcn = (fcn_sym);  \ 	    tmp_bf_ptr->next = NULL; \ 	      \ 		current_head_bf_list = saved_bf_list = tmp_bf_ptr; \ 		  saved_bf_list_end = tmp_bf_ptr; \ 		  } \ else \ {  \      tmp_bf_ptr = allocate_saved_bf_node(); \        \          tmp_bf_ptr->symnum_bf = (bf_sym);  \ 	   tmp_bf_ptr->symnum_fcn = (fcn_sym);  \ 	     tmp_bf_ptr->next = NULL;  \ 	       \ 		 saved_bf_list_end->next = tmp_bf_ptr;  \ 		   saved_bf_list_end = tmp_bf_ptr; \ 		   }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This function frees the entire (.bf,function) list */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void clear_bf_list (void) {    SAVED_BF_PTR tmp = saved_bf_list;   SAVED_BF_PTR next = NULL;    while (tmp != NULL)     {       next = tmp->next;       xfree (tmp);       tmp = next;     }   saved_bf_list = NULL; }
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|global_remote_debug
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static long get_bf_for_fcn (long the_function) {   SAVED_BF_PTR tmp;   int nprobes = 0;
comment|/* First use a simple queuing algorithm (i.e. look and see if the       item at the head of the queue is the one you want)  */
end_comment

begin_comment
unit|if (saved_bf_list == NULL)     internal_error (__FILE__, __LINE__, 		    "cannot get .bf node off empty list");    if (current_head_bf_list != NULL)     if (current_head_bf_list->symnum_fcn == the_function)       { 	if (global_remote_debug) 	  fprintf_unfiltered (gdb_stderr, "*");  	tmp = current_head_bf_list; 	current_head_bf_list = current_head_bf_list->next; 	return (tmp->symnum_bf);       }
comment|/* If the above did not work (probably because #line directives were       used in the sourcefile and they messed up our internal tables) we now do      the ugly linear scan */
end_comment

begin_endif
unit|if (global_remote_debug)     fprintf_unfiltered (gdb_stderr, "\ndefaulting to linear scan\n");    nprobes = 0;   tmp = saved_bf_list;   while (tmp != NULL)     {       nprobes++;       if (tmp->symnum_fcn == the_function) 	{ 	  if (global_remote_debug) 	    fprintf_unfiltered (gdb_stderr, "Found in %d probes\n", nprobes); 	  current_head_bf_list = tmp->next; 	  return (tmp->symnum_bf); 	}       tmp = tmp->next;     }    return (-1); }  static SAVED_FUNCTION_PTR saved_function_list = NULL; static SAVED_FUNCTION_PTR saved_function_list_end = NULL;  static void clear_function_list (void) {   SAVED_FUNCTION_PTR tmp = saved_function_list;   SAVED_FUNCTION_PTR next = NULL;    while (tmp != NULL)     {       next = tmp->next;       xfree (tmp);       tmp = next;     }    saved_function_list = NULL; }
endif|#
directive|endif
end_endif

end_unit

