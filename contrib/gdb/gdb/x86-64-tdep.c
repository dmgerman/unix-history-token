begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target-dependent code for the x86-64 for GDB, the GNU debugger.     Copyright 2001, 2002 Free Software Foundation, Inc.     Contributed by Jiri Smid, SuSE Labs.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"arch-utils.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"x86-64-tdep.h"
end_include

begin_include
include|#
directive|include
file|"dwarf2cfi.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_comment
comment|/* Register numbers of various important registers.  */
end_comment

begin_define
define|#
directive|define
name|RAX_REGNUM
value|0
end_define

begin_define
define|#
directive|define
name|RDX_REGNUM
value|3
end_define

begin_define
define|#
directive|define
name|RDI_REGNUM
value|5
end_define

begin_define
define|#
directive|define
name|EFLAGS_REGNUM
value|17
end_define

begin_define
define|#
directive|define
name|XMM1_REGNUM
value|39
end_define

begin_struct
struct|struct
name|register_info
block|{
name|int
name|size
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|type
modifier|*
modifier|*
name|type
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* x86_64_register_raw_size_table[i] is the number of bytes of storage in    GDB's register array occupied by register i.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|register_info
name|x86_64_register_info_table
index|[]
init|=
block|{
block|{
literal|8
block|,
literal|"rax"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|8
block|,
literal|"rbx"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|8
block|,
literal|"rcx"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|8
block|,
literal|"rdx"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|8
block|,
literal|"rsi"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|8
block|,
literal|"rdi"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|8
block|,
literal|"rbp"
block|,
operator|&
name|builtin_type_void_func_ptr
block|}
block|,
block|{
literal|8
block|,
literal|"rsp"
block|,
operator|&
name|builtin_type_void_func_ptr
block|}
block|,
block|{
literal|8
block|,
literal|"r8"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|8
block|,
literal|"r9"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|8
block|,
literal|"r10"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|8
block|,
literal|"r11"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|8
block|,
literal|"r12"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|8
block|,
literal|"r13"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|8
block|,
literal|"r14"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|8
block|,
literal|"r15"
block|,
operator|&
name|builtin_type_int64
block|}
block|,
block|{
literal|8
block|,
literal|"rip"
block|,
operator|&
name|builtin_type_void_func_ptr
block|}
block|,
block|{
literal|4
block|,
literal|"eflags"
block|,
operator|&
name|builtin_type_int32
block|}
block|,
block|{
literal|4
block|,
literal|"ds"
block|,
operator|&
name|builtin_type_int32
block|}
block|,
block|{
literal|4
block|,
literal|"es"
block|,
operator|&
name|builtin_type_int32
block|}
block|,
block|{
literal|4
block|,
literal|"fs"
block|,
operator|&
name|builtin_type_int32
block|}
block|,
block|{
literal|4
block|,
literal|"gs"
block|,
operator|&
name|builtin_type_int32
block|}
block|,
block|{
literal|10
block|,
literal|"st0"
block|,
operator|&
name|builtin_type_i387_ext
block|}
block|,
block|{
literal|10
block|,
literal|"st1"
block|,
operator|&
name|builtin_type_i387_ext
block|}
block|,
block|{
literal|10
block|,
literal|"st2"
block|,
operator|&
name|builtin_type_i387_ext
block|}
block|,
block|{
literal|10
block|,
literal|"st3"
block|,
operator|&
name|builtin_type_i387_ext
block|}
block|,
block|{
literal|10
block|,
literal|"st4"
block|,
operator|&
name|builtin_type_i387_ext
block|}
block|,
block|{
literal|10
block|,
literal|"st5"
block|,
operator|&
name|builtin_type_i387_ext
block|}
block|,
block|{
literal|10
block|,
literal|"st6"
block|,
operator|&
name|builtin_type_i387_ext
block|}
block|,
block|{
literal|10
block|,
literal|"st7"
block|,
operator|&
name|builtin_type_i387_ext
block|}
block|,
block|{
literal|4
block|,
literal|"fctrl"
block|,
operator|&
name|builtin_type_int32
block|}
block|,
block|{
literal|4
block|,
literal|"fstat"
block|,
operator|&
name|builtin_type_int32
block|}
block|,
block|{
literal|4
block|,
literal|"ftag"
block|,
operator|&
name|builtin_type_int32
block|}
block|,
block|{
literal|4
block|,
literal|"fiseg"
block|,
operator|&
name|builtin_type_int32
block|}
block|,
block|{
literal|4
block|,
literal|"fioff"
block|,
operator|&
name|builtin_type_int32
block|}
block|,
block|{
literal|4
block|,
literal|"foseg"
block|,
operator|&
name|builtin_type_int32
block|}
block|,
block|{
literal|4
block|,
literal|"fooff"
block|,
operator|&
name|builtin_type_int32
block|}
block|,
block|{
literal|4
block|,
literal|"fop"
block|,
operator|&
name|builtin_type_int32
block|}
block|,
block|{
literal|16
block|,
literal|"xmm0"
block|,
operator|&
name|builtin_type_v4sf
block|}
block|,
block|{
literal|16
block|,
literal|"xmm1"
block|,
operator|&
name|builtin_type_v4sf
block|}
block|,
block|{
literal|16
block|,
literal|"xmm2"
block|,
operator|&
name|builtin_type_v4sf
block|}
block|,
block|{
literal|16
block|,
literal|"xmm3"
block|,
operator|&
name|builtin_type_v4sf
block|}
block|,
block|{
literal|16
block|,
literal|"xmm4"
block|,
operator|&
name|builtin_type_v4sf
block|}
block|,
block|{
literal|16
block|,
literal|"xmm5"
block|,
operator|&
name|builtin_type_v4sf
block|}
block|,
block|{
literal|16
block|,
literal|"xmm6"
block|,
operator|&
name|builtin_type_v4sf
block|}
block|,
block|{
literal|16
block|,
literal|"xmm7"
block|,
operator|&
name|builtin_type_v4sf
block|}
block|,
block|{
literal|16
block|,
literal|"xmm8"
block|,
operator|&
name|builtin_type_v4sf
block|}
block|,
block|{
literal|16
block|,
literal|"xmm9"
block|,
operator|&
name|builtin_type_v4sf
block|}
block|,
block|{
literal|16
block|,
literal|"xmm10"
block|,
operator|&
name|builtin_type_v4sf
block|}
block|,
block|{
literal|16
block|,
literal|"xmm11"
block|,
operator|&
name|builtin_type_v4sf
block|}
block|,
block|{
literal|16
block|,
literal|"xmm12"
block|,
operator|&
name|builtin_type_v4sf
block|}
block|,
block|{
literal|16
block|,
literal|"xmm13"
block|,
operator|&
name|builtin_type_v4sf
block|}
block|,
block|{
literal|16
block|,
literal|"xmm14"
block|,
operator|&
name|builtin_type_v4sf
block|}
block|,
block|{
literal|16
block|,
literal|"xmm15"
block|,
operator|&
name|builtin_type_v4sf
block|}
block|,
block|{
literal|4
block|,
literal|"mxcsr"
block|,
operator|&
name|builtin_type_int32
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of all registers */
end_comment

begin_define
define|#
directive|define
name|X86_64_NUM_REGS
value|(sizeof (x86_64_register_info_table) / \   sizeof (x86_64_register_info_table[0]))
end_define

begin_comment
comment|/* Number of general registers.  */
end_comment

begin_define
define|#
directive|define
name|X86_64_NUM_GREGS
value|(22)
end_define

begin_decl_stmt
name|int
name|x86_64_num_regs
init|=
name|X86_64_NUM_REGS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|x86_64_num_gregs
init|=
name|X86_64_NUM_GREGS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Did we already print a note about frame pointer?  */
end_comment

begin_decl_stmt
name|int
name|omit_fp_note_printed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of bytes of storage in the actual machine representation for    register REGNO.  */
end_comment

begin_function
name|int
name|x86_64_register_raw_size
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
return|return
name|x86_64_register_info_table
index|[
name|regno
index|]
operator|.
name|size
return|;
block|}
end_function

begin_comment
comment|/* x86_64_register_byte_table[i] is the offset into the register file of the    start of register number i.  We initialize this from    x86_64_register_info_table.  */
end_comment

begin_decl_stmt
name|int
name|x86_64_register_byte_table
index|[
name|X86_64_NUM_REGS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Index within `registers' of the first byte of the space for register REGNO.  */
end_comment

begin_function
name|int
name|x86_64_register_byte
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
return|return
name|x86_64_register_byte_table
index|[
name|regno
index|]
return|;
block|}
end_function

begin_comment
comment|/* Return the GDB type object for the "standard" data type of data in    register N. */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|x86_64_register_virtual_type
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
return|return
operator|*
name|x86_64_register_info_table
index|[
name|regno
index|]
operator|.
name|type
return|;
block|}
end_function

begin_comment
comment|/* x86_64_register_convertible is true if register N's virtual format is    different from its raw format.  Note that this definition assumes    that the host supports IEEE 32-bit floats, since it doesn't say    that SSE registers need conversion.  Even if we can't find a    counterexample, this is still sloppy.  */
end_comment

begin_function
name|int
name|x86_64_register_convertible
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
return|return
name|IS_FP_REGNUM
argument_list|(
name|regno
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Convert data from raw format for register REGNUM in buffer FROM to    virtual format with type TYPE in buffer TO.  In principle both    formats are identical except that the virtual format has two extra    bytes appended that aren't used.  We set these to zero.  */
end_comment

begin_function
name|void
name|x86_64_register_convert_to_virtual
parameter_list|(
name|int
name|regnum
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|from
parameter_list|,
name|char
modifier|*
name|to
parameter_list|)
block|{
name|char
name|buf
index|[
literal|12
index|]
decl_stmt|;
name|DOUBLEST
name|d
decl_stmt|;
comment|/* We only support floating-point values.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_FLT
condition|)
block|{
name|warning
argument_list|(
literal|"Cannot convert floating-point register value "
literal|"to non-floating-point type."
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|to
argument_list|,
literal|0
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* First add the necessary padding.  */
name|memcpy
argument_list|(
name|buf
argument_list|,
name|from
argument_list|,
name|FPU_REG_RAW_SIZE
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|buf
operator|+
name|FPU_REG_RAW_SIZE
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|buf
operator|-
name|FPU_REG_RAW_SIZE
argument_list|)
expr_stmt|;
comment|/* Convert to TYPE.  This should be a no-op, if TYPE is equivalent      to the extended floating-point format used by the FPU.  */
name|convert_typed_floating
argument_list|(
name|to
argument_list|,
name|type
argument_list|,
name|buf
argument_list|,
name|x86_64_register_virtual_type
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert data from virtual format with type TYPE in buffer FROM to    raw format for register REGNUM in buffer TO.  Simply omit the two    unused bytes.  */
end_comment

begin_function
name|void
name|x86_64_register_convert_to_raw
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|regnum
parameter_list|,
name|char
modifier|*
name|from
parameter_list|,
name|char
modifier|*
name|to
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_FLT
operator|&&
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|==
literal|12
argument_list|)
expr_stmt|;
comment|/* Simply omit the two unused bytes.  */
name|memcpy
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|FPU_REG_RAW_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is the variable that is set with "set disassembly-flavour", and    its legitimate values.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|att_flavour
index|[]
init|=
literal|"att"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|intel_flavour
index|[]
init|=
literal|"intel"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|valid_flavours
index|[]
init|=
block|{
name|att_flavour
block|,
name|intel_flavour
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|disassembly_flavour
init|=
name|att_flavour
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|CORE_ADDR
name|x86_64_push_return_address
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|)
block|{
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
literal|8
argument_list|,
name|CALL_DUMMY_ADDRESS
argument_list|()
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|sp
operator|-
literal|8
argument_list|,
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
return|return
name|sp
operator|-
literal|8
return|;
block|}
end_function

begin_function
name|void
name|x86_64_pop_frame
parameter_list|(
name|void
parameter_list|)
block|{
name|generic_pop_current_frame
argument_list|(
name|cfi_pop_frame
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The returning of values is done according to the special algorithm.    Some types are returned in registers an some (big structures) in memory.    See ABI for details.  */
end_comment

begin_define
define|#
directive|define
name|MAX_CLASSES
value|4
end_define

begin_enum
enum|enum
name|x86_64_reg_class
block|{
name|X86_64_NO_CLASS
block|,
name|X86_64_INTEGER_CLASS
block|,
name|X86_64_INTEGERSI_CLASS
block|,
name|X86_64_SSE_CLASS
block|,
name|X86_64_SSESF_CLASS
block|,
name|X86_64_SSEDF_CLASS
block|,
name|X86_64_SSEUP_CLASS
block|,
name|X86_64_X87_CLASS
block|,
name|X86_64_X87UP_CLASS
block|,
name|X86_64_MEMORY_CLASS
block|}
enum|;
end_enum

begin_comment
comment|/* Return the union class of CLASS1 and CLASS2.    See the x86-64 ABI for details.  */
end_comment

begin_function
specifier|static
name|enum
name|x86_64_reg_class
name|merge_classes
parameter_list|(
name|enum
name|x86_64_reg_class
name|class1
parameter_list|,
name|enum
name|x86_64_reg_class
name|class2
parameter_list|)
block|{
comment|/* Rule #1: If both classes are equal, this is the resulting class.  */
if|if
condition|(
name|class1
operator|==
name|class2
condition|)
return|return
name|class1
return|;
comment|/* Rule #2: If one of the classes is NO_CLASS, the resulting class is      the other class.  */
if|if
condition|(
name|class1
operator|==
name|X86_64_NO_CLASS
condition|)
return|return
name|class2
return|;
if|if
condition|(
name|class2
operator|==
name|X86_64_NO_CLASS
condition|)
return|return
name|class1
return|;
comment|/* Rule #3: If one of the classes is MEMORY, the result is MEMORY.  */
if|if
condition|(
name|class1
operator|==
name|X86_64_MEMORY_CLASS
operator|||
name|class2
operator|==
name|X86_64_MEMORY_CLASS
condition|)
return|return
name|X86_64_MEMORY_CLASS
return|;
comment|/* Rule #4: If one of the classes is INTEGER, the result is INTEGER.  */
if|if
condition|(
operator|(
name|class1
operator|==
name|X86_64_INTEGERSI_CLASS
operator|&&
name|class2
operator|==
name|X86_64_SSESF_CLASS
operator|)
operator|||
operator|(
name|class2
operator|==
name|X86_64_INTEGERSI_CLASS
operator|&&
name|class1
operator|==
name|X86_64_SSESF_CLASS
operator|)
condition|)
return|return
name|X86_64_INTEGERSI_CLASS
return|;
if|if
condition|(
name|class1
operator|==
name|X86_64_INTEGER_CLASS
operator|||
name|class1
operator|==
name|X86_64_INTEGERSI_CLASS
operator|||
name|class2
operator|==
name|X86_64_INTEGER_CLASS
operator|||
name|class2
operator|==
name|X86_64_INTEGERSI_CLASS
condition|)
return|return
name|X86_64_INTEGER_CLASS
return|;
comment|/* Rule #5: If one of the classes is X87 or X87UP class, MEMORY is used.  */
if|if
condition|(
name|class1
operator|==
name|X86_64_X87_CLASS
operator|||
name|class1
operator|==
name|X86_64_X87UP_CLASS
operator|||
name|class2
operator|==
name|X86_64_X87_CLASS
operator|||
name|class2
operator|==
name|X86_64_X87UP_CLASS
condition|)
return|return
name|X86_64_MEMORY_CLASS
return|;
comment|/* Rule #6: Otherwise class SSE is used.  */
return|return
name|X86_64_SSE_CLASS
return|;
block|}
end_function

begin_comment
comment|/* Classify the argument type.    CLASSES will be filled by the register class used to pass each word    of the operand.  The number of words is returned.  In case the parameter    should be passed in memory, 0 is returned. As a special case for zero    sized containers, classes[0] will be NO_CLASS and 1 is returned.     See the x86-64 PS ABI for details. */
end_comment

begin_function
specifier|static
name|int
name|classify_argument
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|enum
name|x86_64_reg_class
name|classes
index|[
name|MAX_CLASSES
index|]
parameter_list|,
name|int
name|bit_offset
parameter_list|)
block|{
name|int
name|bytes
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|words
init|=
operator|(
name|bytes
operator|+
literal|8
operator|-
literal|1
operator|)
operator|/
literal|8
decl_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_ARRAY
case|:
case|case
name|TYPE_CODE_STRUCT
case|:
case|case
name|TYPE_CODE_UNION
case|:
block|{
name|int
name|i
decl_stmt|;
name|enum
name|x86_64_reg_class
name|subclasses
index|[
name|MAX_CLASSES
index|]
decl_stmt|;
comment|/* On x86-64 we pass structures larger than 16 bytes on the stack.  */
if|if
condition|(
name|bytes
operator|>
literal|16
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
name|classes
index|[
name|i
index|]
operator|=
name|X86_64_NO_CLASS
expr_stmt|;
comment|/* Zero sized arrays or structures are NO_CLASS.  We return 0 to 	   signalize memory class, so handle it as special case.  */
if|if
condition|(
operator|!
name|words
condition|)
block|{
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_NO_CLASS
expr_stmt|;
return|return
literal|1
return|;
block|}
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_STRUCT
case|:
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|type
operator|->
name|nfields
condition|;
operator|++
name|j
control|)
block|{
name|int
name|num
init|=
name|classify_argument
argument_list|(
name|type
operator|->
name|fields
index|[
name|j
index|]
operator|.
name|type
argument_list|,
name|subclasses
argument_list|,
operator|(
name|type
operator|->
name|fields
index|[
name|j
index|]
operator|.
name|loc
operator|.
name|bitpos
operator|+
name|bit_offset
operator|)
operator|%
literal|256
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|num
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|int
name|pos
init|=
operator|(
name|type
operator|->
name|fields
index|[
name|j
index|]
operator|.
name|loc
operator|.
name|bitpos
operator|+
name|bit_offset
operator|)
operator|/
literal|8
operator|/
literal|8
decl_stmt|;
name|classes
index|[
name|i
operator|+
name|pos
index|]
operator|=
name|merge_classes
argument_list|(
name|subclasses
index|[
name|i
index|]
argument_list|,
name|classes
index|[
name|i
operator|+
name|pos
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|TYPE_CODE_ARRAY
case|:
block|{
name|int
name|num
decl_stmt|;
name|num
operator|=
name|classify_argument
argument_list|(
name|type
operator|->
name|target_type
argument_list|,
name|subclasses
argument_list|,
name|bit_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|num
condition|)
return|return
literal|0
return|;
comment|/* The partial classes are now full classes.  */
if|if
condition|(
name|subclasses
index|[
literal|0
index|]
operator|==
name|X86_64_SSESF_CLASS
operator|&&
name|bytes
operator|!=
literal|4
condition|)
name|subclasses
index|[
literal|0
index|]
operator|=
name|X86_64_SSE_CLASS
expr_stmt|;
if|if
condition|(
name|subclasses
index|[
literal|0
index|]
operator|==
name|X86_64_INTEGERSI_CLASS
operator|&&
name|bytes
operator|!=
literal|4
condition|)
name|subclasses
index|[
literal|0
index|]
operator|=
name|X86_64_INTEGER_CLASS
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
name|classes
index|[
name|i
index|]
operator|=
name|subclasses
index|[
name|i
operator|%
name|num
index|]
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_UNION
case|:
block|{
name|int
name|j
decl_stmt|;
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|type
operator|->
name|nfields
condition|;
operator|++
name|j
control|)
block|{
name|int
name|num
decl_stmt|;
name|num
operator|=
name|classify_argument
argument_list|(
name|type
operator|->
name|fields
index|[
name|j
index|]
operator|.
name|type
argument_list|,
name|subclasses
argument_list|,
name|bit_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|num
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|classes
index|[
name|i
index|]
operator|=
name|merge_classes
argument_list|(
name|subclasses
index|[
name|i
index|]
argument_list|,
name|classes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
comment|/* Final merger cleanup.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|words
condition|;
name|i
operator|++
control|)
block|{
comment|/* If one class is MEMORY, everything should be passed in 	       memory.  */
if|if
condition|(
name|classes
index|[
name|i
index|]
operator|==
name|X86_64_MEMORY_CLASS
condition|)
return|return
literal|0
return|;
comment|/* The X86_64_SSEUP_CLASS should be always preceeded by 	       X86_64_SSE_CLASS.  */
if|if
condition|(
name|classes
index|[
name|i
index|]
operator|==
name|X86_64_SSEUP_CLASS
operator|&&
operator|(
name|i
operator|==
literal|0
operator|||
name|classes
index|[
name|i
operator|-
literal|1
index|]
operator|!=
name|X86_64_SSE_CLASS
operator|)
condition|)
name|classes
index|[
name|i
index|]
operator|=
name|X86_64_SSE_CLASS
expr_stmt|;
comment|/*  X86_64_X87UP_CLASS should be preceeded by X86_64_X87_CLASS.  */
if|if
condition|(
name|classes
index|[
name|i
index|]
operator|==
name|X86_64_X87UP_CLASS
operator|&&
operator|(
name|i
operator|==
literal|0
operator|||
name|classes
index|[
name|i
operator|-
literal|1
index|]
operator|!=
name|X86_64_X87_CLASS
operator|)
condition|)
name|classes
index|[
name|i
index|]
operator|=
name|X86_64_SSE_CLASS
expr_stmt|;
block|}
return|return
name|words
return|;
block|}
break|break;
case|case
name|TYPE_CODE_FLT
case|:
switch|switch
condition|(
name|bytes
condition|)
block|{
case|case
literal|4
case|:
if|if
condition|(
operator|!
operator|(
name|bit_offset
operator|%
literal|64
operator|)
condition|)
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_SSESF_CLASS
expr_stmt|;
else|else
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_SSE_CLASS
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|8
case|:
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_SSEDF_CLASS
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|16
case|:
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_X87_CLASS
expr_stmt|;
name|classes
index|[
literal|1
index|]
operator|=
name|X86_64_X87UP_CLASS
expr_stmt|;
return|return
literal|2
return|;
block|}
break|break;
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_PTR
case|:
switch|switch
condition|(
name|bytes
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|4
case|:
case|case
literal|8
case|:
if|if
condition|(
name|bytes
operator|*
literal|8
operator|+
name|bit_offset
operator|<=
literal|32
condition|)
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_INTEGERSI_CLASS
expr_stmt|;
else|else
name|classes
index|[
literal|0
index|]
operator|=
name|X86_64_INTEGER_CLASS
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|16
case|:
name|classes
index|[
literal|0
index|]
operator|=
name|classes
index|[
literal|1
index|]
operator|=
name|X86_64_INTEGER_CLASS
expr_stmt|;
return|return
literal|2
return|;
default|default:
break|break;
block|}
case|case
name|TYPE_CODE_VOID
case|:
return|return
literal|0
return|;
block|}
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"classify_argument: unknown argument type"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Examine the argument and return set number of register required in each    class.  Return 0 ifif parameter should be passed in memory.  */
end_comment

begin_function
specifier|static
name|int
name|examine_argument
parameter_list|(
name|enum
name|x86_64_reg_class
name|classes
index|[
name|MAX_CLASSES
index|]
parameter_list|,
name|int
name|n
parameter_list|,
name|int
modifier|*
name|int_nregs
parameter_list|,
name|int
modifier|*
name|sse_nregs
parameter_list|)
block|{
operator|*
name|int_nregs
operator|=
literal|0
expr_stmt|;
operator|*
name|sse_nregs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
return|return
literal|0
return|;
for|for
control|(
name|n
operator|--
init|;
name|n
operator|>=
literal|0
condition|;
name|n
operator|--
control|)
switch|switch
condition|(
name|classes
index|[
name|n
index|]
condition|)
block|{
case|case
name|X86_64_INTEGER_CLASS
case|:
case|case
name|X86_64_INTEGERSI_CLASS
case|:
operator|(
operator|*
name|int_nregs
operator|)
operator|++
expr_stmt|;
break|break;
case|case
name|X86_64_SSE_CLASS
case|:
case|case
name|X86_64_SSESF_CLASS
case|:
case|case
name|X86_64_SSEDF_CLASS
case|:
operator|(
operator|*
name|sse_nregs
operator|)
operator|++
expr_stmt|;
break|break;
case|case
name|X86_64_NO_CLASS
case|:
case|case
name|X86_64_SSEUP_CLASS
case|:
case|case
name|X86_64_X87_CLASS
case|:
case|case
name|X86_64_X87UP_CLASS
case|:
break|break;
case|case
name|X86_64_MEMORY_CLASS
case|:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"examine_argument: unexpected memory class"
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_define
define|#
directive|define
name|RET_INT_REGS
value|2
end_define

begin_define
define|#
directive|define
name|RET_SSE_REGS
value|2
end_define

begin_comment
comment|/* Check if the structure in value_type is returned in registers or in    memory. If this function returns 1, gdb will call STORE_STRUCT_RETURN and    EXTRACT_STRUCT_VALUE_ADDRESS else STORE_RETURN_VALUE and EXTRACT_RETURN_VALUE    will be used.  */
end_comment

begin_function
name|int
name|x86_64_use_struct_convention
parameter_list|(
name|int
name|gcc_p
parameter_list|,
name|struct
name|type
modifier|*
name|value_type
parameter_list|)
block|{
name|enum
name|x86_64_reg_class
name|class
index|[
name|MAX_CLASSES
index|]
decl_stmt|;
name|int
name|n
init|=
name|classify_argument
argument_list|(
name|value_type
argument_list|,
name|class
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|needed_intregs
decl_stmt|;
name|int
name|needed_sseregs
decl_stmt|;
return|return
operator|(
operator|!
name|n
operator|||
operator|!
name|examine_argument
argument_list|(
name|class
argument_list|,
name|n
argument_list|,
operator|&
name|needed_intregs
argument_list|,
operator|&
name|needed_sseregs
argument_list|)
operator|||
name|needed_intregs
operator|>
name|RET_INT_REGS
operator|||
name|needed_sseregs
operator|>
name|RET_SSE_REGS
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Extract from an array REGBUF containing the (raw) register state, a    function return value of TYPE, and copy that, in virtual format,    into VALBUF.  */
end_comment

begin_function
name|void
name|x86_64_extract_return_value
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|regbuf
parameter_list|,
name|char
modifier|*
name|valbuf
parameter_list|)
block|{
name|enum
name|x86_64_reg_class
name|class
index|[
name|MAX_CLASSES
index|]
decl_stmt|;
name|int
name|n
init|=
name|classify_argument
argument_list|(
name|type
argument_list|,
name|class
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|needed_intregs
decl_stmt|;
name|int
name|needed_sseregs
decl_stmt|;
name|int
name|intreg
init|=
literal|0
decl_stmt|;
name|int
name|ssereg
init|=
literal|0
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|ret_int_r
index|[
name|RET_INT_REGS
index|]
init|=
block|{
name|RAX_REGNUM
block|,
name|RDX_REGNUM
block|}
decl_stmt|;
name|int
name|ret_sse_r
index|[
name|RET_SSE_REGS
index|]
init|=
block|{
name|XMM0_REGNUM
block|,
name|XMM1_REGNUM
block|}
decl_stmt|;
if|if
condition|(
operator|!
name|n
operator|||
operator|!
name|examine_argument
argument_list|(
name|class
argument_list|,
name|n
argument_list|,
operator|&
name|needed_intregs
argument_list|,
operator|&
name|needed_sseregs
argument_list|)
operator|||
name|needed_intregs
operator|>
name|RET_INT_REGS
operator|||
name|needed_sseregs
operator|>
name|RET_SSE_REGS
condition|)
block|{
comment|/* memory class */
name|CORE_ADDR
name|addr
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|addr
argument_list|,
name|regbuf
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|RAX_REGNUM
argument_list|)
argument_list|)
expr_stmt|;
name|read_memory
argument_list|(
name|addr
argument_list|,
name|valbuf
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|class
index|[
name|i
index|]
condition|)
block|{
case|case
name|X86_64_NO_CLASS
case|:
break|break;
case|case
name|X86_64_INTEGER_CLASS
case|:
name|memcpy
argument_list|(
name|valbuf
operator|+
name|offset
argument_list|,
name|regbuf
operator|+
name|REGISTER_BYTE
argument_list|(
name|ret_int_r
index|[
operator|(
name|intreg
operator|+
literal|1
operator|)
operator|/
literal|2
index|]
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
name|intreg
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|X86_64_INTEGERSI_CLASS
case|:
name|memcpy
argument_list|(
name|valbuf
operator|+
name|offset
argument_list|,
name|regbuf
operator|+
name|REGISTER_BYTE
argument_list|(
name|ret_int_r
index|[
name|intreg
operator|/
literal|2
index|]
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
name|intreg
operator|++
expr_stmt|;
break|break;
case|case
name|X86_64_SSEDF_CLASS
case|:
case|case
name|X86_64_SSESF_CLASS
case|:
case|case
name|X86_64_SSE_CLASS
case|:
name|memcpy
argument_list|(
name|valbuf
operator|+
name|offset
argument_list|,
name|regbuf
operator|+
name|REGISTER_BYTE
argument_list|(
name|ret_sse_r
index|[
operator|(
name|ssereg
operator|+
literal|1
operator|)
operator|/
literal|2
index|]
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
name|ssereg
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|X86_64_SSEUP_CLASS
case|:
name|memcpy
argument_list|(
name|valbuf
operator|+
name|offset
operator|+
literal|8
argument_list|,
name|regbuf
operator|+
name|REGISTER_BYTE
argument_list|(
name|ret_sse_r
index|[
name|ssereg
operator|/
literal|2
index|]
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
name|ssereg
operator|++
expr_stmt|;
break|break;
case|case
name|X86_64_X87_CLASS
case|:
name|memcpy
argument_list|(
name|valbuf
operator|+
name|offset
argument_list|,
name|regbuf
operator|+
name|REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
name|X86_64_X87UP_CLASS
case|:
name|memcpy
argument_list|(
name|valbuf
operator|+
name|offset
argument_list|,
name|regbuf
operator|+
name|REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
argument_list|)
operator|+
literal|8
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
name|X86_64_MEMORY_CLASS
case|:
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Unexpected argument class"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Handled by unwind informations.  */
end_comment

begin_function
specifier|static
name|void
name|x86_64_frame_init_saved_regs
parameter_list|(
name|struct
name|frame_info
modifier|*
name|fi
parameter_list|)
block|{ }
end_function

begin_define
define|#
directive|define
name|INT_REGS
value|6
end_define

begin_define
define|#
directive|define
name|SSE_REGS
value|16
end_define

begin_function
name|CORE_ADDR
name|x86_64_push_arguments
parameter_list|(
name|int
name|nargs
parameter_list|,
name|struct
name|value
modifier|*
modifier|*
name|args
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|,
name|int
name|struct_return
parameter_list|,
name|CORE_ADDR
name|struct_addr
parameter_list|)
block|{
name|int
name|intreg
init|=
literal|0
decl_stmt|;
name|int
name|ssereg
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
name|int
name|int_parameter_registers
index|[
name|INT_REGS
index|]
init|=
block|{
literal|5
comment|/* RDI */
block|,
literal|4
comment|/* RSI */
block|,
literal|3
comment|/* RDX */
block|,
literal|2
comment|/* RCX */
block|,
literal|8
comment|/* R8  */
block|,
literal|9
comment|/* R9  */
block|}
decl_stmt|;
comment|/* XMM0 - XMM15  */
specifier|static
name|int
name|sse_parameter_registers
index|[
name|SSE_REGS
index|]
init|=
block|{
name|XMM1_REGNUM
operator|-
literal|1
block|,
name|XMM1_REGNUM
block|,
name|XMM1_REGNUM
operator|+
literal|1
block|,
name|XMM1_REGNUM
operator|+
literal|2
block|,
name|XMM1_REGNUM
operator|+
literal|3
block|,
name|XMM1_REGNUM
operator|+
literal|4
block|,
name|XMM1_REGNUM
operator|+
literal|5
block|,
name|XMM1_REGNUM
operator|+
literal|6
block|,
name|XMM1_REGNUM
operator|+
literal|7
block|,
name|XMM1_REGNUM
operator|+
literal|8
block|,
name|XMM1_REGNUM
operator|+
literal|9
block|,
name|XMM1_REGNUM
operator|+
literal|10
block|,
name|XMM1_REGNUM
operator|+
literal|11
block|,
name|XMM1_REGNUM
operator|+
literal|12
block|,
name|XMM1_REGNUM
operator|+
literal|13
block|,
name|XMM1_REGNUM
operator|+
literal|14
block|}
decl_stmt|;
name|int
name|stack_values_count
init|=
literal|0
decl_stmt|;
name|int
modifier|*
name|stack_values
decl_stmt|;
name|stack_values
operator|=
name|alloca
argument_list|(
name|nargs
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|enum
name|x86_64_reg_class
name|class
index|[
name|MAX_CLASSES
index|]
decl_stmt|;
name|int
name|n
init|=
name|classify_argument
argument_list|(
name|args
index|[
name|i
index|]
operator|->
name|type
argument_list|,
name|class
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|int
name|needed_intregs
decl_stmt|;
name|int
name|needed_sseregs
decl_stmt|;
if|if
condition|(
operator|!
name|n
operator|||
operator|!
name|examine_argument
argument_list|(
name|class
argument_list|,
name|n
argument_list|,
operator|&
name|needed_intregs
argument_list|,
operator|&
name|needed_sseregs
argument_list|)
operator|||
name|intreg
operator|/
literal|2
operator|+
name|needed_intregs
operator|>
name|INT_REGS
operator|||
name|ssereg
operator|/
literal|2
operator|+
name|needed_sseregs
operator|>
name|SSE_REGS
condition|)
block|{
comment|/* memory class */
name|stack_values
index|[
name|stack_values_count
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|++
control|)
block|{
name|int
name|offset
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|class
index|[
name|j
index|]
condition|)
block|{
case|case
name|X86_64_NO_CLASS
case|:
break|break;
case|case
name|X86_64_INTEGER_CLASS
case|:
name|write_register_gen
argument_list|(
name|int_parameter_registers
index|[
operator|(
name|intreg
operator|+
literal|1
operator|)
operator|/
literal|2
index|]
argument_list|,
name|VALUE_CONTENTS_ALL
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
operator|+
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
name|intreg
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|X86_64_INTEGERSI_CLASS
case|:
name|write_register_gen
argument_list|(
name|int_parameter_registers
index|[
name|intreg
operator|/
literal|2
index|]
argument_list|,
name|VALUE_CONTENTS_ALL
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
operator|+
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
name|intreg
operator|++
expr_stmt|;
break|break;
case|case
name|X86_64_SSEDF_CLASS
case|:
case|case
name|X86_64_SSESF_CLASS
case|:
case|case
name|X86_64_SSE_CLASS
case|:
name|write_register_gen
argument_list|(
name|sse_parameter_registers
index|[
operator|(
name|ssereg
operator|+
literal|1
operator|)
operator|/
literal|2
index|]
argument_list|,
name|VALUE_CONTENTS_ALL
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
operator|+
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
name|ssereg
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|X86_64_SSEUP_CLASS
case|:
name|write_register_gen
argument_list|(
name|sse_parameter_registers
index|[
name|ssereg
operator|/
literal|2
index|]
argument_list|,
name|VALUE_CONTENTS_ALL
argument_list|(
name|args
index|[
name|i
index|]
argument_list|)
operator|+
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
name|ssereg
operator|++
expr_stmt|;
break|break;
case|case
name|X86_64_X87_CLASS
case|:
case|case
name|X86_64_MEMORY_CLASS
case|:
name|stack_values
index|[
name|stack_values_count
operator|++
index|]
operator|=
name|i
expr_stmt|;
break|break;
case|case
name|X86_64_X87UP_CLASS
case|:
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Unexpected argument class"
argument_list|)
expr_stmt|;
block|}
name|intreg
operator|+=
name|intreg
operator|%
literal|2
expr_stmt|;
name|ssereg
operator|+=
name|ssereg
operator|%
literal|2
expr_stmt|;
block|}
block|}
block|}
while|while
condition|(
operator|--
name|stack_values_count
operator|>=
literal|0
condition|)
block|{
name|struct
name|value
modifier|*
name|arg
init|=
name|args
index|[
name|stack_values
index|[
name|stack_values_count
index|]
index|]
decl_stmt|;
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|VALUE_ENCLOSING_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
name|len
operator|+=
literal|7
expr_stmt|;
name|len
operator|-=
name|len
operator|%
literal|8
expr_stmt|;
name|sp
operator|-=
name|len
expr_stmt|;
name|write_memory
argument_list|(
name|sp
argument_list|,
name|VALUE_CONTENTS_ALL
argument_list|(
name|arg
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|sp
return|;
block|}
end_function

begin_comment
comment|/* Write into the appropriate registers a function return value stored    in VALBUF of type TYPE, given in virtual format.  */
end_comment

begin_function
name|void
name|x86_64_store_return_value
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|valbuf
parameter_list|)
block|{
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_CODE_FLT
operator|==
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Floating-point return values can be found in %st(0).  */
if|if
condition|(
name|len
operator|==
name|TARGET_LONG_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
operator|&&
name|TARGET_LONG_DOUBLE_FORMAT
operator|==
operator|&
name|floatformat_i387_ext
condition|)
block|{
comment|/* Copy straight over.  */
name|write_register_bytes
argument_list|(
name|REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
argument_list|)
argument_list|,
name|valbuf
argument_list|,
name|FPU_REG_RAW_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|buf
index|[
name|FPU_REG_RAW_SIZE
index|]
decl_stmt|;
name|DOUBLEST
name|val
decl_stmt|;
comment|/* Convert the value found in VALBUF to the extended 	     floating point format used by the FPU.  This is probably 	     not exactly how it would happen on the target itself, but 	     it is the best we can do.  */
name|val
operator|=
name|extract_floating
argument_list|(
name|valbuf
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|floatformat_from_doublest
argument_list|(
operator|&
name|floatformat_i387_ext
argument_list|,
operator|&
name|val
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|write_register_bytes
argument_list|(
name|REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
argument_list|)
argument_list|,
name|buf
argument_list|,
name|FPU_REG_RAW_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|low_size
init|=
name|REGISTER_RAW_SIZE
argument_list|(
literal|0
argument_list|)
decl_stmt|;
name|int
name|high_size
init|=
name|REGISTER_RAW_SIZE
argument_list|(
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|<=
name|low_size
condition|)
name|write_register_bytes
argument_list|(
name|REGISTER_BYTE
argument_list|(
literal|0
argument_list|)
argument_list|,
name|valbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|<=
operator|(
name|low_size
operator|+
name|high_size
operator|)
condition|)
block|{
name|write_register_bytes
argument_list|(
name|REGISTER_BYTE
argument_list|(
literal|0
argument_list|)
argument_list|,
name|valbuf
argument_list|,
name|low_size
argument_list|)
expr_stmt|;
name|write_register_bytes
argument_list|(
name|REGISTER_BYTE
argument_list|(
literal|1
argument_list|)
argument_list|,
name|valbuf
operator|+
name|low_size
argument_list|,
name|len
operator|-
name|low_size
argument_list|)
expr_stmt|;
block|}
else|else
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Cannot store return value of %d bytes long."
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|char
modifier|*
name|x86_64_register_name
parameter_list|(
name|int
name|reg_nr
parameter_list|)
block|{
if|if
condition|(
name|reg_nr
operator|<
literal|0
operator|||
name|reg_nr
operator|>=
name|X86_64_NUM_REGS
condition|)
return|return
name|NULL
return|;
return|return
name|x86_64_register_info_table
index|[
name|reg_nr
index|]
operator|.
name|name
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* We have two flavours of disassembly.  The machinery on this page    deals with switching between those.  */
end_comment

begin_function
specifier|static
name|int
name|gdb_print_insn_x86_64
parameter_list|(
name|bfd_vma
name|memaddr
parameter_list|,
name|disassemble_info
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
name|disassembly_flavour
operator|==
name|att_flavour
condition|)
return|return
name|print_insn_i386_att
argument_list|(
name|memaddr
argument_list|,
name|info
argument_list|)
return|;
elseif|else
if|if
condition|(
name|disassembly_flavour
operator|==
name|intel_flavour
condition|)
return|return
name|print_insn_i386_intel
argument_list|(
name|memaddr
argument_list|,
name|info
argument_list|)
return|;
comment|/* Never reached -- disassembly_flavour is always either att_flavour      or intel_flavour.  */
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"failed internal consistency check"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Store the address of the place in which to copy the structure the    subroutine will return.  This is called from call_function. */
end_comment

begin_function
name|void
name|x86_64_store_struct_return
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|CORE_ADDR
name|sp
parameter_list|)
block|{
name|write_register
argument_list|(
name|RDI_REGNUM
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|x86_64_frameless_function_invocation
parameter_list|(
name|struct
name|frame_info
modifier|*
name|frame
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If a function with debugging information and known beginning    is detected, we will return pc of the next line in the source     code. With this approach we effectively skip the prolog.  */
end_comment

begin_define
define|#
directive|define
name|PROLOG_BUFSIZE
value|4
end_define

begin_function
name|CORE_ADDR
name|x86_64_skip_prologue
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|firstline
decl_stmt|,
name|currline
decl_stmt|;
name|struct
name|symtab_and_line
name|v_sal
decl_stmt|;
name|struct
name|symbol
modifier|*
name|v_function
decl_stmt|;
name|CORE_ADDR
name|salendaddr
init|=
literal|0
decl_stmt|,
name|endaddr
init|=
literal|0
decl_stmt|;
comment|/* We will handle only functions beginning with:      55          pushq %rbp      48 89 e5    movq %rsp,%rbp     */
name|unsigned
name|char
name|prolog_expect
index|[
name|PROLOG_BUFSIZE
index|]
init|=
block|{
literal|0x55
block|,
literal|0x48
block|,
literal|0x89
block|,
literal|0xe5
block|}
decl_stmt|,
name|prolog_buf
index|[
name|PROLOG_BUFSIZE
index|]
decl_stmt|;
name|read_memory
argument_list|(
name|pc
argument_list|,
operator|(
name|char
operator|*
operator|)
name|prolog_buf
argument_list|,
name|PROLOG_BUFSIZE
argument_list|)
expr_stmt|;
comment|/* First check, whether pc points to pushq %rbp, movq %rsp,%rbp.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PROLOG_BUFSIZE
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|prolog_expect
index|[
name|i
index|]
operator|!=
name|prolog_buf
index|[
name|i
index|]
condition|)
return|return
name|pc
return|;
comment|/* ... no, it doesn't. Nothing to skip.  */
comment|/* OK, we have found the prologue and want PC of the first       non-prologue instruction.  */
name|pc
operator|+=
name|PROLOG_BUFSIZE
expr_stmt|;
name|v_function
operator|=
name|find_pc_function
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|v_sal
operator|=
name|find_pc_line
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If pc doesn't point to a function with debuginfo,       some of the following may be NULL.  */
if|if
condition|(
operator|!
name|v_function
operator|||
operator|!
name|v_function
operator|->
name|ginfo
operator|.
name|value
operator|.
name|block
operator|||
operator|!
name|v_sal
operator|.
name|symtab
condition|)
return|return
name|pc
return|;
name|firstline
operator|=
name|v_sal
operator|.
name|line
expr_stmt|;
name|currline
operator|=
name|firstline
expr_stmt|;
name|salendaddr
operator|=
name|v_sal
operator|.
name|end
expr_stmt|;
name|endaddr
operator|=
name|v_function
operator|->
name|ginfo
operator|.
name|value
operator|.
name|block
operator|->
name|endaddr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|v_sal
operator|.
name|symtab
operator|->
name|linetable
operator|->
name|nitems
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|v_sal
operator|.
name|symtab
operator|->
name|linetable
operator|->
name|item
index|[
name|i
index|]
operator|.
name|line
operator|>
name|firstline
operator|&&
name|v_sal
operator|.
name|symtab
operator|->
name|linetable
operator|->
name|item
index|[
name|i
index|]
operator|.
name|pc
operator|>=
name|salendaddr
operator|&&
name|v_sal
operator|.
name|symtab
operator|->
name|linetable
operator|->
name|item
index|[
name|i
index|]
operator|.
name|pc
operator|<
name|endaddr
condition|)
block|{
name|pc
operator|=
name|v_sal
operator|.
name|symtab
operator|->
name|linetable
operator|->
name|item
index|[
name|i
index|]
operator|.
name|pc
expr_stmt|;
name|currline
operator|=
name|v_sal
operator|.
name|symtab
operator|->
name|linetable
operator|->
name|item
index|[
name|i
index|]
operator|.
name|line
expr_stmt|;
break|break;
block|}
return|return
name|pc
return|;
block|}
end_function

begin_comment
comment|/* Sequence of bytes for breakpoint instruction.  */
end_comment

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|x86_64_breakpoint_from_pc
parameter_list|(
name|CORE_ADDR
modifier|*
name|pc
parameter_list|,
name|int
modifier|*
name|lenptr
parameter_list|)
block|{
specifier|static
name|unsigned
name|char
name|breakpoint
index|[]
init|=
block|{
literal|0xcc
block|}
decl_stmt|;
operator|*
name|lenptr
operator|=
literal|1
expr_stmt|;
return|return
name|breakpoint
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|gdbarch
modifier|*
name|i386_gdbarch_init
parameter_list|(
name|struct
name|gdbarch_info
name|info
parameter_list|,
name|struct
name|gdbarch_list
modifier|*
name|arches
parameter_list|)
block|{
name|struct
name|gdbarch
modifier|*
name|gdbarch
decl_stmt|;
name|struct
name|gdbarch_tdep
modifier|*
name|tdep
decl_stmt|;
name|int
name|i
decl_stmt|,
name|sum
decl_stmt|;
comment|/* Find a candidate among the list of pre-declared architectures. */
for|for
control|(
name|arches
operator|=
name|gdbarch_list_lookup_by_info
argument_list|(
name|arches
argument_list|,
operator|&
name|info
argument_list|)
init|;
name|arches
operator|!=
name|NULL
condition|;
name|arches
operator|=
name|gdbarch_list_lookup_by_info
argument_list|(
name|arches
operator|->
name|next
argument_list|,
operator|&
name|info
argument_list|)
control|)
block|{
switch|switch
condition|(
name|info
operator|.
name|bfd_arch_info
operator|->
name|mach
condition|)
block|{
case|case
name|bfd_mach_x86_64
case|:
case|case
name|bfd_mach_x86_64_intel_syntax
case|:
switch|switch
condition|(
name|gdbarch_bfd_arch_info
argument_list|(
name|arches
operator|->
name|gdbarch
argument_list|)
operator|->
name|mach
condition|)
block|{
case|case
name|bfd_mach_x86_64
case|:
case|case
name|bfd_mach_x86_64_intel_syntax
case|:
return|return
name|arches
operator|->
name|gdbarch
return|;
case|case
name|bfd_mach_i386_i386
case|:
case|case
name|bfd_mach_i386_i8086
case|:
case|case
name|bfd_mach_i386_i386_intel_syntax
case|:
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"i386_gdbarch_init: unknown machine type"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|bfd_mach_i386_i386
case|:
case|case
name|bfd_mach_i386_i8086
case|:
case|case
name|bfd_mach_i386_i386_intel_syntax
case|:
switch|switch
condition|(
name|gdbarch_bfd_arch_info
argument_list|(
name|arches
operator|->
name|gdbarch
argument_list|)
operator|->
name|mach
condition|)
block|{
case|case
name|bfd_mach_x86_64
case|:
case|case
name|bfd_mach_x86_64_intel_syntax
case|:
break|break;
case|case
name|bfd_mach_i386_i386
case|:
case|case
name|bfd_mach_i386_i8086
case|:
case|case
name|bfd_mach_i386_i386_intel_syntax
case|:
return|return
name|arches
operator|->
name|gdbarch
return|;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"i386_gdbarch_init: unknown machine type"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"i386_gdbarch_init: unknown machine type"
argument_list|)
expr_stmt|;
block|}
block|}
name|tdep
operator|=
operator|(
expr|struct
name|gdbarch_tdep
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|gdbarch_tdep
argument_list|)
argument_list|)
expr_stmt|;
name|gdbarch
operator|=
name|gdbarch_alloc
argument_list|(
operator|&
name|info
argument_list|,
name|tdep
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|info
operator|.
name|bfd_arch_info
operator|->
name|mach
condition|)
block|{
case|case
name|bfd_mach_x86_64
case|:
case|case
name|bfd_mach_x86_64_intel_syntax
case|:
name|tdep
operator|->
name|num_xmm_regs
operator|=
literal|16
expr_stmt|;
break|break;
case|case
name|bfd_mach_i386_i386
case|:
case|case
name|bfd_mach_i386_i8086
case|:
case|case
name|bfd_mach_i386_i386_intel_syntax
case|:
comment|/* This is place for definition of i386 target vector.  */
break|break;
default|default:
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"i386_gdbarch_init: unknown machine type"
argument_list|)
expr_stmt|;
block|}
name|set_gdbarch_long_bit
argument_list|(
name|gdbarch
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|set_gdbarch_long_long_bit
argument_list|(
name|gdbarch
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|set_gdbarch_ptr_bit
argument_list|(
name|gdbarch
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|set_gdbarch_long_double_format
argument_list|(
name|gdbarch
argument_list|,
operator|&
name|floatformat_i387_ext
argument_list|)
expr_stmt|;
name|set_gdbarch_num_regs
argument_list|(
name|gdbarch
argument_list|,
name|X86_64_NUM_REGS
argument_list|)
expr_stmt|;
name|set_gdbarch_register_name
argument_list|(
name|gdbarch
argument_list|,
name|x86_64_register_name
argument_list|)
expr_stmt|;
name|set_gdbarch_register_size
argument_list|(
name|gdbarch
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|set_gdbarch_register_raw_size
argument_list|(
name|gdbarch
argument_list|,
name|x86_64_register_raw_size
argument_list|)
expr_stmt|;
name|set_gdbarch_max_register_raw_size
argument_list|(
name|gdbarch
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|set_gdbarch_register_byte
argument_list|(
name|gdbarch
argument_list|,
name|x86_64_register_byte
argument_list|)
expr_stmt|;
comment|/* Total amount of space needed to store our copies of the machine's register      (SIZEOF_GREGS + SIZEOF_FPU_REGS + SIZEOF_FPU_CTRL_REGS + SIZEOF_SSE_REGS) */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|sum
operator|=
literal|0
init|;
name|i
operator|<
name|X86_64_NUM_REGS
condition|;
name|i
operator|++
control|)
name|sum
operator|+=
name|x86_64_register_info_table
index|[
name|i
index|]
operator|.
name|size
expr_stmt|;
name|set_gdbarch_register_bytes
argument_list|(
name|gdbarch
argument_list|,
name|sum
argument_list|)
expr_stmt|;
name|set_gdbarch_register_virtual_size
argument_list|(
name|gdbarch
argument_list|,
name|generic_register_virtual_size
argument_list|)
expr_stmt|;
name|set_gdbarch_max_register_virtual_size
argument_list|(
name|gdbarch
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|set_gdbarch_register_virtual_type
argument_list|(
name|gdbarch
argument_list|,
name|x86_64_register_virtual_type
argument_list|)
expr_stmt|;
name|set_gdbarch_register_convertible
argument_list|(
name|gdbarch
argument_list|,
name|x86_64_register_convertible
argument_list|)
expr_stmt|;
name|set_gdbarch_register_convert_to_virtual
argument_list|(
name|gdbarch
argument_list|,
name|x86_64_register_convert_to_virtual
argument_list|)
expr_stmt|;
name|set_gdbarch_register_convert_to_raw
argument_list|(
name|gdbarch
argument_list|,
name|x86_64_register_convert_to_raw
argument_list|)
expr_stmt|;
comment|/* Register numbers of various important registers.  */
name|set_gdbarch_sp_regnum
argument_list|(
name|gdbarch
argument_list|,
literal|7
argument_list|)
expr_stmt|;
comment|/* (rsp) Contains address of top of stack.  */
name|set_gdbarch_fp_regnum
argument_list|(
name|gdbarch
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* (rbp) */
name|set_gdbarch_pc_regnum
argument_list|(
name|gdbarch
argument_list|,
literal|16
argument_list|)
expr_stmt|;
comment|/* (rip) Contains program counter.  */
name|set_gdbarch_fp0_regnum
argument_list|(
name|gdbarch
argument_list|,
name|X86_64_NUM_GREGS
argument_list|)
expr_stmt|;
comment|/* First FPU floating-point register.  */
name|set_gdbarch_read_fp
argument_list|(
name|gdbarch
argument_list|,
name|cfi_read_fp
argument_list|)
expr_stmt|;
name|set_gdbarch_write_fp
argument_list|(
name|gdbarch
argument_list|,
name|cfi_write_fp
argument_list|)
expr_stmt|;
comment|/* Discard from the stack the innermost frame, restoring all registers.  */
name|set_gdbarch_pop_frame
argument_list|(
name|gdbarch
argument_list|,
name|x86_64_pop_frame
argument_list|)
expr_stmt|;
comment|/* FRAME_CHAIN takes a frame's nominal address and produces the frame's      chain-pointer.  */
name|set_gdbarch_frame_chain
argument_list|(
name|gdbarch
argument_list|,
name|cfi_frame_chain
argument_list|)
expr_stmt|;
name|set_gdbarch_frameless_function_invocation
argument_list|(
name|gdbarch
argument_list|,
name|x86_64_frameless_function_invocation
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_saved_pc
argument_list|(
name|gdbarch
argument_list|,
name|x86_64_linux_frame_saved_pc
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_args_address
argument_list|(
name|gdbarch
argument_list|,
name|default_frame_address
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_locals_address
argument_list|(
name|gdbarch
argument_list|,
name|default_frame_address
argument_list|)
expr_stmt|;
comment|/* Return number of bytes at start of arglist that are not really args.  */
name|set_gdbarch_frame_args_skip
argument_list|(
name|gdbarch
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_init_saved_regs
argument_list|(
name|gdbarch
argument_list|,
name|x86_64_frame_init_saved_regs
argument_list|)
expr_stmt|;
comment|/* Frame pc initialization is handled by unwind informations.  */
name|set_gdbarch_init_frame_pc
argument_list|(
name|gdbarch
argument_list|,
name|cfi_init_frame_pc
argument_list|)
expr_stmt|;
comment|/* Initialization of unwind informations.  */
name|set_gdbarch_init_extra_frame_info
argument_list|(
name|gdbarch
argument_list|,
name|cfi_init_extra_frame_info
argument_list|)
expr_stmt|;
comment|/* Getting saved registers is handled by unwind informations.  */
name|set_gdbarch_get_saved_register
argument_list|(
name|gdbarch
argument_list|,
name|cfi_get_saved_register
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_init_saved_regs
argument_list|(
name|gdbarch
argument_list|,
name|x86_64_frame_init_saved_regs
argument_list|)
expr_stmt|;
comment|/* Cons up virtual frame pointer for trace */
name|set_gdbarch_virtual_frame_pointer
argument_list|(
name|gdbarch
argument_list|,
name|cfi_virtual_frame_pointer
argument_list|)
expr_stmt|;
name|set_gdbarch_frame_chain_valid
argument_list|(
name|gdbarch
argument_list|,
name|generic_file_frame_chain_valid
argument_list|)
expr_stmt|;
name|set_gdbarch_use_generic_dummy_frames
argument_list|(
name|gdbarch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_location
argument_list|(
name|gdbarch
argument_list|,
name|AT_ENTRY_POINT
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_address
argument_list|(
name|gdbarch
argument_list|,
name|entry_point_address
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_length
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_breakpoint_offset
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_breakpoint_offset_p
argument_list|(
name|gdbarch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_gdbarch_pc_in_call_dummy
argument_list|(
name|gdbarch
argument_list|,
name|pc_in_call_dummy_at_entry_point
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_words
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_gdbarch_sizeof_call_dummy_words
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_stack_adjust_p
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_p
argument_list|(
name|gdbarch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|set_gdbarch_call_dummy_start_offset
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_gdbarch_push_dummy_frame
argument_list|(
name|gdbarch
argument_list|,
name|generic_push_dummy_frame
argument_list|)
expr_stmt|;
name|set_gdbarch_fix_call_dummy
argument_list|(
name|gdbarch
argument_list|,
name|generic_fix_call_dummy
argument_list|)
expr_stmt|;
name|set_gdbarch_push_return_address
argument_list|(
name|gdbarch
argument_list|,
name|x86_64_push_return_address
argument_list|)
expr_stmt|;
name|set_gdbarch_push_arguments
argument_list|(
name|gdbarch
argument_list|,
name|x86_64_push_arguments
argument_list|)
expr_stmt|;
comment|/* Return number of args passed to a frame, no way to tell.  */
name|set_gdbarch_frame_num_args
argument_list|(
name|gdbarch
argument_list|,
name|frame_num_args_unknown
argument_list|)
expr_stmt|;
comment|/* Don't use default structure extract routine */
name|set_gdbarch_extract_struct_value_address
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If USE_STRUCT_CONVENTION retruns 0, then gdb uses STORE_RETURN_VALUE    and EXTRACT_RETURN_VALUE to store/fetch the functions return value.  It is    the case when structure is returned in registers.  */
name|set_gdbarch_use_struct_convention
argument_list|(
name|gdbarch
argument_list|,
name|x86_64_use_struct_convention
argument_list|)
expr_stmt|;
comment|/* Store the address of the place in which to copy the structure the    subroutine will return.  This is called from call_function. */
name|set_gdbarch_store_struct_return
argument_list|(
name|gdbarch
argument_list|,
name|x86_64_store_struct_return
argument_list|)
expr_stmt|;
comment|/* Extract from an array REGBUF containing the (raw) register state    a function return value of type TYPE, and copy that, in virtual format,    into VALBUF.  */
name|set_gdbarch_extract_return_value
argument_list|(
name|gdbarch
argument_list|,
name|x86_64_extract_return_value
argument_list|)
expr_stmt|;
comment|/* Write into the appropriate registers a function return value stored    in VALBUF of type TYPE, given in virtual format.  */
name|set_gdbarch_store_return_value
argument_list|(
name|gdbarch
argument_list|,
name|x86_64_store_return_value
argument_list|)
expr_stmt|;
comment|/* Offset from address of function to start of its code.  */
name|set_gdbarch_function_start_offset
argument_list|(
name|gdbarch
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_gdbarch_skip_prologue
argument_list|(
name|gdbarch
argument_list|,
name|x86_64_skip_prologue
argument_list|)
expr_stmt|;
name|set_gdbarch_saved_pc_after_call
argument_list|(
name|gdbarch
argument_list|,
name|x86_64_linux_saved_pc_after_call
argument_list|)
expr_stmt|;
name|set_gdbarch_inner_than
argument_list|(
name|gdbarch
argument_list|,
name|core_addr_lessthan
argument_list|)
expr_stmt|;
name|set_gdbarch_breakpoint_from_pc
argument_list|(
name|gdbarch
argument_list|,
name|x86_64_breakpoint_from_pc
argument_list|)
expr_stmt|;
comment|/* Amount PC must be decremented by after a breakpoint.  This is often the    number of bytes in BREAKPOINT but not always.  */
name|set_gdbarch_decr_pc_after_break
argument_list|(
name|gdbarch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Use dwarf2 debug frame informations.  */
name|set_gdbarch_dwarf2_build_frame_info
argument_list|(
name|gdbarch
argument_list|,
name|dwarf2_build_frame_info
argument_list|)
expr_stmt|;
return|return
name|gdbarch
return|;
block|}
end_function

begin_function
name|void
name|_initialize_x86_64_tdep
parameter_list|(
name|void
parameter_list|)
block|{
name|register_gdbarch_init
argument_list|(
name|bfd_arch_i386
argument_list|,
name|i386_gdbarch_init
argument_list|)
expr_stmt|;
comment|/* Initialize the table saying where each register starts in the      register file.  */
block|{
name|int
name|i
decl_stmt|,
name|offset
decl_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|X86_64_NUM_REGS
condition|;
name|i
operator|++
control|)
block|{
name|x86_64_register_byte_table
index|[
name|i
index|]
operator|=
name|offset
expr_stmt|;
name|offset
operator|+=
name|x86_64_register_info_table
index|[
name|i
index|]
operator|.
name|size
expr_stmt|;
block|}
block|}
name|tm_print_insn
operator|=
name|gdb_print_insn_x86_64
expr_stmt|;
name|tm_print_insn_info
operator|.
name|mach
operator|=
name|bfd_lookup_arch
argument_list|(
name|bfd_arch_i386
argument_list|,
literal|3
argument_list|)
operator|->
name|mach
expr_stmt|;
comment|/* Add the variable that controls the disassembly flavour.  */
block|{
name|struct
name|cmd_list_element
modifier|*
name|new_cmd
decl_stmt|;
name|new_cmd
operator|=
name|add_set_enum_cmd
argument_list|(
literal|"disassembly-flavour"
argument_list|,
name|no_class
argument_list|,
name|valid_flavours
argument_list|,
operator|&
name|disassembly_flavour
argument_list|,
literal|"\ Set the disassembly flavour, the valid values are \"att\" and \"intel\", \ and the default value is \"att\"."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|new_cmd
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

