begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle SunOS shared libraries for GDB, the GNU Debugger.    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000,    2001    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_comment
comment|/* SunOS shared libs need the nlist structure.  */
end_comment

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_include
include|#
directive|include
file|<link.h>
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"solist.h"
end_include

begin_comment
comment|/* Link map info to include in an allocated so_list entry */
end_comment

begin_struct
struct|struct
name|lm_info
block|{
comment|/* Pointer to copy of link map from inferior.  The type is char *        rather than void *, so that we may use byte offsets to find the        various fields without the need for a cast.  */
name|char
modifier|*
name|lm
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Symbols which are used to locate the base of the link map structures. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|debug_base_symbols
index|[]
init|=
block|{
literal|"_DYNAMIC"
block|,
literal|"_DYNAMIC__MGC"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|main_name_list
index|[]
init|=
block|{
literal|"main_$main"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Macro to extract an address from a solib structure.    When GDB is configured for some 32-bit targets (e.g. Solaris 2.7    sparc), BFD is configured to handle 64-bit targets, so CORE_ADDR is    64 bits.  We have to extract only the significant bits of addresses    to get the right address when accessing the core file BFD.  */
end_comment

begin_define
define|#
directive|define
name|SOLIB_EXTRACT_ADDRESS
parameter_list|(
name|MEMBER
parameter_list|)
define|\
value|extract_address (&(MEMBER), sizeof (MEMBER))
end_define

begin_comment
comment|/* local data declarations */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|link_dynamic
name|dynamic_copy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|link_dynamic_2
name|ld_2_copy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ld_debug
name|debug_copy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|debug_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|flag_addr
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|offsetof
end_ifndef

begin_define
define|#
directive|define
name|offsetof
parameter_list|(
name|TYPE
parameter_list|,
name|MEMBER
parameter_list|)
value|((unsigned long)&((TYPE *)0)->MEMBER)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|fieldsize
parameter_list|(
name|TYPE
parameter_list|,
name|MEMBER
parameter_list|)
value|(sizeof (((TYPE *)0)->MEMBER))
end_define

begin_comment
comment|/* link map access functions */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|LM_ADDR
parameter_list|(
name|struct
name|so_list
modifier|*
name|so
parameter_list|)
block|{
name|int
name|lm_addr_offset
init|=
name|offsetof
argument_list|(
expr|struct
name|link_map
argument_list|,
name|lm_addr
argument_list|)
decl_stmt|;
name|int
name|lm_addr_size
init|=
name|fieldsize
argument_list|(
expr|struct
name|link_map
argument_list|,
name|lm_addr
argument_list|)
decl_stmt|;
return|return
operator|(
name|CORE_ADDR
operator|)
name|extract_signed_integer
argument_list|(
name|so
operator|->
name|lm_info
operator|->
name|lm
operator|+
name|lm_addr_offset
argument_list|,
name|lm_addr_size
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|LM_NEXT
parameter_list|(
name|struct
name|so_list
modifier|*
name|so
parameter_list|)
block|{
name|int
name|lm_next_offset
init|=
name|offsetof
argument_list|(
expr|struct
name|link_map
argument_list|,
name|lm_next
argument_list|)
decl_stmt|;
name|int
name|lm_next_size
init|=
name|fieldsize
argument_list|(
expr|struct
name|link_map
argument_list|,
name|lm_next
argument_list|)
decl_stmt|;
return|return
name|extract_address
argument_list|(
name|so
operator|->
name|lm_info
operator|->
name|lm
operator|+
name|lm_next_offset
argument_list|,
name|lm_next_size
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|CORE_ADDR
name|LM_NAME
parameter_list|(
name|struct
name|so_list
modifier|*
name|so
parameter_list|)
block|{
name|int
name|lm_name_offset
init|=
name|offsetof
argument_list|(
expr|struct
name|link_map
argument_list|,
name|lm_name
argument_list|)
decl_stmt|;
name|int
name|lm_name_size
init|=
name|fieldsize
argument_list|(
expr|struct
name|link_map
argument_list|,
name|lm_name
argument_list|)
decl_stmt|;
return|return
name|extract_address
argument_list|(
name|so
operator|->
name|lm_info
operator|->
name|lm
operator|+
name|lm_name_offset
argument_list|,
name|lm_name_size
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|debug_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Base of dynamic linker structures */
end_comment

begin_comment
comment|/* Local function prototypes */
end_comment

begin_function_decl
specifier|static
name|int
name|match_main
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Allocate the runtime common object file.  */
end_comment

begin_function
specifier|static
name|void
name|allocate_rt_common_objfile
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|objfile
modifier|*
name|last_one
decl_stmt|;
name|objfile
operator|=
operator|(
expr|struct
name|objfile
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|objfile
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|md
operator|=
name|NULL
expr_stmt|;
name|obstack_specify_allocation
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_cache
operator|.
name|cache
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|xmalloc
argument_list|,
name|xfree
argument_list|)
expr_stmt|;
name|obstack_specify_allocation
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|xmalloc
argument_list|,
name|xfree
argument_list|)
expr_stmt|;
name|obstack_specify_allocation
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|xmalloc
argument_list|,
name|xfree
argument_list|)
expr_stmt|;
name|obstack_specify_allocation
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|xmalloc
argument_list|,
name|xfree
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|name
operator|=
name|mstrsave
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
literal|"rt_common"
argument_list|)
expr_stmt|;
comment|/* Add this file onto the tail of the linked list of other such files. */
name|objfile
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|object_files
operator|==
name|NULL
condition|)
name|object_files
operator|=
name|objfile
expr_stmt|;
else|else
block|{
for|for
control|(
name|last_one
operator|=
name|object_files
init|;
name|last_one
operator|->
name|next
condition|;
name|last_one
operator|=
name|last_one
operator|->
name|next
control|)
empty_stmt|;
name|last_one
operator|->
name|next
operator|=
name|objfile
expr_stmt|;
block|}
name|rt_common_objfile
operator|=
name|objfile
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read all dynamically loaded common symbol definitions from the inferior    and put them into the minimal symbol table for the runtime common    objfile.  */
end_comment

begin_function
specifier|static
name|void
name|solib_add_common_symbols
parameter_list|(
name|CORE_ADDR
name|rtc_symp
parameter_list|)
block|{
name|struct
name|rtc_symb
name|inferior_rtc_symb
decl_stmt|;
name|struct
name|nlist
name|inferior_rtc_nlist
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Remove any runtime common symbols from previous runs.  */
if|if
condition|(
name|rt_common_objfile
operator|!=
name|NULL
operator|&&
name|rt_common_objfile
operator|->
name|minimal_symbol_count
condition|)
block|{
name|obstack_free
argument_list|(
operator|&
name|rt_common_objfile
operator|->
name|symbol_obstack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|obstack_specify_allocation
argument_list|(
operator|&
name|rt_common_objfile
operator|->
name|symbol_obstack
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|xmalloc
argument_list|,
name|xfree
argument_list|)
expr_stmt|;
name|rt_common_objfile
operator|->
name|minimal_symbol_count
operator|=
literal|0
expr_stmt|;
name|rt_common_objfile
operator|->
name|msymbols
operator|=
name|NULL
expr_stmt|;
block|}
name|init_minimal_symbol_collection
argument_list|()
expr_stmt|;
name|make_cleanup_discard_minimal_symbols
argument_list|()
expr_stmt|;
while|while
condition|(
name|rtc_symp
condition|)
block|{
name|read_memory
argument_list|(
name|rtc_symp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|inferior_rtc_symb
argument_list|,
sizeof|sizeof
argument_list|(
name|inferior_rtc_symb
argument_list|)
argument_list|)
expr_stmt|;
name|read_memory
argument_list|(
name|SOLIB_EXTRACT_ADDRESS
argument_list|(
name|inferior_rtc_symb
operator|.
name|rtc_sp
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|inferior_rtc_nlist
argument_list|,
sizeof|sizeof
argument_list|(
name|inferior_rtc_nlist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inferior_rtc_nlist
operator|.
name|n_type
operator|==
name|N_COMM
condition|)
block|{
comment|/* FIXME: The length of the symbol name is not available, but in the 	     current implementation the common symbol is allocated immediately 	     behind the name of the symbol. */
name|len
operator|=
name|inferior_rtc_nlist
operator|.
name|n_value
operator|-
name|inferior_rtc_nlist
operator|.
name|n_un
operator|.
name|n_strx
expr_stmt|;
name|name
operator|=
name|xmalloc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|read_memory
argument_list|(
name|SOLIB_EXTRACT_ADDRESS
argument_list|(
name|inferior_rtc_nlist
operator|.
name|n_un
operator|.
name|n_name
argument_list|)
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Allocate the runtime common objfile if necessary. */
if|if
condition|(
name|rt_common_objfile
operator|==
name|NULL
condition|)
name|allocate_rt_common_objfile
argument_list|()
expr_stmt|;
name|prim_record_minimal_symbol
argument_list|(
name|name
argument_list|,
name|inferior_rtc_nlist
operator|.
name|n_value
argument_list|,
name|mst_bss
argument_list|,
name|rt_common_objfile
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|rtc_symp
operator|=
name|SOLIB_EXTRACT_ADDRESS
argument_list|(
name|inferior_rtc_symb
operator|.
name|rtc_next
argument_list|)
expr_stmt|;
block|}
comment|/* Install any minimal symbols that have been collected as the current      minimal symbols for the runtime common objfile.  */
name|install_minimal_symbols
argument_list|(
name|rt_common_objfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*     LOCAL FUNCTION     locate_base -- locate the base address of dynamic linker structs     SYNOPSIS     CORE_ADDR locate_base (void)     DESCRIPTION     For both the SunOS and SVR4 shared library implementations, if the    inferior executable has been linked dynamically, there is a single    address somewhere in the inferior's data space which is the key to    locating all of the dynamic linker's runtime structures.  This    address is the value of the debug base symbol.  The job of this    function is to find and return that address, or to return 0 if there    is no such address (the executable is statically linked for example).     For SunOS, the job is almost trivial, since the dynamic linker and    all of it's structures are statically linked to the executable at    link time.  Thus the symbol for the address we are looking for has    already been added to the minimal symbol table for the executable's    objfile at the time the symbol file's symbols were read, and all we    have to do is look it up there.  Note that we explicitly do NOT want    to find the copies in the shared library.     The SVR4 version is a bit more complicated because the address    is contained somewhere in the dynamic info section.  We have to go    to a lot more work to discover the address of the debug base symbol.    Because of this complexity, we cache the value we find and return that    value on subsequent invocations.  Note there is no copy in the    executable symbol tables.   */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|locate_base
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
name|CORE_ADDR
name|address
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|symbolp
decl_stmt|;
comment|/* For SunOS, we want to limit the search for the debug base symbol to the      executable being debugged, since there is a duplicate named symbol in the      shared library.  We don't want the shared library versions. */
for|for
control|(
name|symbolp
operator|=
name|debug_base_symbols
init|;
operator|*
name|symbolp
operator|!=
name|NULL
condition|;
name|symbolp
operator|++
control|)
block|{
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
operator|*
name|symbolp
argument_list|,
name|NULL
argument_list|,
name|symfile_objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|msymbol
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|address
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
expr_stmt|;
return|return
operator|(
name|address
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*     LOCAL FUNCTION     first_link_map_member -- locate first member in dynamic linker's map     SYNOPSIS     static CORE_ADDR first_link_map_member (void)     DESCRIPTION     Find the first element in the inferior's dynamic link map, and    return its address in the inferior.  This function doesn't copy the    link map entry itself into our address space; current_sos actually    does the reading.  */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|first_link_map_member
parameter_list|(
name|void
parameter_list|)
block|{
name|CORE_ADDR
name|lm
init|=
literal|0
decl_stmt|;
name|read_memory
argument_list|(
name|debug_base
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dynamic_copy
argument_list|,
sizeof|sizeof
argument_list|(
name|dynamic_copy
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dynamic_copy
operator|.
name|ld_version
operator|>=
literal|2
condition|)
block|{
comment|/* It is a version that we can deal with, so read in the secondary          structure and find the address of the link map list from it. */
name|read_memory
argument_list|(
name|SOLIB_EXTRACT_ADDRESS
argument_list|(
name|dynamic_copy
operator|.
name|ld_un
operator|.
name|ld_2
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ld_2_copy
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|link_dynamic_2
argument_list|)
argument_list|)
expr_stmt|;
name|lm
operator|=
name|SOLIB_EXTRACT_ADDRESS
argument_list|(
name|ld_2_copy
operator|.
name|ld_loaded
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|lm
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|open_symbol_file_object
parameter_list|(
name|void
modifier|*
name|from_ttyp
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* LOCAL FUNCTION     current_sos -- build a list of currently loaded shared objects     SYNOPSIS     struct so_list *current_sos ()     DESCRIPTION     Build a list of `struct so_list' objects describing the shared    objects currently loaded in the inferior.  This list does not    include an entry for the main executable file.     Note that we only gather information directly available from the    inferior --- we don't examine any of the shared library files    themselves.  The declaration of `struct so_list' says which fields    we provide values for.  */
end_comment

begin_function
specifier|static
name|struct
name|so_list
modifier|*
name|sunos_current_sos
parameter_list|(
name|void
parameter_list|)
block|{
name|CORE_ADDR
name|lm
decl_stmt|;
name|struct
name|so_list
modifier|*
name|head
init|=
literal|0
decl_stmt|;
name|struct
name|so_list
modifier|*
modifier|*
name|link_ptr
init|=
operator|&
name|head
decl_stmt|;
name|int
name|errcode
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
comment|/* Make sure we've looked up the inferior's dynamic linker's base      structure.  */
if|if
condition|(
operator|!
name|debug_base
condition|)
block|{
name|debug_base
operator|=
name|locate_base
argument_list|()
expr_stmt|;
comment|/* If we can't find the dynamic linker's base structure, this 	 must not be a dynamically linked executable.  Hmm.  */
if|if
condition|(
operator|!
name|debug_base
condition|)
return|return
literal|0
return|;
block|}
comment|/* Walk the inferior's link map list, and build our list of      `struct so_list' nodes.  */
name|lm
operator|=
name|first_link_map_member
argument_list|()
expr_stmt|;
while|while
condition|(
name|lm
condition|)
block|{
name|struct
name|so_list
modifier|*
name|new
init|=
operator|(
expr|struct
name|so_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|so_list
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|new
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|lm_info
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lm_info
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|new
operator|->
name|lm_info
argument_list|)
expr_stmt|;
name|new
operator|->
name|lm_info
operator|->
name|lm
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|link_map
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|new
operator|->
name|lm_info
operator|->
name|lm
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new
operator|->
name|lm_info
operator|->
name|lm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|link_map
argument_list|)
argument_list|)
expr_stmt|;
name|read_memory
argument_list|(
name|lm
argument_list|,
name|new
operator|->
name|lm_info
operator|->
name|lm
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|link_map
argument_list|)
argument_list|)
expr_stmt|;
name|lm
operator|=
name|LM_NEXT
argument_list|(
name|new
argument_list|)
expr_stmt|;
comment|/* Extract this shared object's name.  */
name|target_read_string
argument_list|(
name|LM_NAME
argument_list|(
name|new
argument_list|)
argument_list|,
operator|&
name|buffer
argument_list|,
name|SO_NAME_MAX_PATH_SIZE
operator|-
literal|1
argument_list|,
operator|&
name|errcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
operator|!=
literal|0
condition|)
block|{
name|warning
argument_list|(
literal|"current_sos: Can't read pathname for load map: %s\n"
argument_list|,
name|safe_strerror
argument_list|(
name|errcode
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strncpy
argument_list|(
name|new
operator|->
name|so_name
argument_list|,
name|buffer
argument_list|,
name|SO_NAME_MAX_PATH_SIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
name|new
operator|->
name|so_name
index|[
name|SO_NAME_MAX_PATH_SIZE
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|xfree
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|new
operator|->
name|so_original_name
argument_list|,
name|new
operator|->
name|so_name
argument_list|)
expr_stmt|;
block|}
comment|/* If this entry has no name, or its name matches the name 	 for the main executable, don't include it in the list.  */
if|if
condition|(
operator|!
name|new
operator|->
name|so_name
index|[
literal|0
index|]
operator|||
name|match_main
argument_list|(
name|new
operator|->
name|so_name
argument_list|)
condition|)
name|free_so
argument_list|(
name|new
argument_list|)
expr_stmt|;
else|else
block|{
name|new
operator|->
name|next
operator|=
literal|0
expr_stmt|;
operator|*
name|link_ptr
operator|=
name|new
expr_stmt|;
name|link_ptr
operator|=
operator|&
name|new
operator|->
name|next
expr_stmt|;
block|}
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
return|return
name|head
return|;
block|}
end_function

begin_comment
comment|/* On some systems, the only way to recognize the link map entry for    the main executable file is by looking at its name.  Return    non-zero iff SONAME matches one of the known main executable names.  */
end_comment

begin_function
specifier|static
name|int
name|match_main
parameter_list|(
name|char
modifier|*
name|soname
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|mainp
decl_stmt|;
for|for
control|(
name|mainp
operator|=
name|main_name_list
init|;
operator|*
name|mainp
operator|!=
name|NULL
condition|;
name|mainp
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|soname
argument_list|,
operator|*
name|mainp
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sunos_in_dynsym_resolve_code
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*     LOCAL FUNCTION     disable_break -- remove the "mapping changed" breakpoint     SYNOPSIS     static int disable_break ()     DESCRIPTION     Removes the breakpoint that gets hit when the dynamic linker    completes a mapping change.   */
end_comment

begin_function
specifier|static
name|int
name|disable_break
parameter_list|(
name|void
parameter_list|)
block|{
name|CORE_ADDR
name|breakpoint_addr
decl_stmt|;
comment|/* Address where end bkpt is set */
name|int
name|in_debugger
init|=
literal|0
decl_stmt|;
comment|/* Read the debugger structure from the inferior to retrieve the      address of the breakpoint and the original contents of the      breakpoint address.  Remove the breakpoint by writing the original      contents back. */
name|read_memory
argument_list|(
name|debug_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|debug_copy
argument_list|,
sizeof|sizeof
argument_list|(
name|debug_copy
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set `in_debugger' to zero now. */
name|write_memory
argument_list|(
name|flag_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|in_debugger
argument_list|,
sizeof|sizeof
argument_list|(
name|in_debugger
argument_list|)
argument_list|)
expr_stmt|;
name|breakpoint_addr
operator|=
name|SOLIB_EXTRACT_ADDRESS
argument_list|(
name|debug_copy
operator|.
name|ldd_bp_addr
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|breakpoint_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|debug_copy
operator|.
name|ldd_bp_inst
argument_list|,
sizeof|sizeof
argument_list|(
name|debug_copy
operator|.
name|ldd_bp_inst
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For the SVR4 version, we always know the breakpoint address.  For the      SunOS version we don't know it until the above code is executed.      Grumble if we are stopped anywhere besides the breakpoint address. */
if|if
condition|(
name|stop_pc
operator|!=
name|breakpoint_addr
condition|)
block|{
name|warning
argument_list|(
literal|"stopped at unknown breakpoint while handling shared libraries"
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*     LOCAL FUNCTION     enable_break -- arrange for dynamic linker to hit breakpoint     SYNOPSIS     int enable_break (void)     DESCRIPTION     Both the SunOS and the SVR4 dynamic linkers have, as part of their    debugger interface, support for arranging for the inferior to hit    a breakpoint after mapping in the shared libraries.  This function    enables that breakpoint.     For SunOS, there is a special flag location (in_debugger) which we    set to 1.  When the dynamic linker sees this flag set, it will set    a breakpoint at a location known only to itself, after saving the    original contents of that place and the breakpoint address itself,    in it's own internal structures.  When we resume the inferior, it    will eventually take a SIGTRAP when it runs into the breakpoint.    We handle this (in a different place) by restoring the contents of    the breakpointed location (which is only known after it stops),    chasing around to locate the shared libraries that have been    loaded, then resuming.     For SVR4, the debugger interface structure contains a member (r_brk)    which is statically initialized at the time the shared library is    built, to the offset of a function (_r_debug_state) which is guaran-    teed to be called once before mapping in a library, and again when    the mapping is complete.  At the time we are examining this member,    it contains only the unrelocated offset of the function, so we have    to do our own relocation.  Later, when the dynamic linker actually    runs, it relocates r_brk to be the actual address of _r_debug_state().     The debugger interface structure also contains an enumeration which    is set to either RT_ADD or RT_DELETE prior to changing the mapping,    depending upon whether or not the library is being mapped or unmapped,    and then set to RT_CONSISTENT after the library is mapped/unmapped.  */
end_comment

begin_function
specifier|static
name|int
name|enable_break
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|success
init|=
literal|0
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|in_debugger
decl_stmt|;
comment|/* Get link_dynamic structure */
name|j
operator|=
name|target_read_memory
argument_list|(
name|debug_base
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dynamic_copy
argument_list|,
sizeof|sizeof
argument_list|(
name|dynamic_copy
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
condition|)
block|{
comment|/* unreadable */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Calc address of debugger interface structure */
name|debug_addr
operator|=
name|SOLIB_EXTRACT_ADDRESS
argument_list|(
name|dynamic_copy
operator|.
name|ldd
argument_list|)
expr_stmt|;
comment|/* Calc address of `in_debugger' member of debugger interface structure */
name|flag_addr
operator|=
name|debug_addr
operator|+
call|(
name|CORE_ADDR
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|debug_copy
operator|.
name|ldd_in_debugger
operator|-
operator|(
name|char
operator|*
operator|)
operator|&
name|debug_copy
argument_list|)
expr_stmt|;
comment|/* Write a value of 1 to this member.  */
name|in_debugger
operator|=
literal|1
expr_stmt|;
name|write_memory
argument_list|(
name|flag_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|in_debugger
argument_list|,
sizeof|sizeof
argument_list|(
name|in_debugger
argument_list|)
argument_list|)
expr_stmt|;
name|success
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|success
operator|)
return|;
block|}
end_function

begin_comment
comment|/*     LOCAL FUNCTION     special_symbol_handling -- additional shared library symbol handling     SYNOPSIS     void special_symbol_handling ()     DESCRIPTION     Once the symbols from a shared object have been loaded in the usual    way, we are called to do any system specific symbol handling that     is needed.     For SunOS4, this consists of grunging around in the dynamic    linkers structures to find symbol definitions for "common" symbols    and adding them to the minimal symbol table for the runtime common    objfile.   */
end_comment

begin_function
specifier|static
name|void
name|sunos_special_symbol_handling
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|j
decl_stmt|;
if|if
condition|(
name|debug_addr
operator|==
literal|0
condition|)
block|{
comment|/* Get link_dynamic structure */
name|j
operator|=
name|target_read_memory
argument_list|(
name|debug_base
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|dynamic_copy
argument_list|,
sizeof|sizeof
argument_list|(
name|dynamic_copy
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
condition|)
block|{
comment|/* unreadable */
return|return;
block|}
comment|/* Calc address of debugger interface structure */
comment|/* FIXME, this needs work for cross-debugging of core files          (byteorder, size, alignment, etc).  */
name|debug_addr
operator|=
name|SOLIB_EXTRACT_ADDRESS
argument_list|(
name|dynamic_copy
operator|.
name|ldd
argument_list|)
expr_stmt|;
block|}
comment|/* Read the debugger structure from the inferior, just to make sure      we have a current copy. */
name|j
operator|=
name|target_read_memory
argument_list|(
name|debug_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|debug_copy
argument_list|,
sizeof|sizeof
argument_list|(
name|debug_copy
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
condition|)
return|return;
comment|/* unreadable */
comment|/* Get common symbol definitions for the loaded object. */
if|if
condition|(
name|debug_copy
operator|.
name|ldd_cp
condition|)
block|{
name|solib_add_common_symbols
argument_list|(
name|SOLIB_EXTRACT_ADDRESS
argument_list|(
name|debug_copy
operator|.
name|ldd_cp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Relocate the main executable.  This function should be called upon    stopping the inferior process at the entry point to the program.     The entry point from BFD is compared to the PC and if they are    different, the main executable is relocated by the proper amount.         As written it will only attempt to relocate executables which    lack interpreter sections.  It seems likely that only dynamic    linker executables will get relocated, though it should work    properly for a position-independent static executable as well.  */
end_comment

begin_function
specifier|static
name|void
name|sunos_relocate_main_executable
parameter_list|(
name|void
parameter_list|)
block|{
name|asection
modifier|*
name|interp_sect
decl_stmt|;
name|CORE_ADDR
name|pc
init|=
name|read_pc
argument_list|()
decl_stmt|;
comment|/* Decide if the objfile needs to be relocated.  As indicated above,      we will only be here when execution is stopped at the beginning      of the program.  Relocation is necessary if the address at which      we are presently stopped differs from the start address stored in      the executable AND there's no interpreter section.  The condition      regarding the interpreter section is very important because if      there *is* an interpreter section, execution will begin there      instead.  When there is an interpreter section, the start address      is (presumably) used by the interpreter at some point to start      execution of the program.       If there is an interpreter, it is normal for it to be set to an      arbitrary address at the outset.  The job of finding it is      handled in enable_break().       So, to summarize, relocations are necessary when there is no      interpreter section and the start address obtained from the      executable is different from the address at which GDB is      currently stopped.            [ The astute reader will note that we also test to make sure that        the executable in question has the DYNAMIC flag set.  It is my        opinion that this test is unnecessary (undesirable even).  It        was added to avoid inadvertent relocation of an executable        whose e_type member in the ELF header is not ET_DYN.  There may        be a time in the future when it is desirable to do relocations        on other types of files as well in which case this condition        should either be removed or modified to accomodate the new file        type.  (E.g, an ET_EXEC executable which has been built to be        position-independent could safely be relocated by the OS if        desired.  It is true that this violates the ABI, but the ABI        has been known to be bent from time to time.)  - Kevin, Nov 2000. ]      */
name|interp_sect
operator|=
name|bfd_get_section_by_name
argument_list|(
name|exec_bfd
argument_list|,
literal|".interp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|interp_sect
operator|==
name|NULL
operator|&&
operator|(
name|bfd_get_file_flags
argument_list|(
name|exec_bfd
argument_list|)
operator|&
name|DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
name|bfd_get_start_address
argument_list|(
name|exec_bfd
argument_list|)
operator|!=
name|pc
condition|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|new_offsets
decl_stmt|;
name|int
name|i
decl_stmt|,
name|changed
decl_stmt|;
name|CORE_ADDR
name|displacement
decl_stmt|;
comment|/* It is necessary to relocate the objfile.  The amount to 	 relocate by is simply the address at which we are stopped 	 minus the starting address from the executable.  	 We relocate all of the sections by the same amount.  This 	 behavior is mandated by recent editions of the System V ABI.  	 According to the System V Application Binary Interface, 	 Edition 4.1, page 5-5:  	   ...  Though the system chooses virtual addresses for 	   individual processes, it maintains the segments' relative 	   positions.  Because position-independent code uses relative 	   addressesing between segments, the difference between 	   virtual addresses in memory must match the difference 	   between virtual addresses in the file.  The difference 	   between the virtual address of any segment in memory and 	   the corresponding virtual address in the file is thus a 	   single constant value for any one executable or shared 	   object in a given process.  This difference is the base 	   address.  One use of the base address is to relocate the 	   memory image of the program during dynamic linking.  	 The same language also appears in Edition 4.0 of the System V 	 ABI and is left unspecified in some of the earlier editions.  */
name|displacement
operator|=
name|pc
operator|-
name|bfd_get_start_address
argument_list|(
name|exec_bfd
argument_list|)
expr_stmt|;
name|changed
operator|=
literal|0
expr_stmt|;
name|new_offsets
operator|=
name|xcalloc
argument_list|(
name|symfile_objfile
operator|->
name|num_sections
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|section_offsets
argument_list|)
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|new_offsets
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|symfile_objfile
operator|->
name|num_sections
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|displacement
operator|!=
name|ANOFFSET
argument_list|(
name|symfile_objfile
operator|->
name|section_offsets
argument_list|,
name|i
argument_list|)
condition|)
name|changed
operator|=
literal|1
expr_stmt|;
name|new_offsets
operator|->
name|offsets
index|[
name|i
index|]
operator|=
name|displacement
expr_stmt|;
block|}
if|if
condition|(
name|changed
condition|)
name|objfile_relocate
argument_list|(
name|symfile_objfile
argument_list|,
name|new_offsets
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*     GLOBAL FUNCTION     sunos_solib_create_inferior_hook -- shared library startup support     SYNOPSIS     void sunos_solib_create_inferior_hook()     DESCRIPTION     When gdb starts up the inferior, it nurses it along (through the    shell) until it is ready to execute it's first instruction.  At this    point, this function gets called via expansion of the macro    SOLIB_CREATE_INFERIOR_HOOK.     For SunOS executables, this first instruction is typically the    one at "_start", or a similar text label, regardless of whether    the executable is statically or dynamically linked.  The runtime    startup code takes care of dynamically linking in any shared    libraries, once gdb allows the inferior to continue.     For SVR4 executables, this first instruction is either the first    instruction in the dynamic linker (for dynamically linked    executables) or the instruction at "start" for statically linked    executables.  For dynamically linked executables, the system    first exec's /lib/libc.so.N, which contains the dynamic linker,    and starts it running.  The dynamic linker maps in any needed    shared libraries, maps in the actual user executable, and then    jumps to "start" in the user executable.     For both SunOS shared libraries, and SVR4 shared libraries, we    can arrange to cooperate with the dynamic linker to discover the    names of shared libraries that are dynamically linked, and the    base addresses to which they are linked.     This function is responsible for discovering those names and    addresses, and saving sufficient information about them to allow    their symbols to be read at a later time.     FIXME     Between enable_break() and disable_break(), this code does not    properly handle hitting breakpoints which the user might have    set in the startup code or in the dynamic linker itself.  Proper    handling will probably have to wait until the implementation is    changed to use the "breakpoint handler function" method.     Also, what if child has exit()ed?  Must exit loop somehow.  */
end_comment

begin_function
specifier|static
name|void
name|sunos_solib_create_inferior_hook
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Relocate the main executable if necessary.  */
name|sunos_relocate_main_executable
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|debug_base
operator|=
name|locate_base
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Can't find the symbol or the executable is statically linked. */
return|return;
block|}
if|if
condition|(
operator|!
name|enable_break
argument_list|()
condition|)
block|{
name|warning
argument_list|(
literal|"shared library handler failed to enable breakpoint"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* SCO and SunOS need the loop below, other systems should be using the      special shared library breakpoints and the shared library breakpoint      service routine.       Now run the target.  It will eventually hit the breakpoint, at      which point all of the libraries will have been mapped in and we      can go groveling around in the dynamic linker structures to find      out what we need to know about them. */
name|clear_proceed_status
argument_list|()
expr_stmt|;
name|stop_soon_quietly
operator|=
literal|1
expr_stmt|;
name|stop_signal
operator|=
name|TARGET_SIGNAL_0
expr_stmt|;
do|do
block|{
name|target_resume
argument_list|(
name|pid_to_ptid
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
name|stop_signal
argument_list|)
expr_stmt|;
name|wait_for_inferior
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|stop_signal
operator|!=
name|TARGET_SIGNAL_TRAP
condition|)
do|;
name|stop_soon_quietly
operator|=
literal|0
expr_stmt|;
comment|/* We are now either at the "mapping complete" breakpoint (or somewhere      else, a condition we aren't prepared to deal with anyway), so adjust      the PC as necessary after a breakpoint, disable the breakpoint, and      add any shared libraries that were mapped in. */
if|if
condition|(
name|DECR_PC_AFTER_BREAK
condition|)
block|{
name|stop_pc
operator|-=
name|DECR_PC_AFTER_BREAK
expr_stmt|;
name|write_register
argument_list|(
name|PC_REGNUM
argument_list|,
name|stop_pc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|disable_break
argument_list|()
condition|)
block|{
name|warning
argument_list|(
literal|"shared library handler failed to disable breakpoint"
argument_list|)
expr_stmt|;
block|}
name|solib_add
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|target_ops
operator|*
operator|)
literal|0
argument_list|,
name|auto_solib_add
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sunos_clear_solib
parameter_list|(
name|void
parameter_list|)
block|{
name|debug_base
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sunos_free_so
parameter_list|(
name|struct
name|so_list
modifier|*
name|so
parameter_list|)
block|{
name|xfree
argument_list|(
name|so
operator|->
name|lm_info
operator|->
name|lm
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|so
operator|->
name|lm_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sunos_relocate_section_addresses
parameter_list|(
name|struct
name|so_list
modifier|*
name|so
parameter_list|,
name|struct
name|section_table
modifier|*
name|sec
parameter_list|)
block|{
name|sec
operator|->
name|addr
operator|+=
name|LM_ADDR
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|sec
operator|->
name|endaddr
operator|+=
name|LM_ADDR
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|target_so_ops
name|sunos_so_ops
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_sunos_solib
parameter_list|(
name|void
parameter_list|)
block|{
name|sunos_so_ops
operator|.
name|relocate_section_addresses
operator|=
name|sunos_relocate_section_addresses
expr_stmt|;
name|sunos_so_ops
operator|.
name|free_so
operator|=
name|sunos_free_so
expr_stmt|;
name|sunos_so_ops
operator|.
name|clear_solib
operator|=
name|sunos_clear_solib
expr_stmt|;
name|sunos_so_ops
operator|.
name|solib_create_inferior_hook
operator|=
name|sunos_solib_create_inferior_hook
expr_stmt|;
name|sunos_so_ops
operator|.
name|special_symbol_handling
operator|=
name|sunos_special_symbol_handling
expr_stmt|;
name|sunos_so_ops
operator|.
name|current_sos
operator|=
name|sunos_current_sos
expr_stmt|;
name|sunos_so_ops
operator|.
name|open_symbol_file_object
operator|=
name|open_symbol_file_object
expr_stmt|;
name|sunos_so_ops
operator|.
name|in_dynsym_resolve_code
operator|=
name|sunos_in_dynsym_resolve_code
expr_stmt|;
comment|/* FIXME: Don't do this here.  *_gdbarch_init() should set so_ops. */
name|current_target_so_ops
operator|=
operator|&
name|sunos_so_ops
expr_stmt|;
block|}
end_function

end_unit

