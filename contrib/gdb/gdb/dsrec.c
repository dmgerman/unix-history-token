begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* S-record download support for GDB, the GNU debugger.    Copyright 1995, 1996, 1997, 1999, 2000, 2001    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_include
include|#
directive|include
file|"srec.h"
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_function_decl
specifier|extern
name|void
name|report_transfer_performance
parameter_list|(
name|unsigned
name|long
parameter_list|,
name|time_t
parameter_list|,
name|time_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|remote_debug
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|make_srec
parameter_list|(
name|char
modifier|*
name|srec
parameter_list|,
name|CORE_ADDR
name|targ_addr
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sect
parameter_list|,
name|int
name|sectoff
parameter_list|,
name|int
modifier|*
name|maxrecsize
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Download an executable by converting it to S records.  DESC is a    `struct serial *' to send the data to.  FILE is the name of the    file to be loaded.  LOAD_OFFSET is the offset into memory to load    data into.  It is usually specified by the user and is useful with    the a.out file format.  MAXRECSIZE is the length in chars of the    largest S-record the host can accomodate.  This is measured from    the starting `S' to the last char of the checksum.  FLAGS is    various random flags, and HASHMARK is non-zero to cause a `#' to be    printed out for each record loaded.  WAITACK, if non-NULL, is a    function that waits for an acknowledgement after each S-record, and    returns non-zero if the ack is read correctly.  */
end_comment

begin_function
name|void
name|load_srec
parameter_list|(
name|struct
name|serial
modifier|*
name|desc
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|bfd_vma
name|load_offset
parameter_list|,
name|int
name|maxrecsize
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|hashmark
parameter_list|,
name|int
function_decl|(
modifier|*
name|waitack
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|)
block|{
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|asection
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|srec
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|reclen
decl_stmt|;
name|time_t
name|start_time
decl_stmt|,
name|end_time
decl_stmt|;
name|unsigned
name|long
name|data_count
init|=
literal|0
decl_stmt|;
name|srec
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|maxrecsize
operator|+
literal|1
argument_list|)
expr_stmt|;
name|abfd
operator|=
name|bfd_openr
argument_list|(
name|file
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|abfd
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Unable to open file %s\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bfd_check_format
argument_list|(
name|abfd
argument_list|,
name|bfd_object
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"File is not an object file\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|start_time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* Write a type 0 header record. no data for a type 0, and there      is no data, so len is 0.  */
name|reclen
operator|=
name|maxrecsize
expr_stmt|;
name|make_srec
argument_list|(
name|srec
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|(
name|asection
operator|*
operator|)
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|reclen
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_debug
condition|)
block|{
name|srec
index|[
name|reclen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|puts_debug
argument_list|(
literal|"sent -->"
argument_list|,
name|srec
argument_list|,
literal|"<--"
argument_list|)
expr_stmt|;
block|}
name|serial_write
argument_list|(
name|desc
argument_list|,
name|srec
argument_list|,
name|reclen
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|abfd
operator|->
name|sections
init|;
name|s
condition|;
name|s
operator|=
name|s
operator|->
name|next
control|)
if|if
condition|(
name|s
operator|->
name|flags
operator|&
name|SEC_LOAD
condition|)
block|{
name|int
name|numbytes
decl_stmt|;
name|bfd_vma
name|addr
init|=
name|bfd_get_section_vma
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
operator|+
name|load_offset
decl_stmt|;
name|bfd_size_type
name|size
init|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|s
argument_list|)
decl_stmt|;
name|char
modifier|*
name|section_name
init|=
operator|(
name|char
operator|*
operator|)
name|bfd_get_section_name
argument_list|(
name|abfd
argument_list|,
name|s
argument_list|)
decl_stmt|;
comment|/* Both GDB and BFD have mechanisms for printing addresses.            In the below, GDB's is used so that the address is            consistent with the rest of GDB.  BFD's printf_vma() could            have also been used. cagney 1999-09-01 */
name|printf_filtered
argument_list|(
literal|"%s\t: 0x%s .. 0x%s  "
argument_list|,
name|section_name
argument_list|,
name|paddr
argument_list|(
name|addr
argument_list|)
argument_list|,
name|paddr
argument_list|(
name|addr
operator|+
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|data_count
operator|+=
name|size
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|+=
name|numbytes
control|)
block|{
name|reclen
operator|=
name|maxrecsize
expr_stmt|;
name|numbytes
operator|=
name|make_srec
argument_list|(
name|srec
argument_list|,
call|(
name|CORE_ADDR
call|)
argument_list|(
name|addr
operator|+
name|i
argument_list|)
argument_list|,
name|abfd
argument_list|,
name|s
argument_list|,
name|i
argument_list|,
operator|&
name|reclen
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_debug
condition|)
block|{
name|srec
index|[
name|reclen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|puts_debug
argument_list|(
literal|"sent -->"
argument_list|,
name|srec
argument_list|,
literal|"<--"
argument_list|)
expr_stmt|;
block|}
comment|/* Repeatedly send the S-record until a good 	       acknowledgement is sent back.  */
do|do
block|{
name|serial_write
argument_list|(
name|desc
argument_list|,
name|srec
argument_list|,
name|reclen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ui_load_progress_hook
condition|)
if|if
condition|(
name|ui_load_progress_hook
argument_list|(
name|section_name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|i
argument_list|)
condition|)
name|error
argument_list|(
literal|"Canceled the download"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|waitack
operator|!=
name|NULL
operator|&&
operator|!
name|waitack
argument_list|()
condition|)
do|;
if|if
condition|(
name|hashmark
condition|)
block|{
name|putchar_unfiltered
argument_list|(
literal|'#'
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Per-packet (or S-record) loop */
if|if
condition|(
name|ui_load_progress_hook
condition|)
if|if
condition|(
name|ui_load_progress_hook
argument_list|(
name|section_name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|i
argument_list|)
condition|)
name|error
argument_list|(
literal|"Canceled the download"
argument_list|)
expr_stmt|;
name|putchar_unfiltered
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hashmark
condition|)
name|putchar_unfiltered
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|end_time
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* Write a terminator record.  */
name|reclen
operator|=
name|maxrecsize
expr_stmt|;
name|make_srec
argument_list|(
name|srec
argument_list|,
name|abfd
operator|->
name|start_address
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|reclen
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_debug
condition|)
block|{
name|srec
index|[
name|reclen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|puts_debug
argument_list|(
literal|"sent -->"
argument_list|,
name|srec
argument_list|,
literal|"<--"
argument_list|)
expr_stmt|;
block|}
name|serial_write
argument_list|(
name|desc
argument_list|,
name|srec
argument_list|,
name|reclen
argument_list|)
expr_stmt|;
comment|/* Some monitors need these to wake up properly.  (Which ones? -sts)  */
name|serial_write
argument_list|(
name|desc
argument_list|,
literal|"\r\r"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_debug
condition|)
name|puts_debug
argument_list|(
literal|"sent -->"
argument_list|,
literal|"\r\r"
argument_list|,
literal|"<---"
argument_list|)
expr_stmt|;
name|serial_flush_input
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|report_transfer_performance
argument_list|(
name|data_count
argument_list|,
name|start_time
argument_list|,
name|end_time
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * make_srec -- make an srecord. This writes each line, one at a  *      time, each with it's own header and trailer line.  *      An srecord looks like this:  *  * byte count-+     address  * start ---+ |        |       data        +- checksum  *          | |        |                   |  *        S01000006F6B692D746573742E73726563E4  *        S315000448600000000000000000FC00005900000000E9  *        S31A0004000023C1400037DE00F023604000377B009020825000348D  *        S30B0004485A0000000000004E  *        S70500040000F6  *  *      S<type><length><address><data><checksum>  *  *      Where  *      - length  *        is the number of bytes following upto the checksum. Note that  *        this is not the number of chars following, since it takes two  *        chars to represent a byte.  *      - type  *        is one of:  *        0) header record  *        1) two byte address data record  *        2) three byte address data record  *        3) four byte address data record  *        7) four byte address termination record  *        8) three byte address termination record  *        9) two byte address termination record  *         *      - address  *        is the start address of the data following, or in the case of  *        a termination record, the start address of the image  *      - data  *        is the data.  *      - checksum  *        is the sum of all the raw byte data in the record, from the length  *        upwards, modulo 256 and subtracted from 255.  *  * This routine returns the length of the S-record.  *  */
end_comment

begin_function
specifier|static
name|int
name|make_srec
parameter_list|(
name|char
modifier|*
name|srec
parameter_list|,
name|CORE_ADDR
name|targ_addr
parameter_list|,
name|bfd
modifier|*
name|abfd
parameter_list|,
name|asection
modifier|*
name|sect
parameter_list|,
name|int
name|sectoff
parameter_list|,
name|int
modifier|*
name|maxrecsize
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|unsigned
name|char
name|checksum
decl_stmt|;
name|int
name|tmp
decl_stmt|;
specifier|const
specifier|static
name|char
name|hextab
index|[]
init|=
literal|"0123456789ABCDEF"
decl_stmt|;
specifier|const
specifier|static
name|char
name|data_code_table
index|[]
init|=
literal|"123"
decl_stmt|;
specifier|const
specifier|static
name|char
name|term_code_table
index|[]
init|=
literal|"987"
decl_stmt|;
specifier|const
specifier|static
name|char
name|header_code_table
index|[]
init|=
literal|"000"
decl_stmt|;
specifier|const
specifier|static
name|char
modifier|*
name|formats
index|[]
init|=
block|{
literal|"S%c%02X%04X"
block|,
literal|"S%c%02X%06X"
block|,
literal|"S%c%02X%08X"
block|}
decl_stmt|;
name|char
specifier|const
modifier|*
name|code_table
decl_stmt|;
name|int
name|addr_size
decl_stmt|;
name|int
name|payload_size
decl_stmt|;
name|char
modifier|*
name|binbuf
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|sect
condition|)
block|{
name|tmp
operator|=
name|flags
expr_stmt|;
comment|/* Data or header record */
name|code_table
operator|=
name|abfd
condition|?
name|data_code_table
else|:
name|header_code_table
expr_stmt|;
name|binbuf
operator|=
name|alloca
argument_list|(
operator|*
name|maxrecsize
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|=
name|flags
operator|>>
name|SREC_TERM_SHIFT
expr_stmt|;
comment|/* Term record */
name|code_table
operator|=
name|term_code_table
expr_stmt|;
name|binbuf
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tmp
operator|&
name|SREC_2_BYTE_ADDR
operator|)
operator|&&
operator|(
name|targ_addr
operator|<=
literal|0xffff
operator|)
condition|)
name|addr_size
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|tmp
operator|&
name|SREC_3_BYTE_ADDR
operator|)
operator|&&
operator|(
name|targ_addr
operator|<=
literal|0xffffff
operator|)
condition|)
name|addr_size
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|tmp
operator|&
name|SREC_4_BYTE_ADDR
condition|)
name|addr_size
operator|=
literal|4
expr_stmt|;
else|else
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"make_srec:  Bad address (0x%s), or bad flags (0x%x)."
argument_list|,
name|paddr
argument_list|(
name|targ_addr
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* Now that we know the address size, we can figure out how much      data this record can hold.  */
if|if
condition|(
name|sect
operator|&&
name|abfd
condition|)
block|{
name|payload_size
operator|=
operator|(
operator|*
name|maxrecsize
operator|-
operator|(
literal|1
operator|+
literal|1
operator|+
literal|2
operator|+
name|addr_size
operator|*
literal|2
operator|+
literal|2
operator|)
operator|)
operator|/
literal|2
expr_stmt|;
name|payload_size
operator|=
name|min
argument_list|(
name|payload_size
argument_list|,
name|sect
operator|->
name|_raw_size
operator|-
name|sectoff
argument_list|)
expr_stmt|;
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|sect
argument_list|,
name|binbuf
argument_list|,
name|sectoff
argument_list|,
name|payload_size
argument_list|)
expr_stmt|;
block|}
else|else
name|payload_size
operator|=
literal|0
expr_stmt|;
comment|/* Term or header packets have no payload */
comment|/* Output the header.  */
name|sprintf
argument_list|(
name|srec
argument_list|,
name|formats
index|[
name|addr_size
operator|-
literal|2
index|]
argument_list|,
name|code_table
index|[
name|addr_size
operator|-
literal|2
index|]
argument_list|,
name|addr_size
operator|+
name|payload_size
operator|+
literal|1
argument_list|,
operator|(
name|int
operator|)
name|targ_addr
argument_list|)
expr_stmt|;
comment|/* Note that the checksum is calculated on the raw data, not the      hexified data.  It includes the length, address and the data      portions of the packet.  */
name|checksum
operator|=
literal|0
expr_stmt|;
name|checksum
operator|+=
operator|(
name|payload_size
operator|+
name|addr_size
operator|+
literal|1
comment|/* Packet length */
operator|+
operator|(
name|targ_addr
operator|&
literal|0xff
operator|)
comment|/* Address... */
operator|+
operator|(
operator|(
name|targ_addr
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
operator|+
operator|(
operator|(
name|targ_addr
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
operator|+
operator|(
operator|(
name|targ_addr
operator|>>
literal|24
operator|)
operator|&
literal|0xff
operator|)
operator|)
expr_stmt|;
name|p
operator|=
name|srec
operator|+
literal|1
operator|+
literal|1
operator|+
literal|2
operator|+
name|addr_size
operator|*
literal|2
expr_stmt|;
comment|/* Build the Srecord.  */
for|for
control|(
name|tmp
operator|=
literal|0
init|;
name|tmp
operator|<
name|payload_size
condition|;
name|tmp
operator|++
control|)
block|{
name|unsigned
name|char
name|k
decl_stmt|;
name|k
operator|=
name|binbuf
index|[
name|tmp
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|hextab
index|[
name|k
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|hextab
index|[
name|k
operator|&
literal|0xf
index|]
expr_stmt|;
name|checksum
operator|+=
name|k
expr_stmt|;
block|}
name|checksum
operator|=
operator|~
name|checksum
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|hextab
index|[
name|checksum
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|hextab
index|[
name|checksum
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\r'
expr_stmt|;
operator|*
name|maxrecsize
operator|=
name|p
operator|-
name|srec
expr_stmt|;
return|return
name|payload_size
return|;
block|}
end_function

end_unit

