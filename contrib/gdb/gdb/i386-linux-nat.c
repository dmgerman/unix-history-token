begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Native-dependent code for GNU/Linux x86.     Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/procfs.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_REG_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/reg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_DEBUGREG_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/debugreg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DR_FIRSTADDR
end_ifndef

begin_define
define|#
directive|define
name|DR_FIRSTADDR
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DR_LASTADDR
end_ifndef

begin_define
define|#
directive|define
name|DR_LASTADDR
value|3
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DR_STATUS
end_ifndef

begin_define
define|#
directive|define
name|DR_STATUS
value|6
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DR_CONTROL
end_ifndef

begin_define
define|#
directive|define
name|DR_CONTROL
value|7
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Prototypes for supply_gregset etc.  */
end_comment

begin_include
include|#
directive|include
file|"gregset.h"
end_include

begin_comment
comment|/* Prototypes for i387_supply_fsave etc.  */
end_comment

begin_include
include|#
directive|include
file|"i387-nat.h"
end_include

begin_comment
comment|/* Defines for XMM0_REGNUM etc. */
end_comment

begin_include
include|#
directive|include
file|"i386-tdep.h"
end_include

begin_comment
comment|/* Prototypes for local functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|dummy_sse_values
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/* The register sets used in GNU/Linux ELF core-dumps are identical to    the register sets in `struct user' that is used for a.out    core-dumps, and is also used by `ptrace'.  The corresponding types    are `elf_gregset_t' for the general-purpose registers (with    `elf_greg_t' the type of a single GP register) and `elf_fpregset_t'    for the floating-point registers.     Those types used to be available under the names `gregset_t' and    `fpregset_t' too, and this file used those names in the past.  But    those names are now used for the register sets used in the    `mcontext_t' type, and have a different size and layout.  */
end_comment

begin_comment
comment|/* Mapping between the general-purpose registers in `struct user'    format and GDB's register array layout.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|regmap
index|[]
init|=
block|{
name|EAX
block|,
name|ECX
block|,
name|EDX
block|,
name|EBX
block|,
name|UESP
block|,
name|EBP
block|,
name|ESI
block|,
name|EDI
block|,
name|EIP
block|,
name|EFL
block|,
name|CS
block|,
name|SS
block|,
name|DS
block|,
name|ES
block|,
name|FS
block|,
name|GS
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Which ptrace request retrieves which registers?    These apply to the corresponding SET requests as well.  */
end_comment

begin_define
define|#
directive|define
name|GETREGS_SUPPLIES
parameter_list|(
name|regno
parameter_list|)
define|\
value|((0<= (regno)&& (regno)<= 15) || (regno) == I386_LINUX_ORIG_EAX_REGNUM)
end_define

begin_define
define|#
directive|define
name|GETFPREGS_SUPPLIES
parameter_list|(
name|regno
parameter_list|)
define|\
value|(FP0_REGNUM<= (regno)&& (regno)<= LAST_FPU_CTRL_REGNUM)
end_define

begin_define
define|#
directive|define
name|GETFPXREGS_SUPPLIES
parameter_list|(
name|regno
parameter_list|)
define|\
value|(FP0_REGNUM<= (regno)&& (regno)<= MXCSR_REGNUM)
end_define

begin_comment
comment|/* Does the current host support the GETREGS request?  */
end_comment

begin_decl_stmt
name|int
name|have_ptrace_getregs
init|=
ifdef|#
directive|ifdef
name|HAVE_PTRACE_GETREGS
literal|1
else|#
directive|else
literal|0
endif|#
directive|endif
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Does the current host support the GETFPXREGS request?  The header    file may or may not define it, and even if it is defined, the    kernel will return EIO if it's running on a pre-SSE processor.     My instinct is to attach this to some architecture- or    target-specific data structure, but really, a particular GDB    process can only run on top of one kernel at a time.  So it's okay    for this to be a simple variable.  */
end_comment

begin_decl_stmt
name|int
name|have_ptrace_getfpxregs
init|=
ifdef|#
directive|ifdef
name|HAVE_PTRACE_GETFPXREGS
literal|1
else|#
directive|else
literal|0
endif|#
directive|endif
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Support for the user struct.  */
end_comment

begin_comment
comment|/* Return the address of register REGNUM.  BLOCKEND is the value of    u.u_ar0, which should point to the registers.  */
end_comment

begin_function
name|CORE_ADDR
name|register_u_addr
parameter_list|(
name|CORE_ADDR
name|blockend
parameter_list|,
name|int
name|regnum
parameter_list|)
block|{
return|return
operator|(
name|blockend
operator|+
literal|4
operator|*
name|regmap
index|[
name|regnum
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the size of the user struct.  */
end_comment

begin_function
name|int
name|kernel_u_size
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|user
argument_list|)
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Fetching registers directly from the U area, one at a time.  */
end_comment

begin_comment
comment|/* FIXME: kettenis/2000-03-05: This duplicates code from `inptrace.c'.    The problem is that we define FETCH_INFERIOR_REGISTERS since we    want to use our own versions of {fetch,store}_inferior_registers    that use the GETREGS request.  This means that the code in    `infptrace.c' is #ifdef'd out.  But we need to fall back on that    code when GDB is running on top of a kernel that doesn't support    the GETREGS request.  I want to avoid changing `infptrace.c' right    now.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PT_READ_U
end_ifndef

begin_define
define|#
directive|define
name|PT_READ_U
value|PTRACE_PEEKUSR
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|PT_WRITE_U
end_ifndef

begin_define
define|#
directive|define
name|PT_WRITE_U
value|PTRACE_POKEUSR
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Default the type of the ptrace transfer to int.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PTRACE_XFER_TYPE
end_ifndef

begin_define
define|#
directive|define
name|PTRACE_XFER_TYPE
value|int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Registers we shouldn't try to fetch.  */
end_comment

begin_define
define|#
directive|define
name|OLD_CANNOT_FETCH_REGISTER
parameter_list|(
name|regno
parameter_list|)
value|((regno)>= NUM_GREGS)
end_define

begin_comment
comment|/* Fetch one register.  */
end_comment

begin_function
specifier|static
name|void
name|fetch_register
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
comment|/* This isn't really an address.  But ptrace thinks of it as one.  */
name|CORE_ADDR
name|regaddr
decl_stmt|;
name|char
name|mess
index|[
literal|128
index|]
decl_stmt|;
comment|/* For messages */
specifier|register
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
comment|/* Offset of registers within the u area.  */
name|char
name|buf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|int
name|tid
decl_stmt|;
if|if
condition|(
name|OLD_CANNOT_FETCH_REGISTER
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|memset
argument_list|(
name|buf
argument_list|,
literal|'\0'
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Supply zeroes */
name|supply_register
argument_list|(
name|regno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Overload thread id onto process id */
if|if
condition|(
operator|(
name|tid
operator|=
name|TIDGET
argument_list|(
name|inferior_ptid
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|tid
operator|=
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
comment|/* no thread id, just use process id */
name|offset
operator|=
name|U_REGS_OFFSET
expr_stmt|;
name|regaddr
operator|=
name|register_addr
argument_list|(
name|regno
argument_list|,
name|offset
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|PTRACE_XFER_TYPE
operator|*
operator|)
operator|&
name|buf
index|[
name|i
index|]
operator|=
name|ptrace
argument_list|(
name|PT_READ_U
argument_list|,
name|tid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|regaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|regaddr
operator|+=
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|mess
argument_list|,
literal|"reading register %s (#%d)"
argument_list|,
name|REGISTER_NAME
argument_list|(
name|regno
argument_list|)
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|mess
argument_list|)
expr_stmt|;
block|}
block|}
name|supply_register
argument_list|(
name|regno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fetch register values from the inferior.    If REGNO is negative, do this for all registers.    Otherwise, REGNO specifies which register (so we can save time). */
end_comment

begin_function
name|void
name|old_fetch_inferior_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
name|regno
operator|>=
literal|0
condition|)
block|{
name|fetch_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
block|{
name|fetch_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Registers we shouldn't try to store.  */
end_comment

begin_define
define|#
directive|define
name|OLD_CANNOT_STORE_REGISTER
parameter_list|(
name|regno
parameter_list|)
value|((regno)>= NUM_GREGS)
end_define

begin_comment
comment|/* Store one register. */
end_comment

begin_function
specifier|static
name|void
name|store_register
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
comment|/* This isn't really an address.  But ptrace thinks of it as one.  */
name|CORE_ADDR
name|regaddr
decl_stmt|;
name|char
name|mess
index|[
literal|128
index|]
decl_stmt|;
comment|/* For messages */
specifier|register
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|;
comment|/* Offset of registers within the u area.  */
name|int
name|tid
decl_stmt|;
if|if
condition|(
name|OLD_CANNOT_STORE_REGISTER
argument_list|(
name|regno
argument_list|)
condition|)
block|{
return|return;
block|}
comment|/* Overload thread id onto process id */
if|if
condition|(
operator|(
name|tid
operator|=
name|TIDGET
argument_list|(
name|inferior_ptid
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|tid
operator|=
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
comment|/* no thread id, just use process id */
name|offset
operator|=
name|U_REGS_OFFSET
expr_stmt|;
name|regaddr
operator|=
name|register_addr
argument_list|(
name|regno
argument_list|,
name|offset
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|PT_WRITE_U
argument_list|,
name|tid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|regaddr
argument_list|,
operator|*
operator|(
name|PTRACE_XFER_TYPE
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
name|regaddr
operator|+=
sizeof|sizeof
argument_list|(
name|PTRACE_XFER_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|mess
argument_list|,
literal|"writing register %s (#%d)"
argument_list|,
name|REGISTER_NAME
argument_list|(
name|regno
argument_list|)
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|mess
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Store our register values back into the inferior.    If REGNO is negative, do this for all registers.    Otherwise, REGNO specifies which register (so we can save time).  */
end_comment

begin_function
name|void
name|old_store_inferior_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
name|regno
operator|>=
literal|0
condition|)
block|{
name|store_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
block|{
name|store_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Transfering the general-purpose registers between GDB, inferiors    and core files.  */
end_comment

begin_comment
comment|/* Fill GDB's register array with the general-purpose register values    in *GREGSETP.  */
end_comment

begin_function
name|void
name|supply_gregset
parameter_list|(
name|elf_gregset_t
modifier|*
name|gregsetp
parameter_list|)
block|{
name|elf_greg_t
modifier|*
name|regp
init|=
operator|(
name|elf_greg_t
operator|*
operator|)
name|gregsetp
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_GREGS
condition|;
name|i
operator|++
control|)
name|supply_register
argument_list|(
name|i
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|regmap
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|I386_LINUX_ORIG_EAX_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
name|ORIG_EAX
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fill register REGNO (if it is a general-purpose register) in    *GREGSETPS with the value in GDB's register array.  If REGNO is -1,    do this for all registers.  */
end_comment

begin_function
name|void
name|fill_gregset
parameter_list|(
name|elf_gregset_t
modifier|*
name|gregsetp
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|elf_greg_t
modifier|*
name|regp
init|=
operator|(
name|elf_greg_t
operator|*
operator|)
name|gregsetp
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_GREGS
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|||
name|regno
operator|==
name|i
operator|)
condition|)
name|regcache_collect
argument_list|(
name|i
argument_list|,
name|regp
operator|+
name|regmap
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
operator|||
name|regno
operator|==
name|I386_LINUX_ORIG_EAX_REGNUM
condition|)
name|regcache_collect
argument_list|(
name|I386_LINUX_ORIG_EAX_REGNUM
argument_list|,
name|regp
operator|+
name|ORIG_EAX
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PTRACE_GETREGS
end_ifdef

begin_comment
comment|/* Fetch all general-purpose registers from process/thread TID and    store their values in GDB's register array.  */
end_comment

begin_function
specifier|static
name|void
name|fetch_regs
parameter_list|(
name|int
name|tid
parameter_list|)
block|{
name|elf_gregset_t
name|regs
decl_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PTRACE_GETREGS
argument_list|,
name|tid
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
operator|&
name|regs
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EIO
condition|)
block|{
comment|/* The kernel we're running on doesn't support the GETREGS              request.  Reset `have_ptrace_getregs'.  */
name|have_ptrace_getregs
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|perror_with_name
argument_list|(
literal|"Couldn't get registers"
argument_list|)
expr_stmt|;
block|}
name|supply_gregset
argument_list|(
operator|&
name|regs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store all valid general-purpose registers in GDB's register array    into the process/thread specified by TID.  */
end_comment

begin_function
specifier|static
name|void
name|store_regs
parameter_list|(
name|int
name|tid
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|elf_gregset_t
name|regs
decl_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PTRACE_GETREGS
argument_list|,
name|tid
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
operator|&
name|regs
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"Couldn't get registers"
argument_list|)
expr_stmt|;
name|fill_gregset
argument_list|(
operator|&
name|regs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PTRACE_SETREGS
argument_list|,
name|tid
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
operator|&
name|regs
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"Couldn't write registers"
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|void
name|fetch_regs
parameter_list|(
name|int
name|tid
parameter_list|)
block|{}
end_function

begin_function
specifier|static
name|void
name|store_regs
parameter_list|(
name|int
name|tid
parameter_list|,
name|int
name|regno
parameter_list|)
block|{}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Transfering floating-point registers between GDB, inferiors and cores.  */
end_comment

begin_comment
comment|/* Fill GDB's register array with the floating-point register values in    *FPREGSETP.  */
end_comment

begin_function
name|void
name|supply_fpregset
parameter_list|(
name|elf_fpregset_t
modifier|*
name|fpregsetp
parameter_list|)
block|{
name|i387_supply_fsave
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fpregsetp
argument_list|)
expr_stmt|;
name|dummy_sse_values
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fill register REGNO (if it is a floating-point register) in    *FPREGSETP with the value in GDB's register array.  If REGNO is -1,    do this for all registers.  */
end_comment

begin_function
name|void
name|fill_fpregset
parameter_list|(
name|elf_fpregset_t
modifier|*
name|fpregsetp
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|i387_fill_fsave
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fpregsetp
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PTRACE_GETREGS
end_ifdef

begin_comment
comment|/* Fetch all floating-point registers from process/thread TID and store    thier values in GDB's register array.  */
end_comment

begin_function
specifier|static
name|void
name|fetch_fpregs
parameter_list|(
name|int
name|tid
parameter_list|)
block|{
name|elf_fpregset_t
name|fpregs
decl_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PTRACE_GETFPREGS
argument_list|,
name|tid
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
operator|&
name|fpregs
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"Couldn't get floating point status"
argument_list|)
expr_stmt|;
name|supply_fpregset
argument_list|(
operator|&
name|fpregs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store all valid floating-point registers in GDB's register array    into the process/thread specified by TID.  */
end_comment

begin_function
specifier|static
name|void
name|store_fpregs
parameter_list|(
name|int
name|tid
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|elf_fpregset_t
name|fpregs
decl_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PTRACE_GETFPREGS
argument_list|,
name|tid
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
operator|&
name|fpregs
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"Couldn't get floating point status"
argument_list|)
expr_stmt|;
name|fill_fpregset
argument_list|(
operator|&
name|fpregs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PTRACE_SETFPREGS
argument_list|,
name|tid
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
operator|&
name|fpregs
argument_list|)
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"Couldn't write floating point status"
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|void
name|fetch_fpregs
parameter_list|(
name|int
name|tid
parameter_list|)
block|{}
end_function

begin_function
specifier|static
name|void
name|store_fpregs
parameter_list|(
name|int
name|tid
parameter_list|,
name|int
name|regno
parameter_list|)
block|{}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Transfering floating-point and SSE registers to and from GDB.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PTRACE_GETFPXREGS
end_ifdef

begin_comment
comment|/* Fill GDB's register array with the floating-point and SSE register    values in *FPXREGSETP.  */
end_comment

begin_function
name|void
name|supply_fpxregset
parameter_list|(
name|elf_fpxregset_t
modifier|*
name|fpxregsetp
parameter_list|)
block|{
name|i387_supply_fxsave
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fpxregsetp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fill register REGNO (if it is a floating-point or SSE register) in    *FPXREGSETP with the value in GDB's register array.  If REGNO is    -1, do this for all registers.  */
end_comment

begin_function
name|void
name|fill_fpxregset
parameter_list|(
name|elf_fpxregset_t
modifier|*
name|fpxregsetp
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|i387_fill_fxsave
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fpxregsetp
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fetch all registers covered by the PTRACE_GETFPXREGS request from    process/thread TID and store their values in GDB's register array.    Return non-zero if successful, zero otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|fetch_fpxregs
parameter_list|(
name|int
name|tid
parameter_list|)
block|{
name|elf_fpxregset_t
name|fpxregs
decl_stmt|;
if|if
condition|(
operator|!
name|have_ptrace_getfpxregs
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ptrace
argument_list|(
name|PTRACE_GETFPXREGS
argument_list|,
name|tid
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
operator|&
name|fpxregs
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EIO
condition|)
block|{
name|have_ptrace_getfpxregs
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|perror_with_name
argument_list|(
literal|"Couldn't read floating-point and SSE registers"
argument_list|)
expr_stmt|;
block|}
name|supply_fpxregset
argument_list|(
operator|&
name|fpxregs
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Store all valid registers in GDB's register array covered by the    PTRACE_SETFPXREGS request into the process/thread specified by TID.    Return non-zero if successful, zero otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|store_fpxregs
parameter_list|(
name|int
name|tid
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|elf_fpxregset_t
name|fpxregs
decl_stmt|;
if|if
condition|(
operator|!
name|have_ptrace_getfpxregs
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ptrace
argument_list|(
name|PTRACE_GETFPXREGS
argument_list|,
name|tid
argument_list|,
literal|0
argument_list|,
operator|&
name|fpxregs
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EIO
condition|)
block|{
name|have_ptrace_getfpxregs
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|perror_with_name
argument_list|(
literal|"Couldn't read floating-point and SSE registers"
argument_list|)
expr_stmt|;
block|}
name|fill_fpxregset
argument_list|(
operator|&
name|fpxregs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptrace
argument_list|(
name|PTRACE_SETFPXREGS
argument_list|,
name|tid
argument_list|,
literal|0
argument_list|,
operator|&
name|fpxregs
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|perror_with_name
argument_list|(
literal|"Couldn't write floating-point and SSE registers"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Fill the XMM registers in the register array with dummy values.  For    cases where we don't have access to the XMM registers.  I think    this is cleaner than printing a warning.  For a cleaner solution,    we should gdbarchify the i386 family.  */
end_comment

begin_function
specifier|static
name|void
name|dummy_sse_values
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* C doesn't have a syntax for NaN's, so write it out as an array of      longs.  */
specifier|static
name|long
name|dummy
index|[
literal|4
index|]
init|=
block|{
literal|0xffffffff
block|,
literal|0xffffffff
block|,
literal|0xffffffff
block|,
literal|0xffffffff
block|}
decl_stmt|;
specifier|static
name|long
name|mxcsr
init|=
literal|0x1f80
decl_stmt|;
name|int
name|reg
decl_stmt|;
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<
literal|8
condition|;
name|reg
operator|++
control|)
name|supply_register
argument_list|(
name|XMM0_REGNUM
operator|+
name|reg
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dummy
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|MXCSR_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mxcsr
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|int
name|fetch_fpxregs
parameter_list|(
name|int
name|tid
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|store_fpxregs
parameter_list|(
name|int
name|tid
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dummy_sse_values
parameter_list|(
name|void
parameter_list|)
block|{}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PTRACE_GETFPXREGS */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Transferring arbitrary registers between GDB and inferior.  */
end_comment

begin_comment
comment|/* Check if register REGNO in the child process is accessible.    If we are accessing registers directly via the U area, only the    general-purpose registers are available.    All registers should be accessible if we have GETREGS support.  */
end_comment

begin_function
name|int
name|cannot_fetch_register
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
operator|!
name|have_ptrace_getregs
condition|)
return|return
name|OLD_CANNOT_FETCH_REGISTER
argument_list|(
name|regno
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|cannot_store_register
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
if|if
condition|(
operator|!
name|have_ptrace_getregs
condition|)
return|return
name|OLD_CANNOT_STORE_REGISTER
argument_list|(
name|regno
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Fetch register REGNO from the child process.  If REGNO is -1, do    this for all registers (including the floating point and SSE    registers).  */
end_comment

begin_function
name|void
name|fetch_inferior_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|int
name|tid
decl_stmt|;
comment|/* Use the old method of peeking around in `struct user' if the      GETREGS request isn't available.  */
if|if
condition|(
operator|!
name|have_ptrace_getregs
condition|)
block|{
name|old_fetch_inferior_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* GNU/Linux LWP ID's are process ID's.  */
if|if
condition|(
operator|(
name|tid
operator|=
name|TIDGET
argument_list|(
name|inferior_ptid
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|tid
operator|=
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
comment|/* Not a threaded program.  */
comment|/* Use the PTRACE_GETFPXREGS request whenever possible, since it      transfers more registers in one system call, and we'll cache the      results.  But remember that fetch_fpxregs can fail, and return      zero.  */
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
name|fetch_regs
argument_list|(
name|tid
argument_list|)
expr_stmt|;
comment|/* The call above might reset `have_ptrace_getregs'.  */
if|if
condition|(
operator|!
name|have_ptrace_getregs
condition|)
block|{
name|old_fetch_inferior_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|fetch_fpxregs
argument_list|(
name|tid
argument_list|)
condition|)
return|return;
name|fetch_fpregs
argument_list|(
name|tid
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GETREGS_SUPPLIES
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|fetch_regs
argument_list|(
name|tid
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GETFPXREGS_SUPPLIES
argument_list|(
name|regno
argument_list|)
condition|)
block|{
if|if
condition|(
name|fetch_fpxregs
argument_list|(
name|tid
argument_list|)
condition|)
return|return;
comment|/* Either our processor or our kernel doesn't support the SSE 	 registers, so read the FP registers in the traditional way, 	 and fill the SSE registers with dummy values.  It would be 	 more graceful to handle differences in the register set using 	 gdbarch.  Until then, this will at least make things work 	 plausibly.  */
name|fetch_fpregs
argument_list|(
name|tid
argument_list|)
expr_stmt|;
return|return;
block|}
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Got request for bad register number %d."
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store register REGNO back into the child process.  If REGNO is -1,    do this for all registers (including the floating point and SSE    registers).  */
end_comment

begin_function
name|void
name|store_inferior_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|int
name|tid
decl_stmt|;
comment|/* Use the old method of poking around in `struct user' if the      SETREGS request isn't available.  */
if|if
condition|(
operator|!
name|have_ptrace_getregs
condition|)
block|{
name|old_store_inferior_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* GNU/Linux LWP ID's are process ID's.  */
if|if
condition|(
operator|(
name|tid
operator|=
name|TIDGET
argument_list|(
name|inferior_ptid
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|tid
operator|=
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
comment|/* Not a threaded program.  */
comment|/* Use the PTRACE_SETFPXREGS requests whenever possible, since it      transfers more registers in one system call.  But remember that      store_fpxregs can fail, and return zero.  */
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
name|store_regs
argument_list|(
name|tid
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|store_fpxregs
argument_list|(
name|tid
argument_list|,
name|regno
argument_list|)
condition|)
return|return;
name|store_fpregs
argument_list|(
name|tid
argument_list|,
name|regno
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GETREGS_SUPPLIES
argument_list|(
name|regno
argument_list|)
condition|)
block|{
name|store_regs
argument_list|(
name|tid
argument_list|,
name|regno
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GETFPXREGS_SUPPLIES
argument_list|(
name|regno
argument_list|)
condition|)
block|{
if|if
condition|(
name|store_fpxregs
argument_list|(
name|tid
argument_list|,
name|regno
argument_list|)
condition|)
return|return;
comment|/* Either our processor or our kernel doesn't support the SSE 	 registers, so just write the FP registers in the traditional 	 way.  */
name|store_fpregs
argument_list|(
name|tid
argument_list|,
name|regno
argument_list|)
expr_stmt|;
return|return;
block|}
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"Got request to store bad register number %d."
argument_list|,
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|unsigned
name|long
name|i386_linux_dr_get
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
name|int
name|tid
decl_stmt|;
name|unsigned
name|long
name|value
decl_stmt|;
comment|/* FIXME: kettenis/2001-01-29: It's not clear what we should do with      multi-threaded processes here.  For now, pretend there is just      one thread.  */
name|tid
operator|=
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
comment|/* FIXME: kettenis/2001-03-27: Calling perror_with_name if the      ptrace call fails breaks debugging remote targets.  The correct      way to fix this is to add the hardware breakpoint and watchpoint      stuff to the target vectore.  For now, just return zero if the      ptrace call fails.  */
name|errno
operator|=
literal|0
expr_stmt|;
name|value
operator|=
name|ptrace
argument_list|(
name|PT_READ_U
argument_list|,
name|tid
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|user
argument_list|,
name|u_debugreg
index|[
name|regnum
index|]
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
if|#
directive|if
literal|0
then|perror_with_name ("Couldn't read debug register");
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
return|return
name|value
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|i386_linux_dr_set
parameter_list|(
name|int
name|regnum
parameter_list|,
name|unsigned
name|long
name|value
parameter_list|)
block|{
name|int
name|tid
decl_stmt|;
comment|/* FIXME: kettenis/2001-01-29: It's not clear what we should do with      multi-threaded processes here.  For now, pretend there is just      one thread.  */
name|tid
operator|=
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|PT_WRITE_U
argument_list|,
name|tid
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|user
argument_list|,
name|u_debugreg
index|[
name|regnum
index|]
argument_list|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"Couldn't write debug register"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|i386_linux_dr_set_control
parameter_list|(
name|unsigned
name|long
name|control
parameter_list|)
block|{
name|i386_linux_dr_set
argument_list|(
name|DR_CONTROL
argument_list|,
name|control
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|i386_linux_dr_set_addr
parameter_list|(
name|int
name|regnum
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<=
name|DR_LASTADDR
operator|-
name|DR_FIRSTADDR
argument_list|)
expr_stmt|;
name|i386_linux_dr_set
argument_list|(
name|DR_FIRSTADDR
operator|+
name|regnum
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|i386_linux_dr_reset_addr
parameter_list|(
name|int
name|regnum
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|regnum
operator|>=
literal|0
operator|&&
name|regnum
operator|<=
name|DR_LASTADDR
operator|-
name|DR_FIRSTADDR
argument_list|)
expr_stmt|;
name|i386_linux_dr_set
argument_list|(
name|DR_FIRSTADDR
operator|+
name|regnum
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|long
name|i386_linux_dr_get_status
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|i386_linux_dr_get
argument_list|(
name|DR_STATUS
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Interpreting register set info found in core files.  */
end_comment

begin_comment
comment|/* Provide registers to GDB from a core file.     (We can't use the generic version of this function in    core-regset.c, because GNU/Linux has *three* different kinds of    register set notes.  core-regset.c would have to call    supply_fpxregset, which most platforms don't have.)     CORE_REG_SECT points to an array of bytes, which are the contents    of a `note' from a core file which BFD thinks might contain    register contents.  CORE_REG_SIZE is its size.     WHICH says which register set corelow suspects this is:      0 --- the general-purpose register set, in elf_gregset_t format      2 --- the floating-point register set, in elf_fpregset_t format      3 --- the extended floating-point register set, in elf_fpxregset_t format     REG_ADDR isn't used on GNU/Linux.  */
end_comment

begin_function
specifier|static
name|void
name|fetch_core_registers
parameter_list|(
name|char
modifier|*
name|core_reg_sect
parameter_list|,
name|unsigned
name|core_reg_size
parameter_list|,
name|int
name|which
parameter_list|,
name|CORE_ADDR
name|reg_addr
parameter_list|)
block|{
name|elf_gregset_t
name|gregset
decl_stmt|;
name|elf_fpregset_t
name|fpregset
decl_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|core_reg_size
operator|!=
sizeof|sizeof
argument_list|(
name|gregset
argument_list|)
condition|)
name|warning
argument_list|(
literal|"Wrong size gregset in core file."
argument_list|)
expr_stmt|;
else|else
block|{
name|memcpy
argument_list|(
operator|&
name|gregset
argument_list|,
name|core_reg_sect
argument_list|,
sizeof|sizeof
argument_list|(
name|gregset
argument_list|)
argument_list|)
expr_stmt|;
name|supply_gregset
argument_list|(
operator|&
name|gregset
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|core_reg_size
operator|!=
sizeof|sizeof
argument_list|(
name|fpregset
argument_list|)
condition|)
name|warning
argument_list|(
literal|"Wrong size fpregset in core file."
argument_list|)
expr_stmt|;
else|else
block|{
name|memcpy
argument_list|(
operator|&
name|fpregset
argument_list|,
name|core_reg_sect
argument_list|,
sizeof|sizeof
argument_list|(
name|fpregset
argument_list|)
argument_list|)
expr_stmt|;
name|supply_fpregset
argument_list|(
operator|&
name|fpregset
argument_list|)
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|HAVE_PTRACE_GETFPXREGS
block|{
name|elf_fpxregset_t
name|fpxregset
decl_stmt|;
case|case
literal|3
case|:
if|if
condition|(
name|core_reg_size
operator|!=
sizeof|sizeof
argument_list|(
name|fpxregset
argument_list|)
condition|)
name|warning
argument_list|(
literal|"Wrong size fpxregset in core file."
argument_list|)
expr_stmt|;
else|else
block|{
name|memcpy
argument_list|(
operator|&
name|fpxregset
argument_list|,
name|core_reg_sect
argument_list|,
sizeof|sizeof
argument_list|(
name|fpxregset
argument_list|)
argument_list|)
expr_stmt|;
name|supply_fpxregset
argument_list|(
operator|&
name|fpxregset
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
endif|#
directive|endif
default|default:
comment|/* We've covered all the kinds of registers we know about here,          so this must be something we wouldn't know what to do with          anyway.  Just ignore it.  */
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The instruction for a GNU/Linux system call is:        int $0x80    or 0xcd 0x80.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
name|linux_syscall
index|[]
init|=
block|{
literal|0xcd
block|,
literal|0x80
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LINUX_SYSCALL_LEN
value|(sizeof linux_syscall)
end_define

begin_comment
comment|/* The system call number is stored in the %eax register.  */
end_comment

begin_define
define|#
directive|define
name|LINUX_SYSCALL_REGNUM
value|0
end_define

begin_comment
comment|/* %eax */
end_comment

begin_comment
comment|/* We are specifically interested in the sigreturn and rt_sigreturn    system calls.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SYS_sigreturn
end_ifndef

begin_define
define|#
directive|define
name|SYS_sigreturn
value|0x77
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SYS_rt_sigreturn
end_ifndef

begin_define
define|#
directive|define
name|SYS_rt_sigreturn
value|0xad
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Offset to saved processor flags, from<asm/sigcontext.h>.  */
end_comment

begin_define
define|#
directive|define
name|LINUX_SIGCONTEXT_EFLAGS_OFFSET
value|(64)
end_define

begin_comment
comment|/* Resume execution of the inferior process.    If STEP is nonzero, single-step it.    If SIGNAL is nonzero, give it that signal.  */
end_comment

begin_function
name|void
name|child_resume
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|step
parameter_list|,
name|enum
name|target_signal
name|signal
parameter_list|)
block|{
name|int
name|pid
init|=
name|PIDGET
argument_list|(
name|ptid
argument_list|)
decl_stmt|;
name|int
name|request
init|=
name|PTRACE_CONT
decl_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
comment|/* Resume all threads.  */
comment|/* I think this only gets used in the non-threaded case, where "resume        all threads" and "resume inferior_ptid" are the same.  */
name|pid
operator|=
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
if|if
condition|(
name|step
condition|)
block|{
name|CORE_ADDR
name|pc
init|=
name|read_pc_pid
argument_list|(
name|pid_to_ptid
argument_list|(
name|pid
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
name|LINUX_SYSCALL_LEN
index|]
decl_stmt|;
name|request
operator|=
name|PTRACE_SINGLESTEP
expr_stmt|;
comment|/* Returning from a signal trampoline is done by calling a          special system call (sigreturn or rt_sigreturn, see          i386-linux-tdep.c for more information).  This system call          restores the registers that were saved when the signal was          raised, including %eflags.  That means that single-stepping          won't work.  Instead, we'll have to modify the signal context          that's about to be restored, and set the trace flag there.  */
comment|/* First check if PC is at a system call.  */
if|if
condition|(
name|read_memory_nobpt
argument_list|(
name|pc
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|LINUX_SYSCALL_LEN
argument_list|)
operator|==
literal|0
operator|&&
name|memcmp
argument_list|(
name|buf
argument_list|,
name|linux_syscall
argument_list|,
name|LINUX_SYSCALL_LEN
argument_list|)
operator|==
literal|0
condition|)
block|{
name|int
name|syscall
init|=
name|read_register_pid
argument_list|(
name|LINUX_SYSCALL_REGNUM
argument_list|,
name|pid_to_ptid
argument_list|(
name|pid
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Then check the system call number.  */
if|if
condition|(
name|syscall
operator|==
name|SYS_sigreturn
operator|||
name|syscall
operator|==
name|SYS_rt_sigreturn
condition|)
block|{
name|CORE_ADDR
name|sp
init|=
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|addr
init|=
name|sp
decl_stmt|;
name|unsigned
name|long
name|int
name|eflags
decl_stmt|;
if|if
condition|(
name|syscall
operator|==
name|SYS_rt_sigreturn
condition|)
name|addr
operator|=
name|read_memory_integer
argument_list|(
name|sp
operator|+
literal|8
argument_list|,
literal|4
argument_list|)
operator|+
literal|20
expr_stmt|;
comment|/* Set the trace flag in the context that's about to be                  restored.  */
name|addr
operator|+=
name|LINUX_SIGCONTEXT_EFLAGS_OFFSET
expr_stmt|;
name|read_memory
argument_list|(
name|addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|eflags
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|eflags
operator||=
literal|0x0100
expr_stmt|;
name|write_memory
argument_list|(
name|addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|eflags
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|ptrace
argument_list|(
name|request
argument_list|,
name|pid
argument_list|,
literal|0
argument_list|,
name|target_signal_to_host
argument_list|(
name|signal
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|perror_with_name
argument_list|(
literal|"ptrace"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Register that we are able to handle GNU/Linux ELF core file    formats.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|core_fns
name|linux_elf_core_fns
init|=
block|{
name|bfd_target_elf_flavour
block|,
comment|/* core_flavour */
name|default_check_format
block|,
comment|/* check_format */
name|default_core_sniffer
block|,
comment|/* core_sniffer */
name|fetch_core_registers
block|,
comment|/* core_read_registers */
name|NULL
comment|/* next */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_i386_linux_nat
parameter_list|(
name|void
parameter_list|)
block|{
name|add_core_fns
argument_list|(
operator|&
name|linux_elf_core_fns
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

