begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generic support for remote debugging interfaces.     Copyright 1993, 1994, 1998 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/*  This file actually contains two distinct logical "packages".  They     are packaged together in this one file because they are typically     used together.      The first package is an addition to the serial package.  The     addition provides reading and writing with debugging output and     timeouts based on user settable variables.  These routines are     intended to support serial port based remote backends.  These     functions are prefixed with sr_.      The second package is a collection of more or less generic     functions for use by remote backends.  They support user settable     variables for debugging, retries, and the like.       Todo:     * a pass through mode a la kermit or telnet.    * autobaud.    * ask remote to change his baud rate.    */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_comment
comment|/* for exec_bfd */
end_comment

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_comment
comment|/* for generic_mourn_inferior */
end_comment

begin_include
include|#
directive|include
file|"remote-utils.h"
end_include

begin_decl_stmt
name|void
name|_initialize_sr_support
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|_sr_settings
name|sr_settings
init|=
block|{
literal|4
block|,
comment|/* timeout: 	remote-hms.c had 2 	remote-bug.c had "with a timeout of 2, we time out waiting for 	the prompt after an s-record dump."  	remote.c had (2): This was 5 seconds, which is a long time to 	sit and wait. Unless this is going though some terminal server 	or multiplexer or other form of hairy serial connection, I 	would think 2 seconds would be plenty. */
literal|10
block|,
comment|/* retries */
name|NULL
block|,
comment|/* device */
name|NULL
block|,
comment|/* descriptor */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|gr_settings
modifier|*
name|gr_settings
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|usage
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sr_com
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|proto
parameter_list|,
name|junk
parameter_list|)
name|char
modifier|*
name|proto
decl_stmt|;
name|char
modifier|*
name|junk
decl_stmt|;
block|{
if|if
condition|(
name|junk
operator|!=
name|NULL
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Unrecognized arguments: `%s'.\n"
argument_list|,
name|junk
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Usage: target %s [DEVICE [SPEED [DEBUG]]]\n\ where DEVICE is the name of a device or HOST:PORT"
argument_list|,
name|proto
argument_list|,
name|proto
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_define
define|#
directive|define
name|CHECKDONE
parameter_list|(
name|p
parameter_list|,
name|q
parameter_list|)
define|\
value|{ \   if (q == p) \     { \       if (*p == '\0') \ 	return; \       else \ 	usage(proto, p); \     } \ }
end_define

begin_function
name|void
name|sr_scan_args
parameter_list|(
name|proto
parameter_list|,
name|args
parameter_list|)
name|char
modifier|*
name|proto
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
comment|/* if no args, then nothing to do. */
if|if
condition|(
name|args
operator|==
name|NULL
operator|||
operator|*
name|args
operator|==
literal|'\0'
condition|)
return|return;
comment|/* scan off white space.  */
for|for
control|(
name|p
operator|=
name|args
init|;
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
operator|++
name|p
control|)
empty_stmt|;
empty_stmt|;
comment|/* find end of device name.  */
for|for
control|(
name|q
operator|=
name|p
init|;
operator|*
name|q
operator|!=
literal|'\0'
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|q
argument_list|)
condition|;
operator|++
name|q
control|)
empty_stmt|;
empty_stmt|;
comment|/* check for missing or empty device name.  */
name|CHECKDONE
argument_list|(
name|p
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|sr_set_device
argument_list|(
name|savestring
argument_list|(
name|p
argument_list|,
name|q
operator|-
name|p
argument_list|)
argument_list|)
expr_stmt|;
comment|/* look for baud rate.  */
name|n
operator|=
name|strtol
argument_list|(
name|q
argument_list|,
operator|&
name|p
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* check for missing or empty baud rate.  */
name|CHECKDONE
argument_list|(
name|p
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|baud_rate
operator|=
name|n
expr_stmt|;
comment|/* look for debug value.  */
name|n
operator|=
name|strtol
argument_list|(
name|p
argument_list|,
operator|&
name|q
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* check for missing or empty debug value.  */
name|CHECKDONE
argument_list|(
name|p
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|sr_set_debug
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* scan off remaining white space.  */
for|for
control|(
name|p
operator|=
name|q
init|;
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|;
operator|++
name|p
control|)
empty_stmt|;
empty_stmt|;
comment|/* if not end of string, then there's unrecognized junk. */
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
name|usage
argument_list|(
name|proto
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|gr_generic_checkin
parameter_list|()
block|{
name|sr_write_cr
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|gr_expect_prompt
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gr_open
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|,
name|gr
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|struct
name|gr_settings
modifier|*
name|gr
decl_stmt|;
block|{
name|target_preopen
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
name|sr_scan_args
argument_list|(
name|gr
operator|->
name|ops
operator|->
name|to_shortname
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|unpush_target
argument_list|(
name|gr
operator|->
name|ops
argument_list|)
expr_stmt|;
name|gr_settings
operator|=
name|gr
expr_stmt|;
name|gr_set_dcache
argument_list|(
name|dcache_init
argument_list|(
name|gr
operator|->
name|readfunc
argument_list|,
name|gr
operator|->
name|writefunc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr_get_desc
argument_list|()
operator|!=
name|NULL
condition|)
name|gr_close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* If no args are specified, then we use the device specified by a      previous command or "set remotedevice".  But if there is no      device, better stop now, not dump core.  */
if|if
condition|(
name|sr_get_device
argument_list|()
operator|==
name|NULL
condition|)
name|usage
argument_list|(
name|gr
operator|->
name|ops
operator|->
name|to_shortname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sr_set_desc
argument_list|(
name|SERIAL_OPEN
argument_list|(
name|sr_get_device
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sr_get_desc
argument_list|()
condition|)
name|perror_with_name
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sr_get_device
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|baud_rate
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|SERIAL_SETBAUDRATE
argument_list|(
name|sr_get_desc
argument_list|()
argument_list|,
name|baud_rate
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|SERIAL_CLOSE
argument_list|(
name|sr_get_desc
argument_list|()
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|sr_get_device
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|SERIAL_RAW
argument_list|(
name|sr_get_desc
argument_list|()
argument_list|)
expr_stmt|;
comment|/* If there is something sitting in the buffer we might take it as a      response to a command, which would be bad.  */
name|SERIAL_FLUSH_INPUT
argument_list|(
name|sr_get_desc
argument_list|()
argument_list|)
expr_stmt|;
comment|/* default retries */
if|if
condition|(
name|sr_get_retries
argument_list|()
operator|==
literal|0
condition|)
name|sr_set_retries
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* default clear breakpoint function */
if|if
condition|(
name|gr_settings
operator|->
name|clear_all_breakpoints
operator|==
name|NULL
condition|)
name|gr_settings
operator|->
name|clear_all_breakpoints
operator|=
name|remove_breakpoints
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Remote debugging using `%s'"
argument_list|,
name|sr_get_device
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|baud_rate
operator|!=
operator|-
literal|1
condition|)
name|printf_filtered
argument_list|(
literal|" at baud rate of %d"
argument_list|,
name|baud_rate
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|push_target
argument_list|(
name|gr
operator|->
name|ops
argument_list|)
expr_stmt|;
name|gr_checkin
argument_list|()
expr_stmt|;
name|gr_clear_all_breakpoints
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Read a character from the remote system masking it down to 7 bits    and doing all the fancy timeout stuff.  */
end_comment

begin_function
name|int
name|sr_readchar
parameter_list|()
block|{
name|int
name|buf
decl_stmt|;
name|buf
operator|=
name|SERIAL_READCHAR
argument_list|(
name|sr_get_desc
argument_list|()
argument_list|,
name|sr_get_timeout
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|SERIAL_TIMEOUT
condition|)
name|error
argument_list|(
literal|"Timeout reading from remote system."
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
operator|>
literal|0
condition|)
name|printf_unfiltered
argument_list|(
literal|"%c"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
name|buf
operator|&
literal|0x7f
return|;
block|}
end_function

begin_function
name|int
name|sr_pollchar
parameter_list|()
block|{
name|int
name|buf
decl_stmt|;
name|buf
operator|=
name|SERIAL_READCHAR
argument_list|(
name|sr_get_desc
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|SERIAL_TIMEOUT
condition|)
name|buf
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|buf
condition|)
name|printf_unfiltered
argument_list|(
literal|"%c"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
else|else
name|printf_unfiltered
argument_list|(
literal|"<empty character poll>"
argument_list|)
expr_stmt|;
block|}
return|return
name|buf
operator|&
literal|0x7f
return|;
block|}
end_function

begin_comment
comment|/* Keep discarding input from the remote system, until STRING is found.    Let the user break out immediately.  */
end_comment

begin_function
name|void
name|sr_expect
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|char
modifier|*
name|p
init|=
name|string
decl_stmt|;
name|immediate_quit
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|sr_readchar
argument_list|()
operator|==
operator|*
name|p
condition|)
block|{
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|immediate_quit
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
else|else
name|p
operator|=
name|string
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sr_write
parameter_list|(
name|a
parameter_list|,
name|l
parameter_list|)
name|char
modifier|*
name|a
decl_stmt|;
name|int
name|l
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|SERIAL_WRITE
argument_list|(
name|sr_get_desc
argument_list|()
argument_list|,
name|a
argument_list|,
name|l
argument_list|)
operator|!=
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"sr_write: Error writing to remote"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
operator|>
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
name|printf_unfiltered
argument_list|(
literal|"%c"
argument_list|,
name|a
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|sr_write_cr
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|sr_write
argument_list|(
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
name|sr_write
argument_list|(
literal|"\r"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|sr_timed_read
parameter_list|(
name|buf
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
name|c
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|n
condition|)
block|{
name|c
operator|=
name|sr_readchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
name|i
return|;
name|buf
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* Get a hex digit from the remote system& return its value. If    ignore_space is nonzero, ignore spaces (not newline, tab, etc).  */
end_comment

begin_function
name|int
name|sr_get_hex_digit
parameter_list|(
name|ignore_space
parameter_list|)
name|int
name|ignore_space
decl_stmt|;
block|{
name|int
name|ch
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|ch
operator|=
name|sr_readchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
return|return
name|ch
operator|-
literal|'0'
return|;
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|'A'
operator|&&
name|ch
operator|<=
literal|'F'
condition|)
return|return
name|ch
operator|-
literal|'A'
operator|+
literal|10
return|;
elseif|else
if|if
condition|(
name|ch
operator|>=
literal|'a'
operator|&&
name|ch
operator|<=
literal|'f'
condition|)
return|return
name|ch
operator|-
literal|'a'
operator|+
literal|10
return|;
elseif|else
if|if
condition|(
name|ch
operator|!=
literal|' '
operator|||
operator|!
name|ignore_space
condition|)
block|{
name|gr_expect_prompt
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"Invalid hex digit from remote system."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Get a byte from the remote and put it in *BYT.  Accept any number    leading spaces.  */
end_comment

begin_function
name|void
name|sr_get_hex_byte
parameter_list|(
name|byt
parameter_list|)
name|char
modifier|*
name|byt
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
name|val
operator|=
name|sr_get_hex_digit
argument_list|(
literal|1
argument_list|)
operator|<<
literal|4
expr_stmt|;
name|val
operator||=
name|sr_get_hex_digit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|*
name|byt
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read a 32-bit hex word from the remote, preceded by a space  */
end_comment

begin_function
name|long
name|sr_get_hex_word
parameter_list|()
block|{
name|long
name|val
decl_stmt|;
name|int
name|j
decl_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
name|val
operator|=
operator|(
name|val
operator|<<
literal|4
operator|)
operator|+
name|sr_get_hex_digit
argument_list|(
name|j
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_comment
comment|/* Put a command string, in args, out to the remote.  The remote is assumed to    be in raw mode, all writing/reading done through desc.    Ouput from the remote is placed on the users terminal until the    prompt from the remote is seen.    FIXME: Can't handle commands that take input.  */
end_comment

begin_function
specifier|static
name|void
name|sr_com
parameter_list|(
name|args
parameter_list|,
name|fromtty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|fromtty
decl_stmt|;
block|{
name|sr_check_open
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
return|return;
comment|/* Clear all input so only command relative output is displayed */
name|sr_write_cr
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|sr_write
argument_list|(
literal|"\030"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|registers_changed
argument_list|()
expr_stmt|;
name|gr_expect_prompt
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gr_close
parameter_list|(
name|quitting
parameter_list|)
name|int
name|quitting
decl_stmt|;
block|{
name|gr_clear_all_breakpoints
argument_list|()
expr_stmt|;
if|if
condition|(
name|sr_is_open
argument_list|()
condition|)
block|{
name|SERIAL_CLOSE
argument_list|(
name|sr_get_desc
argument_list|()
argument_list|)
expr_stmt|;
name|sr_set_desc
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* gr_detach()    takes a program previously attached to and detaches it.    We better not have left any breakpoints    in the program or it'll die when it hits one.    Close the open connection to the remote debugger.    Use this when you want to detach and do something else    with your gdb.  */
end_comment

begin_function
name|void
name|gr_detach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|args
condition|)
name|error
argument_list|(
literal|"Argument given to \"detach\" when remotely debugging."
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr_is_open
argument_list|()
condition|)
name|gr_clear_all_breakpoints
argument_list|()
expr_stmt|;
name|pop_target
argument_list|()
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|puts_filtered
argument_list|(
literal|"Ending remote debugging.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|gr_files_info
parameter_list|(
name|ops
parameter_list|)
name|struct
name|target_ops
modifier|*
name|ops
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|__GO32__
name|printf_filtered
argument_list|(
literal|"\tAttached to DOS asynctsr\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf_filtered
argument_list|(
literal|"\tAttached to %s"
argument_list|,
name|sr_get_device
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|baud_rate
operator|!=
operator|-
literal|1
condition|)
name|printf_filtered
argument_list|(
literal|"at %d baud"
argument_list|,
name|baud_rate
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|exec_bfd
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\tand running program %s\n"
argument_list|,
name|bfd_get_filename
argument_list|(
name|exec_bfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"\tusing the %s protocol.\n"
argument_list|,
name|ops
operator|->
name|to_shortname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gr_mourn
parameter_list|()
block|{
name|gr_clear_all_breakpoints
argument_list|()
expr_stmt|;
name|unpush_target
argument_list|(
name|gr_get_ops
argument_list|()
argument_list|)
expr_stmt|;
name|generic_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|gr_kill
parameter_list|()
block|{
return|return;
block|}
end_function

begin_comment
comment|/* This is called not only when we first attach, but also when the    user types "run" after having attached.  */
end_comment

begin_function
name|void
name|gr_create_inferior
parameter_list|(
name|execfile
parameter_list|,
name|args
parameter_list|,
name|env
parameter_list|)
name|char
modifier|*
name|execfile
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
name|char
modifier|*
modifier|*
name|env
decl_stmt|;
block|{
name|int
name|entry_pt
decl_stmt|;
if|if
condition|(
name|args
operator|&&
operator|*
name|args
condition|)
name|error
argument_list|(
literal|"Can't pass arguments to remote process."
argument_list|)
expr_stmt|;
if|if
condition|(
name|execfile
operator|==
literal|0
operator|||
name|exec_bfd
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No executable file specified"
argument_list|)
expr_stmt|;
name|entry_pt
operator|=
operator|(
name|int
operator|)
name|bfd_get_start_address
argument_list|(
name|exec_bfd
argument_list|)
expr_stmt|;
name|sr_check_open
argument_list|()
expr_stmt|;
name|gr_kill
argument_list|()
expr_stmt|;
name|gr_clear_all_breakpoints
argument_list|()
expr_stmt|;
name|init_wait_for_inferior
argument_list|()
expr_stmt|;
name|gr_checkin
argument_list|()
expr_stmt|;
name|insert_breakpoints
argument_list|()
expr_stmt|;
comment|/* Needed to get correct instruction in cache */
name|proceed
argument_list|(
name|entry_pt
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a null terminated list of strings LIST, read the input until we find one of    them.  Return the index of the string found or -1 on error.  '?' means match    any single character. Note that with the algorithm we use, the initial    character of the string cannot recur in the string, or we will not find some    cases of the string in the input.  If PASSTHROUGH is non-zero, then    pass non-matching data on.  */
end_comment

begin_function
name|int
name|gr_multi_scan
parameter_list|(
name|list
parameter_list|,
name|passthrough
parameter_list|)
name|char
modifier|*
name|list
index|[]
decl_stmt|;
name|int
name|passthrough
decl_stmt|;
block|{
name|char
modifier|*
name|swallowed
init|=
name|NULL
decl_stmt|;
comment|/* holding area */
name|char
modifier|*
name|swallowed_p
init|=
name|swallowed
decl_stmt|;
comment|/* Current position in swallowed.  */
name|int
name|ch
decl_stmt|;
name|int
name|ch_handled
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|string_count
decl_stmt|;
name|int
name|max_length
decl_stmt|;
name|char
modifier|*
modifier|*
name|plist
decl_stmt|;
comment|/* Look through the strings.  Count them.  Find the largest one so we can      allocate a holding area.  */
for|for
control|(
name|max_length
operator|=
name|string_count
operator|=
name|i
operator|=
literal|0
init|;
name|list
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
operator|++
name|i
operator|,
operator|++
name|string_count
control|)
block|{
name|int
name|length
init|=
name|strlen
argument_list|(
name|list
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|length
operator|>
name|max_length
condition|)
name|max_length
operator|=
name|length
expr_stmt|;
block|}
comment|/* if we have no strings, then something is wrong. */
if|if
condition|(
name|string_count
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* otherwise, we will need a holding area big enough to hold almost two      copies of our largest string.  */
name|swallowed_p
operator|=
name|swallowed
operator|=
name|alloca
argument_list|(
name|max_length
operator|<<
literal|1
argument_list|)
expr_stmt|;
comment|/* and a list of pointers to current scan points. */
name|plist
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|string_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|plist
argument_list|)
argument_list|)
expr_stmt|;
comment|/* and initialize */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|string_count
condition|;
operator|++
name|i
control|)
name|plist
index|[
name|i
index|]
operator|=
name|list
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|ch
operator|=
name|sr_readchar
argument_list|()
init|;
comment|/* loop forever */
condition|;
name|ch
operator|=
name|sr_readchar
argument_list|()
control|)
block|{
name|QUIT
expr_stmt|;
comment|/* Let user quit and leave process running */
name|ch_handled
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|string_count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|ch
operator|==
operator|*
name|plist
index|[
name|i
index|]
operator|||
operator|*
name|plist
index|[
name|i
index|]
operator|==
literal|'?'
condition|)
block|{
operator|++
name|plist
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|plist
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|i
operator|)
return|;
if|if
condition|(
operator|!
name|ch_handled
condition|)
operator|*
name|swallowed_p
operator|++
operator|=
name|ch
expr_stmt|;
name|ch_handled
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|plist
index|[
name|i
index|]
operator|=
name|list
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ch_handled
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Print out any characters which have been swallowed.  */
if|if
condition|(
name|passthrough
condition|)
block|{
for|for
control|(
name|p
operator|=
name|swallowed
init|;
name|p
operator|<
name|swallowed_p
condition|;
operator|++
name|p
control|)
name|fputc_unfiltered
argument_list|(
operator|*
name|p
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|fputc_unfiltered
argument_list|(
name|ch
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|swallowed_p
operator|=
name|swallowed
expr_stmt|;
block|}
block|}
if|#
directive|if
literal|0
comment|/* Never reached.  */
block|return(-1);
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Get ready to modify the registers array.  On machines which store    individual registers, this doesn't need to do anything.  On machines    which store all the registers in one fell swoop, this makes sure    that registers contains all the registers from the program being    debugged.  */
end_comment

begin_function
name|void
name|gr_prepare_to_store
parameter_list|()
block|{
comment|/* Do nothing, since we assume we can store individual regs */
block|}
end_function

begin_comment
comment|/* Read a word from remote address ADDR and return it.  * This goes through the data cache.  */
end_comment

begin_function
name|int
name|gr_fetch_word
parameter_list|(
name|addr
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
block|{
return|return
name|dcache_fetch
argument_list|(
name|gr_get_dcache
argument_list|()
argument_list|,
name|addr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Write a word WORD into remote address ADDR.    This goes through the data cache.  */
end_comment

begin_function
name|void
name|gr_store_word
parameter_list|(
name|addr
parameter_list|,
name|word
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|word
decl_stmt|;
block|{
name|dcache_poke
argument_list|(
name|gr_get_dcache
argument_list|()
argument_list|,
name|addr
argument_list|,
name|word
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_sr_support
parameter_list|()
block|{
comment|/* FIXME-now: if target is open... */
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"remotedevice"
argument_list|,
name|no_class
argument_list|,
name|var_filename
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sr_settings
operator|.
name|device
argument_list|,
literal|"Set device for remote serial I/O.\n\ This device is used as the serial port when debugging using remote\n\ targets."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"remote<command>"
argument_list|,
name|class_obscure
argument_list|,
name|sr_com
argument_list|,
literal|"Send a command to the remote monitor."
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

