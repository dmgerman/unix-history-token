begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Core dump and executable file functions above target vector, for GDB.     Copyright 1986, 1987, 1989, 1991, 1992, 1993, 1994, 1996, 1997,    1998, 1999, 2000, 2001, 2003 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_include
include|#
directive|include
file|"completer.h"
end_include

begin_comment
comment|/* Local function declarations.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|_initialize_core
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|call_extra_exec_file_hooks
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* You can have any number of hooks for `exec_file_command' command to call.    If there's only one hook, it is set in exec_file_display hook.    If there are two or more hooks, they are set in exec_file_extra_hooks[],    and exec_file_display_hook is set to a function that calls all of them.    This extra complexity is needed to preserve compatibility with    old code that assumed that only one hook could be set, and which called    exec_file_display_hook directly.  */
end_comment

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|hook_type
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_decl_stmt
name|hook_type
name|exec_file_display_hook
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the original hook */
end_comment

begin_decl_stmt
specifier|static
name|hook_type
modifier|*
name|exec_file_extra_hooks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* array of additional hooks */
end_comment

begin_decl_stmt
specifier|static
name|int
name|exec_file_hook_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of array */
end_comment

begin_comment
comment|/* Binary file diddling handle for the core file.  */
end_comment

begin_decl_stmt
name|bfd
modifier|*
name|core_bfd
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Backward compatability with old way of specifying core files.  */
end_comment

begin_function
name|void
name|core_file_command
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|target_ops
modifier|*
name|t
decl_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
comment|/* Either way, seems bogus. */
name|t
operator|=
name|find_core_target
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"GDB can't read core files on this machine."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|filename
condition|)
call|(
name|t
operator|->
name|to_detach
call|)
argument_list|(
name|filename
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
else|else
call|(
name|t
operator|->
name|to_open
call|)
argument_list|(
name|filename
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If there are two or more functions that wish to hook into exec_file_command,  * this function will call all of the hook functions. */
end_comment

begin_function
specifier|static
name|void
name|call_extra_exec_file_hooks
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|exec_file_hook_count
condition|;
name|i
operator|++
control|)
call|(
modifier|*
name|exec_file_extra_hooks
index|[
name|i
index|]
call|)
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call this to specify the hook for exec_file_command to call back.    This is called from the x-window display code.  */
end_comment

begin_function
name|void
name|specify_exec_file_hook
parameter_list|(
name|void
function_decl|(
modifier|*
name|hook
function_decl|)
parameter_list|(
name|char
modifier|*
parameter_list|)
parameter_list|)
block|{
name|hook_type
modifier|*
name|new_array
decl_stmt|;
if|if
condition|(
name|exec_file_display_hook
operator|!=
name|NULL
condition|)
block|{
comment|/* There's already a hook installed.  Arrange to have both it        * and the subsequent hooks called. */
if|if
condition|(
name|exec_file_hook_count
operator|==
literal|0
condition|)
block|{
comment|/* If this is the first extra hook, initialize the hook array. */
name|exec_file_extra_hooks
operator|=
operator|(
name|hook_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|hook_type
argument_list|)
argument_list|)
expr_stmt|;
name|exec_file_extra_hooks
index|[
literal|0
index|]
operator|=
name|exec_file_display_hook
expr_stmt|;
name|exec_file_display_hook
operator|=
name|call_extra_exec_file_hooks
expr_stmt|;
name|exec_file_hook_count
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Grow the hook array by one and add the new hook to the end.          Yes, it's inefficient to grow it by one each time but since          this is hardly ever called it's not a big deal.  */
name|exec_file_hook_count
operator|++
expr_stmt|;
name|new_array
operator|=
operator|(
name|hook_type
operator|*
operator|)
name|xrealloc
argument_list|(
name|exec_file_extra_hooks
argument_list|,
name|exec_file_hook_count
operator|*
sizeof|sizeof
argument_list|(
name|hook_type
argument_list|)
argument_list|)
expr_stmt|;
name|exec_file_extra_hooks
operator|=
name|new_array
expr_stmt|;
name|exec_file_extra_hooks
index|[
name|exec_file_hook_count
operator|-
literal|1
index|]
operator|=
name|hook
expr_stmt|;
block|}
else|else
name|exec_file_display_hook
operator|=
name|hook
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The exec file must be closed before running an inferior.    If it is needed again after the inferior dies, it must    be reopened.  */
end_comment

begin_function
name|void
name|close_exec_file
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
literal|0
comment|/* FIXME */
block|if (exec_bfd)     bfd_tempclose (exec_bfd);
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|reopen_exec_file
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
literal|0
comment|/* FIXME */
block|if (exec_bfd)     bfd_reopen (exec_bfd);
else|#
directive|else
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|res
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|long
name|mtime
decl_stmt|;
comment|/* Don't do anything if the current target isn't exec. */
if|if
condition|(
name|exec_bfd
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|target_shortname
argument_list|,
literal|"exec"
argument_list|)
operator|!=
literal|0
condition|)
return|return;
comment|/* If the timestamp of the exec file has changed, reopen it. */
name|filename
operator|=
name|xstrdup
argument_list|(
name|bfd_get_filename
argument_list|(
name|exec_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|mtime
operator|=
name|bfd_get_mtime
argument_list|(
name|exec_bfd
argument_list|)
expr_stmt|;
name|res
operator|=
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtime
operator|&&
name|mtime
operator|!=
name|st
operator|.
name|st_mtime
condition|)
block|{
name|exec_open
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If we have both a core file and an exec file,    print a warning if they don't go together.  */
end_comment

begin_function
name|void
name|validate_files
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|exec_bfd
operator|&&
name|core_bfd
condition|)
block|{
if|if
condition|(
operator|!
name|core_file_matches_executable_p
argument_list|(
name|core_bfd
argument_list|,
name|exec_bfd
argument_list|)
condition|)
name|warning
argument_list|(
literal|"core file may not match specified executable file."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_get_mtime
argument_list|(
name|exec_bfd
argument_list|)
operator|>
name|bfd_get_mtime
argument_list|(
name|core_bfd
argument_list|)
condition|)
name|warning
argument_list|(
literal|"exec file is newer than core file."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the name of the executable file as a string.    ERR nonzero means get error if there is none specified;    otherwise return 0 in that case.  */
end_comment

begin_function
name|char
modifier|*
name|get_exec_file
parameter_list|(
name|int
name|err
parameter_list|)
block|{
if|if
condition|(
name|exec_bfd
condition|)
return|return
name|bfd_get_filename
argument_list|(
name|exec_bfd
argument_list|)
return|;
if|if
condition|(
operator|!
name|err
condition|)
return|return
name|NULL
return|;
name|error
argument_list|(
literal|"No executable file specified.\n\ Use the \"file\" or \"exec-file\" command."
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Report a memory error with error().  */
end_comment

begin_function
name|void
name|memory_error
parameter_list|(
name|int
name|status
parameter_list|,
name|CORE_ADDR
name|memaddr
parameter_list|)
block|{
name|struct
name|ui_file
modifier|*
name|tmp_stream
init|=
name|mem_fileopen
argument_list|()
decl_stmt|;
name|make_cleanup_ui_file_delete
argument_list|(
name|tmp_stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|EIO
condition|)
block|{
comment|/* Actually, address between memaddr and memaddr + len          was out of bounds. */
name|fprintf_unfiltered
argument_list|(
name|tmp_stream
argument_list|,
literal|"Cannot access memory at address "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|memaddr
argument_list|,
literal|1
argument_list|,
name|tmp_stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|tmp_stream
argument_list|,
literal|"Error accessing memory address "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|memaddr
argument_list|,
literal|1
argument_list|,
name|tmp_stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|tmp_stream
argument_list|,
literal|": %s."
argument_list|,
name|safe_strerror
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|error_stream
argument_list|(
name|tmp_stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Same as target_read_memory, but report an error if can't read.  */
end_comment

begin_function
name|void
name|read_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|status
operator|=
name|target_read_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|memory_error
argument_list|(
name|status
argument_list|,
name|memaddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Argument / return result struct for use with    do_captured_read_memory_integer().  MEMADDR and LEN are filled in    by gdb_read_memory_integer().  RESULT is the contents that were    successfully read from MEMADDR of length LEN.  */
end_comment

begin_struct
struct|struct
name|captured_read_memory_integer_arguments
block|{
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|LONGEST
name|result
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Helper function for gdb_read_memory_integer().  DATA must be a    pointer to a captured_read_memory_integer_arguments struct.     Return 1 if successful.  Note that the catch_errors() interface    will return 0 if an error occurred while reading memory.  This    choice of return code is so that we can distinguish between    success and failure.  */
end_comment

begin_function
specifier|static
name|int
name|do_captured_read_memory_integer
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|captured_read_memory_integer_arguments
modifier|*
name|args
init|=
operator|(
expr|struct
name|captured_read_memory_integer_arguments
operator|*
operator|)
name|data
decl_stmt|;
name|CORE_ADDR
name|memaddr
init|=
name|args
operator|->
name|memaddr
decl_stmt|;
name|int
name|len
init|=
name|args
operator|->
name|len
decl_stmt|;
name|args
operator|->
name|result
operator|=
name|read_memory_integer
argument_list|(
name|memaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Read memory at MEMADDR of length LEN and put the contents in    RETURN_VALUE.  Return 0 if MEMADDR couldn't be read and non-zero    if successful.  */
end_comment

begin_function
name|int
name|safe_read_memory_integer
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|int
name|len
parameter_list|,
name|LONGEST
modifier|*
name|return_value
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|struct
name|captured_read_memory_integer_arguments
name|args
decl_stmt|;
name|args
operator|.
name|memaddr
operator|=
name|memaddr
expr_stmt|;
name|args
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|status
operator|=
name|catch_errors
argument_list|(
name|do_captured_read_memory_integer
argument_list|,
operator|&
name|args
argument_list|,
literal|""
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
operator|*
name|return_value
operator|=
name|args
operator|.
name|result
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
name|LONGEST
name|read_memory_integer
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
index|]
decl_stmt|;
name|read_memory
argument_list|(
name|memaddr
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|extract_signed_integer
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
name|ULONGEST
name|read_memory_unsigned_integer
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
name|ULONGEST
argument_list|)
index|]
decl_stmt|;
name|read_memory
argument_list|(
name|memaddr
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|read_memory_string
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|max_len
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|cp
operator|=
name|buffer
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|cp
operator|-
name|buffer
operator|>=
name|max_len
condition|)
block|{
name|buffer
index|[
name|max_len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
name|cnt
operator|=
name|max_len
operator|-
operator|(
name|cp
operator|-
name|buffer
operator|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|>
literal|8
condition|)
name|cnt
operator|=
literal|8
expr_stmt|;
name|read_memory
argument_list|(
name|memaddr
operator|+
call|(
name|int
call|)
argument_list|(
name|cp
operator|-
name|buffer
argument_list|)
argument_list|,
name|cp
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
operator|&&
operator|*
name|cp
condition|;
name|i
operator|++
operator|,
name|cp
operator|++
control|)
empty_stmt|;
comment|/* null body */
if|if
condition|(
name|i
operator|<
name|cnt
operator|&&
operator|!
operator|*
name|cp
condition|)
break|break;
block|}
block|}
end_function

begin_function
name|CORE_ADDR
name|read_memory_typed_address
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|read_memory
argument_list|(
name|addr
argument_list|,
name|buf
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|extract_typed_address
argument_list|(
name|buf
argument_list|,
name|type
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Same as target_write_memory, but report an error if can't write.  */
end_comment

begin_function
name|void
name|write_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|status
operator|=
name|target_write_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|memory_error
argument_list|(
name|status
argument_list|,
name|memaddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store VALUE at ADDR in the inferior as a LEN-byte unsigned integer.  */
end_comment

begin_function
name|void
name|write_memory_unsigned_integer
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|int
name|len
parameter_list|,
name|ULONGEST
name|value
parameter_list|)
block|{
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|store_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|addr
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store VALUE at ADDR in the inferior as a LEN-byte signed integer.  */
end_comment

begin_function
name|void
name|write_memory_signed_integer
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|int
name|len
parameter_list|,
name|LONGEST
name|value
parameter_list|)
block|{
name|char
modifier|*
name|buf
init|=
name|alloca
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|store_signed_integer
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|write_memory
argument_list|(
name|addr
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Enable after 4.12.  It is not tested.  */
end_comment

begin_comment
comment|/* Search code.  Targets can just make this their search function, or    if the protocol has a less general search function, they can call this    in the cases it can't handle.  */
end_comment

begin_comment
unit|void generic_search (int len, char *data, char *mask, CORE_ADDR startaddr, 		int increment, CORE_ADDR lorange, CORE_ADDR hirange, 		CORE_ADDR *addr_found, char *data_found) {   int i;   CORE_ADDR curaddr = startaddr;    while (curaddr>= lorange&& curaddr< hirange)     {       read_memory (curaddr, data_found, len);       for (i = 0; i< len; ++i) 	if ((data_found[i]& mask[i]) != data[i]) 	  goto try_again;
comment|/* It matches.  */
end_comment

begin_endif
unit|*addr_found = curaddr;       return;      try_again:       curaddr += increment;     }   *addr_found = (CORE_ADDR) 0;   return; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_escape
end_escape

begin_comment
comment|/* The current default bfd target.  Points to storage allocated for    gnutarget_string.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|gnutarget
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Same thing, except it is "auto" not NULL for the default case.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|gnutarget_string
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|set_gnutarget_command
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|set_gnutarget_command
parameter_list|(
name|char
modifier|*
name|ignore
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|struct
name|cmd_list_element
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|gnutarget_string
argument_list|,
literal|"auto"
argument_list|)
operator|==
literal|0
condition|)
name|gnutarget
operator|=
name|NULL
expr_stmt|;
else|else
name|gnutarget
operator|=
name|gnutarget_string
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the gnutarget.  */
end_comment

begin_function
name|void
name|set_gnutarget
parameter_list|(
name|char
modifier|*
name|newtarget
parameter_list|)
block|{
if|if
condition|(
name|gnutarget_string
operator|!=
name|NULL
condition|)
name|xfree
argument_list|(
name|gnutarget_string
argument_list|)
expr_stmt|;
name|gnutarget_string
operator|=
name|savestring
argument_list|(
name|newtarget
argument_list|,
name|strlen
argument_list|(
name|newtarget
argument_list|)
argument_list|)
expr_stmt|;
name|set_gnutarget_command
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_core
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|c
operator|=
name|add_cmd
argument_list|(
literal|"core-file"
argument_list|,
name|class_files
argument_list|,
name|core_file_command
argument_list|,
literal|"Use FILE as core dump for examining memory and registers.\n\ No arg means have no core file.  This command has been superseded by the\n\ `target core' and `detach' commands."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|set_cmd_completer
argument_list|(
name|c
argument_list|,
name|filename_completer
argument_list|)
expr_stmt|;
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"gnutarget"
argument_list|,
name|class_files
argument_list|,
name|var_string_noescape
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|gnutarget_string
argument_list|,
literal|"Set the current BFD target.\n\ Use `set gnutarget auto' to specify automatic detection."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|set_cmd_sfunc
argument_list|(
name|c
argument_list|,
name|set_gnutarget_command
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|getenv
argument_list|(
literal|"GNUTARGET"
argument_list|)
condition|)
name|set_gnutarget
argument_list|(
name|getenv
argument_list|(
literal|"GNUTARGET"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|set_gnutarget
argument_list|(
literal|"auto"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

