begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Core dump and executable file functions above target vector, for GDB.    Copyright 1986, 1987, 1989, 1991, 1992, 1993, 1994    Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_comment
comment|/* required by inferior.h */
end_comment

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"dis-asm.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_decl_stmt
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local function declarations.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|call_extra_exec_file_hooks
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|filename
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* You can have any number of hooks for `exec_file_command' command to call.    If there's only one hook, it is set in exec_file_display hook.    If there are two or more hooks, they are set in exec_file_extra_hooks[],    and exec_file_display_hook is set to a function that calls all of them.    This extra complexity is needed to preserve compatibility with    old code that assumed that only one hook could be set, and which called    exec_file_display_hook directly.  */
end_comment

begin_typedef
typedef|typedef
name|void
argument_list|(
argument|*hook_type
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
end_typedef

begin_decl_stmt
name|hook_type
name|exec_file_display_hook
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the original hook */
end_comment

begin_decl_stmt
specifier|static
name|hook_type
modifier|*
name|exec_file_extra_hooks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* array of additional hooks */
end_comment

begin_decl_stmt
specifier|static
name|int
name|exec_file_hook_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of array */
end_comment

begin_comment
comment|/* Binary file diddling handle for the core file.  */
end_comment

begin_decl_stmt
name|bfd
modifier|*
name|core_bfd
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Backward compatability with old way of specifying core files.  */
end_comment

begin_function
name|void
name|core_file_command
parameter_list|(
name|filename
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|target_ops
modifier|*
name|t
decl_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
comment|/* Either way, seems bogus. */
name|t
operator|=
name|find_core_target
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|!
name|filename
condition|)
call|(
name|t
operator|->
name|to_detach
call|)
argument_list|(
name|filename
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Yes, we were given the path of a core file.  Do we already            have a symbol file?  If not, can we determine it from the            core file?  If we can, do so.            */
ifdef|#
directive|ifdef
name|HPUXHPPA
if|if
condition|(
name|symfile_objfile
operator|==
name|NULL
condition|)
block|{
name|char
modifier|*
name|symfile
decl_stmt|;
name|symfile
operator|=
name|t
operator|->
name|to_core_file_to_sym_file
argument_list|(
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|symfile
condition|)
block|{
name|char
modifier|*
name|symfile_copy
init|=
name|strdup
argument_list|(
name|symfile
argument_list|)
decl_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|symfile_copy
argument_list|)
expr_stmt|;
name|symbol_file_command
argument_list|(
name|symfile_copy
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
else|else
name|warning
argument_list|(
literal|"Unknown symbols for '%s'; use the 'symbol-file' command."
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
call|(
name|t
operator|->
name|to_open
call|)
argument_list|(
name|filename
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"GDB can't read core files on this machine."
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If there are two or more functions that wish to hook into exec_file_command,  * this function will call all of the hook functions. */
end_comment

begin_function
specifier|static
name|void
name|call_extra_exec_file_hooks
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|exec_file_hook_count
condition|;
name|i
operator|++
control|)
call|(
modifier|*
name|exec_file_extra_hooks
index|[
name|i
index|]
call|)
argument_list|(
name|filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Call this to specify the hook for exec_file_command to call back.    This is called from the x-window display code.  */
end_comment

begin_function_decl
name|void
name|specify_exec_file_hook
parameter_list|(
name|hook
parameter_list|)
function_decl|void
parameter_list|(
function_decl|*hook
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|hook_type
modifier|*
name|new_array
decl_stmt|;
if|if
condition|(
name|exec_file_display_hook
operator|!=
name|NULL
condition|)
block|{
comment|/* There's already a hook installed.  Arrange to have both it        * and the subsequent hooks called. */
if|if
condition|(
name|exec_file_hook_count
operator|==
literal|0
condition|)
block|{
comment|/* If this is the first extra hook, initialize the hook array. */
name|exec_file_extra_hooks
operator|=
operator|(
name|hook_type
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|hook_type
argument_list|)
argument_list|)
expr_stmt|;
name|exec_file_extra_hooks
index|[
literal|0
index|]
operator|=
name|exec_file_display_hook
expr_stmt|;
name|exec_file_display_hook
operator|=
name|call_extra_exec_file_hooks
expr_stmt|;
name|exec_file_hook_count
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Grow the hook array by one and add the new hook to the end.          Yes, it's inefficient to grow it by one each time but since          this is hardly ever called it's not a big deal.  */
name|exec_file_hook_count
operator|++
expr_stmt|;
name|new_array
operator|=
operator|(
name|hook_type
operator|*
operator|)
name|xrealloc
argument_list|(
name|exec_file_extra_hooks
argument_list|,
name|exec_file_hook_count
operator|*
sizeof|sizeof
argument_list|(
name|hook_type
argument_list|)
argument_list|)
expr_stmt|;
name|exec_file_extra_hooks
operator|=
name|new_array
expr_stmt|;
name|exec_file_extra_hooks
index|[
name|exec_file_hook_count
operator|-
literal|1
index|]
operator|=
name|hook
expr_stmt|;
block|}
else|else
name|exec_file_display_hook
operator|=
name|hook
expr_stmt|;
block|}
end_block

begin_comment
comment|/* The exec file must be closed before running an inferior.    If it is needed again after the inferior dies, it must    be reopened.  */
end_comment

begin_function
name|void
name|close_exec_file
parameter_list|()
block|{
if|#
directive|if
literal|0
comment|/* FIXME */
block|if (exec_bfd)     bfd_tempclose (exec_bfd);
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|reopen_exec_file
parameter_list|()
block|{
if|#
directive|if
literal|0
comment|/* FIXME */
block|if (exec_bfd)     bfd_reopen (exec_bfd);
else|#
directive|else
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|res
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|long
name|mtime
decl_stmt|;
comment|/* Don't do anything if the current target isn't exec. */
if|if
condition|(
name|exec_bfd
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|target_shortname
argument_list|,
literal|"exec"
argument_list|)
operator|!=
literal|0
condition|)
return|return;
comment|/* If the timestamp of the exec file has changed, reopen it. */
name|filename
operator|=
name|strdup
argument_list|(
name|bfd_get_filename
argument_list|(
name|exec_bfd
argument_list|)
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|mtime
operator|=
name|bfd_get_mtime
argument_list|(
name|exec_bfd
argument_list|)
expr_stmt|;
name|res
operator|=
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtime
operator|&&
name|mtime
operator|!=
name|st
operator|.
name|st_mtime
condition|)
name|exec_file_command
argument_list|(
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If we have both a core file and an exec file,    print a warning if they don't go together.  */
end_comment

begin_function
name|void
name|validate_files
parameter_list|()
block|{
if|if
condition|(
name|exec_bfd
operator|&&
name|core_bfd
condition|)
block|{
if|if
condition|(
operator|!
name|core_file_matches_executable_p
argument_list|(
name|core_bfd
argument_list|,
name|exec_bfd
argument_list|)
condition|)
name|warning
argument_list|(
literal|"core file may not match specified executable file."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bfd_get_mtime
argument_list|(
name|exec_bfd
argument_list|)
operator|>
name|bfd_get_mtime
argument_list|(
name|core_bfd
argument_list|)
condition|)
name|warning
argument_list|(
literal|"exec file is newer than core file."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the name of the executable file as a string.    ERR nonzero means get error if there is none specified;    otherwise return 0 in that case.  */
end_comment

begin_function
name|char
modifier|*
name|get_exec_file
parameter_list|(
name|err
parameter_list|)
name|int
name|err
decl_stmt|;
block|{
if|if
condition|(
name|exec_bfd
condition|)
return|return
name|bfd_get_filename
argument_list|(
name|exec_bfd
argument_list|)
return|;
if|if
condition|(
operator|!
name|err
condition|)
return|return
name|NULL
return|;
name|error
argument_list|(
literal|"No executable file specified.\n\ Use the \"file\" or \"exec-file\" command."
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Report a memory error with error().  */
end_comment

begin_function
name|void
name|memory_error
parameter_list|(
name|status
parameter_list|,
name|memaddr
parameter_list|)
name|int
name|status
decl_stmt|;
name|CORE_ADDR
name|memaddr
decl_stmt|;
block|{
if|if
condition|(
name|status
operator|==
name|EIO
condition|)
block|{
comment|/* Actually, address between memaddr and memaddr + len 	 was out of bounds. */
name|error_begin
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Cannot access memory at address "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|memaddr
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|".\n"
argument_list|)
expr_stmt|;
name|return_to_top_level
argument_list|(
name|RETURN_ERROR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error_begin
argument_list|()
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Error accessing memory address "
argument_list|)
expr_stmt|;
name|print_address_numeric
argument_list|(
name|memaddr
argument_list|,
literal|1
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|": %s.\n"
argument_list|,
name|safe_strerror
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
name|return_to_top_level
argument_list|(
name|RETURN_ERROR
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Same as target_read_memory, but report an error if can't read.  */
end_comment

begin_function
name|void
name|read_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|status
operator|=
name|target_read_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|memory_error
argument_list|(
name|status
argument_list|,
name|memaddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|read_memory_section
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|bfd_section
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|asection
modifier|*
name|bfd_section
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|status
operator|=
name|target_read_memory_section
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|,
name|bfd_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|memory_error
argument_list|(
name|status
argument_list|,
name|memaddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like target_read_memory, but slightly different parameters.  */
end_comment

begin_function
name|int
name|dis_asm_read_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|info
parameter_list|)
name|bfd_vma
name|memaddr
decl_stmt|;
name|bfd_byte
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|disassemble_info
modifier|*
name|info
decl_stmt|;
block|{
return|return
name|target_read_memory
argument_list|(
name|memaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|myaddr
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like memory_error with slightly different parameters.  */
end_comment

begin_function
name|void
name|dis_asm_memory_error
parameter_list|(
name|status
parameter_list|,
name|memaddr
parameter_list|,
name|info
parameter_list|)
name|int
name|status
decl_stmt|;
name|bfd_vma
name|memaddr
decl_stmt|;
name|disassemble_info
modifier|*
name|info
decl_stmt|;
block|{
name|memory_error
argument_list|(
name|status
argument_list|,
name|memaddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Like print_address with slightly different parameters.  */
end_comment

begin_function
name|void
name|dis_asm_print_address
parameter_list|(
name|addr
parameter_list|,
name|info
parameter_list|)
name|bfd_vma
name|addr
decl_stmt|;
name|struct
name|disassemble_info
modifier|*
name|info
decl_stmt|;
block|{
name|print_address
argument_list|(
name|addr
argument_list|,
name|info
operator|->
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Same as target_write_memory, but report an error if can't write.  */
end_comment

begin_function
name|void
name|write_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|status
decl_stmt|;
name|status
operator|=
name|target_write_memory
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
name|memory_error
argument_list|(
name|status
argument_list|,
name|memaddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read an integer from debugged memory, given address and number of bytes.  */
end_comment

begin_function
name|LONGEST
name|read_memory_integer
parameter_list|(
name|memaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
index|]
decl_stmt|;
name|read_memory
argument_list|(
name|memaddr
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|extract_signed_integer
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
name|ULONGEST
name|read_memory_unsigned_integer
parameter_list|(
name|memaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
name|buf
index|[
sizeof|sizeof
argument_list|(
name|ULONGEST
argument_list|)
index|]
decl_stmt|;
name|read_memory
argument_list|(
name|memaddr
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|extract_unsigned_integer
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|read_memory_string
parameter_list|(
name|memaddr
parameter_list|,
name|buffer
parameter_list|,
name|max_len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|;
name|int
name|max_len
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|cp
operator|=
name|buffer
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|cp
operator|-
name|buffer
operator|>=
name|max_len
condition|)
block|{
name|buffer
index|[
name|max_len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
name|cnt
operator|=
name|max_len
operator|-
operator|(
name|cp
operator|-
name|buffer
operator|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|>
literal|8
condition|)
name|cnt
operator|=
literal|8
expr_stmt|;
name|read_memory
argument_list|(
name|memaddr
operator|+
call|(
name|int
call|)
argument_list|(
name|cp
operator|-
name|buffer
argument_list|)
argument_list|,
name|cp
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
operator|&&
operator|*
name|cp
condition|;
name|i
operator|++
operator|,
name|cp
operator|++
control|)
empty_stmt|;
comment|/* null body */
if|if
condition|(
name|i
operator|<
name|cnt
operator|&&
operator|!
operator|*
name|cp
condition|)
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Enable after 4.12.  It is not tested.  */
end_comment

begin_comment
comment|/* Search code.  Targets can just make this their search function, or    if the protocol has a less general search function, they can call this    in the cases it can't handle.  */
end_comment

begin_comment
unit|void generic_search (len, data, mask, startaddr, increment, lorange, hirange 		addr_found, data_found)      int len;      char *data;      char *mask;      CORE_ADDR startaddr;      int increment;      CORE_ADDR lorange;      CORE_ADDR hirange;      CORE_ADDR *addr_found;      char *data_found; {   int i;   CORE_ADDR curaddr = startaddr;    while (curaddr>= lorange&& curaddr< hirange)     {       read_memory (curaddr, data_found, len);       for (i = 0; i< len; ++i) 	if ((data_found[i]& mask[i]) != data[i]) 	  goto try_again;
comment|/* It matches.  */
end_comment

begin_endif
unit|*addr_found = curaddr;       return;      try_again:       curaddr += increment;     }   *addr_found = (CORE_ADDR)0;   return; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_escape
end_escape

begin_comment
comment|/* The current default bfd target.  Points to storage allocated for    gnutarget_string.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|gnutarget
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Same thing, except it is "auto" not NULL for the default case.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|gnutarget_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_gnutarget_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|cmd_list_element
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|set_gnutarget_command
parameter_list|(
name|ignore
parameter_list|,
name|from_tty
parameter_list|,
name|c
parameter_list|)
name|char
modifier|*
name|ignore
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|gnutarget_string
argument_list|,
literal|"auto"
argument_list|)
condition|)
name|gnutarget
operator|=
name|NULL
expr_stmt|;
else|else
name|gnutarget
operator|=
name|gnutarget_string
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set the gnutarget.  */
end_comment

begin_function
name|void
name|set_gnutarget
parameter_list|(
name|newtarget
parameter_list|)
name|char
modifier|*
name|newtarget
decl_stmt|;
block|{
if|if
condition|(
name|gnutarget_string
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|gnutarget_string
argument_list|)
expr_stmt|;
name|gnutarget_string
operator|=
name|savestring
argument_list|(
name|newtarget
argument_list|,
name|strlen
argument_list|(
name|newtarget
argument_list|)
argument_list|)
expr_stmt|;
name|set_gnutarget_command
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_core
parameter_list|()
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|c
operator|=
name|add_cmd
argument_list|(
literal|"core-file"
argument_list|,
name|class_files
argument_list|,
name|core_file_command
argument_list|,
literal|"Use FILE as core dump for examining memory and registers.\n\ No arg means have no core file.  This command has been superseded by the\n\ `target core' and `detach' commands."
argument_list|,
operator|&
name|cmdlist
argument_list|)
expr_stmt|;
name|c
operator|->
name|completer
operator|=
name|filename_completer
expr_stmt|;
name|c
operator|=
name|add_set_cmd
argument_list|(
literal|"gnutarget"
argument_list|,
name|class_files
argument_list|,
name|var_string_noescape
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|gnutarget_string
argument_list|,
literal|"Set the current BFD target.\n\ Use `set gnutarget auto' to specify automatic detection."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|c
operator|->
name|function
operator|.
name|sfunc
operator|=
name|set_gnutarget_command
expr_stmt|;
name|add_show_from_set
argument_list|(
name|c
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|getenv
argument_list|(
literal|"GNUTARGET"
argument_list|)
condition|)
name|set_gnutarget
argument_list|(
name|getenv
argument_list|(
literal|"GNUTARGET"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|set_gnutarget
argument_list|(
literal|"auto"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

