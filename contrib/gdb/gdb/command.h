begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Header file for command-reading library command.c.    Copyright (C) 1986, 1989, 1990 Free Software Foundation, Inc.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|COMMAND_H
argument_list|)
end_if

begin_define
define|#
directive|define
name|COMMAND_H
value|1
end_define

begin_comment
comment|/* Not a set/show command.  Note that some commands which begin with    "set" or "show" might be in this category, if their syntax does    not fall into one of the following categories.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|cmd_types
block|{
name|not_set_cmd
block|,
name|set_cmd
block|,
name|show_cmd
block|}
name|cmd_types
typedef|;
end_typedef

begin_comment
comment|/* Types of "set" or "show" command.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|var_types
block|{
comment|/* "on" or "off".  *VAR is an integer which is nonzero for on,      zero for off.  */
name|var_boolean
block|,
comment|/* Unsigned Integer.  *VAR is an unsigned int.  The user can type 0      to mean "unlimited", which is stored in *VAR as UINT_MAX.  */
name|var_uinteger
block|,
comment|/* Like var_uinteger but signed.  *VAR is an int.  The user can type 0      to mean "unlimited", which is stored in *VAR as INT_MAX.  */
name|var_integer
block|,
comment|/* String which the user enters with escapes (e.g. the user types \n and      it is a real newline in the stored string).      *VAR is a malloc'd string, or NULL if the string is empty.  */
name|var_string
block|,
comment|/* String which stores what the user types verbatim.      *VAR is a malloc'd string, or NULL if the string is empty.  */
name|var_string_noescape
block|,
comment|/* String which stores a filename.      *VAR is a malloc'd string, or NULL if the string is empty.  */
name|var_filename
block|,
comment|/* ZeroableInteger.  *VAR is an int.  Like Unsigned Integer except      that zero really means zero.  */
name|var_zinteger
block|,
comment|/* Enumerated type.  Can only have one of the specified values.  *VAR is a      char pointer to the name of the element that we find.  */
name|var_enum
block|}
name|var_types
typedef|;
end_typedef

begin_comment
comment|/* This structure records one command'd definition.  */
end_comment

begin_struct
struct|struct
name|cmd_list_element
block|{
comment|/* Points to next command in this list.  */
name|struct
name|cmd_list_element
modifier|*
name|next
decl_stmt|;
comment|/* Name of this command.  */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Command class; class values are chosen by application program.  */
name|enum
name|command_class
name|class
decl_stmt|;
comment|/* Function definition of this command.        NO_FUNCTION for command class names and for help topics that        are not really commands.  */
union|union
block|{
comment|/* If type is not_set_cmd, call it like this:  */
name|void
argument_list|(
argument|*cfunc
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|args
operator|,
name|int
name|from_tty
operator|)
argument_list|)
expr_stmt|;
comment|/* If type is cmd_set or show_cmd, first set the variables, and 	   then call this.  */
name|void
argument_list|(
argument|*sfunc
argument_list|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|args
operator|,
name|int
name|from_tty
operator|,
expr|struct
name|cmd_list_element
operator|*
name|c
operator|)
argument_list|)
expr_stmt|;
block|}
name|function
union|;
define|#
directive|define
name|NO_FUNCTION
value|((void (*) PARAMS((char *args, int from_tty))) 0)
comment|/* Documentation of this command (or help topic).        First line is brief documentation; remaining lines form, with it,        the full documentation.  First line should end with a period.        Entire string should also end with a period, not a newline.  */
name|char
modifier|*
name|doc
decl_stmt|;
comment|/* Hook for another command to be executed before this command.  */
name|struct
name|cmd_list_element
modifier|*
name|hook
decl_stmt|;
comment|/* Nonzero identifies a prefix command.  For them, the address        of the variable containing the list of subcommands.  */
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|prefixlist
decl_stmt|;
comment|/* For prefix commands only:        String containing prefix commands to get here: this one        plus any others needed to get to it.  Should end in a space.        It is used before the word "command" in describing the        commands reached through this prefix.  */
name|char
modifier|*
name|prefixname
decl_stmt|;
comment|/* For prefix commands only:        nonzero means do not get an error if subcommand is not        recognized; call the prefix's own function in that case.  */
name|char
name|allow_unknown
decl_stmt|;
comment|/* Nonzero says this is an abbreviation, and should not        be mentioned in lists of commands.        This allows "br<tab>" to complete to "break", which it        otherwise wouldn't.  */
name|char
name|abbrev_flag
decl_stmt|;
comment|/* Completion routine for this command.  TEXT is the text beyond        what was matched for the command itself (leading whitespace is        skipped).  It stops where we are supposed to stop completing        (rl_point) and is '\0' terminated.         Return value is a malloc'd vector of pointers to possible completions        terminated with NULL.  If there are no completions, returning a pointer        to a NULL would work but returning NULL itself is also valid.        WORD points in the same buffer as TEXT, and completions should be        returned relative to this position.  For example, suppose TEXT is "foo"        and we want to complete to "foobar".  If WORD is "oo", return        "oobar"; if WORD is "baz/foo", return "baz/foobar".  */
name|char
operator|*
operator|*
operator|(
operator|*
name|completer
operator|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|text
operator|,
name|char
operator|*
name|word
operator|)
argument_list|)
expr_stmt|;
comment|/* Type of "set" or "show" command (or SET_NOT_SET if not "set"        or "show").  */
name|cmd_types
name|type
decl_stmt|;
comment|/* Pointer to variable affected by "set" and "show".  Doesn't matter        if type is not_set.  */
name|char
modifier|*
name|var
decl_stmt|;
comment|/* What kind of variable is *VAR?  */
name|var_types
name|var_type
decl_stmt|;
comment|/* Pointer to NULL terminated list of enumerated values (like argv).  */
name|char
modifier|*
modifier|*
name|enums
decl_stmt|;
comment|/* Pointer to command strings of user-defined commands */
name|struct
name|command_line
modifier|*
name|user_commands
decl_stmt|;
comment|/* Pointer to command that is hooked by this one,        so the hook can be removed when this one is deleted.  */
name|struct
name|cmd_list_element
modifier|*
name|hookee
decl_stmt|;
comment|/* Pointer to command that is aliased by this one, so the        aliased command can be located in case it has been hooked.  */
name|struct
name|cmd_list_element
modifier|*
name|cmd_pointer
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Forward-declarations of the entry-points of command.c.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|add_cmd
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|enum
name|command_class
operator|,
name|void
argument_list|(
operator|*
name|fun
argument_list|)
argument_list|(
name|char
operator|*
argument_list|,
name|int
argument_list|)
operator|,
name|char
operator|*
operator|,
expr|struct
name|cmd_list_element
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|add_alias_cmd
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
expr|enum
name|command_class
operator|,
name|int
operator|,
expr|struct
name|cmd_list_element
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|add_prefix_cmd
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|enum
name|command_class
operator|,
name|void
argument_list|(
operator|*
name|fun
argument_list|)
argument_list|(
name|char
operator|*
argument_list|,
name|int
argument_list|)
operator|,
name|char
operator|*
operator|,
expr|struct
name|cmd_list_element
operator|*
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|cmd_list_element
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|add_abbrev_prefix_cmd
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|enum
name|command_class
operator|,
name|void
argument_list|(
operator|*
name|fun
argument_list|)
argument_list|(
name|char
operator|*
argument_list|,
name|int
argument_list|)
operator|,
name|char
operator|*
operator|,
expr|struct
name|cmd_list_element
operator|*
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|cmd_list_element
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|lookup_cmd
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
expr|struct
name|cmd_list_element
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|lookup_cmd_1
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
operator|,
expr|struct
name|cmd_list_element
operator|*
operator|,
expr|struct
name|cmd_list_element
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|add_com
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|enum
name|command_class
operator|,
name|void
argument_list|(
operator|*
name|fun
argument_list|)
argument_list|(
name|char
operator|*
argument_list|,
name|int
argument_list|)
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|add_com_alias
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
expr|enum
name|command_class
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|add_info
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|void
argument_list|(
operator|*
name|fun
argument_list|)
argument_list|(
name|char
operator|*
argument_list|,
name|int
argument_list|)
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|add_info_alias
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|complete_on_cmdlist
name|PARAMS
argument_list|(
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|complete_on_enum
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|*
name|enumlist
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|delete_cmd
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|cmd_list_element
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|help_cmd
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|help_list
name|PARAMS
argument_list|(
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|,
name|char
operator|*
operator|,
expr|enum
name|command_class
operator|,
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|help_cmd_list
name|PARAMS
argument_list|(
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|,
expr|enum
name|command_class
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|add_set_cmd
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|enum
name|command_class
operator|,
name|var_types
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|,
expr|struct
name|cmd_list_element
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|add_set_enum_cmd
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|name
operator|,
expr|enum
name|command_class
operator|,
name|char
operator|*
name|list
index|[]
operator|,
name|char
operator|*
name|var
operator|,
name|char
operator|*
name|doc
operator|,
expr|struct
name|cmd_list_element
operator|*
operator|*
name|c
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|add_show_from_set
name|PARAMS
argument_list|(
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|,
expr|struct
name|cmd_list_element
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Do a "set" or "show" command.  ARG is NULL if no argument, or the text    of the argument, and FROM_TTY is nonzero if this command is being entered    directly by the user (i.e. these are just like any other    command).  C is the command list element for the command.  */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|do_setshow_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|cmd_list_element
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Do a "show" command for each thing on a command list.  */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|cmd_show_list
name|PARAMS
argument_list|(
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|error_no_arg
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|dont_repeat
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to mark commands that don't do anything.  If we just leave the    function field NULL, the command is interpreted as a help topic, or    as a class of commands.  */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|not_just_help_class_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !defined (COMMAND_H) */
end_comment

end_unit

