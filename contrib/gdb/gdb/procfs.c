begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Machine independent support for SVR4 /proc (process file system) for GDB.    Copyright 1991, 1992-98, 1999 Free Software Foundation, Inc.    Written by Fred Fish at Cygnus Support.  Changes for sysv4.2mp procfs    compatibility by Geoffrey Noer at Cygnus Solutions.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/*			N  O  T  E  S  For information on the details of using /proc consult section proc(4) in the UNIX System V Release 4 System Administrator's Reference Manual.  The general register and floating point register sets are manipulated separately.  This file makes the assumption that if FP0_REGNUM is defined, then support for the floating point register set is desired, regardless of whether or not the actual target has floating point hardware.   */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<sys/fault.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_include
include|#
directive|include
file|<sys/procfs.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<stropts.h>
end_include

begin_include
include|#
directive|include
file|<poll.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"gdbthread.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SYS_lwp_create
argument_list|)
operator|&&
name|defined
argument_list|(
name|SYS_lwpcreate
argument_list|)
end_if

begin_define
define|#
directive|define
name|SYS_lwp_create
value|SYS_lwpcreate
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SYS_lwp_exit
argument_list|)
operator|&&
name|defined
argument_list|(
name|SYS_lwpexit
argument_list|)
end_if

begin_define
define|#
directive|define
name|SYS_lwp_exit
value|SYS_lwpexit
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SYS_lwp_wait
argument_list|)
operator|&&
name|defined
argument_list|(
name|SYS_lwpwait
argument_list|)
end_if

begin_define
define|#
directive|define
name|SYS_lwp_wait
value|SYS_lwpwait
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SYS_lwp_self
argument_list|)
operator|&&
name|defined
argument_list|(
name|SYS_lwpself
argument_list|)
end_if

begin_define
define|#
directive|define
name|SYS_lwp_self
value|SYS_lwpself
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SYS_lwp_info
argument_list|)
operator|&&
name|defined
argument_list|(
name|SYS_lwpinfo
argument_list|)
end_if

begin_define
define|#
directive|define
name|SYS_lwp_info
value|SYS_lwpinfo
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SYS_lwp_private
argument_list|)
operator|&&
name|defined
argument_list|(
name|SYS_lwpprivate
argument_list|)
end_if

begin_define
define|#
directive|define
name|SYS_lwp_private
value|SYS_lwpprivate
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SYS_lwp_kill
argument_list|)
operator|&&
name|defined
argument_list|(
name|SYS_lwpkill
argument_list|)
end_if

begin_define
define|#
directive|define
name|SYS_lwp_kill
value|SYS_lwpkill
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SYS_lwp_suspend
argument_list|)
operator|&&
name|defined
argument_list|(
name|SYS_lwpsuspend
argument_list|)
end_if

begin_define
define|#
directive|define
name|SYS_lwp_suspend
value|SYS_lwpsuspend
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SYS_lwp_continue
argument_list|)
operator|&&
name|defined
argument_list|(
name|SYS_lwpcontinue
argument_list|)
end_if

begin_define
define|#
directive|define
name|SYS_lwp_continue
value|SYS_lwpcontinue
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* the name of the proc status struct depends on the implementation */
end_comment

begin_comment
comment|/* Wrap Light Weight Process member in THE_PR_LWP macro for clearer code */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_PSTATUS_T
end_ifndef

begin_typedef
typedef|typedef
name|prstatus_t
name|gdb_prstatus_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|THE_PR_LWP
parameter_list|(
name|a
parameter_list|)
value|a
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* HAVE_PSTATUS_T */
end_comment

begin_typedef
typedef|typedef
name|pstatus_t
name|gdb_prstatus_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|THE_PR_LWP
parameter_list|(
name|a
parameter_list|)
value|a.pr_lwp
end_define

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|HAVE_PRRUN_T
argument_list|)
operator|&&
name|defined
argument_list|(
name|HAVE_MULTIPLE_PROC_FDS
argument_list|)
end_if

begin_comment
comment|/* Fallback definitions - for using configure information directly */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|UNIXWARE
end_ifndef

begin_define
define|#
directive|define
name|UNIXWARE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|PROCFS_USE_READ_WRITE
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_PROCFS_PIOCSET
argument_list|)
end_if

begin_define
define|#
directive|define
name|PROCFS_USE_READ_WRITE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !HAVE_PRRUN_T&& HAVE_MULTIPLE_PROC_FDS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_PSTATUS_T */
end_comment

begin_define
define|#
directive|define
name|MAX_SYSCALLS
value|256
end_define

begin_comment
comment|/* Maximum number of syscalls for table */
end_comment

begin_comment
comment|/* proc name formats may vary depending on the proc implementation */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_MULTIPLE_PROC_FDS
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|CTL_PROC_NAME_FMT
end_ifndef

begin_define
define|#
directive|define
name|CTL_PROC_NAME_FMT
value|"/proc/%d/ctl"
end_define

begin_define
define|#
directive|define
name|AS_PROC_NAME_FMT
value|"/proc/%d/as"
end_define

begin_define
define|#
directive|define
name|MAP_PROC_NAME_FMT
value|"/proc/%d/map"
end_define

begin_define
define|#
directive|define
name|STATUS_PROC_NAME_FMT
value|"/proc/%d/status"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* HAVE_MULTIPLE_PROC_FDS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CTL_PROC_NAME_FMT
end_ifndef

begin_define
define|#
directive|define
name|CTL_PROC_NAME_FMT
value|"/proc/%05d"
end_define

begin_define
define|#
directive|define
name|AS_PROC_NAME_FMT
value|"/proc/%05d"
end_define

begin_define
define|#
directive|define
name|MAP_PROC_NAME_FMT
value|"/proc/%05d"
end_define

begin_define
define|#
directive|define
name|STATUS_PROC_NAME_FMT
value|"/proc/%05d"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_MULTIPLE_PROC_FDS */
end_comment

begin_comment
comment|/* These #ifdefs are for sol2.x in particular.  sol2.x has    both a "gregset_t" and a "prgregset_t", which have    similar uses but different layouts.  sol2.x gdb tries to    use prgregset_t (and prfpregset_t) everywhere. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|GDB_GREGSET_TYPE
end_ifdef

begin_typedef
typedef|typedef
name|GDB_GREGSET_TYPE
name|gdb_gregset_t
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|gregset_t
name|gdb_gregset_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|GDB_FPREGSET_TYPE
end_ifdef

begin_typedef
typedef|typedef
name|GDB_FPREGSET_TYPE
name|gdb_fpregset_t
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|fpregset_t
name|gdb_fpregset_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAX_PROC_NAME_SIZE
value|sizeof("/proc/1234567890/status")
end_define

begin_decl_stmt
name|struct
name|target_ops
name|procfs_ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|procfs_suppress_run
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if procfs should pretend not to 				   be a runnable target.  Used by targets 				   that can sit atop procfs, such as solaris 				   thread support.  */
end_comment

begin_if
if|#
directive|if
literal|1
end_if

begin_comment
comment|/* FIXME: Gross and ugly hack to resolve coredep.c global */
end_comment

begin_decl_stmt
name|CORE_ADDR
name|kernel_u_addr
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BROKEN_SIGINFO_H
end_ifdef

begin_comment
comment|/* Workaround broken SGS<sys/siginfo.h> */
end_comment

begin_undef
undef|#
directive|undef
name|si_pid
end_undef

begin_define
define|#
directive|define
name|si_pid
value|_data._proc.pid
end_define

begin_undef
undef|#
directive|undef
name|si_uid
end_undef

begin_define
define|#
directive|define
name|si_uid
value|_data._proc._pdata._kill.uid
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BROKEN_SIGINFO_H */
end_comment

begin_comment
comment|/* Define structures for passing commands to /proc/pid/ctl file.  Note that    while we create these for the PROCFS_USE_READ_WRITE world, we use them    and ignore the extra cmd int in other proc schemes. */
end_comment

begin_comment
comment|/* generic ctl msg */
end_comment

begin_struct
struct|struct
name|proc_ctl
block|{
name|int
name|cmd
decl_stmt|;
name|long
name|data
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* set general registers */
end_comment

begin_struct
struct|struct
name|greg_ctl
block|{
name|int
name|cmd
decl_stmt|;
name|gdb_gregset_t
name|gregset
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* set fp registers */
end_comment

begin_struct
struct|struct
name|fpreg_ctl
block|{
name|int
name|cmd
decl_stmt|;
name|gdb_fpregset_t
name|fpregset
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* set signals to be traced */
end_comment

begin_struct
struct|struct
name|sig_ctl
block|{
name|int
name|cmd
decl_stmt|;
name|sigset_t
name|sigset
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* set faults to be traced */
end_comment

begin_struct
struct|struct
name|flt_ctl
block|{
name|int
name|cmd
decl_stmt|;
name|fltset_t
name|fltset
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* set system calls to be traced */
end_comment

begin_struct
struct|struct
name|sys_ctl
block|{
name|int
name|cmd
decl_stmt|;
name|sysset_t
name|sysset
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* set current signal to be traced */
end_comment

begin_struct
struct|struct
name|sigi_ctl
block|{
name|int
name|cmd
decl_stmt|;
name|siginfo_t
name|siginfo
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  All access to the inferior, either one started by gdb or one that has     been attached to, is controlled by an instance of a procinfo structure,     defined below.  Since gdb currently only handles one inferior at a time,     the procinfo structure for the inferior is statically allocated and     only one exists at any given time.  There is a separate procinfo     structure for use by the "info proc" command, so that we can print     useful information about any random process without interfering with     the inferior's procinfo information. */
end_comment

begin_struct
struct|struct
name|procinfo
block|{
name|struct
name|procinfo
modifier|*
name|next
decl_stmt|;
name|int
name|pid
decl_stmt|;
comment|/* Process ID of inferior */
name|int
name|ctl_fd
decl_stmt|;
comment|/* File descriptor for /proc ctl file */
name|int
name|status_fd
decl_stmt|;
comment|/* File descriptor for /proc status file */
name|int
name|as_fd
decl_stmt|;
comment|/* File descriptor for /proc as file */
name|int
name|map_fd
decl_stmt|;
comment|/* File descriptor for /proc map file */
name|char
modifier|*
name|pathname
decl_stmt|;
comment|/* Pathname to /proc entry */
name|int
name|had_event
decl_stmt|;
comment|/* poll/select says something happened */
name|int
name|was_stopped
decl_stmt|;
comment|/* Nonzero if was stopped prior to attach */
name|int
name|nopass_next_sigstop
decl_stmt|;
comment|/* Don't pass a sigstop on next resume */
ifdef|#
directive|ifdef
name|HAVE_PRRUN_T
name|prrun_t
name|prrun
decl_stmt|;
comment|/* Control state when it is run */
endif|#
directive|endif
name|gdb_prstatus_t
name|prstatus
decl_stmt|;
comment|/* Current process status info */
name|struct
name|greg_ctl
name|gregset
decl_stmt|;
comment|/* General register set */
name|struct
name|fpreg_ctl
name|fpregset
decl_stmt|;
comment|/* Floating point register set */
name|struct
name|flt_ctl
name|fltset
decl_stmt|;
comment|/* Current traced hardware fault set */
name|struct
name|sig_ctl
name|trace
decl_stmt|;
comment|/* Current traced signal set */
name|struct
name|sys_ctl
name|exitset
decl_stmt|;
comment|/* Current traced system call exit set */
name|struct
name|sys_ctl
name|entryset
decl_stmt|;
comment|/* Current traced system call entry set */
name|struct
name|sig_ctl
name|saved_sighold
decl_stmt|;
comment|/* Saved held signal set */
name|struct
name|flt_ctl
name|saved_fltset
decl_stmt|;
comment|/* Saved traced hardware fault set */
name|struct
name|sig_ctl
name|saved_trace
decl_stmt|;
comment|/* Saved traced signal set */
name|struct
name|sys_ctl
name|saved_exitset
decl_stmt|;
comment|/* Saved traced system call exit set */
name|struct
name|sys_ctl
name|saved_entryset
decl_stmt|;
comment|/* Saved traced system call entry set */
name|int
name|num_syscall_handlers
decl_stmt|;
comment|/* Number of syscall trap handlers 				   currently installed */
comment|/* Pointer to list of syscall trap handlers */
name|struct
name|procfs_syscall_handler
modifier|*
name|syscall_handlers
decl_stmt|;
name|int
name|saved_rtnval
decl_stmt|;
comment|/* return value and status for wait(), */
name|int
name|saved_statval
decl_stmt|;
comment|/*  as supplied by a syscall handler. */
name|int
name|new_child
decl_stmt|;
comment|/* Non-zero if it's a new thread */
block|}
struct|;
end_struct

begin_comment
comment|/* List of inferior process information */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|procinfo
modifier|*
name|procinfo_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pollfd
modifier|*
name|poll_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pollfds used for waiting on /proc */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_poll_list
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of entries in poll_list */
end_comment

begin_comment
comment|/*  Much of the information used in the /proc interface, particularly for     printing status information, is kept as tables of structures of the     following form.  These tables can be used to map numeric values to     their symbolic names and to a string that describes their specific use. */
end_comment

begin_struct
struct|struct
name|trans
block|{
name|int
name|value
decl_stmt|;
comment|/* The numeric value */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The equivalent symbolic value */
name|char
modifier|*
name|desc
decl_stmt|;
comment|/* Short description of value */
block|}
struct|;
end_struct

begin_comment
comment|/*  Translate bits in the pr_flags member of the prstatus structure, into the     names and desc information. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|trans
name|pr_flag_table
index|[]
init|=
block|{
if|#
directive|if
name|defined
argument_list|(
name|PR_STOPPED
argument_list|)
block|{
name|PR_STOPPED
block|,
literal|"PR_STOPPED"
block|,
literal|"Process is stopped"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_ISTOP
argument_list|)
block|{
name|PR_ISTOP
block|,
literal|"PR_ISTOP"
block|,
literal|"Stopped on an event of interest"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_DSTOP
argument_list|)
block|{
name|PR_DSTOP
block|,
literal|"PR_DSTOP"
block|,
literal|"A stop directive is in effect"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_ASLEEP
argument_list|)
block|{
name|PR_ASLEEP
block|,
literal|"PR_ASLEEP"
block|,
literal|"Sleeping in an interruptible system call"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_FORK
argument_list|)
block|{
name|PR_FORK
block|,
literal|"PR_FORK"
block|,
literal|"Inherit-on-fork is in effect"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_RLC
argument_list|)
block|{
name|PR_RLC
block|,
literal|"PR_RLC"
block|,
literal|"Run-on-last-close is in effect"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_PTRACE
argument_list|)
block|{
name|PR_PTRACE
block|,
literal|"PR_PTRACE"
block|,
literal|"Process is being controlled by ptrace"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_PCINVAL
argument_list|)
block|{
name|PR_PCINVAL
block|,
literal|"PR_PCINVAL"
block|,
literal|"PC refers to an invalid virtual address"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_ISSYS
argument_list|)
block|{
name|PR_ISSYS
block|,
literal|"PR_ISSYS"
block|,
literal|"Is a system process"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_STEP
argument_list|)
block|{
name|PR_STEP
block|,
literal|"PR_STEP"
block|,
literal|"Process has single step pending"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_KLC
argument_list|)
block|{
name|PR_KLC
block|,
literal|"PR_KLC"
block|,
literal|"Kill-on-last-close is in effect"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_ASYNC
argument_list|)
block|{
name|PR_ASYNC
block|,
literal|"PR_ASYNC"
block|,
literal|"Asynchronous stop is in effect"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_PCOMPAT
argument_list|)
block|{
name|PR_PCOMPAT
block|,
literal|"PR_PCOMPAT"
block|,
literal|"Ptrace compatibility mode in effect"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_MSACCT
argument_list|)
block|{
name|PR_MSACCT
block|,
literal|"PR_MSACCT"
block|,
literal|"Microstate accounting enabled"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_BPTADJ
argument_list|)
block|{
name|PR_BPTADJ
block|,
literal|"PR_BPTADJ"
block|,
literal|"Breakpoint PC adjustment in effect"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_ASLWP
argument_list|)
block|{
name|PR_ASLWP
block|,
literal|"PR_ASLWP"
block|,
literal|"Asynchronus signal LWP"
block|}
block|,
endif|#
directive|endif
block|{
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  Translate values in the pr_why field of the prstatus struct. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|trans
name|pr_why_table
index|[]
init|=
block|{
if|#
directive|if
name|defined
argument_list|(
name|PR_REQUESTED
argument_list|)
block|{
name|PR_REQUESTED
block|,
literal|"PR_REQUESTED"
block|,
literal|"Directed to stop via PIOCSTOP/PIOCWSTOP"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_SIGNALLED
argument_list|)
block|{
name|PR_SIGNALLED
block|,
literal|"PR_SIGNALLED"
block|,
literal|"Receipt of a traced signal"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_SYSENTRY
argument_list|)
block|{
name|PR_SYSENTRY
block|,
literal|"PR_SYSENTRY"
block|,
literal|"Entry to a traced system call"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_SYSEXIT
argument_list|)
block|{
name|PR_SYSEXIT
block|,
literal|"PR_SYSEXIT"
block|,
literal|"Exit from a traced system call"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_JOBCONTROL
argument_list|)
block|{
name|PR_JOBCONTROL
block|,
literal|"PR_JOBCONTROL"
block|,
literal|"Default job control stop signal action"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_FAULTED
argument_list|)
block|{
name|PR_FAULTED
block|,
literal|"PR_FAULTED"
block|,
literal|"Incurred a traced hardware fault"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_SUSPENDED
argument_list|)
block|{
name|PR_SUSPENDED
block|,
literal|"PR_SUSPENDED"
block|,
literal|"Process suspended"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_CHECKPOINT
argument_list|)
block|{
name|PR_CHECKPOINT
block|,
literal|"PR_CHECKPOINT"
block|,
literal|"(???)"
block|}
block|,
endif|#
directive|endif
block|{
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  Hardware fault translation table. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|trans
name|faults_table
index|[]
init|=
block|{
if|#
directive|if
name|defined
argument_list|(
name|FLTILL
argument_list|)
block|{
name|FLTILL
block|,
literal|"FLTILL"
block|,
literal|"Illegal instruction"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|FLTPRIV
argument_list|)
block|{
name|FLTPRIV
block|,
literal|"FLTPRIV"
block|,
literal|"Privileged instruction"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|FLTBPT
argument_list|)
block|{
name|FLTBPT
block|,
literal|"FLTBPT"
block|,
literal|"Breakpoint trap"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|FLTTRACE
argument_list|)
block|{
name|FLTTRACE
block|,
literal|"FLTTRACE"
block|,
literal|"Trace trap"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|FLTACCESS
argument_list|)
block|{
name|FLTACCESS
block|,
literal|"FLTACCESS"
block|,
literal|"Memory access fault"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|FLTBOUNDS
argument_list|)
block|{
name|FLTBOUNDS
block|,
literal|"FLTBOUNDS"
block|,
literal|"Memory bounds violation"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|FLTIOVF
argument_list|)
block|{
name|FLTIOVF
block|,
literal|"FLTIOVF"
block|,
literal|"Integer overflow"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|FLTIZDIV
argument_list|)
block|{
name|FLTIZDIV
block|,
literal|"FLTIZDIV"
block|,
literal|"Integer zero divide"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|FLTFPE
argument_list|)
block|{
name|FLTFPE
block|,
literal|"FLTFPE"
block|,
literal|"Floating-point exception"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|FLTSTACK
argument_list|)
block|{
name|FLTSTACK
block|,
literal|"FLTSTACK"
block|,
literal|"Unrecoverable stack fault"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|FLTPAGE
argument_list|)
block|{
name|FLTPAGE
block|,
literal|"FLTPAGE"
block|,
literal|"Recoverable page fault"
block|}
block|,
endif|#
directive|endif
block|{
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Translation table for signal generation information.  See UNIX System    V Release 4 Programmer's Reference Manual, siginfo(5).  */
end_comment

begin_struct
specifier|static
struct|struct
name|sigcode
block|{
name|int
name|signo
decl_stmt|;
name|int
name|code
decl_stmt|;
name|char
modifier|*
name|codename
decl_stmt|;
name|char
modifier|*
name|desc
decl_stmt|;
block|}
name|siginfo_table
index|[]
init|=
block|{
if|#
directive|if
name|defined
argument_list|(
name|SIGILL
argument_list|)
operator|&&
name|defined
argument_list|(
name|ILL_ILLOPC
argument_list|)
block|{
name|SIGILL
block|,
name|ILL_ILLOPC
block|,
literal|"ILL_ILLOPC"
block|,
literal|"Illegal opcode"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGILL
argument_list|)
operator|&&
name|defined
argument_list|(
name|ILL_ILLOPN
argument_list|)
block|{
name|SIGILL
block|,
name|ILL_ILLOPN
block|,
literal|"ILL_ILLOPN"
block|,
literal|"Illegal operand"
block|, }
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGILL
argument_list|)
operator|&&
name|defined
argument_list|(
name|ILL_ILLADR
argument_list|)
block|{
name|SIGILL
block|,
name|ILL_ILLADR
block|,
literal|"ILL_ILLADR"
block|,
literal|"Illegal addressing mode"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGILL
argument_list|)
operator|&&
name|defined
argument_list|(
name|ILL_ILLTRP
argument_list|)
block|{
name|SIGILL
block|,
name|ILL_ILLTRP
block|,
literal|"ILL_ILLTRP"
block|,
literal|"Illegal trap"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGILL
argument_list|)
operator|&&
name|defined
argument_list|(
name|ILL_PRVOPC
argument_list|)
block|{
name|SIGILL
block|,
name|ILL_PRVOPC
block|,
literal|"ILL_PRVOPC"
block|,
literal|"Privileged opcode"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGILL
argument_list|)
operator|&&
name|defined
argument_list|(
name|ILL_PRVREG
argument_list|)
block|{
name|SIGILL
block|,
name|ILL_PRVREG
block|,
literal|"ILL_PRVREG"
block|,
literal|"Privileged register"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGILL
argument_list|)
operator|&&
name|defined
argument_list|(
name|ILL_COPROC
argument_list|)
block|{
name|SIGILL
block|,
name|ILL_COPROC
block|,
literal|"ILL_COPROC"
block|,
literal|"Coprocessor error"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGILL
argument_list|)
operator|&&
name|defined
argument_list|(
name|ILL_BADSTK
argument_list|)
block|{
name|SIGILL
block|,
name|ILL_BADSTK
block|,
literal|"ILL_BADSTK"
block|,
literal|"Internal stack error"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGFPE
argument_list|)
operator|&&
name|defined
argument_list|(
name|FPE_INTDIV
argument_list|)
block|{
name|SIGFPE
block|,
name|FPE_INTDIV
block|,
literal|"FPE_INTDIV"
block|,
literal|"Integer divide by zero"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGFPE
argument_list|)
operator|&&
name|defined
argument_list|(
name|FPE_INTOVF
argument_list|)
block|{
name|SIGFPE
block|,
name|FPE_INTOVF
block|,
literal|"FPE_INTOVF"
block|,
literal|"Integer overflow"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGFPE
argument_list|)
operator|&&
name|defined
argument_list|(
name|FPE_FLTDIV
argument_list|)
block|{
name|SIGFPE
block|,
name|FPE_FLTDIV
block|,
literal|"FPE_FLTDIV"
block|,
literal|"Floating point divide by zero"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGFPE
argument_list|)
operator|&&
name|defined
argument_list|(
name|FPE_FLTOVF
argument_list|)
block|{
name|SIGFPE
block|,
name|FPE_FLTOVF
block|,
literal|"FPE_FLTOVF"
block|,
literal|"Floating point overflow"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGFPE
argument_list|)
operator|&&
name|defined
argument_list|(
name|FPE_FLTUND
argument_list|)
block|{
name|SIGFPE
block|,
name|FPE_FLTUND
block|,
literal|"FPE_FLTUND"
block|,
literal|"Floating point underflow"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGFPE
argument_list|)
operator|&&
name|defined
argument_list|(
name|FPE_FLTRES
argument_list|)
block|{
name|SIGFPE
block|,
name|FPE_FLTRES
block|,
literal|"FPE_FLTRES"
block|,
literal|"Floating point inexact result"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGFPE
argument_list|)
operator|&&
name|defined
argument_list|(
name|FPE_FLTINV
argument_list|)
block|{
name|SIGFPE
block|,
name|FPE_FLTINV
block|,
literal|"FPE_FLTINV"
block|,
literal|"Invalid floating point operation"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGFPE
argument_list|)
operator|&&
name|defined
argument_list|(
name|FPE_FLTSUB
argument_list|)
block|{
name|SIGFPE
block|,
name|FPE_FLTSUB
block|,
literal|"FPE_FLTSUB"
block|,
literal|"Subscript out of range"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGSEGV
argument_list|)
operator|&&
name|defined
argument_list|(
name|SEGV_MAPERR
argument_list|)
block|{
name|SIGSEGV
block|,
name|SEGV_MAPERR
block|,
literal|"SEGV_MAPERR"
block|,
literal|"Address not mapped to object"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGSEGV
argument_list|)
operator|&&
name|defined
argument_list|(
name|SEGV_ACCERR
argument_list|)
block|{
name|SIGSEGV
block|,
name|SEGV_ACCERR
block|,
literal|"SEGV_ACCERR"
block|,
literal|"Invalid permissions for object"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGBUS
argument_list|)
operator|&&
name|defined
argument_list|(
name|BUS_ADRALN
argument_list|)
block|{
name|SIGBUS
block|,
name|BUS_ADRALN
block|,
literal|"BUS_ADRALN"
block|,
literal|"Invalid address alignment"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGBUS
argument_list|)
operator|&&
name|defined
argument_list|(
name|BUS_ADRERR
argument_list|)
block|{
name|SIGBUS
block|,
name|BUS_ADRERR
block|,
literal|"BUS_ADRERR"
block|,
literal|"Non-existent physical address"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGBUS
argument_list|)
operator|&&
name|defined
argument_list|(
name|BUS_OBJERR
argument_list|)
block|{
name|SIGBUS
block|,
name|BUS_OBJERR
block|,
literal|"BUS_OBJERR"
block|,
literal|"Object specific hardware error"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGTRAP
argument_list|)
operator|&&
name|defined
argument_list|(
name|TRAP_BRKPT
argument_list|)
block|{
name|SIGTRAP
block|,
name|TRAP_BRKPT
block|,
literal|"TRAP_BRKPT"
block|,
literal|"Process breakpoint"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGTRAP
argument_list|)
operator|&&
name|defined
argument_list|(
name|TRAP_TRACE
argument_list|)
block|{
name|SIGTRAP
block|,
name|TRAP_TRACE
block|,
literal|"TRAP_TRACE"
block|,
literal|"Process trace trap"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGCLD
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLD_EXITED
argument_list|)
block|{
name|SIGCLD
block|,
name|CLD_EXITED
block|,
literal|"CLD_EXITED"
block|,
literal|"Child has exited"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGCLD
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLD_KILLED
argument_list|)
block|{
name|SIGCLD
block|,
name|CLD_KILLED
block|,
literal|"CLD_KILLED"
block|,
literal|"Child was killed"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGCLD
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLD_DUMPED
argument_list|)
block|{
name|SIGCLD
block|,
name|CLD_DUMPED
block|,
literal|"CLD_DUMPED"
block|,
literal|"Child has terminated abnormally"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGCLD
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLD_TRAPPED
argument_list|)
block|{
name|SIGCLD
block|,
name|CLD_TRAPPED
block|,
literal|"CLD_TRAPPED"
block|,
literal|"Traced child has trapped"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGCLD
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLD_STOPPED
argument_list|)
block|{
name|SIGCLD
block|,
name|CLD_STOPPED
block|,
literal|"CLD_STOPPED"
block|,
literal|"Child has stopped"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGCLD
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLD_CONTINUED
argument_list|)
block|{
name|SIGCLD
block|,
name|CLD_CONTINUED
block|,
literal|"CLD_CONTINUED"
block|,
literal|"Stopped child had continued"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPOLL
argument_list|)
operator|&&
name|defined
argument_list|(
name|POLL_IN
argument_list|)
block|{
name|SIGPOLL
block|,
name|POLL_IN
block|,
literal|"POLL_IN"
block|,
literal|"Input input available"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPOLL
argument_list|)
operator|&&
name|defined
argument_list|(
name|POLL_OUT
argument_list|)
block|{
name|SIGPOLL
block|,
name|POLL_OUT
block|,
literal|"POLL_OUT"
block|,
literal|"Output buffers available"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPOLL
argument_list|)
operator|&&
name|defined
argument_list|(
name|POLL_MSG
argument_list|)
block|{
name|SIGPOLL
block|,
name|POLL_MSG
block|,
literal|"POLL_MSG"
block|,
literal|"Input message available"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPOLL
argument_list|)
operator|&&
name|defined
argument_list|(
name|POLL_ERR
argument_list|)
block|{
name|SIGPOLL
block|,
name|POLL_ERR
block|,
literal|"POLL_ERR"
block|,
literal|"I/O error"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPOLL
argument_list|)
operator|&&
name|defined
argument_list|(
name|POLL_PRI
argument_list|)
block|{
name|SIGPOLL
block|,
name|POLL_PRI
block|,
literal|"POLL_PRI"
block|,
literal|"High priority input available"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPOLL
argument_list|)
operator|&&
name|defined
argument_list|(
name|POLL_HUP
argument_list|)
block|{
name|SIGPOLL
block|,
name|POLL_HUP
block|,
literal|"POLL_HUP"
block|,
literal|"Device disconnected"
block|}
block|,
endif|#
directive|endif
block|{
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|char
modifier|*
name|syscall_table
index|[
name|MAX_SYSCALLS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_decl_stmt
specifier|static
name|void
name|procfs_stop
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|procfs_thread_alive
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|procfs_can_run
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|procfs_mourn_inferior
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|procfs_fetch_registers
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|procfs_wait
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|target_waitstatus
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|procfs_open
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|procfs_files_info
name|PARAMS
argument_list|(
operator|(
expr|struct
name|target_ops
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|procfs_prepare_to_store
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|procfs_detach
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|procfs_attach
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|proc_set_exec_trap
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|procfs_init_inferior
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|procinfo
modifier|*
name|create_procinfo
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|procfs_store_registers
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|procfs_xfer_memory
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
expr|struct
name|target_ops
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|procfs_kill_inferior
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sigcodedesc
name|PARAMS
argument_list|(
operator|(
name|siginfo_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sigcodename
name|PARAMS
argument_list|(
operator|(
name|siginfo_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|procinfo
modifier|*
name|wait_fd
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|remove_fd
name|PARAMS
argument_list|(
operator|(
expr|struct
name|procinfo
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_fd
name|PARAMS
argument_list|(
operator|(
expr|struct
name|procinfo
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_proc_siginfo
name|PARAMS
argument_list|(
operator|(
expr|struct
name|procinfo
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_syscall_table
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|syscallname
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|signalname
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|errnoname
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|proc_address_to_fd
name|PARAMS
argument_list|(
operator|(
expr|struct
name|procinfo
operator|*
operator|,
name|CORE_ADDR
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|open_proc_file
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|procinfo
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|close_proc_file
name|PARAMS
argument_list|(
operator|(
expr|struct
name|procinfo
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unconditionally_kill_inferior
name|PARAMS
argument_list|(
operator|(
expr|struct
name|procinfo
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|NORETURN
name|void
name|proc_init_failed
name|PARAMS
argument_list|(
operator|(
expr|struct
name|procinfo
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
name|ATTR_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|info_proc
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|info_proc_flags
name|PARAMS
argument_list|(
operator|(
expr|struct
name|procinfo
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|info_proc_stop
name|PARAMS
argument_list|(
operator|(
expr|struct
name|procinfo
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|info_proc_siginfo
name|PARAMS
argument_list|(
operator|(
expr|struct
name|procinfo
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|info_proc_syscalls
name|PARAMS
argument_list|(
operator|(
expr|struct
name|procinfo
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|info_proc_mappings
name|PARAMS
argument_list|(
operator|(
expr|struct
name|procinfo
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|info_proc_signals
name|PARAMS
argument_list|(
operator|(
expr|struct
name|procinfo
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|info_proc_faults
name|PARAMS
argument_list|(
operator|(
expr|struct
name|procinfo
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mappingflags
name|PARAMS
argument_list|(
operator|(
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lookupname
name|PARAMS
argument_list|(
operator|(
expr|struct
name|trans
operator|*
operator|,
name|unsigned
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lookupdesc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|trans
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_attach
name|PARAMS
argument_list|(
operator|(
name|int
name|pid
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_detach
name|PARAMS
argument_list|(
operator|(
name|int
name|siggnal
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|procfs_create_inferior
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|procfs_notice_signals
name|PARAMS
argument_list|(
operator|(
name|int
name|pid
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|notice_signals
name|PARAMS
argument_list|(
operator|(
expr|struct
name|procinfo
operator|*
operator|,
expr|struct
name|sig_ctl
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|procinfo
modifier|*
name|find_procinfo
name|PARAMS
argument_list|(
operator|(
name|pid_t
name|pid
operator|,
name|int
name|okfail
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|procfs_write_pcwstop
name|PARAMS
argument_list|(
operator|(
expr|struct
name|procinfo
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|procfs_read_status
name|PARAMS
argument_list|(
operator|(
expr|struct
name|procinfo
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|procfs_write_pckill
name|PARAMS
argument_list|(
operator|(
expr|struct
name|procinfo
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|int
name|syscall_func_t
name|PARAMS
typedef|((struct
name|procinfo
modifier|*
name|pi
typedef|,
name|int
name|syscall_num
typedef|,
name|int
name|why
typedef|,
name|int
modifier|*
name|rtnval
typedef|,
name|int
modifier|*
name|statval
typedef|));
end_typedef

begin_decl_stmt
specifier|static
name|void
name|procfs_set_syscall_trap
name|PARAMS
argument_list|(
operator|(
expr|struct
name|procinfo
operator|*
name|pi
operator|,
name|int
name|syscall_num
operator|,
name|int
name|flags
operator|,
name|syscall_func_t
operator|*
name|func
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|procfs_clear_syscall_trap
name|PARAMS
argument_list|(
operator|(
expr|struct
name|procinfo
operator|*
name|pi
operator|,
name|int
name|syscall_num
operator|,
name|int
name|errok
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PROCFS_SYSCALL_ENTRY
value|0x1
end_define

begin_comment
comment|/* Trap on entry to sys call */
end_comment

begin_define
define|#
directive|define
name|PROCFS_SYSCALL_EXIT
value|0x2
end_define

begin_comment
comment|/* Trap on exit from sys call */
end_comment

begin_decl_stmt
specifier|static
name|syscall_func_t
name|procfs_exit_handler
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|syscall_func_t
name|procfs_exec_handler
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_sproc
end_ifdef

begin_decl_stmt
specifier|static
name|syscall_func_t
name|procfs_sproc_handler
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|syscall_func_t
name|procfs_fork_handler
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_lwp_create
end_ifdef

begin_decl_stmt
specifier|static
name|syscall_func_t
name|procfs_lwp_creation_handler
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|modify_inherit_on_fork_flag
name|PARAMS
argument_list|(
operator|(
name|int
name|fd
operator|,
name|int
name|flag
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|modify_run_on_last_close_flag
name|PARAMS
argument_list|(
operator|(
name|int
name|fd
operator|,
name|int
name|flag
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* */
end_comment

begin_struct
struct|struct
name|procfs_syscall_handler
block|{
name|int
name|syscall_num
decl_stmt|;
comment|/* The number of the system call being handled */
comment|/* The function to be called */
name|syscall_func_t
modifier|*
name|func
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|procfs_resume
name|PARAMS
argument_list|(
operator|(
name|int
name|pid
operator|,
name|int
name|step
operator|,
expr|enum
name|target_signal
name|signo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_procfs_ops
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* External function prototypes that can't be easily included in any    header file because the args are typedefs in system include files. */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|supply_gregset
name|PARAMS
argument_list|(
operator|(
name|gdb_gregset_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|fill_gregset
name|PARAMS
argument_list|(
operator|(
name|gdb_gregset_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|FP0_REGNUM
end_ifdef

begin_decl_stmt
specifier|extern
name|void
name|supply_fpregset
name|PARAMS
argument_list|(
operator|(
name|gdb_fpregset_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|fill_fpregset
name|PARAMS
argument_list|(
operator|(
name|gdb_fpregset_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  LOCAL FUNCTION  	find_procinfo -- convert a process id to a struct procinfo  SYNOPSIS  	static struct procinfo * find_procinfo (pid_t pid, int okfail);  DESCRIPTION 	 	Given a process id, look it up in the procinfo chain.  Returns 	a struct procinfo *.  If can't find pid, then call error(), 	unless okfail is set, in which case, return NULL;  */
end_comment

begin_function
specifier|static
name|struct
name|procinfo
modifier|*
name|find_procinfo
parameter_list|(
name|pid
parameter_list|,
name|okfail
parameter_list|)
name|pid_t
name|pid
decl_stmt|;
name|int
name|okfail
decl_stmt|;
block|{
name|struct
name|procinfo
modifier|*
name|procinfo
decl_stmt|;
for|for
control|(
name|procinfo
operator|=
name|procinfo_list
init|;
name|procinfo
condition|;
name|procinfo
operator|=
name|procinfo
operator|->
name|next
control|)
if|if
condition|(
name|procinfo
operator|->
name|pid
operator|==
name|pid
condition|)
return|return
name|procinfo
return|;
if|if
condition|(
name|okfail
condition|)
return|return
name|NULL
return|;
name|error
argument_list|(
literal|"procfs (find_procinfo):  Couldn't locate pid %d"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  LOCAL MACRO  	current_procinfo -- convert inferior_pid to a struct procinfo  SYNOPSIS  	static struct procinfo * current_procinfo;  DESCRIPTION 	 	Looks up inferior_pid in the procinfo chain.  Always returns a 	struct procinfo *.  If process can't be found, we error() out.  */
end_comment

begin_define
define|#
directive|define
name|current_procinfo
value|find_procinfo (inferior_pid, 0)
end_define

begin_comment
comment|/*  LOCAL FUNCTION  	add_fd -- Add the fd to the poll/select list  SYNOPSIS  	static void add_fd (struct procinfo *);  DESCRIPTION 	 	Add the fd of the supplied procinfo to the list of fds used for 	poll/select operations.  */
end_comment

begin_function
specifier|static
name|void
name|add_fd
parameter_list|(
name|pi
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pi
decl_stmt|;
block|{
if|if
condition|(
name|num_poll_list
operator|<=
literal|0
condition|)
name|poll_list
operator|=
operator|(
expr|struct
name|pollfd
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pollfd
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|poll_list
operator|=
operator|(
expr|struct
name|pollfd
operator|*
operator|)
name|xrealloc
argument_list|(
name|poll_list
argument_list|,
operator|(
name|num_poll_list
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pollfd
argument_list|)
argument_list|)
expr_stmt|;
name|poll_list
index|[
name|num_poll_list
index|]
operator|.
name|fd
operator|=
name|pi
operator|->
name|ctl_fd
expr_stmt|;
ifdef|#
directive|ifdef
name|UNIXWARE
name|poll_list
index|[
name|num_poll_list
index|]
operator|.
name|events
operator|=
name|POLLWRNORM
expr_stmt|;
else|#
directive|else
name|poll_list
index|[
name|num_poll_list
index|]
operator|.
name|events
operator|=
name|POLLPRI
expr_stmt|;
endif|#
directive|endif
name|num_poll_list
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	remove_fd -- Remove the fd from the poll/select list  SYNOPSIS  	static void remove_fd (struct procinfo *);  DESCRIPTION 	 	Remove the fd of the supplied procinfo from the list of fds used  	for poll/select operations.  */
end_comment

begin_function
specifier|static
name|void
name|remove_fd
parameter_list|(
name|pi
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pi
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_poll_list
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|poll_list
index|[
name|i
index|]
operator|.
name|fd
operator|==
name|pi
operator|->
name|ctl_fd
condition|)
block|{
if|if
condition|(
name|i
operator|!=
name|num_poll_list
operator|-
literal|1
condition|)
name|memcpy
argument_list|(
name|poll_list
operator|+
name|i
argument_list|,
name|poll_list
operator|+
name|i
operator|+
literal|1
argument_list|,
operator|(
name|num_poll_list
operator|-
name|i
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pollfd
argument_list|)
argument_list|)
expr_stmt|;
name|num_poll_list
operator|--
expr_stmt|;
if|if
condition|(
name|num_poll_list
operator|==
literal|0
condition|)
name|free
argument_list|(
name|poll_list
argument_list|)
expr_stmt|;
else|else
name|poll_list
operator|=
operator|(
expr|struct
name|pollfd
operator|*
operator|)
name|xrealloc
argument_list|(
name|poll_list
argument_list|,
name|num_poll_list
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pollfd
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	procfs_read_status - get procfs fd status  SYNOPSIS  	static int procfs_read_status (pi) struct procinfo *pi;  DESCRIPTION 	 	Given a pointer to a procinfo struct, get the status of 	the status_fd in the appropriate way.  Returns 0 on failure, 	1 on success.  */
end_comment

begin_function
specifier|static
name|int
name|procfs_read_status
parameter_list|(
name|pi
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pi
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|PROCFS_USE_READ_WRITE
if|if
condition|(
operator|(
name|lseek
argument_list|(
name|pi
operator|->
name|status_fd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|read
argument_list|(
name|pi
operator|->
name|status_fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pi
operator|->
name|prstatus
argument_list|,
sizeof|sizeof
argument_list|(
name|gdb_prstatus_t
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|gdb_prstatus_t
argument_list|)
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|status_fd
argument_list|,
name|PIOCSTATUS
argument_list|,
operator|&
name|pi
operator|->
name|prstatus
argument_list|)
operator|<
literal|0
condition|)
endif|#
directive|endif
return|return
literal|0
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	procfs_write_pcwstop - send a PCWSTOP to procfs fd  SYNOPSIS  	static int procfs_write_pcwstop (pi) struct procinfo *pi;  DESCRIPTION 	 	Given a pointer to a procinfo struct, send a PCWSTOP to 	the ctl_fd in the appropriate way.  Returns 0 on failure, 	1 on success.  */
end_comment

begin_function
specifier|static
name|int
name|procfs_write_pcwstop
parameter_list|(
name|pi
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pi
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|PROCFS_USE_READ_WRITE
name|long
name|cmd
init|=
name|PCWSTOP
decl_stmt|;
if|if
condition|(
name|write
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCWSTOP
argument_list|,
operator|&
name|pi
operator|->
name|prstatus
argument_list|)
operator|<
literal|0
condition|)
endif|#
directive|endif
return|return
literal|0
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	procfs_write_pckill - send a kill to procfs fd  SYNOPSIS  	static void procfs_write_pckill (pi) struct procinfo *pi;  DESCRIPTION 	 	Given a pointer to a procinfo struct, send a kill to 	the ctl_fd in the appropriate way.  Returns 0 on failure, 	1 on success.  */
end_comment

begin_function
specifier|static
name|void
name|procfs_write_pckill
parameter_list|(
name|pi
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pi
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|PROCFS_USE_READ_WRITE
name|struct
name|proc_ctl
name|pctl
decl_stmt|;
name|pctl
operator|.
name|cmd
operator|=
name|PCKILL
expr_stmt|;
name|pctl
operator|.
name|data
operator|=
name|SIGKILL
expr_stmt|;
name|write
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
operator|&
name|pctl
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|proc_ctl
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|int
name|signo
init|=
name|SIGKILL
decl_stmt|;
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCKILL
argument_list|,
operator|&
name|signo
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|struct
name|procinfo
modifier|*
name|wait_fd
parameter_list|()
block|{
name|struct
name|procinfo
modifier|*
name|pi
decl_stmt|,
modifier|*
name|next_pi
decl_stmt|;
ifndef|#
directive|ifndef
name|LOSING_POLL
name|int
name|num_fds
decl_stmt|;
name|int
name|i
decl_stmt|;
endif|#
directive|endif
name|set_sigint_trap
argument_list|()
expr_stmt|;
comment|/* Causes SIGINT to be passed on to the 			   attached process. */
name|set_sigio_trap
argument_list|()
expr_stmt|;
name|wait_again
label|:
ifndef|#
directive|ifndef
name|LOSING_POLL
while|while
condition|(
literal|1
condition|)
block|{
name|num_fds
operator|=
name|poll
argument_list|(
name|poll_list
argument_list|,
name|num_poll_list
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_fds
operator|>
literal|0
condition|)
break|break;
if|if
condition|(
name|num_fds
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
name|print_sys_errmsg
argument_list|(
literal|"poll failed"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Poll failed, returned %d"
argument_list|,
name|num_fds
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* LOSING_POLL */
name|pi
operator|=
name|current_procinfo
expr_stmt|;
while|while
condition|(
operator|!
name|procfs_write_pcwstop
argument_list|(
name|pi
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
comment|/* Process exited.  */
name|pi
operator|->
name|prstatus
operator|.
name|pr_flags
operator|=
literal|0
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"procfs_write_pcwstop failed"
argument_list|)
expr_stmt|;
block|}
block|}
name|pi
operator|->
name|had_event
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* LOSING_POLL */
name|clear_sigint_trap
argument_list|()
expr_stmt|;
name|clear_sigio_trap
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|LOSING_POLL
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_poll_list
operator|&&
name|num_fds
operator|>
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
literal|0
operator|==
operator|(
name|poll_list
index|[
name|i
index|]
operator|.
name|revents
operator|&
operator|(
name|POLLWRNORM
operator||
name|POLLPRI
operator||
name|POLLERR
operator||
name|POLLHUP
operator||
name|POLLNVAL
operator|)
operator|)
condition|)
continue|continue;
for|for
control|(
name|pi
operator|=
name|procinfo_list
init|;
name|pi
condition|;
name|pi
operator|=
name|next_pi
control|)
block|{
name|next_pi
operator|=
name|pi
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|poll_list
index|[
name|i
index|]
operator|.
name|fd
operator|==
name|pi
operator|->
name|ctl_fd
condition|)
block|{
name|num_fds
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|poll_list
index|[
name|i
index|]
operator|.
name|revents
operator|&
name|POLLHUP
operator|)
operator|!=
literal|0
operator|||
operator|!
name|procfs_read_status
argument_list|(
name|pi
argument_list|)
condition|)
block|{
comment|/* The LWP has apparently terminated.  */
if|if
condition|(
name|num_poll_list
operator|<=
literal|1
condition|)
block|{
name|pi
operator|->
name|prstatus
operator|.
name|pr_flags
operator|=
literal|0
expr_stmt|;
name|pi
operator|->
name|had_event
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"LWP %d exited.\n"
argument_list|,
operator|(
name|pi
operator|->
name|pid
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|close_proc_file
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
comment|/* don't skip deleted entry */
if|if
condition|(
name|num_fds
operator|!=
literal|0
condition|)
break|break;
comment|/* already another event to process */
else|else
goto|goto
name|wait_again
goto|;
comment|/* wait for another event */
block|}
name|pi
operator|->
name|had_event
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|pi
condition|)
name|error
argument_list|(
literal|"wait_fd: Couldn't find procinfo for fd %d\n"
argument_list|,
name|poll_list
index|[
name|i
index|]
operator|.
name|fd
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* LOSING_POLL */
return|return
name|pi
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	lookupdesc -- translate a value to a summary desc string  SYNOPSIS  	static char *lookupdesc (struct trans *transp, unsigned int val);  DESCRIPTION 	 	Given a pointer to a translation table and a value to be translated, 	lookup the desc string and return it.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|lookupdesc
parameter_list|(
name|transp
parameter_list|,
name|val
parameter_list|)
name|struct
name|trans
modifier|*
name|transp
decl_stmt|;
name|unsigned
name|int
name|val
decl_stmt|;
block|{
name|char
modifier|*
name|desc
decl_stmt|;
for|for
control|(
name|desc
operator|=
name|NULL
init|;
name|transp
operator|->
name|name
operator|!=
name|NULL
condition|;
name|transp
operator|++
control|)
block|{
if|if
condition|(
name|transp
operator|->
name|value
operator|==
name|val
condition|)
block|{
name|desc
operator|=
name|transp
operator|->
name|desc
expr_stmt|;
break|break;
block|}
block|}
comment|/* Didn't find a translation for the specified value, set a default one. */
if|if
condition|(
name|desc
operator|==
name|NULL
condition|)
block|{
name|desc
operator|=
literal|"Unknown"
expr_stmt|;
block|}
return|return
operator|(
name|desc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	lookupname -- translate a value to symbolic name  SYNOPSIS  	static char *lookupname (struct trans *transp, unsigned int val, 				 char *prefix);  DESCRIPTION 	 	Given a pointer to a translation table, a value to be translated, 	and a default prefix to return if the value can't be translated, 	match the value with one of the translation table entries and 	return a pointer to the symbolic name.  	If no match is found it just returns the value as a printable string, 	with the given prefix.  The previous such value, if any, is freed 	at this time.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|lookupname
parameter_list|(
name|transp
parameter_list|,
name|val
parameter_list|,
name|prefix
parameter_list|)
name|struct
name|trans
modifier|*
name|transp
decl_stmt|;
name|unsigned
name|int
name|val
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|locbuf
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
for|for
control|(
name|name
operator|=
name|NULL
init|;
name|transp
operator|->
name|name
operator|!=
name|NULL
condition|;
name|transp
operator|++
control|)
block|{
if|if
condition|(
name|transp
operator|->
name|value
operator|==
name|val
condition|)
block|{
name|name
operator|=
name|transp
operator|->
name|name
expr_stmt|;
break|break;
block|}
block|}
comment|/* Didn't find a translation for the specified value, build a default      one using the specified prefix and return it.  The lifetime of      the value is only until the next one is needed. */
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|locbuf
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|locbuf
argument_list|)
expr_stmt|;
block|}
name|locbuf
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|+
literal|16
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|locbuf
argument_list|,
literal|"%s %u"
argument_list|,
name|prefix
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|name
operator|=
name|locbuf
expr_stmt|;
block|}
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|sigcodename
parameter_list|(
name|sip
parameter_list|)
name|siginfo_t
modifier|*
name|sip
decl_stmt|;
block|{
name|struct
name|sigcode
modifier|*
name|scp
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
specifier|static
name|char
name|locbuf
index|[
literal|32
index|]
decl_stmt|;
for|for
control|(
name|scp
operator|=
name|siginfo_table
init|;
name|scp
operator|->
name|codename
operator|!=
name|NULL
condition|;
name|scp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|scp
operator|->
name|signo
operator|==
name|sip
operator|->
name|si_signo
operator|)
operator|&&
operator|(
name|scp
operator|->
name|code
operator|==
name|sip
operator|->
name|si_code
operator|)
condition|)
block|{
name|name
operator|=
name|scp
operator|->
name|codename
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|locbuf
argument_list|,
literal|"sigcode %u"
argument_list|,
name|sip
operator|->
name|si_signo
argument_list|)
expr_stmt|;
name|name
operator|=
name|locbuf
expr_stmt|;
block|}
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|sigcodedesc
parameter_list|(
name|sip
parameter_list|)
name|siginfo_t
modifier|*
name|sip
decl_stmt|;
block|{
name|struct
name|sigcode
modifier|*
name|scp
decl_stmt|;
name|char
modifier|*
name|desc
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|scp
operator|=
name|siginfo_table
init|;
name|scp
operator|->
name|codename
operator|!=
name|NULL
condition|;
name|scp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|scp
operator|->
name|signo
operator|==
name|sip
operator|->
name|si_signo
operator|)
operator|&&
operator|(
name|scp
operator|->
name|code
operator|==
name|sip
operator|->
name|si_code
operator|)
condition|)
block|{
name|desc
operator|=
name|scp
operator|->
name|desc
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|desc
operator|==
name|NULL
condition|)
block|{
name|desc
operator|=
literal|"Unrecognized signal or trap use"
expr_stmt|;
block|}
return|return
operator|(
name|desc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	syscallname - translate a system call number into a system call name  SYNOPSIS  	char *syscallname (int syscallnum)  DESCRIPTION  	Given a system call number, translate it into the printable name 	of a system call, or into "syscall<num>" if it is an unknown 	number.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|syscallname
parameter_list|(
name|syscallnum
parameter_list|)
name|int
name|syscallnum
decl_stmt|;
block|{
specifier|static
name|char
name|locbuf
index|[
literal|32
index|]
decl_stmt|;
if|if
condition|(
name|syscallnum
operator|>=
literal|0
operator|&&
name|syscallnum
operator|<
name|MAX_SYSCALLS
operator|&&
name|syscall_table
index|[
name|syscallnum
index|]
operator|!=
name|NULL
condition|)
return|return
name|syscall_table
index|[
name|syscallnum
index|]
return|;
else|else
block|{
name|sprintf
argument_list|(
name|locbuf
argument_list|,
literal|"syscall %u"
argument_list|,
name|syscallnum
argument_list|)
expr_stmt|;
return|return
name|locbuf
return|;
block|}
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	init_syscall_table - initialize syscall translation table  SYNOPSIS  	void init_syscall_table (void)  DESCRIPTION  	Dynamically initialize the translation table to convert system 	call numbers into printable system call names.  Done once per 	gdb run, on initialization.  NOTES  	This is awfully ugly, but preprocessor tricks to make it prettier 	tend to be nonportable.  */
end_comment

begin_function
specifier|static
name|void
name|init_syscall_table
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|SYS_exit
argument_list|)
name|syscall_table
index|[
name|SYS_exit
index|]
operator|=
literal|"exit"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_fork
argument_list|)
name|syscall_table
index|[
name|SYS_fork
index|]
operator|=
literal|"fork"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_read
argument_list|)
name|syscall_table
index|[
name|SYS_read
index|]
operator|=
literal|"read"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_write
argument_list|)
name|syscall_table
index|[
name|SYS_write
index|]
operator|=
literal|"write"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_open
argument_list|)
name|syscall_table
index|[
name|SYS_open
index|]
operator|=
literal|"open"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_close
argument_list|)
name|syscall_table
index|[
name|SYS_close
index|]
operator|=
literal|"close"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_wait
argument_list|)
name|syscall_table
index|[
name|SYS_wait
index|]
operator|=
literal|"wait"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_creat
argument_list|)
name|syscall_table
index|[
name|SYS_creat
index|]
operator|=
literal|"creat"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_link
argument_list|)
name|syscall_table
index|[
name|SYS_link
index|]
operator|=
literal|"link"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_unlink
argument_list|)
name|syscall_table
index|[
name|SYS_unlink
index|]
operator|=
literal|"unlink"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_exec
argument_list|)
name|syscall_table
index|[
name|SYS_exec
index|]
operator|=
literal|"exec"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_execv
argument_list|)
name|syscall_table
index|[
name|SYS_execv
index|]
operator|=
literal|"execv"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_execve
argument_list|)
name|syscall_table
index|[
name|SYS_execve
index|]
operator|=
literal|"execve"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_chdir
argument_list|)
name|syscall_table
index|[
name|SYS_chdir
index|]
operator|=
literal|"chdir"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_time
argument_list|)
name|syscall_table
index|[
name|SYS_time
index|]
operator|=
literal|"time"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_mknod
argument_list|)
name|syscall_table
index|[
name|SYS_mknod
index|]
operator|=
literal|"mknod"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_chmod
argument_list|)
name|syscall_table
index|[
name|SYS_chmod
index|]
operator|=
literal|"chmod"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_chown
argument_list|)
name|syscall_table
index|[
name|SYS_chown
index|]
operator|=
literal|"chown"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_brk
argument_list|)
name|syscall_table
index|[
name|SYS_brk
index|]
operator|=
literal|"brk"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_stat
argument_list|)
name|syscall_table
index|[
name|SYS_stat
index|]
operator|=
literal|"stat"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_lseek
argument_list|)
name|syscall_table
index|[
name|SYS_lseek
index|]
operator|=
literal|"lseek"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_getpid
argument_list|)
name|syscall_table
index|[
name|SYS_getpid
index|]
operator|=
literal|"getpid"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_mount
argument_list|)
name|syscall_table
index|[
name|SYS_mount
index|]
operator|=
literal|"mount"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_umount
argument_list|)
name|syscall_table
index|[
name|SYS_umount
index|]
operator|=
literal|"umount"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_setuid
argument_list|)
name|syscall_table
index|[
name|SYS_setuid
index|]
operator|=
literal|"setuid"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_getuid
argument_list|)
name|syscall_table
index|[
name|SYS_getuid
index|]
operator|=
literal|"getuid"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_stime
argument_list|)
name|syscall_table
index|[
name|SYS_stime
index|]
operator|=
literal|"stime"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_ptrace
argument_list|)
name|syscall_table
index|[
name|SYS_ptrace
index|]
operator|=
literal|"ptrace"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_alarm
argument_list|)
name|syscall_table
index|[
name|SYS_alarm
index|]
operator|=
literal|"alarm"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_fstat
argument_list|)
name|syscall_table
index|[
name|SYS_fstat
index|]
operator|=
literal|"fstat"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_pause
argument_list|)
name|syscall_table
index|[
name|SYS_pause
index|]
operator|=
literal|"pause"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_utime
argument_list|)
name|syscall_table
index|[
name|SYS_utime
index|]
operator|=
literal|"utime"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_stty
argument_list|)
name|syscall_table
index|[
name|SYS_stty
index|]
operator|=
literal|"stty"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_gtty
argument_list|)
name|syscall_table
index|[
name|SYS_gtty
index|]
operator|=
literal|"gtty"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_access
argument_list|)
name|syscall_table
index|[
name|SYS_access
index|]
operator|=
literal|"access"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_nice
argument_list|)
name|syscall_table
index|[
name|SYS_nice
index|]
operator|=
literal|"nice"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_statfs
argument_list|)
name|syscall_table
index|[
name|SYS_statfs
index|]
operator|=
literal|"statfs"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_sync
argument_list|)
name|syscall_table
index|[
name|SYS_sync
index|]
operator|=
literal|"sync"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_kill
argument_list|)
name|syscall_table
index|[
name|SYS_kill
index|]
operator|=
literal|"kill"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_fstatfs
argument_list|)
name|syscall_table
index|[
name|SYS_fstatfs
index|]
operator|=
literal|"fstatfs"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_pgrpsys
argument_list|)
name|syscall_table
index|[
name|SYS_pgrpsys
index|]
operator|=
literal|"pgrpsys"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_xenix
argument_list|)
name|syscall_table
index|[
name|SYS_xenix
index|]
operator|=
literal|"xenix"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_dup
argument_list|)
name|syscall_table
index|[
name|SYS_dup
index|]
operator|=
literal|"dup"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_pipe
argument_list|)
name|syscall_table
index|[
name|SYS_pipe
index|]
operator|=
literal|"pipe"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_times
argument_list|)
name|syscall_table
index|[
name|SYS_times
index|]
operator|=
literal|"times"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_profil
argument_list|)
name|syscall_table
index|[
name|SYS_profil
index|]
operator|=
literal|"profil"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_plock
argument_list|)
name|syscall_table
index|[
name|SYS_plock
index|]
operator|=
literal|"plock"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_setgid
argument_list|)
name|syscall_table
index|[
name|SYS_setgid
index|]
operator|=
literal|"setgid"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_getgid
argument_list|)
name|syscall_table
index|[
name|SYS_getgid
index|]
operator|=
literal|"getgid"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_signal
argument_list|)
name|syscall_table
index|[
name|SYS_signal
index|]
operator|=
literal|"signal"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_msgsys
argument_list|)
name|syscall_table
index|[
name|SYS_msgsys
index|]
operator|=
literal|"msgsys"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_sys3b
argument_list|)
name|syscall_table
index|[
name|SYS_sys3b
index|]
operator|=
literal|"sys3b"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_sysi86
argument_list|)
name|syscall_table
index|[
name|SYS_sysi86
index|]
operator|=
literal|"sysi86"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_acct
argument_list|)
name|syscall_table
index|[
name|SYS_acct
index|]
operator|=
literal|"acct"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_shmsys
argument_list|)
name|syscall_table
index|[
name|SYS_shmsys
index|]
operator|=
literal|"shmsys"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_semsys
argument_list|)
name|syscall_table
index|[
name|SYS_semsys
index|]
operator|=
literal|"semsys"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_ioctl
argument_list|)
name|syscall_table
index|[
name|SYS_ioctl
index|]
operator|=
literal|"ioctl"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_uadmin
argument_list|)
name|syscall_table
index|[
name|SYS_uadmin
index|]
operator|=
literal|"uadmin"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_utssys
argument_list|)
name|syscall_table
index|[
name|SYS_utssys
index|]
operator|=
literal|"utssys"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_fsync
argument_list|)
name|syscall_table
index|[
name|SYS_fsync
index|]
operator|=
literal|"fsync"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_umask
argument_list|)
name|syscall_table
index|[
name|SYS_umask
index|]
operator|=
literal|"umask"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_chroot
argument_list|)
name|syscall_table
index|[
name|SYS_chroot
index|]
operator|=
literal|"chroot"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_fcntl
argument_list|)
name|syscall_table
index|[
name|SYS_fcntl
index|]
operator|=
literal|"fcntl"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_ulimit
argument_list|)
name|syscall_table
index|[
name|SYS_ulimit
index|]
operator|=
literal|"ulimit"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_rfsys
argument_list|)
name|syscall_table
index|[
name|SYS_rfsys
index|]
operator|=
literal|"rfsys"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_rmdir
argument_list|)
name|syscall_table
index|[
name|SYS_rmdir
index|]
operator|=
literal|"rmdir"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_mkdir
argument_list|)
name|syscall_table
index|[
name|SYS_mkdir
index|]
operator|=
literal|"mkdir"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_getdents
argument_list|)
name|syscall_table
index|[
name|SYS_getdents
index|]
operator|=
literal|"getdents"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_sysfs
argument_list|)
name|syscall_table
index|[
name|SYS_sysfs
index|]
operator|=
literal|"sysfs"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_getmsg
argument_list|)
name|syscall_table
index|[
name|SYS_getmsg
index|]
operator|=
literal|"getmsg"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_putmsg
argument_list|)
name|syscall_table
index|[
name|SYS_putmsg
index|]
operator|=
literal|"putmsg"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_poll
argument_list|)
name|syscall_table
index|[
name|SYS_poll
index|]
operator|=
literal|"poll"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_lstat
argument_list|)
name|syscall_table
index|[
name|SYS_lstat
index|]
operator|=
literal|"lstat"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_symlink
argument_list|)
name|syscall_table
index|[
name|SYS_symlink
index|]
operator|=
literal|"symlink"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_readlink
argument_list|)
name|syscall_table
index|[
name|SYS_readlink
index|]
operator|=
literal|"readlink"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_setgroups
argument_list|)
name|syscall_table
index|[
name|SYS_setgroups
index|]
operator|=
literal|"setgroups"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_getgroups
argument_list|)
name|syscall_table
index|[
name|SYS_getgroups
index|]
operator|=
literal|"getgroups"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_fchmod
argument_list|)
name|syscall_table
index|[
name|SYS_fchmod
index|]
operator|=
literal|"fchmod"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_fchown
argument_list|)
name|syscall_table
index|[
name|SYS_fchown
index|]
operator|=
literal|"fchown"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_sigprocmask
argument_list|)
name|syscall_table
index|[
name|SYS_sigprocmask
index|]
operator|=
literal|"sigprocmask"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_sigsuspend
argument_list|)
name|syscall_table
index|[
name|SYS_sigsuspend
index|]
operator|=
literal|"sigsuspend"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_sigaltstack
argument_list|)
name|syscall_table
index|[
name|SYS_sigaltstack
index|]
operator|=
literal|"sigaltstack"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_sigaction
argument_list|)
name|syscall_table
index|[
name|SYS_sigaction
index|]
operator|=
literal|"sigaction"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_sigpending
argument_list|)
name|syscall_table
index|[
name|SYS_sigpending
index|]
operator|=
literal|"sigpending"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_context
argument_list|)
name|syscall_table
index|[
name|SYS_context
index|]
operator|=
literal|"context"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_evsys
argument_list|)
name|syscall_table
index|[
name|SYS_evsys
index|]
operator|=
literal|"evsys"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_evtrapret
argument_list|)
name|syscall_table
index|[
name|SYS_evtrapret
index|]
operator|=
literal|"evtrapret"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_statvfs
argument_list|)
name|syscall_table
index|[
name|SYS_statvfs
index|]
operator|=
literal|"statvfs"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_fstatvfs
argument_list|)
name|syscall_table
index|[
name|SYS_fstatvfs
index|]
operator|=
literal|"fstatvfs"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_nfssys
argument_list|)
name|syscall_table
index|[
name|SYS_nfssys
index|]
operator|=
literal|"nfssys"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_waitsys
argument_list|)
name|syscall_table
index|[
name|SYS_waitsys
index|]
operator|=
literal|"waitsys"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_sigsendsys
argument_list|)
name|syscall_table
index|[
name|SYS_sigsendsys
index|]
operator|=
literal|"sigsendsys"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_hrtsys
argument_list|)
name|syscall_table
index|[
name|SYS_hrtsys
index|]
operator|=
literal|"hrtsys"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_acancel
argument_list|)
name|syscall_table
index|[
name|SYS_acancel
index|]
operator|=
literal|"acancel"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_async
argument_list|)
name|syscall_table
index|[
name|SYS_async
index|]
operator|=
literal|"async"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_priocntlsys
argument_list|)
name|syscall_table
index|[
name|SYS_priocntlsys
index|]
operator|=
literal|"priocntlsys"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_pathconf
argument_list|)
name|syscall_table
index|[
name|SYS_pathconf
index|]
operator|=
literal|"pathconf"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_mincore
argument_list|)
name|syscall_table
index|[
name|SYS_mincore
index|]
operator|=
literal|"mincore"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_mmap
argument_list|)
name|syscall_table
index|[
name|SYS_mmap
index|]
operator|=
literal|"mmap"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_mprotect
argument_list|)
name|syscall_table
index|[
name|SYS_mprotect
index|]
operator|=
literal|"mprotect"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_munmap
argument_list|)
name|syscall_table
index|[
name|SYS_munmap
index|]
operator|=
literal|"munmap"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_fpathconf
argument_list|)
name|syscall_table
index|[
name|SYS_fpathconf
index|]
operator|=
literal|"fpathconf"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_vfork
argument_list|)
name|syscall_table
index|[
name|SYS_vfork
index|]
operator|=
literal|"vfork"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_fchdir
argument_list|)
name|syscall_table
index|[
name|SYS_fchdir
index|]
operator|=
literal|"fchdir"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_readv
argument_list|)
name|syscall_table
index|[
name|SYS_readv
index|]
operator|=
literal|"readv"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_writev
argument_list|)
name|syscall_table
index|[
name|SYS_writev
index|]
operator|=
literal|"writev"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_xstat
argument_list|)
name|syscall_table
index|[
name|SYS_xstat
index|]
operator|=
literal|"xstat"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_lxstat
argument_list|)
name|syscall_table
index|[
name|SYS_lxstat
index|]
operator|=
literal|"lxstat"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_fxstat
argument_list|)
name|syscall_table
index|[
name|SYS_fxstat
index|]
operator|=
literal|"fxstat"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_xmknod
argument_list|)
name|syscall_table
index|[
name|SYS_xmknod
index|]
operator|=
literal|"xmknod"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_clocal
argument_list|)
name|syscall_table
index|[
name|SYS_clocal
index|]
operator|=
literal|"clocal"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_setrlimit
argument_list|)
name|syscall_table
index|[
name|SYS_setrlimit
index|]
operator|=
literal|"setrlimit"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_getrlimit
argument_list|)
name|syscall_table
index|[
name|SYS_getrlimit
index|]
operator|=
literal|"getrlimit"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_lchown
argument_list|)
name|syscall_table
index|[
name|SYS_lchown
index|]
operator|=
literal|"lchown"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_memcntl
argument_list|)
name|syscall_table
index|[
name|SYS_memcntl
index|]
operator|=
literal|"memcntl"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_getpmsg
argument_list|)
name|syscall_table
index|[
name|SYS_getpmsg
index|]
operator|=
literal|"getpmsg"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_putpmsg
argument_list|)
name|syscall_table
index|[
name|SYS_putpmsg
index|]
operator|=
literal|"putpmsg"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_rename
argument_list|)
name|syscall_table
index|[
name|SYS_rename
index|]
operator|=
literal|"rename"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_uname
argument_list|)
name|syscall_table
index|[
name|SYS_uname
index|]
operator|=
literal|"uname"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_setegid
argument_list|)
name|syscall_table
index|[
name|SYS_setegid
index|]
operator|=
literal|"setegid"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_sysconfig
argument_list|)
name|syscall_table
index|[
name|SYS_sysconfig
index|]
operator|=
literal|"sysconfig"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_adjtime
argument_list|)
name|syscall_table
index|[
name|SYS_adjtime
index|]
operator|=
literal|"adjtime"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_systeminfo
argument_list|)
name|syscall_table
index|[
name|SYS_systeminfo
index|]
operator|=
literal|"systeminfo"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_seteuid
argument_list|)
name|syscall_table
index|[
name|SYS_seteuid
index|]
operator|=
literal|"seteuid"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_sproc
argument_list|)
name|syscall_table
index|[
name|SYS_sproc
index|]
operator|=
literal|"sproc"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_keyctl
argument_list|)
name|syscall_table
index|[
name|SYS_keyctl
index|]
operator|=
literal|"keyctl"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_secsys
argument_list|)
name|syscall_table
index|[
name|SYS_secsys
index|]
operator|=
literal|"secsys"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_filepriv
argument_list|)
name|syscall_table
index|[
name|SYS_filepriv
index|]
operator|=
literal|"filepriv"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_procpriv
argument_list|)
name|syscall_table
index|[
name|SYS_procpriv
index|]
operator|=
literal|"procpriv"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_devstat
argument_list|)
name|syscall_table
index|[
name|SYS_devstat
index|]
operator|=
literal|"devstat"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_aclipc
argument_list|)
name|syscall_table
index|[
name|SYS_aclipc
index|]
operator|=
literal|"aclipc"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_fdevstat
argument_list|)
name|syscall_table
index|[
name|SYS_fdevstat
index|]
operator|=
literal|"fdevstat"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_flvlfile
argument_list|)
name|syscall_table
index|[
name|SYS_flvlfile
index|]
operator|=
literal|"flvlfile"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_lvlfile
argument_list|)
name|syscall_table
index|[
name|SYS_lvlfile
index|]
operator|=
literal|"lvlfile"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_lvlequal
argument_list|)
name|syscall_table
index|[
name|SYS_lvlequal
index|]
operator|=
literal|"lvlequal"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_lvlproc
argument_list|)
name|syscall_table
index|[
name|SYS_lvlproc
index|]
operator|=
literal|"lvlproc"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_lvlipc
argument_list|)
name|syscall_table
index|[
name|SYS_lvlipc
index|]
operator|=
literal|"lvlipc"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_acl
argument_list|)
name|syscall_table
index|[
name|SYS_acl
index|]
operator|=
literal|"acl"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_auditevt
argument_list|)
name|syscall_table
index|[
name|SYS_auditevt
index|]
operator|=
literal|"auditevt"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_auditctl
argument_list|)
name|syscall_table
index|[
name|SYS_auditctl
index|]
operator|=
literal|"auditctl"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_auditdmp
argument_list|)
name|syscall_table
index|[
name|SYS_auditdmp
index|]
operator|=
literal|"auditdmp"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_auditlog
argument_list|)
name|syscall_table
index|[
name|SYS_auditlog
index|]
operator|=
literal|"auditlog"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_auditbuf
argument_list|)
name|syscall_table
index|[
name|SYS_auditbuf
index|]
operator|=
literal|"auditbuf"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_lvldom
argument_list|)
name|syscall_table
index|[
name|SYS_lvldom
index|]
operator|=
literal|"lvldom"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_lvlvfs
argument_list|)
name|syscall_table
index|[
name|SYS_lvlvfs
index|]
operator|=
literal|"lvlvfs"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_mkmld
argument_list|)
name|syscall_table
index|[
name|SYS_mkmld
index|]
operator|=
literal|"mkmld"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_mldmode
argument_list|)
name|syscall_table
index|[
name|SYS_mldmode
index|]
operator|=
literal|"mldmode"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_secadvise
argument_list|)
name|syscall_table
index|[
name|SYS_secadvise
index|]
operator|=
literal|"secadvise"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_online
argument_list|)
name|syscall_table
index|[
name|SYS_online
index|]
operator|=
literal|"online"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_setitimer
argument_list|)
name|syscall_table
index|[
name|SYS_setitimer
index|]
operator|=
literal|"setitimer"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_getitimer
argument_list|)
name|syscall_table
index|[
name|SYS_getitimer
index|]
operator|=
literal|"getitimer"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_gettimeofday
argument_list|)
name|syscall_table
index|[
name|SYS_gettimeofday
index|]
operator|=
literal|"gettimeofday"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_settimeofday
argument_list|)
name|syscall_table
index|[
name|SYS_settimeofday
index|]
operator|=
literal|"settimeofday"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_lwp_create
argument_list|)
name|syscall_table
index|[
name|SYS_lwp_create
index|]
operator|=
literal|"_lwp_create"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_lwp_exit
argument_list|)
name|syscall_table
index|[
name|SYS_lwp_exit
index|]
operator|=
literal|"_lwp_exit"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_lwp_wait
argument_list|)
name|syscall_table
index|[
name|SYS_lwp_wait
index|]
operator|=
literal|"_lwp_wait"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_lwp_self
argument_list|)
name|syscall_table
index|[
name|SYS_lwp_self
index|]
operator|=
literal|"_lwp_self"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_lwp_info
argument_list|)
name|syscall_table
index|[
name|SYS_lwp_info
index|]
operator|=
literal|"_lwp_info"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_lwp_private
argument_list|)
name|syscall_table
index|[
name|SYS_lwp_private
index|]
operator|=
literal|"_lwp_private"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_processor_bind
argument_list|)
name|syscall_table
index|[
name|SYS_processor_bind
index|]
operator|=
literal|"processor_bind"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_processor_exbind
argument_list|)
name|syscall_table
index|[
name|SYS_processor_exbind
index|]
operator|=
literal|"processor_exbind"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_prepblock
argument_list|)
name|syscall_table
index|[
name|SYS_prepblock
index|]
operator|=
literal|"prepblock"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_block
argument_list|)
name|syscall_table
index|[
name|SYS_block
index|]
operator|=
literal|"block"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_rdblock
argument_list|)
name|syscall_table
index|[
name|SYS_rdblock
index|]
operator|=
literal|"rdblock"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_unblock
argument_list|)
name|syscall_table
index|[
name|SYS_unblock
index|]
operator|=
literal|"unblock"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_cancelblock
argument_list|)
name|syscall_table
index|[
name|SYS_cancelblock
index|]
operator|=
literal|"cancelblock"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_pread
argument_list|)
name|syscall_table
index|[
name|SYS_pread
index|]
operator|=
literal|"pread"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_pwrite
argument_list|)
name|syscall_table
index|[
name|SYS_pwrite
index|]
operator|=
literal|"pwrite"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_truncate
argument_list|)
name|syscall_table
index|[
name|SYS_truncate
index|]
operator|=
literal|"truncate"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_ftruncate
argument_list|)
name|syscall_table
index|[
name|SYS_ftruncate
index|]
operator|=
literal|"ftruncate"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_lwp_kill
argument_list|)
name|syscall_table
index|[
name|SYS_lwp_kill
index|]
operator|=
literal|"_lwp_kill"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_sigwait
argument_list|)
name|syscall_table
index|[
name|SYS_sigwait
index|]
operator|=
literal|"sigwait"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_fork1
argument_list|)
name|syscall_table
index|[
name|SYS_fork1
index|]
operator|=
literal|"fork1"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_forkall
argument_list|)
name|syscall_table
index|[
name|SYS_forkall
index|]
operator|=
literal|"forkall"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_modload
argument_list|)
name|syscall_table
index|[
name|SYS_modload
index|]
operator|=
literal|"modload"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_moduload
argument_list|)
name|syscall_table
index|[
name|SYS_moduload
index|]
operator|=
literal|"moduload"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_modpath
argument_list|)
name|syscall_table
index|[
name|SYS_modpath
index|]
operator|=
literal|"modpath"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_modstat
argument_list|)
name|syscall_table
index|[
name|SYS_modstat
index|]
operator|=
literal|"modstat"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_modadm
argument_list|)
name|syscall_table
index|[
name|SYS_modadm
index|]
operator|=
literal|"modadm"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_getksym
argument_list|)
name|syscall_table
index|[
name|SYS_getksym
index|]
operator|=
literal|"getksym"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_lwp_suspend
argument_list|)
name|syscall_table
index|[
name|SYS_lwp_suspend
index|]
operator|=
literal|"_lwp_suspend"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_lwp_continue
argument_list|)
name|syscall_table
index|[
name|SYS_lwp_continue
index|]
operator|=
literal|"_lwp_continue"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_priocntllst
argument_list|)
name|syscall_table
index|[
name|SYS_priocntllst
index|]
operator|=
literal|"priocntllst"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_sleep
argument_list|)
name|syscall_table
index|[
name|SYS_sleep
index|]
operator|=
literal|"sleep"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_lwp_sema_wait
argument_list|)
name|syscall_table
index|[
name|SYS_lwp_sema_wait
index|]
operator|=
literal|"_lwp_sema_wait"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_lwp_sema_post
argument_list|)
name|syscall_table
index|[
name|SYS_lwp_sema_post
index|]
operator|=
literal|"_lwp_sema_post"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_lwp_sema_trywait
argument_list|)
name|syscall_table
index|[
name|SYS_lwp_sema_trywait
index|]
operator|=
literal|"lwp_sema_trywait"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_fstatvfs64
argument_list|)
name|syscall_table
index|[
name|SYS_fstatvfs64
index|]
operator|=
literal|"fstatvfs64"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_statvfs64
argument_list|)
name|syscall_table
index|[
name|SYS_statvfs64
index|]
operator|=
literal|"statvfs64"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_ftruncate64
argument_list|)
name|syscall_table
index|[
name|SYS_ftruncate64
index|]
operator|=
literal|"ftruncate64"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_truncate64
argument_list|)
name|syscall_table
index|[
name|SYS_truncate64
index|]
operator|=
literal|"truncate64"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_getrlimit64
argument_list|)
name|syscall_table
index|[
name|SYS_getrlimit64
index|]
operator|=
literal|"getrlimit64"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_setrlimit64
argument_list|)
name|syscall_table
index|[
name|SYS_setrlimit64
index|]
operator|=
literal|"setrlimit64"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_lseek64
argument_list|)
name|syscall_table
index|[
name|SYS_lseek64
index|]
operator|=
literal|"lseek64"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_mmap64
argument_list|)
name|syscall_table
index|[
name|SYS_mmap64
index|]
operator|=
literal|"mmap64"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_pread64
argument_list|)
name|syscall_table
index|[
name|SYS_pread64
index|]
operator|=
literal|"pread64"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_creat64
argument_list|)
name|syscall_table
index|[
name|SYS_creat64
index|]
operator|=
literal|"creat64"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_dshmsys
argument_list|)
name|syscall_table
index|[
name|SYS_dshmsys
index|]
operator|=
literal|"dshmsys"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_invlpg
argument_list|)
name|syscall_table
index|[
name|SYS_invlpg
index|]
operator|=
literal|"invlpg"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_cg_ids
argument_list|)
name|syscall_table
index|[
name|SYS_cg_ids
index|]
operator|=
literal|"cg_ids"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_cg_processors
argument_list|)
name|syscall_table
index|[
name|SYS_cg_processors
index|]
operator|=
literal|"cg_processors"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_cg_info
argument_list|)
name|syscall_table
index|[
name|SYS_cg_info
index|]
operator|=
literal|"cg_info"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_cg_bind
argument_list|)
name|syscall_table
index|[
name|SYS_cg_bind
index|]
operator|=
literal|"cg_bind"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_cg_current
argument_list|)
name|syscall_table
index|[
name|SYS_cg_current
index|]
operator|=
literal|"cg_current"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_cg_memloc
argument_list|)
name|syscall_table
index|[
name|SYS_cg_memloc
index|]
operator|=
literal|"cg_memloc"
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	procfs_kill_inferior - kill any currently inferior  SYNOPSIS  	void procfs_kill_inferior (void)  DESCRIPTION  	Kill any current inferior.  NOTES  	Kills even attached inferiors.  Presumably the user has already 	been prompted that the inferior is an attached one rather than 	one started by gdb.  (FIXME?)  */
end_comment

begin_function
specifier|static
name|void
name|procfs_kill_inferior
parameter_list|()
block|{
name|target_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	unconditionally_kill_inferior - terminate the inferior  SYNOPSIS  	static void unconditionally_kill_inferior (struct procinfo *)  DESCRIPTION  	Kill the specified inferior.  NOTE  	A possibly useful enhancement would be to first try sending 	the inferior a terminate signal, politely asking it to commit 	suicide, before we murder it (we could call that 	politely_kill_inferior()).  */
end_comment

begin_function
specifier|static
name|void
name|unconditionally_kill_inferior
parameter_list|(
name|pi
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pi
decl_stmt|;
block|{
name|int
name|ppid
decl_stmt|;
name|struct
name|proc_ctl
name|pctl
decl_stmt|;
name|ppid
operator|=
name|pi
operator|->
name|prstatus
operator|.
name|pr_ppid
expr_stmt|;
ifdef|#
directive|ifdef
name|PROCFS_NEED_CLEAR_CURSIG_FOR_KILL
comment|/* Alpha OSF/1-3.x procfs needs a clear of the current signal      before the PIOCKILL, otherwise it might generate a corrupted core      file for the inferior.  */
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCSSIG
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PROCFS_NEED_PIOCSSIG_FOR_KILL
comment|/* Alpha OSF/1-2.x procfs needs a PIOCSSIG call with a SIGKILL signal      to kill the inferior, otherwise it might remain stopped with a      pending SIGKILL.      We do not check the result of the PIOCSSIG, the inferior might have      died already.  */
block|{
name|struct
name|siginfo
name|newsiginfo
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|newsiginfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|newsiginfo
argument_list|)
argument_list|)
expr_stmt|;
name|newsiginfo
operator|.
name|si_signo
operator|=
name|SIGKILL
expr_stmt|;
name|newsiginfo
operator|.
name|si_code
operator|=
literal|0
expr_stmt|;
name|newsiginfo
operator|.
name|si_errno
operator|=
literal|0
expr_stmt|;
name|newsiginfo
operator|.
name|si_pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|newsiginfo
operator|.
name|si_uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCSSIG
argument_list|,
operator|&
name|newsiginfo
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* PROCFS_NEED_PIOCSSIG_FOR_KILL */
name|procfs_write_pckill
argument_list|(
name|pi
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PROCFS_NEED_PIOCSSIG_FOR_KILL */
name|close_proc_file
argument_list|(
name|pi
argument_list|)
expr_stmt|;
comment|/* Only wait() for our direct children.  Our grandchildren zombies are killed    by the death of their parents.  */
if|if
condition|(
name|ppid
operator|==
name|getpid
argument_list|()
condition|)
name|wait
argument_list|(
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	procfs_xfer_memory -- copy data to or from inferior memory space  SYNOPSIS  	int procfs_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, 		int dowrite, struct target_ops target)  DESCRIPTION  	Copy LEN bytes to/from inferior's memory starting at MEMADDR 	from/to debugger memory starting at MYADDR.  Copy from inferior 	if DOWRITE is zero or to inferior if DOWRITE is nonzero.    	Returns the length copied, which is either the LEN argument or 	zero.  This xfer function does not do partial moves, since procfs_ops 	doesn't allow memory operations to cross below us in the target stack 	anyway.  NOTES  	The /proc interface makes this an almost trivial task.  */
end_comment

begin_function
specifier|static
name|int
name|procfs_xfer_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|dowrite
parameter_list|,
name|target
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|dowrite
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
comment|/* ignored */
block|{
name|int
name|nbytes
init|=
literal|0
decl_stmt|;
name|struct
name|procinfo
modifier|*
name|pi
decl_stmt|;
name|pi
operator|=
name|current_procinfo
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|pi
operator|->
name|as_fd
argument_list|,
operator|(
name|off_t
operator|)
name|memaddr
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|(
name|off_t
operator|)
name|memaddr
condition|)
block|{
if|if
condition|(
name|dowrite
condition|)
block|{
name|nbytes
operator|=
name|write
argument_list|(
name|pi
operator|->
name|as_fd
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nbytes
operator|=
name|read
argument_list|(
name|pi
operator|->
name|as_fd
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nbytes
operator|<
literal|0
condition|)
block|{
name|nbytes
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
operator|(
name|nbytes
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	procfs_store_registers -- copy register values back to inferior  SYNOPSIS  	void procfs_store_registers (int regno)  DESCRIPTION  	Store our current register values back into the inferior.  If 	REGNO is -1 then store all the register, otherwise store just 	the value specified by REGNO.  NOTES  	If we are storing only a single register, we first have to get all 	the current values from the process, overwrite the desired register 	in the gregset with the one we want from gdb's registers, and then 	send the whole set back to the process.  For writing all the 	registers, all we have to do is generate the gregset and send it to 	the process.  	Also note that the process has to be stopped on an event of interest 	for this to work, which basically means that it has to have been 	run under the control of one of the other /proc ioctl calls and not 	ptrace.  Since we don't use ptrace anyway, we don't worry about this 	fine point, but it is worth noting for future reference.  	Gdb is confused about what this function is supposed to return. 	Some versions return a value, others return nothing.  Some are 	declared to return a value and actually return nothing.  Gdb ignores 	anything returned.  (FIXME)   */
end_comment

begin_function
specifier|static
name|void
name|procfs_store_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|struct
name|procinfo
modifier|*
name|pi
decl_stmt|;
ifdef|#
directive|ifdef
name|PROCFS_USE_READ_WRITE
name|struct
name|greg_ctl
name|greg
decl_stmt|;
name|struct
name|fpreg_ctl
name|fpreg
decl_stmt|;
endif|#
directive|endif
name|pi
operator|=
name|current_procinfo
expr_stmt|;
ifdef|#
directive|ifdef
name|PROCFS_USE_READ_WRITE
if|if
condition|(
name|regno
operator|!=
operator|-
literal|1
condition|)
block|{
name|procfs_read_status
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|greg
operator|.
name|gregset
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pi
operator|->
name|prstatus
operator|.
name|pr_lwp
operator|.
name|pr_context
operator|.
name|uc_mcontext
operator|.
name|gregs
argument_list|,
sizeof|sizeof
argument_list|(
name|gdb_gregset_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fill_gregset
argument_list|(
operator|&
name|greg
operator|.
name|gregset
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|greg
operator|.
name|cmd
operator|=
name|PCSREG
expr_stmt|;
name|write
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
operator|&
name|greg
argument_list|,
sizeof|sizeof
argument_list|(
name|greg
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* PROCFS_USE_READ_WRITE */
if|if
condition|(
name|regno
operator|!=
operator|-
literal|1
condition|)
block|{
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCGREG
argument_list|,
operator|&
name|pi
operator|->
name|gregset
operator|.
name|gregset
argument_list|)
expr_stmt|;
block|}
name|fill_gregset
argument_list|(
operator|&
name|pi
operator|->
name|gregset
operator|.
name|gregset
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCSREG
argument_list|,
operator|&
name|pi
operator|->
name|gregset
operator|.
name|gregset
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PROCFS_USE_READ_WRITE */
if|#
directive|if
name|defined
argument_list|(
name|FP0_REGNUM
argument_list|)
comment|/* Now repeat everything using the floating point register set, if the      target has floating point hardware. Since we ignore the returned value,      we'll never know whether it worked or not anyway. */
ifdef|#
directive|ifdef
name|PROCFS_USE_READ_WRITE
if|if
condition|(
name|regno
operator|!=
operator|-
literal|1
condition|)
block|{
name|procfs_read_status
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|fpreg
operator|.
name|fpregset
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pi
operator|->
name|prstatus
operator|.
name|pr_lwp
operator|.
name|pr_context
operator|.
name|uc_mcontext
operator|.
name|fpregs
argument_list|,
sizeof|sizeof
argument_list|(
name|gdb_fpregset_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fill_fpregset
argument_list|(
operator|&
name|fpreg
operator|.
name|fpregset
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|fpreg
operator|.
name|cmd
operator|=
name|PCSFPREG
expr_stmt|;
name|write
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
operator|&
name|fpreg
argument_list|,
sizeof|sizeof
argument_list|(
name|fpreg
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* PROCFS_USE_READ_WRITE */
if|if
condition|(
name|regno
operator|!=
operator|-
literal|1
condition|)
block|{
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCGFPREG
argument_list|,
operator|&
name|pi
operator|->
name|fpregset
operator|.
name|fpregset
argument_list|)
expr_stmt|;
block|}
name|fill_fpregset
argument_list|(
operator|&
name|pi
operator|->
name|fpregset
operator|.
name|fpregset
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCSFPREG
argument_list|,
operator|&
name|pi
operator|->
name|fpregset
operator|.
name|fpregset
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PROCFS_USE_READ_WRITE */
endif|#
directive|endif
comment|/* FP0_REGNUM */
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	init_procinfo - setup a procinfo struct and connect it to a process  SYNOPSIS  	struct procinfo * init_procinfo (int pid)  DESCRIPTION  	Allocate a procinfo structure, open the /proc file and then set up the 	set of signals and faults that are to be traced.  Returns a pointer to 	the new procinfo structure.    NOTES  	If proc_init_failed ever gets called, control returns to the command 	processing loop via the standard error handling code.   */
end_comment

begin_function
specifier|static
name|struct
name|procinfo
modifier|*
name|init_procinfo
parameter_list|(
name|pid
parameter_list|,
name|kill
parameter_list|)
name|int
name|pid
decl_stmt|;
name|int
name|kill
decl_stmt|;
block|{
name|struct
name|procinfo
modifier|*
name|pi
init|=
operator|(
expr|struct
name|procinfo
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|procinfo
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|sig_ctl
name|sctl
decl_stmt|;
name|struct
name|flt_ctl
name|fctl
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pi
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|open_proc_file
argument_list|(
name|pid
argument_list|,
name|pi
argument_list|,
name|O_RDWR
argument_list|,
literal|1
argument_list|)
condition|)
name|proc_init_failed
argument_list|(
name|pi
argument_list|,
literal|"can't open process file"
argument_list|,
name|kill
argument_list|)
expr_stmt|;
comment|/* open_proc_file may modify pid.  */
name|pid
operator|=
name|pi
operator|->
name|pid
expr_stmt|;
comment|/* Add new process to process info list */
name|pi
operator|->
name|next
operator|=
name|procinfo_list
expr_stmt|;
name|procinfo_list
operator|=
name|pi
expr_stmt|;
name|add_fd
argument_list|(
name|pi
argument_list|)
expr_stmt|;
comment|/* Add to list for poll/select */
comment|/*  Remember some things about the inferior that we will, or might, change       so that we can restore them when we detach. */
ifdef|#
directive|ifdef
name|UNIXWARE
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pi
operator|->
name|saved_trace
operator|.
name|sigset
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pi
operator|->
name|prstatus
operator|.
name|pr_sigtrace
argument_list|,
sizeof|sizeof
argument_list|(
name|sigset_t
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pi
operator|->
name|saved_fltset
operator|.
name|fltset
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pi
operator|->
name|prstatus
operator|.
name|pr_flttrace
argument_list|,
sizeof|sizeof
argument_list|(
name|fltset_t
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pi
operator|->
name|saved_entryset
operator|.
name|sysset
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pi
operator|->
name|prstatus
operator|.
name|pr_sysentry
argument_list|,
sizeof|sizeof
argument_list|(
name|sysset_t
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pi
operator|->
name|saved_exitset
operator|.
name|sysset
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pi
operator|->
name|prstatus
operator|.
name|pr_sysexit
argument_list|,
sizeof|sizeof
argument_list|(
name|sysset_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set up trace and fault sets, as gdb expects them. */
name|prfillset
argument_list|(
operator|&
name|sctl
operator|.
name|sigset
argument_list|)
expr_stmt|;
name|notice_signals
argument_list|(
name|pi
argument_list|,
operator|&
name|sctl
argument_list|)
expr_stmt|;
name|prfillset
argument_list|(
operator|&
name|fctl
operator|.
name|fltset
argument_list|)
expr_stmt|;
name|prdelset
argument_list|(
operator|&
name|fctl
operator|.
name|fltset
argument_list|,
name|FLTPAGE
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* ! UNIXWARE */
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCGTRACE
argument_list|,
operator|&
name|pi
operator|->
name|saved_trace
operator|.
name|sigset
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCGHOLD
argument_list|,
operator|&
name|pi
operator|->
name|saved_sighold
operator|.
name|sigset
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCGFAULT
argument_list|,
operator|&
name|pi
operator|->
name|saved_fltset
operator|.
name|fltset
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCGENTRY
argument_list|,
operator|&
name|pi
operator|->
name|saved_entryset
operator|.
name|sysset
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCGEXIT
argument_list|,
operator|&
name|pi
operator|->
name|saved_exitset
operator|.
name|sysset
argument_list|)
expr_stmt|;
comment|/* Set up trace and fault sets, as gdb expects them. */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pi
operator|->
name|prrun
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pi
operator|->
name|prrun
argument_list|)
argument_list|)
expr_stmt|;
name|prfillset
argument_list|(
operator|&
name|pi
operator|->
name|prrun
operator|.
name|pr_trace
argument_list|)
expr_stmt|;
name|procfs_notice_signals
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|prfillset
argument_list|(
operator|&
name|pi
operator|->
name|prrun
operator|.
name|pr_fault
argument_list|)
expr_stmt|;
name|prdelset
argument_list|(
operator|&
name|pi
operator|->
name|prrun
operator|.
name|pr_fault
argument_list|,
name|FLTPAGE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROCFS_DONT_TRACE_FAULTS
name|premptyset
argument_list|(
operator|&
name|pi
operator|->
name|prrun
operator|.
name|pr_fault
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* UNIXWARE */
if|if
condition|(
operator|!
name|procfs_read_status
argument_list|(
name|pi
argument_list|)
condition|)
name|proc_init_failed
argument_list|(
name|pi
argument_list|,
literal|"procfs_read_status failed"
argument_list|,
name|kill
argument_list|)
expr_stmt|;
return|return
name|pi
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	create_procinfo - initialize access to a /proc entry  SYNOPSIS  	struct procinfo * create_procinfo (int pid)  DESCRIPTION  	Allocate a procinfo structure, open the /proc file and then set up the 	set of signals and faults that are to be traced.  Returns a pointer to 	the new procinfo structure.  NOTES  	If proc_init_failed ever gets called, control returns to the command 	processing loop via the standard error handling code.   */
end_comment

begin_function
specifier|static
name|struct
name|procinfo
modifier|*
name|create_procinfo
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|struct
name|procinfo
modifier|*
name|pi
decl_stmt|;
name|struct
name|sig_ctl
name|sctl
decl_stmt|;
name|struct
name|flt_ctl
name|fctl
decl_stmt|;
name|pi
operator|=
name|find_procinfo
argument_list|(
name|pid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|!=
name|NULL
condition|)
return|return
name|pi
return|;
comment|/* All done!  It already exists */
name|pi
operator|=
name|init_procinfo
argument_list|(
name|pid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|UNIXWARE
comment|/* A bug in Solaris (2.5 at least) causes PIOCWSTOP to hang on LWPs that are    already stopped, even if they all have PR_ASYNC set.  */
if|if
condition|(
operator|!
operator|(
name|pi
operator|->
name|prstatus
operator|.
name|pr_flags
operator|&
name|PR_STOPPED
operator|)
condition|)
endif|#
directive|endif
if|if
condition|(
operator|!
name|procfs_write_pcwstop
argument_list|(
name|pi
argument_list|)
condition|)
name|proc_init_failed
argument_list|(
name|pi
argument_list|,
literal|"procfs_write_pcwstop failed"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROCFS_USE_READ_WRITE
name|fctl
operator|.
name|cmd
operator|=
name|PCSFAULT
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|fctl
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|flt_ctl
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|proc_init_failed
argument_list|(
name|pi
argument_list|,
literal|"PCSFAULT failed"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCSFAULT
argument_list|,
operator|&
name|pi
operator|->
name|prrun
operator|.
name|pr_fault
argument_list|)
operator|<
literal|0
condition|)
name|proc_init_failed
argument_list|(
name|pi
argument_list|,
literal|"PIOCSFAULT failed"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|pi
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	procfs_exit_handler - handle entry into the _exit syscall  SYNOPSIS  	int procfs_exit_handler (pi, syscall_num, why, rtnvalp, statvalp)  DESCRIPTION  	This routine is called when an inferior process enters the _exit() 	system call.  It continues the process, and then collects the exit 	status and pid which are returned in *statvalp and *rtnvalp.  After 	that it returns non-zero to indicate that procfs_wait should wake up.  NOTES 	There is probably a better way to do this.   */
end_comment

begin_function
specifier|static
name|int
name|procfs_exit_handler
parameter_list|(
name|pi
parameter_list|,
name|syscall_num
parameter_list|,
name|why
parameter_list|,
name|rtnvalp
parameter_list|,
name|statvalp
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pi
decl_stmt|;
name|int
name|syscall_num
decl_stmt|;
name|int
name|why
decl_stmt|;
name|int
modifier|*
name|rtnvalp
decl_stmt|;
name|int
modifier|*
name|statvalp
decl_stmt|;
block|{
name|struct
name|procinfo
modifier|*
name|temp_pi
decl_stmt|,
modifier|*
name|next_pi
decl_stmt|;
name|struct
name|proc_ctl
name|pctl
decl_stmt|;
ifdef|#
directive|ifdef
name|UNIXWARE
name|pctl
operator|.
name|cmd
operator|=
name|PCRUN
expr_stmt|;
name|pctl
operator|.
name|data
operator|=
name|PRCFAULT
expr_stmt|;
else|#
directive|else
name|pi
operator|->
name|prrun
operator|.
name|pr_flags
operator|=
name|PRCFAULT
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PROCFS_USE_READ_WRITE
if|if
condition|(
name|write
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pctl
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|proc_ctl
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCRUN
argument_list|,
operator|&
name|pi
operator|->
name|prrun
argument_list|)
operator|!=
literal|0
condition|)
endif|#
directive|endif
name|perror_with_name
argument_list|(
name|pi
operator|->
name|pathname
argument_list|)
expr_stmt|;
if|if
condition|(
name|attach_flag
condition|)
block|{
comment|/* Claim it exited (don't call wait). */
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"(attached process has exited)\n"
argument_list|)
expr_stmt|;
operator|*
name|statvalp
operator|=
literal|0
expr_stmt|;
operator|*
name|rtnvalp
operator|=
name|inferior_pid
expr_stmt|;
block|}
else|else
block|{
operator|*
name|rtnvalp
operator|=
name|wait
argument_list|(
name|statvalp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|rtnvalp
operator|>=
literal|0
condition|)
operator|*
name|rtnvalp
operator|=
name|pi
operator|->
name|pid
expr_stmt|;
block|}
comment|/* Close ALL open proc file handles,      except the one that called SYS_exit. */
for|for
control|(
name|temp_pi
operator|=
name|procinfo_list
init|;
name|temp_pi
condition|;
name|temp_pi
operator|=
name|next_pi
control|)
block|{
name|next_pi
operator|=
name|temp_pi
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|temp_pi
operator|==
name|pi
condition|)
continue|continue;
comment|/* Handled below */
name|close_proc_file
argument_list|(
name|temp_pi
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	procfs_exec_handler - handle exit from the exec family of syscalls  SYNOPSIS  	int procfs_exec_handler (pi, syscall_num, why, rtnvalp, statvalp)  DESCRIPTION  	This routine is called when an inferior process is about to finish any 	of the exec() family of	system calls.  It pretends that we got a 	SIGTRAP (for compatibility with ptrace behavior), and returns non-zero 	to tell procfs_wait to wake up.  NOTES 	This need for compatibility with ptrace is questionable.  In the 	future, it shouldn't be necessary.   */
end_comment

begin_function
specifier|static
name|int
name|procfs_exec_handler
parameter_list|(
name|pi
parameter_list|,
name|syscall_num
parameter_list|,
name|why
parameter_list|,
name|rtnvalp
parameter_list|,
name|statvalp
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pi
decl_stmt|;
name|int
name|syscall_num
decl_stmt|;
name|int
name|why
decl_stmt|;
name|int
modifier|*
name|rtnvalp
decl_stmt|;
name|int
modifier|*
name|statvalp
decl_stmt|;
block|{
operator|*
name|statvalp
operator|=
operator|(
name|SIGTRAP
operator|<<
literal|8
operator|)
operator||
literal|0177
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SYS_sproc
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|UNIXWARE
argument_list|)
end_if

begin_comment
comment|/* IRIX lwp creation system call */
end_comment

begin_comment
comment|/*  LOCAL FUNCTION  	procfs_sproc_handler - handle exit from the sproc syscall  SYNOPSIS  	int procfs_sproc_handler (pi, syscall_num, why, rtnvalp, statvalp)  DESCRIPTION  	This routine is called when an inferior process is about to finish an 	sproc() system call.  This is the system call that IRIX uses to create 	a lightweight process.  When the target process gets this event, we can 	look at rval1 to find the new child processes ID, and create a new 	procinfo struct from that.  	After that, it pretends that we got a SIGTRAP, and returns non-zero 	to tell procfs_wait to wake up.  Subsequently, wait_for_inferior gets 	woken up, sees the new process and continues it.  NOTES 	We actually never see the child exiting from sproc because we will 	shortly stop the child with PIOCSTOP, which is then registered as the 	event of interest.  */
end_comment

begin_function
specifier|static
name|int
name|procfs_sproc_handler
parameter_list|(
name|pi
parameter_list|,
name|syscall_num
parameter_list|,
name|why
parameter_list|,
name|rtnvalp
parameter_list|,
name|statvalp
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pi
decl_stmt|;
name|int
name|syscall_num
decl_stmt|;
name|int
name|why
decl_stmt|;
name|int
modifier|*
name|rtnvalp
decl_stmt|;
name|int
modifier|*
name|statvalp
decl_stmt|;
block|{
comment|/* We've just detected the completion of an sproc system call.  Now we need to    setup a procinfo struct for this thread, and notify the thread system of the    new arrival.  */
comment|/* If sproc failed, then nothing interesting happened.  Continue the process    and go back to sleep. */
if|if
condition|(
name|pi
operator|->
name|prstatus
operator|.
name|pr_errno
operator|!=
literal|0
condition|)
block|{
name|pi
operator|->
name|prrun
operator|.
name|pr_flags
operator|&=
name|PRSTEP
expr_stmt|;
name|pi
operator|->
name|prrun
operator|.
name|pr_flags
operator||=
name|PRCFAULT
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCRUN
argument_list|,
operator|&
name|pi
operator|->
name|prrun
argument_list|)
operator|!=
literal|0
condition|)
name|perror_with_name
argument_list|(
name|pi
operator|->
name|pathname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* At this point, the new thread is stopped at it's first instruction, and      the parent is stopped at the exit from sproc.  */
comment|/* Notify the caller of the arrival of a new thread. */
name|create_procinfo
argument_list|(
name|pi
operator|->
name|prstatus
operator|.
name|pr_rval1
argument_list|)
expr_stmt|;
operator|*
name|rtnvalp
operator|=
name|pi
operator|->
name|prstatus
operator|.
name|pr_rval1
expr_stmt|;
operator|*
name|statvalp
operator|=
operator|(
name|SIGTRAP
operator|<<
literal|8
operator|)
operator||
literal|0177
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	procfs_fork_handler - handle exit from the fork syscall  SYNOPSIS  	int procfs_fork_handler (pi, syscall_num, why, rtnvalp, statvalp)  DESCRIPTION  	This routine is called when an inferior process is about to finish a 	fork() system call.  We will open up the new process, and then close 	it, which releases it from the clutches of the debugger.  	After that, we continue the target process as though nothing had 	happened.  NOTES 	This is necessary for IRIX because we have to set PR_FORK in order 	to catch the creation of lwps (via sproc()).  When an actual fork 	occurs, it becomes necessary to reset the forks debugger flags and 	continue it because we can't hack multiple processes yet.  */
end_comment

begin_function
specifier|static
name|int
name|procfs_fork_handler
parameter_list|(
name|pi
parameter_list|,
name|syscall_num
parameter_list|,
name|why
parameter_list|,
name|rtnvalp
parameter_list|,
name|statvalp
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pi
decl_stmt|;
name|int
name|syscall_num
decl_stmt|;
name|int
name|why
decl_stmt|;
name|int
modifier|*
name|rtnvalp
decl_stmt|;
name|int
modifier|*
name|statvalp
decl_stmt|;
block|{
name|struct
name|procinfo
modifier|*
name|pitemp
decl_stmt|;
comment|/* At this point, we've detected the completion of a fork (or vfork) call in    our child.  The grandchild is also stopped because we set inherit-on-fork    earlier.  (Note that nobody has the grandchilds' /proc file open at this    point.)  We will release the grandchild from the debugger by opening it's    /proc file and then closing it.  Since run-on-last-close is set, the    grandchild continues on its' merry way.  */
name|pitemp
operator|=
name|create_procinfo
argument_list|(
name|pi
operator|->
name|prstatus
operator|.
name|pr_rval1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pitemp
condition|)
name|close_proc_file
argument_list|(
name|pitemp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCRUN
argument_list|,
operator|&
name|pi
operator|->
name|prrun
argument_list|)
operator|!=
literal|0
condition|)
name|perror_with_name
argument_list|(
name|pi
operator|->
name|pathname
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYS_sproc&& !UNIXWARE */
end_comment

begin_comment
comment|/*  LOCAL FUNCTION  	procfs_set_inferior_syscall_traps - setup the syscall traps   SYNOPSIS  	void procfs_set_inferior_syscall_traps (struct procinfo *pip)  DESCRIPTION  	Called for each "procinfo" (process, thread, or LWP) in the 	inferior, to register for notification of and handlers for 	syscall traps in the inferior.   */
end_comment

begin_function
specifier|static
name|void
name|procfs_set_inferior_syscall_traps
parameter_list|(
name|pip
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pip
decl_stmt|;
block|{
name|procfs_set_syscall_trap
argument_list|(
name|pip
argument_list|,
name|SYS_exit
argument_list|,
name|PROCFS_SYSCALL_ENTRY
argument_list|,
name|procfs_exit_handler
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PRFS_STOPEXEC
ifdef|#
directive|ifdef
name|SYS_exec
name|procfs_set_syscall_trap
argument_list|(
name|pip
argument_list|,
name|SYS_exec
argument_list|,
name|PROCFS_SYSCALL_EXIT
argument_list|,
name|procfs_exec_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYS_execv
name|procfs_set_syscall_trap
argument_list|(
name|pip
argument_list|,
name|SYS_execv
argument_list|,
name|PROCFS_SYSCALL_EXIT
argument_list|,
name|procfs_exec_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYS_execve
name|procfs_set_syscall_trap
argument_list|(
name|pip
argument_list|,
name|SYS_execve
argument_list|,
name|PROCFS_SYSCALL_EXIT
argument_list|,
name|procfs_exec_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* PRFS_STOPEXEC */
comment|/* Setup traps on exit from sproc() */
ifdef|#
directive|ifdef
name|SYS_sproc
name|procfs_set_syscall_trap
argument_list|(
name|pip
argument_list|,
name|SYS_sproc
argument_list|,
name|PROCFS_SYSCALL_EXIT
argument_list|,
name|procfs_sproc_handler
argument_list|)
expr_stmt|;
name|procfs_set_syscall_trap
argument_list|(
name|pip
argument_list|,
name|SYS_fork
argument_list|,
name|PROCFS_SYSCALL_EXIT
argument_list|,
name|procfs_fork_handler
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SYS_vfork
name|procfs_set_syscall_trap
argument_list|(
name|pip
argument_list|,
name|SYS_vfork
argument_list|,
name|PROCFS_SYSCALL_EXIT
argument_list|,
name|procfs_fork_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Turn on inherit-on-fork flag so that all children of the target process    start with tracing flags set.  This allows us to trap lwp creation.  Note    that we also have to trap on fork and vfork in order to disable all tracing    in the targets child processes.  */
name|modify_inherit_on_fork_flag
argument_list|(
name|pip
operator|->
name|ctl_fd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYS_lwp_create
name|procfs_set_syscall_trap
argument_list|(
name|pip
argument_list|,
name|SYS_lwp_create
argument_list|,
name|PROCFS_SYSCALL_EXIT
argument_list|,
name|procfs_lwp_creation_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	procfs_init_inferior - initialize target vector and access to a 	/proc entry  SYNOPSIS  	void procfs_init_inferior (int pid)  DESCRIPTION  	When gdb starts an inferior, this function is called in the parent 	process immediately after the fork.  It waits for the child to stop 	on the return from the exec system call (the child itself takes care 	of ensuring that this is set up), then sets up the set of signals 	and faults that are to be traced.  Returns the pid, which may have had 	the thread-id added to it.  NOTES  	If proc_init_failed ever gets called, control returns to the command 	processing loop via the standard error handling code.   */
end_comment

begin_function
specifier|static
name|void
name|procfs_init_inferior
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|struct
name|procinfo
modifier|*
name|pip
decl_stmt|;
name|push_target
argument_list|(
operator|&
name|procfs_ops
argument_list|)
expr_stmt|;
name|pip
operator|=
name|create_procinfo
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|procfs_set_inferior_syscall_traps
argument_list|(
name|pip
argument_list|)
expr_stmt|;
comment|/* create_procinfo may change the pid, so we have to update inferior_pid      here before calling other gdb routines that need the right pid.  */
name|pid
operator|=
name|pip
operator|->
name|pid
expr_stmt|;
name|inferior_pid
operator|=
name|pid
expr_stmt|;
name|add_thread
argument_list|(
name|pip
operator|->
name|pid
argument_list|)
expr_stmt|;
comment|/* Setup initial thread */
ifdef|#
directive|ifdef
name|START_INFERIOR_TRAPS_EXPECTED
name|startup_inferior
argument_list|(
name|START_INFERIOR_TRAPS_EXPECTED
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* One trap to exec the shell, one to exec the program being debugged.  */
name|startup_inferior
argument_list|(
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  GLOBAL FUNCTION  	procfs_notice_signals  SYNOPSIS  	static void procfs_notice_signals (int pid);  DESCRIPTION  	When the user changes the state of gdb's signal handling via the 	"handle" command, this function gets called to see if any change 	in the /proc interface is required.  It is also called internally 	by other /proc interface functions to initialize the state of 	the traced signal set.  	One thing it does is that signals for which the state is "nostop", 	"noprint", and "pass", have their trace bits reset in the pr_trace 	field, so that they are no longer traced.  This allows them to be 	delivered directly to the inferior without the debugger ever being 	involved.  */
end_comment

begin_function
specifier|static
name|void
name|procfs_notice_signals
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|struct
name|procinfo
modifier|*
name|pi
decl_stmt|;
name|struct
name|sig_ctl
name|sctl
decl_stmt|;
name|pi
operator|=
name|find_procinfo
argument_list|(
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|HAVE_PRRUN_T
name|premptyset
argument_list|(
operator|&
name|sctl
operator|.
name|sigset
argument_list|)
expr_stmt|;
else|#
directive|else
name|sctl
operator|.
name|sigset
operator|=
name|pi
operator|->
name|prrun
operator|.
name|pr_trace
expr_stmt|;
endif|#
directive|endif
name|notice_signals
argument_list|(
name|pi
argument_list|,
operator|&
name|sctl
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_PRRUN_T
name|pi
operator|->
name|prrun
operator|.
name|pr_trace
operator|=
name|sctl
operator|.
name|sigset
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|notice_signals
parameter_list|(
name|pi
parameter_list|,
name|sctl
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pi
decl_stmt|;
name|struct
name|sig_ctl
modifier|*
name|sctl
decl_stmt|;
block|{
name|int
name|signo
decl_stmt|;
for|for
control|(
name|signo
operator|=
literal|0
init|;
name|signo
operator|<
name|NSIG
condition|;
name|signo
operator|++
control|)
block|{
if|if
condition|(
name|signal_stop_state
argument_list|(
name|target_signal_from_host
argument_list|(
name|signo
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|signal_print_state
argument_list|(
name|target_signal_from_host
argument_list|(
name|signo
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|signal_pass_state
argument_list|(
name|target_signal_from_host
argument_list|(
name|signo
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
block|{
name|prdelset
argument_list|(
operator|&
name|sctl
operator|->
name|sigset
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|praddset
argument_list|(
operator|&
name|sctl
operator|->
name|sigset
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|PROCFS_USE_READ_WRITE
name|sctl
operator|->
name|cmd
operator|=
name|PCSTRACE
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sctl
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sig_ctl
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCSTRACE
argument_list|,
operator|&
name|sctl
operator|->
name|sigset
argument_list|)
condition|)
endif|#
directive|endif
block|{
name|print_sys_errmsg
argument_list|(
literal|"PIOCSTRACE failed"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	proc_set_exec_trap -- arrange for exec'd child to halt at startup  SYNOPSIS  	void proc_set_exec_trap (void)  DESCRIPTION  	This function is called in the child process when starting up 	an inferior, prior to doing the exec of the actual inferior. 	It sets the child process's exitset to make exit from the exec 	system call an event of interest to stop on, and then simply 	returns.  The child does the exec, the system call returns, and 	the child stops at the first instruction, ready for the gdb 	parent process to take control of it.  NOTE  	We need to use all local variables since the child may be sharing 	it's data space with the parent, if vfork was used rather than 	fork.  	Also note that we want to turn off the inherit-on-fork flag in 	the child process so that any grand-children start with all 	tracing flags cleared.  */
end_comment

begin_function
specifier|static
name|void
name|proc_set_exec_trap
parameter_list|()
block|{
name|struct
name|sys_ctl
name|exitset
decl_stmt|;
name|struct
name|sys_ctl
name|entryset
decl_stmt|;
name|char
name|procname
index|[
name|MAX_PROC_NAME_SIZE
index|]
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|sprintf
argument_list|(
name|procname
argument_list|,
name|CTL_PROC_NAME_FMT
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UNIXWARE
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|procname
argument_list|,
name|O_WRONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
else|#
directive|else
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|procname
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
endif|#
directive|endif
block|{
name|perror
argument_list|(
name|procname
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|127
argument_list|)
expr_stmt|;
block|}
name|premptyset
argument_list|(
operator|&
name|exitset
operator|.
name|sysset
argument_list|)
expr_stmt|;
name|premptyset
argument_list|(
operator|&
name|entryset
operator|.
name|sysset
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PRFS_STOPEXEC
comment|/* Under Alpha OSF/1 we have to use a PIOCSSPCACT ioctl to trace      exits from exec system calls because of the user level loader.  */
block|{
name|int
name|prfs_flags
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|PIOCGSPCACT
argument_list|,
operator|&
name|prfs_flags
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|procname
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|127
argument_list|)
expr_stmt|;
block|}
name|prfs_flags
operator||=
name|PRFS_STOPEXEC
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|PIOCSSPCACT
argument_list|,
operator|&
name|prfs_flags
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|procname
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|127
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* PRFS_STOPEXEC */
comment|/* GW: Rationale...      Not all systems with /proc have all the exec* syscalls with the same      names.  On the SGI, for example, there is no SYS_exec, but there      *is* a SYS_execv.  So, we try to account for that. */
ifdef|#
directive|ifdef
name|SYS_exec
name|praddset
argument_list|(
operator|&
name|exitset
operator|.
name|sysset
argument_list|,
name|SYS_exec
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYS_execve
name|praddset
argument_list|(
operator|&
name|exitset
operator|.
name|sysset
argument_list|,
name|SYS_execve
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYS_execv
name|praddset
argument_list|(
operator|&
name|exitset
operator|.
name|sysset
argument_list|,
name|SYS_execv
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PROCFS_USE_READ_WRITE
name|exitset
operator|.
name|cmd
operator|=
name|PCSEXIT
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|exitset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sys_ctl
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|PIOCSEXIT
argument_list|,
operator|&
name|exitset
operator|.
name|sysset
argument_list|)
operator|<
literal|0
condition|)
endif|#
directive|endif
block|{
name|perror
argument_list|(
name|procname
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|127
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* PRFS_STOPEXEC */
name|praddset
argument_list|(
operator|&
name|entryset
operator|.
name|sysset
argument_list|,
name|SYS_exit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROCFS_USE_READ_WRITE
name|entryset
operator|.
name|cmd
operator|=
name|PCSENTRY
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|entryset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sys_ctl
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|PIOCSENTRY
argument_list|,
operator|&
name|entryset
operator|.
name|sysset
argument_list|)
operator|<
literal|0
condition|)
endif|#
directive|endif
block|{
name|perror
argument_list|(
name|procname
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|126
argument_list|)
expr_stmt|;
block|}
comment|/* Turn off inherit-on-fork flag so that all grand-children of gdb      start with tracing flags cleared. */
name|modify_inherit_on_fork_flag
argument_list|(
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Turn on run-on-last-close flag so that this process will not hang      if GDB goes away for some reason.  */
name|modify_run_on_last_close_flag
argument_list|(
name|fd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|UNIXWARE
comment|/* since this is a solaris-ism, we don't want it */
comment|/* NOTE: revisit when doing thread support for UW */
ifdef|#
directive|ifdef
name|PR_ASYNC
block|{
name|long
name|pr_flags
decl_stmt|;
name|struct
name|proc_ctl
name|pctl
decl_stmt|;
comment|/* Solaris needs this to make procfs treat all threads seperately.  Without    this, all threads halt whenever something happens to any thread.  Since    GDB wants to control all this itself, it needs to set PR_ASYNC.  */
name|pr_flags
operator|=
name|PR_ASYNC
expr_stmt|;
ifdef|#
directive|ifdef
name|PROCFS_USE_READ_WRITE
name|pctl
operator|.
name|cmd
operator|=
name|PCSET
expr_stmt|;
name|pctl
operator|.
name|data
operator|=
name|PR_FORK
operator||
name|PR_ASYNC
expr_stmt|;
name|write
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pctl
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|proc_ctl
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|ioctl
argument_list|(
name|fd
argument_list|,
name|PIOCSET
argument_list|,
operator|&
name|pr_flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* PR_ASYNC */
endif|#
directive|endif
comment|/* !UNIXWARE */
block|}
end_function

begin_comment
comment|/*  GLOBAL FUNCTION  	proc_iterate_over_mappings -- call function for every mapped space  SYNOPSIS  	int proc_iterate_over_mappings (int (*func)())  DESCRIPTION  	Given a pointer to a function, call that function for every 	mapped address space, passing it an open file descriptor for 	the file corresponding to that mapped address space (if any) 	and the base address of the mapped space.  Quit when we hit 	the end of the mappings or the function returns nonzero.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|UNIXWARE
end_ifdef

begin_function_decl
name|int
name|proc_iterate_over_mappings
parameter_list|(
name|func
parameter_list|)
function_decl|int
parameter_list|(
function_decl|*func
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|CORE_ADDR
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|nmap
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|funcstat
init|=
literal|0
decl_stmt|;
name|prmap_t
modifier|*
name|prmaps
decl_stmt|;
name|prmap_t
modifier|*
name|prmap
decl_stmt|;
name|struct
name|procinfo
modifier|*
name|pi
decl_stmt|;
name|struct
name|stat
name|sbuf
decl_stmt|;
name|pi
operator|=
name|current_procinfo
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|pi
operator|->
name|map_fd
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|nmap
operator|=
name|sbuf
operator|.
name|st_size
operator|/
sizeof|sizeof
argument_list|(
name|prmap_t
argument_list|)
expr_stmt|;
name|prmaps
operator|=
operator|(
name|prmap_t
operator|*
operator|)
name|alloca
argument_list|(
name|nmap
operator|*
sizeof|sizeof
argument_list|(
name|prmap_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lseek
argument_list|(
name|pi
operator|->
name|map_fd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|read
argument_list|(
name|pi
operator|->
name|map_fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|prmaps
argument_list|,
name|nmap
operator|*
sizeof|sizeof
argument_list|(
name|prmap_t
argument_list|)
argument_list|)
operator|==
operator|(
name|nmap
operator|*
sizeof|sizeof
argument_list|(
name|prmap_t
argument_list|)
operator|)
operator|)
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|prmap
operator|=
name|prmaps
init|;
name|i
operator|<
name|nmap
operator|&&
name|funcstat
operator|==
literal|0
condition|;
operator|++
name|prmap
operator|,
operator|++
name|i
control|)
block|{
name|char
name|name
index|[
sizeof|sizeof
argument_list|(
literal|"/proc/1234567890/object"
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|prmap
operator|->
name|pr_mapname
argument_list|)
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"/proc/%d/object/%s"
argument_list|,
name|pi
operator|->
name|pid
argument_list|,
name|prmap
operator|->
name|pr_mapname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|funcstat
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|funcstat
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|fd
argument_list|,
operator|(
name|CORE_ADDR
operator|)
name|prmap
operator|->
name|pr_vaddr
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|funcstat
operator|)
return|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* UNIXWARE */
end_comment

begin_function_decl
name|int
name|proc_iterate_over_mappings
parameter_list|(
name|func
parameter_list|)
function_decl|int
parameter_list|(
function_decl|*func
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|CORE_ADDR
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|nmap
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|funcstat
init|=
literal|0
decl_stmt|;
name|struct
name|prmap
modifier|*
name|prmaps
decl_stmt|;
name|struct
name|prmap
modifier|*
name|prmap
decl_stmt|;
name|struct
name|procinfo
modifier|*
name|pi
decl_stmt|;
name|pi
operator|=
name|current_procinfo
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|map_fd
argument_list|,
name|PIOCNMAP
argument_list|,
operator|&
name|nmap
argument_list|)
operator|==
literal|0
condition|)
block|{
name|prmaps
operator|=
operator|(
expr|struct
name|prmap
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|nmap
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|prmaps
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|map_fd
argument_list|,
name|PIOCMAP
argument_list|,
name|prmaps
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|prmap
operator|=
name|prmaps
init|;
name|prmap
operator|->
name|pr_size
operator|&&
name|funcstat
operator|==
literal|0
condition|;
operator|++
name|prmap
control|)
block|{
name|fd
operator|=
name|proc_address_to_fd
argument_list|(
name|pi
argument_list|,
operator|(
name|CORE_ADDR
operator|)
name|prmap
operator|->
name|pr_vaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|funcstat
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|fd
argument_list|,
operator|(
name|CORE_ADDR
operator|)
name|prmap
operator|->
name|pr_vaddr
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|funcstat
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNIXWARE */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Currently unused */
end_comment

begin_comment
comment|/*  GLOBAL FUNCTION  	proc_base_address -- find base address for segment containing address  SYNOPSIS  	CORE_ADDR proc_base_address (CORE_ADDR addr)  DESCRIPTION  	Given an address of a location in the inferior, find and return 	the base address of the mapped segment containing that address.  	This is used for example, by the shared library support code, 	where we have the pc value for some location in the shared library 	where we are stopped, and need to know the base address of the 	segment containing that address. */
end_comment

begin_endif
unit|CORE_ADDR proc_base_address (addr)      CORE_ADDR addr; {   int nmap;   struct prmap *prmaps;   struct prmap *prmap;   CORE_ADDR baseaddr = 0;   struct procinfo *pi;    pi = current_procinfo;    if (ioctl (pi->map_fd, PIOCNMAP,&nmap) == 0)     {       prmaps = (struct prmap *) alloca ((nmap + 1) * sizeof (*prmaps));       if (ioctl (pi->map_fd, PIOCMAP, prmaps) == 0) 	{ 	  for (prmap = prmaps; prmap -> pr_size; ++prmap) 	    { 	      if ((prmap -> pr_vaddr<= (caddr_t) addr)&& 		  (prmap -> pr_vaddr + prmap -> pr_size> (caddr_t) addr)) 		{ 		  baseaddr = (CORE_ADDR) prmap -> pr_vaddr; 		  break; 		} 	    } 	}     }   return (baseaddr); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|UNIXWARE
end_ifndef

begin_comment
comment|/*  LOCAL FUNCTION  	proc_address_to_fd -- return open fd for file mapped to address  SYNOPSIS  	int proc_address_to_fd (struct procinfo *pi, CORE_ADDR addr, complain)  DESCRIPTION  	Given an address in the current inferior's address space, use the 	/proc interface to find an open file descriptor for the file that 	this address was mapped in from.  Return -1 if there is no current 	inferior.  Print a warning message if there is an inferior but 	the address corresponds to no file (IE a bogus address).  */
end_comment

begin_function
specifier|static
name|int
name|proc_address_to_fd
parameter_list|(
name|pi
parameter_list|,
name|addr
parameter_list|,
name|complain
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pi
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|complain
decl_stmt|;
block|{
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCOPENM
argument_list|,
operator|(
name|caddr_t
operator|*
operator|)
operator|&
name|addr
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|complain
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"can't find mapped file for address 0x%x"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|fd
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !UNIXWARE */
end_comment

begin_comment
comment|/* Attach to process PID, then initialize for debugging it    and wait for the trace-trap that results from attaching.  */
end_comment

begin_function
specifier|static
name|void
name|procfs_attach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
name|exec_file
decl_stmt|;
name|int
name|pid
decl_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
name|error_no_arg
argument_list|(
literal|"process-id to attach"
argument_list|)
expr_stmt|;
name|pid
operator|=
name|atoi
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
name|getpid
argument_list|()
condition|)
comment|/* Trying to masturbate? */
name|error
argument_list|(
literal|"I refuse to debug myself!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|exec_file
operator|=
operator|(
name|char
operator|*
operator|)
name|get_exec_file
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|exec_file
condition|)
name|printf_unfiltered
argument_list|(
literal|"Attaching to program `%s', %s\n"
argument_list|,
name|exec_file
argument_list|,
name|target_pid_to_str
argument_list|(
name|pid
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf_unfiltered
argument_list|(
literal|"Attaching to %s\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|pid
argument_list|)
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|inferior_pid
operator|=
name|pid
operator|=
name|do_attach
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|push_target
argument_list|(
operator|&
name|procfs_ops
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Take a program previously attached to and detaches it.    The program resumes execution and will no longer stop    on signals, etc.  We'd better not have left any breakpoints    in the program or it'll die when it hits one.  For this    to work, it may be necessary for the process to have been    previously attached.  It *might* work if the program was    started via the normal ptrace (PTRACE_TRACEME).  */
end_comment

begin_function
specifier|static
name|void
name|procfs_detach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|siggnal
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|char
modifier|*
name|exec_file
init|=
name|get_exec_file
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|exec_file
operator|==
literal|0
condition|)
name|exec_file
operator|=
literal|""
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"Detaching from program: %s %s\n"
argument_list|,
name|exec_file
argument_list|,
name|target_pid_to_str
argument_list|(
name|inferior_pid
argument_list|)
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|args
condition|)
name|siggnal
operator|=
name|atoi
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|do_detach
argument_list|(
name|siggnal
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
literal|0
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|procfs_ops
argument_list|)
expr_stmt|;
comment|/* Pop out of handling an inferior */
block|}
end_function

begin_comment
comment|/* Get ready to modify the registers array.  On machines which store    individual registers, this doesn't need to do anything.  On machines    which store all the registers in one fell swoop, this makes sure    that registers contains all the registers from the program being    debugged.  */
end_comment

begin_function
specifier|static
name|void
name|procfs_prepare_to_store
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|CHILD_PREPARE_TO_STORE
name|CHILD_PREPARE_TO_STORE
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Print status information about what we're accessing.  */
end_comment

begin_function
specifier|static
name|void
name|procfs_files_info
parameter_list|(
name|ignore
parameter_list|)
name|struct
name|target_ops
modifier|*
name|ignore
decl_stmt|;
block|{
name|printf_unfiltered
argument_list|(
literal|"\tUsing the running image of %s %s via /proc.\n"
argument_list|,
name|attach_flag
condition|?
literal|"attached"
else|:
literal|"child"
argument_list|,
name|target_pid_to_str
argument_list|(
name|inferior_pid
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|procfs_open
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|error
argument_list|(
literal|"Use the \"run\" command to start a Unix child process."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	do_attach -- attach to an already existing process  SYNOPSIS  	int do_attach (int pid)  DESCRIPTION  	Attach to an already existing process with the specified process 	id.  If the process is not already stopped, query whether to 	stop it or not.  NOTES  	The option of stopping at attach time is specific to the /proc 	versions of gdb.  Versions using ptrace force the attachee 	to stop.  (I have changed this version to do so, too.  All you 	have to do is "continue" to make it go on. -- gnu@cygnus.com)  */
end_comment

begin_function
specifier|static
name|int
name|do_attach
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|struct
name|procinfo
modifier|*
name|pi
decl_stmt|;
name|struct
name|sig_ctl
name|sctl
decl_stmt|;
name|struct
name|flt_ctl
name|fctl
decl_stmt|;
name|int
name|nlwp
decl_stmt|,
modifier|*
name|lwps
decl_stmt|;
name|pi
operator|=
name|init_procinfo
argument_list|(
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PIOCLWPIDS
name|nlwp
operator|=
name|pi
operator|->
name|prstatus
operator|.
name|pr_nlwp
expr_stmt|;
name|lwps
operator|=
name|alloca
argument_list|(
operator|(
literal|2
operator|*
name|nlwp
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|id_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCLWPIDS
argument_list|,
name|lwps
argument_list|)
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"PIOCLWPIDS failed"
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* PIOCLWPIDS */
name|nlwp
operator|=
literal|1
expr_stmt|;
name|lwps
operator|=
name|alloca
argument_list|(
operator|(
literal|2
operator|*
name|nlwp
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
expr|*
name|lwps
argument_list|)
expr_stmt|;
name|lwps
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
name|nlwp
operator|>
literal|0
condition|;
name|nlwp
operator|--
operator|,
name|lwps
operator|++
control|)
block|{
comment|/* First one has already been created above.  */
if|if
condition|(
operator|(
name|pi
operator|=
name|find_procinfo
argument_list|(
operator|(
operator|*
name|lwps
operator|<<
literal|16
operator|)
operator||
name|pid
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|pi
operator|=
name|init_procinfo
argument_list|(
operator|(
operator|*
name|lwps
operator|<<
literal|16
operator|)
operator||
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|THE_PR_LWP
argument_list|(
name|pi
operator|->
name|prstatus
argument_list|)
operator|.
name|pr_flags
operator|&
operator|(
name|PR_STOPPED
operator||
name|PR_ISTOP
operator|)
condition|)
block|{
name|pi
operator|->
name|was_stopped
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|pi
operator|->
name|was_stopped
operator|=
literal|0
expr_stmt|;
if|if
condition|(
literal|1
operator|||
name|query
argument_list|(
literal|"Process is currently running, stop it? "
argument_list|)
condition|)
block|{
name|long
name|cmd
decl_stmt|;
comment|/* Make it run again when we close it.  */
name|modify_run_on_last_close_flag
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROCFS_USE_READ_WRITE
name|cmd
operator|=
name|PCSTOP
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCSTOP
argument_list|,
operator|&
name|pi
operator|->
name|prstatus
argument_list|)
operator|<
literal|0
condition|)
endif|#
directive|endif
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|close_proc_file
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"PIOCSTOP failed"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|UNIXWARE
if|if
condition|(
operator|!
name|procfs_read_status
argument_list|(
name|pi
argument_list|)
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|close_proc_file
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"procfs_read_status failed"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|pi
operator|->
name|nopass_next_sigstop
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|printf_unfiltered
argument_list|(
literal|"Ok, gdb will wait for %s to stop.\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|pi
operator|->
name|pid
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|PROCFS_USE_READ_WRITE
name|fctl
operator|.
name|cmd
operator|=
name|PCSFAULT
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|fctl
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|flt_ctl
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|print_sys_errmsg
argument_list|(
literal|"PCSFAULT failed"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* PROCFS_USE_READ_WRITE */
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCSFAULT
argument_list|,
operator|&
name|pi
operator|->
name|prrun
operator|.
name|pr_fault
argument_list|)
condition|)
block|{
name|print_sys_errmsg
argument_list|(
literal|"PIOCSFAULT failed"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCSTRACE
argument_list|,
operator|&
name|pi
operator|->
name|prrun
operator|.
name|pr_trace
argument_list|)
condition|)
block|{
name|print_sys_errmsg
argument_list|(
literal|"PIOCSTRACE failed"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
name|add_thread
argument_list|(
name|pi
operator|->
name|pid
argument_list|)
expr_stmt|;
name|procfs_set_inferior_syscall_traps
argument_list|(
name|pi
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PROCFS_USE_READ_WRITE */
block|}
name|attach_flag
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|pi
operator|->
name|pid
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	do_detach -- detach from an attached-to process  SYNOPSIS  	void do_detach (int signal)  DESCRIPTION  	Detach from the current attachee.  	If signal is non-zero, the attachee is started running again and sent 	the specified signal.  	If signal is zero and the attachee was not already stopped when we 	attached to it, then we make it runnable again when we detach.  	Otherwise, we query whether or not to make the attachee runnable 	again, since we may simply want to leave it in the state it was in 	when we attached.  	We report any problems, but do not consider them errors, since we 	MUST detach even if some things don't seem to go right.  This may not 	be the ideal situation.  (FIXME).  */
end_comment

begin_function
specifier|static
name|void
name|do_detach
parameter_list|(
name|signal
parameter_list|)
name|int
name|signal
decl_stmt|;
block|{
name|struct
name|procinfo
modifier|*
name|pi
decl_stmt|;
for|for
control|(
name|pi
operator|=
name|procinfo_list
init|;
name|pi
condition|;
name|pi
operator|=
name|pi
operator|->
name|next
control|)
block|{
if|if
condition|(
name|signal
condition|)
block|{
name|set_proc_siginfo
argument_list|(
name|pi
argument_list|,
name|signal
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PROCFS_USE_READ_WRITE
name|pi
operator|->
name|saved_exitset
operator|.
name|cmd
operator|=
name|PCSEXIT
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pi
operator|->
name|saved_exitset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sys_ctl
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCSEXIT
argument_list|,
operator|&
name|pi
operator|->
name|saved_exitset
operator|.
name|sysset
argument_list|)
operator|<
literal|0
condition|)
endif|#
directive|endif
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"PIOCSEXIT failed.\n"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PROCFS_USE_READ_WRITE
name|pi
operator|->
name|saved_entryset
operator|.
name|cmd
operator|=
name|PCSENTRY
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pi
operator|->
name|saved_entryset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sys_ctl
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCSENTRY
argument_list|,
operator|&
name|pi
operator|->
name|saved_entryset
operator|.
name|sysset
argument_list|)
operator|<
literal|0
condition|)
endif|#
directive|endif
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"PIOCSENTRY failed.\n"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PROCFS_USE_READ_WRITE
name|pi
operator|->
name|saved_trace
operator|.
name|cmd
operator|=
name|PCSTRACE
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pi
operator|->
name|saved_trace
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sig_ctl
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCSTRACE
argument_list|,
operator|&
name|pi
operator|->
name|saved_trace
operator|.
name|sigset
argument_list|)
operator|<
literal|0
condition|)
endif|#
directive|endif
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"PIOCSTRACE failed.\n"
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|UNIXWARE
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCSHOLD
argument_list|,
operator|&
name|pi
operator|->
name|saved_sighold
operator|.
name|sigset
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"PIOSCHOLD failed.\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PROCFS_USE_READ_WRITE
name|pi
operator|->
name|saved_fltset
operator|.
name|cmd
operator|=
name|PCSFAULT
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pi
operator|->
name|saved_fltset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|flt_ctl
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCSFAULT
argument_list|,
operator|&
name|pi
operator|->
name|saved_fltset
operator|.
name|fltset
argument_list|)
operator|<
literal|0
condition|)
endif|#
directive|endif
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"PIOCSFAULT failed.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|procfs_read_status
argument_list|(
name|pi
argument_list|)
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"procfs_read_status failed.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|signal
operator|||
operator|(
name|THE_PR_LWP
argument_list|(
name|pi
operator|->
name|prstatus
argument_list|)
operator|.
name|pr_flags
operator|&
operator|(
name|PR_STOPPED
operator||
name|PR_ISTOP
operator|)
operator|)
condition|)
block|{
name|long
name|cmd
decl_stmt|;
name|struct
name|proc_ctl
name|pctl
decl_stmt|;
if|if
condition|(
name|signal
operator|||
operator|!
name|pi
operator|->
name|was_stopped
operator|||
name|query
argument_list|(
literal|"Was stopped when attached, make it runnable again? "
argument_list|)
condition|)
block|{
comment|/* Clear any pending signal if we want to detach without 		     a signal.  */
if|if
condition|(
name|signal
operator|==
literal|0
condition|)
name|set_proc_siginfo
argument_list|(
name|pi
argument_list|,
name|signal
argument_list|)
expr_stmt|;
comment|/* Clear any fault that might have stopped it.  */
ifdef|#
directive|ifdef
name|PROCFS_USE_READ_WRITE
name|cmd
operator|=
name|PCCFAULT
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCCFAULT
argument_list|,
literal|0
argument_list|)
condition|)
endif|#
directive|endif
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"PIOCCFAULT failed.\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Make it run again when we close it.  */
name|modify_run_on_last_close_flag
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|close_proc_file
argument_list|(
name|pi
argument_list|)
expr_stmt|;
block|}
name|attach_flag
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  emulate wait() as much as possible.     Wait for child to do something.  Return pid of child, or -1 in case     of error; store status in *OURSTATUS.      Not sure why we can't     just use wait(), but it seems to have problems when applied to a     process being controlled with the /proc interface.      We have a race problem here with no obvious solution.  We need to let     the inferior run until it stops on an event of interest, which means     that we need to use the PIOCWSTOP ioctl.  However, we cannot use this     ioctl if the process is already stopped on something that is not an     event of interest, or the call will hang indefinitely.  Thus we first     use PIOCSTATUS to see if the process is not stopped.  If not, then we     use PIOCWSTOP.  But during the window between the two, if the process     stops for any reason that is not an event of interest (such as a job     control signal) then gdb will hang.  One possible workaround is to set     an alarm to wake up every minute of so and check to see if the process     is still running, and if so, then reissue the PIOCWSTOP.  But this is     a real kludge, so has not been implemented.  FIXME: investigate     alternatives.      FIXME:  Investigate why wait() seems to have problems with programs     being control by /proc routines.  */
end_comment

begin_function
specifier|static
name|int
name|procfs_wait
parameter_list|(
name|pid
parameter_list|,
name|ourstatus
parameter_list|)
name|int
name|pid
decl_stmt|;
name|struct
name|target_waitstatus
modifier|*
name|ourstatus
decl_stmt|;
block|{
name|short
name|what
decl_stmt|;
name|short
name|why
decl_stmt|;
name|int
name|statval
init|=
literal|0
decl_stmt|;
name|int
name|checkerr
init|=
literal|0
decl_stmt|;
name|int
name|rtnval
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|procinfo
modifier|*
name|pi
decl_stmt|;
name|struct
name|proc_ctl
name|pctl
decl_stmt|;
name|scan_again
label|:
comment|/* handle all syscall events first, otherwise we might not      notice a thread was created until too late. */
for|for
control|(
name|pi
operator|=
name|procinfo_list
init|;
name|pi
condition|;
name|pi
operator|=
name|pi
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|pi
operator|->
name|had_event
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|THE_PR_LWP
argument_list|(
name|pi
operator|->
name|prstatus
argument_list|)
operator|.
name|pr_flags
operator|&
operator|(
name|PR_STOPPED
operator||
name|PR_ISTOP
operator|)
operator|)
condition|)
continue|continue;
name|why
operator|=
name|THE_PR_LWP
argument_list|(
name|pi
operator|->
name|prstatus
argument_list|)
operator|.
name|pr_why
expr_stmt|;
name|what
operator|=
name|THE_PR_LWP
argument_list|(
name|pi
operator|->
name|prstatus
argument_list|)
operator|.
name|pr_what
expr_stmt|;
if|if
condition|(
name|why
operator|==
name|PR_SYSENTRY
operator|||
name|why
operator|==
name|PR_SYSEXIT
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|found_handler
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pi
operator|->
name|num_syscall_handlers
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pi
operator|->
name|syscall_handlers
index|[
name|i
index|]
operator|.
name|syscall_num
operator|==
name|what
condition|)
block|{
name|found_handler
operator|=
literal|1
expr_stmt|;
name|pi
operator|->
name|saved_rtnval
operator|=
name|pi
operator|->
name|pid
expr_stmt|;
name|pi
operator|->
name|saved_statval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|pi
operator|->
name|syscall_handlers
index|[
name|i
index|]
operator|.
name|func
argument_list|(
name|pi
argument_list|,
name|what
argument_list|,
name|why
argument_list|,
operator|&
name|pi
operator|->
name|saved_rtnval
argument_list|,
operator|&
name|pi
operator|->
name|saved_statval
argument_list|)
condition|)
name|pi
operator|->
name|had_event
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|found_handler
condition|)
block|{
if|if
condition|(
name|why
operator|==
name|PR_SYSENTRY
condition|)
name|error
argument_list|(
literal|"PR_SYSENTRY, unhandled system call %d"
argument_list|,
name|what
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"PR_SYSEXIT, unhandled system call %d"
argument_list|,
name|what
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* find a relevant process with an event */
for|for
control|(
name|pi
operator|=
name|procinfo_list
init|;
name|pi
condition|;
name|pi
operator|=
name|pi
operator|->
name|next
control|)
if|if
condition|(
name|pi
operator|->
name|had_event
operator|&&
operator|(
name|pid
operator|==
operator|-
literal|1
operator|||
name|pi
operator|->
name|pid
operator|==
name|pid
operator|)
condition|)
break|break;
if|if
condition|(
operator|!
name|pi
condition|)
block|{
name|wait_fd
argument_list|()
expr_stmt|;
goto|goto
name|scan_again
goto|;
block|}
if|if
condition|(
operator|!
name|checkerr
operator|&&
operator|!
operator|(
name|THE_PR_LWP
argument_list|(
name|pi
operator|->
name|prstatus
argument_list|)
operator|.
name|pr_flags
operator|&
operator|(
name|PR_STOPPED
operator||
name|PR_ISTOP
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|procfs_write_pcwstop
argument_list|(
name|pi
argument_list|)
condition|)
block|{
name|checkerr
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|checkerr
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
comment|/* XXX Fixme -- what to do if attached?  Can't call wait... */
name|rtnval
operator|=
name|wait
argument_list|(
operator|&
name|statval
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rtnval
operator|)
operator|!=
operator|(
name|PIDGET
argument_list|(
name|inferior_pid
argument_list|)
operator|)
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"procfs_wait: wait failed, returned %d"
argument_list|,
name|rtnval
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
else|else
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"PIOCSTATUS or PIOCWSTOP failed."
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
elseif|else
if|if
condition|(
name|THE_PR_LWP
argument_list|(
name|pi
operator|->
name|prstatus
argument_list|)
operator|.
name|pr_flags
operator|&
operator|(
name|PR_STOPPED
operator||
name|PR_ISTOP
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|UNIXWARE
name|rtnval
operator|=
name|pi
operator|->
name|prstatus
operator|.
name|pr_pid
expr_stmt|;
else|#
directive|else
name|rtnval
operator|=
name|pi
operator|->
name|pid
expr_stmt|;
endif|#
directive|endif
name|why
operator|=
name|THE_PR_LWP
argument_list|(
name|pi
operator|->
name|prstatus
argument_list|)
operator|.
name|pr_why
expr_stmt|;
name|what
operator|=
name|THE_PR_LWP
argument_list|(
name|pi
operator|->
name|prstatus
argument_list|)
operator|.
name|pr_what
expr_stmt|;
switch|switch
condition|(
name|why
condition|)
block|{
case|case
name|PR_SIGNALLED
case|:
name|statval
operator|=
operator|(
name|what
operator|<<
literal|8
operator|)
operator||
literal|0177
expr_stmt|;
break|break;
case|case
name|PR_SYSENTRY
case|:
case|case
name|PR_SYSEXIT
case|:
name|rtnval
operator|=
name|pi
operator|->
name|saved_rtnval
expr_stmt|;
name|statval
operator|=
name|pi
operator|->
name|saved_statval
expr_stmt|;
break|break;
case|case
name|PR_REQUESTED
case|:
name|statval
operator|=
operator|(
name|SIGSTOP
operator|<<
literal|8
operator|)
operator||
literal|0177
expr_stmt|;
break|break;
case|case
name|PR_JOBCONTROL
case|:
name|statval
operator|=
operator|(
name|what
operator|<<
literal|8
operator|)
operator||
literal|0177
expr_stmt|;
break|break;
case|case
name|PR_FAULTED
case|:
switch|switch
condition|(
name|what
condition|)
block|{
ifdef|#
directive|ifdef
name|FLTWATCH
case|case
name|FLTWATCH
case|:
name|statval
operator|=
operator|(
name|SIGTRAP
operator|<<
literal|8
operator|)
operator||
literal|0177
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FLTKWATCH
case|case
name|FLTKWATCH
case|:
name|statval
operator|=
operator|(
name|SIGTRAP
operator|<<
literal|8
operator|)
operator||
literal|0177
expr_stmt|;
break|break;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|FAULTED_USE_SIGINFO
comment|/* Irix, contrary to the documentation, fills in 0 for si_signo. 		 Solaris fills in si_signo.  I'm not sure about others.  */
case|case
name|FLTPRIV
case|:
case|case
name|FLTILL
case|:
name|statval
operator|=
operator|(
name|SIGILL
operator|<<
literal|8
operator|)
operator||
literal|0177
expr_stmt|;
break|break;
case|case
name|FLTBPT
case|:
case|case
name|FLTTRACE
case|:
name|statval
operator|=
operator|(
name|SIGTRAP
operator|<<
literal|8
operator|)
operator||
literal|0177
expr_stmt|;
break|break;
case|case
name|FLTSTACK
case|:
case|case
name|FLTACCESS
case|:
case|case
name|FLTBOUNDS
case|:
name|statval
operator|=
operator|(
name|SIGSEGV
operator|<<
literal|8
operator|)
operator||
literal|0177
expr_stmt|;
break|break;
case|case
name|FLTIOVF
case|:
case|case
name|FLTIZDIV
case|:
case|case
name|FLTFPE
case|:
name|statval
operator|=
operator|(
name|SIGFPE
operator|<<
literal|8
operator|)
operator||
literal|0177
expr_stmt|;
break|break;
case|case
name|FLTPAGE
case|:
comment|/* Recoverable page fault */
endif|#
directive|endif
comment|/* not FAULTED_USE_SIGINFO */
default|default:
comment|/* Use the signal which the kernel assigns.  This is better than 		 trying to second-guess it from the fault.  In fact, I suspect 		 that FLTACCESS can be either SIGSEGV or SIGBUS.  */
name|statval
operator|=
operator|(
operator|(
name|THE_PR_LWP
argument_list|(
name|pi
operator|->
name|prstatus
argument_list|)
operator|.
name|pr_info
operator|.
name|si_signo
operator|)
operator|<<
literal|8
operator|)
operator||
literal|0177
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|error
argument_list|(
literal|"PIOCWSTOP, unknown why %d, what %d"
argument_list|,
name|why
argument_list|,
name|what
argument_list|)
expr_stmt|;
block|}
comment|/* Stop all the other threads when any of them stops.  */
block|{
name|struct
name|procinfo
modifier|*
name|procinfo
decl_stmt|,
modifier|*
name|next_pi
decl_stmt|;
for|for
control|(
name|procinfo
operator|=
name|procinfo_list
init|;
name|procinfo
condition|;
name|procinfo
operator|=
name|next_pi
control|)
block|{
name|next_pi
operator|=
name|procinfo
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|procinfo
operator|->
name|had_event
condition|)
block|{
ifdef|#
directive|ifdef
name|PROCFS_USE_READ_WRITE
name|long
name|cmd
init|=
name|PCSTOP
decl_stmt|;
if|if
condition|(
name|write
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|procinfo
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"PCSTOP failed"
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* A bug in Solaris (2.5) causes us to hang when trying to 		   stop a stopped process.  So, we have to check first in 		   order to avoid the hang. */
if|if
condition|(
operator|!
name|procfs_read_status
argument_list|(
name|procinfo
argument_list|)
condition|)
block|{
comment|/* The LWP has apparently terminated.  */
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"LWP %d doesn't respond.\n"
argument_list|,
operator|(
name|procinfo
operator|->
name|pid
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|close_proc_file
argument_list|(
name|procinfo
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
operator|(
name|procinfo
operator|->
name|prstatus
operator|.
name|pr_flags
operator|&
name|PR_STOPPED
operator|)
condition|)
if|if
condition|(
name|ioctl
argument_list|(
name|procinfo
operator|->
name|ctl_fd
argument_list|,
name|PIOCSTOP
argument_list|,
operator|&
name|procinfo
operator|->
name|prstatus
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|procinfo
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"PIOCSTOP failed"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
block|}
block|}
else|else
block|{
name|error
argument_list|(
literal|"PIOCWSTOP, stopped for unknown/unhandled reason, flags %#x"
argument_list|,
name|THE_PR_LWP
argument_list|(
name|pi
operator|->
name|prstatus
argument_list|)
operator|.
name|pr_flags
argument_list|)
expr_stmt|;
block|}
name|store_waitstatus
argument_list|(
name|ourstatus
argument_list|,
name|statval
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtnval
operator|==
operator|-
literal|1
condition|)
comment|/* No more children to wait for */
block|{
name|warning
argument_list|(
literal|"Child process unexpectedly missing"
argument_list|)
expr_stmt|;
comment|/* Claim it exited with unknown signal.  */
name|ourstatus
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_SIGNALLED
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_UNKNOWN
expr_stmt|;
return|return
name|rtnval
return|;
block|}
name|pi
operator|->
name|had_event
operator|=
literal|0
expr_stmt|;
comment|/* Indicate that we've seen this one */
return|return
operator|(
name|rtnval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	set_proc_siginfo - set a process's current signal info  SYNOPSIS  	void set_proc_siginfo (struct procinfo *pip, int signo);  DESCRIPTION  	Given a pointer to a process info struct in PIP and a signal number 	in SIGNO, set the process's current signal and its associated signal 	information.  The signal will be delivered to the process immediately 	after execution is resumed, even if it is being held.  In addition, 	this particular delivery will not cause another PR_SIGNALLED stop 	even if the signal is being traced.  	If we are not delivering the same signal that the prstatus siginfo 	struct contains information about, then synthesize a siginfo struct 	to match the signal we are doing to deliver, make it of the type 	"generated by a user process", and send this synthesized copy.  When 	used to set the inferior's signal state, this will be required if we 	are not currently stopped because of a traced signal, or if we decide 	to continue with a different signal.  	Note that when continuing the inferior from a stop due to receipt 	of a traced signal, we either have set PRCSIG to clear the existing 	signal, or we have to call this function to do a PIOCSSIG with either 	the existing siginfo struct from pr_info, or one we have synthesized 	appropriately for the signal we want to deliver.  Otherwise if the 	signal is still being traced, the inferior will immediately stop 	again.  	See siginfo(5) for more details. */
end_comment

begin_function
specifier|static
name|void
name|set_proc_siginfo
parameter_list|(
name|pip
parameter_list|,
name|signo
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pip
decl_stmt|;
name|int
name|signo
decl_stmt|;
block|{
name|struct
name|siginfo
name|newsiginfo
decl_stmt|;
name|struct
name|siginfo
modifier|*
name|sip
decl_stmt|;
name|struct
name|sigi_ctl
name|sictl
decl_stmt|;
ifdef|#
directive|ifdef
name|PROCFS_DONT_PIOCSSIG_CURSIG
comment|/* With Alpha OSF/1 procfs, the kernel gets really confused if it      receives a PIOCSSIG with a signal identical to the current signal,      it messes up the current signal. Work around the kernel bug.  */
if|if
condition|(
name|signo
operator|==
name|THE_PR_LWP
argument_list|(
name|pip
operator|->
name|prstatus
argument_list|)
operator|.
name|pr_cursig
condition|)
return|return;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UNIXWARE
if|if
condition|(
name|signo
operator|==
name|THE_PR_LWP
argument_list|(
name|pip
operator|->
name|prstatus
argument_list|)
operator|.
name|pr_info
operator|.
name|si_signo
condition|)
block|{
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sictl
operator|.
name|siginfo
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pip
operator|->
name|prstatus
operator|.
name|pr_lwp
operator|.
name|pr_info
argument_list|,
sizeof|sizeof
argument_list|(
name|siginfo_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|signo
operator|==
name|THE_PR_LWP
argument_list|(
name|pip
operator|->
name|prstatus
argument_list|)
operator|.
name|pr_info
operator|.
name|si_signo
condition|)
block|{
name|sip
operator|=
operator|&
name|pip
operator|->
name|prstatus
operator|.
name|pr_info
expr_stmt|;
block|}
endif|#
directive|endif
else|else
block|{
ifdef|#
directive|ifdef
name|UNIXWARE
name|siginfo_t
modifier|*
name|sip
init|=
operator|&
name|sictl
operator|.
name|siginfo
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sip
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|siginfo_t
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|newsiginfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|newsiginfo
argument_list|)
argument_list|)
expr_stmt|;
name|sip
operator|=
operator|&
name|newsiginfo
expr_stmt|;
endif|#
directive|endif
name|sip
operator|->
name|si_signo
operator|=
name|signo
expr_stmt|;
name|sip
operator|->
name|si_code
operator|=
literal|0
expr_stmt|;
name|sip
operator|->
name|si_errno
operator|=
literal|0
expr_stmt|;
name|sip
operator|->
name|si_pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|sip
operator|->
name|si_uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PROCFS_USE_READ_WRITE
name|sictl
operator|.
name|cmd
operator|=
name|PCSSIG
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|pip
operator|->
name|ctl_fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sictl
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sigi_ctl
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|ioctl
argument_list|(
name|pip
operator|->
name|ctl_fd
argument_list|,
name|PIOCSSIG
argument_list|,
name|sip
argument_list|)
operator|<
literal|0
condition|)
endif|#
directive|endif
block|{
name|print_sys_errmsg
argument_list|(
name|pip
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"PIOCSSIG failed"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Resume execution of process PID.  If STEP is nozero, then    just single step it.  If SIGNAL is nonzero, restart it with that    signal activated.  */
end_comment

begin_function
specifier|static
name|void
name|procfs_resume
parameter_list|(
name|pid
parameter_list|,
name|step
parameter_list|,
name|signo
parameter_list|)
name|int
name|pid
decl_stmt|;
name|int
name|step
decl_stmt|;
name|enum
name|target_signal
name|signo
decl_stmt|;
block|{
name|int
name|signal_to_pass
decl_stmt|;
name|struct
name|procinfo
modifier|*
name|pi
decl_stmt|,
modifier|*
name|procinfo
decl_stmt|,
modifier|*
name|next_pi
decl_stmt|;
name|struct
name|proc_ctl
name|pctl
decl_stmt|;
name|pi
operator|=
name|find_procinfo
argument_list|(
name|pid
operator|==
operator|-
literal|1
condition|?
name|inferior_pid
else|:
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|UNIXWARE
name|pctl
operator|.
name|cmd
operator|=
name|PCRUN
expr_stmt|;
name|pctl
operator|.
name|data
operator|=
name|PRCFAULT
expr_stmt|;
else|#
directive|else
name|pi
operator|->
name|prrun
operator|.
name|pr_flags
operator|=
name|PRSTRACE
operator||
name|PRSFAULT
operator||
name|PRCFAULT
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
comment|/* It should not be necessary.  If the user explicitly changes the value,      value_assign calls write_register_bytes, which writes it.  */
comment|/*	It may not be absolutely necessary to specify the PC value for 	restarting, but to be safe we use the value that gdb considers 	to be current.  One case where this might be necessary is if the 	user explicitly changes the PC value that gdb considers to be 	current.  FIXME:  Investigate if this is necessary or not.  */
ifdef|#
directive|ifdef
name|PRSVADDR_BROKEN
comment|/* Can't do this under Solaris running on a Sparc, as there seems to be no    place to put nPC.  In fact, if you use this, nPC seems to be set to some    random garbage.  We have to rely on the fact that PC and nPC have been    written previously via PIOCSREG during a register flush. */
block|pi->prrun.pr_vaddr = (caddr_t) *(int *)&registers[REGISTER_BYTE (PC_REGNUM)];   pi->prrun.pr_flags != PRSVADDR;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|signo
operator|==
name|TARGET_SIGNAL_STOP
operator|&&
name|pi
operator|->
name|nopass_next_sigstop
condition|)
comment|/* When attaching to a child process, if we forced it to stop with        a PIOCSTOP, then we will have set the nopass_next_sigstop flag.        Upon resuming the first time after such a stop, we explicitly        inhibit sending it another SIGSTOP, which would be the normal        result of default signal handling.  One potential drawback to        this is that we will also ignore any attempt to by the user        to explicitly continue after the attach with a SIGSTOP.  Ultimately        this problem should be dealt with by making the routines that        deal with the inferior a little smarter, and possibly even allow        an inferior to continue running at the same time as gdb.  (FIXME?)  */
name|signal_to_pass
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|signo
operator|==
name|TARGET_SIGNAL_TSTP
operator|&&
name|THE_PR_LWP
argument_list|(
name|pi
operator|->
name|prstatus
argument_list|)
operator|.
name|pr_cursig
operator|==
name|SIGTSTP
operator|&&
name|THE_PR_LWP
argument_list|(
name|pi
operator|->
name|prstatus
argument_list|)
operator|.
name|pr_action
operator|.
name|sa_handler
operator|==
name|SIG_DFL
condition|)
comment|/* We are about to pass the inferior a SIGTSTP whose action is        SIG_DFL.  The SIG_DFL action for a SIGTSTP is to stop        (notifying the parent via wait()), and then keep going from the        same place when the parent is ready for you to keep going.  So        under the debugger, it should do nothing (as if the program had        been stopped and then later resumed.  Under ptrace, this        happens for us, but under /proc, the system obligingly stops        the process, and wait_for_inferior would have no way of        distinguishing that type of stop (which indicates that we        should just start it again), with a stop due to the pr_trace        field of the prrun_t struct.         Note that if the SIGTSTP is being caught, we *do* need to pass it,        because the handler needs to get executed.  */
name|signal_to_pass
operator|=
literal|0
expr_stmt|;
else|else
name|signal_to_pass
operator|=
name|target_signal_to_host
argument_list|(
name|signo
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal_to_pass
condition|)
block|{
name|set_proc_siginfo
argument_list|(
name|pi
argument_list|,
name|signal_to_pass
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|UNIXWARE
name|pctl
operator|.
name|data
operator||=
name|PRCSIG
expr_stmt|;
else|#
directive|else
name|pi
operator|->
name|prrun
operator|.
name|pr_flags
operator||=
name|PRCSIG
expr_stmt|;
endif|#
directive|endif
block|}
name|pi
operator|->
name|nopass_next_sigstop
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|step
condition|)
block|{
ifdef|#
directive|ifdef
name|UNIXWARE
name|pctl
operator|.
name|data
operator||=
name|PRSTEP
expr_stmt|;
else|#
directive|else
name|pi
operator|->
name|prrun
operator|.
name|pr_flags
operator||=
name|PRSTEP
expr_stmt|;
endif|#
directive|endif
block|}
name|pi
operator|->
name|had_event
operator|=
literal|0
expr_stmt|;
comment|/* Don't try to start a process unless it's stopped on an      `event of interest'.  Doing so will cause errors.  */
if|if
condition|(
operator|!
name|procfs_read_status
argument_list|(
name|pi
argument_list|)
condition|)
block|{
comment|/* The LWP has apparently terminated.  */
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"LWP %d doesn't respond.\n"
argument_list|,
operator|(
name|pi
operator|->
name|pid
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|close_proc_file
argument_list|(
name|pi
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|PROCFS_USE_READ_WRITE
if|if
condition|(
name|write
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pctl
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|proc_ctl
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
else|#
directive|else
if|if
condition|(
operator|(
name|pi
operator|->
name|prstatus
operator|.
name|pr_flags
operator|&
name|PR_ISTOP
operator|)
operator|&&
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCRUN
argument_list|,
operator|&
name|pi
operator|->
name|prrun
argument_list|)
operator|!=
literal|0
condition|)
endif|#
directive|endif
block|{
comment|/* The LWP has apparently terminated.  */
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"LWP %d doesn't respond.\n"
argument_list|,
operator|(
name|pi
operator|->
name|pid
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|close_proc_file
argument_list|(
name|pi
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Continue all the other threads that haven't had an event of interest.      Also continue them if they have NOPASS_NEXT_SIGSTOP set; this is only      set by do_attach, and means this is the first resume after an attach.        All threads were CSTOP'd by do_attach, and should be resumed now.  */
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
for|for
control|(
name|procinfo
operator|=
name|procinfo_list
init|;
name|procinfo
condition|;
name|procinfo
operator|=
name|next_pi
control|)
block|{
name|next_pi
operator|=
name|procinfo
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|pi
operator|!=
name|procinfo
condition|)
if|if
condition|(
operator|!
name|procinfo
operator|->
name|had_event
operator|||
operator|(
name|procinfo
operator|->
name|nopass_next_sigstop
operator|&&
name|signo
operator|==
name|TARGET_SIGNAL_STOP
operator|)
condition|)
block|{
name|procinfo
operator|->
name|had_event
operator|=
name|procinfo
operator|->
name|nopass_next_sigstop
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|PROCFS_USE_READ_WRITE
name|pctl
operator|.
name|data
operator|=
name|PRCFAULT
operator||
name|PRCSIG
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|procinfo
operator|->
name|ctl_fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pctl
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|proc_ctl
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|procfs_read_status
argument_list|(
name|procinfo
argument_list|)
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"procfs_read_status failed, errno=%d\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|print_sys_errmsg
argument_list|(
name|procinfo
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"PCRUN failed"
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|procinfo
operator|->
name|prrun
operator|.
name|pr_flags
operator|&=
name|PRSTEP
expr_stmt|;
name|procinfo
operator|->
name|prrun
operator|.
name|pr_flags
operator||=
name|PRCFAULT
operator||
name|PRCSIG
expr_stmt|;
if|if
condition|(
operator|!
name|procfs_read_status
argument_list|(
name|procinfo
argument_list|)
condition|)
block|{
comment|/* The LWP has apparently terminated.  */
if|if
condition|(
name|info_verbose
condition|)
name|printf_filtered
argument_list|(
literal|"LWP %d doesn't respond.\n"
argument_list|,
operator|(
name|procinfo
operator|->
name|pid
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|close_proc_file
argument_list|(
name|procinfo
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Don't try to start a process unless it's stopped on an 		 `event of interest'.  Doing so will cause errors.  */
if|if
condition|(
operator|(
name|procinfo
operator|->
name|prstatus
operator|.
name|pr_flags
operator|&
name|PR_ISTOP
operator|)
operator|&&
name|ioctl
argument_list|(
name|procinfo
operator|->
name|ctl_fd
argument_list|,
name|PIOCRUN
argument_list|,
operator|&
name|procinfo
operator|->
name|prrun
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|procfs_read_status
argument_list|(
name|procinfo
argument_list|)
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"procfs_read_status failed, errno=%d\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|print_sys_errmsg
argument_list|(
name|procinfo
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"PIOCRUN failed"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|procfs_read_status
argument_list|(
name|procinfo
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	procfs_fetch_registers -- fetch current registers from inferior  SYNOPSIS  	void procfs_fetch_registers (int regno)  DESCRIPTION  	Read the current values of the inferior's registers, both the 	general register set and floating point registers (if supported) 	and update gdb's idea of their current values.  */
end_comment

begin_function
specifier|static
name|void
name|procfs_fetch_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|struct
name|procinfo
modifier|*
name|pi
decl_stmt|;
name|pi
operator|=
name|current_procinfo
expr_stmt|;
ifdef|#
directive|ifdef
name|UNIXWARE
if|if
condition|(
name|procfs_read_status
argument_list|(
name|pi
argument_list|)
condition|)
block|{
name|supply_gregset
argument_list|(
operator|&
name|pi
operator|->
name|prstatus
operator|.
name|pr_lwp
operator|.
name|pr_context
operator|.
name|uc_mcontext
operator|.
name|gregs
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|FP0_REGNUM
argument_list|)
name|supply_fpregset
argument_list|(
operator|&
name|pi
operator|->
name|prstatus
operator|.
name|pr_lwp
operator|.
name|pr_context
operator|.
name|uc_mcontext
operator|.
name|fpregs
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|#
directive|else
comment|/* UNIXWARE */
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCGREG
argument_list|,
operator|&
name|pi
operator|->
name|gregset
operator|.
name|gregset
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|supply_gregset
argument_list|(
operator|&
name|pi
operator|->
name|gregset
operator|.
name|gregset
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|FP0_REGNUM
argument_list|)
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCGFPREG
argument_list|,
operator|&
name|pi
operator|->
name|fpregset
operator|.
name|fpregset
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|supply_fpregset
argument_list|(
operator|&
name|pi
operator|->
name|fpregset
operator|.
name|fpregset
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* UNIXWARE */
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	proc_init_failed - called when /proc access initialization fails fails  SYNOPSIS  	static void proc_init_failed (struct procinfo *pi,  				      char *why, int kill_p)  DESCRIPTION  	This function is called whenever initialization of access to a /proc 	entry fails.  It prints a suitable error message, does some cleanup, 	and then invokes the standard error processing routine which dumps 	us back into the command loop.  If KILL_P is true, sends SIGKILL.  */
end_comment

begin_function
specifier|static
name|void
name|proc_init_failed
parameter_list|(
name|pi
parameter_list|,
name|why
parameter_list|,
name|kill_p
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pi
decl_stmt|;
name|char
modifier|*
name|why
decl_stmt|;
name|int
name|kill_p
decl_stmt|;
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
if|if
condition|(
name|kill_p
condition|)
name|kill
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
name|close_proc_file
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|why
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	close_proc_file - close any currently open /proc entry  SYNOPSIS  	static void close_proc_file (struct procinfo *pip)  DESCRIPTION  	Close any currently open /proc entry and mark the process information 	entry as invalid.  In order to ensure that we don't try to reuse any 	stale information, the pid, fd, and pathnames are explicitly 	invalidated, which may be overkill.   */
end_comment

begin_function
specifier|static
name|void
name|close_proc_file
parameter_list|(
name|pip
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pip
decl_stmt|;
block|{
name|struct
name|procinfo
modifier|*
name|procinfo
decl_stmt|;
name|delete_thread
argument_list|(
name|pip
operator|->
name|pid
argument_list|)
expr_stmt|;
comment|/* remove thread from GDB's thread list */
name|remove_fd
argument_list|(
name|pip
argument_list|)
expr_stmt|;
comment|/* Remove fd from poll/select list */
name|close
argument_list|(
name|pip
operator|->
name|ctl_fd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_MULTIPLE_PROC_FDS
name|close
argument_list|(
name|pip
operator|->
name|as_fd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pip
operator|->
name|status_fd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pip
operator|->
name|map_fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|pip
operator|->
name|pathname
argument_list|)
expr_stmt|;
comment|/* Unlink pip from the procinfo chain.  Note pip might not be on the list. */
if|if
condition|(
name|procinfo_list
operator|==
name|pip
condition|)
name|procinfo_list
operator|=
name|pip
operator|->
name|next
expr_stmt|;
else|else
block|{
for|for
control|(
name|procinfo
operator|=
name|procinfo_list
init|;
name|procinfo
condition|;
name|procinfo
operator|=
name|procinfo
operator|->
name|next
control|)
block|{
if|if
condition|(
name|procinfo
operator|->
name|next
operator|==
name|pip
condition|)
block|{
name|procinfo
operator|->
name|next
operator|=
name|pip
operator|->
name|next
expr_stmt|;
break|break;
block|}
block|}
name|free
argument_list|(
name|pip
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	open_proc_file - open a /proc entry for a given process id  SYNOPSIS  	static int open_proc_file (int pid, struct procinfo *pip, int mode)  DESCRIPTION  	Given a process id and a mode, close the existing open /proc 	entry (if any) and open one for the new process id, in the 	specified mode.  Once it is open, then mark the local process 	information structure as valid, which guarantees that the pid, 	fd, and pathname fields match an open /proc entry.  Returns 	zero if the open fails, nonzero otherwise.  	Note that the pathname is left intact, even when the open fails, 	so that callers can use it to construct meaningful error messages 	rather than just "file open failed".  	Note that for Solaris, the process-id also includes an LWP-id, so we 	actually attempt to open that.  If we are handed a pid with a 0 LWP-id, 	then we will ask the kernel what it is and add it to the pid.  Hence, 	the pid can be changed by us.  */
end_comment

begin_function
specifier|static
name|int
name|open_proc_file
parameter_list|(
name|pid
parameter_list|,
name|pip
parameter_list|,
name|mode
parameter_list|,
name|control
parameter_list|)
name|int
name|pid
decl_stmt|;
name|struct
name|procinfo
modifier|*
name|pip
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|control
decl_stmt|;
block|{
name|int
name|tmp
decl_stmt|,
name|tmpfd
decl_stmt|;
name|pip
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|pip
operator|->
name|had_event
operator|=
literal|0
expr_stmt|;
name|pip
operator|->
name|pathname
operator|=
name|xmalloc
argument_list|(
name|MAX_PROC_NAME_SIZE
argument_list|)
expr_stmt|;
name|pip
operator|->
name|pid
operator|=
name|pid
expr_stmt|;
ifndef|#
directive|ifndef
name|PIOCOPENLWP
name|tmp
operator|=
name|pid
expr_stmt|;
else|#
directive|else
name|tmp
operator|=
name|pid
operator|&
literal|0xffff
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_MULTIPLE_PROC_FDS
name|sprintf
argument_list|(
name|pip
operator|->
name|pathname
argument_list|,
name|STATUS_PROC_NAME_FMT
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pip
operator|->
name|status_fd
operator|=
name|open
argument_list|(
name|pip
operator|->
name|pathname
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|sprintf
argument_list|(
name|pip
operator|->
name|pathname
argument_list|,
name|AS_PROC_NAME_FMT
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pip
operator|->
name|as_fd
operator|=
name|open
argument_list|(
name|pip
operator|->
name|pathname
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|pip
operator|->
name|status_fd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sprintf
argument_list|(
name|pip
operator|->
name|pathname
argument_list|,
name|MAP_PROC_NAME_FMT
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pip
operator|->
name|map_fd
operator|=
name|open
argument_list|(
name|pip
operator|->
name|pathname
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|pip
operator|->
name|status_fd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pip
operator|->
name|as_fd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|control
condition|)
block|{
name|sprintf
argument_list|(
name|pip
operator|->
name|pathname
argument_list|,
name|CTL_PROC_NAME_FMT
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pip
operator|->
name|ctl_fd
operator|=
name|open
argument_list|(
name|pip
operator|->
name|pathname
argument_list|,
name|O_WRONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|pip
operator|->
name|status_fd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pip
operator|->
name|as_fd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pip
operator|->
name|map_fd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|#
directive|else
comment|/* HAVE_MULTIPLE_PROC_FDS */
name|sprintf
argument_list|(
name|pip
operator|->
name|pathname
argument_list|,
name|CTL_PROC_NAME_FMT
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmpfd
operator|=
name|open
argument_list|(
name|pip
operator|->
name|pathname
argument_list|,
name|mode
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
ifndef|#
directive|ifndef
name|PIOCOPENLWP
name|pip
operator|->
name|ctl_fd
operator|=
name|tmpfd
expr_stmt|;
name|pip
operator|->
name|as_fd
operator|=
name|tmpfd
expr_stmt|;
name|pip
operator|->
name|map_fd
operator|=
name|tmpfd
expr_stmt|;
name|pip
operator|->
name|status_fd
operator|=
name|tmpfd
expr_stmt|;
else|#
directive|else
name|tmp
operator|=
operator|(
name|pid
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
expr_stmt|;
comment|/* Extract thread id */
if|if
condition|(
name|tmp
operator|==
literal|0
condition|)
block|{
comment|/* Don't know thread id yet */
if|if
condition|(
name|ioctl
argument_list|(
name|tmpfd
argument_list|,
name|PIOCSTATUS
argument_list|,
operator|&
name|pip
operator|->
name|prstatus
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pip
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|tmpfd
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"open_proc_file: PIOCSTATUS failed"
argument_list|)
expr_stmt|;
block|}
name|tmp
operator|=
name|pip
operator|->
name|prstatus
operator|.
name|pr_who
expr_stmt|;
comment|/* Get thread id from prstatus_t */
name|pip
operator|->
name|pid
operator|=
operator|(
name|tmp
operator|<<
literal|16
operator|)
operator||
name|pid
expr_stmt|;
comment|/* Update pip */
block|}
if|if
condition|(
operator|(
name|pip
operator|->
name|ctl_fd
operator|=
name|ioctl
argument_list|(
name|tmpfd
argument_list|,
name|PIOCOPENLWP
argument_list|,
operator|&
name|tmp
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|close
argument_list|(
name|tmpfd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|PIOCSET
comment|/* New method */
block|{
name|long
name|pr_flags
decl_stmt|;
name|pr_flags
operator|=
name|PR_ASYNC
expr_stmt|;
name|ioctl
argument_list|(
name|pip
operator|->
name|ctl_fd
argument_list|,
name|PIOCSET
argument_list|,
operator|&
name|pr_flags
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* keep extra fds in sync */
name|pip
operator|->
name|as_fd
operator|=
name|pip
operator|->
name|ctl_fd
expr_stmt|;
name|pip
operator|->
name|map_fd
operator|=
name|pip
operator|->
name|ctl_fd
expr_stmt|;
name|pip
operator|->
name|status_fd
operator|=
name|pip
operator|->
name|ctl_fd
expr_stmt|;
name|close
argument_list|(
name|tmpfd
argument_list|)
expr_stmt|;
comment|/* All done with main pid */
endif|#
directive|endif
comment|/* PIOCOPENLWP */
endif|#
directive|endif
comment|/* HAVE_MULTIPLE_PROC_FDS */
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|mappingflags
parameter_list|(
name|flags
parameter_list|)
name|long
name|flags
decl_stmt|;
block|{
specifier|static
name|char
name|asciiflags
index|[
literal|8
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|asciiflags
argument_list|,
literal|"-------"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MA_PHYS
argument_list|)
if|if
condition|(
name|flags
operator|&
name|MA_PHYS
condition|)
name|asciiflags
index|[
literal|0
index|]
operator|=
literal|'d'
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flags
operator|&
name|MA_STACK
condition|)
name|asciiflags
index|[
literal|1
index|]
operator|=
literal|'s'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MA_BREAK
condition|)
name|asciiflags
index|[
literal|2
index|]
operator|=
literal|'b'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MA_SHARED
condition|)
name|asciiflags
index|[
literal|3
index|]
operator|=
literal|'s'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MA_READ
condition|)
name|asciiflags
index|[
literal|4
index|]
operator|=
literal|'r'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MA_WRITE
condition|)
name|asciiflags
index|[
literal|5
index|]
operator|=
literal|'w'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MA_EXEC
condition|)
name|asciiflags
index|[
literal|6
index|]
operator|=
literal|'x'
expr_stmt|;
return|return
operator|(
name|asciiflags
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|info_proc_flags
parameter_list|(
name|pip
parameter_list|,
name|summary
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pip
decl_stmt|;
name|int
name|summary
decl_stmt|;
block|{
name|struct
name|trans
modifier|*
name|transp
decl_stmt|;
ifdef|#
directive|ifdef
name|UNIXWARE
name|long
name|flags
init|=
name|pip
operator|->
name|prstatus
operator|.
name|pr_flags
operator||
name|pip
operator|->
name|prstatus
operator|.
name|pr_lwp
operator|.
name|pr_flags
decl_stmt|;
else|#
directive|else
name|long
name|flags
init|=
name|pip
operator|->
name|prstatus
operator|.
name|pr_flags
decl_stmt|;
endif|#
directive|endif
name|printf_filtered
argument_list|(
literal|"%-32s"
argument_list|,
literal|"Process status flags:"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|summary
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|transp
operator|=
name|pr_flag_table
init|;
name|transp
operator|->
name|name
operator|!=
name|NULL
condition|;
name|transp
operator|++
control|)
block|{
if|if
condition|(
name|flags
operator|&
name|transp
operator|->
name|value
condition|)
block|{
if|if
condition|(
name|summary
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%s "
argument_list|,
name|transp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"\t%-16s %s.\n"
argument_list|,
name|transp
operator|->
name|name
argument_list|,
name|transp
operator|->
name|desc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|info_proc_stop
parameter_list|(
name|pip
parameter_list|,
name|summary
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pip
decl_stmt|;
name|int
name|summary
decl_stmt|;
block|{
name|struct
name|trans
modifier|*
name|transp
decl_stmt|;
name|int
name|why
decl_stmt|;
name|int
name|what
decl_stmt|;
name|why
operator|=
name|THE_PR_LWP
argument_list|(
name|pip
operator|->
name|prstatus
argument_list|)
operator|.
name|pr_why
expr_stmt|;
name|what
operator|=
name|THE_PR_LWP
argument_list|(
name|pip
operator|->
name|prstatus
argument_list|)
operator|.
name|pr_what
expr_stmt|;
if|if
condition|(
name|THE_PR_LWP
argument_list|(
name|pip
operator|->
name|prstatus
argument_list|)
operator|.
name|pr_flags
operator|&
name|PR_STOPPED
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%-32s"
argument_list|,
literal|"Reason for stopping:"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|summary
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|transp
operator|=
name|pr_why_table
init|;
name|transp
operator|->
name|name
operator|!=
name|NULL
condition|;
name|transp
operator|++
control|)
block|{
if|if
condition|(
name|why
operator|==
name|transp
operator|->
name|value
condition|)
block|{
if|if
condition|(
name|summary
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%s "
argument_list|,
name|transp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"\t%-16s %s.\n"
argument_list|,
name|transp
operator|->
name|name
argument_list|,
name|transp
operator|->
name|desc
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/* Use the pr_why field to determine what the pr_what field means, and 	 print more information. */
switch|switch
condition|(
name|why
condition|)
block|{
case|case
name|PR_REQUESTED
case|:
comment|/* pr_what is unused for this case */
break|break;
case|case
name|PR_JOBCONTROL
case|:
case|case
name|PR_SIGNALLED
case|:
if|if
condition|(
name|summary
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%s "
argument_list|,
name|signalname
argument_list|(
name|what
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"\t%-16s %s.\n"
argument_list|,
name|signalname
argument_list|(
name|what
argument_list|)
argument_list|,
name|safe_strsignal
argument_list|(
name|what
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PR_SYSENTRY
case|:
if|if
condition|(
name|summary
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%s "
argument_list|,
name|syscallname
argument_list|(
name|what
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"\t%-16s %s.\n"
argument_list|,
name|syscallname
argument_list|(
name|what
argument_list|)
argument_list|,
literal|"Entered this system call"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PR_SYSEXIT
case|:
if|if
condition|(
name|summary
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%s "
argument_list|,
name|syscallname
argument_list|(
name|what
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"\t%-16s %s.\n"
argument_list|,
name|syscallname
argument_list|(
name|what
argument_list|)
argument_list|,
literal|"Returned from this system call"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PR_FAULTED
case|:
if|if
condition|(
name|summary
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%s "
argument_list|,
name|lookupname
argument_list|(
name|faults_table
argument_list|,
name|what
argument_list|,
literal|"fault"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"\t%-16s %s.\n"
argument_list|,
name|lookupname
argument_list|(
name|faults_table
argument_list|,
name|what
argument_list|,
literal|"fault"
argument_list|)
argument_list|,
name|lookupdesc
argument_list|(
name|faults_table
argument_list|,
name|what
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|info_proc_siginfo
parameter_list|(
name|pip
parameter_list|,
name|summary
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pip
decl_stmt|;
name|int
name|summary
decl_stmt|;
block|{
name|struct
name|siginfo
modifier|*
name|sip
decl_stmt|;
if|if
condition|(
operator|(
name|THE_PR_LWP
argument_list|(
name|pip
operator|->
name|prstatus
argument_list|)
operator|.
name|pr_flags
operator|&
name|PR_STOPPED
operator|)
operator|&&
operator|(
name|THE_PR_LWP
argument_list|(
name|pip
operator|->
name|prstatus
argument_list|)
operator|.
name|pr_why
operator|==
name|PR_SIGNALLED
operator|||
name|THE_PR_LWP
argument_list|(
name|pip
operator|->
name|prstatus
argument_list|)
operator|.
name|pr_why
operator|==
name|PR_FAULTED
operator|)
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%-32s"
argument_list|,
literal|"Additional signal/fault info:"
argument_list|)
expr_stmt|;
name|sip
operator|=
operator|&
operator|(
name|THE_PR_LWP
argument_list|(
name|pip
operator|->
name|prstatus
argument_list|)
operator|.
name|pr_info
operator|)
expr_stmt|;
if|if
condition|(
name|summary
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%s "
argument_list|,
name|signalname
argument_list|(
name|sip
operator|->
name|si_signo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sip
operator|->
name|si_errno
operator|>
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%s "
argument_list|,
name|errnoname
argument_list|(
name|sip
operator|->
name|si_errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sip
operator|->
name|si_code
operator|<=
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"sent by %s, uid %d "
argument_list|,
name|target_pid_to_str
argument_list|(
name|sip
operator|->
name|si_pid
argument_list|)
argument_list|,
name|sip
operator|->
name|si_uid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"%s "
argument_list|,
name|sigcodename
argument_list|(
name|sip
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sip
operator|->
name|si_signo
operator|==
name|SIGILL
operator|)
operator|||
operator|(
name|sip
operator|->
name|si_signo
operator|==
name|SIGFPE
operator|)
operator|||
operator|(
name|sip
operator|->
name|si_signo
operator|==
name|SIGSEGV
operator|)
operator|||
operator|(
name|sip
operator|->
name|si_signo
operator|==
name|SIGBUS
operator|)
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"addr=%#lx "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sip
operator|->
name|si_addr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sip
operator|->
name|si_signo
operator|==
name|SIGCHLD
operator|)
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"child %s, status %u "
argument_list|,
name|target_pid_to_str
argument_list|(
name|sip
operator|->
name|si_pid
argument_list|)
argument_list|,
name|sip
operator|->
name|si_status
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sip
operator|->
name|si_signo
operator|==
name|SIGPOLL
operator|)
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"band %u "
argument_list|,
name|sip
operator|->
name|si_band
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\t%-16s %s.\n"
argument_list|,
name|signalname
argument_list|(
name|sip
operator|->
name|si_signo
argument_list|)
argument_list|,
name|safe_strsignal
argument_list|(
name|sip
operator|->
name|si_signo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sip
operator|->
name|si_errno
operator|>
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\t%-16s %s.\n"
argument_list|,
name|errnoname
argument_list|(
name|sip
operator|->
name|si_errno
argument_list|)
argument_list|,
name|safe_strerror
argument_list|(
name|sip
operator|->
name|si_errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sip
operator|->
name|si_code
operator|<=
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\t%-16u %s\n"
argument_list|,
name|sip
operator|->
name|si_pid
argument_list|,
comment|/* XXX need target_pid_to_str() */
literal|"PID of process sending signal"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\t%-16u %s\n"
argument_list|,
name|sip
operator|->
name|si_uid
argument_list|,
literal|"UID of process sending signal"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"\t%-16s %s.\n"
argument_list|,
name|sigcodename
argument_list|(
name|sip
argument_list|)
argument_list|,
name|sigcodedesc
argument_list|(
name|sip
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sip
operator|->
name|si_signo
operator|==
name|SIGILL
operator|)
operator|||
operator|(
name|sip
operator|->
name|si_signo
operator|==
name|SIGFPE
operator|)
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\t%#-16lx %s.\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sip
operator|->
name|si_addr
argument_list|,
literal|"Address of faulting instruction"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sip
operator|->
name|si_signo
operator|==
name|SIGSEGV
operator|)
operator|||
operator|(
name|sip
operator|->
name|si_signo
operator|==
name|SIGBUS
operator|)
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\t%#-16lx %s.\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sip
operator|->
name|si_addr
argument_list|,
literal|"Address of faulting memory reference"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sip
operator|->
name|si_signo
operator|==
name|SIGCHLD
operator|)
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\t%-16u %s.\n"
argument_list|,
name|sip
operator|->
name|si_pid
argument_list|,
comment|/* XXX need target_pid_to_str() */
literal|"Child process ID"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\t%-16u %s.\n"
argument_list|,
name|sip
operator|->
name|si_status
argument_list|,
literal|"Child process exit value or signal"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sip
operator|->
name|si_signo
operator|==
name|SIGPOLL
operator|)
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\t%-16u %s.\n"
argument_list|,
name|sip
operator|->
name|si_band
argument_list|,
literal|"Band event for POLL_{IN,OUT,MSG}"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|info_proc_syscalls
parameter_list|(
name|pip
parameter_list|,
name|summary
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pip
decl_stmt|;
name|int
name|summary
decl_stmt|;
block|{
name|int
name|syscallnum
decl_stmt|;
if|if
condition|(
operator|!
name|summary
condition|)
block|{
if|#
directive|if
literal|0
comment|/* FIXME:  Needs to use gdb-wide configured info about system calls. */
block|if (pip -> prstatus.pr_flags& PR_ASLEEP) 	{ 	  int syscallnum = pip -> prstatus.pr_reg[R_D0]; 	  if (summary) 	    { 	      printf_filtered ("%-32s", "Sleeping in system call:"); 	      printf_filtered ("%s", syscallname (syscallnum)); 	    } 	  else 	    { 	      printf_filtered ("Sleeping in system call '%s'.\n", 			       syscallname (syscallnum)); 	    } 	}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|UNIXWARE
if|if
condition|(
name|ioctl
argument_list|(
name|pip
operator|->
name|ctl_fd
argument_list|,
name|PIOCGENTRY
argument_list|,
operator|&
name|pip
operator|->
name|entryset
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pip
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"PIOCGENTRY failed"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|pip
operator|->
name|ctl_fd
argument_list|,
name|PIOCGEXIT
argument_list|,
operator|&
name|pip
operator|->
name|exitset
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pip
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"PIOCGEXIT failed"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|printf_filtered
argument_list|(
literal|"System call tracing information:\n\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\t%-12s %-8s %-8s\n"
argument_list|,
literal|"System call"
argument_list|,
literal|"Entry"
argument_list|,
literal|"Exit"
argument_list|)
expr_stmt|;
for|for
control|(
name|syscallnum
operator|=
literal|0
init|;
name|syscallnum
operator|<
name|MAX_SYSCALLS
condition|;
name|syscallnum
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|syscall_table
index|[
name|syscallnum
index|]
operator|!=
name|NULL
condition|)
name|printf_filtered
argument_list|(
literal|"\t%-12s "
argument_list|,
name|syscall_table
index|[
name|syscallnum
index|]
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"\t%-12d "
argument_list|,
name|syscallnum
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UNIXWARE
name|printf_filtered
argument_list|(
literal|"%-8s "
argument_list|,
name|prismember
argument_list|(
operator|&
name|pip
operator|->
name|prstatus
operator|.
name|pr_sysentry
argument_list|,
name|syscallnum
argument_list|)
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%-8s "
argument_list|,
name|prismember
argument_list|(
operator|&
name|pip
operator|->
name|prstatus
operator|.
name|pr_sysexit
argument_list|,
name|syscallnum
argument_list|)
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf_filtered
argument_list|(
literal|"%-8s "
argument_list|,
name|prismember
argument_list|(
operator|&
name|pip
operator|->
name|entryset
argument_list|,
name|syscallnum
argument_list|)
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%-8s "
argument_list|,
name|prismember
argument_list|(
operator|&
name|pip
operator|->
name|exitset
argument_list|,
name|syscallnum
argument_list|)
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|signalname
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|static
name|char
name|locbuf
index|[
literal|32
index|]
decl_stmt|;
name|name
operator|=
name|strsigno
argument_list|(
name|signo
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|locbuf
argument_list|,
literal|"Signal %d"
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|locbuf
argument_list|,
literal|"%s (%d)"
argument_list|,
name|name
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|locbuf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|errnoname
parameter_list|(
name|errnum
parameter_list|)
name|int
name|errnum
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|static
name|char
name|locbuf
index|[
literal|32
index|]
decl_stmt|;
name|name
operator|=
name|strerrno
argument_list|(
name|errnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|locbuf
argument_list|,
literal|"Errno %d"
argument_list|,
name|errnum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|locbuf
argument_list|,
literal|"%s (%d)"
argument_list|,
name|name
argument_list|,
name|errnum
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|locbuf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|info_proc_signals
parameter_list|(
name|pip
parameter_list|,
name|summary
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pip
decl_stmt|;
name|int
name|summary
decl_stmt|;
block|{
name|int
name|signo
decl_stmt|;
if|if
condition|(
operator|!
name|summary
condition|)
block|{
ifndef|#
directive|ifndef
name|PROCFS_USE_READ_WRITE
if|if
condition|(
name|ioctl
argument_list|(
name|pip
operator|->
name|ctl_fd
argument_list|,
name|PIOCGTRACE
argument_list|,
operator|&
name|pip
operator|->
name|trace
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pip
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"PIOCGTRACE failed"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|printf_filtered
argument_list|(
literal|"Disposition of signals:\n\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\t%-15s %-8s %-8s %-8s  %s\n\n"
argument_list|,
literal|"Signal"
argument_list|,
literal|"Trace"
argument_list|,
literal|"Hold"
argument_list|,
literal|"Pending"
argument_list|,
literal|"Description"
argument_list|)
expr_stmt|;
for|for
control|(
name|signo
operator|=
literal|0
init|;
name|signo
operator|<
name|NSIG
condition|;
name|signo
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\t%-15s "
argument_list|,
name|signalname
argument_list|(
name|signo
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UNIXWARE
name|printf_filtered
argument_list|(
literal|"%-8s "
argument_list|,
name|prismember
argument_list|(
operator|&
name|pip
operator|->
name|prstatus
operator|.
name|pr_sigtrace
argument_list|,
name|signo
argument_list|)
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%-8s "
argument_list|,
name|prismember
argument_list|(
operator|&
name|pip
operator|->
name|prstatus
operator|.
name|pr_lwp
operator|.
name|pr_context
operator|.
name|uc_sigmask
argument_list|,
name|signo
argument_list|)
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf_filtered
argument_list|(
literal|"%-8s "
argument_list|,
name|prismember
argument_list|(
operator|&
name|pip
operator|->
name|trace
argument_list|,
name|signo
argument_list|)
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%-8s "
argument_list|,
name|prismember
argument_list|(
operator|&
name|pip
operator|->
name|prstatus
operator|.
name|pr_sighold
argument_list|,
name|signo
argument_list|)
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UNIXWARE
if|if
condition|(
name|prismember
argument_list|(
operator|&
name|pip
operator|->
name|prstatus
operator|.
name|pr_sigpend
argument_list|,
name|signo
argument_list|)
operator|||
name|prismember
argument_list|(
operator|&
name|pip
operator|->
name|prstatus
operator|.
name|pr_lwp
operator|.
name|pr_lwppend
argument_list|,
name|signo
argument_list|)
condition|)
name|printf_filtered
argument_list|(
literal|"%-8s "
argument_list|,
literal|"yes"
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"%-8s "
argument_list|,
literal|"no"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* UNIXWARE */
ifdef|#
directive|ifdef
name|PROCFS_SIGPEND_OFFSET
comment|/* Alpha OSF/1 numbers the pending signals from 1.  */
name|printf_filtered
argument_list|(
literal|"%-8s "
argument_list|,
operator|(
name|signo
condition|?
name|prismember
argument_list|(
operator|&
name|pip
operator|->
name|prstatus
operator|.
name|pr_sigpend
argument_list|,
name|signo
operator|-
literal|1
argument_list|)
else|:
literal|0
operator|)
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf_filtered
argument_list|(
literal|"%-8s "
argument_list|,
name|prismember
argument_list|(
operator|&
name|pip
operator|->
name|prstatus
operator|.
name|pr_sigpend
argument_list|,
name|signo
argument_list|)
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* UNIXWARE */
name|printf_filtered
argument_list|(
literal|" %s\n"
argument_list|,
name|safe_strsignal
argument_list|(
name|signo
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|info_proc_faults
parameter_list|(
name|pip
parameter_list|,
name|summary
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pip
decl_stmt|;
name|int
name|summary
decl_stmt|;
block|{
name|struct
name|trans
modifier|*
name|transp
decl_stmt|;
if|if
condition|(
operator|!
name|summary
condition|)
block|{
ifndef|#
directive|ifndef
name|UNIXWARE
if|if
condition|(
name|ioctl
argument_list|(
name|pip
operator|->
name|ctl_fd
argument_list|,
name|PIOCGFAULT
argument_list|,
operator|&
name|pip
operator|->
name|fltset
operator|.
name|fltset
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pip
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"PIOCGFAULT failed"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|printf_filtered
argument_list|(
literal|"Current traced hardware fault set:\n\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\t%-12s %-8s\n"
argument_list|,
literal|"Fault"
argument_list|,
literal|"Trace"
argument_list|)
expr_stmt|;
for|for
control|(
name|transp
operator|=
name|faults_table
init|;
name|transp
operator|->
name|name
operator|!=
name|NULL
condition|;
name|transp
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\t%-12s "
argument_list|,
name|transp
operator|->
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UNIXWARE
name|printf_filtered
argument_list|(
literal|"%-8s"
argument_list|,
name|prismember
argument_list|(
operator|&
name|pip
operator|->
name|prstatus
operator|.
name|pr_flttrace
argument_list|,
name|transp
operator|->
name|value
argument_list|)
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf_filtered
argument_list|(
literal|"%-8s"
argument_list|,
name|prismember
argument_list|(
operator|&
name|pip
operator|->
name|fltset
operator|.
name|fltset
argument_list|,
name|transp
operator|->
name|value
argument_list|)
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|info_proc_mappings
parameter_list|(
name|pip
parameter_list|,
name|summary
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pip
decl_stmt|;
name|int
name|summary
decl_stmt|;
block|{
name|int
name|nmap
decl_stmt|;
name|struct
name|prmap
modifier|*
name|prmaps
decl_stmt|;
name|struct
name|prmap
modifier|*
name|prmap
decl_stmt|;
name|struct
name|stat
name|sbuf
decl_stmt|;
if|if
condition|(
operator|!
name|summary
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Mapped address spaces:\n\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_HOST_64_BIT
name|printf_filtered
argument_list|(
literal|"  %18s %18s %10s %10s %7s\n"
argument_list|,
else|#
directive|else
argument|printf_filtered (
literal|"\t%10s %10s %10s %10s %7s\n"
argument|,
endif|#
directive|endif
literal|"Start Addr"
argument|,
literal|"  End Addr"
argument|,
literal|"      Size"
argument|,
literal|"    Offset"
argument|,
literal|"Flags"
argument|);
ifdef|#
directive|ifdef
name|PROCFS_USE_READ_WRITE
argument|if (fstat (pip->map_fd,&sbuf) ==
literal|0
argument|)         {           nmap = sbuf.st_size / sizeof (prmap_t); 	  prmaps = (struct prmap *) alloca ((nmap +
literal|1
argument|) * sizeof (*prmaps));           if ((lseek (pip->map_fd,
literal|0
argument|, SEEK_SET) ==
literal|0
argument|)&& 		(read (pip->map_fd, (char *) prmaps, 		nmap * sizeof (*prmaps)) == (nmap * sizeof (*prmaps)))) 	    { 	      int i =
literal|0
argument|; 	      for (prmap = prmaps; i< nmap; ++prmap, ++i)
else|#
directive|else
argument|if (ioctl (pip -> ctl_fd, PIOCNMAP,&nmap) ==
literal|0
argument|) 	{ 	  prmaps = (struct prmap *) alloca ((nmap +
literal|1
argument|) * sizeof (*prmaps)); 	  if (ioctl (pip -> ctl_fd, PIOCMAP, prmaps) ==
literal|0
argument|) 	    { 	      for (prmap = prmaps; prmap -> pr_size; ++prmap)
endif|#
directive|endif
comment|/* PROCFS_USE_READ_WRITE */
argument|{
ifdef|#
directive|ifdef
name|BFD_HOST_64_BIT
argument|printf_filtered (
literal|"  %#18lx %#18lx %#10x %#10x %7s\n"
argument|,
else|#
directive|else
argument|printf_filtered (
literal|"\t%#10lx %#10lx %#10x %#10x %7s\n"
argument|,
endif|#
directive|endif
argument|(unsigned long)prmap -> pr_vaddr, 				   (unsigned long)prmap -> pr_vaddr 				     + prmap -> pr_size -
literal|1
argument|, 				   prmap -> pr_size, 				   prmap -> pr_off, 				   mappingflags (prmap -> pr_mflags)); 		} 	    } 	}       printf_filtered (
literal|"\n"
argument|);     } }
comment|/*  LOCAL FUNCTION  	info_proc -- implement the "info proc" command  SYNOPSIS  	void info_proc (char *args, int from_tty)  DESCRIPTION  	Implement gdb's "info proc" command by using the /proc interface 	to print status information about any currently running process.  	Examples of the use of "info proc" are:  	info proc		(prints summary info for current inferior) 	info proc 123		(prints summary info for process with pid 123) 	info proc mappings	(prints address mappings) 	info proc times		(prints process/children times) 	info proc id		(prints pid, ppid, gid, sid, etc) 		FIXME:  i proc id not implemented. 	info proc status	(prints general process state info) 		FIXME:  i proc status not implemented. 	info proc signals	(prints info about signal handling) 	info proc all		(prints all info)   */
argument|static void info_proc (args, from_tty)      char *args;      int from_tty; {   int pid;   struct procinfo *pip;   struct cleanup *old_chain;   char **argv;   int argsize;   int summary =
literal|1
argument|;   int flags =
literal|0
argument|;   int syscalls =
literal|0
argument|;   int signals =
literal|0
argument|;   int faults =
literal|0
argument|;   int mappings =
literal|0
argument|;   int times =
literal|0
argument|;   int id =
literal|0
argument|;   int status =
literal|0
argument|;   int all =
literal|0
argument|;   int nlwp;   int *lwps;    old_chain = make_cleanup (null_cleanup,
literal|0
argument|);
comment|/* Default to using the current inferior if no pid specified.  Note      that inferior_pid may be 0, hence we set okerr.  */
argument|pid = inferior_pid&
literal|0x7fffffff
argument|;
comment|/* strip off sol-thread bit */
argument|if (!(pip = find_procinfo (pid,
literal|1
argument|)))
comment|/* inferior_pid no good?  */
argument|pip = procinfo_list;
comment|/* take first available */
argument|pid = pid&
literal|0xffff
argument|;
comment|/* extract "real" pid */
argument|if (args != NULL)     {       if ((argv = buildargv (args)) == NULL) 	{ 	  nomem (
literal|0
argument|); 	}       make_cleanup (freeargv, (char *) argv);        while (*argv != NULL) 	{ 	  argsize = strlen (*argv); 	  if (argsize>=
literal|1
argument|&& strncmp (*argv,
literal|"all"
argument|, argsize) ==
literal|0
argument|) 	    { 	      summary =
literal|0
argument|; 	      all =
literal|1
argument|; 	    } 	  else if (argsize>=
literal|2
argument|&& strncmp (*argv,
literal|"faults"
argument|, argsize) ==
literal|0
argument|) 	    { 	      summary =
literal|0
argument|; 	      faults =
literal|1
argument|; 	    } 	  else if (argsize>=
literal|2
argument|&& strncmp (*argv,
literal|"flags"
argument|, argsize) ==
literal|0
argument|) 	    { 	      summary =
literal|0
argument|; 	      flags =
literal|1
argument|; 	    } 	  else if (argsize>=
literal|1
argument|&& strncmp (*argv,
literal|"id"
argument|, argsize) ==
literal|0
argument|) 	    { 	      summary =
literal|0
argument|; 	      id =
literal|1
argument|; 	    } 	  else if (argsize>=
literal|1
argument|&& strncmp (*argv,
literal|"mappings"
argument|, argsize) ==
literal|0
argument|) 	    { 	      summary =
literal|0
argument|; 	      mappings =
literal|1
argument|; 	    } 	  else if (argsize>=
literal|2
argument|&& strncmp (*argv,
literal|"signals"
argument|, argsize) ==
literal|0
argument|) 	    { 	      summary =
literal|0
argument|; 	      signals =
literal|1
argument|; 	    } 	  else if (argsize>=
literal|2
argument|&& strncmp (*argv,
literal|"status"
argument|, argsize) ==
literal|0
argument|) 	    { 	      summary =
literal|0
argument|; 	      status =
literal|1
argument|; 	    } 	  else if (argsize>=
literal|2
argument|&& strncmp (*argv,
literal|"syscalls"
argument|, argsize) ==
literal|0
argument|) 	    { 	      summary =
literal|0
argument|; 	      syscalls =
literal|1
argument|; 	    } 	  else if (argsize>=
literal|1
argument|&& strncmp (*argv,
literal|"times"
argument|, argsize) ==
literal|0
argument|) 	    { 	      summary =
literal|0
argument|; 	      times =
literal|1
argument|; 	    } 	  else if ((pid = atoi (*argv))>
literal|0
argument|) 	    { 	      pip = (struct procinfo *) xmalloc (sizeof (struct procinfo)); 	      memset (pip,
literal|0
argument|, sizeof (*pip));  	      pip->pid = pid; 	      if (!open_proc_file (pid, pip, O_RDONLY,
literal|0
argument|)) 		{ 		  perror_with_name (pip -> pathname);
comment|/* NOTREACHED */
argument|} 	      pid = pip->pid; 	      make_cleanup (close_proc_file, pip); 	    } 	  else if (**argv !=
literal|'\000'
argument|) 	    { 	      error (
literal|"Unrecognized or ambiguous keyword `%s'."
argument|, *argv); 	    } 	  argv++; 	}     }
comment|/* If we don't have a valid open process at this point, then we have no      inferior or didn't specify a specific pid. */
argument|if (!pip)     {       error (
literal|"\ No process.  Start debugging a program or specify an explicit process ID."
argument|);     }    if (!procfs_read_status (pip))     {       print_sys_errmsg (pip -> pathname, errno);       error (
literal|"procfs_read_status failed"
argument|);     }
ifndef|#
directive|ifndef
name|PROCFS_USE_READ_WRITE
ifdef|#
directive|ifdef
name|PIOCLWPIDS
argument|nlwp = pip->prstatus.pr_nlwp;   lwps = alloca ((
literal|2
argument|* nlwp +
literal|2
argument|) * sizeof (*lwps));    if (ioctl (pip->ctl_fd, PIOCLWPIDS, lwps))     {       print_sys_errmsg (pip -> pathname, errno);       error (
literal|"PIOCLWPIDS failed"
argument|);     }
else|#
directive|else
comment|/* PIOCLWPIDS */
argument|nlwp =
literal|1
argument|;   lwps = alloca ((
literal|2
argument|* nlwp +
literal|2
argument|) * sizeof *lwps);   lwps[
literal|0
argument|] =
literal|0
argument|;
endif|#
directive|endif
comment|/* PIOCLWPIDS */
argument|for (; nlwp>
literal|0
argument|; nlwp--, lwps++)     {       pip = find_procinfo ((*lwps<<
literal|16
argument|) | pid,
literal|1
argument|);        if (!pip) 	{ 	  pip = (struct procinfo *) xmalloc (sizeof (struct procinfo)); 	  memset (pip,
literal|0
argument|, sizeof (*pip)); 	  if (!open_proc_file ((*lwps<<
literal|16
argument|) | pid, pip, O_RDONLY,
literal|0
argument|)) 	    continue;  	  make_cleanup (close_proc_file, pip);  	  if (!procfs_read_status (pip)) 	    { 	      print_sys_errmsg (pip -> pathname, errno); 	      error (
literal|"procfs_read_status failed"
argument|); 	    } 	}
endif|#
directive|endif
comment|/* PROCFS_USE_READ_WRITE */
comment|/* Print verbose information of the requested type(s), or just a summary 	 of the information for all types. */
argument|printf_filtered (
literal|"\nInformation for %s.%d:\n\n"
argument|, pip -> pathname, *lwps);       if (summary || all || flags) 	{ 	  info_proc_flags (pip, summary); 	}       if (summary || all) 	{ 	  info_proc_stop (pip, summary);
ifdef|#
directive|ifdef
name|UNIXWARE
argument|supply_gregset (&pip->prstatus.pr_lwp.pr_context.uc_mcontext.gregs);
else|#
directive|else
argument|supply_gregset (&pip->prstatus.pr_reg);
endif|#
directive|endif
argument|printf_filtered (
literal|"PC: "
argument|); 	  print_address (read_pc (), gdb_stdout); 	  printf_filtered (
literal|"\n"
argument|); 	}       if (summary || all || signals || faults) 	{ 	  info_proc_siginfo (pip, summary); 	}       if (summary || all || syscalls) 	{ 	  info_proc_syscalls (pip, summary); 	}       if (summary || all || mappings) 	{ 	  info_proc_mappings (pip, summary); 	}       if (summary || all || signals) 	{ 	  info_proc_signals (pip, summary); 	}       if (summary || all || faults) 	{ 	  info_proc_faults (pip, summary); 	}       printf_filtered (
literal|"\n"
argument|);
comment|/* All done, deal with closing any temporary process info structure, 	 freeing temporary memory , etc. */
argument|do_cleanups (old_chain);
ifndef|#
directive|ifndef
name|PROCFS_USE_READ_WRITE
argument|}
endif|#
directive|endif
argument|}
comment|/*  LOCAL FUNCTION  	modify_inherit_on_fork_flag - Change the inherit-on-fork flag  SYNOPSIS  	void modify_inherit_on_fork_flag (fd, flag)  DESCRIPTION  	Call this routine to modify the inherit-on-fork flag.  This routine is 	just a nice wrapper to hide the #ifdefs needed by various systems to 	control this flag.   */
argument|static void modify_inherit_on_fork_flag (fd, flag)      int fd;      int flag; {
if|#
directive|if
name|defined
argument_list|(
name|PIOCSET
argument_list|)
operator|||
name|defined
argument_list|(
name|PCSET
argument_list|)
argument|long pr_flags;
endif|#
directive|endif
argument|int retval =
literal|0
argument|;   struct proc_ctl pctl;
if|#
directive|if
name|defined
argument_list|(
name|PIOCSET
argument_list|)
operator|||
name|defined
argument_list|(
name|PCSET
argument_list|)
comment|/* New method */
argument|pr_flags = PR_FORK;   if (flag)     {
ifdef|#
directive|ifdef
name|PROCFS_USE_READ_WRITE
argument|pctl.cmd = PCSET;       pctl.data = PR_FORK;       if (write (fd, (char *)&pctl, sizeof (struct proc_ctl))<
literal|0
argument|) 	retval = -
literal|1
argument|;
else|#
directive|else
argument|retval = ioctl (fd, PIOCSET,&pr_flags);
endif|#
directive|endif
argument|}   else     {
ifdef|#
directive|ifdef
name|PROCFS_USE_READ_WRITE
argument|pctl.cmd = PCRESET;       pctl.data = PR_FORK;       if (write (fd, (char *)&pctl, sizeof (struct proc_ctl))<
literal|0
argument|) 	retval = -
literal|1
argument|;
else|#
directive|else
argument|retval = ioctl (fd, PIOCRESET,&pr_flags);
endif|#
directive|endif
argument|}
else|#
directive|else
ifdef|#
directive|ifdef
name|PIOCSFORK
comment|/* Original method */
argument|if (flag)     {       retval = ioctl (fd, PIOCSFORK, NULL);     }   else     {       retval = ioctl (fd, PIOCRFORK, NULL);     }
else|#
directive|else
argument|Neither PR_FORK nor PIOCSFORK exist!!!
endif|#
directive|endif
endif|#
directive|endif
argument|if (!retval)     return;    print_sys_errmsg (
literal|"modify_inherit_on_fork_flag"
argument|, errno);   error (
literal|"PIOCSFORK or PR_FORK modification failed"
argument|); }
comment|/*  LOCAL FUNCTION  	modify_run_on_last_close_flag - Change the run-on-last-close flag  SYNOPSIS  	void modify_run_on_last_close_flag (fd, flag)  DESCRIPTION  	Call this routine to modify the run-on-last-close flag.  This routine 	is just a nice wrapper to hide the #ifdefs needed by various systems to 	control this flag.   */
argument|static void modify_run_on_last_close_flag (fd, flag)      int fd;      int flag; {
if|#
directive|if
name|defined
argument_list|(
name|PIOCSET
argument_list|)
operator|||
name|defined
argument_list|(
name|PCSET
argument_list|)
argument|long pr_flags;
endif|#
directive|endif
argument|int retval =
literal|0
argument|;   struct proc_ctl pctl;
if|#
directive|if
name|defined
argument_list|(
name|PIOCSET
argument_list|)
operator|||
name|defined
argument_list|(
name|PCSET
argument_list|)
comment|/* New method */
argument|pr_flags = PR_RLC;   if (flag)     {
ifdef|#
directive|ifdef
name|PROCFS_USE_READ_WRITE
argument|pctl.cmd = PCSET;       pctl.data = PR_RLC;       if (write (fd, (char *)&pctl, sizeof (struct proc_ctl))<
literal|0
argument|) 	retval = -
literal|1
argument|;
else|#
directive|else
argument|retval = ioctl (fd, PIOCSET,&pr_flags);
endif|#
directive|endif
argument|}   else     {
ifdef|#
directive|ifdef
name|PROCFS_USE_READ_WRITE
argument|pctl.cmd = PCRESET;       pctl.data = PR_RLC;       if (write (fd, (char *)&pctl, sizeof (struct proc_ctl))<
literal|0
argument|) 	retval = -
literal|1
argument|;
else|#
directive|else
argument|retval = ioctl (fd, PIOCRESET,&pr_flags);
endif|#
directive|endif
argument|}
else|#
directive|else
ifdef|#
directive|ifdef
name|PIOCSRLC
comment|/* Original method */
argument|if (flag)     retval = ioctl (fd, PIOCSRLC, NULL);   else     retval = ioctl (fd, PIOCRRLC, NULL);
else|#
directive|else
argument|Neither PR_RLC nor PIOCSRLC exist!!!
endif|#
directive|endif
endif|#
directive|endif
argument|if (!retval)     return;    print_sys_errmsg (
literal|"modify_run_on_last_close_flag"
argument|, errno);   error (
literal|"PIOCSRLC or PR_RLC modification failed"
argument|); }
comment|/*  LOCAL FUNCTION  	procfs_clear_syscall_trap -- Deletes the trap for the specified system call.  SYNOPSIS  	void procfs_clear_syscall_trap (struct procinfo *, int syscall_num, int errok)  DESCRIPTION  	This function function disables traps for the specified system call. 	errok is non-zero if errors should be ignored.  */
argument|static void procfs_clear_syscall_trap (pi, syscall_num, errok)      struct procinfo *pi;      int syscall_num;      int errok; {   sysset_t sysset;   int goterr, i;
ifndef|#
directive|ifndef
name|UNIXWARE
argument|goterr = ioctl (pi->ctl_fd, PIOCGENTRY,&sysset)<
literal|0
argument|;    if (goterr&& !errok)     {       print_sys_errmsg (pi->pathname, errno);       error (
literal|"PIOCGENTRY failed"
argument|);     }    if (!goterr)     {       prdelset (&sysset, syscall_num);        if ((ioctl (pi->ctl_fd, PIOCSENTRY,&sysset)<
literal|0
argument|)&& !errok) 	{ 	  print_sys_errmsg (pi->pathname, errno); 	  error (
literal|"PIOCSENTRY failed"
argument|); 	}     }    goterr = ioctl (pi->ctl_fd, PIOCGEXIT,&sysset)<
literal|0
argument|;    if (goterr&& !errok)     {       procfs_clear_syscall_trap (pi, syscall_num,
literal|1
argument|);       print_sys_errmsg (pi->pathname, errno);       error (
literal|"PIOCGEXIT failed"
argument|);     }    if (!goterr)     {       praddset (&sysset, syscall_num);        if ((ioctl (pi->ctl_fd, PIOCSEXIT,&sysset)<
literal|0
argument|)&& !errok) 	{ 	  procfs_clear_syscall_trap (pi, syscall_num,
literal|1
argument|); 	  print_sys_errmsg (pi->pathname, errno); 	  error (
literal|"PIOCSEXIT failed"
argument|); 	}     }
endif|#
directive|endif
argument|if (!pi->syscall_handlers)     {       if (!errok) 	error (
literal|"procfs_clear_syscall_trap:  syscall_handlers is empty"
argument|);       return;     }
comment|/* Remove handler func from the handler list */
argument|for (i =
literal|0
argument|; i< pi->num_syscall_handlers; i++)     if (pi->syscall_handlers[i].syscall_num == syscall_num)       { 	if (i +
literal|1
argument|!= pi->num_syscall_handlers) 	  {
comment|/* Not the last entry. 				   Move subsequent entries fwd. */
argument|memcpy (&pi->syscall_handlers[i],&pi->syscall_handlers[i +
literal|1
argument|], 		    (pi->num_syscall_handlers - i -
literal|1
argument|) 		    * sizeof (struct procfs_syscall_handler)); 	  }  	pi->syscall_handlers = xrealloc (pi->syscall_handlers, 					 (pi->num_syscall_handlers -
literal|1
argument|) 					 * sizeof (struct procfs_syscall_handler)); 	pi->num_syscall_handlers--; 	return;       }    if (!errok)     error (
literal|"procfs_clear_syscall_trap:  Couldn't find handler for sys call %d"
argument|, 	   syscall_num); }
comment|/*  LOCAL FUNCTION  	procfs_set_syscall_trap -- arrange for a function to be called when the 				   child executes the specified system call.  SYNOPSIS  	void procfs_set_syscall_trap (struct procinfo *, int syscall_num, int flags, 				      syscall_func_t *function)  DESCRIPTION  	This function sets up an entry and/or exit trap for the specified system 	call.  When the child executes the specified system call, your function 	will be	called with the call #, a flag that indicates entry or exit, and 	pointers to rtnval and statval (which are used by procfs_wait).  The 	function should return non-zero if something interesting happened, zero 	otherwise.  */
argument|static void procfs_set_syscall_trap (pi, syscall_num, flags, func)      struct procinfo *pi;      int syscall_num;      int flags;      syscall_func_t *func; {   sysset_t sysset;
ifndef|#
directive|ifndef
name|UNIXWARE
argument|if (flags& PROCFS_SYSCALL_ENTRY)     {       if (ioctl (pi->ctl_fd, PIOCGENTRY,&sysset)<
literal|0
argument|) 	{ 	  print_sys_errmsg (pi->pathname, errno); 	  error (
literal|"PIOCGENTRY failed"
argument|); 	}        praddset (&sysset, syscall_num);        if (ioctl (pi->ctl_fd, PIOCSENTRY,&sysset)<
literal|0
argument|) 	{ 	  print_sys_errmsg (pi->pathname, errno); 	  error (
literal|"PIOCSENTRY failed"
argument|); 	}     }    if (flags& PROCFS_SYSCALL_EXIT)     {       if (ioctl (pi->ctl_fd, PIOCGEXIT,&sysset)<
literal|0
argument|) 	{ 	  procfs_clear_syscall_trap (pi, syscall_num,
literal|1
argument|); 	  print_sys_errmsg (pi->pathname, errno); 	  error (
literal|"PIOCGEXIT failed"
argument|); 	}        praddset (&sysset, syscall_num);        if (ioctl (pi->ctl_fd, PIOCSEXIT,&sysset)<
literal|0
argument|) 	{ 	  procfs_clear_syscall_trap (pi, syscall_num,
literal|1
argument|); 	  print_sys_errmsg (pi->pathname, errno); 	  error (
literal|"PIOCSEXIT failed"
argument|); 	}     }
endif|#
directive|endif
argument|if (!pi->syscall_handlers)     {       pi->syscall_handlers = xmalloc (sizeof (struct procfs_syscall_handler));       pi->syscall_handlers[
literal|0
argument|].syscall_num = syscall_num;       pi->syscall_handlers[
literal|0
argument|].func = func;       pi->num_syscall_handlers =
literal|1
argument|;     }   else     {       int i;        for (i =
literal|0
argument|; i< pi->num_syscall_handlers; i++) 	if (pi->syscall_handlers[i].syscall_num == syscall_num) 	  { 	    pi->syscall_handlers[i].func = func; 	    return; 	  }        pi->syscall_handlers = xrealloc (pi->syscall_handlers, (i +
literal|1
argument|) 				       * sizeof (struct procfs_syscall_handler));       pi->syscall_handlers[i].syscall_num = syscall_num;       pi->syscall_handlers[i].func = func;       pi->num_syscall_handlers++;     } }
ifdef|#
directive|ifdef
name|SYS_lwp_create
comment|/*  LOCAL FUNCTION  	procfs_lwp_creation_handler - handle exit from the _lwp_create syscall  SYNOPSIS  	int procfs_lwp_creation_handler (pi, syscall_num, why, rtnvalp, statvalp)  DESCRIPTION  	This routine is called both when an inferior process and it's new lwp 	are about to finish a _lwp_create() system call.  This is the system 	call that Solaris uses to create a lightweight process.  When the 	target process gets this event, we can look at sysarg[2] to find the 	new childs lwp ID, and create a procinfo struct from that.  After that, 	we pretend that we got a SIGTRAP, and return non-zero to tell 	procfs_wait to wake up.  Subsequently, wait_for_inferior gets woken up, 	sees the new process and continues it.  	When we see the child exiting from lwp_create, we just contine it, 	since everything was handled when the parent trapped.  NOTES 	In effect, we are only paying attention to the parent's completion of 	the lwp_create syscall.  If we only paid attention to the child 	instead, then we wouldn't detect the creation of a suspended thread.  */
argument|static int procfs_lwp_creation_handler (pi, syscall_num, why, rtnvalp, statvalp)      struct procinfo *pi;      int syscall_num;      int why;      int *rtnvalp;      int *statvalp; {   int lwp_id;   struct procinfo *childpi;   struct proc_ctl pctl;
comment|/* We've just detected the completion of an lwp_create system call.  Now we      need to setup a procinfo struct for this thread, and notify the thread      system of the new arrival.  */
comment|/* If lwp_create failed, then nothing interesting happened.  Continue the      process and go back to sleep. */
ifdef|#
directive|ifdef
name|UNIXWARE
comment|/* Joel ... can you check this logic out please? JKJ */
argument|if (pi->prstatus.pr_lwp.pr_context.uc_mcontext.gregs[R_EFL]&
literal|1
argument|)     {
comment|/* _lwp_create failed */
argument|pctl.cmd = PCRUN;       pctl.data = PRCFAULT;        if (write (pi->ctl_fd, (char *)&pctl, sizeof (struct proc_ctl))<
literal|0
argument|) 	perror_with_name (pi->pathname);        return
literal|0
argument|;     }
else|#
directive|else
comment|/* UNIXWARE */
argument|if (PROCFS_GET_CARRY (pi->prstatus.pr_reg))     {
comment|/* _lwp_create failed */
argument|pi->prrun.pr_flags&= PRSTEP;       pi->prrun.pr_flags |= PRCFAULT;        if (ioctl (pi->ctl_fd, PIOCRUN,&pi->prrun) !=
literal|0
argument|) 	perror_with_name (pi->pathname);        return
literal|0
argument|;     }
endif|#
directive|endif
comment|/* At this point, the new thread is stopped at it's first instruction, and      the parent is stopped at the exit from lwp_create.  */
argument|if (pi->new_child)
comment|/* Child? */
argument|{
comment|/* Yes, just continue it */
ifdef|#
directive|ifdef
name|UNIXWARE
argument|pctl.cmd = PCRUN;       pctl.data = PRCFAULT;        if (write(pi->ctl_fd, (char *)&pctl, sizeof (struct proc_ctl))<
literal|0
argument|)
else|#
directive|else
comment|/* !UNIXWARE */
argument|pi->prrun.pr_flags&= PRSTEP;       pi->prrun.pr_flags |= PRCFAULT;        if ((pi->prstatus.pr_flags& PR_ISTOP)&& ioctl (pi->ctl_fd, PIOCRUN,&pi->prrun) !=
literal|0
argument|)
endif|#
directive|endif
comment|/* !UNIXWARE */
argument|perror_with_name (pi->pathname);        pi->new_child =
literal|0
argument|;
comment|/* No longer new */
argument|return
literal|0
argument|;     }
comment|/* We're the proud parent of a new thread.  Setup an exit trap for lwp_create      in the child and continue the parent.  */
comment|/* Third arg is pointer to new thread id. */
argument|lwp_id = read_memory_integer (      THE_PR_LWP(pi->prstatus).pr_sysarg[
literal|2
argument|], sizeof (int));    lwp_id = (lwp_id<<
literal|16
argument|) | PIDGET (pi->pid);    childpi = create_procinfo (lwp_id);
comment|/* The new process has actually inherited the lwp_create syscall trap from      it's parent, but we still have to call this to register handlers for      that child.  */
argument|procfs_set_inferior_syscall_traps (childpi);   add_thread (lwp_id);   printf_filtered (
literal|"[New %s]\n"
argument|, target_pid_to_str (lwp_id));
comment|/* Continue the parent */
ifdef|#
directive|ifdef
name|UNIXWARE
argument|pctl.cmd = PCRUN;   pctl.data = PRCFAULT;    if (write(pi->ctl_fd, (char *)&pctl, sizeof (struct proc_ctl))<
literal|0
argument|)
else|#
directive|else
argument|pi->prrun.pr_flags&= PRSTEP;   pi->prrun.pr_flags |= PRCFAULT;   if (ioctl (pi->ctl_fd, PIOCRUN,&pi->prrun) !=
literal|0
argument|)
endif|#
directive|endif
argument|perror_with_name (pi->pathname);
comment|/* The new child may have been created in one of two states:       SUSPENDED or RUNNABLE.  If runnable, we will simply signal it to run.      If suspended, we flag it to be continued later, when it has an event.  */
argument|if (THE_PR_LWP(childpi->prstatus).pr_why == PR_SUSPENDED)     childpi->new_child =
literal|1
argument|;
comment|/* Flag this as an unseen child process */
argument|else     {
comment|/* Continue the child */
ifdef|#
directive|ifdef
name|UNIXWARE
argument|pctl.cmd = PCRUN;       pctl.data = PRCFAULT;        if (write(pi->ctl_fd, (char *)&pctl, sizeof (struct proc_ctl))<
literal|0
argument|)
else|#
directive|else
argument|childpi->prrun.pr_flags&= PRSTEP;       childpi->prrun.pr_flags |= PRCFAULT;        if (ioctl (childpi->ctl_fd, PIOCRUN,&childpi->prrun) !=
literal|0
argument|)
endif|#
directive|endif
argument|perror_with_name (childpi->pathname);     }   return
literal|0
argument|; }
endif|#
directive|endif
comment|/* SYS_lwp_create */
comment|/* Fork an inferior process, and start debugging it with /proc.  */
argument|static void procfs_create_inferior (exec_file, allargs, env)      char *exec_file;      char *allargs;      char **env; {   char *shell_file = getenv (
literal|"SHELL"
argument|);   char *tryname;   if (shell_file != NULL&& strchr (shell_file,
literal|'/'
argument|) == NULL)     {
comment|/* We will be looking down the PATH to find shell_file.  If we 	 just do this the normal way (via execlp, which operates by 	 attempting an exec for each element of the PATH until it 	 finds one which succeeds), then there will be an exec for 	 each failed attempt, each of which will cause a PR_SYSEXIT 	 stop, and we won't know how to distinguish the PR_SYSEXIT's 	 for these failed execs with the ones for successful execs 	 (whether the exec has succeeded is stored at that time in the 	 carry bit or some such architecture-specific and 	 non-ABI-specified place).  	 So I can't think of anything better than to search the PATH 	 now.  This has several disadvantages: (1) There is a race 	 condition; if we find a file now and it is deleted before we 	 exec it, we lose, even if the deletion leaves a valid file 	 further down in the PATH, (2) there is no way to know exactly 	 what an executable (in the sense of "capable of being 	 exec'd") file is.  Using access() loses because it may lose 	 if the caller is the superuser; failing to use it loses if 	 there are ACLs or some such.  */
argument|char *p;       char *p1;
comment|/* FIXME-maybe: might want "set path" command so user can change what 	 path is used from within GDB.  */
argument|char *path = getenv (
literal|"PATH"
argument|);       int len;       struct stat statbuf;        if (path == NULL) 	path =
literal|"/bin:/usr/bin"
argument|;        tryname = alloca (strlen (path) + strlen (shell_file) +
literal|2
argument|);       for (p = path; p != NULL; p = p1 ? p1 +
literal|1
argument|: NULL) 	{ 	  p1 = strchr (p,
literal|':'
argument|); 	  if (p1 != NULL) 	    len = p1 - p; 	  else 	    len = strlen (p); 	  strncpy (tryname, p, len); 	  tryname[len] =
literal|'\0'
argument|; 	  strcat (tryname,
literal|"/"
argument|); 	  strcat (tryname, shell_file); 	  if (access (tryname, X_OK)<
literal|0
argument|) 	    continue; 	  if (stat (tryname,&statbuf)<
literal|0
argument|) 	    continue; 	  if (!S_ISREG (statbuf.st_mode))
comment|/* We certainly need to reject directories.  I'm not quite 	       as sure about FIFOs, sockets, etc., but I kind of doubt 	       that people want to exec() these things.  */
argument|continue; 	  break; 	}       if (p == NULL)
comment|/* Not found.  This must be an error rather than merely passing 	   the file to execlp(), because execlp() would try all the 	   exec()s, causing GDB to get confused.  */
argument|error (
literal|"Can't find shell %s in PATH"
argument|, shell_file);        shell_file = tryname;     }    fork_inferior (exec_file, allargs, env, 		 proc_set_exec_trap, procfs_init_inferior, NULL, shell_file);
comment|/* We are at the first instruction we care about.  */
comment|/* Pedal to the metal... */
argument|proceed ((CORE_ADDR) -
literal|1
argument|, TARGET_SIGNAL_0,
literal|0
argument|); }
comment|/* Clean up after the inferior dies.  */
argument|static void procfs_mourn_inferior () {   struct procinfo *pi;   struct procinfo *next_pi;    for (pi = procinfo_list; pi; pi = next_pi)     {       next_pi = pi->next;       unconditionally_kill_inferior (pi);     }    unpush_target (&procfs_ops);   generic_mourn_inferior (); }
comment|/* Mark our target-struct as eligible for stray "run" and "attach" commands.  */
argument|static int procfs_can_run () {
comment|/* This variable is controlled by modules that sit atop procfs that may layer      their own process structure atop that provided here.  sol-thread.c does      this because of the Solaris two-level thread model.  */
argument|return !procfs_suppress_run; }
ifdef|#
directive|ifdef
name|TARGET_HAS_HARDWARE_WATCHPOINTS
ifndef|#
directive|ifndef
name|UNIXWARE
comment|/* Insert a watchpoint */
argument|int procfs_set_watchpoint(pid, addr, len, rw)      int		pid;      CORE_ADDR		addr;      int		len;      int		rw; {   struct procinfo	*pi;   prwatch_t		wpt;    pi = find_procinfo (pid == -
literal|1
argument|? inferior_pid : pid,
literal|0
argument|);   wpt.pr_vaddr = (caddr_t)addr;   wpt.pr_size = len;   wpt.pr_wflags = ((rw&
literal|1
argument|) ? MA_READ :
literal|0
argument|) | ((rw&
literal|2
argument|) ? MA_WRITE :
literal|0
argument|);   if (ioctl (pi->ctl_fd, PIOCSWATCH,&wpt)<
literal|0
argument|)     {       if (errno == E2BIG) 	return -
literal|1
argument|;
comment|/* Currently it sometimes happens that the same watchpoint gets 	 deleted twice - don't die in this case (FIXME please) */
argument|if (errno == ESRCH&& len ==
literal|0
argument|) 	return
literal|0
argument|;       print_sys_errmsg (pi->pathname, errno);       error (
literal|"PIOCSWATCH failed"
argument|);     }   return
literal|0
argument|; }  int procfs_stopped_by_watchpoint(pid)     int			pid; {   struct procinfo	*pi;   short 		what;   short 		why;    pi = find_procinfo (pid == -
literal|1
argument|? inferior_pid : pid,
literal|0
argument|);   if (pi->prstatus.pr_flags& (PR_STOPPED | PR_ISTOP))     {       why = pi->prstatus.pr_why;       what = pi->prstatus.pr_what;       if (why == PR_FAULTED
if|#
directive|if
name|defined
argument_list|(
name|FLTWATCH
argument_list|)
operator|&&
name|defined
argument_list|(
name|FLTKWATCH
argument_list|)
argument|&& (what == FLTWATCH || what == FLTKWATCH)
else|#
directive|else
ifdef|#
directive|ifdef
name|FLTWATCH
argument|&& (what == FLTWATCH)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FLTKWATCH
argument|&& (what == FLTKWATCH)
endif|#
directive|endif
endif|#
directive|endif
argument|) 	return what;     }   return
literal|0
argument|; }
endif|#
directive|endif
comment|/* !UNIXWARE */
endif|#
directive|endif
comment|/* TARGET_HAS_HARDWARE_WATCHPOINTS */
comment|/* Why is this necessary?  Shouldn't dead threads just be removed from the    thread database?  */
argument|static int procfs_thread_alive (pid)      int pid; {   struct procinfo *pi, *next_pi;    for (pi = procinfo_list; pi; pi = next_pi)     {       next_pi = pi->next;       if (pi -> pid == pid) 	if (procfs_read_status (pi))
comment|/* alive */
argument|return
literal|1
argument|; 	else
comment|/* defunct (exited) */
argument|{ 	    close_proc_file (pi); 	    return
literal|0
argument|; 	  }     }   return
literal|0
argument|; }  int procfs_first_available () {   struct procinfo *pi;    for (pi = procinfo_list; pi; pi = pi->next)     {       if (procfs_read_status (pi)) 	return pi->pid;     }   return -
literal|1
argument|; }  int procfs_get_pid_fd (pid)      int pid; {   struct procinfo *pi = find_procinfo (pid,
literal|1
argument|);    if (pi == NULL)     return -
literal|1
argument|;    return pi->ctl_fd; }
comment|/* Send a SIGINT to the process group.  This acts just like the user typed a    ^C on the controlling terminal.     XXX - This may not be correct for all systems.  Some may want to use    killpg() instead of kill (-pgrp). */
argument|static void procfs_stop () {   extern pid_t inferior_process_group;    kill (-inferior_process_group, SIGINT); }
comment|/* Convert a pid to printable form. */
ifdef|#
directive|ifdef
name|TIDGET
argument|char * procfs_pid_to_str (pid)      int pid; {   static char buf[
literal|100
argument|];    sprintf (buf,
literal|"Kernel thread %d"
argument|, TIDGET (pid));    return buf; }
endif|#
directive|endif
comment|/* TIDGET */
argument|static void init_procfs_ops () {   procfs_ops.to_shortname =
literal|"procfs"
argument|;   procfs_ops.to_longname =
literal|"Unix /proc child process"
argument|;   procfs_ops.to_doc =
literal|"Unix /proc child process (started by the \"run\" command)."
argument|;   procfs_ops.to_open = procfs_open;   procfs_ops.to_attach = procfs_attach;   procfs_ops.to_detach = procfs_detach;   procfs_ops.to_resume = procfs_resume;   procfs_ops.to_wait = procfs_wait;   procfs_ops.to_fetch_registers = procfs_fetch_registers;   procfs_ops.to_store_registers = procfs_store_registers;   procfs_ops.to_prepare_to_store = procfs_prepare_to_store;   procfs_ops.to_xfer_memory = procfs_xfer_memory;   procfs_ops.to_files_info = procfs_files_info;   procfs_ops.to_insert_breakpoint = memory_insert_breakpoint;   procfs_ops.to_remove_breakpoint = memory_remove_breakpoint;   procfs_ops.to_terminal_init = terminal_init_inferior;   procfs_ops.to_terminal_inferior = terminal_inferior;   procfs_ops.to_terminal_ours_for_output = terminal_ours_for_output;   procfs_ops.to_terminal_ours = terminal_ours;   procfs_ops.to_terminal_info = child_terminal_info;   procfs_ops.to_kill = procfs_kill_inferior;   procfs_ops.to_create_inferior = procfs_create_inferior;   procfs_ops.to_mourn_inferior = procfs_mourn_inferior;   procfs_ops.to_can_run = procfs_can_run;   procfs_ops.to_notice_signals = procfs_notice_signals;   procfs_ops.to_thread_alive = procfs_thread_alive;   procfs_ops.to_stop = procfs_stop;   procfs_ops.to_stratum = process_stratum;   procfs_ops.to_has_all_memory =
literal|1
argument|;   procfs_ops.to_has_memory =
literal|1
argument|;   procfs_ops.to_has_stack =
literal|1
argument|;   procfs_ops.to_has_registers =
literal|1
argument|;   procfs_ops.to_has_execution =
literal|1
argument|;   procfs_ops.to_magic = OPS_MAGIC; }  void _initialize_procfs () {
ifdef|#
directive|ifdef
name|HAVE_OPTIONAL_PROC_FS
argument|char procname[MAX_PROC_NAME_SIZE];   int fd;
comment|/* If we have an optional /proc filesystem (e.g. under OSF/1),      don't add procfs support if we cannot access the running      GDB via /proc.  */
argument|sprintf (procname, STATUS_PROC_NAME_FMT, getpid ());   if ((fd = open (procname, O_RDONLY))<
literal|0
argument|)     return;   close (fd);
endif|#
directive|endif
argument|init_procfs_ops ();   add_target (&procfs_ops);    add_info (
literal|"processes"
argument|, info_proc,
literal|"Show process status information using /proc entry.\n\ Specify process id or use current inferior by default.\n\ Specify keywords for detailed information; default is summary.\n\ Keywords are: `all', `faults', `flags', `id', `mappings', `signals',\n\ `status', `syscalls', and `times'.\n\ Unambiguous abbreviations may be used."
argument|);    init_syscall_table (); }
end_function

end_unit

