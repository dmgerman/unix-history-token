begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Machine independent support for SVR4 /proc (process file system) for GDB.    Copyright 1991, 1992, 1993, 1994, 1995, 1996 Free Software Foundation, Inc.    Written by Fred Fish at Cygnus Support.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/*			N  O  T  E  S  For information on the details of using /proc consult section proc(4) in the UNIX System V Release 4 System Administrator's Reference Manual.  The general register and floating point register sets are manipulated by separate ioctl's.  This file makes the assumption that if FP0_REGNUM is defined, then support for the floating point register set is desired, regardless of whether or not the actual target has floating point hardware.   */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<sys/fault.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_include
include|#
directive|include
file|<sys/procfs.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<stropts.h>
end_include

begin_include
include|#
directive|include
file|<poll.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"thread.h"
end_include

begin_define
define|#
directive|define
name|MAX_SYSCALLS
value|256
end_define

begin_comment
comment|/* Maximum number of syscalls for table */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|PROC_NAME_FMT
end_ifndef

begin_define
define|#
directive|define
name|PROC_NAME_FMT
value|"/proc/%05d"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|procfs_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declaration */
end_comment

begin_if
if|#
directive|if
literal|1
end_if

begin_comment
comment|/* FIXME: Gross and ugly hack to resolve coredep.c global */
end_comment

begin_decl_stmt
name|CORE_ADDR
name|kernel_u_addr
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BROKEN_SIGINFO_H
end_ifdef

begin_comment
comment|/* Workaround broken SGS<sys/siginfo.h> */
end_comment

begin_undef
undef|#
directive|undef
name|si_pid
end_undef

begin_define
define|#
directive|define
name|si_pid
value|_data._proc.pid
end_define

begin_undef
undef|#
directive|undef
name|si_uid
end_undef

begin_define
define|#
directive|define
name|si_uid
value|_data._proc._pdata._kill.uid
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BROKEN_SIGINFO_H */
end_comment

begin_comment
comment|/*  All access to the inferior, either one started by gdb or one that has     been attached to, is controlled by an instance of a procinfo structure,     defined below.  Since gdb currently only handles one inferior at a time,     the procinfo structure for the inferior is statically allocated and     only one exists at any given time.  There is a separate procinfo     structure for use by the "info proc" command, so that we can print     useful information about any random process without interfering with     the inferior's procinfo information. */
end_comment

begin_struct
struct|struct
name|procinfo
block|{
name|struct
name|procinfo
modifier|*
name|next
decl_stmt|;
name|int
name|pid
decl_stmt|;
comment|/* Process ID of inferior */
name|int
name|fd
decl_stmt|;
comment|/* File descriptor for /proc entry */
name|char
modifier|*
name|pathname
decl_stmt|;
comment|/* Pathname to /proc entry */
name|int
name|had_event
decl_stmt|;
comment|/* poll/select says something happened */
name|int
name|was_stopped
decl_stmt|;
comment|/* Nonzero if was stopped prior to attach */
name|int
name|nopass_next_sigstop
decl_stmt|;
comment|/* Don't pass a sigstop on next resume */
name|prrun_t
name|prrun
decl_stmt|;
comment|/* Control state when it is run */
name|prstatus_t
name|prstatus
decl_stmt|;
comment|/* Current process status info */
name|gregset_t
name|gregset
decl_stmt|;
comment|/* General register set */
name|fpregset_t
name|fpregset
decl_stmt|;
comment|/* Floating point register set */
name|fltset_t
name|fltset
decl_stmt|;
comment|/* Current traced hardware fault set */
name|sigset_t
name|trace
decl_stmt|;
comment|/* Current traced signal set */
name|sysset_t
name|exitset
decl_stmt|;
comment|/* Current traced system call exit set */
name|sysset_t
name|entryset
decl_stmt|;
comment|/* Current traced system call entry set */
name|fltset_t
name|saved_fltset
decl_stmt|;
comment|/* Saved traced hardware fault set */
name|sigset_t
name|saved_trace
decl_stmt|;
comment|/* Saved traced signal set */
name|sigset_t
name|saved_sighold
decl_stmt|;
comment|/* Saved held signal set */
name|sysset_t
name|saved_exitset
decl_stmt|;
comment|/* Saved traced system call exit set */
name|sysset_t
name|saved_entryset
decl_stmt|;
comment|/* Saved traced system call entry set */
block|}
struct|;
end_struct

begin_comment
comment|/* List of inferior process information */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|procinfo
modifier|*
name|procinfo_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pollfd
modifier|*
name|poll_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pollfds used for waiting on /proc */
end_comment

begin_decl_stmt
specifier|static
name|int
name|num_poll_list
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of entries in poll_list */
end_comment

begin_decl_stmt
specifier|static
name|int
name|last_resume_pid
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last pid used with procfs_resume */
end_comment

begin_comment
comment|/*  Much of the information used in the /proc interface, particularly for     printing status information, is kept as tables of structures of the     following form.  These tables can be used to map numeric values to     their symbolic names and to a string that describes their specific use. */
end_comment

begin_struct
struct|struct
name|trans
block|{
name|int
name|value
decl_stmt|;
comment|/* The numeric value */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The equivalent symbolic value */
name|char
modifier|*
name|desc
decl_stmt|;
comment|/* Short description of value */
block|}
struct|;
end_struct

begin_comment
comment|/*  Translate bits in the pr_flags member of the prstatus structure, into the     names and desc information. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|trans
name|pr_flag_table
index|[]
init|=
block|{
if|#
directive|if
name|defined
argument_list|(
name|PR_STOPPED
argument_list|)
block|{
name|PR_STOPPED
block|,
literal|"PR_STOPPED"
block|,
literal|"Process is stopped"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_ISTOP
argument_list|)
block|{
name|PR_ISTOP
block|,
literal|"PR_ISTOP"
block|,
literal|"Stopped on an event of interest"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_DSTOP
argument_list|)
block|{
name|PR_DSTOP
block|,
literal|"PR_DSTOP"
block|,
literal|"A stop directive is in effect"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_ASLEEP
argument_list|)
block|{
name|PR_ASLEEP
block|,
literal|"PR_ASLEEP"
block|,
literal|"Sleeping in an interruptible system call"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_FORK
argument_list|)
block|{
name|PR_FORK
block|,
literal|"PR_FORK"
block|,
literal|"Inherit-on-fork is in effect"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_RLC
argument_list|)
block|{
name|PR_RLC
block|,
literal|"PR_RLC"
block|,
literal|"Run-on-last-close is in effect"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_PTRACE
argument_list|)
block|{
name|PR_PTRACE
block|,
literal|"PR_PTRACE"
block|,
literal|"Process is being controlled by ptrace"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_PCINVAL
argument_list|)
block|{
name|PR_PCINVAL
block|,
literal|"PR_PCINVAL"
block|,
literal|"PC refers to an invalid virtual address"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_ISSYS
argument_list|)
block|{
name|PR_ISSYS
block|,
literal|"PR_ISSYS"
block|,
literal|"Is a system process"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_STEP
argument_list|)
block|{
name|PR_STEP
block|,
literal|"PR_STEP"
block|,
literal|"Process has single step pending"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_KLC
argument_list|)
block|{
name|PR_KLC
block|,
literal|"PR_KLC"
block|,
literal|"Kill-on-last-close is in effect"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_ASYNC
argument_list|)
block|{
name|PR_ASYNC
block|,
literal|"PR_ASYNC"
block|,
literal|"Asynchronous stop is in effect"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_PCOMPAT
argument_list|)
block|{
name|PR_PCOMPAT
block|,
literal|"PR_PCOMPAT"
block|,
literal|"Ptrace compatibility mode in effect"
block|}
block|,
endif|#
directive|endif
block|{
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  Translate values in the pr_why field of the prstatus struct. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|trans
name|pr_why_table
index|[]
init|=
block|{
if|#
directive|if
name|defined
argument_list|(
name|PR_REQUESTED
argument_list|)
block|{
name|PR_REQUESTED
block|,
literal|"PR_REQUESTED"
block|,
literal|"Directed to stop via PIOCSTOP/PIOCWSTOP"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_SIGNALLED
argument_list|)
block|{
name|PR_SIGNALLED
block|,
literal|"PR_SIGNALLED"
block|,
literal|"Receipt of a traced signal"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_FAULTED
argument_list|)
block|{
name|PR_FAULTED
block|,
literal|"PR_FAULTED"
block|,
literal|"Incurred a traced hardware fault"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_SYSENTRY
argument_list|)
block|{
name|PR_SYSENTRY
block|,
literal|"PR_SYSENTRY"
block|,
literal|"Entry to a traced system call"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_SYSEXIT
argument_list|)
block|{
name|PR_SYSEXIT
block|,
literal|"PR_SYSEXIT"
block|,
literal|"Exit from a traced system call"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_JOBCONTROL
argument_list|)
block|{
name|PR_JOBCONTROL
block|,
literal|"PR_JOBCONTROL"
block|,
literal|"Default job control stop signal action"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_SUSPENDED
argument_list|)
block|{
name|PR_SUSPENDED
block|,
literal|"PR_SUSPENDED"
block|,
literal|"Process suspended"
block|}
block|,
endif|#
directive|endif
block|{
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  Hardware fault translation table. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|trans
name|faults_table
index|[]
init|=
block|{
if|#
directive|if
name|defined
argument_list|(
name|FLTILL
argument_list|)
block|{
name|FLTILL
block|,
literal|"FLTILL"
block|,
literal|"Illegal instruction"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|FLTPRIV
argument_list|)
block|{
name|FLTPRIV
block|,
literal|"FLTPRIV"
block|,
literal|"Privileged instruction"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|FLTBPT
argument_list|)
block|{
name|FLTBPT
block|,
literal|"FLTBPT"
block|,
literal|"Breakpoint trap"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|FLTTRACE
argument_list|)
block|{
name|FLTTRACE
block|,
literal|"FLTTRACE"
block|,
literal|"Trace trap"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|FLTACCESS
argument_list|)
block|{
name|FLTACCESS
block|,
literal|"FLTACCESS"
block|,
literal|"Memory access fault"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|FLTBOUNDS
argument_list|)
block|{
name|FLTBOUNDS
block|,
literal|"FLTBOUNDS"
block|,
literal|"Memory bounds violation"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|FLTIOVF
argument_list|)
block|{
name|FLTIOVF
block|,
literal|"FLTIOVF"
block|,
literal|"Integer overflow"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|FLTIZDIV
argument_list|)
block|{
name|FLTIZDIV
block|,
literal|"FLTIZDIV"
block|,
literal|"Integer zero divide"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|FLTFPE
argument_list|)
block|{
name|FLTFPE
block|,
literal|"FLTFPE"
block|,
literal|"Floating-point exception"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|FLTSTACK
argument_list|)
block|{
name|FLTSTACK
block|,
literal|"FLTSTACK"
block|,
literal|"Unrecoverable stack fault"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|FLTPAGE
argument_list|)
block|{
name|FLTPAGE
block|,
literal|"FLTPAGE"
block|,
literal|"Recoverable page fault"
block|}
block|,
endif|#
directive|endif
block|{
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Translation table for signal generation information.  See UNIX System    V Release 4 Programmer's Reference Manual, siginfo(5).  */
end_comment

begin_struct
specifier|static
struct|struct
name|sigcode
block|{
name|int
name|signo
decl_stmt|;
name|int
name|code
decl_stmt|;
name|char
modifier|*
name|codename
decl_stmt|;
name|char
modifier|*
name|desc
decl_stmt|;
block|}
name|siginfo_table
index|[]
init|=
block|{
if|#
directive|if
name|defined
argument_list|(
name|SIGILL
argument_list|)
operator|&&
name|defined
argument_list|(
name|ILL_ILLOPC
argument_list|)
block|{
name|SIGILL
block|,
name|ILL_ILLOPC
block|,
literal|"ILL_ILLOPC"
block|,
literal|"Illegal opcode"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGILL
argument_list|)
operator|&&
name|defined
argument_list|(
name|ILL_ILLOPN
argument_list|)
block|{
name|SIGILL
block|,
name|ILL_ILLOPN
block|,
literal|"ILL_ILLOPN"
block|,
literal|"Illegal operand"
block|, }
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGILL
argument_list|)
operator|&&
name|defined
argument_list|(
name|ILL_ILLADR
argument_list|)
block|{
name|SIGILL
block|,
name|ILL_ILLADR
block|,
literal|"ILL_ILLADR"
block|,
literal|"Illegal addressing mode"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGILL
argument_list|)
operator|&&
name|defined
argument_list|(
name|ILL_ILLTRP
argument_list|)
block|{
name|SIGILL
block|,
name|ILL_ILLTRP
block|,
literal|"ILL_ILLTRP"
block|,
literal|"Illegal trap"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGILL
argument_list|)
operator|&&
name|defined
argument_list|(
name|ILL_PRVOPC
argument_list|)
block|{
name|SIGILL
block|,
name|ILL_PRVOPC
block|,
literal|"ILL_PRVOPC"
block|,
literal|"Privileged opcode"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGILL
argument_list|)
operator|&&
name|defined
argument_list|(
name|ILL_PRVREG
argument_list|)
block|{
name|SIGILL
block|,
name|ILL_PRVREG
block|,
literal|"ILL_PRVREG"
block|,
literal|"Privileged register"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGILL
argument_list|)
operator|&&
name|defined
argument_list|(
name|ILL_COPROC
argument_list|)
block|{
name|SIGILL
block|,
name|ILL_COPROC
block|,
literal|"ILL_COPROC"
block|,
literal|"Coprocessor error"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGILL
argument_list|)
operator|&&
name|defined
argument_list|(
name|ILL_BADSTK
argument_list|)
block|{
name|SIGILL
block|,
name|ILL_BADSTK
block|,
literal|"ILL_BADSTK"
block|,
literal|"Internal stack error"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGFPE
argument_list|)
operator|&&
name|defined
argument_list|(
name|FPE_INTDIV
argument_list|)
block|{
name|SIGFPE
block|,
name|FPE_INTDIV
block|,
literal|"FPE_INTDIV"
block|,
literal|"Integer divide by zero"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGFPE
argument_list|)
operator|&&
name|defined
argument_list|(
name|FPE_INTOVF
argument_list|)
block|{
name|SIGFPE
block|,
name|FPE_INTOVF
block|,
literal|"FPE_INTOVF"
block|,
literal|"Integer overflow"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGFPE
argument_list|)
operator|&&
name|defined
argument_list|(
name|FPE_FLTDIV
argument_list|)
block|{
name|SIGFPE
block|,
name|FPE_FLTDIV
block|,
literal|"FPE_FLTDIV"
block|,
literal|"Floating point divide by zero"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGFPE
argument_list|)
operator|&&
name|defined
argument_list|(
name|FPE_FLTOVF
argument_list|)
block|{
name|SIGFPE
block|,
name|FPE_FLTOVF
block|,
literal|"FPE_FLTOVF"
block|,
literal|"Floating point overflow"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGFPE
argument_list|)
operator|&&
name|defined
argument_list|(
name|FPE_FLTUND
argument_list|)
block|{
name|SIGFPE
block|,
name|FPE_FLTUND
block|,
literal|"FPE_FLTUND"
block|,
literal|"Floating point underflow"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGFPE
argument_list|)
operator|&&
name|defined
argument_list|(
name|FPE_FLTRES
argument_list|)
block|{
name|SIGFPE
block|,
name|FPE_FLTRES
block|,
literal|"FPE_FLTRES"
block|,
literal|"Floating point inexact result"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGFPE
argument_list|)
operator|&&
name|defined
argument_list|(
name|FPE_FLTINV
argument_list|)
block|{
name|SIGFPE
block|,
name|FPE_FLTINV
block|,
literal|"FPE_FLTINV"
block|,
literal|"Invalid floating point operation"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGFPE
argument_list|)
operator|&&
name|defined
argument_list|(
name|FPE_FLTSUB
argument_list|)
block|{
name|SIGFPE
block|,
name|FPE_FLTSUB
block|,
literal|"FPE_FLTSUB"
block|,
literal|"Subscript out of range"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGSEGV
argument_list|)
operator|&&
name|defined
argument_list|(
name|SEGV_MAPERR
argument_list|)
block|{
name|SIGSEGV
block|,
name|SEGV_MAPERR
block|,
literal|"SEGV_MAPERR"
block|,
literal|"Address not mapped to object"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGSEGV
argument_list|)
operator|&&
name|defined
argument_list|(
name|SEGV_ACCERR
argument_list|)
block|{
name|SIGSEGV
block|,
name|SEGV_ACCERR
block|,
literal|"SEGV_ACCERR"
block|,
literal|"Invalid permissions for object"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGBUS
argument_list|)
operator|&&
name|defined
argument_list|(
name|BUS_ADRALN
argument_list|)
block|{
name|SIGBUS
block|,
name|BUS_ADRALN
block|,
literal|"BUS_ADRALN"
block|,
literal|"Invalid address alignment"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGBUS
argument_list|)
operator|&&
name|defined
argument_list|(
name|BUS_ADRERR
argument_list|)
block|{
name|SIGBUS
block|,
name|BUS_ADRERR
block|,
literal|"BUS_ADRERR"
block|,
literal|"Non-existent physical address"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGBUS
argument_list|)
operator|&&
name|defined
argument_list|(
name|BUS_OBJERR
argument_list|)
block|{
name|SIGBUS
block|,
name|BUS_OBJERR
block|,
literal|"BUS_OBJERR"
block|,
literal|"Object specific hardware error"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGTRAP
argument_list|)
operator|&&
name|defined
argument_list|(
name|TRAP_BRKPT
argument_list|)
block|{
name|SIGTRAP
block|,
name|TRAP_BRKPT
block|,
literal|"TRAP_BRKPT"
block|,
literal|"Process breakpoint"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGTRAP
argument_list|)
operator|&&
name|defined
argument_list|(
name|TRAP_TRACE
argument_list|)
block|{
name|SIGTRAP
block|,
name|TRAP_TRACE
block|,
literal|"TRAP_TRACE"
block|,
literal|"Process trace trap"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGCLD
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLD_EXITED
argument_list|)
block|{
name|SIGCLD
block|,
name|CLD_EXITED
block|,
literal|"CLD_EXITED"
block|,
literal|"Child has exited"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGCLD
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLD_KILLED
argument_list|)
block|{
name|SIGCLD
block|,
name|CLD_KILLED
block|,
literal|"CLD_KILLED"
block|,
literal|"Child was killed"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGCLD
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLD_DUMPED
argument_list|)
block|{
name|SIGCLD
block|,
name|CLD_DUMPED
block|,
literal|"CLD_DUMPED"
block|,
literal|"Child has terminated abnormally"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGCLD
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLD_TRAPPED
argument_list|)
block|{
name|SIGCLD
block|,
name|CLD_TRAPPED
block|,
literal|"CLD_TRAPPED"
block|,
literal|"Traced child has trapped"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGCLD
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLD_STOPPED
argument_list|)
block|{
name|SIGCLD
block|,
name|CLD_STOPPED
block|,
literal|"CLD_STOPPED"
block|,
literal|"Child has stopped"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGCLD
argument_list|)
operator|&&
name|defined
argument_list|(
name|CLD_CONTINUED
argument_list|)
block|{
name|SIGCLD
block|,
name|CLD_CONTINUED
block|,
literal|"CLD_CONTINUED"
block|,
literal|"Stopped child had continued"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPOLL
argument_list|)
operator|&&
name|defined
argument_list|(
name|POLL_IN
argument_list|)
block|{
name|SIGPOLL
block|,
name|POLL_IN
block|,
literal|"POLL_IN"
block|,
literal|"Input input available"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPOLL
argument_list|)
operator|&&
name|defined
argument_list|(
name|POLL_OUT
argument_list|)
block|{
name|SIGPOLL
block|,
name|POLL_OUT
block|,
literal|"POLL_OUT"
block|,
literal|"Output buffers available"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPOLL
argument_list|)
operator|&&
name|defined
argument_list|(
name|POLL_MSG
argument_list|)
block|{
name|SIGPOLL
block|,
name|POLL_MSG
block|,
literal|"POLL_MSG"
block|,
literal|"Input message available"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPOLL
argument_list|)
operator|&&
name|defined
argument_list|(
name|POLL_ERR
argument_list|)
block|{
name|SIGPOLL
block|,
name|POLL_ERR
block|,
literal|"POLL_ERR"
block|,
literal|"I/O error"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPOLL
argument_list|)
operator|&&
name|defined
argument_list|(
name|POLL_PRI
argument_list|)
block|{
name|SIGPOLL
block|,
name|POLL_PRI
block|,
literal|"POLL_PRI"
block|,
literal|"High priority input available"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SIGPOLL
argument_list|)
operator|&&
name|defined
argument_list|(
name|POLL_HUP
argument_list|)
block|{
name|SIGPOLL
block|,
name|POLL_HUP
block|,
literal|"POLL_HUP"
block|,
literal|"Device disconnected"
block|}
block|,
endif|#
directive|endif
block|{
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|char
modifier|*
name|syscall_table
index|[
name|MAX_SYSCALLS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_decl_stmt
specifier|static
name|void
name|set_proc_siginfo
name|PARAMS
argument_list|(
operator|(
expr|struct
name|procinfo
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_syscall_table
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|syscallname
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|signalname
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|errnoname
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|proc_address_to_fd
name|PARAMS
argument_list|(
operator|(
expr|struct
name|procinfo
operator|*
operator|,
name|CORE_ADDR
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|open_proc_file
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|procinfo
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|close_proc_file
name|PARAMS
argument_list|(
operator|(
expr|struct
name|procinfo
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|unconditionally_kill_inferior
name|PARAMS
argument_list|(
operator|(
expr|struct
name|procinfo
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|NORETURN
name|void
name|proc_init_failed
name|PARAMS
argument_list|(
operator|(
expr|struct
name|procinfo
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
name|ATTR_NORETURN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|info_proc
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|info_proc_flags
name|PARAMS
argument_list|(
operator|(
expr|struct
name|procinfo
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|info_proc_stop
name|PARAMS
argument_list|(
operator|(
expr|struct
name|procinfo
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|info_proc_siginfo
name|PARAMS
argument_list|(
operator|(
expr|struct
name|procinfo
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|info_proc_syscalls
name|PARAMS
argument_list|(
operator|(
expr|struct
name|procinfo
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|info_proc_mappings
name|PARAMS
argument_list|(
operator|(
expr|struct
name|procinfo
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|info_proc_signals
name|PARAMS
argument_list|(
operator|(
expr|struct
name|procinfo
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|info_proc_faults
name|PARAMS
argument_list|(
operator|(
expr|struct
name|procinfo
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|mappingflags
name|PARAMS
argument_list|(
operator|(
name|long
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lookupname
name|PARAMS
argument_list|(
operator|(
expr|struct
name|trans
operator|*
operator|,
name|unsigned
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lookupdesc
name|PARAMS
argument_list|(
operator|(
expr|struct
name|trans
operator|*
operator|,
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|do_attach
name|PARAMS
argument_list|(
operator|(
name|int
name|pid
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|do_detach
name|PARAMS
argument_list|(
operator|(
name|int
name|siggnal
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|procfs_create_inferior
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|procfs_notice_signals
name|PARAMS
argument_list|(
operator|(
name|int
name|pid
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|procinfo
modifier|*
name|find_procinfo
name|PARAMS
argument_list|(
operator|(
name|pid_t
name|pid
operator|,
name|int
name|okfail
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* External function prototypes that can't be easily included in any    header file because the args are typedefs in system include files. */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|supply_gregset
name|PARAMS
argument_list|(
operator|(
name|gregset_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|fill_gregset
name|PARAMS
argument_list|(
operator|(
name|gregset_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|supply_fpregset
name|PARAMS
argument_list|(
operator|(
name|fpregset_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|fill_fpregset
name|PARAMS
argument_list|(
operator|(
name|fpregset_t
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  LOCAL FUNCTION  	find_procinfo -- convert a process id to a struct procinfo  SYNOPSIS  	static struct procinfo * find_procinfo (pid_t pid, int okfail);  DESCRIPTION 	 	Given a process id, look it up in the procinfo chain.  Returns 	a struct procinfo *.  If can't find pid, then call error(), 	unless okfail is set, in which case, return NULL;  */
end_comment

begin_function
specifier|static
name|struct
name|procinfo
modifier|*
name|find_procinfo
parameter_list|(
name|pid
parameter_list|,
name|okfail
parameter_list|)
name|pid_t
name|pid
decl_stmt|;
name|int
name|okfail
decl_stmt|;
block|{
name|struct
name|procinfo
modifier|*
name|procinfo
decl_stmt|;
for|for
control|(
name|procinfo
operator|=
name|procinfo_list
init|;
name|procinfo
condition|;
name|procinfo
operator|=
name|procinfo
operator|->
name|next
control|)
if|if
condition|(
name|procinfo
operator|->
name|pid
operator|==
name|pid
condition|)
return|return
name|procinfo
return|;
if|if
condition|(
name|okfail
condition|)
return|return
name|NULL
return|;
name|error
argument_list|(
literal|"procfs (find_procinfo):  Couldn't locate pid %d"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  LOCAL MACRO  	current_procinfo -- convert inferior_pid to a struct procinfo  SYNOPSIS  	static struct procinfo * current_procinfo;  DESCRIPTION 	 	Looks up inferior_pid in the procinfo chain.  Always returns a 	struct procinfo *.  If process can't be found, we error() out.  */
end_comment

begin_define
define|#
directive|define
name|current_procinfo
value|find_procinfo (inferior_pid, 0)
end_define

begin_comment
comment|/*  LOCAL FUNCTION  	add_fd -- Add the fd to the poll/select list  SYNOPSIS  	static void add_fd (struct procinfo *);  DESCRIPTION 	 	Add the fd of the supplied procinfo to the list of fds used for 	poll/select operations.  */
end_comment

begin_function
specifier|static
name|void
name|add_fd
parameter_list|(
name|pi
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pi
decl_stmt|;
block|{
if|if
condition|(
name|num_poll_list
operator|<=
literal|0
condition|)
name|poll_list
operator|=
operator|(
expr|struct
name|pollfd
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pollfd
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|poll_list
operator|=
operator|(
expr|struct
name|pollfd
operator|*
operator|)
name|xrealloc
argument_list|(
name|poll_list
argument_list|,
operator|(
name|num_poll_list
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pollfd
argument_list|)
argument_list|)
expr_stmt|;
name|poll_list
index|[
name|num_poll_list
index|]
operator|.
name|fd
operator|=
name|pi
operator|->
name|fd
expr_stmt|;
name|poll_list
index|[
name|num_poll_list
index|]
operator|.
name|events
operator|=
name|POLLPRI
expr_stmt|;
name|num_poll_list
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|remove_fd
parameter_list|(
name|pi
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pi
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_poll_list
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|poll_list
index|[
name|i
index|]
operator|.
name|fd
operator|==
name|pi
operator|->
name|fd
condition|)
block|{
if|if
condition|(
name|i
operator|!=
name|num_poll_list
operator|-
literal|1
condition|)
name|memcpy
argument_list|(
name|poll_list
argument_list|,
name|poll_list
operator|+
name|i
operator|+
literal|1
argument_list|,
operator|(
name|num_poll_list
operator|-
name|i
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pollfd
argument_list|)
argument_list|)
expr_stmt|;
name|num_poll_list
operator|--
expr_stmt|;
if|if
condition|(
name|num_poll_list
operator|==
literal|0
condition|)
name|free
argument_list|(
name|poll_list
argument_list|)
expr_stmt|;
else|else
name|poll_list
operator|=
operator|(
expr|struct
name|pollfd
operator|*
operator|)
name|xrealloc
argument_list|(
name|poll_list
argument_list|,
name|num_poll_list
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pollfd
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_define
define|#
directive|define
name|LOSING_POLL
value|unixware_sux
end_define

begin_function
specifier|static
name|struct
name|procinfo
modifier|*
name|wait_fd
parameter_list|()
block|{
name|struct
name|procinfo
modifier|*
name|pi
decl_stmt|;
name|int
name|num_fds
decl_stmt|;
name|int
name|i
decl_stmt|;
name|set_sigint_trap
argument_list|()
expr_stmt|;
comment|/* Causes SIGINT to be passed on to the 			   attached process. */
name|set_sigio_trap
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|LOSING_POLL
name|num_fds
operator|=
name|poll
argument_list|(
name|poll_list
argument_list|,
name|num_poll_list
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|pi
operator|=
name|current_procinfo
expr_stmt|;
while|while
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|PIOCWSTOP
argument_list|,
operator|&
name|pi
operator|->
name|prstatus
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
comment|/* Process exited.  */
name|pi
operator|->
name|prstatus
operator|.
name|pr_flags
operator|=
literal|0
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"PIOCWSTOP failed"
argument_list|)
expr_stmt|;
block|}
block|}
name|pi
operator|->
name|had_event
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|clear_sigint_trap
argument_list|()
expr_stmt|;
name|clear_sigio_trap
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|LOSING_POLL
if|if
condition|(
name|num_fds
operator|<=
literal|0
condition|)
block|{
name|print_sys_errmsg
argument_list|(
literal|"poll failed\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Poll failed, returned %d"
argument_list|,
name|num_fds
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_poll_list
operator|&&
name|num_fds
operator|>
literal|0
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|poll_list
index|[
name|i
index|]
operator|.
name|revents
operator|&
operator|(
name|POLLPRI
operator||
name|POLLERR
operator||
name|POLLHUP
operator||
name|POLLNVAL
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|pi
operator|=
name|procinfo_list
init|;
name|pi
condition|;
name|pi
operator|=
name|pi
operator|->
name|next
control|)
block|{
if|if
condition|(
name|poll_list
index|[
name|i
index|]
operator|.
name|fd
operator|==
name|pi
operator|->
name|fd
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|PIOCSTATUS
argument_list|,
operator|&
name|pi
operator|->
name|prstatus
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"PIOCSTATUS failed"
argument_list|)
expr_stmt|;
block|}
name|num_fds
operator|--
expr_stmt|;
name|pi
operator|->
name|had_event
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|pi
condition|)
name|error
argument_list|(
literal|"procfs_wait: Couldn't find procinfo for fd %d\n"
argument_list|,
name|poll_list
index|[
name|i
index|]
operator|.
name|fd
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* LOSING_POLL */
return|return
name|pi
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	lookupdesc -- translate a value to a summary desc string  SYNOPSIS  	static char *lookupdesc (struct trans *transp, unsigned int val);  DESCRIPTION 	 	Given a pointer to a translation table and a value to be translated, 	lookup the desc string and return it.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|lookupdesc
parameter_list|(
name|transp
parameter_list|,
name|val
parameter_list|)
name|struct
name|trans
modifier|*
name|transp
decl_stmt|;
name|unsigned
name|int
name|val
decl_stmt|;
block|{
name|char
modifier|*
name|desc
decl_stmt|;
for|for
control|(
name|desc
operator|=
name|NULL
init|;
name|transp
operator|->
name|name
operator|!=
name|NULL
condition|;
name|transp
operator|++
control|)
block|{
if|if
condition|(
name|transp
operator|->
name|value
operator|==
name|val
condition|)
block|{
name|desc
operator|=
name|transp
operator|->
name|desc
expr_stmt|;
break|break;
block|}
block|}
comment|/* Didn't find a translation for the specified value, set a default one. */
if|if
condition|(
name|desc
operator|==
name|NULL
condition|)
block|{
name|desc
operator|=
literal|"Unknown"
expr_stmt|;
block|}
return|return
operator|(
name|desc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	lookupname -- translate a value to symbolic name  SYNOPSIS  	static char *lookupname (struct trans *transp, unsigned int val, 				 char *prefix);  DESCRIPTION 	 	Given a pointer to a translation table, a value to be translated, 	and a default prefix to return if the value can't be translated, 	match the value with one of the translation table entries and 	return a pointer to the symbolic name.  	If no match is found it just returns the value as a printable string, 	with the given prefix.  The previous such value, if any, is freed 	at this time.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|lookupname
parameter_list|(
name|transp
parameter_list|,
name|val
parameter_list|,
name|prefix
parameter_list|)
name|struct
name|trans
modifier|*
name|transp
decl_stmt|;
name|unsigned
name|int
name|val
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|locbuf
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
for|for
control|(
name|name
operator|=
name|NULL
init|;
name|transp
operator|->
name|name
operator|!=
name|NULL
condition|;
name|transp
operator|++
control|)
block|{
if|if
condition|(
name|transp
operator|->
name|value
operator|==
name|val
condition|)
block|{
name|name
operator|=
name|transp
operator|->
name|name
expr_stmt|;
break|break;
block|}
block|}
comment|/* Didn't find a translation for the specified value, build a default      one using the specified prefix and return it.  The lifetime of      the value is only until the next one is needed. */
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|locbuf
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|locbuf
argument_list|)
expr_stmt|;
block|}
name|locbuf
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|+
literal|16
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|locbuf
argument_list|,
literal|"%s %u"
argument_list|,
name|prefix
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|name
operator|=
name|locbuf
expr_stmt|;
block|}
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|sigcodename
parameter_list|(
name|sip
parameter_list|)
name|siginfo_t
modifier|*
name|sip
decl_stmt|;
block|{
name|struct
name|sigcode
modifier|*
name|scp
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
specifier|static
name|char
name|locbuf
index|[
literal|32
index|]
decl_stmt|;
for|for
control|(
name|scp
operator|=
name|siginfo_table
init|;
name|scp
operator|->
name|codename
operator|!=
name|NULL
condition|;
name|scp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|scp
operator|->
name|signo
operator|==
name|sip
operator|->
name|si_signo
operator|)
operator|&&
operator|(
name|scp
operator|->
name|code
operator|==
name|sip
operator|->
name|si_code
operator|)
condition|)
block|{
name|name
operator|=
name|scp
operator|->
name|codename
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|locbuf
argument_list|,
literal|"sigcode %u"
argument_list|,
name|sip
operator|->
name|si_signo
argument_list|)
expr_stmt|;
name|name
operator|=
name|locbuf
expr_stmt|;
block|}
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|sigcodedesc
parameter_list|(
name|sip
parameter_list|)
name|siginfo_t
modifier|*
name|sip
decl_stmt|;
block|{
name|struct
name|sigcode
modifier|*
name|scp
decl_stmt|;
name|char
modifier|*
name|desc
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|scp
operator|=
name|siginfo_table
init|;
name|scp
operator|->
name|codename
operator|!=
name|NULL
condition|;
name|scp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|scp
operator|->
name|signo
operator|==
name|sip
operator|->
name|si_signo
operator|)
operator|&&
operator|(
name|scp
operator|->
name|code
operator|==
name|sip
operator|->
name|si_code
operator|)
condition|)
block|{
name|desc
operator|=
name|scp
operator|->
name|desc
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|desc
operator|==
name|NULL
condition|)
block|{
name|desc
operator|=
literal|"Unrecognized signal or trap use"
expr_stmt|;
block|}
return|return
operator|(
name|desc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	syscallname - translate a system call number into a system call name  SYNOPSIS  	char *syscallname (int syscallnum)  DESCRIPTION  	Given a system call number, translate it into the printable name 	of a system call, or into "syscall<num>" if it is an unknown 	number.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|syscallname
parameter_list|(
name|syscallnum
parameter_list|)
name|int
name|syscallnum
decl_stmt|;
block|{
specifier|static
name|char
name|locbuf
index|[
literal|32
index|]
decl_stmt|;
name|char
modifier|*
name|rtnval
decl_stmt|;
if|if
condition|(
name|syscallnum
operator|>=
literal|0
operator|&&
name|syscallnum
operator|<
name|MAX_SYSCALLS
condition|)
block|{
name|rtnval
operator|=
name|syscall_table
index|[
name|syscallnum
index|]
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|locbuf
argument_list|,
literal|"syscall %u"
argument_list|,
name|syscallnum
argument_list|)
expr_stmt|;
name|rtnval
operator|=
name|locbuf
expr_stmt|;
block|}
return|return
operator|(
name|rtnval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	init_syscall_table - initialize syscall translation table  SYNOPSIS  	void init_syscall_table (void)  DESCRIPTION  	Dynamically initialize the translation table to convert system 	call numbers into printable system call names.  Done once per 	gdb run, on initialization.  NOTES  	This is awfully ugly, but preprocessor tricks to make it prettier 	tend to be nonportable.  */
end_comment

begin_function
specifier|static
name|void
name|init_syscall_table
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|SYS_exit
argument_list|)
name|syscall_table
index|[
name|SYS_exit
index|]
operator|=
literal|"exit"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_fork
argument_list|)
name|syscall_table
index|[
name|SYS_fork
index|]
operator|=
literal|"fork"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_read
argument_list|)
name|syscall_table
index|[
name|SYS_read
index|]
operator|=
literal|"read"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_write
argument_list|)
name|syscall_table
index|[
name|SYS_write
index|]
operator|=
literal|"write"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_open
argument_list|)
name|syscall_table
index|[
name|SYS_open
index|]
operator|=
literal|"open"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_close
argument_list|)
name|syscall_table
index|[
name|SYS_close
index|]
operator|=
literal|"close"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_wait
argument_list|)
name|syscall_table
index|[
name|SYS_wait
index|]
operator|=
literal|"wait"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_creat
argument_list|)
name|syscall_table
index|[
name|SYS_creat
index|]
operator|=
literal|"creat"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_link
argument_list|)
name|syscall_table
index|[
name|SYS_link
index|]
operator|=
literal|"link"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_unlink
argument_list|)
name|syscall_table
index|[
name|SYS_unlink
index|]
operator|=
literal|"unlink"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_exec
argument_list|)
name|syscall_table
index|[
name|SYS_exec
index|]
operator|=
literal|"exec"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_execv
argument_list|)
name|syscall_table
index|[
name|SYS_execv
index|]
operator|=
literal|"execv"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_execve
argument_list|)
name|syscall_table
index|[
name|SYS_execve
index|]
operator|=
literal|"execve"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_chdir
argument_list|)
name|syscall_table
index|[
name|SYS_chdir
index|]
operator|=
literal|"chdir"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_time
argument_list|)
name|syscall_table
index|[
name|SYS_time
index|]
operator|=
literal|"time"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_mknod
argument_list|)
name|syscall_table
index|[
name|SYS_mknod
index|]
operator|=
literal|"mknod"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_chmod
argument_list|)
name|syscall_table
index|[
name|SYS_chmod
index|]
operator|=
literal|"chmod"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_chown
argument_list|)
name|syscall_table
index|[
name|SYS_chown
index|]
operator|=
literal|"chown"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_brk
argument_list|)
name|syscall_table
index|[
name|SYS_brk
index|]
operator|=
literal|"brk"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_stat
argument_list|)
name|syscall_table
index|[
name|SYS_stat
index|]
operator|=
literal|"stat"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_lseek
argument_list|)
name|syscall_table
index|[
name|SYS_lseek
index|]
operator|=
literal|"lseek"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_getpid
argument_list|)
name|syscall_table
index|[
name|SYS_getpid
index|]
operator|=
literal|"getpid"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_mount
argument_list|)
name|syscall_table
index|[
name|SYS_mount
index|]
operator|=
literal|"mount"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_umount
argument_list|)
name|syscall_table
index|[
name|SYS_umount
index|]
operator|=
literal|"umount"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_setuid
argument_list|)
name|syscall_table
index|[
name|SYS_setuid
index|]
operator|=
literal|"setuid"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_getuid
argument_list|)
name|syscall_table
index|[
name|SYS_getuid
index|]
operator|=
literal|"getuid"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_stime
argument_list|)
name|syscall_table
index|[
name|SYS_stime
index|]
operator|=
literal|"stime"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_ptrace
argument_list|)
name|syscall_table
index|[
name|SYS_ptrace
index|]
operator|=
literal|"ptrace"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_alarm
argument_list|)
name|syscall_table
index|[
name|SYS_alarm
index|]
operator|=
literal|"alarm"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_fstat
argument_list|)
name|syscall_table
index|[
name|SYS_fstat
index|]
operator|=
literal|"fstat"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_pause
argument_list|)
name|syscall_table
index|[
name|SYS_pause
index|]
operator|=
literal|"pause"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_utime
argument_list|)
name|syscall_table
index|[
name|SYS_utime
index|]
operator|=
literal|"utime"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_stty
argument_list|)
name|syscall_table
index|[
name|SYS_stty
index|]
operator|=
literal|"stty"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_gtty
argument_list|)
name|syscall_table
index|[
name|SYS_gtty
index|]
operator|=
literal|"gtty"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_access
argument_list|)
name|syscall_table
index|[
name|SYS_access
index|]
operator|=
literal|"access"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_nice
argument_list|)
name|syscall_table
index|[
name|SYS_nice
index|]
operator|=
literal|"nice"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_statfs
argument_list|)
name|syscall_table
index|[
name|SYS_statfs
index|]
operator|=
literal|"statfs"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_sync
argument_list|)
name|syscall_table
index|[
name|SYS_sync
index|]
operator|=
literal|"sync"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_kill
argument_list|)
name|syscall_table
index|[
name|SYS_kill
index|]
operator|=
literal|"kill"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_fstatfs
argument_list|)
name|syscall_table
index|[
name|SYS_fstatfs
index|]
operator|=
literal|"fstatfs"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_pgrpsys
argument_list|)
name|syscall_table
index|[
name|SYS_pgrpsys
index|]
operator|=
literal|"pgrpsys"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_xenix
argument_list|)
name|syscall_table
index|[
name|SYS_xenix
index|]
operator|=
literal|"xenix"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_dup
argument_list|)
name|syscall_table
index|[
name|SYS_dup
index|]
operator|=
literal|"dup"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_pipe
argument_list|)
name|syscall_table
index|[
name|SYS_pipe
index|]
operator|=
literal|"pipe"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_times
argument_list|)
name|syscall_table
index|[
name|SYS_times
index|]
operator|=
literal|"times"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_profil
argument_list|)
name|syscall_table
index|[
name|SYS_profil
index|]
operator|=
literal|"profil"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_plock
argument_list|)
name|syscall_table
index|[
name|SYS_plock
index|]
operator|=
literal|"plock"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_setgid
argument_list|)
name|syscall_table
index|[
name|SYS_setgid
index|]
operator|=
literal|"setgid"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_getgid
argument_list|)
name|syscall_table
index|[
name|SYS_getgid
index|]
operator|=
literal|"getgid"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_signal
argument_list|)
name|syscall_table
index|[
name|SYS_signal
index|]
operator|=
literal|"signal"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_msgsys
argument_list|)
name|syscall_table
index|[
name|SYS_msgsys
index|]
operator|=
literal|"msgsys"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_sys3b
argument_list|)
name|syscall_table
index|[
name|SYS_sys3b
index|]
operator|=
literal|"sys3b"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_acct
argument_list|)
name|syscall_table
index|[
name|SYS_acct
index|]
operator|=
literal|"acct"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_shmsys
argument_list|)
name|syscall_table
index|[
name|SYS_shmsys
index|]
operator|=
literal|"shmsys"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_semsys
argument_list|)
name|syscall_table
index|[
name|SYS_semsys
index|]
operator|=
literal|"semsys"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_ioctl
argument_list|)
name|syscall_table
index|[
name|SYS_ioctl
index|]
operator|=
literal|"ioctl"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_uadmin
argument_list|)
name|syscall_table
index|[
name|SYS_uadmin
index|]
operator|=
literal|"uadmin"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_utssys
argument_list|)
name|syscall_table
index|[
name|SYS_utssys
index|]
operator|=
literal|"utssys"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_fsync
argument_list|)
name|syscall_table
index|[
name|SYS_fsync
index|]
operator|=
literal|"fsync"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_umask
argument_list|)
name|syscall_table
index|[
name|SYS_umask
index|]
operator|=
literal|"umask"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_chroot
argument_list|)
name|syscall_table
index|[
name|SYS_chroot
index|]
operator|=
literal|"chroot"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_fcntl
argument_list|)
name|syscall_table
index|[
name|SYS_fcntl
index|]
operator|=
literal|"fcntl"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_ulimit
argument_list|)
name|syscall_table
index|[
name|SYS_ulimit
index|]
operator|=
literal|"ulimit"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_rfsys
argument_list|)
name|syscall_table
index|[
name|SYS_rfsys
index|]
operator|=
literal|"rfsys"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_rmdir
argument_list|)
name|syscall_table
index|[
name|SYS_rmdir
index|]
operator|=
literal|"rmdir"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_mkdir
argument_list|)
name|syscall_table
index|[
name|SYS_mkdir
index|]
operator|=
literal|"mkdir"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_getdents
argument_list|)
name|syscall_table
index|[
name|SYS_getdents
index|]
operator|=
literal|"getdents"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_sysfs
argument_list|)
name|syscall_table
index|[
name|SYS_sysfs
index|]
operator|=
literal|"sysfs"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_getmsg
argument_list|)
name|syscall_table
index|[
name|SYS_getmsg
index|]
operator|=
literal|"getmsg"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_putmsg
argument_list|)
name|syscall_table
index|[
name|SYS_putmsg
index|]
operator|=
literal|"putmsg"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_poll
argument_list|)
name|syscall_table
index|[
name|SYS_poll
index|]
operator|=
literal|"poll"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_lstat
argument_list|)
name|syscall_table
index|[
name|SYS_lstat
index|]
operator|=
literal|"lstat"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_symlink
argument_list|)
name|syscall_table
index|[
name|SYS_symlink
index|]
operator|=
literal|"symlink"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_readlink
argument_list|)
name|syscall_table
index|[
name|SYS_readlink
index|]
operator|=
literal|"readlink"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_setgroups
argument_list|)
name|syscall_table
index|[
name|SYS_setgroups
index|]
operator|=
literal|"setgroups"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_getgroups
argument_list|)
name|syscall_table
index|[
name|SYS_getgroups
index|]
operator|=
literal|"getgroups"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_fchmod
argument_list|)
name|syscall_table
index|[
name|SYS_fchmod
index|]
operator|=
literal|"fchmod"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_fchown
argument_list|)
name|syscall_table
index|[
name|SYS_fchown
index|]
operator|=
literal|"fchown"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_sigprocmask
argument_list|)
name|syscall_table
index|[
name|SYS_sigprocmask
index|]
operator|=
literal|"sigprocmask"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_sigsuspend
argument_list|)
name|syscall_table
index|[
name|SYS_sigsuspend
index|]
operator|=
literal|"sigsuspend"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_sigaltstack
argument_list|)
name|syscall_table
index|[
name|SYS_sigaltstack
index|]
operator|=
literal|"sigaltstack"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_sigaction
argument_list|)
name|syscall_table
index|[
name|SYS_sigaction
index|]
operator|=
literal|"sigaction"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_sigpending
argument_list|)
name|syscall_table
index|[
name|SYS_sigpending
index|]
operator|=
literal|"sigpending"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_context
argument_list|)
name|syscall_table
index|[
name|SYS_context
index|]
operator|=
literal|"context"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_evsys
argument_list|)
name|syscall_table
index|[
name|SYS_evsys
index|]
operator|=
literal|"evsys"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_evtrapret
argument_list|)
name|syscall_table
index|[
name|SYS_evtrapret
index|]
operator|=
literal|"evtrapret"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_statvfs
argument_list|)
name|syscall_table
index|[
name|SYS_statvfs
index|]
operator|=
literal|"statvfs"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_fstatvfs
argument_list|)
name|syscall_table
index|[
name|SYS_fstatvfs
index|]
operator|=
literal|"fstatvfs"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_nfssys
argument_list|)
name|syscall_table
index|[
name|SYS_nfssys
index|]
operator|=
literal|"nfssys"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_waitsys
argument_list|)
name|syscall_table
index|[
name|SYS_waitsys
index|]
operator|=
literal|"waitsys"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_sigsendsys
argument_list|)
name|syscall_table
index|[
name|SYS_sigsendsys
index|]
operator|=
literal|"sigsendsys"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_hrtsys
argument_list|)
name|syscall_table
index|[
name|SYS_hrtsys
index|]
operator|=
literal|"hrtsys"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_acancel
argument_list|)
name|syscall_table
index|[
name|SYS_acancel
index|]
operator|=
literal|"acancel"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_async
argument_list|)
name|syscall_table
index|[
name|SYS_async
index|]
operator|=
literal|"async"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_priocntlsys
argument_list|)
name|syscall_table
index|[
name|SYS_priocntlsys
index|]
operator|=
literal|"priocntlsys"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_pathconf
argument_list|)
name|syscall_table
index|[
name|SYS_pathconf
index|]
operator|=
literal|"pathconf"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_mincore
argument_list|)
name|syscall_table
index|[
name|SYS_mincore
index|]
operator|=
literal|"mincore"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_mmap
argument_list|)
name|syscall_table
index|[
name|SYS_mmap
index|]
operator|=
literal|"mmap"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_mprotect
argument_list|)
name|syscall_table
index|[
name|SYS_mprotect
index|]
operator|=
literal|"mprotect"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_munmap
argument_list|)
name|syscall_table
index|[
name|SYS_munmap
index|]
operator|=
literal|"munmap"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_fpathconf
argument_list|)
name|syscall_table
index|[
name|SYS_fpathconf
index|]
operator|=
literal|"fpathconf"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_vfork
argument_list|)
name|syscall_table
index|[
name|SYS_vfork
index|]
operator|=
literal|"vfork"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_fchdir
argument_list|)
name|syscall_table
index|[
name|SYS_fchdir
index|]
operator|=
literal|"fchdir"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_readv
argument_list|)
name|syscall_table
index|[
name|SYS_readv
index|]
operator|=
literal|"readv"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_writev
argument_list|)
name|syscall_table
index|[
name|SYS_writev
index|]
operator|=
literal|"writev"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_xstat
argument_list|)
name|syscall_table
index|[
name|SYS_xstat
index|]
operator|=
literal|"xstat"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_lxstat
argument_list|)
name|syscall_table
index|[
name|SYS_lxstat
index|]
operator|=
literal|"lxstat"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_fxstat
argument_list|)
name|syscall_table
index|[
name|SYS_fxstat
index|]
operator|=
literal|"fxstat"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_xmknod
argument_list|)
name|syscall_table
index|[
name|SYS_xmknod
index|]
operator|=
literal|"xmknod"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_clocal
argument_list|)
name|syscall_table
index|[
name|SYS_clocal
index|]
operator|=
literal|"clocal"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_setrlimit
argument_list|)
name|syscall_table
index|[
name|SYS_setrlimit
index|]
operator|=
literal|"setrlimit"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_getrlimit
argument_list|)
name|syscall_table
index|[
name|SYS_getrlimit
index|]
operator|=
literal|"getrlimit"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_lchown
argument_list|)
name|syscall_table
index|[
name|SYS_lchown
index|]
operator|=
literal|"lchown"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_memcntl
argument_list|)
name|syscall_table
index|[
name|SYS_memcntl
index|]
operator|=
literal|"memcntl"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_getpmsg
argument_list|)
name|syscall_table
index|[
name|SYS_getpmsg
index|]
operator|=
literal|"getpmsg"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_putpmsg
argument_list|)
name|syscall_table
index|[
name|SYS_putpmsg
index|]
operator|=
literal|"putpmsg"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_rename
argument_list|)
name|syscall_table
index|[
name|SYS_rename
index|]
operator|=
literal|"rename"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_uname
argument_list|)
name|syscall_table
index|[
name|SYS_uname
index|]
operator|=
literal|"uname"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_setegid
argument_list|)
name|syscall_table
index|[
name|SYS_setegid
index|]
operator|=
literal|"setegid"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_sysconfig
argument_list|)
name|syscall_table
index|[
name|SYS_sysconfig
index|]
operator|=
literal|"sysconfig"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_adjtime
argument_list|)
name|syscall_table
index|[
name|SYS_adjtime
index|]
operator|=
literal|"adjtime"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_systeminfo
argument_list|)
name|syscall_table
index|[
name|SYS_systeminfo
index|]
operator|=
literal|"systeminfo"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_seteuid
argument_list|)
name|syscall_table
index|[
name|SYS_seteuid
index|]
operator|=
literal|"seteuid"
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SYS_sproc
argument_list|)
name|syscall_table
index|[
name|SYS_sproc
index|]
operator|=
literal|"sproc"
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	procfs_kill_inferior - kill any currently inferior  SYNOPSIS  	void procfs_kill_inferior (void)  DESCRIPTION  	Kill any current inferior.  NOTES  	Kills even attached inferiors.  Presumably the user has already 	been prompted that the inferior is an attached one rather than 	one started by gdb.  (FIXME?)  */
end_comment

begin_function
specifier|static
name|void
name|procfs_kill_inferior
parameter_list|()
block|{
name|target_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	unconditionally_kill_inferior - terminate the inferior  SYNOPSIS  	static void unconditionally_kill_inferior (struct procinfo *)  DESCRIPTION  	Kill the specified inferior.  NOTE  	A possibly useful enhancement would be to first try sending 	the inferior a terminate signal, politely asking it to commit 	suicide, before we murder it (we could call that 	politely_kill_inferior()).  */
end_comment

begin_function
specifier|static
name|void
name|unconditionally_kill_inferior
parameter_list|(
name|pi
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pi
decl_stmt|;
block|{
name|int
name|signo
decl_stmt|;
name|int
name|ppid
decl_stmt|;
name|ppid
operator|=
name|pi
operator|->
name|prstatus
operator|.
name|pr_ppid
expr_stmt|;
name|signo
operator|=
name|SIGKILL
expr_stmt|;
ifdef|#
directive|ifdef
name|PROCFS_NEED_CLEAR_CURSIG_FOR_KILL
comment|/* Alpha OSF/1-3.x procfs needs a clear of the current signal      before the PIOCKILL, otherwise it might generate a corrupted core      file for the inferior.  */
name|ioctl
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|PIOCSSIG
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PROCFS_NEED_PIOCSSIG_FOR_KILL
comment|/* Alpha OSF/1-2.x procfs needs a PIOCSSIG call with a SIGKILL signal      to kill the inferior, otherwise it might remain stopped with a      pending SIGKILL.      We do not check the result of the PIOCSSIG, the inferior might have      died already.  */
block|{
name|struct
name|siginfo
name|newsiginfo
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|newsiginfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|newsiginfo
argument_list|)
argument_list|)
expr_stmt|;
name|newsiginfo
operator|.
name|si_signo
operator|=
name|signo
expr_stmt|;
name|newsiginfo
operator|.
name|si_code
operator|=
literal|0
expr_stmt|;
name|newsiginfo
operator|.
name|si_errno
operator|=
literal|0
expr_stmt|;
name|newsiginfo
operator|.
name|si_pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|newsiginfo
operator|.
name|si_uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
name|ioctl
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|PIOCSSIG
argument_list|,
operator|&
name|newsiginfo
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|ioctl
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|PIOCKILL
argument_list|,
operator|&
name|signo
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|close_proc_file
argument_list|(
name|pi
argument_list|)
expr_stmt|;
comment|/* Only wait() for our direct children.  Our grandchildren zombies are killed    by the death of their parents.  */
if|if
condition|(
name|ppid
operator|==
name|getpid
argument_list|()
condition|)
name|wait
argument_list|(
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	procfs_xfer_memory -- copy data to or from inferior memory space  SYNOPSIS  	int procfs_xfer_memory (CORE_ADDR memaddr, char *myaddr, int len, 		int dowrite, struct target_ops target)  DESCRIPTION  	Copy LEN bytes to/from inferior's memory starting at MEMADDR 	from/to debugger memory starting at MYADDR.  Copy from inferior 	if DOWRITE is zero or to inferior if DOWRITE is nonzero.    	Returns the length copied, which is either the LEN argument or 	zero.  This xfer function does not do partial moves, since procfs_ops 	doesn't allow memory operations to cross below us in the target stack 	anyway.  NOTES  	The /proc interface makes this an almost trivial task.  */
end_comment

begin_function
specifier|static
name|int
name|procfs_xfer_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|dowrite
parameter_list|,
name|target
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|dowrite
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
comment|/* ignored */
block|{
name|int
name|nbytes
init|=
literal|0
decl_stmt|;
name|struct
name|procinfo
modifier|*
name|pi
decl_stmt|;
name|pi
operator|=
name|current_procinfo
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
operator|(
name|off_t
operator|)
name|memaddr
argument_list|,
literal|0
argument_list|)
operator|==
operator|(
name|off_t
operator|)
name|memaddr
condition|)
block|{
if|if
condition|(
name|dowrite
condition|)
block|{
name|nbytes
operator|=
name|write
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nbytes
operator|=
name|read
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nbytes
operator|<
literal|0
condition|)
block|{
name|nbytes
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
operator|(
name|nbytes
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	procfs_store_registers -- copy register values back to inferior  SYNOPSIS  	void procfs_store_registers (int regno)  DESCRIPTION  	Store our current register values back into the inferior.  If 	REGNO is -1 then store all the register, otherwise store just 	the value specified by REGNO.  NOTES  	If we are storing only a single register, we first have to get all 	the current values from the process, overwrite the desired register 	in the gregset with the one we want from gdb's registers, and then 	send the whole set back to the process.  For writing all the 	registers, all we have to do is generate the gregset and send it to 	the process.  	Also note that the process has to be stopped on an event of interest 	for this to work, which basically means that it has to have been 	run under the control of one of the other /proc ioctl calls and not 	ptrace.  Since we don't use ptrace anyway, we don't worry about this 	fine point, but it is worth noting for future reference.  	Gdb is confused about what this function is supposed to return. 	Some versions return a value, others return nothing.  Some are 	declared to return a value and actually return nothing.  Gdb ignores 	anything returned.  (FIXME)   */
end_comment

begin_function
specifier|static
name|void
name|procfs_store_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|struct
name|procinfo
modifier|*
name|pi
decl_stmt|;
name|pi
operator|=
name|current_procinfo
expr_stmt|;
if|if
condition|(
name|regno
operator|!=
operator|-
literal|1
condition|)
block|{
name|ioctl
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|PIOCGREG
argument_list|,
operator|&
name|pi
operator|->
name|gregset
argument_list|)
expr_stmt|;
block|}
name|fill_gregset
argument_list|(
operator|&
name|pi
operator|->
name|gregset
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|PIOCSREG
argument_list|,
operator|&
name|pi
operator|->
name|gregset
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|FP0_REGNUM
argument_list|)
comment|/* Now repeat everything using the floating point register set, if the      target has floating point hardware. Since we ignore the returned value,      we'll never know whether it worked or not anyway. */
if|if
condition|(
name|regno
operator|!=
operator|-
literal|1
condition|)
block|{
name|ioctl
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|PIOCGFPREG
argument_list|,
operator|&
name|pi
operator|->
name|fpregset
argument_list|)
expr_stmt|;
block|}
name|fill_fpregset
argument_list|(
operator|&
name|pi
operator|->
name|fpregset
argument_list|,
name|regno
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|PIOCSFPREG
argument_list|,
operator|&
name|pi
operator|->
name|fpregset
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FP0_REGNUM */
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	create_procinfo - initialize access to a /proc entry  SYNOPSIS  	struct procinfo * create_procinfo (int pid)  DESCRIPTION  	Allocate a procinfo structure, open the /proc file and then set up the 	set of signals and faults that are to be traced.  Returns a pointer to 	the new procinfo structure.  NOTES  	If proc_init_failed ever gets called, control returns to the command 	processing loop via the standard error handling code.   */
end_comment

begin_function
specifier|static
name|struct
name|procinfo
modifier|*
name|create_procinfo
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|struct
name|procinfo
modifier|*
name|pi
decl_stmt|;
name|pi
operator|=
name|find_procinfo
argument_list|(
name|pid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|!=
name|NULL
condition|)
return|return
name|pi
return|;
comment|/* All done!  It already exists */
name|pi
operator|=
operator|(
expr|struct
name|procinfo
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|procinfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|open_proc_file
argument_list|(
name|pid
argument_list|,
name|pi
argument_list|,
name|O_RDWR
argument_list|)
condition|)
name|proc_init_failed
argument_list|(
name|pi
argument_list|,
literal|"can't open process file"
argument_list|)
expr_stmt|;
comment|/* Add new process to process info list */
name|pi
operator|->
name|next
operator|=
name|procinfo_list
expr_stmt|;
name|procinfo_list
operator|=
name|pi
expr_stmt|;
name|add_fd
argument_list|(
name|pi
argument_list|)
expr_stmt|;
comment|/* Add to list for poll/select */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|pi
operator|->
name|prrun
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pi
operator|->
name|prrun
argument_list|)
argument_list|)
expr_stmt|;
name|prfillset
argument_list|(
operator|&
name|pi
operator|->
name|prrun
operator|.
name|pr_trace
argument_list|)
expr_stmt|;
name|procfs_notice_signals
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|prfillset
argument_list|(
operator|&
name|pi
operator|->
name|prrun
operator|.
name|pr_fault
argument_list|)
expr_stmt|;
name|prdelset
argument_list|(
operator|&
name|pi
operator|->
name|prrun
operator|.
name|pr_fault
argument_list|,
name|FLTPAGE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROCFS_DONT_TRACE_FAULTS
name|premptyset
argument_list|(
operator|&
name|pi
operator|->
name|prrun
operator|.
name|pr_fault
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|PIOCWSTOP
argument_list|,
operator|&
name|pi
operator|->
name|prstatus
argument_list|)
operator|<
literal|0
condition|)
name|proc_init_failed
argument_list|(
name|pi
argument_list|,
literal|"PIOCWSTOP failed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|PIOCSFAULT
argument_list|,
operator|&
name|pi
operator|->
name|prrun
operator|.
name|pr_fault
argument_list|)
operator|<
literal|0
condition|)
name|proc_init_failed
argument_list|(
name|pi
argument_list|,
literal|"PIOCSFAULT failed"
argument_list|)
expr_stmt|;
return|return
name|pi
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	procfs_init_inferior - initialize target vector and access to a 	/proc entry  SYNOPSIS  	void procfs_init_inferior (int pid)  DESCRIPTION  	When gdb starts an inferior, this function is called in the parent 	process immediately after the fork.  It waits for the child to stop 	on the return from the exec system call (the child itself takes care 	of ensuring that this is set up), then sets up the set of signals 	and faults that are to be traced.  NOTES  	If proc_init_failed ever gets called, control returns to the command 	processing loop via the standard error handling code.   */
end_comment

begin_function
specifier|static
name|void
name|procfs_init_inferior
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|push_target
argument_list|(
operator|&
name|procfs_ops
argument_list|)
expr_stmt|;
name|create_procinfo
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|add_thread
argument_list|(
name|pid
argument_list|)
expr_stmt|;
comment|/* Setup initial thread */
ifdef|#
directive|ifdef
name|START_INFERIOR_TRAPS_EXPECTED
name|startup_inferior
argument_list|(
name|START_INFERIOR_TRAPS_EXPECTED
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* One trap to exec the shell, one to exec the program being debugged.  */
name|startup_inferior
argument_list|(
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  GLOBAL FUNCTION  	procfs_notice_signals  SYNOPSIS  	static void procfs_notice_signals (int pid);  DESCRIPTION  	When the user changes the state of gdb's signal handling via the 	"handle" command, this function gets called to see if any change 	in the /proc interface is required.  It is also called internally 	by other /proc interface functions to initialize the state of 	the traced signal set.  	One thing it does is that signals for which the state is "nostop", 	"noprint", and "pass", have their trace bits reset in the pr_trace 	field, so that they are no longer traced.  This allows them to be 	delivered directly to the inferior without the debugger ever being 	involved.  */
end_comment

begin_function
specifier|static
name|void
name|procfs_notice_signals
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|int
name|signo
decl_stmt|;
name|struct
name|procinfo
modifier|*
name|pi
decl_stmt|;
name|pi
operator|=
name|find_procinfo
argument_list|(
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|signo
operator|=
literal|0
init|;
name|signo
operator|<
name|NSIG
condition|;
name|signo
operator|++
control|)
block|{
if|if
condition|(
name|signal_stop_state
argument_list|(
name|target_signal_from_host
argument_list|(
name|signo
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|signal_print_state
argument_list|(
name|target_signal_from_host
argument_list|(
name|signo
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|signal_pass_state
argument_list|(
name|target_signal_from_host
argument_list|(
name|signo
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
block|{
name|prdelset
argument_list|(
operator|&
name|pi
operator|->
name|prrun
operator|.
name|pr_trace
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|praddset
argument_list|(
operator|&
name|pi
operator|->
name|prrun
operator|.
name|pr_trace
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|PIOCSTRACE
argument_list|,
operator|&
name|pi
operator|->
name|prrun
operator|.
name|pr_trace
argument_list|)
condition|)
block|{
name|print_sys_errmsg
argument_list|(
literal|"PIOCSTRACE failed"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	proc_set_exec_trap -- arrange for exec'd child to halt at startup  SYNOPSIS  	void proc_set_exec_trap (void)  DESCRIPTION  	This function is called in the child process when starting up 	an inferior, prior to doing the exec of the actual inferior. 	It sets the child process's exitset to make exit from the exec 	system call an event of interest to stop on, and then simply 	returns.  The child does the exec, the system call returns, and 	the child stops at the first instruction, ready for the gdb 	parent process to take control of it.  NOTE  	We need to use all local variables since the child may be sharing 	it's data space with the parent, if vfork was used rather than 	fork.  	Also note that we want to turn off the inherit-on-fork flag in 	the child process so that any grand-children start with all 	tracing flags cleared.  */
end_comment

begin_function
specifier|static
name|void
name|proc_set_exec_trap
parameter_list|()
block|{
name|sysset_t
name|exitset
decl_stmt|;
name|sysset_t
name|entryset
decl_stmt|;
specifier|auto
name|char
name|procname
index|[
literal|32
index|]
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|sprintf
argument_list|(
name|procname
argument_list|,
name|PROC_NAME_FMT
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|procname
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|procname
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|127
argument_list|)
expr_stmt|;
block|}
name|premptyset
argument_list|(
operator|&
name|exitset
argument_list|)
expr_stmt|;
name|premptyset
argument_list|(
operator|&
name|entryset
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PIOCSSPCACT
comment|/* Under Alpha OSF/1 we have to use a PIOCSSPCACT ioctl to trace      exits from exec system calls because of the user level loader.  */
block|{
name|int
name|prfs_flags
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|PIOCGSPCACT
argument_list|,
operator|&
name|prfs_flags
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|procname
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|127
argument_list|)
expr_stmt|;
block|}
name|prfs_flags
operator||=
name|PRFS_STOPEXEC
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|PIOCSSPCACT
argument_list|,
operator|&
name|prfs_flags
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|procname
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|127
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* GW: Rationale...      Not all systems with /proc have all the exec* syscalls with the same      names.  On the SGI, for example, there is no SYS_exec, but there      *is* a SYS_execv.  So, we try to account for that. */
ifdef|#
directive|ifdef
name|SYS_exec
name|praddset
argument_list|(
operator|&
name|exitset
argument_list|,
name|SYS_exec
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYS_execve
name|praddset
argument_list|(
operator|&
name|exitset
argument_list|,
name|SYS_execve
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYS_execv
name|praddset
argument_list|(
operator|&
name|exitset
argument_list|,
name|SYS_execv
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|PIOCSEXIT
argument_list|,
operator|&
name|exitset
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|procname
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|127
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|praddset
argument_list|(
operator|&
name|entryset
argument_list|,
name|SYS_exit
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|PIOCSENTRY
argument_list|,
operator|&
name|entryset
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|procname
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|126
argument_list|)
expr_stmt|;
block|}
comment|/* Turn off inherit-on-fork flag so that all grand-children of gdb      start with tracing flags cleared. */
if|#
directive|if
name|defined
argument_list|(
name|PIOCRESET
argument_list|)
comment|/* New method */
block|{
name|long
name|pr_flags
decl_stmt|;
name|pr_flags
operator|=
name|PR_FORK
expr_stmt|;
name|ioctl
argument_list|(
name|fd
argument_list|,
name|PIOCRESET
argument_list|,
operator|&
name|pr_flags
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|PIOCRFORK
argument_list|)
comment|/* Original method */
name|ioctl
argument_list|(
name|fd
argument_list|,
name|PIOCRFORK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* Turn on run-on-last-close flag so that this process will not hang      if GDB goes away for some reason.  */
if|#
directive|if
name|defined
argument_list|(
name|PIOCSET
argument_list|)
comment|/* New method */
block|{
name|long
name|pr_flags
decl_stmt|;
name|pr_flags
operator|=
name|PR_RLC
expr_stmt|;
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fd
argument_list|,
name|PIOCSET
argument_list|,
operator|&
name|pr_flags
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|PIOCSRLC
argument_list|)
comment|/* Original method */
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fd
argument_list|,
name|PIOCSRLC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  GLOBAL FUNCTION  	proc_iterate_over_mappings -- call function for every mapped space  SYNOPSIS  	int proc_iterate_over_mappings (int (*func)())  DESCRIPTION  	Given a pointer to a function, call that function for every 	mapped address space, passing it an open file descriptor for 	the file corresponding to that mapped address space (if any) 	and the base address of the mapped space.  Quit when we hit 	the end of the mappings or the function returns nonzero.  */
end_comment

begin_function_decl
name|int
name|proc_iterate_over_mappings
parameter_list|(
name|func
parameter_list|)
function_decl|int
parameter_list|(
function_decl|*func
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|CORE_ADDR
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|nmap
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|funcstat
init|=
literal|0
decl_stmt|;
name|struct
name|prmap
modifier|*
name|prmaps
decl_stmt|;
name|struct
name|prmap
modifier|*
name|prmap
decl_stmt|;
name|struct
name|procinfo
modifier|*
name|pi
decl_stmt|;
name|pi
operator|=
name|current_procinfo
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|PIOCNMAP
argument_list|,
operator|&
name|nmap
argument_list|)
operator|==
literal|0
condition|)
block|{
name|prmaps
operator|=
operator|(
expr|struct
name|prmap
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|nmap
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|prmaps
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|PIOCMAP
argument_list|,
name|prmaps
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|prmap
operator|=
name|prmaps
init|;
name|prmap
operator|->
name|pr_size
operator|&&
name|funcstat
operator|==
literal|0
condition|;
operator|++
name|prmap
control|)
block|{
name|fd
operator|=
name|proc_address_to_fd
argument_list|(
name|pi
argument_list|,
operator|(
name|CORE_ADDR
operator|)
name|prmap
operator|->
name|pr_vaddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|funcstat
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|fd
argument_list|,
operator|(
name|CORE_ADDR
operator|)
name|prmap
operator|->
name|pr_vaddr
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|funcstat
operator|)
return|;
block|}
end_block

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Currently unused */
end_comment

begin_comment
comment|/*  GLOBAL FUNCTION  	proc_base_address -- find base address for segment containing address  SYNOPSIS  	CORE_ADDR proc_base_address (CORE_ADDR addr)  DESCRIPTION  	Given an address of a location in the inferior, find and return 	the base address of the mapped segment containing that address.  	This is used for example, by the shared library support code, 	where we have the pc value for some location in the shared library 	where we are stopped, and need to know the base address of the 	segment containing that address. */
end_comment

begin_endif
unit|CORE_ADDR proc_base_address (addr)      CORE_ADDR addr; {   int nmap;   struct prmap *prmaps;   struct prmap *prmap;   CORE_ADDR baseaddr = 0;   struct procinfo *pi;    pi = current_procinfo;    if (ioctl (pi->fd, PIOCNMAP,&nmap) == 0)     {       prmaps = (struct prmap *) alloca ((nmap + 1) * sizeof (*prmaps));       if (ioctl (pi->fd, PIOCMAP, prmaps) == 0) 	{ 	  for (prmap = prmaps; prmap -> pr_size; ++prmap) 	    { 	      if ((prmap -> pr_vaddr<= (caddr_t) addr)&& 		  (prmap -> pr_vaddr + prmap -> pr_size> (caddr_t) addr)) 		{ 		  baseaddr = (CORE_ADDR) prmap -> pr_vaddr; 		  break; 		} 	    } 	}     }   return (baseaddr); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/*  LOCAL FUNCTION  	proc_address_to_fd -- return open fd for file mapped to address  SYNOPSIS  	int proc_address_to_fd (struct procinfo *pi, CORE_ADDR addr, complain)  DESCRIPTION  	Given an address in the current inferior's address space, use the 	/proc interface to find an open file descriptor for the file that 	this address was mapped in from.  Return -1 if there is no current 	inferior.  Print a warning message if there is an inferior but 	the address corresponds to no file (IE a bogus address).  */
end_comment

begin_function
specifier|static
name|int
name|proc_address_to_fd
parameter_list|(
name|pi
parameter_list|,
name|addr
parameter_list|,
name|complain
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pi
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|int
name|complain
decl_stmt|;
block|{
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|ioctl
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|PIOCOPENM
argument_list|,
operator|(
name|caddr_t
operator|*
operator|)
operator|&
name|addr
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|complain
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"can't find mapped file for address 0x%x"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|fd
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Attach to process PID, then initialize for debugging it    and wait for the trace-trap that results from attaching.  */
end_comment

begin_function
specifier|static
name|void
name|procfs_attach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
name|exec_file
decl_stmt|;
name|int
name|pid
decl_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
name|error_no_arg
argument_list|(
literal|"process-id to attach"
argument_list|)
expr_stmt|;
name|pid
operator|=
name|atoi
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
name|getpid
argument_list|()
condition|)
comment|/* Trying to masturbate? */
name|error
argument_list|(
literal|"I refuse to debug myself!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|exec_file
operator|=
operator|(
name|char
operator|*
operator|)
name|get_exec_file
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|exec_file
condition|)
name|printf_unfiltered
argument_list|(
literal|"Attaching to program `%s', %s\n"
argument_list|,
name|exec_file
argument_list|,
name|target_pid_to_str
argument_list|(
name|pid
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf_unfiltered
argument_list|(
literal|"Attaching to %s\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|pid
argument_list|)
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|do_attach
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
name|pid
expr_stmt|;
name|push_target
argument_list|(
operator|&
name|procfs_ops
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Take a program previously attached to and detaches it.    The program resumes execution and will no longer stop    on signals, etc.  We'd better not have left any breakpoints    in the program or it'll die when it hits one.  For this    to work, it may be necessary for the process to have been    previously attached.  It *might* work if the program was    started via the normal ptrace (PTRACE_TRACEME).  */
end_comment

begin_function
specifier|static
name|void
name|procfs_detach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|siggnal
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|char
modifier|*
name|exec_file
init|=
name|get_exec_file
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|exec_file
operator|==
literal|0
condition|)
name|exec_file
operator|=
literal|""
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"Detaching from program: %s %s\n"
argument_list|,
name|exec_file
argument_list|,
name|target_pid_to_str
argument_list|(
name|inferior_pid
argument_list|)
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|args
condition|)
name|siggnal
operator|=
name|atoi
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|do_detach
argument_list|(
name|siggnal
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
literal|0
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|procfs_ops
argument_list|)
expr_stmt|;
comment|/* Pop out of handling an inferior */
block|}
end_function

begin_comment
comment|/* Get ready to modify the registers array.  On machines which store    individual registers, this doesn't need to do anything.  On machines    which store all the registers in one fell swoop, this makes sure    that registers contains all the registers from the program being    debugged.  */
end_comment

begin_function
specifier|static
name|void
name|procfs_prepare_to_store
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|CHILD_PREPARE_TO_STORE
name|CHILD_PREPARE_TO_STORE
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Print status information about what we're accessing.  */
end_comment

begin_function
specifier|static
name|void
name|procfs_files_info
parameter_list|(
name|ignore
parameter_list|)
name|struct
name|target_ops
modifier|*
name|ignore
decl_stmt|;
block|{
name|printf_unfiltered
argument_list|(
literal|"\tUsing the running image of %s %s via /proc.\n"
argument_list|,
name|attach_flag
condition|?
literal|"attached"
else|:
literal|"child"
argument_list|,
name|target_pid_to_str
argument_list|(
name|inferior_pid
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|procfs_open
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|error
argument_list|(
literal|"Use the \"run\" command to start a Unix child process."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	do_attach -- attach to an already existing process  SYNOPSIS  	int do_attach (int pid)  DESCRIPTION  	Attach to an already existing process with the specified process 	id.  If the process is not already stopped, query whether to 	stop it or not.  NOTES  	The option of stopping at attach time is specific to the /proc 	versions of gdb.  Versions using ptrace force the attachee 	to stop.  (I have changed this version to do so, too.  All you 	have to do is "continue" to make it go on. -- gnu@cygnus.com)  */
end_comment

begin_function
specifier|static
name|int
name|do_attach
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
name|struct
name|procinfo
modifier|*
name|pi
decl_stmt|;
name|pi
operator|=
operator|(
expr|struct
name|procinfo
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|procinfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|open_proc_file
argument_list|(
name|pid
argument_list|,
name|pi
argument_list|,
name|O_RDWR
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|pi
operator|->
name|pathname
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
comment|/* Add new process to process info list */
name|pi
operator|->
name|next
operator|=
name|procinfo_list
expr_stmt|;
name|procinfo_list
operator|=
name|pi
expr_stmt|;
name|add_fd
argument_list|(
name|pi
argument_list|)
expr_stmt|;
comment|/* Add to list for poll/select */
comment|/*  Get current status of process and if it is not already stopped,       then stop it.  Remember whether or not it was stopped when we first       examined it. */
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|PIOCSTATUS
argument_list|,
operator|&
name|pi
operator|->
name|prstatus
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|close_proc_file
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"PIOCSTATUS failed"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pi
operator|->
name|prstatus
operator|.
name|pr_flags
operator|&
operator|(
name|PR_STOPPED
operator||
name|PR_ISTOP
operator|)
condition|)
block|{
name|pi
operator|->
name|was_stopped
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|pi
operator|->
name|was_stopped
operator|=
literal|0
expr_stmt|;
if|if
condition|(
literal|1
operator|||
name|query
argument_list|(
literal|"Process is currently running, stop it? "
argument_list|)
condition|)
block|{
comment|/* Make it run again when we close it.  */
if|#
directive|if
name|defined
argument_list|(
name|PIOCSET
argument_list|)
comment|/* New method */
block|{
name|long
name|pr_flags
decl_stmt|;
name|pr_flags
operator|=
name|PR_RLC
expr_stmt|;
name|result
operator|=
name|ioctl
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|PIOCSET
argument_list|,
operator|&
name|pr_flags
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|PIOCSRLC
argument_list|)
comment|/* Original method */
name|result
operator|=
name|ioctl
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|PIOCSRLC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|close_proc_file
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"PIOCSRLC or PIOCSET failed"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|PIOCSTOP
argument_list|,
operator|&
name|pi
operator|->
name|prstatus
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|close_proc_file
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"PIOCSTOP failed"
argument_list|)
expr_stmt|;
block|}
name|pi
operator|->
name|nopass_next_sigstop
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|printf_unfiltered
argument_list|(
literal|"Ok, gdb will wait for %s to stop.\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|pid
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  Remember some things about the inferior that we will, or might, change       so that we can restore them when we detach. */
name|ioctl
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|PIOCGTRACE
argument_list|,
operator|&
name|pi
operator|->
name|saved_trace
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|PIOCGHOLD
argument_list|,
operator|&
name|pi
operator|->
name|saved_sighold
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|PIOCGFAULT
argument_list|,
operator|&
name|pi
operator|->
name|saved_fltset
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|PIOCGENTRY
argument_list|,
operator|&
name|pi
operator|->
name|saved_entryset
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|PIOCGEXIT
argument_list|,
operator|&
name|pi
operator|->
name|saved_exitset
argument_list|)
expr_stmt|;
comment|/* Set up trace and fault sets, as gdb expects them. */
name|memset
argument_list|(
operator|&
name|pi
operator|->
name|prrun
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pi
operator|->
name|prrun
argument_list|)
argument_list|)
expr_stmt|;
name|prfillset
argument_list|(
operator|&
name|pi
operator|->
name|prrun
operator|.
name|pr_trace
argument_list|)
expr_stmt|;
name|procfs_notice_signals
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|prfillset
argument_list|(
operator|&
name|pi
operator|->
name|prrun
operator|.
name|pr_fault
argument_list|)
expr_stmt|;
name|prdelset
argument_list|(
operator|&
name|pi
operator|->
name|prrun
operator|.
name|pr_fault
argument_list|,
name|FLTPAGE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROCFS_DONT_TRACE_FAULTS
name|premptyset
argument_list|(
operator|&
name|pi
operator|->
name|prrun
operator|.
name|pr_fault
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|PIOCSFAULT
argument_list|,
operator|&
name|pi
operator|->
name|prrun
operator|.
name|pr_fault
argument_list|)
condition|)
block|{
name|print_sys_errmsg
argument_list|(
literal|"PIOCSFAULT failed"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|PIOCSTRACE
argument_list|,
operator|&
name|pi
operator|->
name|prrun
operator|.
name|pr_trace
argument_list|)
condition|)
block|{
name|print_sys_errmsg
argument_list|(
literal|"PIOCSTRACE failed"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
name|attach_flag
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|pid
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	do_detach -- detach from an attached-to process  SYNOPSIS  	void do_detach (int signal)  DESCRIPTION  	Detach from the current attachee.  	If signal is non-zero, the attachee is started running again and sent 	the specified signal.  	If signal is zero and the attachee was not already stopped when we 	attached to it, then we make it runnable again when we detach.  	Otherwise, we query whether or not to make the attachee runnable 	again, since we may simply want to leave it in the state it was in 	when we attached.  	We report any problems, but do not consider them errors, since we 	MUST detach even if some things don't seem to go right.  This may not 	be the ideal situation.  (FIXME).  */
end_comment

begin_function
specifier|static
name|void
name|do_detach
parameter_list|(
name|signal
parameter_list|)
name|int
name|signal
decl_stmt|;
block|{
name|int
name|result
decl_stmt|;
name|struct
name|procinfo
modifier|*
name|pi
decl_stmt|;
name|pi
operator|=
name|current_procinfo
expr_stmt|;
if|if
condition|(
name|signal
condition|)
block|{
name|set_proc_siginfo
argument_list|(
name|pi
argument_list|,
name|signal
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|PIOCSEXIT
argument_list|,
operator|&
name|pi
operator|->
name|saved_exitset
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"PIOCSEXIT failed.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|PIOCSENTRY
argument_list|,
operator|&
name|pi
operator|->
name|saved_entryset
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"PIOCSENTRY failed.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|PIOCSTRACE
argument_list|,
operator|&
name|pi
operator|->
name|saved_trace
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"PIOCSTRACE failed.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|PIOCSHOLD
argument_list|,
operator|&
name|pi
operator|->
name|saved_sighold
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"PIOSCHOLD failed.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|PIOCSFAULT
argument_list|,
operator|&
name|pi
operator|->
name|saved_fltset
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"PIOCSFAULT failed.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|PIOCSTATUS
argument_list|,
operator|&
name|pi
operator|->
name|prstatus
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"PIOCSTATUS failed.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|signal
operator|||
operator|(
name|pi
operator|->
name|prstatus
operator|.
name|pr_flags
operator|&
operator|(
name|PR_STOPPED
operator||
name|PR_ISTOP
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|signal
operator|||
operator|!
name|pi
operator|->
name|was_stopped
operator|||
name|query
argument_list|(
literal|"Was stopped when attached, make it runnable again? "
argument_list|)
condition|)
block|{
comment|/* Clear any pending signal if we want to detach without 		 a signal.  */
if|if
condition|(
name|signal
operator|==
literal|0
condition|)
name|set_proc_siginfo
argument_list|(
name|pi
argument_list|,
name|signal
argument_list|)
expr_stmt|;
comment|/* Clear any fault that might have stopped it.  */
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|PIOCCFAULT
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"PIOCCFAULT failed.\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Make it run again when we close it.  */
if|#
directive|if
name|defined
argument_list|(
name|PIOCSET
argument_list|)
comment|/* New method */
block|{
name|long
name|pr_flags
decl_stmt|;
name|pr_flags
operator|=
name|PR_RLC
expr_stmt|;
name|result
operator|=
name|ioctl
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|PIOCSET
argument_list|,
operator|&
name|pr_flags
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|PIOCSRLC
argument_list|)
comment|/* Original method */
name|result
operator|=
name|ioctl
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|PIOCSRLC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|result
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"PIOCSRLC or PIOCSET failed.\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|close_proc_file
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|attach_flag
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  emulate wait() as much as possible.     Wait for child to do something.  Return pid of child, or -1 in case     of error; store status in *OURSTATUS.      Not sure why we can't     just use wait(), but it seems to have problems when applied to a     process being controlled with the /proc interface.      We have a race problem here with no obvious solution.  We need to let     the inferior run until it stops on an event of interest, which means     that we need to use the PIOCWSTOP ioctl.  However, we cannot use this     ioctl if the process is already stopped on something that is not an     event of interest, or the call will hang indefinitely.  Thus we first     use PIOCSTATUS to see if the process is not stopped.  If not, then we     use PIOCWSTOP.  But during the window between the two, if the process     stops for any reason that is not an event of interest (such as a job     control signal) then gdb will hang.  One possible workaround is to set     an alarm to wake up every minute of so and check to see if the process     is still running, and if so, then reissue the PIOCWSTOP.  But this is     a real kludge, so has not been implemented.  FIXME: investigate     alternatives.      FIXME:  Investigate why wait() seems to have problems with programs     being control by /proc routines.  */
end_comment

begin_function
specifier|static
name|int
name|procfs_wait
parameter_list|(
name|pid
parameter_list|,
name|ourstatus
parameter_list|)
name|int
name|pid
decl_stmt|;
name|struct
name|target_waitstatus
modifier|*
name|ourstatus
decl_stmt|;
block|{
name|short
name|what
decl_stmt|;
name|short
name|why
decl_stmt|;
name|int
name|statval
init|=
literal|0
decl_stmt|;
name|int
name|checkerr
init|=
literal|0
decl_stmt|;
name|int
name|rtnval
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|procinfo
modifier|*
name|pi
decl_stmt|;
if|if
condition|(
name|pid
operator|!=
operator|-
literal|1
condition|)
comment|/* Non-specific process? */
name|pi
operator|=
name|NULL
expr_stmt|;
else|else
for|for
control|(
name|pi
operator|=
name|procinfo_list
init|;
name|pi
condition|;
name|pi
operator|=
name|pi
operator|->
name|next
control|)
if|if
condition|(
name|pi
operator|->
name|had_event
condition|)
break|break;
if|if
condition|(
operator|!
name|pi
condition|)
block|{
name|wait_again
label|:
name|pi
operator|=
name|wait_fd
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|!=
operator|-
literal|1
condition|)
for|for
control|(
name|pi
operator|=
name|procinfo_list
init|;
name|pi
condition|;
name|pi
operator|=
name|pi
operator|->
name|next
control|)
if|if
condition|(
name|pi
operator|->
name|pid
operator|==
name|pid
operator|&&
name|pi
operator|->
name|had_event
condition|)
break|break;
if|if
condition|(
operator|!
name|pi
operator|&&
operator|!
name|checkerr
condition|)
goto|goto
name|wait_again
goto|;
if|if
condition|(
operator|!
name|checkerr
operator|&&
operator|!
operator|(
name|pi
operator|->
name|prstatus
operator|.
name|pr_flags
operator|&
operator|(
name|PR_STOPPED
operator||
name|PR_ISTOP
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|PIOCWSTOP
argument_list|,
operator|&
name|pi
operator|->
name|prstatus
argument_list|)
operator|<
literal|0
condition|)
block|{
name|checkerr
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|checkerr
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
name|rtnval
operator|=
name|wait
argument_list|(
operator|&
name|statval
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtnval
operator|!=
name|inferior_pid
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"PIOCWSTOP, wait failed, returned %d"
argument_list|,
name|rtnval
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
else|else
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"PIOCSTATUS or PIOCWSTOP failed."
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
elseif|else
if|if
condition|(
name|pi
operator|->
name|prstatus
operator|.
name|pr_flags
operator|&
operator|(
name|PR_STOPPED
operator||
name|PR_ISTOP
operator|)
condition|)
block|{
name|rtnval
operator|=
name|pi
operator|->
name|prstatus
operator|.
name|pr_pid
expr_stmt|;
name|why
operator|=
name|pi
operator|->
name|prstatus
operator|.
name|pr_why
expr_stmt|;
name|what
operator|=
name|pi
operator|->
name|prstatus
operator|.
name|pr_what
expr_stmt|;
switch|switch
condition|(
name|why
condition|)
block|{
case|case
name|PR_SIGNALLED
case|:
name|statval
operator|=
operator|(
name|what
operator|<<
literal|8
operator|)
operator||
literal|0177
expr_stmt|;
break|break;
case|case
name|PR_SYSENTRY
case|:
if|if
condition|(
name|what
operator|!=
name|SYS_exit
condition|)
name|error
argument_list|(
literal|"PR_SYSENTRY, unknown system call %d"
argument_list|,
name|what
argument_list|)
expr_stmt|;
name|pi
operator|->
name|prrun
operator|.
name|pr_flags
operator|=
name|PRCFAULT
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|PIOCRUN
argument_list|,
operator|&
name|pi
operator|->
name|prrun
argument_list|)
operator|!=
literal|0
condition|)
name|perror_with_name
argument_list|(
name|pi
operator|->
name|pathname
argument_list|)
expr_stmt|;
name|rtnval
operator|=
name|wait
argument_list|(
operator|&
name|statval
argument_list|)
expr_stmt|;
break|break;
case|case
name|PR_SYSEXIT
case|:
switch|switch
condition|(
name|what
condition|)
block|{
ifdef|#
directive|ifdef
name|SYS_exec
case|case
name|SYS_exec
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYS_execve
case|case
name|SYS_execve
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYS_execv
case|case
name|SYS_execv
case|:
endif|#
directive|endif
name|statval
operator|=
operator|(
name|SIGTRAP
operator|<<
literal|8
operator|)
operator||
literal|0177
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|SYS_sproc
case|case
name|SYS_sproc
case|:
comment|/* We've just detected the completion of an sproc system call.  Now we need to    setup a procinfo struct for this thread, and notify the thread system of the    new arrival.  */
comment|/* If sproc failed, then nothing interesting happened.  Continue the process and    go back to sleep. */
if|if
condition|(
name|pi
operator|->
name|prstatus
operator|.
name|pr_errno
operator|!=
literal|0
condition|)
block|{
name|pi
operator|->
name|prrun
operator|.
name|pr_flags
operator|&=
name|PRSTEP
expr_stmt|;
name|pi
operator|->
name|prrun
operator|.
name|pr_flags
operator||=
name|PRCFAULT
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|PIOCRUN
argument_list|,
operator|&
name|pi
operator|->
name|prrun
argument_list|)
operator|!=
literal|0
condition|)
name|perror_with_name
argument_list|(
name|pi
operator|->
name|pathname
argument_list|)
expr_stmt|;
goto|goto
name|wait_again
goto|;
block|}
comment|/* At this point, the new thread is stopped at it's first instruction, and    the parent is stopped at the exit from sproc.  */
comment|/* Notify the caller of the arrival of a new thread. */
name|create_procinfo
argument_list|(
name|pi
operator|->
name|prstatus
operator|.
name|pr_rval1
argument_list|)
expr_stmt|;
name|rtnval
operator|=
name|pi
operator|->
name|prstatus
operator|.
name|pr_rval1
expr_stmt|;
name|statval
operator|=
operator|(
name|SIGTRAP
operator|<<
literal|8
operator|)
operator||
literal|0177
expr_stmt|;
break|break;
case|case
name|SYS_fork
case|:
ifdef|#
directive|ifdef
name|SYS_vfork
case|case
name|SYS_vfork
case|:
endif|#
directive|endif
comment|/* At this point, we've detected the completion of a fork (or vfork) call in    our child.  The grandchild is also stopped because we set inherit-on-fork    earlier.  (Note that nobody has the grandchilds' /proc file open at this    point.)  We will release the grandchild from the debugger by opening it's    /proc file and then closing it.  Since run-on-last-close is set, the    grandchild continues on its' merry way.  */
block|{
name|struct
name|procinfo
modifier|*
name|pitemp
decl_stmt|;
name|pitemp
operator|=
name|create_procinfo
argument_list|(
name|pi
operator|->
name|prstatus
operator|.
name|pr_rval1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pitemp
condition|)
name|close_proc_file
argument_list|(
name|pitemp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|PIOCRUN
argument_list|,
operator|&
name|pi
operator|->
name|prrun
argument_list|)
operator|!=
literal|0
condition|)
name|perror_with_name
argument_list|(
name|pi
operator|->
name|pathname
argument_list|)
expr_stmt|;
block|}
goto|goto
name|wait_again
goto|;
endif|#
directive|endif
comment|/* SYS_sproc */
default|default:
name|error
argument_list|(
literal|"PIOCSTATUS (PR_SYSEXIT):  Unknown system call %d"
argument_list|,
name|what
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PR_REQUESTED
case|:
name|statval
operator|=
operator|(
name|SIGSTOP
operator|<<
literal|8
operator|)
operator||
literal|0177
expr_stmt|;
break|break;
case|case
name|PR_JOBCONTROL
case|:
name|statval
operator|=
operator|(
name|what
operator|<<
literal|8
operator|)
operator||
literal|0177
expr_stmt|;
break|break;
case|case
name|PR_FAULTED
case|:
switch|switch
condition|(
name|what
condition|)
block|{
ifdef|#
directive|ifdef
name|FLTWATCH
case|case
name|FLTWATCH
case|:
name|statval
operator|=
operator|(
name|SIGTRAP
operator|<<
literal|8
operator|)
operator||
literal|0177
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FLTKWATCH
case|case
name|FLTKWATCH
case|:
name|statval
operator|=
operator|(
name|SIGTRAP
operator|<<
literal|8
operator|)
operator||
literal|0177
expr_stmt|;
break|break;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|FAULTED_USE_SIGINFO
comment|/* Irix, contrary to the documentation, fills in 0 for si_signo. 		 Solaris fills in si_signo.  I'm not sure about others.  */
case|case
name|FLTPRIV
case|:
case|case
name|FLTILL
case|:
name|statval
operator|=
operator|(
name|SIGILL
operator|<<
literal|8
operator|)
operator||
literal|0177
expr_stmt|;
break|break;
case|case
name|FLTBPT
case|:
case|case
name|FLTTRACE
case|:
name|statval
operator|=
operator|(
name|SIGTRAP
operator|<<
literal|8
operator|)
operator||
literal|0177
expr_stmt|;
break|break;
case|case
name|FLTSTACK
case|:
case|case
name|FLTACCESS
case|:
case|case
name|FLTBOUNDS
case|:
name|statval
operator|=
operator|(
name|SIGSEGV
operator|<<
literal|8
operator|)
operator||
literal|0177
expr_stmt|;
break|break;
case|case
name|FLTIOVF
case|:
case|case
name|FLTIZDIV
case|:
case|case
name|FLTFPE
case|:
name|statval
operator|=
operator|(
name|SIGFPE
operator|<<
literal|8
operator|)
operator||
literal|0177
expr_stmt|;
break|break;
case|case
name|FLTPAGE
case|:
comment|/* Recoverable page fault */
endif|#
directive|endif
comment|/* not FAULTED_USE_SIGINFO */
default|default:
comment|/* Use the signal which the kernel assigns.  This is better than 		 trying to second-guess it from the fault.  In fact, I suspect 		 that FLTACCESS can be either SIGSEGV or SIGBUS.  */
name|statval
operator|=
operator|(
operator|(
name|pi
operator|->
name|prstatus
operator|.
name|pr_info
operator|.
name|si_signo
operator|)
operator|<<
literal|8
operator|)
operator||
literal|0177
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|error
argument_list|(
literal|"PIOCWSTOP, unknown why %d, what %d"
argument_list|,
name|why
argument_list|,
name|what
argument_list|)
expr_stmt|;
block|}
comment|/* Stop all the other threads when any of them stops.  */
block|{
name|struct
name|procinfo
modifier|*
name|procinfo
decl_stmt|;
for|for
control|(
name|procinfo
operator|=
name|procinfo_list
init|;
name|procinfo
condition|;
name|procinfo
operator|=
name|procinfo
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|procinfo
operator|->
name|had_event
condition|)
if|if
condition|(
name|ioctl
argument_list|(
name|procinfo
operator|->
name|fd
argument_list|,
name|PIOCSTOP
argument_list|,
operator|&
name|procinfo
operator|->
name|prstatus
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|procinfo
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"PIOCSTOP failed"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|error
argument_list|(
literal|"PIOCWSTOP, stopped for unknown/unhandled reason, flags %#x"
argument_list|,
name|pi
operator|->
name|prstatus
operator|.
name|pr_flags
argument_list|)
expr_stmt|;
block|}
name|store_waitstatus
argument_list|(
name|ourstatus
argument_list|,
name|statval
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtnval
operator|==
operator|-
literal|1
condition|)
comment|/* No more children to wait for */
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Child process unexpectedly missing.\n"
argument_list|)
expr_stmt|;
comment|/* Claim it exited with unknown signal.  */
name|ourstatus
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_SIGNALLED
expr_stmt|;
name|ourstatus
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_UNKNOWN
expr_stmt|;
return|return
name|rtnval
return|;
block|}
name|pi
operator|->
name|had_event
operator|=
literal|0
expr_stmt|;
comment|/* Indicate that we've seen this one */
return|return
operator|(
name|rtnval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	set_proc_siginfo - set a process's current signal info  SYNOPSIS  	void set_proc_siginfo (struct procinfo *pip, int signo);  DESCRIPTION  	Given a pointer to a process info struct in PIP and a signal number 	in SIGNO, set the process's current signal and its associated signal 	information.  The signal will be delivered to the process immediately 	after execution is resumed, even if it is being held.  In addition, 	this particular delivery will not cause another PR_SIGNALLED stop 	even if the signal is being traced.  	If we are not delivering the same signal that the prstatus siginfo 	struct contains information about, then synthesize a siginfo struct 	to match the signal we are doing to deliver, make it of the type 	"generated by a user process", and send this synthesized copy.  When 	used to set the inferior's signal state, this will be required if we 	are not currently stopped because of a traced signal, or if we decide 	to continue with a different signal.  	Note that when continuing the inferior from a stop due to receipt 	of a traced signal, we either have set PRCSIG to clear the existing 	signal, or we have to call this function to do a PIOCSSIG with either 	the existing siginfo struct from pr_info, or one we have synthesized 	appropriately for the signal we want to deliver.  Otherwise if the 	signal is still being traced, the inferior will immediately stop 	again.  	See siginfo(5) for more details. */
end_comment

begin_function
specifier|static
name|void
name|set_proc_siginfo
parameter_list|(
name|pip
parameter_list|,
name|signo
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pip
decl_stmt|;
name|int
name|signo
decl_stmt|;
block|{
name|struct
name|siginfo
name|newsiginfo
decl_stmt|;
name|struct
name|siginfo
modifier|*
name|sip
decl_stmt|;
ifdef|#
directive|ifdef
name|PROCFS_DONT_PIOCSSIG_CURSIG
comment|/* With Alpha OSF/1 procfs, the kernel gets really confused if it      receives a PIOCSSIG with a signal identical to the current signal,      it messes up the current signal. Work around the kernel bug.  */
if|if
condition|(
name|signo
operator|==
name|pip
operator|->
name|prstatus
operator|.
name|pr_cursig
condition|)
return|return;
endif|#
directive|endif
if|if
condition|(
name|signo
operator|==
name|pip
operator|->
name|prstatus
operator|.
name|pr_info
operator|.
name|si_signo
condition|)
block|{
name|sip
operator|=
operator|&
name|pip
operator|->
name|prstatus
operator|.
name|pr_info
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|newsiginfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|newsiginfo
argument_list|)
argument_list|)
expr_stmt|;
name|sip
operator|=
operator|&
name|newsiginfo
expr_stmt|;
name|sip
operator|->
name|si_signo
operator|=
name|signo
expr_stmt|;
name|sip
operator|->
name|si_code
operator|=
literal|0
expr_stmt|;
name|sip
operator|->
name|si_errno
operator|=
literal|0
expr_stmt|;
name|sip
operator|->
name|si_pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|sip
operator|->
name|si_uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|pip
operator|->
name|fd
argument_list|,
name|PIOCSSIG
argument_list|,
name|sip
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pip
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"PIOCSSIG failed"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Resume execution of process PID.  If STEP is nozero, then    just single step it.  If SIGNAL is nonzero, restart it with that    signal activated.  */
end_comment

begin_function
specifier|static
name|void
name|procfs_resume
parameter_list|(
name|pid
parameter_list|,
name|step
parameter_list|,
name|signo
parameter_list|)
name|int
name|pid
decl_stmt|;
name|int
name|step
decl_stmt|;
name|enum
name|target_signal
name|signo
decl_stmt|;
block|{
name|int
name|signal_to_pass
decl_stmt|;
name|struct
name|procinfo
modifier|*
name|pi
decl_stmt|,
modifier|*
name|procinfo
decl_stmt|;
name|pi
operator|=
name|find_procinfo
argument_list|(
name|pid
operator|==
operator|-
literal|1
condition|?
name|inferior_pid
else|:
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|pi
operator|->
name|prrun
operator|.
name|pr_flags
operator|=
name|PRSTRACE
operator||
name|PRSFAULT
operator||
name|PRCFAULT
expr_stmt|;
if|#
directive|if
literal|0
comment|/* It should not be necessary.  If the user explicitly changes the value,      value_assign calls write_register_bytes, which writes it.  */
comment|/*	It may not be absolutely necessary to specify the PC value for 	restarting, but to be safe we use the value that gdb considers 	to be current.  One case where this might be necessary is if the 	user explicitly changes the PC value that gdb considers to be 	current.  FIXME:  Investigate if this is necessary or not.  */
ifdef|#
directive|ifdef
name|PRSVADDR_BROKEN
comment|/* Can't do this under Solaris running on a Sparc, as there seems to be no    place to put nPC.  In fact, if you use this, nPC seems to be set to some    random garbage.  We have to rely on the fact that PC and nPC have been    written previously via PIOCSREG during a register flush. */
block|pi->prrun.pr_vaddr = (caddr_t) *(int *)&registers[REGISTER_BYTE (PC_REGNUM)];   pi->prrun.pr_flags != PRSVADDR;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|signo
operator|==
name|TARGET_SIGNAL_STOP
operator|&&
name|pi
operator|->
name|nopass_next_sigstop
condition|)
comment|/* When attaching to a child process, if we forced it to stop with        a PIOCSTOP, then we will have set the nopass_next_sigstop flag.        Upon resuming the first time after such a stop, we explicitly        inhibit sending it another SIGSTOP, which would be the normal        result of default signal handling.  One potential drawback to        this is that we will also ignore any attempt to by the user        to explicitly continue after the attach with a SIGSTOP.  Ultimately        this problem should be dealt with by making the routines that        deal with the inferior a little smarter, and possibly even allow        an inferior to continue running at the same time as gdb.  (FIXME?)  */
name|signal_to_pass
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|signo
operator|==
name|TARGET_SIGNAL_TSTP
operator|&&
name|pi
operator|->
name|prstatus
operator|.
name|pr_cursig
operator|==
name|SIGTSTP
operator|&&
name|pi
operator|->
name|prstatus
operator|.
name|pr_action
operator|.
name|sa_handler
operator|==
name|SIG_DFL
condition|)
comment|/* We are about to pass the inferior a SIGTSTP whose action is        SIG_DFL.  The SIG_DFL action for a SIGTSTP is to stop        (notifying the parent via wait()), and then keep going from the        same place when the parent is ready for you to keep going.  So        under the debugger, it should do nothing (as if the program had        been stopped and then later resumed.  Under ptrace, this        happens for us, but under /proc, the system obligingly stops        the process, and wait_for_inferior would have no way of        distinguishing that type of stop (which indicates that we        should just start it again), with a stop due to the pr_trace        field of the prrun_t struct.         Note that if the SIGTSTP is being caught, we *do* need to pass it,        because the handler needs to get executed.  */
name|signal_to_pass
operator|=
literal|0
expr_stmt|;
else|else
name|signal_to_pass
operator|=
name|target_signal_to_host
argument_list|(
name|signo
argument_list|)
expr_stmt|;
if|if
condition|(
name|signal_to_pass
condition|)
block|{
name|set_proc_siginfo
argument_list|(
name|pi
argument_list|,
name|signal_to_pass
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pi
operator|->
name|prrun
operator|.
name|pr_flags
operator||=
name|PRCSIG
expr_stmt|;
block|}
name|pi
operator|->
name|nopass_next_sigstop
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|step
condition|)
block|{
name|pi
operator|->
name|prrun
operator|.
name|pr_flags
operator||=
name|PRSTEP
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|PIOCRUN
argument_list|,
operator|&
name|pi
operator|->
name|prrun
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|perror_with_name
argument_list|(
name|pi
operator|->
name|pathname
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|pi
operator|->
name|had_event
operator|=
literal|0
expr_stmt|;
comment|/* Continue all the other threads that haven't had an event of      interest.  */
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
for|for
control|(
name|procinfo
operator|=
name|procinfo_list
init|;
name|procinfo
condition|;
name|procinfo
operator|=
name|procinfo
operator|->
name|next
control|)
block|{
if|if
condition|(
name|pi
operator|!=
name|procinfo
operator|&&
operator|!
name|procinfo
operator|->
name|had_event
condition|)
block|{
name|procinfo
operator|->
name|prrun
operator|.
name|pr_flags
operator|&=
name|PRSTEP
expr_stmt|;
name|procinfo
operator|->
name|prrun
operator|.
name|pr_flags
operator||=
name|PRCFAULT
operator||
name|PRCSIG
expr_stmt|;
name|ioctl
argument_list|(
name|procinfo
operator|->
name|fd
argument_list|,
name|PIOCSTATUS
argument_list|,
operator|&
name|procinfo
operator|->
name|prstatus
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|procinfo
operator|->
name|fd
argument_list|,
name|PIOCRUN
argument_list|,
operator|&
name|procinfo
operator|->
name|prrun
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|procinfo
operator|->
name|fd
argument_list|,
name|PIOCSTATUS
argument_list|,
operator|&
name|procinfo
operator|->
name|prstatus
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"PIOCSTATUS failed, errno=%d\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
name|print_sys_errmsg
argument_list|(
name|procinfo
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"PIOCRUN failed"
argument_list|)
expr_stmt|;
block|}
name|ioctl
argument_list|(
name|procinfo
operator|->
name|fd
argument_list|,
name|PIOCSTATUS
argument_list|,
operator|&
name|procinfo
operator|->
name|prstatus
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	procfs_fetch_registers -- fetch current registers from inferior  SYNOPSIS  	void procfs_fetch_registers (int regno)  DESCRIPTION  	Read the current values of the inferior's registers, both the 	general register set and floating point registers (if supported) 	and update gdb's idea of their current values.  */
end_comment

begin_function
specifier|static
name|void
name|procfs_fetch_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|struct
name|procinfo
modifier|*
name|pi
decl_stmt|;
name|pi
operator|=
name|current_procinfo
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|PIOCGREG
argument_list|,
operator|&
name|pi
operator|->
name|gregset
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|supply_gregset
argument_list|(
operator|&
name|pi
operator|->
name|gregset
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|FP0_REGNUM
argument_list|)
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|fd
argument_list|,
name|PIOCGFPREG
argument_list|,
operator|&
name|pi
operator|->
name|fpregset
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|supply_fpregset
argument_list|(
operator|&
name|pi
operator|->
name|fpregset
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	proc_init_failed - called whenever /proc access initialization fails  SYNOPSIS  	static void proc_init_failed (struct procinfo *pi, char *why)  DESCRIPTION  	This function is called whenever initialization of access to a /proc 	entry fails.  It prints a suitable error message, does some cleanup, 	and then invokes the standard error processing routine which dumps 	us back into the command loop.  */
end_comment

begin_function
specifier|static
name|void
name|proc_init_failed
parameter_list|(
name|pi
parameter_list|,
name|why
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pi
decl_stmt|;
name|char
modifier|*
name|why
decl_stmt|;
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
name|close_proc_file
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|why
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	close_proc_file - close any currently open /proc entry  SYNOPSIS  	static void close_proc_file (struct procinfo *pip)  DESCRIPTION  	Close any currently open /proc entry and mark the process information 	entry as invalid.  In order to ensure that we don't try to reuse any 	stale information, the pid, fd, and pathnames are explicitly 	invalidated, which may be overkill.   */
end_comment

begin_function
specifier|static
name|void
name|close_proc_file
parameter_list|(
name|pip
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pip
decl_stmt|;
block|{
name|struct
name|procinfo
modifier|*
name|procinfo
decl_stmt|;
name|remove_fd
argument_list|(
name|pip
argument_list|)
expr_stmt|;
comment|/* Remove fd from poll/select list */
name|close
argument_list|(
name|pip
operator|->
name|fd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pip
operator|->
name|pathname
argument_list|)
expr_stmt|;
comment|/* Unlink pip from the procinfo chain.  Note pip might not be on the list. */
if|if
condition|(
name|procinfo_list
operator|==
name|pip
condition|)
name|procinfo_list
operator|=
name|pip
operator|->
name|next
expr_stmt|;
else|else
for|for
control|(
name|procinfo
operator|=
name|procinfo_list
init|;
name|procinfo
condition|;
name|procinfo
operator|=
name|procinfo
operator|->
name|next
control|)
if|if
condition|(
name|procinfo
operator|->
name|next
operator|==
name|pip
condition|)
name|procinfo
operator|->
name|next
operator|=
name|pip
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|pip
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	open_proc_file - open a /proc entry for a given process id  SYNOPSIS  	static int open_proc_file (int pid, struct procinfo *pip, int mode)  DESCRIPTION  	Given a process id and a mode, close the existing open /proc 	entry (if any) and open one for the new process id, in the 	specified mode.  Once it is open, then mark the local process 	information structure as valid, which guarantees that the pid, 	fd, and pathname fields match an open /proc entry.  Returns 	zero if the open fails, nonzero otherwise.  	Note that the pathname is left intact, even when the open fails, 	so that callers can use it to construct meaningful error messages 	rather than just "file open failed".  */
end_comment

begin_function
specifier|static
name|int
name|open_proc_file
parameter_list|(
name|pid
parameter_list|,
name|pip
parameter_list|,
name|mode
parameter_list|)
name|int
name|pid
decl_stmt|;
name|struct
name|procinfo
modifier|*
name|pip
decl_stmt|;
name|int
name|mode
decl_stmt|;
block|{
name|pip
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|pip
operator|->
name|had_event
operator|=
literal|0
expr_stmt|;
name|pip
operator|->
name|pathname
operator|=
name|xmalloc
argument_list|(
literal|32
argument_list|)
expr_stmt|;
name|pip
operator|->
name|pid
operator|=
name|pid
expr_stmt|;
name|sprintf
argument_list|(
name|pip
operator|->
name|pathname
argument_list|,
name|PROC_NAME_FMT
argument_list|,
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pip
operator|->
name|fd
operator|=
name|open
argument_list|(
name|pip
operator|->
name|pathname
argument_list|,
name|mode
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|mappingflags
parameter_list|(
name|flags
parameter_list|)
name|long
name|flags
decl_stmt|;
block|{
specifier|static
name|char
name|asciiflags
index|[
literal|8
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|asciiflags
argument_list|,
literal|"-------"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MA_PHYS
argument_list|)
if|if
condition|(
name|flags
operator|&
name|MA_PHYS
condition|)
name|asciiflags
index|[
literal|0
index|]
operator|=
literal|'d'
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flags
operator|&
name|MA_STACK
condition|)
name|asciiflags
index|[
literal|1
index|]
operator|=
literal|'s'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MA_BREAK
condition|)
name|asciiflags
index|[
literal|2
index|]
operator|=
literal|'b'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MA_SHARED
condition|)
name|asciiflags
index|[
literal|3
index|]
operator|=
literal|'s'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MA_READ
condition|)
name|asciiflags
index|[
literal|4
index|]
operator|=
literal|'r'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MA_WRITE
condition|)
name|asciiflags
index|[
literal|5
index|]
operator|=
literal|'w'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MA_EXEC
condition|)
name|asciiflags
index|[
literal|6
index|]
operator|=
literal|'x'
expr_stmt|;
return|return
operator|(
name|asciiflags
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|info_proc_flags
parameter_list|(
name|pip
parameter_list|,
name|summary
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pip
decl_stmt|;
name|int
name|summary
decl_stmt|;
block|{
name|struct
name|trans
modifier|*
name|transp
decl_stmt|;
name|printf_filtered
argument_list|(
literal|"%-32s"
argument_list|,
literal|"Process status flags:"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|summary
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|transp
operator|=
name|pr_flag_table
init|;
name|transp
operator|->
name|name
operator|!=
name|NULL
condition|;
name|transp
operator|++
control|)
block|{
if|if
condition|(
name|pip
operator|->
name|prstatus
operator|.
name|pr_flags
operator|&
name|transp
operator|->
name|value
condition|)
block|{
if|if
condition|(
name|summary
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%s "
argument_list|,
name|transp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"\t%-16s %s.\n"
argument_list|,
name|transp
operator|->
name|name
argument_list|,
name|transp
operator|->
name|desc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|info_proc_stop
parameter_list|(
name|pip
parameter_list|,
name|summary
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pip
decl_stmt|;
name|int
name|summary
decl_stmt|;
block|{
name|struct
name|trans
modifier|*
name|transp
decl_stmt|;
name|int
name|why
decl_stmt|;
name|int
name|what
decl_stmt|;
name|why
operator|=
name|pip
operator|->
name|prstatus
operator|.
name|pr_why
expr_stmt|;
name|what
operator|=
name|pip
operator|->
name|prstatus
operator|.
name|pr_what
expr_stmt|;
if|if
condition|(
name|pip
operator|->
name|prstatus
operator|.
name|pr_flags
operator|&
name|PR_STOPPED
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%-32s"
argument_list|,
literal|"Reason for stopping:"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|summary
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|transp
operator|=
name|pr_why_table
init|;
name|transp
operator|->
name|name
operator|!=
name|NULL
condition|;
name|transp
operator|++
control|)
block|{
if|if
condition|(
name|why
operator|==
name|transp
operator|->
name|value
condition|)
block|{
if|if
condition|(
name|summary
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%s "
argument_list|,
name|transp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"\t%-16s %s.\n"
argument_list|,
name|transp
operator|->
name|name
argument_list|,
name|transp
operator|->
name|desc
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/* Use the pr_why field to determine what the pr_what field means, and 	 print more information. */
switch|switch
condition|(
name|why
condition|)
block|{
case|case
name|PR_REQUESTED
case|:
comment|/* pr_what is unused for this case */
break|break;
case|case
name|PR_JOBCONTROL
case|:
case|case
name|PR_SIGNALLED
case|:
if|if
condition|(
name|summary
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%s "
argument_list|,
name|signalname
argument_list|(
name|what
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"\t%-16s %s.\n"
argument_list|,
name|signalname
argument_list|(
name|what
argument_list|)
argument_list|,
name|safe_strsignal
argument_list|(
name|what
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PR_SYSENTRY
case|:
if|if
condition|(
name|summary
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%s "
argument_list|,
name|syscallname
argument_list|(
name|what
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"\t%-16s %s.\n"
argument_list|,
name|syscallname
argument_list|(
name|what
argument_list|)
argument_list|,
literal|"Entered this system call"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PR_SYSEXIT
case|:
if|if
condition|(
name|summary
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%s "
argument_list|,
name|syscallname
argument_list|(
name|what
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"\t%-16s %s.\n"
argument_list|,
name|syscallname
argument_list|(
name|what
argument_list|)
argument_list|,
literal|"Returned from this system call"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PR_FAULTED
case|:
if|if
condition|(
name|summary
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%s "
argument_list|,
name|lookupname
argument_list|(
name|faults_table
argument_list|,
name|what
argument_list|,
literal|"fault"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"\t%-16s %s.\n"
argument_list|,
name|lookupname
argument_list|(
name|faults_table
argument_list|,
name|what
argument_list|,
literal|"fault"
argument_list|)
argument_list|,
name|lookupdesc
argument_list|(
name|faults_table
argument_list|,
name|what
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|info_proc_siginfo
parameter_list|(
name|pip
parameter_list|,
name|summary
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pip
decl_stmt|;
name|int
name|summary
decl_stmt|;
block|{
name|struct
name|siginfo
modifier|*
name|sip
decl_stmt|;
if|if
condition|(
operator|(
name|pip
operator|->
name|prstatus
operator|.
name|pr_flags
operator|&
name|PR_STOPPED
operator|)
operator|&&
operator|(
name|pip
operator|->
name|prstatus
operator|.
name|pr_why
operator|==
name|PR_SIGNALLED
operator|||
name|pip
operator|->
name|prstatus
operator|.
name|pr_why
operator|==
name|PR_FAULTED
operator|)
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%-32s"
argument_list|,
literal|"Additional signal/fault info:"
argument_list|)
expr_stmt|;
name|sip
operator|=
operator|&
name|pip
operator|->
name|prstatus
operator|.
name|pr_info
expr_stmt|;
if|if
condition|(
name|summary
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%s "
argument_list|,
name|signalname
argument_list|(
name|sip
operator|->
name|si_signo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sip
operator|->
name|si_errno
operator|>
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%s "
argument_list|,
name|errnoname
argument_list|(
name|sip
operator|->
name|si_errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sip
operator|->
name|si_code
operator|<=
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"sent by %s, uid %d "
argument_list|,
name|target_pid_to_str
argument_list|(
name|sip
operator|->
name|si_pid
argument_list|)
argument_list|,
name|sip
operator|->
name|si_uid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"%s "
argument_list|,
name|sigcodename
argument_list|(
name|sip
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sip
operator|->
name|si_signo
operator|==
name|SIGILL
operator|)
operator|||
operator|(
name|sip
operator|->
name|si_signo
operator|==
name|SIGFPE
operator|)
operator|||
operator|(
name|sip
operator|->
name|si_signo
operator|==
name|SIGSEGV
operator|)
operator|||
operator|(
name|sip
operator|->
name|si_signo
operator|==
name|SIGBUS
operator|)
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"addr=%#lx "
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sip
operator|->
name|si_addr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sip
operator|->
name|si_signo
operator|==
name|SIGCHLD
operator|)
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"child %s, status %u "
argument_list|,
name|target_pid_to_str
argument_list|(
name|sip
operator|->
name|si_pid
argument_list|)
argument_list|,
name|sip
operator|->
name|si_status
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sip
operator|->
name|si_signo
operator|==
name|SIGPOLL
operator|)
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"band %u "
argument_list|,
name|sip
operator|->
name|si_band
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\t%-16s %s.\n"
argument_list|,
name|signalname
argument_list|(
name|sip
operator|->
name|si_signo
argument_list|)
argument_list|,
name|safe_strsignal
argument_list|(
name|sip
operator|->
name|si_signo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sip
operator|->
name|si_errno
operator|>
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\t%-16s %s.\n"
argument_list|,
name|errnoname
argument_list|(
name|sip
operator|->
name|si_errno
argument_list|)
argument_list|,
name|safe_strerror
argument_list|(
name|sip
operator|->
name|si_errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sip
operator|->
name|si_code
operator|<=
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\t%-16u %s\n"
argument_list|,
name|sip
operator|->
name|si_pid
argument_list|,
comment|/* XXX need target_pid_to_str() */
literal|"PID of process sending signal"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\t%-16u %s\n"
argument_list|,
name|sip
operator|->
name|si_uid
argument_list|,
literal|"UID of process sending signal"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"\t%-16s %s.\n"
argument_list|,
name|sigcodename
argument_list|(
name|sip
argument_list|)
argument_list|,
name|sigcodedesc
argument_list|(
name|sip
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sip
operator|->
name|si_signo
operator|==
name|SIGILL
operator|)
operator|||
operator|(
name|sip
operator|->
name|si_signo
operator|==
name|SIGFPE
operator|)
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\t%#-16lx %s.\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sip
operator|->
name|si_addr
argument_list|,
literal|"Address of faulting instruction"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sip
operator|->
name|si_signo
operator|==
name|SIGSEGV
operator|)
operator|||
operator|(
name|sip
operator|->
name|si_signo
operator|==
name|SIGBUS
operator|)
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\t%#-16lx %s.\n"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|sip
operator|->
name|si_addr
argument_list|,
literal|"Address of faulting memory reference"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sip
operator|->
name|si_signo
operator|==
name|SIGCHLD
operator|)
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\t%-16u %s.\n"
argument_list|,
name|sip
operator|->
name|si_pid
argument_list|,
comment|/* XXX need target_pid_to_str() */
literal|"Child process ID"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\t%-16u %s.\n"
argument_list|,
name|sip
operator|->
name|si_status
argument_list|,
literal|"Child process exit value or signal"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sip
operator|->
name|si_signo
operator|==
name|SIGPOLL
operator|)
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\t%-16u %s.\n"
argument_list|,
name|sip
operator|->
name|si_band
argument_list|,
literal|"Band event for POLL_{IN,OUT,MSG}"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|info_proc_syscalls
parameter_list|(
name|pip
parameter_list|,
name|summary
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pip
decl_stmt|;
name|int
name|summary
decl_stmt|;
block|{
name|int
name|syscallnum
decl_stmt|;
if|if
condition|(
operator|!
name|summary
condition|)
block|{
if|#
directive|if
literal|0
comment|/* FIXME:  Needs to use gdb-wide configured info about system calls. */
block|if (pip -> prstatus.pr_flags& PR_ASLEEP) 	{ 	  int syscallnum = pip -> prstatus.pr_reg[R_D0]; 	  if (summary) 	    { 	      printf_filtered ("%-32s", "Sleeping in system call:"); 	      printf_filtered ("%s", syscallname (syscallnum)); 	    } 	  else 	    { 	      printf_filtered ("Sleeping in system call '%s'.\n", 			       syscallname (syscallnum)); 	    } 	}
endif|#
directive|endif
if|if
condition|(
name|ioctl
argument_list|(
name|pip
operator|->
name|fd
argument_list|,
name|PIOCGENTRY
argument_list|,
operator|&
name|pip
operator|->
name|entryset
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pip
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"PIOCGENTRY failed"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|pip
operator|->
name|fd
argument_list|,
name|PIOCGEXIT
argument_list|,
operator|&
name|pip
operator|->
name|exitset
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pip
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"PIOCGEXIT failed"
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"System call tracing information:\n\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\t%-12s %-8s %-8s\n"
argument_list|,
literal|"System call"
argument_list|,
literal|"Entry"
argument_list|,
literal|"Exit"
argument_list|)
expr_stmt|;
for|for
control|(
name|syscallnum
operator|=
literal|0
init|;
name|syscallnum
operator|<
name|MAX_SYSCALLS
condition|;
name|syscallnum
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|syscall_table
index|[
name|syscallnum
index|]
operator|!=
name|NULL
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\t%-12s "
argument_list|,
name|syscall_table
index|[
name|syscallnum
index|]
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%-8s "
argument_list|,
name|prismember
argument_list|(
operator|&
name|pip
operator|->
name|entryset
argument_list|,
name|syscallnum
argument_list|)
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%-8s "
argument_list|,
name|prismember
argument_list|(
operator|&
name|pip
operator|->
name|exitset
argument_list|,
name|syscallnum
argument_list|)
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|signalname
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|static
name|char
name|locbuf
index|[
literal|32
index|]
decl_stmt|;
name|name
operator|=
name|strsigno
argument_list|(
name|signo
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|locbuf
argument_list|,
literal|"Signal %d"
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|locbuf
argument_list|,
literal|"%s (%d)"
argument_list|,
name|name
argument_list|,
name|signo
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|locbuf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|errnoname
parameter_list|(
name|errnum
parameter_list|)
name|int
name|errnum
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|static
name|char
name|locbuf
index|[
literal|32
index|]
decl_stmt|;
name|name
operator|=
name|strerrno
argument_list|(
name|errnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|locbuf
argument_list|,
literal|"Errno %d"
argument_list|,
name|errnum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|locbuf
argument_list|,
literal|"%s (%d)"
argument_list|,
name|name
argument_list|,
name|errnum
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|locbuf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|info_proc_signals
parameter_list|(
name|pip
parameter_list|,
name|summary
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pip
decl_stmt|;
name|int
name|summary
decl_stmt|;
block|{
name|int
name|signo
decl_stmt|;
if|if
condition|(
operator|!
name|summary
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|pip
operator|->
name|fd
argument_list|,
name|PIOCGTRACE
argument_list|,
operator|&
name|pip
operator|->
name|trace
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pip
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"PIOCGTRACE failed"
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"Disposition of signals:\n\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\t%-15s %-8s %-8s %-8s  %s\n\n"
argument_list|,
literal|"Signal"
argument_list|,
literal|"Trace"
argument_list|,
literal|"Hold"
argument_list|,
literal|"Pending"
argument_list|,
literal|"Description"
argument_list|)
expr_stmt|;
for|for
control|(
name|signo
operator|=
literal|0
init|;
name|signo
operator|<
name|NSIG
condition|;
name|signo
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\t%-15s "
argument_list|,
name|signalname
argument_list|(
name|signo
argument_list|)
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%-8s "
argument_list|,
name|prismember
argument_list|(
operator|&
name|pip
operator|->
name|trace
argument_list|,
name|signo
argument_list|)
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%-8s "
argument_list|,
name|prismember
argument_list|(
operator|&
name|pip
operator|->
name|prstatus
operator|.
name|pr_sighold
argument_list|,
name|signo
argument_list|)
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROCFS_SIGPEND_OFFSET
comment|/* Alpha OSF/1 numbers the pending signals from 1.  */
name|printf_filtered
argument_list|(
literal|"%-8s "
argument_list|,
operator|(
name|signo
condition|?
name|prismember
argument_list|(
operator|&
name|pip
operator|->
name|prstatus
operator|.
name|pr_sigpend
argument_list|,
name|signo
operator|-
literal|1
argument_list|)
else|:
literal|0
operator|)
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf_filtered
argument_list|(
literal|"%-8s "
argument_list|,
name|prismember
argument_list|(
operator|&
name|pip
operator|->
name|prstatus
operator|.
name|pr_sigpend
argument_list|,
name|signo
argument_list|)
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printf_filtered
argument_list|(
literal|" %s\n"
argument_list|,
name|safe_strsignal
argument_list|(
name|signo
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|info_proc_faults
parameter_list|(
name|pip
parameter_list|,
name|summary
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pip
decl_stmt|;
name|int
name|summary
decl_stmt|;
block|{
name|struct
name|trans
modifier|*
name|transp
decl_stmt|;
if|if
condition|(
operator|!
name|summary
condition|)
block|{
if|if
condition|(
name|ioctl
argument_list|(
name|pip
operator|->
name|fd
argument_list|,
name|PIOCGFAULT
argument_list|,
operator|&
name|pip
operator|->
name|fltset
argument_list|)
operator|<
literal|0
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pip
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"PIOCGFAULT failed"
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"Current traced hardware fault set:\n\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\t%-12s %-8s\n"
argument_list|,
literal|"Fault"
argument_list|,
literal|"Trace"
argument_list|)
expr_stmt|;
for|for
control|(
name|transp
operator|=
name|faults_table
init|;
name|transp
operator|->
name|name
operator|!=
name|NULL
condition|;
name|transp
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\t%-12s "
argument_list|,
name|transp
operator|->
name|name
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%-8s"
argument_list|,
name|prismember
argument_list|(
operator|&
name|pip
operator|->
name|fltset
argument_list|,
name|transp
operator|->
name|value
argument_list|)
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|info_proc_mappings
parameter_list|(
name|pip
parameter_list|,
name|summary
parameter_list|)
name|struct
name|procinfo
modifier|*
name|pip
decl_stmt|;
name|int
name|summary
decl_stmt|;
block|{
name|int
name|nmap
decl_stmt|;
name|struct
name|prmap
modifier|*
name|prmaps
decl_stmt|;
name|struct
name|prmap
modifier|*
name|prmap
decl_stmt|;
if|if
condition|(
operator|!
name|summary
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Mapped address spaces:\n\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BFD_HOST_64_BIT
name|printf_filtered
argument_list|(
literal|"  %18s %18s %10s %10s %7s\n"
argument_list|,
else|#
directive|else
argument|printf_filtered (
literal|"\t%10s %10s %10s %10s %7s\n"
argument|,
endif|#
directive|endif
literal|"Start Addr"
argument|,
literal|"  End Addr"
argument|,
literal|"      Size"
argument|,
literal|"    Offset"
argument|,
literal|"Flags"
argument|);       if (ioctl (pip -> fd, PIOCNMAP,&nmap) ==
literal|0
argument|) 	{ 	  prmaps = (struct prmap *) alloca ((nmap +
literal|1
argument|) * sizeof (*prmaps)); 	  if (ioctl (pip -> fd, PIOCMAP, prmaps) ==
literal|0
argument|) 	    { 	      for (prmap = prmaps; prmap -> pr_size; ++prmap) 		{
ifdef|#
directive|ifdef
name|BFD_HOST_64_BIT
argument|printf_filtered (
literal|"  %#18lx %#18lx %#10x %#10x %7s\n"
argument|,
else|#
directive|else
argument|printf_filtered (
literal|"\t%#10lx %#10lx %#10x %#10x %7s\n"
argument|,
endif|#
directive|endif
argument|(unsigned long)prmap -> pr_vaddr, 				   (unsigned long)prmap -> pr_vaddr 				     + prmap -> pr_size -
literal|1
argument|, 				   prmap -> pr_size, 				   prmap -> pr_off, 				   mappingflags (prmap -> pr_mflags)); 		} 	    } 	}       printf_filtered (
literal|"\n"
argument|);     } }
comment|/*  LOCAL FUNCTION  	info_proc -- implement the "info proc" command  SYNOPSIS  	void info_proc (char *args, int from_tty)  DESCRIPTION  	Implement gdb's "info proc" command by using the /proc interface 	to print status information about any currently running process.  	Examples of the use of "info proc" are:  	info proc		(prints summary info for current inferior) 	info proc 123		(prints summary info for process with pid 123) 	info proc mappings	(prints address mappings) 	info proc times		(prints process/children times) 	info proc id		(prints pid, ppid, gid, sid, etc) 		FIXME:  i proc id not implemented. 	info proc status	(prints general process state info) 		FIXME:  i proc status not implemented. 	info proc signals	(prints info about signal handling) 	info proc all		(prints all info)   */
argument|static void info_proc (args, from_tty)      char *args;      int from_tty; {   int pid;   struct procinfo *pip;   struct cleanup *old_chain;   char **argv;   int argsize;   int summary =
literal|1
argument|;   int flags =
literal|0
argument|;   int syscalls =
literal|0
argument|;   int signals =
literal|0
argument|;   int faults =
literal|0
argument|;   int mappings =
literal|0
argument|;   int times =
literal|0
argument|;   int id =
literal|0
argument|;   int status =
literal|0
argument|;   int all =
literal|0
argument|;    old_chain = make_cleanup (null_cleanup,
literal|0
argument|);
comment|/* Default to using the current inferior if no pid specified.  Note      that inferior_pid may be 0, hence we set okerr.  */
argument|pip = find_procinfo (inferior_pid,
literal|1
argument|);    if (args != NULL)     {       if ((argv = buildargv (args)) == NULL) 	{ 	  nomem (
literal|0
argument|); 	}       make_cleanup (freeargv, (char *) argv);        while (*argv != NULL) 	{ 	  argsize = strlen (*argv); 	  if (argsize>=
literal|1
argument|&& strncmp (*argv,
literal|"all"
argument|, argsize) ==
literal|0
argument|) 	    { 	      summary =
literal|0
argument|; 	      all =
literal|1
argument|; 	    } 	  else if (argsize>=
literal|2
argument|&& strncmp (*argv,
literal|"faults"
argument|, argsize) ==
literal|0
argument|) 	    { 	      summary =
literal|0
argument|; 	      faults =
literal|1
argument|; 	    } 	  else if (argsize>=
literal|2
argument|&& strncmp (*argv,
literal|"flags"
argument|, argsize) ==
literal|0
argument|) 	    { 	      summary =
literal|0
argument|; 	      flags =
literal|1
argument|; 	    } 	  else if (argsize>=
literal|1
argument|&& strncmp (*argv,
literal|"id"
argument|, argsize) ==
literal|0
argument|) 	    { 	      summary =
literal|0
argument|; 	      id =
literal|1
argument|; 	    } 	  else if (argsize>=
literal|1
argument|&& strncmp (*argv,
literal|"mappings"
argument|, argsize) ==
literal|0
argument|) 	    { 	      summary =
literal|0
argument|; 	      mappings =
literal|1
argument|; 	    } 	  else if (argsize>=
literal|2
argument|&& strncmp (*argv,
literal|"signals"
argument|, argsize) ==
literal|0
argument|) 	    { 	      summary =
literal|0
argument|; 	      signals =
literal|1
argument|; 	    } 	  else if (argsize>=
literal|2
argument|&& strncmp (*argv,
literal|"status"
argument|, argsize) ==
literal|0
argument|) 	    { 	      summary =
literal|0
argument|; 	      status =
literal|1
argument|; 	    } 	  else if (argsize>=
literal|2
argument|&& strncmp (*argv,
literal|"syscalls"
argument|, argsize) ==
literal|0
argument|) 	    { 	      summary =
literal|0
argument|; 	      syscalls =
literal|1
argument|; 	    } 	  else if (argsize>=
literal|1
argument|&& strncmp (*argv,
literal|"times"
argument|, argsize) ==
literal|0
argument|) 	    { 	      summary =
literal|0
argument|; 	      times =
literal|1
argument|; 	    } 	  else if ((pid = atoi (*argv))>
literal|0
argument|) 	    { 	      pip = (struct procinfo *) xmalloc (sizeof (struct procinfo)); 	      memset (pip,
literal|0
argument|, sizeof (*pip));  	      pip->pid = pid; 	      if (!open_proc_file (pid, pip, O_RDONLY)) 		{ 		  perror_with_name (pip -> pathname);
comment|/* NOTREACHED */
argument|} 	      make_cleanup (close_proc_file, pip); 	    } 	  else if (**argv !=
literal|'\000'
argument|) 	    { 	      error (
literal|"Unrecognized or ambiguous keyword `%s'."
argument|, *argv); 	    } 	  argv++; 	}     }
comment|/* If we don't have a valid open process at this point, then we have no      inferior or didn't specify a specific pid. */
argument|if (!pip)     {       error (
literal|"\ No process.  Start debugging a program or specify an explicit process ID."
argument|);     }   if (ioctl (pip -> fd, PIOCSTATUS,&(pip -> prstatus))<
literal|0
argument|)     {       print_sys_errmsg (pip -> pathname, errno);       error (
literal|"PIOCSTATUS failed"
argument|);     }
comment|/* Print verbose information of the requested type(s), or just a summary      of the information for all types. */
argument|printf_filtered (
literal|"\nInformation for %s:\n\n"
argument|, pip -> pathname);   if (summary || all || flags)     {       info_proc_flags (pip, summary);     }   if (summary || all)     {       info_proc_stop (pip, summary);     }   if (summary || all || signals || faults)     {       info_proc_siginfo (pip, summary);     }   if (summary || all || syscalls)     {       info_proc_syscalls (pip, summary);     }   if (summary || all || mappings)     {       info_proc_mappings (pip, summary);     }   if (summary || all || signals)     {       info_proc_signals (pip, summary);     }   if (summary || all || faults)     {       info_proc_faults (pip, summary);     }   printf_filtered (
literal|"\n"
argument|);
comment|/* All done, deal with closing any temporary process info structure,      freeing temporary memory , etc. */
argument|do_cleanups (old_chain); }
comment|/*  LOCAL FUNCTION  	procfs_set_sproc_trap -- arrange for child to stop on sproc().  SYNOPSIS  	void procfs_set_sproc_trap (struct procinfo *)  DESCRIPTION  	This function sets up a trap on sproc system call exits so that we can 	detect the arrival of a new thread.  We are called with the new thread 	stopped prior to it's first instruction.  	Also note that we turn on the inherit-on-fork flag in the child process 	so that any grand-children start with all tracing flags set.  */
ifdef|#
directive|ifdef
name|SYS_sproc
argument|static void procfs_set_sproc_trap (pi)      struct procinfo *pi; {   sysset_t exitset;      if (ioctl (pi->fd, PIOCGEXIT,&exitset)<
literal|0
argument|)     {       print_sys_errmsg (pi->pathname, errno);       error (
literal|"PIOCGEXIT failed"
argument|);     }    praddset (&exitset, SYS_sproc);
comment|/* We trap on fork() and vfork() in order to disable debugging in our grand-      children and descendant processes.  At this time, GDB can only handle      threads (multiple processes, one address space).  forks (and execs) result      in the creation of multiple address spaces, which GDB can't handle yet.  */
argument|praddset (&exitset, SYS_fork);
ifdef|#
directive|ifdef
name|SYS_vfork
argument|praddset (&exitset, SYS_vfork);
endif|#
directive|endif
argument|if (ioctl (pi->fd, PIOCSEXIT,&exitset)<
literal|0
argument|)     {       print_sys_errmsg (pi->pathname, errno);       error (
literal|"PIOCSEXIT failed"
argument|);     }
comment|/* Turn on inherit-on-fork flag so that all grand-children of gdb start with      tracing flags set. */
ifdef|#
directive|ifdef
name|PIOCSET
comment|/* New method */
argument|{       long pr_flags;       pr_flags = PR_FORK;       ioctl (pi->fd, PIOCSET,&pr_flags);   }
else|#
directive|else
ifdef|#
directive|ifdef
name|PIOCSFORK
comment|/* Original method */
argument|ioctl (pi->fd, PIOCSFORK, NULL);
endif|#
directive|endif
endif|#
directive|endif
argument|}
endif|#
directive|endif
comment|/* SYS_sproc */
comment|/* Fork an inferior process, and start debugging it with /proc.  */
argument|static void procfs_create_inferior (exec_file, allargs, env)      char *exec_file;      char *allargs;      char **env; {   char *shell_file = getenv (
literal|"SHELL"
argument|);   char *tryname;   if (shell_file != NULL&& strchr (shell_file,
literal|'/'
argument|) == NULL)     {
comment|/* We will be looking down the PATH to find shell_file.  If we 	 just do this the normal way (via execlp, which operates by 	 attempting an exec for each element of the PATH until it 	 finds one which succeeds), then there will be an exec for 	 each failed attempt, each of which will cause a PR_SYSEXIT 	 stop, and we won't know how to distinguish the PR_SYSEXIT's 	 for these failed execs with the ones for successful execs 	 (whether the exec has succeeded is stored at that time in the 	 carry bit or some such architecture-specific and 	 non-ABI-specified place).  	 So I can't think of anything better than to search the PATH 	 now.  This has several disadvantages: (1) There is a race 	 condition; if we find a file now and it is deleted before we 	 exec it, we lose, even if the deletion leaves a valid file 	 further down in the PATH, (2) there is no way to know exactly 	 what an executable (in the sense of "capable of being 	 exec'd") file is.  Using access() loses because it may lose 	 if the caller is the superuser; failing to use it loses if 	 there are ACLs or some such.  */
argument|char *p;       char *p1;
comment|/* FIXME-maybe: might want "set path" command so user can change what 	 path is used from within GDB.  */
argument|char *path = getenv (
literal|"PATH"
argument|);       int len;       struct stat statbuf;        if (path == NULL) 	path =
literal|"/bin:/usr/bin"
argument|;        tryname = alloca (strlen (path) + strlen (shell_file) +
literal|2
argument|);       for (p = path; p != NULL; p = p1 ? p1 +
literal|1
argument|: NULL) 	{ 	  p1 = strchr (p,
literal|':'
argument|); 	  if (p1 != NULL) 	    len = p1 - p; 	  else 	    len = strlen (p); 	  strncpy (tryname, p, len); 	  tryname[len] =
literal|'\0'
argument|; 	  strcat (tryname,
literal|"/"
argument|); 	  strcat (tryname, shell_file); 	  if (access (tryname, X_OK)<
literal|0
argument|) 	    continue; 	  if (stat (tryname,&statbuf)<
literal|0
argument|) 	    continue; 	  if (!S_ISREG (statbuf.st_mode))
comment|/* We certainly need to reject directories.  I'm not quite 	       as sure about FIFOs, sockets, etc., but I kind of doubt 	       that people want to exec() these things.  */
argument|continue; 	  break; 	}       if (p == NULL)
comment|/* Not found.  This must be an error rather than merely passing 	   the file to execlp(), because execlp() would try all the 	   exec()s, causing GDB to get confused.  */
argument|error (
literal|"Can't find shell %s in PATH"
argument|, shell_file);        shell_file = tryname;     }    fork_inferior (exec_file, allargs, env, 		 proc_set_exec_trap, procfs_init_inferior, shell_file);
comment|/* We are at the first instruction we care about.  */
comment|/* Pedal to the metal... */
comment|/* Setup traps on exit from sproc() */
ifdef|#
directive|ifdef
name|SYS_sproc
argument|procfs_set_sproc_trap (current_procinfo);
endif|#
directive|endif
argument|proceed ((CORE_ADDR) -
literal|1
argument|, TARGET_SIGNAL_0,
literal|0
argument|); }
comment|/* Clean up after the inferior dies.  */
argument|static void procfs_mourn_inferior () {   struct procinfo *pi;   struct procinfo *next_pi;    for (pi = procinfo_list; pi; pi = next_pi)     {       next_pi = pi->next;       unconditionally_kill_inferior (pi);     }    unpush_target (&procfs_ops);   generic_mourn_inferior (); }
comment|/* Mark our target-struct as eligible for stray "run" and "attach" commands.  */
argument|static int procfs_can_run () {   return(
literal|1
argument|); }
ifdef|#
directive|ifdef
name|TARGET_HAS_HARDWARE_WATCHPOINTS
comment|/* Insert a watchpoint */
argument|int procfs_set_watchpoint(pid, addr, len, rw)      int		pid;      CORE_ADDR		addr;      int		len;      int		rw; {   struct procinfo	*pi;   prwatch_t		wpt;    pi = find_procinfo (pid == -
literal|1
argument|? inferior_pid : pid,
literal|0
argument|);   wpt.pr_vaddr = (caddr_t)addr;   wpt.pr_size = len;   wpt.pr_wflags = ((rw&
literal|1
argument|) ? MA_READ :
literal|0
argument|) | ((rw&
literal|2
argument|) ? MA_WRITE :
literal|0
argument|);   if (ioctl (pi->fd, PIOCSWATCH,&wpt)<
literal|0
argument|)     {       if (errno == E2BIG) 	return -
literal|1
argument|;
comment|/* Currently it sometimes happens that the same watchpoint gets 	 deleted twice - don't die in this case (FIXME please) */
argument|if (errno == ESRCH&& len ==
literal|0
argument|) 	return
literal|0
argument|;       print_sys_errmsg (pi->pathname, errno);       error (
literal|"PIOCSWATCH failed"
argument|);     }   return
literal|0
argument|; }  int procfs_stopped_by_watchpoint(pid)     int			pid; {   struct procinfo	*pi;   short 		what;   short 		why;    pi = find_procinfo (pid == -
literal|1
argument|? inferior_pid : pid,
literal|0
argument|);   if (pi->prstatus.pr_flags& (PR_STOPPED | PR_ISTOP))     {       why = pi->prstatus.pr_why;       what = pi->prstatus.pr_what;       if (why == PR_FAULTED
if|#
directive|if
name|defined
argument_list|(
name|FLTWATCH
argument_list|)
operator|&&
name|defined
argument_list|(
name|FLTKWATCH
argument_list|)
argument|&& (what == FLTWATCH || what == FLTKWATCH)
else|#
directive|else
ifdef|#
directive|ifdef
name|FLTWATCH
argument|&& (what == FLTWATCH)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FLTKWATCH
argument|&& (what == FLTKWATCH)
endif|#
directive|endif
endif|#
directive|endif
argument|) 	return what;     }   return
literal|0
argument|; }
endif|#
directive|endif
comment|/* Send a SIGINT to the process group.  This acts just like the user typed a    ^C on the controlling terminal.     XXX - This may not be correct for all systems.  Some may want to use    killpg() instead of kill (-pgrp). */
argument|void procfs_stop () {   extern pid_t inferior_process_group;    kill (-inferior_process_group, SIGINT); }
argument|struct target_ops procfs_ops = {
literal|"procfs"
argument|,
comment|/* to_shortname */
literal|"Unix /proc child process"
argument|,
comment|/* to_longname */
literal|"Unix /proc child process (started by the \"run\" command)."
argument|,
comment|/* to_doc */
argument|procfs_open,
comment|/* to_open */
literal|0
argument|,
comment|/* to_close */
argument|procfs_attach,
comment|/* to_attach */
argument|procfs_detach,
comment|/* to_detach */
argument|procfs_resume,
comment|/* to_resume */
argument|procfs_wait,
comment|/* to_wait */
argument|procfs_fetch_registers,
comment|/* to_fetch_registers */
argument|procfs_store_registers,
comment|/* to_store_registers */
argument|procfs_prepare_to_store,
comment|/* to_prepare_to_store */
argument|procfs_xfer_memory,
comment|/* to_xfer_memory */
argument|procfs_files_info,
comment|/* to_files_info */
argument|memory_insert_breakpoint,
comment|/* to_insert_breakpoint */
argument|memory_remove_breakpoint,
comment|/* to_remove_breakpoint */
argument|terminal_init_inferior,
comment|/* to_terminal_init */
argument|terminal_inferior,
comment|/* to_terminal_inferior */
argument|terminal_ours_for_output,
comment|/* to_terminal_ours_for_output */
argument|terminal_ours,
comment|/* to_terminal_ours */
argument|child_terminal_info,
comment|/* to_terminal_info */
argument|procfs_kill_inferior,
comment|/* to_kill */
literal|0
argument|,
comment|/* to_load */
literal|0
argument|,
comment|/* to_lookup_symbol */
argument|procfs_create_inferior,
comment|/* to_create_inferior */
argument|procfs_mourn_inferior,
comment|/* to_mourn_inferior */
argument|procfs_can_run,
comment|/* to_can_run */
argument|procfs_notice_signals,
comment|/* to_notice_signals */
literal|0
argument|,
comment|/* to_thread_alive */
argument|procfs_stop,
comment|/* to_stop */
argument|process_stratum,
comment|/* to_stratum */
literal|0
argument|,
comment|/* to_next */
literal|1
argument|,
comment|/* to_has_all_memory */
literal|1
argument|,
comment|/* to_has_memory */
literal|1
argument|,
comment|/* to_has_stack */
literal|1
argument|,
comment|/* to_has_registers */
literal|1
argument|,
comment|/* to_has_execution */
literal|0
argument|,
comment|/* sections */
literal|0
argument|,
comment|/* sections_end */
argument|OPS_MAGIC
comment|/* to_magic */
argument|};  void _initialize_procfs () {
ifdef|#
directive|ifdef
name|HAVE_OPTIONAL_PROC_FS
argument|char procname[
literal|32
argument|];   int fd;
comment|/* If we have an optional /proc filesystem (e.g. under OSF/1),      don't add procfs support if we cannot access the running      GDB via /proc.  */
argument|sprintf (procname, PROC_NAME_FMT, getpid ());   if ((fd = open (procname, O_RDONLY))<
literal|0
argument|)     return;   close (fd);
endif|#
directive|endif
argument|add_target (&procfs_ops);    add_info (
literal|"proc"
argument|, info_proc,
literal|"Show process status information using /proc entry.\n\ Specify process id or use current inferior by default.\n\ Specify keywords for detailed information; default is summary.\n\ Keywords are: `all', `faults', `flags', `id', `mappings', `signals',\n\ `status', `syscalls', and `times'.\n\ Unambiguous abbreviations may be used."
argument|);    init_syscall_table (); }
end_function

end_unit

