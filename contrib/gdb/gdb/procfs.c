begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Machine independent support for SVR4 /proc (process file system) for GDB.    Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.    Written by Michael Snyder at Cygnus Solutions.    Based on work by Fred Fish, Stu Grossman, Geoff Noer, and others.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation,  Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"elf-bfd.h"
end_include

begin_comment
comment|/* for elfcore_write_* */
end_comment

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"gdbthread.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEW_PROC_API
argument_list|)
end_if

begin_define
define|#
directive|define
name|_STRUCTURED_PROC
value|1
end_define

begin_comment
comment|/* Should be done by configure script. */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/procfs.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_FAULT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/fault.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_SYSCALL_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_comment
comment|/*   * PROCFS.C  *  * This module provides the interface between GDB and the  * /proc file system, which is used on many versions of Unix  * as a means for debuggers to control other processes.  * Examples of the systems that use this interface are:  *   Irix  *   Solaris  *   OSF  *   Unixware  *   AIX5  *  * /proc works by imitating a file system: you open a simulated file  * that represents the process you wish to interact with, and  * perform operations on that "file" in order to examine or change  * the state of the other process.  *  * The most important thing to know about /proc and this module  * is that there are two very different interfaces to /proc:  *   One that uses the ioctl system call, and  *   another that uses read and write system calls.  * This module has to support both /proc interfaces.  This means  * that there are two different ways of doing every basic operation.  *  * In order to keep most of the code simple and clean, I have   * defined an interface "layer" which hides all these system calls.  * An ifdef (NEW_PROC_API) determines which interface we are using,  * and most or all occurrances of this ifdef should be confined to  * this interface layer.  */
end_comment

begin_comment
comment|/* Determine which /proc API we are using:    The ioctl API defines PIOCSTATUS, while     the read/write (multiple fd) API never does.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NEW_PROC_API
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"gdb_dirent.h"
end_include

begin_comment
comment|/* opendir/readdir, for listing the LWP's */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_comment
comment|/* for O_RDONLY */
end_comment

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/* for "X_OK" */
end_comment

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_comment
comment|/* for struct stat */
end_comment

begin_comment
comment|/* Note: procfs-utils.h must be included after the above system header    files, because it redefines various system calls using macros.    This may be incompatible with the prototype declarations.  */
end_comment

begin_include
include|#
directive|include
file|"proc-utils.h"
end_include

begin_comment
comment|/* Prototypes for supply_gregset etc. */
end_comment

begin_include
include|#
directive|include
file|"gregset.h"
end_include

begin_comment
comment|/* =================== TARGET_OPS "MODULE" =================== */
end_comment

begin_comment
comment|/*  * This module defines the GDB target vector and its methods.  */
end_comment

begin_function_decl
specifier|static
name|void
name|procfs_open
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|procfs_attach
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|procfs_detach
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|procfs_resume
parameter_list|(
name|ptid_t
parameter_list|,
name|int
parameter_list|,
name|enum
name|target_signal
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|procfs_can_run
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|procfs_stop
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|procfs_files_info
parameter_list|(
name|struct
name|target_ops
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|procfs_fetch_registers
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|procfs_store_registers
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|procfs_notice_signals
parameter_list|(
name|ptid_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|procfs_prepare_to_store
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|procfs_kill_inferior
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|procfs_mourn_inferior
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|procfs_create_inferior
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ptid_t
name|procfs_wait
parameter_list|(
name|ptid_t
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|procfs_xfer_memory
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|struct
name|mem_attrib
modifier|*
name|attrib
parameter_list|,
name|struct
name|target_ops
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|procfs_thread_alive
parameter_list|(
name|ptid_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|procfs_find_new_threads
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|procfs_pid_to_str
parameter_list|(
name|ptid_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|proc_find_memory_regions
parameter_list|(
name|int
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|unsigned
name|long
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|procfs_make_note_section
parameter_list|(
name|bfd
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|target_ops
name|procfs_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the target vector */
end_comment

begin_function
specifier|static
name|void
name|init_procfs_ops
parameter_list|(
name|void
parameter_list|)
block|{
name|procfs_ops
operator|.
name|to_shortname
operator|=
literal|"procfs"
expr_stmt|;
name|procfs_ops
operator|.
name|to_longname
operator|=
literal|"Unix /proc child process"
expr_stmt|;
name|procfs_ops
operator|.
name|to_doc
operator|=
literal|"Unix /proc child process (started by the \"run\" command)."
expr_stmt|;
name|procfs_ops
operator|.
name|to_open
operator|=
name|procfs_open
expr_stmt|;
name|procfs_ops
operator|.
name|to_can_run
operator|=
name|procfs_can_run
expr_stmt|;
name|procfs_ops
operator|.
name|to_create_inferior
operator|=
name|procfs_create_inferior
expr_stmt|;
name|procfs_ops
operator|.
name|to_kill
operator|=
name|procfs_kill_inferior
expr_stmt|;
name|procfs_ops
operator|.
name|to_mourn_inferior
operator|=
name|procfs_mourn_inferior
expr_stmt|;
name|procfs_ops
operator|.
name|to_attach
operator|=
name|procfs_attach
expr_stmt|;
name|procfs_ops
operator|.
name|to_detach
operator|=
name|procfs_detach
expr_stmt|;
name|procfs_ops
operator|.
name|to_wait
operator|=
name|procfs_wait
expr_stmt|;
name|procfs_ops
operator|.
name|to_resume
operator|=
name|procfs_resume
expr_stmt|;
name|procfs_ops
operator|.
name|to_prepare_to_store
operator|=
name|procfs_prepare_to_store
expr_stmt|;
name|procfs_ops
operator|.
name|to_fetch_registers
operator|=
name|procfs_fetch_registers
expr_stmt|;
name|procfs_ops
operator|.
name|to_store_registers
operator|=
name|procfs_store_registers
expr_stmt|;
name|procfs_ops
operator|.
name|to_xfer_memory
operator|=
name|procfs_xfer_memory
expr_stmt|;
name|procfs_ops
operator|.
name|to_insert_breakpoint
operator|=
name|memory_insert_breakpoint
expr_stmt|;
name|procfs_ops
operator|.
name|to_remove_breakpoint
operator|=
name|memory_remove_breakpoint
expr_stmt|;
name|procfs_ops
operator|.
name|to_notice_signals
operator|=
name|procfs_notice_signals
expr_stmt|;
name|procfs_ops
operator|.
name|to_files_info
operator|=
name|procfs_files_info
expr_stmt|;
name|procfs_ops
operator|.
name|to_stop
operator|=
name|procfs_stop
expr_stmt|;
name|procfs_ops
operator|.
name|to_terminal_init
operator|=
name|terminal_init_inferior
expr_stmt|;
name|procfs_ops
operator|.
name|to_terminal_inferior
operator|=
name|terminal_inferior
expr_stmt|;
name|procfs_ops
operator|.
name|to_terminal_ours_for_output
operator|=
name|terminal_ours_for_output
expr_stmt|;
name|procfs_ops
operator|.
name|to_terminal_ours
operator|=
name|terminal_ours
expr_stmt|;
name|procfs_ops
operator|.
name|to_terminal_info
operator|=
name|child_terminal_info
expr_stmt|;
name|procfs_ops
operator|.
name|to_find_new_threads
operator|=
name|procfs_find_new_threads
expr_stmt|;
name|procfs_ops
operator|.
name|to_thread_alive
operator|=
name|procfs_thread_alive
expr_stmt|;
name|procfs_ops
operator|.
name|to_pid_to_str
operator|=
name|procfs_pid_to_str
expr_stmt|;
name|procfs_ops
operator|.
name|to_has_all_memory
operator|=
literal|1
expr_stmt|;
name|procfs_ops
operator|.
name|to_has_memory
operator|=
literal|1
expr_stmt|;
name|procfs_ops
operator|.
name|to_has_execution
operator|=
literal|1
expr_stmt|;
name|procfs_ops
operator|.
name|to_has_stack
operator|=
literal|1
expr_stmt|;
name|procfs_ops
operator|.
name|to_has_registers
operator|=
literal|1
expr_stmt|;
name|procfs_ops
operator|.
name|to_stratum
operator|=
name|process_stratum
expr_stmt|;
name|procfs_ops
operator|.
name|to_has_thread_control
operator|=
name|tc_schedlock
expr_stmt|;
name|procfs_ops
operator|.
name|to_find_memory_regions
operator|=
name|proc_find_memory_regions
expr_stmt|;
name|procfs_ops
operator|.
name|to_make_corefile_notes
operator|=
name|procfs_make_note_section
expr_stmt|;
name|procfs_ops
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =================== END, TARGET_OPS "MODULE" =================== */
end_comment

begin_comment
comment|/*  * World Unification:  *  * Put any typedefs, defines etc. here that are required for  * the unification of code that handles different versions of /proc.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NEW_PROC_API
end_ifdef

begin_comment
comment|/* Solaris 7&& 8 method for watchpoints */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|WA_READ
end_ifdef

begin_enum
enum|enum
block|{
name|READ_WATCHFLAG
init|=
name|WA_READ
block|,
name|WRITE_WATCHFLAG
init|=
name|WA_WRITE
block|,
name|EXEC_WATCHFLAG
init|=
name|WA_EXEC
block|,
name|AFTER_WATCHFLAG
init|=
name|WA_TRAPAFTER
block|}
enum|;
end_enum

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Irix method for watchpoints */
end_comment

begin_enum
enum|enum
block|{
name|READ_WATCHFLAG
init|=
name|MA_READ
block|,
name|WRITE_WATCHFLAG
init|=
name|MA_WRITE
block|,
name|EXEC_WATCHFLAG
init|=
name|MA_EXEC
block|,
name|AFTER_WATCHFLAG
init|=
literal|0
comment|/* trapafter not implemented */
block|}
enum|;
end_enum

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* gdb_sigset_t */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PR_SIGSET_T
end_ifdef

begin_typedef
typedef|typedef
name|pr_sigset_t
name|gdb_sigset_t
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|sigset_t
name|gdb_sigset_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* sigaction */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PR_SIGACTION64_T
end_ifdef

begin_typedef
typedef|typedef
name|pr_sigaction64_t
name|gdb_sigaction_t
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|struct
name|sigaction
name|gdb_sigaction_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* siginfo */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PR_SIGINFO64_T
end_ifdef

begin_typedef
typedef|typedef
name|pr_siginfo64_t
name|gdb_siginfo_t
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|struct
name|siginfo
name|gdb_siginfo_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* gdb_premptysysset */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|premptysysset
end_ifdef

begin_define
define|#
directive|define
name|gdb_premptysysset
value|premptysysset
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|gdb_premptysysset
value|premptyset
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* praddsysset */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|praddsysset
end_ifdef

begin_define
define|#
directive|define
name|gdb_praddsysset
value|praddsysset
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|gdb_praddsysset
value|praddset
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* prdelsysset */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|prdelsysset
end_ifdef

begin_define
define|#
directive|define
name|gdb_prdelsysset
value|prdelsysset
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|gdb_prdelsysset
value|prdelset
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* prissyssetmember */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|prissyssetmember
end_ifdef

begin_define
define|#
directive|define
name|gdb_pr_issyssetmember
value|prissyssetmember
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|gdb_pr_issyssetmember
value|prismember
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* As a feature test, saying ``#if HAVE_PRSYSENT_T'' everywhere isn't    as intuitively descriptive as it could be, so we'll define    DYNAMIC_SYSCALLS to mean the same thing.  Anyway, at the time of    this writing, this feature is only found on AIX5 systems and    basically means that the set of syscalls is not fixed.  I.e,    there's no nice table that one can #include to get all of the    syscall numbers.  Instead, they're stored in /proc/PID/sysent    for each process.  We are at least guaranteed that they won't    change over the lifetime of the process.  But each process could    (in theory) have different syscall numbers. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PRSYSENT_T
end_ifdef

begin_define
define|#
directive|define
name|DYNAMIC_SYSCALLS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* =================== STRUCT PROCINFO "MODULE" =================== */
end_comment

begin_comment
comment|/* FIXME: this comment will soon be out of date W.R.T. threads.  */
end_comment

begin_comment
comment|/* The procinfo struct is a wrapper to hold all the state information    concerning a /proc process.  There should be exactly one procinfo    for each process, and since GDB currently can debug only one    process at a time, that means there should be only one procinfo.    All of the LWP's of a process can be accessed indirectly thru the    single process procinfo.     However, against the day when GDB may debug more than one process,    this data structure is kept in a list (which for now will hold no    more than one member), and many functions will have a pointer to a    procinfo as an argument.     There will be a separate procinfo structure for use by the (not yet    implemented) "info proc" command, so that we can print useful    information about any random process without interfering with the    inferior's procinfo information. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NEW_PROC_API
end_ifdef

begin_comment
comment|/* format strings for /proc paths */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CTL_PROC_NAME_FMT
end_ifndef

begin_define
define|#
directive|define
name|MAIN_PROC_NAME_FMT
value|"/proc/%d"
end_define

begin_define
define|#
directive|define
name|CTL_PROC_NAME_FMT
value|"/proc/%d/ctl"
end_define

begin_define
define|#
directive|define
name|AS_PROC_NAME_FMT
value|"/proc/%d/as"
end_define

begin_define
define|#
directive|define
name|MAP_PROC_NAME_FMT
value|"/proc/%d/map"
end_define

begin_define
define|#
directive|define
name|STATUS_PROC_NAME_FMT
value|"/proc/%d/status"
end_define

begin_define
define|#
directive|define
name|MAX_PROC_NAME_SIZE
value|sizeof("/proc/99999/lwp/8096/lstatus")
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* the name of the proc status struct depends on the implementation */
end_comment

begin_typedef
typedef|typedef
name|pstatus_t
name|gdb_prstatus_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|lwpstatus_t
name|gdb_lwpstatus_t
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! NEW_PROC_API */
end_comment

begin_comment
comment|/* format strings for /proc paths */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CTL_PROC_NAME_FMT
end_ifndef

begin_define
define|#
directive|define
name|MAIN_PROC_NAME_FMT
value|"/proc/%05d"
end_define

begin_define
define|#
directive|define
name|CTL_PROC_NAME_FMT
value|"/proc/%05d"
end_define

begin_define
define|#
directive|define
name|AS_PROC_NAME_FMT
value|"/proc/%05d"
end_define

begin_define
define|#
directive|define
name|MAP_PROC_NAME_FMT
value|"/proc/%05d"
end_define

begin_define
define|#
directive|define
name|STATUS_PROC_NAME_FMT
value|"/proc/%05d"
end_define

begin_define
define|#
directive|define
name|MAX_PROC_NAME_SIZE
value|sizeof("/proc/ttttppppp")
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* the name of the proc status struct depends on the implementation */
end_comment

begin_typedef
typedef|typedef
name|prstatus_t
name|gdb_prstatus_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|prstatus_t
name|gdb_lwpstatus_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NEW_PROC_API */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|procinfo
block|{
name|struct
name|procinfo
modifier|*
name|next
decl_stmt|;
name|int
name|pid
decl_stmt|;
comment|/* Process ID    */
name|int
name|tid
decl_stmt|;
comment|/* Thread/LWP id */
comment|/* process state */
name|int
name|was_stopped
decl_stmt|;
name|int
name|ignore_next_sigstop
decl_stmt|;
comment|/* The following four fd fields may be identical, or may contain       several different fd's, depending on the version of /proc      (old ioctl or new read/write).  */
name|int
name|ctl_fd
decl_stmt|;
comment|/* File descriptor for /proc control file */
comment|/*    * The next three file descriptors are actually only needed in the    * read/write, multiple-file-descriptor implemenation (NEW_PROC_API).    * However, to avoid a bunch of #ifdefs in the code, we will use     * them uniformly by (in the case of the ioctl single-file-descriptor    * implementation) filling them with copies of the control fd.    */
name|int
name|status_fd
decl_stmt|;
comment|/* File descriptor for /proc status file */
name|int
name|as_fd
decl_stmt|;
comment|/* File descriptor for /proc as file */
name|char
name|pathname
index|[
name|MAX_PROC_NAME_SIZE
index|]
decl_stmt|;
comment|/* Pathname to /proc entry */
name|fltset_t
name|saved_fltset
decl_stmt|;
comment|/* Saved traced hardware fault set */
name|gdb_sigset_t
name|saved_sigset
decl_stmt|;
comment|/* Saved traced signal set */
name|gdb_sigset_t
name|saved_sighold
decl_stmt|;
comment|/* Saved held signal set */
name|sysset_t
modifier|*
name|saved_exitset
decl_stmt|;
comment|/* Saved traced system call exit set */
name|sysset_t
modifier|*
name|saved_entryset
decl_stmt|;
comment|/* Saved traced system call entry set */
name|gdb_prstatus_t
name|prstatus
decl_stmt|;
comment|/* Current process status info */
ifndef|#
directive|ifndef
name|NEW_PROC_API
name|gdb_fpregset_t
name|fpregset
decl_stmt|;
comment|/* Current floating point registers */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DYNAMIC_SYSCALLS
name|int
name|num_syscalls
decl_stmt|;
comment|/* Total number of syscalls */
name|char
modifier|*
modifier|*
name|syscall_names
decl_stmt|;
comment|/* Syscall number to name map */
endif|#
directive|endif
name|struct
name|procinfo
modifier|*
name|thread_list
decl_stmt|;
name|int
name|status_valid
range|:
literal|1
decl_stmt|;
name|int
name|gregs_valid
range|:
literal|1
decl_stmt|;
name|int
name|fpregs_valid
range|:
literal|1
decl_stmt|;
name|int
name|threads_valid
range|:
literal|1
decl_stmt|;
block|}
name|procinfo
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|char
name|errmsg
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* shared error msg buffer */
end_comment

begin_comment
comment|/* Function prototypes for procinfo module: */
end_comment

begin_function_decl
specifier|static
name|procinfo
modifier|*
name|find_procinfo_or_die
parameter_list|(
name|int
name|pid
parameter_list|,
name|int
name|tid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|procinfo
modifier|*
name|find_procinfo
parameter_list|(
name|int
name|pid
parameter_list|,
name|int
name|tid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|procinfo
modifier|*
name|create_procinfo
parameter_list|(
name|int
name|pid
parameter_list|,
name|int
name|tid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|destroy_procinfo
parameter_list|(
name|procinfo
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_destroy_procinfo_cleanup
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dead_procinfo
parameter_list|(
name|procinfo
modifier|*
name|p
parameter_list|,
name|char
modifier|*
name|msg
parameter_list|,
name|int
name|killp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|open_procinfo_files
parameter_list|(
name|procinfo
modifier|*
name|p
parameter_list|,
name|int
name|which
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|close_procinfo_files
parameter_list|(
name|procinfo
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysset_t_size
parameter_list|(
name|procinfo
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|sysset_t
modifier|*
name|sysset_t_alloc
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DYNAMIC_SYSCALLS
end_ifdef

begin_function_decl
specifier|static
name|void
name|load_syscalls
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_syscalls
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|find_syscall
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DYNAMIC_SYSCALLS */
end_comment

begin_comment
comment|/* The head of the procinfo list: */
end_comment

begin_decl_stmt
specifier|static
name|procinfo
modifier|*
name|procinfo_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Function: find_procinfo  *  * Search the procinfo list.  *  * Returns: pointer to procinfo, or NULL if not found.  */
end_comment

begin_function
specifier|static
name|procinfo
modifier|*
name|find_procinfo
parameter_list|(
name|int
name|pid
parameter_list|,
name|int
name|tid
parameter_list|)
block|{
name|procinfo
modifier|*
name|pi
decl_stmt|;
for|for
control|(
name|pi
operator|=
name|procinfo_list
init|;
name|pi
condition|;
name|pi
operator|=
name|pi
operator|->
name|next
control|)
if|if
condition|(
name|pi
operator|->
name|pid
operator|==
name|pid
condition|)
break|break;
if|if
condition|(
name|pi
condition|)
if|if
condition|(
name|tid
condition|)
block|{
comment|/* Don't check threads_valid.  If we're updating the 	   thread_list, we want to find whatever threads are already 	   here.  This means that in general it is the caller's 	   responsibility to check threads_valid and update before 	   calling find_procinfo, if the caller wants to find a new 	   thread. */
for|for
control|(
name|pi
operator|=
name|pi
operator|->
name|thread_list
init|;
name|pi
condition|;
name|pi
operator|=
name|pi
operator|->
name|next
control|)
if|if
condition|(
name|pi
operator|->
name|tid
operator|==
name|tid
condition|)
break|break;
block|}
return|return
name|pi
return|;
block|}
end_function

begin_comment
comment|/*  * Function: find_procinfo_or_die  *  * Calls find_procinfo, but errors on failure.  */
end_comment

begin_function
specifier|static
name|procinfo
modifier|*
name|find_procinfo_or_die
parameter_list|(
name|int
name|pid
parameter_list|,
name|int
name|tid
parameter_list|)
block|{
name|procinfo
modifier|*
name|pi
init|=
name|find_procinfo
argument_list|(
name|pid
argument_list|,
name|tid
argument_list|)
decl_stmt|;
if|if
condition|(
name|pi
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|tid
condition|)
name|error
argument_list|(
literal|"procfs: couldn't find pid %d (kernel thread %d) in procinfo list."
argument_list|,
name|pid
argument_list|,
name|tid
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"procfs: couldn't find pid %d in procinfo list."
argument_list|,
name|pid
argument_list|)
expr_stmt|;
block|}
return|return
name|pi
return|;
block|}
end_function

begin_comment
comment|/* open_with_retry() is a wrapper for open().  The appropriate    open() call is attempted; if unsuccessful, it will be retried as    many times as needed for the EAGAIN and EINTR conditions.        For other conditions, open_with_retry() will retry the open() a    limited number of times.  In addition, a short sleep is imposed    prior to retrying the open().  The reason for this sleep is to give    the kernel a chance to catch up and create the file in question in    the event that GDB "wins" the race to open a file before the kernel    has created it.  */
end_comment

begin_function
specifier|static
name|int
name|open_with_retry
parameter_list|(
specifier|const
name|char
modifier|*
name|pathname
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|retries_remaining
decl_stmt|,
name|status
decl_stmt|;
name|retries_remaining
operator|=
literal|2
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|status
operator|=
name|open
argument_list|(
name|pathname
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|>=
literal|0
operator|||
name|retries_remaining
operator|==
literal|0
condition|)
break|break;
elseif|else
if|if
condition|(
name|errno
operator|!=
name|EINTR
operator|&&
name|errno
operator|!=
name|EAGAIN
condition|)
block|{
name|retries_remaining
operator|--
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/*  * Function: open_procinfo_files  *  * Open the file descriptor for the process or LWP.  * ifdef NEW_PROC_API, we only open the control file descriptor;  * the others are opened lazily as needed.  * else (if not NEW_PROC_API), there is only one real  * file descriptor, but we keep multiple copies of it so that  * the code that uses them does not have to be #ifdef'd.  *  * Return: file descriptor, or zero for failure.  */
end_comment

begin_enum
enum|enum
block|{
name|FD_CTL
block|,
name|FD_STATUS
block|,
name|FD_AS
block|}
enum|;
end_enum

begin_function
specifier|static
name|int
name|open_procinfo_files
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|int
name|which
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|NEW_PROC_API
name|char
name|tmp
index|[
name|MAX_PROC_NAME_SIZE
index|]
decl_stmt|;
endif|#
directive|endif
name|int
name|fd
decl_stmt|;
comment|/*     * This function is getting ALMOST long enough to break up into several.    * Here is some rationale:    *    * NEW_PROC_API (Solaris 2.6, Solaris 2.7, Unixware):    *   There are several file descriptors that may need to be open     *   for any given process or LWP.  The ones we're intereted in are:    *     - control	 (ctl)	  write-only	change the state    *     - status	 (status) read-only	query the state    *     - address space (as)     read/write	access memory    *     - map           (map)    read-only     virtual addr map    *   Most of these are opened lazily as they are needed.    *   The pathnames for the 'files' for an LWP look slightly     *   different from those of a first-class process:    *     Pathnames for a process (<proc-id>):    *       /proc/<proc-id>/ctl    *       /proc/<proc-id>/status    *       /proc/<proc-id>/as    *       /proc/<proc-id>/map    *     Pathnames for an LWP (lwp-id):    *       /proc/<proc-id>/lwp/<lwp-id>/lwpctl    *       /proc/<proc-id>/lwp/<lwp-id>/lwpstatus    *   An LWP has no map or address space file descriptor, since    *   the memory map and address space are shared by all LWPs.    *    * Everyone else (Solaris 2.5, Irix, OSF)    *   There is only one file descriptor for each process or LWP.    *   For convenience, we copy the same file descriptor into all    *   three fields of the procinfo struct (ctl_fd, status_fd, and    *   as_fd, see NEW_PROC_API above) so that code that uses them    *   doesn't need any #ifdef's.      *     Pathname for all:    *       /proc/<proc-id>    *    *   Solaris 2.5 LWP's:    *     Each LWP has an independent file descriptor, but these     *     are not obtained via the 'open' system call like the rest:    *     instead, they're obtained thru an ioctl call (PIOCOPENLWP)    *     to the file descriptor of the parent process.    *    *   OSF threads:    *     These do not even have their own independent file descriptor.    *     All operations are carried out on the file descriptor of the    *     parent process.  Therefore we just call open again for each    *     thread, getting a new handle for the same 'file'.    */
ifdef|#
directive|ifdef
name|NEW_PROC_API
comment|/*    * In this case, there are several different file descriptors that    * we might be asked to open.  The control file descriptor will be    * opened early, but the others will be opened lazily as they are    * needed.    */
name|strcpy
argument_list|(
name|tmp
argument_list|,
name|pi
operator|->
name|pathname
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
comment|/* which file descriptor to open? */
case|case
name|FD_CTL
case|:
if|if
condition|(
name|pi
operator|->
name|tid
condition|)
name|strcat
argument_list|(
name|tmp
argument_list|,
literal|"/lwpctl"
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|tmp
argument_list|,
literal|"/ctl"
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open_with_retry
argument_list|(
name|tmp
argument_list|,
name|O_WRONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* fail */
name|pi
operator|->
name|ctl_fd
operator|=
name|fd
expr_stmt|;
break|break;
case|case
name|FD_AS
case|:
if|if
condition|(
name|pi
operator|->
name|tid
condition|)
return|return
literal|0
return|;
comment|/* there is no 'as' file descriptor for an lwp */
name|strcat
argument_list|(
name|tmp
argument_list|,
literal|"/as"
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open_with_retry
argument_list|(
name|tmp
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* fail */
name|pi
operator|->
name|as_fd
operator|=
name|fd
expr_stmt|;
break|break;
case|case
name|FD_STATUS
case|:
if|if
condition|(
name|pi
operator|->
name|tid
condition|)
name|strcat
argument_list|(
name|tmp
argument_list|,
literal|"/lwpstatus"
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|tmp
argument_list|,
literal|"/status"
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open_with_retry
argument_list|(
name|tmp
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* fail */
name|pi
operator|->
name|status_fd
operator|=
name|fd
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
comment|/* unknown file descriptor */
block|}
else|#
directive|else
comment|/* not NEW_PROC_API */
comment|/*    * In this case, there is only one file descriptor for each procinfo    * (ie. each process or LWP).  In fact, only the file descriptor for    * the process can actually be opened by an 'open' system call.    * The ones for the LWPs have to be obtained thru an IOCTL call     * on the process's file descriptor.     *    * For convenience, we copy each procinfo's single file descriptor    * into all of the fields occupied by the several file descriptors     * of the NEW_PROC_API implementation.  That way, the code that uses    * them can be written without ifdefs.    */
ifdef|#
directive|ifdef
name|PIOCTSTATUS
comment|/* OSF */
comment|/* Only one FD; just open it. */
if|if
condition|(
operator|(
name|fd
operator|=
name|open_with_retry
argument_list|(
name|pi
operator|->
name|pathname
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
else|#
directive|else
comment|/* Sol 2.5, Irix, other? */
if|if
condition|(
name|pi
operator|->
name|tid
operator|==
literal|0
condition|)
comment|/* Master procinfo for the process */
block|{
name|fd
operator|=
name|open_with_retry
argument_list|(
name|pi
operator|->
name|pathname
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* fail */
block|}
else|else
comment|/* LWP thread procinfo */
block|{
ifdef|#
directive|ifdef
name|PIOCOPENLWP
comment|/* Sol 2.5, thread/LWP */
name|procinfo
modifier|*
name|process
decl_stmt|;
name|int
name|lwpid
init|=
name|pi
operator|->
name|tid
decl_stmt|;
comment|/* Find the procinfo for the entire process. */
if|if
condition|(
operator|(
name|process
operator|=
name|find_procinfo
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* fail */
comment|/* Now obtain the file descriptor for the LWP. */
if|if
condition|(
operator|(
name|fd
operator|=
name|ioctl
argument_list|(
name|process
operator|->
name|ctl_fd
argument_list|,
name|PIOCOPENLWP
argument_list|,
operator|&
name|lwpid
argument_list|)
operator|)
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
comment|/* fail */
else|#
directive|else
comment|/* Irix, other? */
return|return
literal|0
return|;
comment|/* Don't know how to open threads */
endif|#
directive|endif
comment|/* Sol 2.5 PIOCOPENLWP */
block|}
endif|#
directive|endif
comment|/* OSF     PIOCTSTATUS */
name|pi
operator|->
name|ctl_fd
operator|=
name|pi
operator|->
name|as_fd
operator|=
name|pi
operator|->
name|status_fd
operator|=
name|fd
expr_stmt|;
endif|#
directive|endif
comment|/* NEW_PROC_API */
return|return
literal|1
return|;
comment|/* success */
block|}
end_function

begin_comment
comment|/*  * Function: create_procinfo  *  * Allocate a data structure and link it into the procinfo list.  * (First tries to find a pre-existing one (FIXME: why?)  *  * Return: pointer to new procinfo struct.  */
end_comment

begin_function
specifier|static
name|procinfo
modifier|*
name|create_procinfo
parameter_list|(
name|int
name|pid
parameter_list|,
name|int
name|tid
parameter_list|)
block|{
name|procinfo
modifier|*
name|pi
decl_stmt|,
modifier|*
name|parent
decl_stmt|;
if|if
condition|(
operator|(
name|pi
operator|=
name|find_procinfo
argument_list|(
name|pid
argument_list|,
name|tid
argument_list|)
operator|)
condition|)
return|return
name|pi
return|;
comment|/* Already exists, nothing to do. */
comment|/* find parent before doing malloc, to save having to cleanup */
if|if
condition|(
name|tid
operator|!=
literal|0
condition|)
name|parent
operator|=
name|find_procinfo_or_die
argument_list|(
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FIXME: should I 						   create it if it 						   doesn't exist yet? */
name|pi
operator|=
operator|(
name|procinfo
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|procinfo
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|pi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|procinfo
argument_list|)
argument_list|)
expr_stmt|;
name|pi
operator|->
name|pid
operator|=
name|pid
expr_stmt|;
name|pi
operator|->
name|tid
operator|=
name|tid
expr_stmt|;
ifdef|#
directive|ifdef
name|DYNAMIC_SYSCALLS
name|load_syscalls
argument_list|(
name|pi
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pi
operator|->
name|saved_entryset
operator|=
name|sysset_t_alloc
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|pi
operator|->
name|saved_exitset
operator|=
name|sysset_t_alloc
argument_list|(
name|pi
argument_list|)
expr_stmt|;
comment|/* Chain into list.  */
if|if
condition|(
name|tid
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|pi
operator|->
name|pathname
argument_list|,
name|MAIN_PROC_NAME_FMT
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|pi
operator|->
name|next
operator|=
name|procinfo_list
expr_stmt|;
name|procinfo_list
operator|=
name|pi
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|NEW_PROC_API
name|sprintf
argument_list|(
name|pi
operator|->
name|pathname
argument_list|,
literal|"/proc/%05d/lwp/%d"
argument_list|,
name|pid
argument_list|,
name|tid
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|pi
operator|->
name|pathname
argument_list|,
name|MAIN_PROC_NAME_FMT
argument_list|,
name|pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pi
operator|->
name|next
operator|=
name|parent
operator|->
name|thread_list
expr_stmt|;
name|parent
operator|->
name|thread_list
operator|=
name|pi
expr_stmt|;
block|}
return|return
name|pi
return|;
block|}
end_function

begin_comment
comment|/*  * Function: close_procinfo_files  *  * Close all file descriptors associated with the procinfo  */
end_comment

begin_function
specifier|static
name|void
name|close_procinfo_files
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
if|if
condition|(
name|pi
operator|->
name|ctl_fd
operator|>
literal|0
condition|)
name|close
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NEW_PROC_API
if|if
condition|(
name|pi
operator|->
name|as_fd
operator|>
literal|0
condition|)
name|close
argument_list|(
name|pi
operator|->
name|as_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|status_fd
operator|>
literal|0
condition|)
name|close
argument_list|(
name|pi
operator|->
name|status_fd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pi
operator|->
name|ctl_fd
operator|=
name|pi
operator|->
name|as_fd
operator|=
name|pi
operator|->
name|status_fd
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function: destroy_procinfo  *  * Destructor function.  Close, unlink and deallocate the object.  */
end_comment

begin_function
specifier|static
name|void
name|destroy_one_procinfo
parameter_list|(
name|procinfo
modifier|*
modifier|*
name|list
parameter_list|,
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
name|procinfo
modifier|*
name|ptr
decl_stmt|;
comment|/* Step one: unlink the procinfo from its list */
if|if
condition|(
name|pi
operator|==
operator|*
name|list
condition|)
operator|*
name|list
operator|=
name|pi
operator|->
name|next
expr_stmt|;
else|else
for|for
control|(
name|ptr
operator|=
operator|*
name|list
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
if|if
condition|(
name|ptr
operator|->
name|next
operator|==
name|pi
condition|)
block|{
name|ptr
operator|->
name|next
operator|=
name|pi
operator|->
name|next
expr_stmt|;
break|break;
block|}
comment|/* Step two: close any open file descriptors */
name|close_procinfo_files
argument_list|(
name|pi
argument_list|)
expr_stmt|;
comment|/* Step three: free the memory. */
ifdef|#
directive|ifdef
name|DYNAMIC_SYSCALLS
name|free_syscalls
argument_list|(
name|pi
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|xfree
argument_list|(
name|pi
operator|->
name|saved_entryset
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|pi
operator|->
name|saved_exitset
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|pi
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|destroy_procinfo
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
name|procinfo
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|pi
operator|->
name|tid
operator|!=
literal|0
condition|)
comment|/* destroy a thread procinfo */
block|{
name|tmp
operator|=
name|find_procinfo
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* find the parent process */
name|destroy_one_procinfo
argument_list|(
operator|&
name|tmp
operator|->
name|thread_list
argument_list|,
name|pi
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* destroy a process procinfo and all its threads */
block|{
comment|/* First destroy the children, if any; */
while|while
condition|(
name|pi
operator|->
name|thread_list
operator|!=
name|NULL
condition|)
name|destroy_one_procinfo
argument_list|(
operator|&
name|pi
operator|->
name|thread_list
argument_list|,
name|pi
operator|->
name|thread_list
argument_list|)
expr_stmt|;
comment|/* Then destroy the parent.  Genocide!!!  */
name|destroy_one_procinfo
argument_list|(
operator|&
name|procinfo_list
argument_list|,
name|pi
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|do_destroy_procinfo_cleanup
parameter_list|(
name|void
modifier|*
name|pi
parameter_list|)
block|{
name|destroy_procinfo
argument_list|(
name|pi
argument_list|)
expr_stmt|;
block|}
end_function

begin_enum
enum|enum
block|{
name|NOKILL
block|,
name|KILL
block|}
enum|;
end_enum

begin_comment
comment|/*  * Function: dead_procinfo  *  * To be called on a non_recoverable error for a procinfo.  * Prints error messages, optionally sends a SIGKILL to the process,  * then destroys the data structure.  */
end_comment

begin_function
specifier|static
name|void
name|dead_procinfo
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|char
modifier|*
name|msg
parameter_list|,
name|int
name|kill_p
parameter_list|)
block|{
name|char
name|procfile
index|[
literal|80
index|]
decl_stmt|;
if|if
condition|(
name|pi
operator|->
name|pathname
condition|)
block|{
name|print_sys_errmsg
argument_list|(
name|pi
operator|->
name|pathname
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|procfile
argument_list|,
literal|"process %d"
argument_list|,
name|pi
operator|->
name|pid
argument_list|)
expr_stmt|;
name|print_sys_errmsg
argument_list|(
name|procfile
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kill_p
operator|==
name|KILL
condition|)
name|kill
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
name|destroy_procinfo
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function: sysset_t_size  *  * Returns the (complete) size of a sysset_t struct.  Normally, this  * is just sizeof (syset_t), but in the case of Monterey/64, the actual  * size of sysset_t isn't known until runtime.  */
end_comment

begin_function
specifier|static
name|int
name|sysset_t_size
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|DYNAMIC_SYSCALLS
return|return
sizeof|sizeof
argument_list|(
name|sysset_t
argument_list|)
return|;
else|#
directive|else
return|return
sizeof|sizeof
argument_list|(
name|sysset_t
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|*
operator|(
operator|(
name|pi
operator|->
name|num_syscalls
operator|+
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|/
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|)
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Function: sysset_t_alloc       Allocate and (partially) initialize a sysset_t struct.  */
end_comment

begin_function
specifier|static
name|sysset_t
modifier|*
name|sysset_t_alloc
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
name|sysset_t
modifier|*
name|ret
decl_stmt|;
name|int
name|size
init|=
name|sysset_t_size
argument_list|(
name|pi
argument_list|)
decl_stmt|;
name|ret
operator|=
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DYNAMIC_SYSCALLS
name|ret
operator|->
name|pr_size
operator|=
operator|(
name|pi
operator|->
name|num_syscalls
operator|+
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|/
operator|(
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ret
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DYNAMIC_SYSCALLS
end_ifdef

begin_comment
comment|/* Function: load_syscalls       Extract syscall numbers and names from /proc/<pid>/sysent.  Initialize    pi->num_syscalls with the number of syscalls and pi->syscall_names    with the names.  (Certain numbers may be skipped in which case the    names for these numbers will be left as NULL.) */
end_comment

begin_define
define|#
directive|define
name|MAX_SYSCALL_NAME_LENGTH
value|256
end_define

begin_define
define|#
directive|define
name|MAX_SYSCALLS
value|65536
end_define

begin_function
specifier|static
name|void
name|load_syscalls
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
name|char
name|pathname
index|[
name|MAX_PROC_NAME_SIZE
index|]
decl_stmt|;
name|int
name|sysent_fd
decl_stmt|;
name|prsysent_t
name|header
decl_stmt|;
name|prsyscall_t
modifier|*
name|syscalls
decl_stmt|;
name|int
name|i
decl_stmt|,
name|size
decl_stmt|,
name|maxcall
decl_stmt|;
name|pi
operator|->
name|num_syscalls
operator|=
literal|0
expr_stmt|;
name|pi
operator|->
name|syscall_names
operator|=
literal|0
expr_stmt|;
comment|/* Open the file descriptor for the sysent file */
name|sprintf
argument_list|(
name|pathname
argument_list|,
literal|"/proc/%d/sysent"
argument_list|,
name|pi
operator|->
name|pid
argument_list|)
expr_stmt|;
name|sysent_fd
operator|=
name|open_with_retry
argument_list|(
name|pathname
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysent_fd
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"load_syscalls: Can't open /proc/%d/sysent"
argument_list|,
name|pi
operator|->
name|pid
argument_list|)
expr_stmt|;
block|}
name|size
operator|=
sizeof|sizeof
name|header
operator|-
sizeof|sizeof
argument_list|(
name|prsyscall_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|sysent_fd
argument_list|,
operator|&
name|header
argument_list|,
name|size
argument_list|)
operator|!=
name|size
condition|)
block|{
name|error
argument_list|(
literal|"load_syscalls: Error reading /proc/%d/sysent"
argument_list|,
name|pi
operator|->
name|pid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|header
operator|.
name|pr_nsyscalls
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"load_syscalls: /proc/%d/sysent contains no syscalls!"
argument_list|,
name|pi
operator|->
name|pid
argument_list|)
expr_stmt|;
block|}
name|size
operator|=
name|header
operator|.
name|pr_nsyscalls
operator|*
sizeof|sizeof
argument_list|(
name|prsyscall_t
argument_list|)
expr_stmt|;
name|syscalls
operator|=
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|sysent_fd
argument_list|,
name|syscalls
argument_list|,
name|size
argument_list|)
operator|!=
name|size
condition|)
block|{
name|xfree
argument_list|(
name|syscalls
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"load_syscalls: Error reading /proc/%d/sysent"
argument_list|,
name|pi
operator|->
name|pid
argument_list|)
expr_stmt|;
block|}
comment|/* Find maximum syscall number.  This may not be the same as      pr_nsyscalls since that value refers to the number of entries      in the table.  (Also, the docs indicate that some system      call numbers may be skipped.) */
name|maxcall
operator|=
name|syscalls
index|[
literal|0
index|]
operator|.
name|pr_number
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|header
operator|.
name|pr_nsyscalls
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|syscalls
index|[
name|i
index|]
operator|.
name|pr_number
operator|>
name|maxcall
operator|&&
name|syscalls
index|[
name|i
index|]
operator|.
name|pr_nameoff
operator|>
literal|0
operator|&&
name|syscalls
index|[
name|i
index|]
operator|.
name|pr_number
operator|<
name|MAX_SYSCALLS
condition|)
name|maxcall
operator|=
name|syscalls
index|[
name|i
index|]
operator|.
name|pr_number
expr_stmt|;
name|pi
operator|->
name|num_syscalls
operator|=
name|maxcall
operator|+
literal|1
expr_stmt|;
name|pi
operator|->
name|syscall_names
operator|=
name|xmalloc
argument_list|(
name|pi
operator|->
name|num_syscalls
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pi
operator|->
name|num_syscalls
condition|;
name|i
operator|++
control|)
name|pi
operator|->
name|syscall_names
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Read the syscall names in */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|header
operator|.
name|pr_nsyscalls
condition|;
name|i
operator|++
control|)
block|{
name|char
name|namebuf
index|[
name|MAX_SYSCALL_NAME_LENGTH
index|]
decl_stmt|;
name|int
name|nread
decl_stmt|;
name|int
name|callnum
decl_stmt|;
if|if
condition|(
name|syscalls
index|[
name|i
index|]
operator|.
name|pr_number
operator|>=
name|MAX_SYSCALLS
operator|||
name|syscalls
index|[
name|i
index|]
operator|.
name|pr_number
operator|<
literal|0
operator|||
name|syscalls
index|[
name|i
index|]
operator|.
name|pr_nameoff
operator|<=
literal|0
operator|||
operator|(
name|lseek
argument_list|(
name|sysent_fd
argument_list|,
operator|(
name|off_t
operator|)
name|syscalls
index|[
name|i
index|]
operator|.
name|pr_nameoff
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
operator|(
name|off_t
operator|)
name|syscalls
index|[
name|i
index|]
operator|.
name|pr_nameoff
operator|)
condition|)
continue|continue;
name|nread
operator|=
name|read
argument_list|(
name|sysent_fd
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
name|namebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|<=
literal|0
condition|)
continue|continue;
name|callnum
operator|=
name|syscalls
index|[
name|i
index|]
operator|.
name|pr_number
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|syscall_names
index|[
name|callnum
index|]
operator|!=
name|NULL
condition|)
block|{
comment|/* FIXME: Generate warning */
continue|continue;
block|}
name|namebuf
index|[
name|nread
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|size
operator|=
name|strlen
argument_list|(
name|namebuf
argument_list|)
operator|+
literal|1
expr_stmt|;
name|pi
operator|->
name|syscall_names
index|[
name|callnum
index|]
operator|=
name|xmalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|pi
operator|->
name|syscall_names
index|[
name|callnum
index|]
argument_list|,
name|namebuf
argument_list|,
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pi
operator|->
name|syscall_names
index|[
name|callnum
index|]
index|[
name|size
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|close
argument_list|(
name|sysent_fd
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|syscalls
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function: free_syscalls        Free the space allocated for the syscall names from the procinfo    structure.  */
end_comment

begin_function
specifier|static
name|void
name|free_syscalls
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
if|if
condition|(
name|pi
operator|->
name|syscall_names
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pi
operator|->
name|num_syscalls
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pi
operator|->
name|syscall_names
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|xfree
argument_list|(
name|pi
operator|->
name|syscall_names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|pi
operator|->
name|syscall_names
argument_list|)
expr_stmt|;
name|pi
operator|->
name|syscall_names
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Function: find_syscall     Given a name, look up (and return) the corresponding syscall number.    If no match is found, return -1.  */
end_comment

begin_function
specifier|static
name|int
name|find_syscall
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pi
operator|->
name|num_syscalls
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pi
operator|->
name|syscall_names
index|[
name|i
index|]
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|pi
operator|->
name|syscall_names
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
return|return
name|i
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* =================== END, STRUCT PROCINFO "MODULE" =================== */
end_comment

begin_comment
comment|/* ===================  /proc  "MODULE" =================== */
end_comment

begin_comment
comment|/*  * This "module" is the interface layer between the /proc system API  * and the gdb target vector functions.  This layer consists of   * access functions that encapsulate each of the basic operations  * that we need to use from the /proc API.  *  * The main motivation for this layer is to hide the fact that  * there are two very different implementations of the /proc API.  * Rather than have a bunch of #ifdefs all thru the gdb target vector  * functions, we do our best to hide them all in here.  */
end_comment

begin_function_decl
name|int
name|proc_get_status
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|long
name|proc_flags
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|proc_why
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|proc_what
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|proc_set_run_on_last_close
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|proc_unset_run_on_last_close
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|proc_set_inherit_on_fork
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|proc_unset_inherit_on_fork
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|proc_set_async
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|proc_unset_async
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|proc_stop_process
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|proc_trace_signal
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|int
name|signo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|proc_ignore_signal
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|int
name|signo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|proc_clear_current_fault
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|proc_set_current_signal
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|int
name|signo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|proc_clear_current_signal
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|proc_set_gregs
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|proc_set_fpregs
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|proc_wait_for_stop
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|proc_run_process
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|int
name|step
parameter_list|,
name|int
name|signo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|proc_kill
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|int
name|signo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|proc_parent_pid
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|proc_get_nthreads
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|proc_get_current_thread
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|proc_set_held_signals
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|gdb_sigset_t
modifier|*
name|sighold
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|proc_set_traced_sysexit
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|sysset_t
modifier|*
name|sysset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|proc_set_traced_sysentry
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|sysset_t
modifier|*
name|sysset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|proc_set_traced_faults
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|fltset_t
modifier|*
name|fltset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|proc_set_traced_signals
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|gdb_sigset_t
modifier|*
name|sigset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|proc_update_threads
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|proc_iterate_over_threads
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|procinfo
modifier|*
parameter_list|,
name|procinfo
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|gdb_gregset_t
modifier|*
name|proc_get_gregs
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|gdb_fpregset_t
modifier|*
name|proc_get_fpregs
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|sysset_t
modifier|*
name|proc_get_traced_sysexit
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|sysset_t
modifier|*
name|save
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|sysset_t
modifier|*
name|proc_get_traced_sysentry
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|sysset_t
modifier|*
name|save
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|fltset_t
modifier|*
name|proc_get_traced_faults
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|fltset_t
modifier|*
name|save
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|gdb_sigset_t
modifier|*
name|proc_get_traced_signals
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|gdb_sigset_t
modifier|*
name|save
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|gdb_sigset_t
modifier|*
name|proc_get_held_signals
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|gdb_sigset_t
modifier|*
name|save
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|gdb_sigset_t
modifier|*
name|proc_get_pending_signals
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|gdb_sigset_t
modifier|*
name|save
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|gdb_sigaction_t
modifier|*
name|proc_get_signal_actions
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|gdb_sigaction_t
modifier|*
name|save
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|proc_warn
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|char
modifier|*
name|func
parameter_list|,
name|int
name|line
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|proc_error
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|char
modifier|*
name|func
parameter_list|,
name|int
name|line
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|proc_warn
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|char
modifier|*
name|func
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"procfs: %s line %d, %s"
argument_list|,
name|func
argument_list|,
name|line
argument_list|,
name|pi
operator|->
name|pathname
argument_list|)
expr_stmt|;
name|print_sys_errmsg
argument_list|(
name|errmsg
argument_list|,
name|errno
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|proc_error
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|char
modifier|*
name|func
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"procfs: %s line %d, %s"
argument_list|,
name|func
argument_list|,
name|line
argument_list|,
name|pi
operator|->
name|pathname
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|errmsg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function: proc_get_status  *  * Updates the status struct in the procinfo.  * There is a 'valid' flag, to let other functions know when  * this function needs to be called (so the status is only  * read when it is needed).  The status file descriptor is  * also only opened when it is needed.  *  * Return: non-zero for success, zero for failure.  */
end_comment

begin_function
name|int
name|proc_get_status
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
comment|/* Status file descriptor is opened "lazily" */
if|if
condition|(
name|pi
operator|->
name|status_fd
operator|==
literal|0
operator|&&
name|open_procinfo_files
argument_list|(
name|pi
argument_list|,
name|FD_STATUS
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pi
operator|->
name|status_valid
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|NEW_PROC_API
if|if
condition|(
name|lseek
argument_list|(
name|pi
operator|->
name|status_fd
argument_list|,
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
name|pi
operator|->
name|status_valid
operator|=
literal|0
expr_stmt|;
comment|/* fail */
else|else
block|{
comment|/* Sigh... I have to read a different data structure,  	 depending on whether this is a main process or an LWP. */
if|if
condition|(
name|pi
operator|->
name|tid
condition|)
name|pi
operator|->
name|status_valid
operator|=
operator|(
name|read
argument_list|(
name|pi
operator|->
name|status_fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pi
operator|->
name|prstatus
operator|.
name|pr_lwp
argument_list|,
sizeof|sizeof
argument_list|(
name|lwpstatus_t
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|lwpstatus_t
argument_list|)
operator|)
expr_stmt|;
else|else
block|{
name|pi
operator|->
name|status_valid
operator|=
operator|(
name|read
argument_list|(
name|pi
operator|->
name|status_fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|pi
operator|->
name|prstatus
argument_list|,
sizeof|sizeof
argument_list|(
name|gdb_prstatus_t
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|gdb_prstatus_t
argument_list|)
operator|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/*def UNIXWARE*/
block|if (pi->status_valid&& 	      (pi->prstatus.pr_lwp.pr_flags& PR_ISTOP)&& 	      pi->prstatus.pr_lwp.pr_why == PR_REQUESTED)
comment|/* Unixware peculiarity -- read the damn thing again! */
block|pi->status_valid = (read (pi->status_fd,  				      (char *)&pi->prstatus, 				      sizeof (gdb_prstatus_t)) 				== sizeof (gdb_prstatus_t));
endif|#
directive|endif
comment|/* UNIXWARE */
block|}
block|}
else|#
directive|else
comment|/* ioctl method */
ifdef|#
directive|ifdef
name|PIOCTSTATUS
comment|/* osf */
if|if
condition|(
name|pi
operator|->
name|tid
operator|==
literal|0
condition|)
comment|/* main process */
block|{
comment|/* Just read the danged status.  Now isn't that simple? */
name|pi
operator|->
name|status_valid
operator|=
operator|(
name|ioctl
argument_list|(
name|pi
operator|->
name|status_fd
argument_list|,
name|PIOCSTATUS
argument_list|,
operator|&
name|pi
operator|->
name|prstatus
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|win
decl_stmt|;
struct|struct
block|{
name|long
name|pr_count
decl_stmt|;
name|tid_t
name|pr_error_thread
decl_stmt|;
name|struct
name|prstatus
name|status
decl_stmt|;
block|}
name|thread_status
struct|;
name|thread_status
operator|.
name|pr_count
operator|=
literal|1
expr_stmt|;
name|thread_status
operator|.
name|status
operator|.
name|pr_tid
operator|=
name|pi
operator|->
name|tid
expr_stmt|;
name|win
operator|=
operator|(
name|ioctl
argument_list|(
name|pi
operator|->
name|status_fd
argument_list|,
name|PIOCTSTATUS
argument_list|,
operator|&
name|thread_status
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|win
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|pi
operator|->
name|prstatus
argument_list|,
operator|&
name|thread_status
operator|.
name|status
argument_list|,
sizeof|sizeof
argument_list|(
name|pi
operator|->
name|prstatus
argument_list|)
argument_list|)
expr_stmt|;
name|pi
operator|->
name|status_valid
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* Just read the danged status.  Now isn't that simple? */
name|pi
operator|->
name|status_valid
operator|=
operator|(
name|ioctl
argument_list|(
name|pi
operator|->
name|status_fd
argument_list|,
name|PIOCSTATUS
argument_list|,
operator|&
name|pi
operator|->
name|prstatus
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|pi
operator|->
name|status_valid
condition|)
block|{
name|PROC_PRETTYFPRINT_STATUS
argument_list|(
name|proc_flags
argument_list|(
name|pi
argument_list|)
argument_list|,
name|proc_why
argument_list|(
name|pi
argument_list|)
argument_list|,
name|proc_what
argument_list|(
name|pi
argument_list|)
argument_list|,
name|proc_get_current_thread
argument_list|(
name|pi
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* The status struct includes general regs, so mark them valid too */
name|pi
operator|->
name|gregs_valid
operator|=
name|pi
operator|->
name|status_valid
expr_stmt|;
ifdef|#
directive|ifdef
name|NEW_PROC_API
comment|/* In the read/write multiple-fd model,       the status struct includes the fp regs too, so mark them valid too */
name|pi
operator|->
name|fpregs_valid
operator|=
name|pi
operator|->
name|status_valid
expr_stmt|;
endif|#
directive|endif
return|return
name|pi
operator|->
name|status_valid
return|;
comment|/* True if success, false if failure. */
block|}
end_function

begin_comment
comment|/*  * Function: proc_flags  *  * returns the process flags (pr_flags field).  */
end_comment

begin_function
name|long
name|proc_flags
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pi
operator|->
name|status_valid
condition|)
if|if
condition|(
operator|!
name|proc_get_status
argument_list|(
name|pi
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* FIXME: not a good failure value (but what is?) */
ifdef|#
directive|ifdef
name|NEW_PROC_API
ifdef|#
directive|ifdef
name|UNIXWARE
comment|/* UnixWare 7.1 puts process status flags, e.g. PR_ASYNC, in      pstatus_t and LWP status flags, e.g. PR_STOPPED, in lwpstatus_t.      The two sets of flags don't overlap. */
return|return
name|pi
operator|->
name|prstatus
operator|.
name|pr_flags
operator||
name|pi
operator|->
name|prstatus
operator|.
name|pr_lwp
operator|.
name|pr_flags
return|;
else|#
directive|else
return|return
name|pi
operator|->
name|prstatus
operator|.
name|pr_lwp
operator|.
name|pr_flags
return|;
endif|#
directive|endif
else|#
directive|else
return|return
name|pi
operator|->
name|prstatus
operator|.
name|pr_flags
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Function: proc_why  *  * returns the pr_why field (why the process stopped).  */
end_comment

begin_function
name|int
name|proc_why
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pi
operator|->
name|status_valid
condition|)
if|if
condition|(
operator|!
name|proc_get_status
argument_list|(
name|pi
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* FIXME: not a good failure value (but what is?) */
ifdef|#
directive|ifdef
name|NEW_PROC_API
return|return
name|pi
operator|->
name|prstatus
operator|.
name|pr_lwp
operator|.
name|pr_why
return|;
else|#
directive|else
return|return
name|pi
operator|->
name|prstatus
operator|.
name|pr_why
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Function: proc_what  *  * returns the pr_what field (details of why the process stopped).  */
end_comment

begin_function
name|int
name|proc_what
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pi
operator|->
name|status_valid
condition|)
if|if
condition|(
operator|!
name|proc_get_status
argument_list|(
name|pi
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* FIXME: not a good failure value (but what is?) */
ifdef|#
directive|ifdef
name|NEW_PROC_API
return|return
name|pi
operator|->
name|prstatus
operator|.
name|pr_lwp
operator|.
name|pr_what
return|;
else|#
directive|else
return|return
name|pi
operator|->
name|prstatus
operator|.
name|pr_what
return|;
endif|#
directive|endif
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|PIOCSSPCACT
end_ifndef

begin_comment
comment|/* The following is not supported on OSF.  */
end_comment

begin_comment
comment|/*  * Function: proc_nsysarg  *  * returns the pr_nsysarg field (number of args to the current syscall).  */
end_comment

begin_function
name|int
name|proc_nsysarg
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pi
operator|->
name|status_valid
condition|)
if|if
condition|(
operator|!
name|proc_get_status
argument_list|(
name|pi
argument_list|)
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|NEW_PROC_API
return|return
name|pi
operator|->
name|prstatus
operator|.
name|pr_lwp
operator|.
name|pr_nsysarg
return|;
else|#
directive|else
return|return
name|pi
operator|->
name|prstatus
operator|.
name|pr_nsysarg
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Function: proc_sysargs  *  * returns the pr_sysarg field (pointer to the arguments of current syscall).  */
end_comment

begin_function
name|long
modifier|*
name|proc_sysargs
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pi
operator|->
name|status_valid
condition|)
if|if
condition|(
operator|!
name|proc_get_status
argument_list|(
name|pi
argument_list|)
condition|)
return|return
name|NULL
return|;
ifdef|#
directive|ifdef
name|NEW_PROC_API
return|return
operator|(
name|long
operator|*
operator|)
operator|&
name|pi
operator|->
name|prstatus
operator|.
name|pr_lwp
operator|.
name|pr_sysarg
return|;
else|#
directive|else
return|return
operator|(
name|long
operator|*
operator|)
operator|&
name|pi
operator|->
name|prstatus
operator|.
name|pr_sysarg
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Function: proc_syscall  *  * returns the pr_syscall field (id of current syscall if we are in one).  */
end_comment

begin_function
name|int
name|proc_syscall
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pi
operator|->
name|status_valid
condition|)
if|if
condition|(
operator|!
name|proc_get_status
argument_list|(
name|pi
argument_list|)
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|NEW_PROC_API
return|return
name|pi
operator|->
name|prstatus
operator|.
name|pr_lwp
operator|.
name|pr_syscall
return|;
else|#
directive|else
return|return
name|pi
operator|->
name|prstatus
operator|.
name|pr_syscall
return|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PIOCSSPCACT */
end_comment

begin_comment
comment|/*  * Function: proc_cursig:  *  * returns the pr_cursig field (current signal).  */
end_comment

begin_function
name|long
name|proc_cursig
parameter_list|(
name|struct
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pi
operator|->
name|status_valid
condition|)
if|if
condition|(
operator|!
name|proc_get_status
argument_list|(
name|pi
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* FIXME: not a good failure value (but what is?) */
ifdef|#
directive|ifdef
name|NEW_PROC_API
return|return
name|pi
operator|->
name|prstatus
operator|.
name|pr_lwp
operator|.
name|pr_cursig
return|;
else|#
directive|else
return|return
name|pi
operator|->
name|prstatus
operator|.
name|pr_cursig
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Function: proc_modify_flag   *  *  === I appologize for the messiness of this function.   *  === This is an area where the different versions of  *  === /proc are more inconsistent than usual.     MVS  *  * Set or reset any of the following process flags:  *    PR_FORK	-- forked child will inherit trace flags  *    PR_RLC	-- traced process runs when last /proc file closed.  *    PR_KLC    -- traced process is killed when last /proc file closed.  *    PR_ASYNC	-- LWP's get to run/stop independently.  *  * There are three methods for doing this function:  * 1) Newest: read/write [PCSET/PCRESET/PCUNSET]  *    [Sol6, Sol7, UW]  * 2) Middle: PIOCSET/PIOCRESET  *    [Irix, Sol5]  * 3) Oldest: PIOCSFORK/PIOCRFORK/PIOCSRLC/PIOCRRLC  *    [OSF, Sol5]  *  * Note: Irix does not define PR_ASYNC.  * Note: OSF  does not define PR_KLC.  * Note: OSF  is the only one that can ONLY use the oldest method.  *  * Arguments:   *    pi   -- the procinfo  *    flag -- one of PR_FORK, PR_RLC, or PR_ASYNC  *    mode -- 1 for set, 0 for reset.  *  * Returns non-zero for success, zero for failure.  */
end_comment

begin_enum
enum|enum
block|{
name|FLAG_RESET
block|,
name|FLAG_SET
block|}
enum|;
end_enum

begin_function
specifier|static
name|int
name|proc_modify_flag
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|long
name|flag
parameter_list|,
name|long
name|mode
parameter_list|)
block|{
name|long
name|win
init|=
literal|0
decl_stmt|;
comment|/* default to fail */
comment|/*     * These operations affect the process as a whole, and applying     * them to an individual LWP has the same meaning as applying them     * to the main process.  Therefore, if we're ever called with a     * pointer to an LWP's procinfo, let's substitute the process's     * procinfo and avoid opening the LWP's file descriptor     * unnecessarily.      */
if|if
condition|(
name|pi
operator|->
name|pid
operator|!=
literal|0
condition|)
name|pi
operator|=
name|find_procinfo_or_die
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NEW_PROC_API
comment|/* Newest method: UnixWare and newer Solarii */
comment|/* First normalize the PCUNSET/PCRESET command opcode       (which for no obvious reason has a different definition      from one operating system to the next...)  */
ifdef|#
directive|ifdef
name|PCUNSET
define|#
directive|define
name|GDBRESET
value|PCUNSET
else|#
directive|else
ifdef|#
directive|ifdef
name|PCRESET
define|#
directive|define
name|GDBRESET
value|PCRESET
endif|#
directive|endif
endif|#
directive|endif
block|{
name|procfs_ctl_t
name|arg
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|FLAG_SET
condition|)
comment|/* Set the flag (RLC, FORK, or ASYNC) */
name|arg
index|[
literal|0
index|]
operator|=
name|PCSET
expr_stmt|;
else|else
comment|/* Reset the flag */
name|arg
index|[
literal|0
index|]
operator|=
name|GDBRESET
expr_stmt|;
name|arg
index|[
literal|1
index|]
operator|=
name|flag
expr_stmt|;
name|win
operator|=
operator|(
name|write
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|arg
argument_list|)
operator|)
expr_stmt|;
block|}
else|#
directive|else
ifdef|#
directive|ifdef
name|PIOCSET
comment|/* Irix/Sol5 method */
if|if
condition|(
name|mode
operator|==
name|FLAG_SET
condition|)
comment|/* Set the flag (hopefully RLC, FORK, or ASYNC) */
block|{
name|win
operator|=
operator|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCSET
argument_list|,
operator|&
name|flag
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
block|}
else|else
comment|/* Reset the flag */
block|{
name|win
operator|=
operator|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCRESET
argument_list|,
operator|&
name|flag
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
block|}
else|#
directive|else
ifdef|#
directive|ifdef
name|PIOCSRLC
comment|/* Oldest method: OSF */
switch|switch
condition|(
name|flag
condition|)
block|{
case|case
name|PR_RLC
case|:
if|if
condition|(
name|mode
operator|==
name|FLAG_SET
condition|)
comment|/* Set run-on-last-close */
block|{
name|win
operator|=
operator|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCSRLC
argument_list|,
name|NULL
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
block|}
else|else
comment|/* Clear run-on-last-close */
block|{
name|win
operator|=
operator|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCRRLC
argument_list|,
name|NULL
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|PR_FORK
case|:
if|if
condition|(
name|mode
operator|==
name|FLAG_SET
condition|)
comment|/* Set inherit-on-fork */
block|{
name|win
operator|=
operator|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCSFORK
argument_list|,
name|NULL
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
block|}
else|else
comment|/* Clear inherit-on-fork */
block|{
name|win
operator|=
operator|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCRFORK
argument_list|,
name|NULL
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
block|}
break|break;
default|default:
name|win
operator|=
literal|0
expr_stmt|;
comment|/* fail -- unknown flag (can't do PR_ASYNC) */
break|break;
block|}
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
undef|#
directive|undef
name|GDBRESET
comment|/* The above operation renders the procinfo's cached pstatus obsolete. */
name|pi
operator|->
name|status_valid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|win
condition|)
name|warning
argument_list|(
literal|"procfs: modify_flag failed to turn %s %s"
argument_list|,
name|flag
operator|==
name|PR_FORK
condition|?
literal|"PR_FORK"
else|:
name|flag
operator|==
name|PR_RLC
condition|?
literal|"PR_RLC"
else|:
ifdef|#
directive|ifdef
name|PR_ASYNC
name|flag
operator|==
name|PR_ASYNC
condition|?
literal|"PR_ASYNC"
else|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PR_KLC
name|flag
operator|==
name|PR_KLC
condition|?
literal|"PR_KLC"
else|:
endif|#
directive|endif
literal|"<unknown flag>"
argument_list|,
name|mode
operator|==
name|FLAG_RESET
condition|?
literal|"off"
else|:
literal|"on"
argument_list|)
expr_stmt|;
return|return
name|win
return|;
block|}
end_function

begin_comment
comment|/*  * Function: proc_set_run_on_last_close  *  * Set the run_on_last_close flag.  * Process with all threads will become runnable  * when debugger closes all /proc fds.  *  * Returns non-zero for success, zero for failure.  */
end_comment

begin_function
name|int
name|proc_set_run_on_last_close
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
return|return
name|proc_modify_flag
argument_list|(
name|pi
argument_list|,
name|PR_RLC
argument_list|,
name|FLAG_SET
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function: proc_unset_run_on_last_close  *  * Reset the run_on_last_close flag.  * Process will NOT become runnable  * when debugger closes its file handles.  *  * Returns non-zero for success, zero for failure.  */
end_comment

begin_function
name|int
name|proc_unset_run_on_last_close
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
return|return
name|proc_modify_flag
argument_list|(
name|pi
argument_list|,
name|PR_RLC
argument_list|,
name|FLAG_RESET
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PR_KLC
end_ifdef

begin_comment
comment|/*  * Function: proc_set_kill_on_last_close  *  * Set the kill_on_last_close flag.  * Process with all threads will be killed when debugger  * closes all /proc fds (or debugger exits or dies).  *  * Returns non-zero for success, zero for failure.  */
end_comment

begin_function
name|int
name|proc_set_kill_on_last_close
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
return|return
name|proc_modify_flag
argument_list|(
name|pi
argument_list|,
name|PR_KLC
argument_list|,
name|FLAG_SET
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function: proc_unset_kill_on_last_close  *  * Reset the kill_on_last_close flag.  * Process will NOT be killed when debugger   * closes its file handles (or exits or dies).  *  * Returns non-zero for success, zero for failure.  */
end_comment

begin_function
name|int
name|proc_unset_kill_on_last_close
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
return|return
name|proc_modify_flag
argument_list|(
name|pi
argument_list|,
name|PR_KLC
argument_list|,
name|FLAG_RESET
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PR_KLC */
end_comment

begin_comment
comment|/*  * Function: proc_set_inherit_on_fork  *  * Set inherit_on_fork flag.  * If the process forks a child while we are registered for events  * in the parent, then we will also recieve events from the child.  *  * Returns non-zero for success, zero for failure.  */
end_comment

begin_function
name|int
name|proc_set_inherit_on_fork
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
return|return
name|proc_modify_flag
argument_list|(
name|pi
argument_list|,
name|PR_FORK
argument_list|,
name|FLAG_SET
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function: proc_unset_inherit_on_fork  *  * Reset inherit_on_fork flag.  * If the process forks a child while we are registered for events  * in the parent, then we will NOT recieve events from the child.  *  * Returns non-zero for success, zero for failure.  */
end_comment

begin_function
name|int
name|proc_unset_inherit_on_fork
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
return|return
name|proc_modify_flag
argument_list|(
name|pi
argument_list|,
name|PR_FORK
argument_list|,
name|FLAG_RESET
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PR_ASYNC
end_ifdef

begin_comment
comment|/*  * Function: proc_set_async  *  * Set PR_ASYNC flag.  * If one LWP stops because of a debug event (signal etc.),   * the remaining LWPs will continue to run.  *  * Returns non-zero for success, zero for failure.  */
end_comment

begin_function
name|int
name|proc_set_async
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
return|return
name|proc_modify_flag
argument_list|(
name|pi
argument_list|,
name|PR_ASYNC
argument_list|,
name|FLAG_SET
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function: proc_unset_async  *  * Reset PR_ASYNC flag.  * If one LWP stops because of a debug event (signal etc.),  * then all other LWPs will stop as well.  *  * Returns non-zero for success, zero for failure.  */
end_comment

begin_function
name|int
name|proc_unset_async
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
return|return
name|proc_modify_flag
argument_list|(
name|pi
argument_list|,
name|PR_ASYNC
argument_list|,
name|FLAG_RESET
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PR_ASYNC */
end_comment

begin_comment
comment|/*  * Function: proc_stop_process  *  * Request the process/LWP to stop.  Does not wait.  * Returns non-zero for success, zero for failure.   */
end_comment

begin_function
name|int
name|proc_stop_process
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
name|int
name|win
decl_stmt|;
comment|/*    * We might conceivably apply this operation to an LWP, and    * the LWP's ctl file descriptor might not be open.    */
if|if
condition|(
name|pi
operator|->
name|ctl_fd
operator|==
literal|0
operator|&&
name|open_procinfo_files
argument_list|(
name|pi
argument_list|,
name|FD_CTL
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
else|else
block|{
ifdef|#
directive|ifdef
name|NEW_PROC_API
name|procfs_ctl_t
name|cmd
init|=
name|PCSTOP
decl_stmt|;
name|win
operator|=
operator|(
name|write
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
operator|)
expr_stmt|;
else|#
directive|else
comment|/* ioctl method */
name|win
operator|=
operator|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCSTOP
argument_list|,
operator|&
name|pi
operator|->
name|prstatus
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
comment|/* Note: the call also reads the prstatus.  */
if|if
condition|(
name|win
condition|)
block|{
name|pi
operator|->
name|status_valid
operator|=
literal|1
expr_stmt|;
name|PROC_PRETTYFPRINT_STATUS
argument_list|(
name|proc_flags
argument_list|(
name|pi
argument_list|)
argument_list|,
name|proc_why
argument_list|(
name|pi
argument_list|)
argument_list|,
name|proc_what
argument_list|(
name|pi
argument_list|)
argument_list|,
name|proc_get_current_thread
argument_list|(
name|pi
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
return|return
name|win
return|;
block|}
end_function

begin_comment
comment|/*  * Function: proc_wait_for_stop  *  * Wait for the process or LWP to stop (block until it does).  * Returns non-zero for success, zero for failure.   */
end_comment

begin_function
name|int
name|proc_wait_for_stop
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
name|int
name|win
decl_stmt|;
comment|/*    * We should never have to apply this operation to any procinfo    * except the one for the main process.  If that ever changes    * for any reason, then take out the following clause and     * replace it with one that makes sure the ctl_fd is open.    */
if|if
condition|(
name|pi
operator|->
name|tid
operator|!=
literal|0
condition|)
name|pi
operator|=
name|find_procinfo_or_die
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NEW_PROC_API
block|{
name|procfs_ctl_t
name|cmd
init|=
name|PCWSTOP
decl_stmt|;
name|win
operator|=
operator|(
name|write
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
operator|)
expr_stmt|;
comment|/* We been runnin' and we stopped -- need to update status.  */
name|pi
operator|->
name|status_valid
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
comment|/* ioctl method */
name|win
operator|=
operator|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCWSTOP
argument_list|,
operator|&
name|pi
operator|->
name|prstatus
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
comment|/* Above call also refreshes the prstatus.  */
if|if
condition|(
name|win
condition|)
block|{
name|pi
operator|->
name|status_valid
operator|=
literal|1
expr_stmt|;
name|PROC_PRETTYFPRINT_STATUS
argument_list|(
name|proc_flags
argument_list|(
name|pi
argument_list|)
argument_list|,
name|proc_why
argument_list|(
name|pi
argument_list|)
argument_list|,
name|proc_what
argument_list|(
name|pi
argument_list|)
argument_list|,
name|proc_get_current_thread
argument_list|(
name|pi
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|win
return|;
block|}
end_function

begin_comment
comment|/*  * Function: proc_run_process  *  * Make the process or LWP runnable.  * Options (not all are implemented):  *   - single-step  *   - clear current fault  *   - clear current signal  *   - abort the current system call  *   - stop as soon as finished with system call  *   - (ioctl): set traced signal set  *   - (ioctl): set held   signal set  *   - (ioctl): set traced fault  set  *   - (ioctl): set start pc (vaddr)  * Always clear the current fault.  * Clear the current signal if 'signo' is zero.  *  * Arguments:  *   pi		the process or LWP to operate on.  *   step	if true, set the process or LWP to trap after one instr.  *   signo	if zero, clear the current signal if any.  *		if non-zero, set the current signal to this one.  *  * Returns non-zero for success, zero for failure.   */
end_comment

begin_function
name|int
name|proc_run_process
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|int
name|step
parameter_list|,
name|int
name|signo
parameter_list|)
block|{
name|int
name|win
decl_stmt|;
name|int
name|runflags
decl_stmt|;
comment|/*    * We will probably have to apply this operation to individual threads,    * so make sure the control file descriptor is open.    */
if|if
condition|(
name|pi
operator|->
name|ctl_fd
operator|==
literal|0
operator|&&
name|open_procinfo_files
argument_list|(
name|pi
argument_list|,
name|FD_CTL
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|runflags
operator|=
name|PRCFAULT
expr_stmt|;
comment|/* always clear current fault  */
if|if
condition|(
name|step
condition|)
name|runflags
operator||=
name|PRSTEP
expr_stmt|;
if|if
condition|(
name|signo
operator|==
literal|0
condition|)
name|runflags
operator||=
name|PRCSIG
expr_stmt|;
elseif|else
if|if
condition|(
name|signo
operator|!=
operator|-
literal|1
condition|)
comment|/* -1 means do nothing W.R.T. signals */
name|proc_set_current_signal
argument_list|(
name|pi
argument_list|,
name|signo
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NEW_PROC_API
block|{
name|procfs_ctl_t
name|cmd
index|[
literal|2
index|]
decl_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|PCRUN
expr_stmt|;
name|cmd
index|[
literal|1
index|]
operator|=
name|runflags
expr_stmt|;
name|win
operator|=
operator|(
name|write
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
operator|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* ioctl method */
block|{
name|prrun_t
name|prrun
decl_stmt|;
name|memset
argument_list|(
operator|&
name|prrun
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|prrun
argument_list|)
argument_list|)
expr_stmt|;
name|prrun
operator|.
name|pr_flags
operator|=
name|runflags
expr_stmt|;
name|win
operator|=
operator|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCRUN
argument_list|,
operator|&
name|prrun
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|win
return|;
block|}
end_function

begin_comment
comment|/*  * Function: proc_set_traced_signals  *  * Register to trace signals in the process or LWP.  * Returns non-zero for success, zero for failure.   */
end_comment

begin_function
name|int
name|proc_set_traced_signals
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|gdb_sigset_t
modifier|*
name|sigset
parameter_list|)
block|{
name|int
name|win
decl_stmt|;
comment|/*    * We should never have to apply this operation to any procinfo    * except the one for the main process.  If that ever changes    * for any reason, then take out the following clause and     * replace it with one that makes sure the ctl_fd is open.    */
if|if
condition|(
name|pi
operator|->
name|tid
operator|!=
literal|0
condition|)
name|pi
operator|=
name|find_procinfo_or_die
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NEW_PROC_API
block|{
struct|struct
block|{
name|procfs_ctl_t
name|cmd
decl_stmt|;
comment|/* Use char array to avoid alignment issues.  */
name|char
name|sigset
index|[
sizeof|sizeof
argument_list|(
name|gdb_sigset_t
argument_list|)
index|]
decl_stmt|;
block|}
name|arg
struct|;
name|arg
operator|.
name|cmd
operator|=
name|PCSTRACE
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|arg
operator|.
name|sigset
argument_list|,
name|sigset
argument_list|,
sizeof|sizeof
argument_list|(
name|gdb_sigset_t
argument_list|)
argument_list|)
expr_stmt|;
name|win
operator|=
operator|(
name|write
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|arg
argument_list|)
operator|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* ioctl method */
name|win
operator|=
operator|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCSTRACE
argument_list|,
name|sigset
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* The above operation renders the procinfo's cached pstatus obsolete. */
name|pi
operator|->
name|status_valid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|win
condition|)
name|warning
argument_list|(
literal|"procfs: set_traced_signals failed"
argument_list|)
expr_stmt|;
return|return
name|win
return|;
block|}
end_function

begin_comment
comment|/*  * Function: proc_set_traced_faults  *  * Register to trace hardware faults in the process or LWP.  * Returns non-zero for success, zero for failure.   */
end_comment

begin_function
name|int
name|proc_set_traced_faults
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|fltset_t
modifier|*
name|fltset
parameter_list|)
block|{
name|int
name|win
decl_stmt|;
comment|/*    * We should never have to apply this operation to any procinfo    * except the one for the main process.  If that ever changes    * for any reason, then take out the following clause and     * replace it with one that makes sure the ctl_fd is open.    */
if|if
condition|(
name|pi
operator|->
name|tid
operator|!=
literal|0
condition|)
name|pi
operator|=
name|find_procinfo_or_die
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NEW_PROC_API
block|{
struct|struct
block|{
name|procfs_ctl_t
name|cmd
decl_stmt|;
comment|/* Use char array to avoid alignment issues.  */
name|char
name|fltset
index|[
sizeof|sizeof
argument_list|(
name|fltset_t
argument_list|)
index|]
decl_stmt|;
block|}
name|arg
struct|;
name|arg
operator|.
name|cmd
operator|=
name|PCSFAULT
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|arg
operator|.
name|fltset
argument_list|,
name|fltset
argument_list|,
sizeof|sizeof
argument_list|(
name|fltset_t
argument_list|)
argument_list|)
expr_stmt|;
name|win
operator|=
operator|(
name|write
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|arg
argument_list|)
operator|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* ioctl method */
name|win
operator|=
operator|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCSFAULT
argument_list|,
name|fltset
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* The above operation renders the procinfo's cached pstatus obsolete. */
name|pi
operator|->
name|status_valid
operator|=
literal|0
expr_stmt|;
return|return
name|win
return|;
block|}
end_function

begin_comment
comment|/*  * Function: proc_set_traced_sysentry  *  * Register to trace entry to system calls in the process or LWP.  * Returns non-zero for success, zero for failure.   */
end_comment

begin_function
name|int
name|proc_set_traced_sysentry
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|sysset_t
modifier|*
name|sysset
parameter_list|)
block|{
name|int
name|win
decl_stmt|;
comment|/*    * We should never have to apply this operation to any procinfo    * except the one for the main process.  If that ever changes    * for any reason, then take out the following clause and     * replace it with one that makes sure the ctl_fd is open.    */
if|if
condition|(
name|pi
operator|->
name|tid
operator|!=
literal|0
condition|)
name|pi
operator|=
name|find_procinfo_or_die
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NEW_PROC_API
block|{
struct|struct
name|gdb_proc_ctl_pcsentry
block|{
name|procfs_ctl_t
name|cmd
decl_stmt|;
comment|/* Use char array to avoid alignment issues.  */
name|char
name|sysset
index|[
sizeof|sizeof
argument_list|(
name|sysset_t
argument_list|)
index|]
decl_stmt|;
block|}
modifier|*
name|argp
struct|;
name|int
name|argp_size
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|gdb_proc_ctl_pcsentry
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|sysset_t
argument_list|)
operator|+
name|sysset_t_size
argument_list|(
name|pi
argument_list|)
decl_stmt|;
name|argp
operator|=
name|xmalloc
argument_list|(
name|argp_size
argument_list|)
expr_stmt|;
name|argp
operator|->
name|cmd
operator|=
name|PCSENTRY
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|argp
operator|->
name|sysset
argument_list|,
name|sysset
argument_list|,
name|sysset_t_size
argument_list|(
name|pi
argument_list|)
argument_list|)
expr_stmt|;
name|win
operator|=
operator|(
name|write
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|argp
argument_list|,
name|argp_size
argument_list|)
operator|==
name|argp_size
operator|)
expr_stmt|;
name|xfree
argument_list|(
name|argp
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* ioctl method */
name|win
operator|=
operator|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCSENTRY
argument_list|,
name|sysset
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* The above operation renders the procinfo's cached pstatus obsolete. */
name|pi
operator|->
name|status_valid
operator|=
literal|0
expr_stmt|;
return|return
name|win
return|;
block|}
end_function

begin_comment
comment|/*  * Function: proc_set_traced_sysexit  *  * Register to trace exit from system calls in the process or LWP.  * Returns non-zero for success, zero for failure.   */
end_comment

begin_function
name|int
name|proc_set_traced_sysexit
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|sysset_t
modifier|*
name|sysset
parameter_list|)
block|{
name|int
name|win
decl_stmt|;
comment|/*    * We should never have to apply this operation to any procinfo    * except the one for the main process.  If that ever changes    * for any reason, then take out the following clause and     * replace it with one that makes sure the ctl_fd is open.    */
if|if
condition|(
name|pi
operator|->
name|tid
operator|!=
literal|0
condition|)
name|pi
operator|=
name|find_procinfo_or_die
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NEW_PROC_API
block|{
struct|struct
name|gdb_proc_ctl_pcsexit
block|{
name|procfs_ctl_t
name|cmd
decl_stmt|;
comment|/* Use char array to avoid alignment issues.  */
name|char
name|sysset
index|[
sizeof|sizeof
argument_list|(
name|sysset_t
argument_list|)
index|]
decl_stmt|;
block|}
modifier|*
name|argp
struct|;
name|int
name|argp_size
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|gdb_proc_ctl_pcsexit
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|sysset_t
argument_list|)
operator|+
name|sysset_t_size
argument_list|(
name|pi
argument_list|)
decl_stmt|;
name|argp
operator|=
name|xmalloc
argument_list|(
name|argp_size
argument_list|)
expr_stmt|;
name|argp
operator|->
name|cmd
operator|=
name|PCSEXIT
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|argp
operator|->
name|sysset
argument_list|,
name|sysset
argument_list|,
name|sysset_t_size
argument_list|(
name|pi
argument_list|)
argument_list|)
expr_stmt|;
name|win
operator|=
operator|(
name|write
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|argp
argument_list|,
name|argp_size
argument_list|)
operator|==
name|argp_size
operator|)
expr_stmt|;
name|xfree
argument_list|(
name|argp
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* ioctl method */
name|win
operator|=
operator|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCSEXIT
argument_list|,
name|sysset
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* The above operation renders the procinfo's cached pstatus obsolete. */
name|pi
operator|->
name|status_valid
operator|=
literal|0
expr_stmt|;
return|return
name|win
return|;
block|}
end_function

begin_comment
comment|/*  * Function: proc_set_held_signals  *  * Specify the set of blocked / held signals in the process or LWP.  * Returns non-zero for success, zero for failure.   */
end_comment

begin_function
name|int
name|proc_set_held_signals
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|gdb_sigset_t
modifier|*
name|sighold
parameter_list|)
block|{
name|int
name|win
decl_stmt|;
comment|/*    * We should never have to apply this operation to any procinfo    * except the one for the main process.  If that ever changes    * for any reason, then take out the following clause and     * replace it with one that makes sure the ctl_fd is open.    */
if|if
condition|(
name|pi
operator|->
name|tid
operator|!=
literal|0
condition|)
name|pi
operator|=
name|find_procinfo_or_die
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NEW_PROC_API
block|{
struct|struct
block|{
name|procfs_ctl_t
name|cmd
decl_stmt|;
comment|/* Use char array to avoid alignment issues.  */
name|char
name|hold
index|[
sizeof|sizeof
argument_list|(
name|gdb_sigset_t
argument_list|)
index|]
decl_stmt|;
block|}
name|arg
struct|;
name|arg
operator|.
name|cmd
operator|=
name|PCSHOLD
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|arg
operator|.
name|hold
argument_list|,
name|sighold
argument_list|,
sizeof|sizeof
argument_list|(
name|gdb_sigset_t
argument_list|)
argument_list|)
expr_stmt|;
name|win
operator|=
operator|(
name|write
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|arg
argument_list|)
operator|)
expr_stmt|;
block|}
else|#
directive|else
name|win
operator|=
operator|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCSHOLD
argument_list|,
name|sighold
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* The above operation renders the procinfo's cached pstatus obsolete. */
name|pi
operator|->
name|status_valid
operator|=
literal|0
expr_stmt|;
return|return
name|win
return|;
block|}
end_function

begin_comment
comment|/*  * Function: proc_get_pending_signals  *  * returns the set of signals that are pending in the process or LWP.  * Will also copy the sigset if 'save' is non-zero.  */
end_comment

begin_function
name|gdb_sigset_t
modifier|*
name|proc_get_pending_signals
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|gdb_sigset_t
modifier|*
name|save
parameter_list|)
block|{
name|gdb_sigset_t
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
comment|/*    * We should never have to apply this operation to any procinfo    * except the one for the main process.  If that ever changes    * for any reason, then take out the following clause and     * replace it with one that makes sure the ctl_fd is open.    */
if|if
condition|(
name|pi
operator|->
name|tid
operator|!=
literal|0
condition|)
name|pi
operator|=
name|find_procinfo_or_die
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pi
operator|->
name|status_valid
condition|)
if|if
condition|(
operator|!
name|proc_get_status
argument_list|(
name|pi
argument_list|)
condition|)
return|return
name|NULL
return|;
ifdef|#
directive|ifdef
name|NEW_PROC_API
name|ret
operator|=
operator|&
name|pi
operator|->
name|prstatus
operator|.
name|pr_lwp
operator|.
name|pr_lwppend
expr_stmt|;
else|#
directive|else
name|ret
operator|=
operator|&
name|pi
operator|->
name|prstatus
operator|.
name|pr_sigpend
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|save
operator|&&
name|ret
condition|)
name|memcpy
argument_list|(
name|save
argument_list|,
name|ret
argument_list|,
sizeof|sizeof
argument_list|(
name|gdb_sigset_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Function: proc_get_signal_actions  *  * returns the set of signal actions.  * Will also copy the sigactionset if 'save' is non-zero.  */
end_comment

begin_function
name|gdb_sigaction_t
modifier|*
name|proc_get_signal_actions
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|gdb_sigaction_t
modifier|*
name|save
parameter_list|)
block|{
name|gdb_sigaction_t
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
comment|/*    * We should never have to apply this operation to any procinfo    * except the one for the main process.  If that ever changes    * for any reason, then take out the following clause and     * replace it with one that makes sure the ctl_fd is open.    */
if|if
condition|(
name|pi
operator|->
name|tid
operator|!=
literal|0
condition|)
name|pi
operator|=
name|find_procinfo_or_die
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pi
operator|->
name|status_valid
condition|)
if|if
condition|(
operator|!
name|proc_get_status
argument_list|(
name|pi
argument_list|)
condition|)
return|return
name|NULL
return|;
ifdef|#
directive|ifdef
name|NEW_PROC_API
name|ret
operator|=
operator|&
name|pi
operator|->
name|prstatus
operator|.
name|pr_lwp
operator|.
name|pr_action
expr_stmt|;
else|#
directive|else
name|ret
operator|=
operator|&
name|pi
operator|->
name|prstatus
operator|.
name|pr_action
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|save
operator|&&
name|ret
condition|)
name|memcpy
argument_list|(
name|save
argument_list|,
name|ret
argument_list|,
sizeof|sizeof
argument_list|(
name|gdb_sigaction_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Function: proc_get_held_signals  *  * returns the set of signals that are held / blocked.  * Will also copy the sigset if 'save' is non-zero.  */
end_comment

begin_function
name|gdb_sigset_t
modifier|*
name|proc_get_held_signals
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|gdb_sigset_t
modifier|*
name|save
parameter_list|)
block|{
name|gdb_sigset_t
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
comment|/*    * We should never have to apply this operation to any procinfo    * except the one for the main process.  If that ever changes    * for any reason, then take out the following clause and     * replace it with one that makes sure the ctl_fd is open.    */
if|if
condition|(
name|pi
operator|->
name|tid
operator|!=
literal|0
condition|)
name|pi
operator|=
name|find_procinfo_or_die
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NEW_PROC_API
if|if
condition|(
operator|!
name|pi
operator|->
name|status_valid
condition|)
if|if
condition|(
operator|!
name|proc_get_status
argument_list|(
name|pi
argument_list|)
condition|)
return|return
name|NULL
return|;
ifdef|#
directive|ifdef
name|UNIXWARE
name|ret
operator|=
operator|&
name|pi
operator|->
name|prstatus
operator|.
name|pr_lwp
operator|.
name|pr_context
operator|.
name|uc_sigmask
expr_stmt|;
else|#
directive|else
name|ret
operator|=
operator|&
name|pi
operator|->
name|prstatus
operator|.
name|pr_lwp
operator|.
name|pr_lwphold
expr_stmt|;
endif|#
directive|endif
comment|/* UNIXWARE */
else|#
directive|else
comment|/* not NEW_PROC_API */
block|{
specifier|static
name|gdb_sigset_t
name|sigheld
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCGHOLD
argument_list|,
operator|&
name|sigheld
argument_list|)
operator|>=
literal|0
condition|)
name|ret
operator|=
operator|&
name|sigheld
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NEW_PROC_API */
if|if
condition|(
name|save
operator|&&
name|ret
condition|)
name|memcpy
argument_list|(
name|save
argument_list|,
name|ret
argument_list|,
sizeof|sizeof
argument_list|(
name|gdb_sigset_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Function: proc_get_traced_signals  *  * returns the set of signals that are traced / debugged.  * Will also copy the sigset if 'save' is non-zero.  */
end_comment

begin_function
name|gdb_sigset_t
modifier|*
name|proc_get_traced_signals
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|gdb_sigset_t
modifier|*
name|save
parameter_list|)
block|{
name|gdb_sigset_t
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
comment|/*    * We should never have to apply this operation to any procinfo    * except the one for the main process.  If that ever changes    * for any reason, then take out the following clause and     * replace it with one that makes sure the ctl_fd is open.    */
if|if
condition|(
name|pi
operator|->
name|tid
operator|!=
literal|0
condition|)
name|pi
operator|=
name|find_procinfo_or_die
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NEW_PROC_API
if|if
condition|(
operator|!
name|pi
operator|->
name|status_valid
condition|)
if|if
condition|(
operator|!
name|proc_get_status
argument_list|(
name|pi
argument_list|)
condition|)
return|return
name|NULL
return|;
name|ret
operator|=
operator|&
name|pi
operator|->
name|prstatus
operator|.
name|pr_sigtrace
expr_stmt|;
else|#
directive|else
block|{
specifier|static
name|gdb_sigset_t
name|sigtrace
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCGTRACE
argument_list|,
operator|&
name|sigtrace
argument_list|)
operator|>=
literal|0
condition|)
name|ret
operator|=
operator|&
name|sigtrace
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|save
operator|&&
name|ret
condition|)
name|memcpy
argument_list|(
name|save
argument_list|,
name|ret
argument_list|,
sizeof|sizeof
argument_list|(
name|gdb_sigset_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Function: proc_trace_signal  *  * Add 'signo' to the set of signals that are traced.  * Returns non-zero for success, zero for failure.  */
end_comment

begin_function
name|int
name|proc_trace_signal
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|int
name|signo
parameter_list|)
block|{
name|gdb_sigset_t
name|temp
decl_stmt|;
comment|/*    * We should never have to apply this operation to any procinfo    * except the one for the main process.  If that ever changes    * for any reason, then take out the following clause and     * replace it with one that makes sure the ctl_fd is open.    */
if|if
condition|(
name|pi
operator|->
name|tid
operator|!=
literal|0
condition|)
name|pi
operator|=
name|find_procinfo_or_die
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
condition|)
block|{
if|if
condition|(
name|proc_get_traced_signals
argument_list|(
name|pi
argument_list|,
operator|&
name|temp
argument_list|)
condition|)
block|{
name|praddset
argument_list|(
operator|&
name|temp
argument_list|,
name|signo
argument_list|)
expr_stmt|;
return|return
name|proc_set_traced_signals
argument_list|(
name|pi
argument_list|,
operator|&
name|temp
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
comment|/* failure */
block|}
end_function

begin_comment
comment|/*  * Function: proc_ignore_signal  *  * Remove 'signo' from the set of signals that are traced.  * Returns non-zero for success, zero for failure.  */
end_comment

begin_function
name|int
name|proc_ignore_signal
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|int
name|signo
parameter_list|)
block|{
name|gdb_sigset_t
name|temp
decl_stmt|;
comment|/*    * We should never have to apply this operation to any procinfo    * except the one for the main process.  If that ever changes    * for any reason, then take out the following clause and     * replace it with one that makes sure the ctl_fd is open.    */
if|if
condition|(
name|pi
operator|->
name|tid
operator|!=
literal|0
condition|)
name|pi
operator|=
name|find_procinfo_or_die
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
condition|)
block|{
if|if
condition|(
name|proc_get_traced_signals
argument_list|(
name|pi
argument_list|,
operator|&
name|temp
argument_list|)
condition|)
block|{
name|prdelset
argument_list|(
operator|&
name|temp
argument_list|,
name|signo
argument_list|)
expr_stmt|;
return|return
name|proc_set_traced_signals
argument_list|(
name|pi
argument_list|,
operator|&
name|temp
argument_list|)
return|;
block|}
block|}
return|return
literal|0
return|;
comment|/* failure */
block|}
end_function

begin_comment
comment|/*  * Function: proc_get_traced_faults  *  * returns the set of hardware faults that are traced /debugged.  * Will also copy the faultset if 'save' is non-zero.  */
end_comment

begin_function
name|fltset_t
modifier|*
name|proc_get_traced_faults
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|fltset_t
modifier|*
name|save
parameter_list|)
block|{
name|fltset_t
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
comment|/*    * We should never have to apply this operation to any procinfo    * except the one for the main process.  If that ever changes    * for any reason, then take out the following clause and     * replace it with one that makes sure the ctl_fd is open.    */
if|if
condition|(
name|pi
operator|->
name|tid
operator|!=
literal|0
condition|)
name|pi
operator|=
name|find_procinfo_or_die
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NEW_PROC_API
if|if
condition|(
operator|!
name|pi
operator|->
name|status_valid
condition|)
if|if
condition|(
operator|!
name|proc_get_status
argument_list|(
name|pi
argument_list|)
condition|)
return|return
name|NULL
return|;
name|ret
operator|=
operator|&
name|pi
operator|->
name|prstatus
operator|.
name|pr_flttrace
expr_stmt|;
else|#
directive|else
block|{
specifier|static
name|fltset_t
name|flttrace
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCGFAULT
argument_list|,
operator|&
name|flttrace
argument_list|)
operator|>=
literal|0
condition|)
name|ret
operator|=
operator|&
name|flttrace
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|save
operator|&&
name|ret
condition|)
name|memcpy
argument_list|(
name|save
argument_list|,
name|ret
argument_list|,
sizeof|sizeof
argument_list|(
name|fltset_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Function: proc_get_traced_sysentry  *  * returns the set of syscalls that are traced /debugged on entry.  * Will also copy the syscall set if 'save' is non-zero.  */
end_comment

begin_function
name|sysset_t
modifier|*
name|proc_get_traced_sysentry
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|sysset_t
modifier|*
name|save
parameter_list|)
block|{
name|sysset_t
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
comment|/*    * We should never have to apply this operation to any procinfo    * except the one for the main process.  If that ever changes    * for any reason, then take out the following clause and     * replace it with one that makes sure the ctl_fd is open.    */
if|if
condition|(
name|pi
operator|->
name|tid
operator|!=
literal|0
condition|)
name|pi
operator|=
name|find_procinfo_or_die
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NEW_PROC_API
if|if
condition|(
operator|!
name|pi
operator|->
name|status_valid
condition|)
if|if
condition|(
operator|!
name|proc_get_status
argument_list|(
name|pi
argument_list|)
condition|)
return|return
name|NULL
return|;
ifndef|#
directive|ifndef
name|DYNAMIC_SYSCALLS
name|ret
operator|=
operator|&
name|pi
operator|->
name|prstatus
operator|.
name|pr_sysentry
expr_stmt|;
else|#
directive|else
comment|/* DYNAMIC_SYSCALLS */
block|{
specifier|static
name|sysset_t
modifier|*
name|sysentry
decl_stmt|;
name|size_t
name|size
decl_stmt|;
if|if
condition|(
operator|!
name|sysentry
condition|)
name|sysentry
operator|=
name|sysset_t_alloc
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|ret
operator|=
name|sysentry
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|status_fd
operator|==
literal|0
operator|&&
name|open_procinfo_files
argument_list|(
name|pi
argument_list|,
name|FD_STATUS
argument_list|)
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|pi
operator|->
name|prstatus
operator|.
name|pr_sysentry_offset
operator|==
literal|0
condition|)
block|{
name|gdb_premptysysset
argument_list|(
name|sysentry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|rsize
decl_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|pi
operator|->
name|status_fd
argument_list|,
operator|(
name|off_t
operator|)
name|pi
operator|->
name|prstatus
operator|.
name|pr_sysentry_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
operator|(
name|off_t
operator|)
name|pi
operator|->
name|prstatus
operator|.
name|pr_sysentry_offset
condition|)
return|return
name|NULL
return|;
name|size
operator|=
name|sysset_t_size
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|gdb_premptysysset
argument_list|(
name|sysentry
argument_list|)
expr_stmt|;
name|rsize
operator|=
name|read
argument_list|(
name|pi
operator|->
name|status_fd
argument_list|,
name|sysentry
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsize
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
block|}
block|}
endif|#
directive|endif
comment|/* DYNAMIC_SYSCALLS */
else|#
directive|else
comment|/* !NEW_PROC_API */
block|{
specifier|static
name|sysset_t
name|sysentry
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCGENTRY
argument_list|,
operator|&
name|sysentry
argument_list|)
operator|>=
literal|0
condition|)
name|ret
operator|=
operator|&
name|sysentry
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NEW_PROC_API */
if|if
condition|(
name|save
operator|&&
name|ret
condition|)
name|memcpy
argument_list|(
name|save
argument_list|,
name|ret
argument_list|,
name|sysset_t_size
argument_list|(
name|pi
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Function: proc_get_traced_sysexit  *  * returns the set of syscalls that are traced /debugged on exit.  * Will also copy the syscall set if 'save' is non-zero.  */
end_comment

begin_function
name|sysset_t
modifier|*
name|proc_get_traced_sysexit
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|sysset_t
modifier|*
name|save
parameter_list|)
block|{
name|sysset_t
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
comment|/*    * We should never have to apply this operation to any procinfo    * except the one for the main process.  If that ever changes    * for any reason, then take out the following clause and     * replace it with one that makes sure the ctl_fd is open.    */
if|if
condition|(
name|pi
operator|->
name|tid
operator|!=
literal|0
condition|)
name|pi
operator|=
name|find_procinfo_or_die
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NEW_PROC_API
if|if
condition|(
operator|!
name|pi
operator|->
name|status_valid
condition|)
if|if
condition|(
operator|!
name|proc_get_status
argument_list|(
name|pi
argument_list|)
condition|)
return|return
name|NULL
return|;
ifndef|#
directive|ifndef
name|DYNAMIC_SYSCALLS
name|ret
operator|=
operator|&
name|pi
operator|->
name|prstatus
operator|.
name|pr_sysexit
expr_stmt|;
else|#
directive|else
comment|/* DYNAMIC_SYSCALLS */
block|{
specifier|static
name|sysset_t
modifier|*
name|sysexit
decl_stmt|;
name|size_t
name|size
decl_stmt|;
if|if
condition|(
operator|!
name|sysexit
condition|)
name|sysexit
operator|=
name|sysset_t_alloc
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|ret
operator|=
name|sysexit
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|status_fd
operator|==
literal|0
operator|&&
name|open_procinfo_files
argument_list|(
name|pi
argument_list|,
name|FD_STATUS
argument_list|)
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|pi
operator|->
name|prstatus
operator|.
name|pr_sysexit_offset
operator|==
literal|0
condition|)
block|{
name|gdb_premptysysset
argument_list|(
name|sysexit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|rsize
decl_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|pi
operator|->
name|status_fd
argument_list|,
operator|(
name|off_t
operator|)
name|pi
operator|->
name|prstatus
operator|.
name|pr_sysexit_offset
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
operator|(
name|off_t
operator|)
name|pi
operator|->
name|prstatus
operator|.
name|pr_sysexit_offset
condition|)
return|return
name|NULL
return|;
name|size
operator|=
name|sysset_t_size
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|gdb_premptysysset
argument_list|(
name|sysexit
argument_list|)
expr_stmt|;
name|rsize
operator|=
name|read
argument_list|(
name|pi
operator|->
name|status_fd
argument_list|,
name|sysexit
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsize
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
block|}
block|}
endif|#
directive|endif
comment|/* DYNAMIC_SYSCALLS */
else|#
directive|else
block|{
specifier|static
name|sysset_t
name|sysexit
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCGEXIT
argument_list|,
operator|&
name|sysexit
argument_list|)
operator|>=
literal|0
condition|)
name|ret
operator|=
operator|&
name|sysexit
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|save
operator|&&
name|ret
condition|)
name|memcpy
argument_list|(
name|save
argument_list|,
name|ret
argument_list|,
name|sysset_t_size
argument_list|(
name|pi
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Function: proc_clear_current_fault  *  * The current fault (if any) is cleared; the associated signal  * will not be sent to the process or LWP when it resumes.  * Returns non-zero for success,  zero for failure.  */
end_comment

begin_function
name|int
name|proc_clear_current_fault
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
name|int
name|win
decl_stmt|;
comment|/*    * We should never have to apply this operation to any procinfo    * except the one for the main process.  If that ever changes    * for any reason, then take out the following clause and     * replace it with one that makes sure the ctl_fd is open.    */
if|if
condition|(
name|pi
operator|->
name|tid
operator|!=
literal|0
condition|)
name|pi
operator|=
name|find_procinfo_or_die
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NEW_PROC_API
block|{
name|procfs_ctl_t
name|cmd
init|=
name|PCCFAULT
decl_stmt|;
name|win
operator|=
operator|(
name|write
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
operator|)
expr_stmt|;
block|}
else|#
directive|else
name|win
operator|=
operator|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCCFAULT
argument_list|,
literal|0
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
endif|#
directive|endif
return|return
name|win
return|;
block|}
end_function

begin_comment
comment|/*  * Function: proc_set_current_signal  *  * Set the "current signal" that will be delivered next to the process.  * NOTE: semantics are different from those of KILL.  * This signal will be delivered to the process or LWP  * immediately when it is resumed (even if the signal is held/blocked);  * it will NOT immediately cause another event of interest, and will NOT  * first trap back to the debugger.  *  * Returns non-zero for success,  zero for failure.  */
end_comment

begin_function
name|int
name|proc_set_current_signal
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|int
name|signo
parameter_list|)
block|{
name|int
name|win
decl_stmt|;
struct|struct
block|{
name|procfs_ctl_t
name|cmd
decl_stmt|;
comment|/* Use char array to avoid alignment issues.  */
name|char
name|sinfo
index|[
sizeof|sizeof
argument_list|(
name|gdb_siginfo_t
argument_list|)
index|]
decl_stmt|;
block|}
name|arg
struct|;
name|gdb_siginfo_t
modifier|*
name|mysinfo
decl_stmt|;
comment|/*    * We should never have to apply this operation to any procinfo    * except the one for the main process.  If that ever changes    * for any reason, then take out the following clause and     * replace it with one that makes sure the ctl_fd is open.    */
if|if
condition|(
name|pi
operator|->
name|tid
operator|!=
literal|0
condition|)
name|pi
operator|=
name|find_procinfo_or_die
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROCFS_DONT_PIOCSSIG_CURSIG
comment|/* With Alpha OSF/1 procfs, the kernel gets really confused if it    * receives a PIOCSSIG with a signal identical to the current signal,    * it messes up the current signal. Work around the kernel bug.     */
if|if
condition|(
name|signo
operator|>
literal|0
operator|&&
name|signo
operator|==
name|proc_cursig
argument_list|(
name|pi
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* I assume this is a success? */
endif|#
directive|endif
comment|/* The pointer is just a type alias.  */
name|mysinfo
operator|=
operator|(
name|gdb_siginfo_t
operator|*
operator|)
operator|&
name|arg
operator|.
name|sinfo
expr_stmt|;
name|mysinfo
operator|->
name|si_signo
operator|=
name|signo
expr_stmt|;
name|mysinfo
operator|->
name|si_code
operator|=
literal|0
expr_stmt|;
name|mysinfo
operator|->
name|si_pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
comment|/* ?why? */
name|mysinfo
operator|->
name|si_uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
comment|/* ?why? */
ifdef|#
directive|ifdef
name|NEW_PROC_API
name|arg
operator|.
name|cmd
operator|=
name|PCSSIG
expr_stmt|;
name|win
operator|=
operator|(
name|write
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|arg
argument_list|)
operator|)
expr_stmt|;
else|#
directive|else
name|win
operator|=
operator|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCSSIG
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|arg
operator|.
name|sinfo
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
endif|#
directive|endif
return|return
name|win
return|;
block|}
end_function

begin_comment
comment|/*  * Function: proc_clear_current_signal  *  * The current signal (if any) is cleared, and  * is not sent to the process or LWP when it resumes.  * Returns non-zero for success,  zero for failure.  */
end_comment

begin_function
name|int
name|proc_clear_current_signal
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
name|int
name|win
decl_stmt|;
comment|/*    * We should never have to apply this operation to any procinfo    * except the one for the main process.  If that ever changes    * for any reason, then take out the following clause and     * replace it with one that makes sure the ctl_fd is open.    */
if|if
condition|(
name|pi
operator|->
name|tid
operator|!=
literal|0
condition|)
name|pi
operator|=
name|find_procinfo_or_die
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NEW_PROC_API
block|{
struct|struct
block|{
name|procfs_ctl_t
name|cmd
decl_stmt|;
comment|/* Use char array to avoid alignment issues.  */
name|char
name|sinfo
index|[
sizeof|sizeof
argument_list|(
name|gdb_siginfo_t
argument_list|)
index|]
decl_stmt|;
block|}
name|arg
struct|;
name|gdb_siginfo_t
modifier|*
name|mysinfo
decl_stmt|;
name|arg
operator|.
name|cmd
operator|=
name|PCSSIG
expr_stmt|;
comment|/* The pointer is just a type alias.  */
name|mysinfo
operator|=
operator|(
name|gdb_siginfo_t
operator|*
operator|)
operator|&
name|arg
operator|.
name|sinfo
expr_stmt|;
name|mysinfo
operator|->
name|si_signo
operator|=
literal|0
expr_stmt|;
name|mysinfo
operator|->
name|si_code
operator|=
literal|0
expr_stmt|;
name|mysinfo
operator|->
name|si_errno
operator|=
literal|0
expr_stmt|;
name|mysinfo
operator|->
name|si_pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
comment|/* ?why? */
name|mysinfo
operator|->
name|si_uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
comment|/* ?why? */
name|win
operator|=
operator|(
name|write
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|arg
argument_list|)
operator|)
expr_stmt|;
block|}
else|#
directive|else
name|win
operator|=
operator|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCSSIG
argument_list|,
literal|0
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
endif|#
directive|endif
return|return
name|win
return|;
block|}
end_function

begin_comment
comment|/*  * Function: proc_get_gregs  *  * Get the general registers for the process or LWP.  * Returns non-zero for success, zero for failure.  */
end_comment

begin_function
name|gdb_gregset_t
modifier|*
name|proc_get_gregs
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pi
operator|->
name|status_valid
operator|||
operator|!
name|pi
operator|->
name|gregs_valid
condition|)
if|if
condition|(
operator|!
name|proc_get_status
argument_list|(
name|pi
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/*    * OK, sorry about the ifdef's.    * There's three cases instead of two, because     * in this instance Unixware and Solaris/RW differ.    */
ifdef|#
directive|ifdef
name|NEW_PROC_API
ifdef|#
directive|ifdef
name|UNIXWARE
comment|/* ugh, a true architecture dependency */
return|return
operator|&
name|pi
operator|->
name|prstatus
operator|.
name|pr_lwp
operator|.
name|pr_context
operator|.
name|uc_mcontext
operator|.
name|gregs
return|;
else|#
directive|else
comment|/* not Unixware */
return|return
operator|&
name|pi
operator|->
name|prstatus
operator|.
name|pr_lwp
operator|.
name|pr_reg
return|;
endif|#
directive|endif
comment|/* Unixware */
else|#
directive|else
comment|/* not NEW_PROC_API */
return|return
operator|&
name|pi
operator|->
name|prstatus
operator|.
name|pr_reg
return|;
endif|#
directive|endif
comment|/* NEW_PROC_API */
block|}
end_function

begin_comment
comment|/*  * Function: proc_get_fpregs  *  * Get the floating point registers for the process or LWP.  * Returns non-zero for success, zero for failure.  */
end_comment

begin_function
name|gdb_fpregset_t
modifier|*
name|proc_get_fpregs
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|NEW_PROC_API
if|if
condition|(
operator|!
name|pi
operator|->
name|status_valid
operator|||
operator|!
name|pi
operator|->
name|fpregs_valid
condition|)
if|if
condition|(
operator|!
name|proc_get_status
argument_list|(
name|pi
argument_list|)
condition|)
return|return
name|NULL
return|;
ifdef|#
directive|ifdef
name|UNIXWARE
comment|/* a true architecture dependency */
return|return
operator|&
name|pi
operator|->
name|prstatus
operator|.
name|pr_lwp
operator|.
name|pr_context
operator|.
name|uc_mcontext
operator|.
name|fpregs
return|;
else|#
directive|else
return|return
operator|&
name|pi
operator|->
name|prstatus
operator|.
name|pr_lwp
operator|.
name|pr_fpreg
return|;
endif|#
directive|endif
comment|/* Unixware */
else|#
directive|else
comment|/* not NEW_PROC_API */
if|if
condition|(
name|pi
operator|->
name|fpregs_valid
condition|)
return|return
operator|&
name|pi
operator|->
name|fpregset
return|;
comment|/* already got 'em */
else|else
block|{
if|if
condition|(
name|pi
operator|->
name|ctl_fd
operator|==
literal|0
operator|&&
name|open_procinfo_files
argument_list|(
name|pi
argument_list|,
name|FD_CTL
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|NULL
return|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|PIOCTGFPREG
struct|struct
block|{
name|long
name|pr_count
decl_stmt|;
name|tid_t
name|pr_error_thread
decl_stmt|;
name|tfpregset_t
name|thread_1
decl_stmt|;
block|}
name|thread_fpregs
struct|;
name|thread_fpregs
operator|.
name|pr_count
operator|=
literal|1
expr_stmt|;
name|thread_fpregs
operator|.
name|thread_1
operator|.
name|tid
operator|=
name|pi
operator|->
name|tid
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|tid
operator|==
literal|0
operator|&&
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCGFPREG
argument_list|,
operator|&
name|pi
operator|->
name|fpregset
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|pi
operator|->
name|fpregs_valid
operator|=
literal|1
expr_stmt|;
return|return
operator|&
name|pi
operator|->
name|fpregset
return|;
comment|/* got 'em now! */
block|}
elseif|else
if|if
condition|(
name|pi
operator|->
name|tid
operator|!=
literal|0
operator|&&
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCTGFPREG
argument_list|,
operator|&
name|thread_fpregs
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|pi
operator|->
name|fpregset
argument_list|,
operator|&
name|thread_fpregs
operator|.
name|thread_1
operator|.
name|pr_fpregs
argument_list|,
sizeof|sizeof
argument_list|(
name|pi
operator|->
name|fpregset
argument_list|)
argument_list|)
expr_stmt|;
name|pi
operator|->
name|fpregs_valid
operator|=
literal|1
expr_stmt|;
return|return
operator|&
name|pi
operator|->
name|fpregset
return|;
comment|/* got 'em now! */
block|}
else|else
block|{
return|return
name|NULL
return|;
block|}
else|#
directive|else
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCGFPREG
argument_list|,
operator|&
name|pi
operator|->
name|fpregset
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|pi
operator|->
name|fpregs_valid
operator|=
literal|1
expr_stmt|;
return|return
operator|&
name|pi
operator|->
name|fpregset
return|;
comment|/* got 'em now! */
block|}
else|else
block|{
return|return
name|NULL
return|;
block|}
endif|#
directive|endif
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Function: proc_set_gregs  *  * Write the general registers back to the process or LWP.  * Returns non-zero for success, zero for failure.  */
end_comment

begin_function
name|int
name|proc_set_gregs
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
name|gdb_gregset_t
modifier|*
name|gregs
decl_stmt|;
name|int
name|win
decl_stmt|;
if|if
condition|(
operator|(
name|gregs
operator|=
name|proc_get_gregs
argument_list|(
name|pi
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* get_regs has already warned */
if|if
condition|(
name|pi
operator|->
name|ctl_fd
operator|==
literal|0
operator|&&
name|open_procinfo_files
argument_list|(
name|pi
argument_list|,
name|FD_CTL
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|NEW_PROC_API
struct|struct
block|{
name|procfs_ctl_t
name|cmd
decl_stmt|;
comment|/* Use char array to avoid alignment issues.  */
name|char
name|gregs
index|[
sizeof|sizeof
argument_list|(
name|gdb_gregset_t
argument_list|)
index|]
decl_stmt|;
block|}
name|arg
struct|;
name|arg
operator|.
name|cmd
operator|=
name|PCSREG
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|arg
operator|.
name|gregs
argument_list|,
name|gregs
argument_list|,
sizeof|sizeof
argument_list|(
name|arg
operator|.
name|gregs
argument_list|)
argument_list|)
expr_stmt|;
name|win
operator|=
operator|(
name|write
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|arg
argument_list|)
operator|)
expr_stmt|;
else|#
directive|else
name|win
operator|=
operator|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCSREG
argument_list|,
name|gregs
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Policy: writing the regs invalidates our cache. */
name|pi
operator|->
name|gregs_valid
operator|=
literal|0
expr_stmt|;
return|return
name|win
return|;
block|}
end_function

begin_comment
comment|/*  * Function: proc_set_fpregs  *  * Modify the floating point register set of the process or LWP.  * Returns non-zero for success, zero for failure.  */
end_comment

begin_function
name|int
name|proc_set_fpregs
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
name|gdb_fpregset_t
modifier|*
name|fpregs
decl_stmt|;
name|int
name|win
decl_stmt|;
if|if
condition|(
operator|(
name|fpregs
operator|=
name|proc_get_fpregs
argument_list|(
name|pi
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* get_fpregs has already warned */
if|if
condition|(
name|pi
operator|->
name|ctl_fd
operator|==
literal|0
operator|&&
name|open_procinfo_files
argument_list|(
name|pi
argument_list|,
name|FD_CTL
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|NEW_PROC_API
struct|struct
block|{
name|procfs_ctl_t
name|cmd
decl_stmt|;
comment|/* Use char array to avoid alignment issues.  */
name|char
name|fpregs
index|[
sizeof|sizeof
argument_list|(
name|gdb_fpregset_t
argument_list|)
index|]
decl_stmt|;
block|}
name|arg
struct|;
name|arg
operator|.
name|cmd
operator|=
name|PCSFPREG
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|arg
operator|.
name|fpregs
argument_list|,
name|fpregs
argument_list|,
sizeof|sizeof
argument_list|(
name|arg
operator|.
name|fpregs
argument_list|)
argument_list|)
expr_stmt|;
name|win
operator|=
operator|(
name|write
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|arg
argument_list|)
operator|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|PIOCTSFPREG
if|if
condition|(
name|pi
operator|->
name|tid
operator|==
literal|0
condition|)
name|win
operator|=
operator|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCSFPREG
argument_list|,
name|fpregs
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
else|else
block|{
struct|struct
block|{
name|long
name|pr_count
decl_stmt|;
name|tid_t
name|pr_error_thread
decl_stmt|;
name|tfpregset_t
name|thread_1
decl_stmt|;
block|}
name|thread_fpregs
struct|;
name|thread_fpregs
operator|.
name|pr_count
operator|=
literal|1
expr_stmt|;
name|thread_fpregs
operator|.
name|thread_1
operator|.
name|tid
operator|=
name|pi
operator|->
name|tid
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|thread_fpregs
operator|.
name|thread_1
operator|.
name|pr_fpregs
argument_list|,
name|fpregs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fpregs
argument_list|)
argument_list|)
expr_stmt|;
name|win
operator|=
operator|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCTSFPREG
argument_list|,
operator|&
name|thread_fpregs
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
block|}
else|#
directive|else
name|win
operator|=
operator|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCSFPREG
argument_list|,
name|fpregs
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* osf PIOCTSFPREG */
endif|#
directive|endif
comment|/* NEW_PROC_API */
block|}
comment|/* Policy: writing the regs invalidates our cache. */
name|pi
operator|->
name|fpregs_valid
operator|=
literal|0
expr_stmt|;
return|return
name|win
return|;
block|}
end_function

begin_comment
comment|/*  * Function: proc_kill  *  * Send a signal to the proc or lwp with the semantics of "kill()".  * Returns non-zero for success,  zero for failure.  */
end_comment

begin_function
name|int
name|proc_kill
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|int
name|signo
parameter_list|)
block|{
name|int
name|win
decl_stmt|;
comment|/*    * We might conceivably apply this operation to an LWP, and    * the LWP's ctl file descriptor might not be open.    */
if|if
condition|(
name|pi
operator|->
name|ctl_fd
operator|==
literal|0
operator|&&
name|open_procinfo_files
argument_list|(
name|pi
argument_list|,
name|FD_CTL
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|NEW_PROC_API
name|procfs_ctl_t
name|cmd
index|[
literal|2
index|]
decl_stmt|;
name|cmd
index|[
literal|0
index|]
operator|=
name|PCKILL
expr_stmt|;
name|cmd
index|[
literal|1
index|]
operator|=
name|signo
expr_stmt|;
name|win
operator|=
operator|(
name|write
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
operator|)
expr_stmt|;
else|#
directive|else
comment|/* ioctl method */
comment|/* FIXME: do I need the Alpha OSF fixups present in 	 procfs.c/unconditionally_kill_inferior?  Perhaps only for SIGKILL? */
name|win
operator|=
operator|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCKILL
argument_list|,
operator|&
name|signo
argument_list|)
operator|>=
literal|0
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
name|win
return|;
block|}
end_function

begin_comment
comment|/*  * Function: proc_parent_pid  *  * Find the pid of the process that started this one.  * Returns the parent process pid, or zero.  */
end_comment

begin_function
name|int
name|proc_parent_pid
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
comment|/*    * We should never have to apply this operation to any procinfo    * except the one for the main process.  If that ever changes    * for any reason, then take out the following clause and     * replace it with one that makes sure the ctl_fd is open.    */
if|if
condition|(
name|pi
operator|->
name|tid
operator|!=
literal|0
condition|)
name|pi
operator|=
name|find_procinfo_or_die
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pi
operator|->
name|status_valid
condition|)
if|if
condition|(
operator|!
name|proc_get_status
argument_list|(
name|pi
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|pi
operator|->
name|prstatus
operator|.
name|pr_ppid
return|;
block|}
end_function

begin_comment
comment|/*  * Function: proc_set_watchpoint  *  */
end_comment

begin_function
name|int
name|proc_set_watchpoint
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|wflags
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TARGET_HAS_HARDWARE_WATCHPOINTS
argument_list|)
return|return
literal|0
return|;
else|#
directive|else
comment|/* Horrible hack!  Detect Solaris 2.5, because this doesn't work on 2.5 */
if|#
directive|if
name|defined
argument_list|(
name|PIOCOPENLWP
argument_list|)
operator|||
name|defined
argument_list|(
name|UNIXWARE
argument_list|)
comment|/* Solaris 2.5: bail out */
return|return
literal|0
return|;
else|#
directive|else
struct|struct
block|{
name|procfs_ctl_t
name|cmd
decl_stmt|;
name|char
name|watch
index|[
sizeof|sizeof
argument_list|(
name|prwatch_t
argument_list|)
index|]
decl_stmt|;
block|}
name|arg
struct|;
name|prwatch_t
modifier|*
name|pwatch
decl_stmt|;
name|pwatch
operator|=
operator|(
name|prwatch_t
operator|*
operator|)
operator|&
name|arg
operator|.
name|watch
expr_stmt|;
ifdef|#
directive|ifdef
name|PCAGENT
comment|/* Horrible hack: only defined on Solaris 2.6+ */
name|pwatch
operator|->
name|pr_vaddr
operator|=
operator|(
name|uintptr_t
operator|)
name|address_to_host_pointer
argument_list|(
name|addr
argument_list|)
expr_stmt|;
else|#
directive|else
name|pwatch
operator|->
name|pr_vaddr
operator|=
operator|(
name|caddr_t
operator|)
name|address_to_host_pointer
argument_list|(
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pwatch
operator|->
name|pr_size
operator|=
name|len
expr_stmt|;
name|pwatch
operator|->
name|pr_wflags
operator|=
name|wflags
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|NEW_PROC_API
argument_list|)
operator|&&
name|defined
argument_list|(
name|PCWATCH
argument_list|)
name|arg
operator|.
name|cmd
operator|=
name|PCWATCH
expr_stmt|;
return|return
operator|(
name|write
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
operator|&
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|arg
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|arg
argument_list|)
operator|)
return|;
else|#
directive|else
if|#
directive|if
name|defined
argument_list|(
name|PIOCSWATCH
argument_list|)
return|return
operator|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCSWATCH
argument_list|,
name|pwatch
argument_list|)
operator|>=
literal|0
operator|)
return|;
else|#
directive|else
return|return
literal|0
return|;
comment|/* Fail */
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TM_I386SOL2_H
end_ifdef

begin_comment
comment|/* Is it hokey to use this? */
end_comment

begin_include
include|#
directive|include
file|<sys/sysi86.h>
end_include

begin_comment
comment|/*  * Function: proc_get_LDT_entry  *  * Inputs:  *   procinfo *pi;  *   int key;  *  * The 'key' is actually the value of the lower 16 bits of  * the GS register for the LWP that we're interested in.  *  * Return: matching ssh struct (LDT entry).  */
end_comment

begin_function
name|struct
name|ssd
modifier|*
name|proc_get_LDT_entry
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|int
name|key
parameter_list|)
block|{
specifier|static
name|struct
name|ssd
modifier|*
name|ldt_entry
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|NEW_PROC_API
name|char
name|pathname
index|[
name|MAX_PROC_NAME_SIZE
index|]
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|NULL
decl_stmt|;
name|int
name|fd
decl_stmt|;
comment|/* Allocate space for one LDT entry.      This alloc must persist, because we return a pointer to it.  */
if|if
condition|(
name|ldt_entry
operator|==
name|NULL
condition|)
name|ldt_entry
operator|=
operator|(
expr|struct
name|ssd
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ssd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Open the file descriptor for the LDT table.  */
name|sprintf
argument_list|(
name|pathname
argument_list|,
literal|"/proc/%d/ldt"
argument_list|,
name|pi
operator|->
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open_with_retry
argument_list|(
name|pathname
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|proc_warn
argument_list|(
name|pi
argument_list|,
literal|"proc_get_LDT_entry (open)"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Make sure it gets closed again! */
name|old_chain
operator|=
name|make_cleanup_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* Now 'read' thru the table, find a match and return it.  */
while|while
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|ldt_entry
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ssd
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|ssd
argument_list|)
condition|)
block|{
if|if
condition|(
name|ldt_entry
operator|->
name|sel
operator|==
literal|0
operator|&&
name|ldt_entry
operator|->
name|bo
operator|==
literal|0
operator|&&
name|ldt_entry
operator|->
name|acc1
operator|==
literal|0
operator|&&
name|ldt_entry
operator|->
name|acc2
operator|==
literal|0
condition|)
break|break;
comment|/* end of table */
comment|/* If key matches, return this entry. */
if|if
condition|(
name|ldt_entry
operator|->
name|sel
operator|==
name|key
condition|)
return|return
name|ldt_entry
return|;
block|}
comment|/* Loop ended, match not found. */
return|return
name|NULL
return|;
else|#
directive|else
name|int
name|nldt
decl_stmt|,
name|i
decl_stmt|;
specifier|static
name|int
name|nalloc
init|=
literal|0
decl_stmt|;
comment|/* Get the number of LDT entries.  */
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCNLDT
argument_list|,
operator|&
name|nldt
argument_list|)
operator|<
literal|0
condition|)
block|{
name|proc_warn
argument_list|(
name|pi
argument_list|,
literal|"proc_get_LDT_entry (PIOCNLDT)"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Allocate space for the number of LDT entries. */
comment|/* This alloc has to persist, 'cause we return a pointer to it. */
if|if
condition|(
name|nldt
operator|>
name|nalloc
condition|)
block|{
name|ldt_entry
operator|=
operator|(
expr|struct
name|ssd
operator|*
operator|)
name|xrealloc
argument_list|(
name|ldt_entry
argument_list|,
operator|(
name|nldt
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ssd
argument_list|)
argument_list|)
expr_stmt|;
name|nalloc
operator|=
name|nldt
expr_stmt|;
block|}
comment|/* Read the whole table in one gulp.  */
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCLDT
argument_list|,
name|ldt_entry
argument_list|)
operator|<
literal|0
condition|)
block|{
name|proc_warn
argument_list|(
name|pi
argument_list|,
literal|"proc_get_LDT_entry (PIOCLDT)"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Search the table and return the (first) entry matching 'key'. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nldt
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ldt_entry
index|[
name|i
index|]
operator|.
name|sel
operator|==
name|key
condition|)
return|return
operator|&
name|ldt_entry
index|[
name|i
index|]
return|;
comment|/* Loop ended, match not found. */
return|return
name|NULL
return|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TM_I386SOL2_H */
end_comment

begin_comment
comment|/* =============== END, non-thread part of /proc  "MODULE" =============== */
end_comment

begin_comment
comment|/* =================== Thread "MODULE" =================== */
end_comment

begin_comment
comment|/* NOTE: you'll see more ifdefs and duplication of functions here,    since there is a different way to do threads on every OS.  */
end_comment

begin_comment
comment|/*  * Function: proc_get_nthreads   *  * Return the number of threads for the process   */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PIOCNTHR
argument_list|)
operator|&&
name|defined
argument_list|(
name|PIOCTLIST
argument_list|)
end_if

begin_comment
comment|/*  * OSF version  */
end_comment

begin_function
name|int
name|proc_get_nthreads
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
name|int
name|nthreads
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCNTHR
argument_list|,
operator|&
name|nthreads
argument_list|)
operator|<
literal|0
condition|)
name|proc_warn
argument_list|(
name|pi
argument_list|,
literal|"procfs: PIOCNTHR failed"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return
name|nthreads
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SYS_lwpcreate
argument_list|)
operator|||
name|defined
argument_list|(
name|SYS_lwp_create
argument_list|)
end_if

begin_comment
comment|/* FIXME: multiple */
end_comment

begin_comment
comment|/*  * Solaris and Unixware version  */
end_comment

begin_function
name|int
name|proc_get_nthreads
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pi
operator|->
name|status_valid
condition|)
if|if
condition|(
operator|!
name|proc_get_status
argument_list|(
name|pi
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/*    * NEW_PROC_API: only works for the process procinfo,     * because the LWP procinfos do not get prstatus filled in.    */
ifdef|#
directive|ifdef
name|NEW_PROC_API
if|if
condition|(
name|pi
operator|->
name|tid
operator|!=
literal|0
condition|)
comment|/* find the parent process procinfo */
name|pi
operator|=
name|find_procinfo_or_die
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|pi
operator|->
name|prstatus
operator|.
name|pr_nlwp
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*  * Default version  */
end_comment

begin_function
name|int
name|proc_get_nthreads
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Function: proc_get_current_thread (LWP version)  *  * Return the ID of the thread that had an event of interest.  * (ie. the one that hit a breakpoint or other traced event).  * All other things being equal, this should be the ID of a  * thread that is currently executing.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SYS_lwpcreate
argument_list|)
operator|||
name|defined
argument_list|(
name|SYS_lwp_create
argument_list|)
end_if

begin_comment
comment|/* FIXME: multiple */
end_comment

begin_comment
comment|/*  * Solaris and Unixware version  */
end_comment

begin_function
name|int
name|proc_get_current_thread
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
comment|/*    * Note: this should be applied to the root procinfo for the process,    * not to the procinfo for an LWP.  If applied to the procinfo for    * an LWP, it will simply return that LWP's ID.  In that case,     * find the parent process procinfo.    */
if|if
condition|(
name|pi
operator|->
name|tid
operator|!=
literal|0
condition|)
name|pi
operator|=
name|find_procinfo_or_die
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pi
operator|->
name|status_valid
condition|)
if|if
condition|(
operator|!
name|proc_get_status
argument_list|(
name|pi
argument_list|)
condition|)
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|NEW_PROC_API
return|return
name|pi
operator|->
name|prstatus
operator|.
name|pr_lwp
operator|.
name|pr_lwpid
return|;
else|#
directive|else
return|return
name|pi
operator|->
name|prstatus
operator|.
name|pr_who
return|;
endif|#
directive|endif
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PIOCNTHR
argument_list|)
operator|&&
name|defined
argument_list|(
name|PIOCTLIST
argument_list|)
end_if

begin_comment
comment|/*  * OSF version  */
end_comment

begin_function
name|int
name|proc_get_current_thread
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
if|#
directive|if
literal|0
comment|/* FIXME: not ready for prime time? */
block|return pi->prstatus.pr_tid;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*  * Default version  */
end_comment

begin_function
name|int
name|proc_get_current_thread
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Function: proc_update_threads   *  * Discover the IDs of all the threads within the process, and  * create a procinfo for each of them (chained to the parent).  *  * This unfortunately requires a different method on every OS.  *  * Return: non-zero for success, zero for failure.  */
end_comment

begin_function
name|int
name|proc_delete_dead_threads
parameter_list|(
name|procinfo
modifier|*
name|parent
parameter_list|,
name|procinfo
modifier|*
name|thread
parameter_list|,
name|void
modifier|*
name|ignore
parameter_list|)
block|{
if|if
condition|(
name|thread
operator|&&
name|parent
condition|)
comment|/* sanity */
block|{
name|thread
operator|->
name|status_valid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|proc_get_status
argument_list|(
name|thread
argument_list|)
condition|)
name|destroy_one_procinfo
argument_list|(
operator|&
name|parent
operator|->
name|thread_list
argument_list|,
name|thread
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
comment|/* keep iterating */
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|PIOCLSTATUS
argument_list|)
end_if

begin_comment
comment|/*  * Solaris 2.5 (ioctl) version  */
end_comment

begin_function
name|int
name|proc_update_threads
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
name|gdb_prstatus_t
modifier|*
name|prstatus
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|NULL
decl_stmt|;
name|procinfo
modifier|*
name|thread
decl_stmt|;
name|int
name|nlwp
decl_stmt|,
name|i
decl_stmt|;
comment|/*    * We should never have to apply this operation to any procinfo    * except the one for the main process.  If that ever changes    * for any reason, then take out the following clause and     * replace it with one that makes sure the ctl_fd is open.    */
if|if
condition|(
name|pi
operator|->
name|tid
operator|!=
literal|0
condition|)
name|pi
operator|=
name|find_procinfo_or_die
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|proc_iterate_over_threads
argument_list|(
name|pi
argument_list|,
name|proc_delete_dead_threads
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nlwp
operator|=
name|proc_get_nthreads
argument_list|(
name|pi
argument_list|)
operator|)
operator|<=
literal|1
condition|)
return|return
literal|1
return|;
comment|/* Process is not multi-threaded; nothing to do.  */
name|prstatus
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|gdb_prstatus_t
argument_list|)
operator|*
operator|(
name|nlwp
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|prstatus
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCLSTATUS
argument_list|,
name|prstatus
argument_list|)
operator|<
literal|0
condition|)
name|proc_error
argument_list|(
name|pi
argument_list|,
literal|"update_threads (PIOCLSTATUS)"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
comment|/* Skip element zero, which represents the process as a whole. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nlwp
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|thread
operator|=
name|create_procinfo
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
name|prstatus
index|[
name|i
index|]
operator|.
name|pr_who
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|proc_error
argument_list|(
name|pi
argument_list|,
literal|"update_threads, create_procinfo"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|thread
operator|->
name|prstatus
argument_list|,
operator|&
name|prstatus
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|prstatus
argument_list|)
argument_list|)
expr_stmt|;
name|thread
operator|->
name|status_valid
operator|=
literal|1
expr_stmt|;
block|}
name|pi
operator|->
name|threads_valid
operator|=
literal|1
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|NEW_PROC_API
end_ifdef

begin_comment
comment|/*  * Unixware and Solaris 6 (and later) version  */
end_comment

begin_function
specifier|static
name|void
name|do_closedir_cleanup
parameter_list|(
name|void
modifier|*
name|dir
parameter_list|)
block|{
name|closedir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|proc_update_threads
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
name|char
name|pathname
index|[
name|MAX_PROC_NAME_SIZE
operator|+
literal|16
index|]
decl_stmt|;
name|struct
name|dirent
modifier|*
name|direntry
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
init|=
name|NULL
decl_stmt|;
name|procinfo
modifier|*
name|thread
decl_stmt|;
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|int
name|lwpid
decl_stmt|;
comment|/*    * We should never have to apply this operation to any procinfo    * except the one for the main process.  If that ever changes    * for any reason, then take out the following clause and     * replace it with one that makes sure the ctl_fd is open.    */
if|if
condition|(
name|pi
operator|->
name|tid
operator|!=
literal|0
condition|)
name|pi
operator|=
name|find_procinfo_or_die
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|proc_iterate_over_threads
argument_list|(
name|pi
argument_list|,
name|proc_delete_dead_threads
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*    * Unixware    *    * Note: this brute-force method is the only way I know of     * to accomplish this task on Unixware.  This method will     * also work on Solaris 2.6 and 2.7.  There is a much simpler    * and more elegant way to do this on Solaris, but the margins    * of this manuscript are too small to write it here...  ;-)    */
name|strcpy
argument_list|(
name|pathname
argument_list|,
name|pi
operator|->
name|pathname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|pathname
argument_list|,
literal|"/lwp"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dirp
operator|=
name|opendir
argument_list|(
name|pathname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|proc_error
argument_list|(
name|pi
argument_list|,
literal|"update_threads, opendir"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|do_closedir_cleanup
argument_list|,
name|dirp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|direntry
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|direntry
operator|->
name|d_name
index|[
literal|0
index|]
operator|!=
literal|'.'
condition|)
comment|/* skip '.' and '..' */
block|{
name|lwpid
operator|=
name|atoi
argument_list|(
operator|&
name|direntry
operator|->
name|d_name
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|thread
operator|=
name|create_procinfo
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
name|lwpid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|proc_error
argument_list|(
name|pi
argument_list|,
literal|"update_threads, create_procinfo"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
name|pi
operator|->
name|threads_valid
operator|=
literal|1
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|PIOCTLIST
end_ifdef

begin_comment
comment|/*  * OSF version  */
end_comment

begin_function
name|int
name|proc_update_threads
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
name|int
name|nthreads
decl_stmt|,
name|i
decl_stmt|;
name|tid_t
modifier|*
name|threads
decl_stmt|;
comment|/*    * We should never have to apply this operation to any procinfo    * except the one for the main process.  If that ever changes    * for any reason, then take out the following clause and     * replace it with one that makes sure the ctl_fd is open.    */
if|if
condition|(
name|pi
operator|->
name|tid
operator|!=
literal|0
condition|)
name|pi
operator|=
name|find_procinfo_or_die
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|proc_iterate_over_threads
argument_list|(
name|pi
argument_list|,
name|proc_delete_dead_threads
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nthreads
operator|=
name|proc_get_nthreads
argument_list|(
name|pi
argument_list|)
expr_stmt|;
if|if
condition|(
name|nthreads
operator|<
literal|2
condition|)
return|return
literal|0
return|;
comment|/* nothing to do for 1 or fewer threads */
name|threads
operator|=
name|xmalloc
argument_list|(
name|nthreads
operator|*
sizeof|sizeof
argument_list|(
name|tid_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCTLIST
argument_list|,
name|threads
argument_list|)
operator|<
literal|0
condition|)
name|proc_error
argument_list|(
name|pi
argument_list|,
literal|"procfs: update_threads (PIOCTLIST)"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nthreads
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|find_procinfo
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
name|threads
index|[
name|i
index|]
argument_list|)
condition|)
if|if
condition|(
operator|!
name|create_procinfo
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
name|threads
index|[
name|i
index|]
argument_list|)
condition|)
name|proc_error
argument_list|(
name|pi
argument_list|,
literal|"update_threads, create_procinfo"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
name|pi
operator|->
name|threads_valid
operator|=
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*  * Default version  */
end_comment

begin_function
name|int
name|proc_update_threads
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* OSF PIOCTLIST */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NEW_PROC_API   */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SOL 2.5 PIOCLSTATUS */
end_comment

begin_comment
comment|/*  * Function: proc_iterate_over_threads  *  * Description:  *   Given a pointer to a function, call that function once  *   for each lwp in the procinfo list, until the function  *   returns non-zero, in which event return the value  *   returned by the function.  *  * Note: this function does NOT call update_threads.  * If you want to discover new threads first, you must  * call that function explicitly.  This function just makes  * a quick pass over the currently-known procinfos.   *   * Arguments:  *   pi		- parent process procinfo  *   func	- per-thread function  *   ptr	- opaque parameter for function.  *  * Return:  *   First non-zero return value from the callee, or zero.  */
end_comment

begin_function
name|int
name|proc_iterate_over_threads
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|procinfo
modifier|*
parameter_list|,
name|procinfo
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|procinfo
modifier|*
name|thread
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
comment|/*    * We should never have to apply this operation to any procinfo    * except the one for the main process.  If that ever changes    * for any reason, then take out the following clause and     * replace it with one that makes sure the ctl_fd is open.    */
if|if
condition|(
name|pi
operator|->
name|tid
operator|!=
literal|0
condition|)
name|pi
operator|=
name|find_procinfo_or_die
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|thread
operator|=
name|pi
operator|->
name|thread_list
init|;
name|thread
operator|!=
name|NULL
condition|;
name|thread
operator|=
name|next
control|)
block|{
name|next
operator|=
name|thread
operator|->
name|next
expr_stmt|;
comment|/* in case thread is destroyed */
if|if
condition|(
operator|(
name|retval
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|pi
argument_list|,
name|thread
argument_list|,
name|ptr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* =================== END, Thread "MODULE" =================== */
end_comment

begin_comment
comment|/* =================== END, /proc  "MODULE" =================== */
end_comment

begin_comment
comment|/* ===================  GDB  "MODULE" =================== */
end_comment

begin_comment
comment|/*  * Here are all of the gdb target vector functions and their friends.  */
end_comment

begin_function_decl
specifier|static
name|ptid_t
name|do_attach
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|do_detach
parameter_list|(
name|int
name|signo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|register_gdb_signals
parameter_list|(
name|procinfo
modifier|*
parameter_list|,
name|gdb_sigset_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Function: procfs_debug_inferior  *  * Sets up the inferior to be debugged.  * Registers to trace signals, hardware faults, and syscalls.  * Note: does not set RLC flag: caller may want to customize that.  *  * Returns: zero for success (note! unlike most functions in this module)  *   On failure, returns the LINE NUMBER where it failed!  */
end_comment

begin_function
specifier|static
name|int
name|procfs_debug_inferior
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
name|fltset_t
name|traced_faults
decl_stmt|;
name|gdb_sigset_t
name|traced_signals
decl_stmt|;
name|sysset_t
modifier|*
name|traced_syscall_entries
decl_stmt|;
name|sysset_t
modifier|*
name|traced_syscall_exits
decl_stmt|;
name|int
name|status
decl_stmt|;
ifdef|#
directive|ifdef
name|PROCFS_DONT_TRACE_FAULTS
comment|/* On some systems (OSF), we don't trace hardware faults.      Apparently it's enough that we catch them as signals.      Wonder why we don't just do that in general? */
name|premptyset
argument_list|(
operator|&
name|traced_faults
argument_list|)
expr_stmt|;
comment|/* don't trace faults. */
else|#
directive|else
comment|/* Register to trace hardware faults in the child. */
name|prfillset
argument_list|(
operator|&
name|traced_faults
argument_list|)
expr_stmt|;
comment|/* trace all faults... */
name|prdelset
argument_list|(
operator|&
name|traced_faults
argument_list|,
name|FLTPAGE
argument_list|)
expr_stmt|;
comment|/* except page fault.  */
endif|#
directive|endif
if|if
condition|(
operator|!
name|proc_set_traced_faults
argument_list|(
name|pi
argument_list|,
operator|&
name|traced_faults
argument_list|)
condition|)
return|return
name|__LINE__
return|;
comment|/* Register to trace selected signals in the child. */
name|premptyset
argument_list|(
operator|&
name|traced_signals
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|register_gdb_signals
argument_list|(
name|pi
argument_list|,
operator|&
name|traced_signals
argument_list|)
condition|)
return|return
name|__LINE__
return|;
comment|/* Register to trace the 'exit' system call (on entry).  */
name|traced_syscall_entries
operator|=
name|sysset_t_alloc
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|gdb_premptysysset
argument_list|(
name|traced_syscall_entries
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SYS_exit
name|gdb_praddsysset
argument_list|(
name|traced_syscall_entries
argument_list|,
name|SYS_exit
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYS_lwpexit
name|gdb_praddsysset
argument_list|(
name|traced_syscall_entries
argument_list|,
name|SYS_lwpexit
argument_list|)
expr_stmt|;
comment|/* And _lwp_exit... */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYS_lwp_exit
name|gdb_praddsysset
argument_list|(
name|traced_syscall_entries
argument_list|,
name|SYS_lwp_exit
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DYNAMIC_SYSCALLS
block|{
name|int
name|callnum
init|=
name|find_syscall
argument_list|(
name|pi
argument_list|,
literal|"_exit"
argument_list|)
decl_stmt|;
if|if
condition|(
name|callnum
operator|>=
literal|0
condition|)
name|gdb_praddsysset
argument_list|(
name|traced_syscall_entries
argument_list|,
name|callnum
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|status
operator|=
name|proc_set_traced_sysentry
argument_list|(
name|pi
argument_list|,
name|traced_syscall_entries
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|traced_syscall_entries
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|status
condition|)
return|return
name|__LINE__
return|;
ifdef|#
directive|ifdef
name|PRFS_STOPEXEC
comment|/* defined on OSF */
comment|/* OSF method for tracing exec syscalls.  Quoting:      Under Alpha OSF/1 we have to use a PIOCSSPCACT ioctl to trace      exits from exec system calls because of the user level loader.  */
comment|/* FIXME: make nice and maybe move into an access function. */
block|{
name|int
name|prfs_flags
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCGSPCACT
argument_list|,
operator|&
name|prfs_flags
argument_list|)
operator|<
literal|0
condition|)
return|return
name|__LINE__
return|;
name|prfs_flags
operator||=
name|PRFS_STOPEXEC
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCSSPCACT
argument_list|,
operator|&
name|prfs_flags
argument_list|)
operator|<
literal|0
condition|)
return|return
name|__LINE__
return|;
block|}
else|#
directive|else
comment|/* not PRFS_STOPEXEC */
comment|/* Everyone else's (except OSF) method for tracing exec syscalls */
comment|/* GW: Rationale...      Not all systems with /proc have all the exec* syscalls with the same      names.  On the SGI, for example, there is no SYS_exec, but there      *is* a SYS_execv.  So, we try to account for that. */
name|traced_syscall_exits
operator|=
name|sysset_t_alloc
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|gdb_premptysysset
argument_list|(
name|traced_syscall_exits
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SYS_exec
name|gdb_praddsysset
argument_list|(
name|traced_syscall_exits
argument_list|,
name|SYS_exec
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYS_execve
name|gdb_praddsysset
argument_list|(
name|traced_syscall_exits
argument_list|,
name|SYS_execve
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYS_execv
name|gdb_praddsysset
argument_list|(
name|traced_syscall_exits
argument_list|,
name|SYS_execv
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYS_lwpcreate
name|gdb_praddsysset
argument_list|(
name|traced_syscall_exits
argument_list|,
name|SYS_lwpcreate
argument_list|)
expr_stmt|;
name|gdb_praddsysset
argument_list|(
name|traced_syscall_exits
argument_list|,
name|SYS_lwpexit
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYS_lwp_create
comment|/* FIXME: once only, please */
name|gdb_praddsysset
argument_list|(
name|traced_syscall_exits
argument_list|,
name|SYS_lwp_create
argument_list|)
expr_stmt|;
name|gdb_praddsysset
argument_list|(
name|traced_syscall_exits
argument_list|,
name|SYS_lwp_exit
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DYNAMIC_SYSCALLS
block|{
name|int
name|callnum
init|=
name|find_syscall
argument_list|(
name|pi
argument_list|,
literal|"execve"
argument_list|)
decl_stmt|;
if|if
condition|(
name|callnum
operator|>=
literal|0
condition|)
name|gdb_praddsysset
argument_list|(
name|traced_syscall_exits
argument_list|,
name|callnum
argument_list|)
expr_stmt|;
name|callnum
operator|=
name|find_syscall
argument_list|(
name|pi
argument_list|,
literal|"ra_execve"
argument_list|)
expr_stmt|;
if|if
condition|(
name|callnum
operator|>=
literal|0
condition|)
name|gdb_praddsysset
argument_list|(
name|traced_syscall_exits
argument_list|,
name|callnum
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|status
operator|=
name|proc_set_traced_sysexit
argument_list|(
name|pi
argument_list|,
name|traced_syscall_exits
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|traced_syscall_exits
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|status
condition|)
return|return
name|__LINE__
return|;
endif|#
directive|endif
comment|/* PRFS_STOPEXEC */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|procfs_attach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
modifier|*
name|exec_file
decl_stmt|;
name|int
name|pid
decl_stmt|;
if|if
condition|(
operator|!
name|args
condition|)
name|error_no_arg
argument_list|(
literal|"process-id to attach"
argument_list|)
expr_stmt|;
name|pid
operator|=
name|atoi
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
name|getpid
argument_list|()
condition|)
name|error
argument_list|(
literal|"Attaching GDB to itself is not a good idea..."
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|exec_file
operator|=
name|get_exec_file
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|exec_file
condition|)
name|printf_filtered
argument_list|(
literal|"Attaching to program `%s', %s\n"
argument_list|,
name|exec_file
argument_list|,
name|target_pid_to_str
argument_list|(
name|pid_to_ptid
argument_list|(
name|pid
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"Attaching to %s\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|pid_to_ptid
argument_list|(
name|pid
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|inferior_ptid
operator|=
name|do_attach
argument_list|(
name|pid_to_ptid
argument_list|(
name|pid
argument_list|)
argument_list|)
expr_stmt|;
name|push_target
argument_list|(
operator|&
name|procfs_ops
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|procfs_detach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
modifier|*
name|exec_file
decl_stmt|;
name|int
name|signo
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|exec_file
operator|=
name|get_exec_file
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|exec_file
operator|==
literal|0
condition|)
name|exec_file
operator|=
literal|""
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Detaching from program: %s %s\n"
argument_list|,
name|exec_file
argument_list|,
name|target_pid_to_str
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|args
condition|)
name|signo
operator|=
name|atoi
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|do_detach
argument_list|(
name|signo
argument_list|)
expr_stmt|;
name|inferior_ptid
operator|=
name|null_ptid
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|procfs_ops
argument_list|)
expr_stmt|;
comment|/* Pop out of handling an inferior */
block|}
end_function

begin_function
specifier|static
name|ptid_t
name|do_attach
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
name|procinfo
modifier|*
name|pi
decl_stmt|;
name|int
name|fail
decl_stmt|;
if|if
condition|(
operator|(
name|pi
operator|=
name|create_procinfo
argument_list|(
name|PIDGET
argument_list|(
name|ptid
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|perror
argument_list|(
literal|"procfs: out of memory in 'attach'"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|open_procinfo_files
argument_list|(
name|pi
argument_list|,
name|FD_CTL
argument_list|)
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"procfs:%d -- "
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|errmsg
argument_list|,
literal|"do_attach: couldn't open /proc file for process %d"
argument_list|,
name|PIDGET
argument_list|(
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
name|dead_procinfo
argument_list|(
name|pi
argument_list|,
name|errmsg
argument_list|,
name|NOKILL
argument_list|)
expr_stmt|;
block|}
comment|/* Stop the process (if it isn't already stopped).  */
if|if
condition|(
name|proc_flags
argument_list|(
name|pi
argument_list|)
operator|&
operator|(
name|PR_STOPPED
operator||
name|PR_ISTOP
operator|)
condition|)
block|{
name|pi
operator|->
name|was_stopped
operator|=
literal|1
expr_stmt|;
name|proc_prettyprint_why
argument_list|(
name|proc_why
argument_list|(
name|pi
argument_list|)
argument_list|,
name|proc_what
argument_list|(
name|pi
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pi
operator|->
name|was_stopped
operator|=
literal|0
expr_stmt|;
comment|/* Set the process to run again when we close it.  */
if|if
condition|(
operator|!
name|proc_set_run_on_last_close
argument_list|(
name|pi
argument_list|)
condition|)
name|dead_procinfo
argument_list|(
name|pi
argument_list|,
literal|"do_attach: couldn't set RLC."
argument_list|,
name|NOKILL
argument_list|)
expr_stmt|;
comment|/* Now stop the process. */
if|if
condition|(
operator|!
name|proc_stop_process
argument_list|(
name|pi
argument_list|)
condition|)
name|dead_procinfo
argument_list|(
name|pi
argument_list|,
literal|"do_attach: couldn't stop the process."
argument_list|,
name|NOKILL
argument_list|)
expr_stmt|;
name|pi
operator|->
name|ignore_next_sigstop
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Save some of the /proc state to be restored if we detach.  */
if|if
condition|(
operator|!
name|proc_get_traced_faults
argument_list|(
name|pi
argument_list|,
operator|&
name|pi
operator|->
name|saved_fltset
argument_list|)
condition|)
name|dead_procinfo
argument_list|(
name|pi
argument_list|,
literal|"do_attach: couldn't save traced faults."
argument_list|,
name|NOKILL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|proc_get_traced_signals
argument_list|(
name|pi
argument_list|,
operator|&
name|pi
operator|->
name|saved_sigset
argument_list|)
condition|)
name|dead_procinfo
argument_list|(
name|pi
argument_list|,
literal|"do_attach: couldn't save traced signals."
argument_list|,
name|NOKILL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|proc_get_traced_sysentry
argument_list|(
name|pi
argument_list|,
name|pi
operator|->
name|saved_entryset
argument_list|)
condition|)
name|dead_procinfo
argument_list|(
name|pi
argument_list|,
literal|"do_attach: couldn't save traced syscall entries."
argument_list|,
name|NOKILL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|proc_get_traced_sysexit
argument_list|(
name|pi
argument_list|,
name|pi
operator|->
name|saved_exitset
argument_list|)
condition|)
name|dead_procinfo
argument_list|(
name|pi
argument_list|,
literal|"do_attach: couldn't save traced syscall exits."
argument_list|,
name|NOKILL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|proc_get_held_signals
argument_list|(
name|pi
argument_list|,
operator|&
name|pi
operator|->
name|saved_sighold
argument_list|)
condition|)
name|dead_procinfo
argument_list|(
name|pi
argument_list|,
literal|"do_attach: couldn't save held signals."
argument_list|,
name|NOKILL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fail
operator|=
name|procfs_debug_inferior
argument_list|(
name|pi
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|dead_procinfo
argument_list|(
name|pi
argument_list|,
literal|"do_attach: failed in procfs_debug_inferior"
argument_list|,
name|NOKILL
argument_list|)
expr_stmt|;
comment|/* Let GDB know that the inferior was attached.  */
name|attach_flag
operator|=
literal|1
expr_stmt|;
return|return
name|MERGEPID
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
name|proc_get_current_thread
argument_list|(
name|pi
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_detach
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
name|procinfo
modifier|*
name|pi
decl_stmt|;
comment|/* Find procinfo for the main process */
name|pi
operator|=
name|find_procinfo_or_die
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* FIXME: threads */
if|if
condition|(
name|signo
condition|)
if|if
condition|(
operator|!
name|proc_set_current_signal
argument_list|(
name|pi
argument_list|,
name|signo
argument_list|)
condition|)
name|proc_warn
argument_list|(
name|pi
argument_list|,
literal|"do_detach, set_current_signal"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|proc_set_traced_signals
argument_list|(
name|pi
argument_list|,
operator|&
name|pi
operator|->
name|saved_sigset
argument_list|)
condition|)
name|proc_warn
argument_list|(
name|pi
argument_list|,
literal|"do_detach, set_traced_signal"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|proc_set_traced_faults
argument_list|(
name|pi
argument_list|,
operator|&
name|pi
operator|->
name|saved_fltset
argument_list|)
condition|)
name|proc_warn
argument_list|(
name|pi
argument_list|,
literal|"do_detach, set_traced_faults"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|proc_set_traced_sysentry
argument_list|(
name|pi
argument_list|,
name|pi
operator|->
name|saved_entryset
argument_list|)
condition|)
name|proc_warn
argument_list|(
name|pi
argument_list|,
literal|"do_detach, set_traced_sysentry"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|proc_set_traced_sysexit
argument_list|(
name|pi
argument_list|,
name|pi
operator|->
name|saved_exitset
argument_list|)
condition|)
name|proc_warn
argument_list|(
name|pi
argument_list|,
literal|"do_detach, set_traced_sysexit"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|proc_set_held_signals
argument_list|(
name|pi
argument_list|,
operator|&
name|pi
operator|->
name|saved_sighold
argument_list|)
condition|)
name|proc_warn
argument_list|(
name|pi
argument_list|,
literal|"do_detach, set_held_signals"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
if|if
condition|(
name|signo
operator|||
operator|(
name|proc_flags
argument_list|(
name|pi
argument_list|)
operator|&
operator|(
name|PR_STOPPED
operator||
name|PR_ISTOP
operator|)
operator|)
condition|)
if|if
condition|(
name|signo
operator|||
operator|!
operator|(
name|pi
operator|->
name|was_stopped
operator|)
operator|||
name|query
argument_list|(
literal|"Was stopped when attached, make it runnable again? "
argument_list|)
condition|)
block|{
comment|/* Clear any pending signal.  */
if|if
condition|(
operator|!
name|proc_clear_current_fault
argument_list|(
name|pi
argument_list|)
condition|)
name|proc_warn
argument_list|(
name|pi
argument_list|,
literal|"do_detach, clear_current_fault"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|proc_set_run_on_last_close
argument_list|(
name|pi
argument_list|)
condition|)
name|proc_warn
argument_list|(
name|pi
argument_list|,
literal|"do_detach, set_rlc"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
name|attach_flag
operator|=
literal|0
expr_stmt|;
name|destroy_procinfo
argument_list|(
name|pi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * fetch_registers  *  * Since the /proc interface cannot give us individual registers,  * we pay no attention to the (regno) argument, and just fetch them all.  * This results in the possibility that we will do unnecessarily many  * fetches, since we may be called repeatedly for individual registers.  * So we cache the results, and mark the cache invalid when the process  * is resumed.  */
end_comment

begin_function
specifier|static
name|void
name|procfs_fetch_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|gdb_fpregset_t
modifier|*
name|fpregs
decl_stmt|;
name|gdb_gregset_t
modifier|*
name|gregs
decl_stmt|;
name|procinfo
modifier|*
name|pi
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|int
name|tid
decl_stmt|;
name|pid
operator|=
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
name|tid
operator|=
name|TIDGET
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
comment|/* First look up procinfo for the main process. */
name|pi
operator|=
name|find_procinfo_or_die
argument_list|(
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If the event thread is not the same as GDB's requested thread       (ie. inferior_ptid), then look up procinfo for the requested       thread.  */
if|if
condition|(
operator|(
name|tid
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|tid
operator|!=
name|proc_get_current_thread
argument_list|(
name|pi
argument_list|)
operator|)
condition|)
name|pi
operator|=
name|find_procinfo_or_die
argument_list|(
name|pid
argument_list|,
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"procfs: fetch_registers failed to find procinfo for %s"
argument_list|,
name|target_pid_to_str
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gregs
operator|=
name|proc_get_gregs
argument_list|(
name|pi
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|proc_error
argument_list|(
name|pi
argument_list|,
literal|"fetch_registers, get_gregs"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|supply_gregset
argument_list|(
name|gregs
argument_list|)
expr_stmt|;
if|if
condition|(
name|FP0_REGNUM
operator|>=
literal|0
condition|)
comment|/* need floating point? */
block|{
if|if
condition|(
operator|(
name|regno
operator|>=
literal|0
operator|&&
name|regno
operator|<
name|FP0_REGNUM
operator|)
operator|||
name|regno
operator|==
name|PC_REGNUM
operator|||
operator|(
name|NPC_REGNUM
operator|>=
literal|0
operator|&&
name|regno
operator|==
name|NPC_REGNUM
operator|)
operator|||
name|regno
operator|==
name|FP_REGNUM
operator|||
name|regno
operator|==
name|SP_REGNUM
condition|)
return|return;
comment|/* not a floating point register */
if|if
condition|(
operator|(
name|fpregs
operator|=
name|proc_get_fpregs
argument_list|(
name|pi
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|proc_error
argument_list|(
name|pi
argument_list|,
literal|"fetch_registers, get_fpregs"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|supply_fpregset
argument_list|(
name|fpregs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Get ready to modify the registers array.  On machines which store    individual registers, this doesn't need to do anything.  On    machines which store all the registers in one fell swoop, such as    /proc, this makes sure that registers contains all the registers    from the program being debugged.  */
end_comment

begin_function
specifier|static
name|void
name|procfs_prepare_to_store
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CHILD_PREPARE_TO_STORE
name|CHILD_PREPARE_TO_STORE
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * store_registers  *  * Since the /proc interface will not read individual registers,   * we will cache these requests until the process is resumed, and  * only then write them back to the inferior process.  *  * FIXME: is that a really bad idea?  Have to think about cases  * where writing one register might affect the value of others, etc.  */
end_comment

begin_function
specifier|static
name|void
name|procfs_store_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|gdb_fpregset_t
modifier|*
name|fpregs
decl_stmt|;
name|gdb_gregset_t
modifier|*
name|gregs
decl_stmt|;
name|procinfo
modifier|*
name|pi
decl_stmt|;
name|int
name|pid
decl_stmt|;
name|int
name|tid
decl_stmt|;
name|pid
operator|=
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
name|tid
operator|=
name|TIDGET
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
comment|/* First find procinfo for main process */
name|pi
operator|=
name|find_procinfo_or_die
argument_list|(
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If current lwp for process is not the same as requested thread      (ie. inferior_ptid), then find procinfo for the requested thread.  */
if|if
condition|(
operator|(
name|tid
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|tid
operator|!=
name|proc_get_current_thread
argument_list|(
name|pi
argument_list|)
operator|)
condition|)
name|pi
operator|=
name|find_procinfo_or_die
argument_list|(
name|pid
argument_list|,
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"procfs: store_registers: failed to find procinfo for %s"
argument_list|,
name|target_pid_to_str
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gregs
operator|=
name|proc_get_gregs
argument_list|(
name|pi
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|proc_error
argument_list|(
name|pi
argument_list|,
literal|"store_registers, get_gregs"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|fill_gregset
argument_list|(
name|gregs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|proc_set_gregs
argument_list|(
name|pi
argument_list|)
condition|)
name|proc_error
argument_list|(
name|pi
argument_list|,
literal|"store_registers, set_gregs"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
if|if
condition|(
name|FP0_REGNUM
operator|>=
literal|0
condition|)
comment|/* need floating point? */
block|{
if|if
condition|(
operator|(
name|regno
operator|>=
literal|0
operator|&&
name|regno
operator|<
name|FP0_REGNUM
operator|)
operator|||
name|regno
operator|==
name|PC_REGNUM
operator|||
operator|(
name|NPC_REGNUM
operator|>=
literal|0
operator|&&
name|regno
operator|==
name|NPC_REGNUM
operator|)
operator|||
name|regno
operator|==
name|FP_REGNUM
operator|||
name|regno
operator|==
name|SP_REGNUM
condition|)
return|return;
comment|/* not a floating point register */
if|if
condition|(
operator|(
name|fpregs
operator|=
name|proc_get_fpregs
argument_list|(
name|pi
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|proc_error
argument_list|(
name|pi
argument_list|,
literal|"store_registers, get_fpregs"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|fill_fpregset
argument_list|(
name|fpregs
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|proc_set_fpregs
argument_list|(
name|pi
argument_list|)
condition|)
name|proc_error
argument_list|(
name|pi
argument_list|,
literal|"store_registers, set_fpregs"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|syscall_is_lwp_exit
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|int
name|scall
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SYS_lwp_exit
if|if
condition|(
name|scall
operator|==
name|SYS_lwp_exit
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYS_lwpexit
if|if
condition|(
name|scall
operator|==
name|SYS_lwpexit
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|syscall_is_exit
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|int
name|scall
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SYS_exit
if|if
condition|(
name|scall
operator|==
name|SYS_exit
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DYNAMIC_SYSCALLS
if|if
condition|(
name|find_syscall
argument_list|(
name|pi
argument_list|,
literal|"_exit"
argument_list|)
operator|==
name|scall
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|syscall_is_exec
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|int
name|scall
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SYS_exec
if|if
condition|(
name|scall
operator|==
name|SYS_exec
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYS_execv
if|if
condition|(
name|scall
operator|==
name|SYS_execv
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYS_execve
if|if
condition|(
name|scall
operator|==
name|SYS_execve
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DYNAMIC_SYSCALLS
if|if
condition|(
name|find_syscall
argument_list|(
name|pi
argument_list|,
literal|"_execve"
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|find_syscall
argument_list|(
name|pi
argument_list|,
literal|"ra_execve"
argument_list|)
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|syscall_is_lwp_create
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|int
name|scall
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SYS_lwp_create
if|if
condition|(
name|scall
operator|==
name|SYS_lwp_create
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYS_lwpcreate
if|if
condition|(
name|scall
operator|==
name|SYS_lwpcreate
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Function: target_wait  *  * Retrieve the next stop event from the child process.  * If child has not stopped yet, wait for it to stop.  * Translate /proc eventcodes (or possibly wait eventcodes)  * into gdb internal event codes.  *  * Return: id of process (and possibly thread) that incurred the event.  *         event codes are returned thru a pointer parameter.  */
end_comment

begin_function
specifier|static
name|ptid_t
name|procfs_wait
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
name|status
parameter_list|)
block|{
comment|/* First cut: loosely based on original version 2.1 */
name|procinfo
modifier|*
name|pi
decl_stmt|;
name|int
name|wstat
decl_stmt|;
name|int
name|temp_tid
decl_stmt|;
name|ptid_t
name|retval
decl_stmt|,
name|temp_ptid
decl_stmt|;
name|int
name|why
decl_stmt|,
name|what
decl_stmt|,
name|flags
decl_stmt|;
name|int
name|retry
init|=
literal|0
decl_stmt|;
name|wait_again
label|:
name|retry
operator|++
expr_stmt|;
name|wstat
operator|=
literal|0
expr_stmt|;
name|retval
operator|=
name|pid_to_ptid
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Find procinfo for main process */
name|pi
operator|=
name|find_procinfo_or_die
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
condition|)
block|{
comment|/* We must assume that the status is stale now... */
name|pi
operator|->
name|status_valid
operator|=
literal|0
expr_stmt|;
name|pi
operator|->
name|gregs_valid
operator|=
literal|0
expr_stmt|;
name|pi
operator|->
name|fpregs_valid
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
comment|/* just try this out... */
block|flags = proc_flags (pi);       why   = proc_why (pi);       if ((flags& PR_STOPPED)&& (why == PR_REQUESTED)) 	pi->status_valid = 0;
comment|/* re-read again, IMMEDIATELY... */
endif|#
directive|endif
comment|/* If child is not stopped, wait for it to stop.  */
if|if
condition|(
operator|!
operator|(
name|proc_flags
argument_list|(
name|pi
argument_list|)
operator|&
operator|(
name|PR_STOPPED
operator||
name|PR_ISTOP
operator|)
operator|)
operator|&&
operator|!
name|proc_wait_for_stop
argument_list|(
name|pi
argument_list|)
condition|)
block|{
comment|/* wait_for_stop failed: has the child terminated? */
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
name|int
name|wait_retval
decl_stmt|;
comment|/* /proc file not found; presumably child has terminated. */
name|wait_retval
operator|=
name|wait
argument_list|(
operator|&
name|wstat
argument_list|)
expr_stmt|;
comment|/* "wait" for the child's exit  */
if|if
condition|(
name|wait_retval
operator|!=
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
condition|)
comment|/* wrong child? */
name|error
argument_list|(
literal|"procfs: couldn't stop process %d: wait returned %d\n"
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|wait_retval
argument_list|)
expr_stmt|;
comment|/* FIXME: might I not just use waitpid? 		 Or try find_procinfo to see if I know about this child? */
name|retval
operator|=
name|pid_to_ptid
argument_list|(
name|wait_retval
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
goto|goto
name|wait_again
goto|;
else|else
block|{
comment|/* Unknown error from wait_for_stop. */
name|proc_error
argument_list|(
name|pi
argument_list|,
literal|"target_wait (wait_for_stop)"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* This long block is reached if either: 	     a) the child was already stopped, or 	     b) we successfully waited for the child with wait_for_stop. 	     This block will analyze the /proc status, and translate it 	     into a waitstatus for GDB.  	     If we actually had to call wait because the /proc file 	     is gone (child terminated), then we skip this block,  	     because we already have a waitstatus.  */
name|flags
operator|=
name|proc_flags
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|why
operator|=
name|proc_why
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|what
operator|=
name|proc_what
argument_list|(
name|pi
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
operator|(
name|PR_STOPPED
operator||
name|PR_ISTOP
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|PR_ASYNC
comment|/* If it's running async (for single_thread control), 		 set it back to normal again.  */
if|if
condition|(
name|flags
operator|&
name|PR_ASYNC
condition|)
if|if
condition|(
operator|!
name|proc_unset_async
argument_list|(
name|pi
argument_list|)
condition|)
name|proc_error
argument_list|(
name|pi
argument_list|,
literal|"target_wait, unset_async"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|info_verbose
condition|)
name|proc_prettyprint_why
argument_list|(
name|why
argument_list|,
name|what
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* The 'pid' we will return to GDB is composed of 		 the process ID plus the lwp ID.  */
name|retval
operator|=
name|MERGEPID
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
name|proc_get_current_thread
argument_list|(
name|pi
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|why
condition|)
block|{
case|case
name|PR_SIGNALLED
case|:
name|wstat
operator|=
operator|(
name|what
operator|<<
literal|8
operator|)
operator||
literal|0177
expr_stmt|;
break|break;
case|case
name|PR_SYSENTRY
case|:
if|if
condition|(
name|syscall_is_lwp_exit
argument_list|(
name|pi
argument_list|,
name|what
argument_list|)
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"[%s exited]\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|retval
argument_list|)
argument_list|)
expr_stmt|;
name|delete_thread
argument_list|(
name|retval
argument_list|)
expr_stmt|;
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_SPURIOUS
expr_stmt|;
return|return
name|retval
return|;
block|}
elseif|else
if|if
condition|(
name|syscall_is_exit
argument_list|(
name|pi
argument_list|,
name|what
argument_list|)
condition|)
block|{
comment|/* Handle SYS_exit call only */
comment|/* Stopped at entry to SYS_exit. 		       Make it runnable, resume it, then use  		       the wait system call to get its exit code. 		       Proc_run_process always clears the current  		       fault and signal. 		       Then return its exit status.  */
name|pi
operator|->
name|status_valid
operator|=
literal|0
expr_stmt|;
name|wstat
operator|=
literal|0
expr_stmt|;
comment|/* FIXME: what we should do is return  		       TARGET_WAITKIND_SPURIOUS.  */
if|if
condition|(
operator|!
name|proc_run_process
argument_list|(
name|pi
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
name|proc_error
argument_list|(
name|pi
argument_list|,
literal|"target_wait, run_process"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
if|if
condition|(
name|attach_flag
condition|)
block|{
comment|/* Don't call wait: simulate waiting for exit,  			   return a "success" exit code.  Bogus: what if 			   it returns something else?  */
name|wstat
operator|=
literal|0
expr_stmt|;
name|retval
operator|=
name|inferior_ptid
expr_stmt|;
comment|/* ? ? ? */
block|}
else|else
block|{
name|int
name|temp
init|=
name|wait
argument_list|(
operator|&
name|wstat
argument_list|)
decl_stmt|;
comment|/* FIXME: shouldn't I make sure I get the right 			   event from the right process?  If (for 			   instance) I have killed an earlier inferior 			   process but failed to clean up after it 			   somehow, I could get its termination event 			   here.  */
comment|/* If wait returns -1, that's what we return to GDB. */
if|if
condition|(
name|temp
operator|<
literal|0
condition|)
name|retval
operator|=
name|pid_to_ptid
argument_list|(
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"procfs: trapped on entry to "
argument_list|)
expr_stmt|;
name|proc_prettyprint_syscall
argument_list|(
name|proc_what
argument_list|(
name|pi
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PIOCSSPCACT
block|{
name|long
name|i
decl_stmt|,
name|nsysargs
decl_stmt|,
modifier|*
name|sysargs
decl_stmt|;
if|if
condition|(
operator|(
name|nsysargs
operator|=
name|proc_nsysarg
argument_list|(
name|pi
argument_list|)
operator|)
operator|>
literal|0
operator|&&
operator|(
name|sysargs
operator|=
name|proc_sysargs
argument_list|(
name|pi
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%ld syscall arguments:\n"
argument_list|,
name|nsysargs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsysargs
condition|;
name|i
operator|++
control|)
name|printf_filtered
argument_list|(
literal|"#%ld: 0x%08lx\n"
argument_list|,
name|i
argument_list|,
name|sysargs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|status
condition|)
block|{
comment|/* How to exit gracefully, returning "unknown event" */
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_SPURIOUS
expr_stmt|;
return|return
name|inferior_ptid
return|;
block|}
else|else
block|{
comment|/* How to keep going without returning to wfi: */
name|target_resume
argument_list|(
name|ptid
argument_list|,
literal|0
argument_list|,
name|TARGET_SIGNAL_0
argument_list|)
expr_stmt|;
goto|goto
name|wait_again
goto|;
block|}
block|}
break|break;
case|case
name|PR_SYSEXIT
case|:
if|if
condition|(
name|syscall_is_exec
argument_list|(
name|pi
argument_list|,
name|what
argument_list|)
condition|)
block|{
comment|/* Hopefully this is our own "fork-child" execing 		       the real child.  Hoax this event into a trap, and 		       GDB will see the child about to execute its start 		       address. */
name|wstat
operator|=
operator|(
name|SIGTRAP
operator|<<
literal|8
operator|)
operator||
literal|0177
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|syscall_is_lwp_create
argument_list|(
name|pi
argument_list|,
name|what
argument_list|)
condition|)
block|{
comment|/* 		     * This syscall is somewhat like fork/exec. 		     * We will get the event twice: once for the parent LWP, 		     * and once for the child.  We should already know about 		     * the parent LWP, but the child will be new to us.  So, 		     * whenever we get this event, if it represents a new 		     * thread, simply add the thread to the list. 		     */
comment|/* If not in procinfo list, add it.  */
name|temp_tid
operator|=
name|proc_get_current_thread
argument_list|(
name|pi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|find_procinfo
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
name|temp_tid
argument_list|)
condition|)
name|create_procinfo
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
name|temp_tid
argument_list|)
expr_stmt|;
name|temp_ptid
operator|=
name|MERGEPID
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
name|temp_tid
argument_list|)
expr_stmt|;
comment|/* If not in GDB's thread list, add it.  */
if|if
condition|(
operator|!
name|in_thread_list
argument_list|(
name|temp_ptid
argument_list|)
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"[New %s]\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|temp_ptid
argument_list|)
argument_list|)
expr_stmt|;
name|add_thread
argument_list|(
name|temp_ptid
argument_list|)
expr_stmt|;
block|}
comment|/* Return to WFI, but tell it to immediately resume. */
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_SPURIOUS
expr_stmt|;
return|return
name|inferior_ptid
return|;
block|}
elseif|else
if|if
condition|(
name|syscall_is_lwp_exit
argument_list|(
name|pi
argument_list|,
name|what
argument_list|)
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"[%s exited]\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|retval
argument_list|)
argument_list|)
expr_stmt|;
name|delete_thread
argument_list|(
name|retval
argument_list|)
expr_stmt|;
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_SPURIOUS
expr_stmt|;
return|return
name|retval
return|;
block|}
elseif|else
if|if
condition|(
literal|0
condition|)
block|{
comment|/* FIXME:  Do we need to handle SYS_sproc, 		       SYS_fork, or SYS_vfork here?  The old procfs 		       seemed to use this event to handle threads on 		       older (non-LWP) systems, where I'm assuming 		       that threads were actually separate processes.  		       Irix, maybe?  Anyway, low priority for now.  */
block|}
else|else
block|{
name|printf_filtered
argument_list|(
literal|"procfs: trapped on exit from "
argument_list|)
expr_stmt|;
name|proc_prettyprint_syscall
argument_list|(
name|proc_what
argument_list|(
name|pi
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PIOCSSPCACT
block|{
name|long
name|i
decl_stmt|,
name|nsysargs
decl_stmt|,
modifier|*
name|sysargs
decl_stmt|;
if|if
condition|(
operator|(
name|nsysargs
operator|=
name|proc_nsysarg
argument_list|(
name|pi
argument_list|)
operator|)
operator|>
literal|0
operator|&&
operator|(
name|sysargs
operator|=
name|proc_sysargs
argument_list|(
name|pi
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%ld syscall arguments:\n"
argument_list|,
name|nsysargs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsysargs
condition|;
name|i
operator|++
control|)
name|printf_filtered
argument_list|(
literal|"#%ld: 0x%08lx\n"
argument_list|,
name|i
argument_list|,
name|sysargs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_SPURIOUS
expr_stmt|;
return|return
name|inferior_ptid
return|;
block|}
break|break;
case|case
name|PR_REQUESTED
case|:
if|#
directive|if
literal|0
comment|/* FIXME */
block|wstat = (SIGSTOP<< 8) | 0177; 		break;
else|#
directive|else
if|if
condition|(
name|retry
operator|<
literal|5
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Retry #%d:\n"
argument_list|,
name|retry
argument_list|)
expr_stmt|;
name|pi
operator|->
name|status_valid
operator|=
literal|0
expr_stmt|;
goto|goto
name|wait_again
goto|;
block|}
else|else
block|{
comment|/* If not in procinfo list, add it.  */
name|temp_tid
operator|=
name|proc_get_current_thread
argument_list|(
name|pi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|find_procinfo
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
name|temp_tid
argument_list|)
condition|)
name|create_procinfo
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
name|temp_tid
argument_list|)
expr_stmt|;
comment|/* If not in GDB's thread list, add it.  */
name|temp_ptid
operator|=
name|MERGEPID
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
name|temp_tid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in_thread_list
argument_list|(
name|temp_ptid
argument_list|)
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"[New %s]\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|temp_ptid
argument_list|)
argument_list|)
expr_stmt|;
name|add_thread
argument_list|(
name|temp_ptid
argument_list|)
expr_stmt|;
block|}
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
literal|0
expr_stmt|;
return|return
name|retval
return|;
block|}
endif|#
directive|endif
case|case
name|PR_JOBCONTROL
case|:
name|wstat
operator|=
operator|(
name|what
operator|<<
literal|8
operator|)
operator||
literal|0177
expr_stmt|;
break|break;
case|case
name|PR_FAULTED
case|:
switch|switch
condition|(
name|what
condition|)
block|{
comment|/* FIXME: FAULTED_USE_SIGINFO */
ifdef|#
directive|ifdef
name|FLTWATCH
case|case
name|FLTWATCH
case|:
name|wstat
operator|=
operator|(
name|SIGTRAP
operator|<<
literal|8
operator|)
operator||
literal|0177
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FLTKWATCH
case|case
name|FLTKWATCH
case|:
name|wstat
operator|=
operator|(
name|SIGTRAP
operator|<<
literal|8
operator|)
operator||
literal|0177
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* FIXME: use si_signo where possible. */
case|case
name|FLTPRIV
case|:
if|#
directive|if
operator|(
name|FLTILL
operator|!=
name|FLTPRIV
operator|)
comment|/* avoid "duplicate case" error */
case|case
name|FLTILL
case|:
endif|#
directive|endif
name|wstat
operator|=
operator|(
name|SIGILL
operator|<<
literal|8
operator|)
operator||
literal|0177
expr_stmt|;
break|break;
case|case
name|FLTBPT
case|:
if|#
directive|if
operator|(
name|FLTTRACE
operator|!=
name|FLTBPT
operator|)
comment|/* avoid "duplicate case" error */
case|case
name|FLTTRACE
case|:
endif|#
directive|endif
name|wstat
operator|=
operator|(
name|SIGTRAP
operator|<<
literal|8
operator|)
operator||
literal|0177
expr_stmt|;
break|break;
case|case
name|FLTSTACK
case|:
case|case
name|FLTACCESS
case|:
if|#
directive|if
operator|(
name|FLTBOUNDS
operator|!=
name|FLTSTACK
operator|)
comment|/* avoid "duplicate case" error */
case|case
name|FLTBOUNDS
case|:
endif|#
directive|endif
name|wstat
operator|=
operator|(
name|SIGSEGV
operator|<<
literal|8
operator|)
operator||
literal|0177
expr_stmt|;
break|break;
case|case
name|FLTIOVF
case|:
case|case
name|FLTIZDIV
case|:
if|#
directive|if
operator|(
name|FLTFPE
operator|!=
name|FLTIOVF
operator|)
comment|/* avoid "duplicate case" error */
case|case
name|FLTFPE
case|:
endif|#
directive|endif
name|wstat
operator|=
operator|(
name|SIGFPE
operator|<<
literal|8
operator|)
operator||
literal|0177
expr_stmt|;
break|break;
case|case
name|FLTPAGE
case|:
comment|/* Recoverable page fault */
default|default:
comment|/* FIXME: use si_signo if possible for fault */
name|retval
operator|=
name|pid_to_ptid
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"procfs:%d -- "
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"child stopped for unknown reason:\n"
argument_list|)
expr_stmt|;
name|proc_prettyprint_why
argument_list|(
name|why
argument_list|,
name|what
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"... giving up..."
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
comment|/* case PR_FAULTED: */
default|default:
comment|/* switch (why) unmatched */
name|printf_filtered
argument_list|(
literal|"procfs:%d -- "
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"child stopped for unknown reason:\n"
argument_list|)
expr_stmt|;
name|proc_prettyprint_why
argument_list|(
name|why
argument_list|,
name|what
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"... giving up..."
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 	       * Got this far without error: 	       * If retval isn't in the threads database, add it. 	       */
if|if
condition|(
name|PIDGET
argument_list|(
name|retval
argument_list|)
operator|>
literal|0
operator|&&
operator|!
name|ptid_equal
argument_list|(
name|retval
argument_list|,
name|inferior_ptid
argument_list|)
operator|&&
operator|!
name|in_thread_list
argument_list|(
name|retval
argument_list|)
condition|)
block|{
comment|/* 		   * We have a new thread.   		   * We need to add it both to GDB's list and to our own. 		   * If we don't create a procinfo, resume may be unhappy  		   * later. 		   */
name|printf_filtered
argument_list|(
literal|"[New %s]\n"
argument_list|,
name|target_pid_to_str
argument_list|(
name|retval
argument_list|)
argument_list|)
expr_stmt|;
name|add_thread
argument_list|(
name|retval
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_procinfo
argument_list|(
name|PIDGET
argument_list|(
name|retval
argument_list|)
argument_list|,
name|TIDGET
argument_list|(
name|retval
argument_list|)
argument_list|)
operator|==
name|NULL
condition|)
name|create_procinfo
argument_list|(
name|PIDGET
argument_list|(
name|retval
argument_list|)
argument_list|,
name|TIDGET
argument_list|(
name|retval
argument_list|)
argument_list|)
expr_stmt|;
comment|/* In addition, it's possible that this is the first 		   * new thread we've seen, in which case we may not  		   * have created entries for inferior_ptid yet. 		   */
if|if
condition|(
name|TIDGET
argument_list|(
name|inferior_ptid
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|in_thread_list
argument_list|(
name|inferior_ptid
argument_list|)
condition|)
name|add_thread
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
if|if
condition|(
name|find_procinfo
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|TIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
operator|==
name|NULL
condition|)
name|create_procinfo
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|TIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
comment|/* flags do not indicate STOPPED */
block|{
comment|/* surely this can't happen... */
name|printf_filtered
argument_list|(
literal|"procfs:%d -- process not stopped.\n"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|proc_prettyprint_flags
argument_list|(
name|flags
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"procfs: ...giving up..."
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|status
condition|)
name|store_waitstatus
argument_list|(
name|status
argument_list|,
name|wstat
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Transfer LEN bytes between GDB address MYADDR and target address    MEMADDR.  If DOWRITE is non-zero, transfer them to the target,    otherwise transfer them from the target.  TARGET is unused.     The return value is 0 if an error occurred or no bytes were    transferred.  Otherwise, it will be a positive value which    indicates the number of bytes transferred between gdb and the    target.  (Note that the interface also makes provisions for    negative values, but this capability isn't implemented here.) */
end_comment

begin_function
specifier|static
name|int
name|procfs_xfer_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|dowrite
parameter_list|,
name|struct
name|mem_attrib
modifier|*
name|attrib
parameter_list|,
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
block|{
name|procinfo
modifier|*
name|pi
decl_stmt|;
name|int
name|nbytes
init|=
literal|0
decl_stmt|;
comment|/* Find procinfo for main process */
name|pi
operator|=
name|find_procinfo_or_die
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|as_fd
operator|==
literal|0
operator|&&
name|open_procinfo_files
argument_list|(
name|pi
argument_list|,
name|FD_AS
argument_list|)
operator|==
literal|0
condition|)
block|{
name|proc_warn
argument_list|(
name|pi
argument_list|,
literal|"xfer_memory, open_proc_files"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|lseek
argument_list|(
name|pi
operator|->
name|as_fd
argument_list|,
operator|(
name|off_t
operator|)
name|memaddr
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|(
name|off_t
operator|)
name|memaddr
condition|)
block|{
if|if
condition|(
name|dowrite
condition|)
block|{
ifdef|#
directive|ifdef
name|NEW_PROC_API
name|PROCFS_NOTE
argument_list|(
literal|"write memory: "
argument_list|)
expr_stmt|;
else|#
directive|else
name|PROCFS_NOTE
argument_list|(
literal|"write memory: \n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nbytes
operator|=
name|write
argument_list|(
name|pi
operator|->
name|as_fd
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PROCFS_NOTE
argument_list|(
literal|"read  memory: \n"
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|read
argument_list|(
name|pi
operator|->
name|as_fd
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nbytes
operator|<
literal|0
condition|)
block|{
name|nbytes
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|nbytes
return|;
block|}
end_function

begin_comment
comment|/*  * Function: invalidate_cache  *  * Called by target_resume before making child runnable.  * Mark cached registers and status's invalid.  * If there are "dirty" caches that need to be written back  * to the child process, do that.  *  * File descriptors are also cached.    * As they are a limited resource, we cannot hold onto them indefinitely.  * However, as they are expensive to open, we don't want to throw them  * away indescriminately either.  As a compromise, we will keep the  * file descriptors for the parent process, but discard any file  * descriptors we may have accumulated for the threads.  *  * Return value:  * As this function is called by iterate_over_threads, it always   * returns zero (so that iterate_over_threads will keep iterating).  */
end_comment

begin_function
specifier|static
name|int
name|invalidate_cache
parameter_list|(
name|procinfo
modifier|*
name|parent
parameter_list|,
name|procinfo
modifier|*
name|pi
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
comment|/*    * About to run the child; invalidate caches and do any other cleanup.    */
if|#
directive|if
literal|0
block|if (pi->gregs_dirty)     if (parent == NULL || 	proc_get_current_thread (parent) != pi->tid)       if (!proc_set_gregs (pi))
comment|/* flush gregs cache */
block|proc_warn (pi, "target_resume, set_gregs", 		   __LINE__);   if (FP0_REGNUM>= 0)     if (pi->fpregs_dirty)       if (parent == NULL || 	  proc_get_current_thread (parent) != pi->tid) 	if (!proc_set_fpregs (pi))
comment|/* flush fpregs cache */
block|proc_warn (pi, "target_resume, set_fpregs",  		     __LINE__);
endif|#
directive|endif
if|if
condition|(
name|parent
operator|!=
name|NULL
condition|)
block|{
comment|/* The presence of a parent indicates that this is an LWP. 	 Close any file descriptors that it might have open.   	 We don't do this to the master (parent) procinfo.  */
name|close_procinfo_files
argument_list|(
name|pi
argument_list|)
expr_stmt|;
block|}
name|pi
operator|->
name|gregs_valid
operator|=
literal|0
expr_stmt|;
name|pi
operator|->
name|fpregs_valid
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
block|pi->gregs_dirty   = 0;   pi->fpregs_dirty  = 0;
endif|#
directive|endif
name|pi
operator|->
name|status_valid
operator|=
literal|0
expr_stmt|;
name|pi
operator|->
name|threads_valid
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * Function: make_signal_thread_runnable  *  * A callback function for iterate_over_threads.  * Find the asynchronous signal thread, and make it runnable.  * See if that helps matters any.  */
end_comment

begin_ifdef
unit|static int make_signal_thread_runnable (procinfo *process, procinfo *pi, void *ptr) {
ifdef|#
directive|ifdef
name|PR_ASLWP
end_ifdef

begin_endif
unit|if (proc_flags (pi)& PR_ASLWP)     {       if (!proc_run_process (pi, 0, -1)) 	proc_error (pi, "make_signal_thread_runnable", __LINE__);       return 1;     }
endif|#
directive|endif
end_endif

begin_endif
unit|return 0; }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Function: target_resume  *  * Make the child process runnable.  Normally we will then call  * procfs_wait and wait for it to stop again (unles gdb is async).  *  * Arguments:  *  step:  if true, then arrange for the child to stop again   *         after executing a single instruction.  *  signo: if zero, then cancel any pending signal.  *         If non-zero, then arrange for the indicated signal   *         to be delivered to the child when it runs.  *  pid:   if -1, then allow any child thread to run.  *         if non-zero, then allow only the indicated thread to run.  *******   (not implemented yet)  */
end_comment

begin_function
specifier|static
name|void
name|procfs_resume
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|step
parameter_list|,
name|enum
name|target_signal
name|signo
parameter_list|)
block|{
name|procinfo
modifier|*
name|pi
decl_stmt|,
modifier|*
name|thread
decl_stmt|;
name|int
name|native_signo
decl_stmt|;
comment|/* 2.1:       prrun.prflags |= PRSVADDR;      prrun.pr_vaddr = $PC;	   set resume address       prrun.prflags |= PRSTRACE;    trace signals in pr_trace (all)      prrun.prflags |= PRSFAULT;    trace faults in pr_fault (all but PAGE)       prrun.prflags |= PRCFAULT;    clear current fault.       PRSTRACE and PRSFAULT can be done by other means      	(proc_trace_signals, proc_trace_faults)      PRSVADDR is unnecessary.      PRCFAULT may be replaced by a PIOCCFAULT call (proc_clear_current_fault)      This basically leaves PRSTEP and PRCSIG.      PRCSIG is like PIOCSSIG (proc_clear_current_signal).      So basically PR_STEP is the sole argument that must be passed      to proc_run_process (for use in the prrun struct by ioctl). */
comment|/* Find procinfo for main process */
name|pi
operator|=
name|find_procinfo_or_die
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* First cut: ignore pid argument */
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* Convert signal to host numbering.  */
if|if
condition|(
name|signo
operator|==
literal|0
operator|||
operator|(
name|signo
operator|==
name|TARGET_SIGNAL_STOP
operator|&&
name|pi
operator|->
name|ignore_next_sigstop
operator|)
condition|)
name|native_signo
operator|=
literal|0
expr_stmt|;
else|else
name|native_signo
operator|=
name|target_signal_to_host
argument_list|(
name|signo
argument_list|)
expr_stmt|;
name|pi
operator|->
name|ignore_next_sigstop
operator|=
literal|0
expr_stmt|;
comment|/* Running the process voids all cached registers and status. */
comment|/* Void the threads' caches first */
name|proc_iterate_over_threads
argument_list|(
name|pi
argument_list|,
name|invalidate_cache
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Void the process procinfo's caches.  */
name|invalidate_cache
argument_list|(
name|NULL
argument_list|,
name|pi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|PIDGET
argument_list|(
name|ptid
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* Resume a specific thread, presumably suppressing the others. */
name|thread
operator|=
name|find_procinfo
argument_list|(
name|PIDGET
argument_list|(
name|ptid
argument_list|)
argument_list|,
name|TIDGET
argument_list|(
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|thread
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|thread
operator|->
name|tid
operator|!=
literal|0
condition|)
block|{
comment|/* We're to resume a specific thread, and not the others. 	       * Set the child process's PR_ASYNC flag. 	       */
ifdef|#
directive|ifdef
name|PR_ASYNC
if|if
condition|(
operator|!
name|proc_set_async
argument_list|(
name|pi
argument_list|)
condition|)
name|proc_error
argument_list|(
name|pi
argument_list|,
literal|"target_resume, set_async"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|0
block|proc_iterate_over_threads (pi,  					 make_signal_thread_runnable, 					 NULL);
endif|#
directive|endif
name|pi
operator|=
name|thread
expr_stmt|;
comment|/* substitute the thread's procinfo for run */
block|}
block|}
block|}
if|if
condition|(
operator|!
name|proc_run_process
argument_list|(
name|pi
argument_list|,
name|step
argument_list|,
name|native_signo
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EBUSY
condition|)
name|warning
argument_list|(
literal|"resume: target already running.  Pretend to resume, and hope for the best!\n"
argument_list|)
expr_stmt|;
else|else
name|proc_error
argument_list|(
name|pi
argument_list|,
literal|"target_resume"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Function: register_gdb_signals  *  * Traverse the list of signals that GDB knows about   * (see "handle" command), and arrange for the target  * to be stopped or not, according to these settings.  *  * Returns non-zero for success, zero for failure.  */
end_comment

begin_function
specifier|static
name|int
name|register_gdb_signals
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|gdb_sigset_t
modifier|*
name|signals
parameter_list|)
block|{
name|int
name|signo
decl_stmt|;
for|for
control|(
name|signo
operator|=
literal|0
init|;
name|signo
operator|<
name|NSIG
condition|;
name|signo
operator|++
control|)
if|if
condition|(
name|signal_stop_state
argument_list|(
name|target_signal_from_host
argument_list|(
name|signo
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|signal_print_state
argument_list|(
name|target_signal_from_host
argument_list|(
name|signo
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|signal_pass_state
argument_list|(
name|target_signal_from_host
argument_list|(
name|signo
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
name|prdelset
argument_list|(
name|signals
argument_list|,
name|signo
argument_list|)
expr_stmt|;
else|else
name|praddset
argument_list|(
name|signals
argument_list|,
name|signo
argument_list|)
expr_stmt|;
return|return
name|proc_set_traced_signals
argument_list|(
name|pi
argument_list|,
name|signals
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function: target_notice_signals  *  * Set up to trace signals in the child process.  */
end_comment

begin_function
specifier|static
name|void
name|procfs_notice_signals
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
name|gdb_sigset_t
name|signals
decl_stmt|;
name|procinfo
modifier|*
name|pi
init|=
name|find_procinfo_or_die
argument_list|(
name|PIDGET
argument_list|(
name|ptid
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|proc_get_traced_signals
argument_list|(
name|pi
argument_list|,
operator|&
name|signals
argument_list|)
operator|&&
name|register_gdb_signals
argument_list|(
name|pi
argument_list|,
operator|&
name|signals
argument_list|)
condition|)
return|return;
else|else
name|proc_error
argument_list|(
name|pi
argument_list|,
literal|"notice_signals"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function: target_files_info  *  * Print status information about the child process.  */
end_comment

begin_function
specifier|static
name|void
name|procfs_files_info
parameter_list|(
name|struct
name|target_ops
modifier|*
name|ignore
parameter_list|)
block|{
name|printf_filtered
argument_list|(
literal|"\tUsing the running image of %s %s via /proc.\n"
argument_list|,
name|attach_flag
condition|?
literal|"attached"
else|:
literal|"child"
argument_list|,
name|target_pid_to_str
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function: target_open  *  * A dummy: you don't open procfs.  */
end_comment

begin_function
specifier|static
name|void
name|procfs_open
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|error
argument_list|(
literal|"Use the \"run\" command to start a Unix child process."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function: target_can_run  *  * This tells GDB that this target vector can be invoked   * for "run" or "attach".  */
end_comment

begin_decl_stmt
name|int
name|procfs_suppress_run
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero if procfs should pretend not to 				   be a runnable target.  Used by targets 				   that can sit atop procfs, such as solaris 				   thread support.  */
end_comment

begin_function
specifier|static
name|int
name|procfs_can_run
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* This variable is controlled by modules that sit atop procfs that      may layer their own process structure atop that provided here.      sol-thread.c does this because of the Solaris two-level thread      model.  */
comment|/* NOTE: possibly obsolete -- use the thread_stratum approach instead. */
return|return
operator|!
name|procfs_suppress_run
return|;
block|}
end_function

begin_comment
comment|/*  * Function: target_stop  *  * Stop the child process asynchronously, as when the  * gdb user types control-c or presses a "stop" button.  *  * Works by sending kill(SIGINT) to the child's process group.  */
end_comment

begin_function
specifier|static
name|void
name|procfs_stop
parameter_list|(
name|void
parameter_list|)
block|{
specifier|extern
name|pid_t
name|inferior_process_group
decl_stmt|;
name|kill
argument_list|(
operator|-
name|inferior_process_group
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function: unconditionally_kill_inferior  *  * Make it die.  Wait for it to die.  Clean up after it.  * Note: this should only be applied to the real process,   * not to an LWP, because of the check for parent-process.  * If we need this to work for an LWP, it needs some more logic.  */
end_comment

begin_function
specifier|static
name|void
name|unconditionally_kill_inferior
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|)
block|{
name|int
name|parent_pid
decl_stmt|;
name|parent_pid
operator|=
name|proc_parent_pid
argument_list|(
name|pi
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROCFS_NEED_CLEAR_CURSIG_FOR_KILL
comment|/* FIXME: use access functions */
comment|/* Alpha OSF/1-3.x procfs needs a clear of the current signal      before the PIOCKILL, otherwise it might generate a corrupted core      file for the inferior.  */
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCSSIG
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"unconditionally_kill: SSIG failed!\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PROCFS_NEED_PIOCSSIG_FOR_KILL
comment|/* Alpha OSF/1-2.x procfs needs a PIOCSSIG call with a SIGKILL signal      to kill the inferior, otherwise it might remain stopped with a      pending SIGKILL.      We do not check the result of the PIOCSSIG, the inferior might have      died already.  */
block|{
name|gdb_siginfo_t
name|newsiginfo
decl_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|newsiginfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|newsiginfo
argument_list|)
argument_list|)
expr_stmt|;
name|newsiginfo
operator|.
name|si_signo
operator|=
name|SIGKILL
expr_stmt|;
name|newsiginfo
operator|.
name|si_code
operator|=
literal|0
expr_stmt|;
name|newsiginfo
operator|.
name|si_errno
operator|=
literal|0
expr_stmt|;
name|newsiginfo
operator|.
name|si_pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|newsiginfo
operator|.
name|si_uid
operator|=
name|getuid
argument_list|()
expr_stmt|;
comment|/* FIXME: use proc_set_current_signal */
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCSSIG
argument_list|,
operator|&
name|newsiginfo
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* PROCFS_NEED_PIOCSSIG_FOR_KILL */
if|if
condition|(
operator|!
name|proc_kill
argument_list|(
name|pi
argument_list|,
name|SIGKILL
argument_list|)
condition|)
name|proc_error
argument_list|(
name|pi
argument_list|,
literal|"unconditionally_kill, proc_kill"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PROCFS_NEED_PIOCSSIG_FOR_KILL */
name|destroy_procinfo
argument_list|(
name|pi
argument_list|)
expr_stmt|;
comment|/* If pi is GDB's child, wait for it to die.  */
if|if
condition|(
name|parent_pid
operator|==
name|getpid
argument_list|()
condition|)
comment|/* FIXME: should we use waitpid to make sure we get the right event?          Should we check the returned event?  */
block|{
if|#
directive|if
literal|0
block|int status, ret;        ret = waitpid (pi->pid,&status, 0);
else|#
directive|else
name|wait
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/*  * Function: target_kill_inferior  *  * We're done debugging it, and we want it to go away.  * Then we want GDB to forget all about it.  */
end_comment

begin_function
specifier|static
name|void
name|procfs_kill_inferior
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ptid_equal
argument_list|(
name|inferior_ptid
argument_list|,
name|null_ptid
argument_list|)
condition|)
comment|/* ? */
block|{
comment|/* Find procinfo for main process */
name|procinfo
modifier|*
name|pi
init|=
name|find_procinfo
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|pi
condition|)
name|unconditionally_kill_inferior
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|target_mourn_inferior
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Function: target_mourn_inferior  *  * Forget we ever debugged this thing!  */
end_comment

begin_function
specifier|static
name|void
name|procfs_mourn_inferior
parameter_list|(
name|void
parameter_list|)
block|{
name|procinfo
modifier|*
name|pi
decl_stmt|;
if|if
condition|(
operator|!
name|ptid_equal
argument_list|(
name|inferior_ptid
argument_list|,
name|null_ptid
argument_list|)
condition|)
block|{
comment|/* Find procinfo for main process */
name|pi
operator|=
name|find_procinfo
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
condition|)
name|destroy_procinfo
argument_list|(
name|pi
argument_list|)
expr_stmt|;
block|}
name|unpush_target
argument_list|(
operator|&
name|procfs_ops
argument_list|)
expr_stmt|;
name|generic_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function: init_inferior  *  * When GDB forks to create a runnable inferior process,   * this function is called on the parent side of the fork.  * It's job is to do whatever is necessary to make the child  * ready to be debugged, and then wait for the child to synchronize.  */
end_comment

begin_function
specifier|static
name|void
name|procfs_init_inferior
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
name|procinfo
modifier|*
name|pi
decl_stmt|;
name|gdb_sigset_t
name|signals
decl_stmt|;
name|int
name|fail
decl_stmt|;
comment|/* This routine called on the parent side (GDB side)      after GDB forks the inferior.  */
name|push_target
argument_list|(
operator|&
name|procfs_ops
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pi
operator|=
name|create_procinfo
argument_list|(
name|pid
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|perror
argument_list|(
literal|"procfs: out of memory in 'init_inferior'"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|open_procinfo_files
argument_list|(
name|pi
argument_list|,
name|FD_CTL
argument_list|)
condition|)
name|proc_error
argument_list|(
name|pi
argument_list|,
literal|"init_inferior, open_proc_files"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
comment|/*     xmalloc			// done     open_procinfo_files		// done     link list			// done     prfillset (trace)     procfs_notice_signals     prfillset (fault)     prdelset (FLTPAGE)     PIOCWSTOP     PIOCSFAULT     */
comment|/* If not stopped yet, wait for it to stop. */
if|if
condition|(
operator|!
operator|(
name|proc_flags
argument_list|(
name|pi
argument_list|)
operator|&
name|PR_STOPPED
operator|)
operator|&&
operator|!
operator|(
name|proc_wait_for_stop
argument_list|(
name|pi
argument_list|)
operator|)
condition|)
name|dead_procinfo
argument_list|(
name|pi
argument_list|,
literal|"init_inferior: wait_for_stop failed"
argument_list|,
name|KILL
argument_list|)
expr_stmt|;
comment|/* Save some of the /proc state to be restored if we detach.  */
comment|/* FIXME: Why?  In case another debugger was debugging it?      We're it's parent, for Ghu's sake! */
if|if
condition|(
operator|!
name|proc_get_traced_signals
argument_list|(
name|pi
argument_list|,
operator|&
name|pi
operator|->
name|saved_sigset
argument_list|)
condition|)
name|proc_error
argument_list|(
name|pi
argument_list|,
literal|"init_inferior, get_traced_signals"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|proc_get_held_signals
argument_list|(
name|pi
argument_list|,
operator|&
name|pi
operator|->
name|saved_sighold
argument_list|)
condition|)
name|proc_error
argument_list|(
name|pi
argument_list|,
literal|"init_inferior, get_held_signals"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|proc_get_traced_faults
argument_list|(
name|pi
argument_list|,
operator|&
name|pi
operator|->
name|saved_fltset
argument_list|)
condition|)
name|proc_error
argument_list|(
name|pi
argument_list|,
literal|"init_inferior, get_traced_faults"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|proc_get_traced_sysentry
argument_list|(
name|pi
argument_list|,
name|pi
operator|->
name|saved_entryset
argument_list|)
condition|)
name|proc_error
argument_list|(
name|pi
argument_list|,
literal|"init_inferior, get_traced_sysentry"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|proc_get_traced_sysexit
argument_list|(
name|pi
argument_list|,
name|pi
operator|->
name|saved_exitset
argument_list|)
condition|)
name|proc_error
argument_list|(
name|pi
argument_list|,
literal|"init_inferior, get_traced_sysexit"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
comment|/* Register to trace selected signals in the child. */
name|prfillset
argument_list|(
operator|&
name|signals
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|register_gdb_signals
argument_list|(
name|pi
argument_list|,
operator|&
name|signals
argument_list|)
condition|)
name|proc_error
argument_list|(
name|pi
argument_list|,
literal|"init_inferior, register_signals"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fail
operator|=
name|procfs_debug_inferior
argument_list|(
name|pi
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|proc_error
argument_list|(
name|pi
argument_list|,
literal|"init_inferior (procfs_debug_inferior)"
argument_list|,
name|fail
argument_list|)
expr_stmt|;
comment|/* FIXME: logically, we should really be turning OFF run-on-last-close,      and possibly even turning ON kill-on-last-close at this point.  But      I can't make that change without careful testing which I don't have      time to do right now...  */
comment|/* Turn on run-on-last-close flag so that the child      will die if GDB goes away for some reason.  */
if|if
condition|(
operator|!
name|proc_set_run_on_last_close
argument_list|(
name|pi
argument_list|)
condition|)
name|proc_error
argument_list|(
name|pi
argument_list|,
literal|"init_inferior, set_RLC"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
comment|/* The 'process ID' we return to GDB is composed of      the actual process ID plus the lwp ID. */
name|inferior_ptid
operator|=
name|MERGEPID
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
name|proc_get_current_thread
argument_list|(
name|pi
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|START_INFERIOR_TRAPS_EXPECTED
name|startup_inferior
argument_list|(
name|START_INFERIOR_TRAPS_EXPECTED
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* One trap to exec the shell, one to exec the program being debugged.  */
name|startup_inferior
argument_list|(
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* START_INFERIOR_TRAPS_EXPECTED */
block|}
end_function

begin_comment
comment|/*  * Function: set_exec_trap  *  * When GDB forks to create a new process, this function is called  * on the child side of the fork before GDB exec's the user program.  * Its job is to make the child minimally debuggable, so that the  * parent GDB process can connect to the child and take over.  * This function should do only the minimum to make that possible,  * and to synchronize with the parent process.  The parent process  * should take care of the details.  */
end_comment

begin_function
specifier|static
name|void
name|procfs_set_exec_trap
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* This routine called on the child side (inferior side)      after GDB forks the inferior.  It must use only local variables,      because it may be sharing data space with its parent.  */
name|procinfo
modifier|*
name|pi
decl_stmt|;
name|sysset_t
modifier|*
name|exitset
decl_stmt|;
if|if
condition|(
operator|(
name|pi
operator|=
name|create_procinfo
argument_list|(
name|getpid
argument_list|()
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|perror_with_name
argument_list|(
literal|"procfs: create_procinfo failed in child."
argument_list|)
expr_stmt|;
if|if
condition|(
name|open_procinfo_files
argument_list|(
name|pi
argument_list|,
name|FD_CTL
argument_list|)
operator|==
literal|0
condition|)
block|{
name|proc_warn
argument_list|(
name|pi
argument_list|,
literal|"set_exec_trap, open_proc_files"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
comment|/* no need to call "dead_procinfo", because we're going to exit. */
name|_exit
argument_list|(
literal|127
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PRFS_STOPEXEC
comment|/* defined on OSF */
comment|/* OSF method for tracing exec syscalls.  Quoting:      Under Alpha OSF/1 we have to use a PIOCSSPCACT ioctl to trace      exits from exec system calls because of the user level loader.  */
comment|/* FIXME: make nice and maybe move into an access function. */
block|{
name|int
name|prfs_flags
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCGSPCACT
argument_list|,
operator|&
name|prfs_flags
argument_list|)
operator|<
literal|0
condition|)
block|{
name|proc_warn
argument_list|(
name|pi
argument_list|,
literal|"set_exec_trap (PIOCGSPCACT)"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|127
argument_list|)
expr_stmt|;
block|}
name|prfs_flags
operator||=
name|PRFS_STOPEXEC
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCSSPCACT
argument_list|,
operator|&
name|prfs_flags
argument_list|)
operator|<
literal|0
condition|)
block|{
name|proc_warn
argument_list|(
name|pi
argument_list|,
literal|"set_exec_trap (PIOCSSPCACT)"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|127
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* not PRFS_STOPEXEC */
comment|/* Everyone else's (except OSF) method for tracing exec syscalls */
comment|/* GW: Rationale...      Not all systems with /proc have all the exec* syscalls with the same      names.  On the SGI, for example, there is no SYS_exec, but there      *is* a SYS_execv.  So, we try to account for that. */
name|exitset
operator|=
name|sysset_t_alloc
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|gdb_premptysysset
argument_list|(
name|exitset
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SYS_exec
name|gdb_praddsysset
argument_list|(
name|exitset
argument_list|,
name|SYS_exec
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYS_execve
name|gdb_praddsysset
argument_list|(
name|exitset
argument_list|,
name|SYS_execve
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYS_execv
name|gdb_praddsysset
argument_list|(
name|exitset
argument_list|,
name|SYS_execv
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DYNAMIC_SYSCALLS
block|{
name|int
name|callnum
init|=
name|find_syscall
argument_list|(
name|pi
argument_list|,
literal|"execve"
argument_list|)
decl_stmt|;
if|if
condition|(
name|callnum
operator|>=
literal|0
condition|)
name|gdb_praddsysset
argument_list|(
name|exitset
argument_list|,
name|callnum
argument_list|)
expr_stmt|;
name|callnum
operator|=
name|find_syscall
argument_list|(
name|pi
argument_list|,
literal|"ra_execve"
argument_list|)
expr_stmt|;
if|if
condition|(
name|callnum
operator|>=
literal|0
condition|)
name|gdb_praddsysset
argument_list|(
name|exitset
argument_list|,
name|callnum
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DYNAMIC_SYSCALLS */
if|if
condition|(
operator|!
name|proc_set_traced_sysexit
argument_list|(
name|pi
argument_list|,
name|exitset
argument_list|)
condition|)
block|{
name|proc_warn
argument_list|(
name|pi
argument_list|,
literal|"set_exec_trap, set_traced_sysexit"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|127
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* PRFS_STOPEXEC */
comment|/* FIXME: should this be done in the parent instead? */
comment|/* Turn off inherit on fork flag so that all grand-children      of gdb start with tracing flags cleared.  */
if|if
condition|(
operator|!
name|proc_unset_inherit_on_fork
argument_list|(
name|pi
argument_list|)
condition|)
name|proc_warn
argument_list|(
name|pi
argument_list|,
literal|"set_exec_trap, unset_inherit"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
comment|/* Turn off run on last close flag, so that the child process      cannot run away just because we close our handle on it.      We want it to wait for the parent to attach.  */
if|if
condition|(
operator|!
name|proc_unset_run_on_last_close
argument_list|(
name|pi
argument_list|)
condition|)
name|proc_warn
argument_list|(
name|pi
argument_list|,
literal|"set_exec_trap, unset_RLC"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
comment|/* FIXME: No need to destroy the procinfo --       we have our own address space, and we're about to do an exec! */
comment|/*destroy_procinfo (pi);*/
block|}
end_function

begin_comment
comment|/*  * Function: create_inferior  *  * This function is called BEFORE gdb forks the inferior process.  * Its only real responsibility is to set things up for the fork,   * and tell GDB which two functions to call after the fork (one  * for the parent, and one for the child).  *   * This function does a complicated search for a unix shell program,  * which it then uses to parse arguments and environment variables  * to be sent to the child.  I wonder whether this code could not  * be abstracted out and shared with other unix targets such as  * infptrace?  */
end_comment

begin_function
specifier|static
name|void
name|procfs_create_inferior
parameter_list|(
name|char
modifier|*
name|exec_file
parameter_list|,
name|char
modifier|*
name|allargs
parameter_list|,
name|char
modifier|*
modifier|*
name|env
parameter_list|)
block|{
name|char
modifier|*
name|shell_file
init|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|tryname
decl_stmt|;
if|if
condition|(
name|shell_file
operator|!=
name|NULL
operator|&&
name|strchr
argument_list|(
name|shell_file
argument_list|,
literal|'/'
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* We will be looking down the PATH to find shell_file.  If we 	 just do this the normal way (via execlp, which operates by 	 attempting an exec for each element of the PATH until it 	 finds one which succeeds), then there will be an exec for 	 each failed attempt, each of which will cause a PR_SYSEXIT 	 stop, and we won't know how to distinguish the PR_SYSEXIT's 	 for these failed execs with the ones for successful execs 	 (whether the exec has succeeded is stored at that time in the 	 carry bit or some such architecture-specific and 	 non-ABI-specified place).  	 So I can't think of anything better than to search the PATH 	 now.  This has several disadvantages: (1) There is a race 	 condition; if we find a file now and it is deleted before we 	 exec it, we lose, even if the deletion leaves a valid file 	 further down in the PATH, (2) there is no way to know exactly 	 what an executable (in the sense of "capable of being 	 exec'd") file is.  Using access() loses because it may lose 	 if the caller is the superuser; failing to use it loses if 	 there are ACLs or some such.  */
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|p1
decl_stmt|;
comment|/* FIXME-maybe: might want "set path" command so user can change what 	 path is used from within GDB.  */
name|char
modifier|*
name|path
init|=
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
decl_stmt|;
name|int
name|len
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
name|path
operator|=
literal|"/bin:/usr/bin"
expr_stmt|;
name|tryname
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
name|strlen
argument_list|(
name|shell_file
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|path
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p1
condition|?
name|p1
operator|+
literal|1
else|:
name|NULL
control|)
block|{
name|p1
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|!=
name|NULL
condition|)
name|len
operator|=
name|p1
operator|-
name|p
expr_stmt|;
else|else
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|tryname
argument_list|,
name|p
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|tryname
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|tryname
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tryname
argument_list|,
name|shell_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|tryname
argument_list|,
name|X_OK
argument_list|)
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
name|stat
argument_list|(
name|tryname
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
condition|)
comment|/* We certainly need to reject directories.  I'm not quite 	       as sure about FIFOs, sockets, etc., but I kind of doubt 	       that people want to exec() these things.  */
continue|continue;
break|break;
block|}
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
comment|/* Not found.  This must be an error rather than merely passing 	   the file to execlp(), because execlp() would try all the 	   exec()s, causing GDB to get confused.  */
name|error
argument_list|(
literal|"procfs:%d -- Can't find shell %s in PATH"
argument_list|,
name|__LINE__
argument_list|,
name|shell_file
argument_list|)
expr_stmt|;
name|shell_file
operator|=
name|tryname
expr_stmt|;
block|}
name|fork_inferior
argument_list|(
name|exec_file
argument_list|,
name|allargs
argument_list|,
name|env
argument_list|,
name|procfs_set_exec_trap
argument_list|,
name|procfs_init_inferior
argument_list|,
name|NULL
argument_list|,
name|shell_file
argument_list|)
expr_stmt|;
comment|/* We are at the first instruction we care about.  */
comment|/* Pedal to the metal... */
name|proceed
argument_list|(
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
argument_list|,
name|TARGET_SIGNAL_0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function: notice_thread  *  * Callback for find_new_threads.  * Calls "add_thread".  */
end_comment

begin_function
specifier|static
name|int
name|procfs_notice_thread
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|procinfo
modifier|*
name|thread
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|ptid_t
name|gdb_threadid
init|=
name|MERGEPID
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
name|thread
operator|->
name|tid
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|in_thread_list
argument_list|(
name|gdb_threadid
argument_list|)
condition|)
name|add_thread
argument_list|(
name|gdb_threadid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Function: target_find_new_threads  *  * Query all the threads that the target knows about,   * and give them back to GDB to add to its list.  */
end_comment

begin_function
name|void
name|procfs_find_new_threads
parameter_list|(
name|void
parameter_list|)
block|{
name|procinfo
modifier|*
name|pi
decl_stmt|;
comment|/* Find procinfo for main process */
name|pi
operator|=
name|find_procinfo_or_die
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|proc_update_threads
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|proc_iterate_over_threads
argument_list|(
name|pi
argument_list|,
name|procfs_notice_thread
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * Function: target_thread_alive  *  * Return true if the thread is still 'alive'.  *  * This guy doesn't really seem to be doing his job.  * Got to investigate how to tell when a thread is really gone.  */
end_comment

begin_function
specifier|static
name|int
name|procfs_thread_alive
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
name|int
name|proc
decl_stmt|,
name|thread
decl_stmt|;
name|procinfo
modifier|*
name|pi
decl_stmt|;
name|proc
operator|=
name|PIDGET
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
name|thread
operator|=
name|TIDGET
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
comment|/* If I don't know it, it ain't alive! */
if|if
condition|(
operator|(
name|pi
operator|=
name|find_procinfo
argument_list|(
name|proc
argument_list|,
name|thread
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* If I can't get its status, it ain't alive!      What's more, I need to forget about it!  */
if|if
condition|(
operator|!
name|proc_get_status
argument_list|(
name|pi
argument_list|)
condition|)
block|{
name|destroy_procinfo
argument_list|(
name|pi
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* I couldn't have got its status if it weren't alive, so it's alive.  */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Function: target_pid_to_str  *  * Return a string to be used to identify the thread in   * the "info threads" display.  */
end_comment

begin_function
name|char
modifier|*
name|procfs_pid_to_str
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|int
name|proc
decl_stmt|,
name|thread
decl_stmt|;
name|procinfo
modifier|*
name|pi
decl_stmt|;
name|proc
operator|=
name|PIDGET
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
name|thread
operator|=
name|TIDGET
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
name|pi
operator|=
name|find_procinfo
argument_list|(
name|proc
argument_list|,
name|thread
argument_list|)
expr_stmt|;
if|if
condition|(
name|thread
operator|==
literal|0
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Process %d"
argument_list|,
name|proc
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"LWP %d"
argument_list|,
name|thread
argument_list|)
expr_stmt|;
return|return
operator|&
name|buf
index|[
literal|0
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * Function: procfs_set_watchpoint  * Insert a watchpoint  */
end_comment

begin_function
name|int
name|procfs_set_watchpoint
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|rwflag
parameter_list|,
name|int
name|after
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|UNIXWARE
ifndef|#
directive|ifndef
name|AIX5
name|int
name|pflags
init|=
literal|0
decl_stmt|;
name|procinfo
modifier|*
name|pi
decl_stmt|;
name|pi
operator|=
name|find_procinfo_or_die
argument_list|(
name|PIDGET
argument_list|(
name|ptid
argument_list|)
operator|==
operator|-
literal|1
condition|?
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
else|:
name|PIDGET
argument_list|(
name|ptid
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Translate from GDB's flags to /proc's */
if|if
condition|(
name|len
operator|>
literal|0
condition|)
comment|/* len == 0 means delete watchpoint */
block|{
switch|switch
condition|(
name|rwflag
condition|)
block|{
comment|/* FIXME: need an enum! */
case|case
name|hw_write
case|:
comment|/* default watchpoint (write) */
name|pflags
operator|=
name|WRITE_WATCHFLAG
expr_stmt|;
break|break;
case|case
name|hw_read
case|:
comment|/* read watchpoint */
name|pflags
operator|=
name|READ_WATCHFLAG
expr_stmt|;
break|break;
case|case
name|hw_access
case|:
comment|/* access watchpoint */
name|pflags
operator|=
name|READ_WATCHFLAG
operator||
name|WRITE_WATCHFLAG
expr_stmt|;
break|break;
case|case
name|hw_execute
case|:
comment|/* execution HW breakpoint */
name|pflags
operator|=
name|EXEC_WATCHFLAG
expr_stmt|;
break|break;
default|default:
comment|/* Something weird.  Return error. */
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|after
condition|)
comment|/* Stop after r/w access is completed. */
name|pflags
operator||=
name|AFTER_WATCHFLAG
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|proc_set_watchpoint
argument_list|(
name|pi
argument_list|,
name|addr
argument_list|,
name|len
argument_list|,
name|pflags
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|E2BIG
condition|)
comment|/* Typical error for no resources */
return|return
operator|-
literal|1
return|;
comment|/* fail */
comment|/* GDB may try to remove the same watchpoint twice. 	 If a remove request returns no match, don't error.  */
if|if
condition|(
name|errno
operator|==
name|ESRCH
operator|&&
name|len
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* ignore */
name|proc_error
argument_list|(
name|pi
argument_list|,
literal|"set_watchpoint"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* AIX5 */
endif|#
directive|endif
comment|/* UNIXWARE */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Function: stopped_by_watchpoint  *  * Returns non-zero if process is stopped on a hardware watchpoint fault,  * else returns zero.  */
end_comment

begin_function
name|int
name|procfs_stopped_by_watchpoint
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
name|procinfo
modifier|*
name|pi
decl_stmt|;
name|pi
operator|=
name|find_procinfo_or_die
argument_list|(
name|PIDGET
argument_list|(
name|ptid
argument_list|)
operator|==
operator|-
literal|1
condition|?
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
else|:
name|PIDGET
argument_list|(
name|ptid
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pi
condition|)
comment|/* If no process, then not stopped by watchpoint!  */
return|return
literal|0
return|;
if|if
condition|(
name|proc_flags
argument_list|(
name|pi
argument_list|)
operator|&
operator|(
name|PR_STOPPED
operator||
name|PR_ISTOP
operator|)
condition|)
block|{
if|if
condition|(
name|proc_why
argument_list|(
name|pi
argument_list|)
operator|==
name|PR_FAULTED
condition|)
block|{
ifdef|#
directive|ifdef
name|FLTWATCH
if|if
condition|(
name|proc_what
argument_list|(
name|pi
argument_list|)
operator|==
name|FLTWATCH
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FLTKWATCH
if|if
condition|(
name|proc_what
argument_list|(
name|pi
argument_list|)
operator|==
name|FLTKWATCH
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TM_I386SOL2_H
end_ifdef

begin_comment
comment|/*  * Function: procfs_find_LDT_entry   *  * Input:  *   ptid_t ptid;	// The GDB-style pid-plus-LWP.  *  * Return:  *   pointer to the corresponding LDT entry.  */
end_comment

begin_function
name|struct
name|ssd
modifier|*
name|procfs_find_LDT_entry
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
name|gdb_gregset_t
modifier|*
name|gregs
decl_stmt|;
name|int
name|key
decl_stmt|;
name|procinfo
modifier|*
name|pi
decl_stmt|;
comment|/* Find procinfo for the lwp. */
if|if
condition|(
operator|(
name|pi
operator|=
name|find_procinfo
argument_list|(
name|PIDGET
argument_list|(
name|ptid
argument_list|)
argument_list|,
name|TIDGET
argument_list|(
name|ptid
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warning
argument_list|(
literal|"procfs_find_LDT_entry: could not find procinfo for %d:%d."
argument_list|,
name|PIDGET
argument_list|(
name|ptid
argument_list|)
argument_list|,
name|TIDGET
argument_list|(
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* get its general registers. */
if|if
condition|(
operator|(
name|gregs
operator|=
name|proc_get_gregs
argument_list|(
name|pi
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warning
argument_list|(
literal|"procfs_find_LDT_entry: could not read gregs for %d:%d."
argument_list|,
name|PIDGET
argument_list|(
name|ptid
argument_list|)
argument_list|,
name|TIDGET
argument_list|(
name|ptid
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Now extract the GS register's lower 16 bits. */
name|key
operator|=
operator|(
operator|*
name|gregs
operator|)
index|[
name|GS
index|]
operator|&
literal|0xffff
expr_stmt|;
comment|/* Find the matching entry and return it. */
return|return
name|proc_get_LDT_entry
argument_list|(
name|pi
argument_list|,
name|key
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TM_I386SOL2_H */
end_comment

begin_comment
comment|/*  * Memory Mappings Functions:  */
end_comment

begin_comment
comment|/*   * Function: iterate_over_mappings  *  * Call a callback function once for each mapping, passing it the mapping,  * an optional secondary callback function, and some optional opaque data.  * Quit and return the first non-zero value returned from the callback.  *  * Arguments:  *   pi   -- procinfo struct for the process to be mapped.  *   func -- callback function to be called by this iterator.  *   data -- optional opaque data to be passed to the callback function.  *   child_func -- optional secondary function pointer to be passed  *                 to the child function.  *  * Return: First non-zero return value from the callback function,   *         or zero.  */
end_comment

begin_function
specifier|static
name|int
name|iterate_over_mappings
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|int
function_decl|(
modifier|*
name|child_func
function_decl|)
parameter_list|()
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|struct
name|prmap
modifier|*
name|map
parameter_list|,
name|int
function_decl|(
modifier|*
name|child_func
function_decl|)
parameter_list|()
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
parameter_list|)
block|{
name|char
name|pathname
index|[
name|MAX_PROC_NAME_SIZE
index|]
decl_stmt|;
name|struct
name|prmap
modifier|*
name|prmaps
decl_stmt|;
name|struct
name|prmap
modifier|*
name|prmap
decl_stmt|;
name|int
name|funcstat
decl_stmt|;
name|int
name|map_fd
decl_stmt|;
name|int
name|nmap
decl_stmt|;
ifdef|#
directive|ifdef
name|NEW_PROC_API
name|struct
name|stat
name|sbuf
decl_stmt|;
endif|#
directive|endif
comment|/* Get the number of mappings, allocate space,       and read the mappings into prmaps.  */
ifdef|#
directive|ifdef
name|NEW_PROC_API
comment|/* Open map fd. */
name|sprintf
argument_list|(
name|pathname
argument_list|,
literal|"/proc/%d/map"
argument_list|,
name|pi
operator|->
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|map_fd
operator|=
name|open
argument_list|(
name|pathname
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|proc_error
argument_list|(
name|pi
argument_list|,
literal|"iterate_over_mappings (open)"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
comment|/* Make sure it gets closed again. */
name|make_cleanup_close
argument_list|(
name|map_fd
argument_list|)
expr_stmt|;
comment|/* Use stat to determine the file size, and compute       the number of prmap_t objects it contains.  */
if|if
condition|(
name|fstat
argument_list|(
name|map_fd
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|!=
literal|0
condition|)
name|proc_error
argument_list|(
name|pi
argument_list|,
literal|"iterate_over_mappings (fstat)"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|nmap
operator|=
name|sbuf
operator|.
name|st_size
operator|/
sizeof|sizeof
argument_list|(
name|prmap_t
argument_list|)
expr_stmt|;
name|prmaps
operator|=
operator|(
expr|struct
name|prmap
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|nmap
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|prmaps
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|map_fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|prmaps
argument_list|,
name|nmap
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|prmaps
argument_list|)
argument_list|)
operator|!=
operator|(
name|nmap
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|prmaps
argument_list|)
operator|)
condition|)
name|proc_error
argument_list|(
name|pi
argument_list|,
literal|"iterate_over_mappings (read)"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Use ioctl command PIOCNMAP to get number of mappings.  */
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCNMAP
argument_list|,
operator|&
name|nmap
argument_list|)
operator|!=
literal|0
condition|)
name|proc_error
argument_list|(
name|pi
argument_list|,
literal|"iterate_over_mappings (PIOCNMAP)"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|prmaps
operator|=
operator|(
expr|struct
name|prmap
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|nmap
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|prmaps
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCMAP
argument_list|,
name|prmaps
argument_list|)
operator|!=
literal|0
condition|)
name|proc_error
argument_list|(
name|pi
argument_list|,
literal|"iterate_over_mappings (PIOCMAP)"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|prmap
operator|=
name|prmaps
init|;
name|nmap
operator|>
literal|0
condition|;
name|prmap
operator|++
operator|,
name|nmap
operator|--
control|)
if|if
condition|(
operator|(
name|funcstat
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|prmap
argument_list|,
name|child_func
argument_list|,
name|data
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|funcstat
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Function: solib_mappings_callback  *  * Calls the supplied callback function once for each mapped address   * space in the process.  The callback function  receives an open   * file descriptor for the file corresponding to that mapped   * address space (if there is one), and the base address of the   * mapped space.  Quit when the callback function returns a  * nonzero value, or at teh end of the mappings.  *  * Returns: the first non-zero return value of the callback function,  * or zero.  */
end_comment

begin_function
name|int
name|solib_mappings_callback
parameter_list|(
name|struct
name|prmap
modifier|*
name|map
parameter_list|,
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|CORE_ADDR
parameter_list|)
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|procinfo
modifier|*
name|pi
init|=
name|data
decl_stmt|;
name|int
name|fd
decl_stmt|;
ifdef|#
directive|ifdef
name|NEW_PROC_API
name|char
name|name
index|[
name|MAX_PROC_NAME_SIZE
operator|+
sizeof|sizeof
argument_list|(
name|map
operator|->
name|pr_mapname
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|map
operator|->
name|pr_vaddr
operator|==
literal|0
operator|&&
name|map
operator|->
name|pr_size
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* sanity */
if|if
condition|(
name|map
operator|->
name|pr_mapname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* no map file */
block|}
else|else
block|{
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"/proc/%d/object/%s"
argument_list|,
name|pi
operator|->
name|pid
argument_list|,
name|map
operator|->
name|pr_mapname
argument_list|)
expr_stmt|;
comment|/* Note: caller's responsibility to close this fd!  */
name|fd
operator|=
name|open_with_retry
argument_list|(
name|name
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
comment|/* Note: we don't test the above call for failure; 	 we just pass the FD on as given.  Sometimes there is  	 no file, so the open may return failure, but that's 	 not a problem.  */
block|}
else|#
directive|else
name|fd
operator|=
name|ioctl
argument_list|(
name|pi
operator|->
name|ctl_fd
argument_list|,
name|PIOCOPENM
argument_list|,
operator|&
name|map
operator|->
name|pr_vaddr
argument_list|)
expr_stmt|;
comment|/* Note: we don't test the above call for failure;      we just pass the FD on as given.  Sometimes there is       no file, so the ioctl may return failure, but that's      not a problem.  */
endif|#
directive|endif
return|return
call|(
modifier|*
name|func
call|)
argument_list|(
name|fd
argument_list|,
operator|(
name|CORE_ADDR
operator|)
name|map
operator|->
name|pr_vaddr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function: proc_iterate_over_mappings  *  * Uses the unified "iterate_over_mappings" function  * to implement the exported interface to solib-svr4.c.  *  * Given a pointer to a function, call that function once for every  * mapped address space in the process.  The callback function   * receives an open file descriptor for the file corresponding to  * that mapped address space (if there is one), and the base address  * of the mapped space.  Quit when the callback function returns a  * nonzero value, or at teh end of the mappings.  *  * Returns: the first non-zero return value of the callback function,  * or zero.  */
end_comment

begin_function
name|int
name|proc_iterate_over_mappings
parameter_list|(
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|CORE_ADDR
parameter_list|)
parameter_list|)
block|{
name|procinfo
modifier|*
name|pi
init|=
name|find_procinfo_or_die
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
return|return
name|iterate_over_mappings
argument_list|(
name|pi
argument_list|,
name|func
argument_list|,
name|pi
argument_list|,
name|solib_mappings_callback
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function: find_memory_regions_callback  *  * Implements the to_find_memory_regions method.  * Calls an external function for each memory region.  * External function will have the signiture:  *  *   int callback (CORE_ADDR vaddr,   *                 unsigned long size,   *                 int read, int write, int execute,   *                 void *data);  *  * Returns the integer value returned by the callback.  */
end_comment

begin_function
specifier|static
name|int
name|find_memory_regions_callback
parameter_list|(
name|struct
name|prmap
modifier|*
name|map
parameter_list|,
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|unsigned
name|long
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
return|return
call|(
modifier|*
name|func
call|)
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|map
operator|->
name|pr_vaddr
argument_list|,
name|map
operator|->
name|pr_size
argument_list|,
operator|(
name|map
operator|->
name|pr_mflags
operator|&
name|MA_READ
operator|)
operator|!=
literal|0
argument_list|,
operator|(
name|map
operator|->
name|pr_mflags
operator|&
name|MA_WRITE
operator|)
operator|!=
literal|0
argument_list|,
operator|(
name|map
operator|->
name|pr_mflags
operator|&
name|MA_EXEC
operator|)
operator|!=
literal|0
argument_list|,
name|data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function: proc_find_memory_regions  *  * External interface.  Calls a callback function once for each  * mapped memory region in the child process, passing as arguments  *	CORE_ADDR virtual_address,  *	unsigned long size,   *	int read, 	TRUE if region is readable by the child  *	int write, 	TRUE if region is writable by the child  *	int execute	TRUE if region is executable by the child.  *   * Stops iterating and returns the first non-zero value  * returned by the callback.  */
end_comment

begin_function
specifier|static
name|int
name|proc_find_memory_regions
parameter_list|(
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|unsigned
name|long
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|procinfo
modifier|*
name|pi
init|=
name|find_procinfo_or_die
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
return|return
name|iterate_over_mappings
argument_list|(
name|pi
argument_list|,
name|func
argument_list|,
name|data
argument_list|,
name|find_memory_regions_callback
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function: mappingflags  *  * Returns an ascii representation of a memory mapping's flags.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|mappingflags
parameter_list|(
name|flags
parameter_list|)
name|long
name|flags
decl_stmt|;
block|{
specifier|static
name|char
name|asciiflags
index|[
literal|8
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|asciiflags
argument_list|,
literal|"-------"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MA_PHYS
argument_list|)
if|if
condition|(
name|flags
operator|&
name|MA_PHYS
condition|)
name|asciiflags
index|[
literal|0
index|]
operator|=
literal|'d'
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flags
operator|&
name|MA_STACK
condition|)
name|asciiflags
index|[
literal|1
index|]
operator|=
literal|'s'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MA_BREAK
condition|)
name|asciiflags
index|[
literal|2
index|]
operator|=
literal|'b'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MA_SHARED
condition|)
name|asciiflags
index|[
literal|3
index|]
operator|=
literal|'s'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MA_READ
condition|)
name|asciiflags
index|[
literal|4
index|]
operator|=
literal|'r'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MA_WRITE
condition|)
name|asciiflags
index|[
literal|5
index|]
operator|=
literal|'w'
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MA_EXEC
condition|)
name|asciiflags
index|[
literal|6
index|]
operator|=
literal|'x'
expr_stmt|;
return|return
operator|(
name|asciiflags
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function: info_mappings_callback  *  * Callback function, does the actual work for 'info proc mappings'.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|info_mappings_callback
parameter_list|(
name|struct
name|prmap
modifier|*
name|map
parameter_list|,
name|int
function_decl|(
modifier|*
name|ignore
function_decl|)
parameter_list|()
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|char
modifier|*
name|data_fmt_string
decl_stmt|;
if|if
condition|(
name|TARGET_ADDR_BIT
operator|==
literal|32
condition|)
name|data_fmt_string
operator|=
literal|"\t%#10lx %#10lx %#10x %#10x %7s\n"
expr_stmt|;
else|else
name|data_fmt_string
operator|=
literal|"  %#18lx %#18lx %#10x %#10x %7s\n"
expr_stmt|;
name|printf_filtered
argument_list|(
name|data_fmt_string
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|map
operator|->
name|pr_vaddr
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|map
operator|->
name|pr_vaddr
operator|+
name|map
operator|->
name|pr_size
operator|-
literal|1
argument_list|,
name|map
operator|->
name|pr_size
argument_list|,
ifdef|#
directive|ifdef
name|PCAGENT
comment|/* Horrible hack: only defined on Solaris 2.6+ */
operator|(
name|unsigned
name|int
operator|)
name|map
operator|->
name|pr_offset
argument_list|,
else|#
directive|else
name|map
operator|->
name|pr_off
argument_list|,
endif|#
directive|endif
name|mappingflags
argument_list|(
name|map
operator|->
name|pr_mflags
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Function: info_proc_mappings  *  * Implement the "info proc mappings" subcommand.  */
end_comment

begin_function
specifier|static
name|void
name|info_proc_mappings
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|int
name|summary
parameter_list|)
block|{
name|char
modifier|*
name|header_fmt_string
decl_stmt|;
if|if
condition|(
name|TARGET_PTR_BIT
operator|==
literal|32
condition|)
name|header_fmt_string
operator|=
literal|"\t%10s %10s %10s %10s %7s\n"
expr_stmt|;
else|else
name|header_fmt_string
operator|=
literal|"  %18s %18s %10s %10s %7s\n"
expr_stmt|;
if|if
condition|(
name|summary
condition|)
return|return;
comment|/* No output for summary mode. */
name|printf_filtered
argument_list|(
literal|"Mapped address spaces:\n\n"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
name|header_fmt_string
argument_list|,
literal|"Start Addr"
argument_list|,
literal|"  End Addr"
argument_list|,
literal|"      Size"
argument_list|,
literal|"    Offset"
argument_list|,
literal|"Flags"
argument_list|)
expr_stmt|;
name|iterate_over_mappings
argument_list|(
name|pi
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|info_mappings_callback
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function: info_proc_cmd  *  * Implement the "info proc" command.  */
end_comment

begin_function
specifier|static
name|void
name|info_proc_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|procinfo
modifier|*
name|process
init|=
name|NULL
decl_stmt|;
name|procinfo
modifier|*
name|thread
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|tmp
init|=
name|NULL
decl_stmt|;
name|int
name|pid
init|=
literal|0
decl_stmt|;
name|int
name|tid
init|=
literal|0
decl_stmt|;
name|int
name|mappings
init|=
literal|0
decl_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|null_cleanup
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
condition|)
block|{
if|if
condition|(
operator|(
name|argv
operator|=
name|buildargv
argument_list|(
name|args
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|nomem
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
name|make_cleanup_freeargv
argument_list|(
name|argv
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|argv
operator|!=
name|NULL
operator|&&
operator|*
name|argv
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|pid
operator|=
name|strtoul
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
operator|&
name|tmp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tmp
operator|==
literal|'/'
condition|)
name|tid
operator|=
name|strtoul
argument_list|(
operator|++
name|tmp
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|tid
operator|=
name|strtoul
argument_list|(
name|argv
index|[
literal|0
index|]
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"mappings"
argument_list|,
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mappings
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* [...] */
block|}
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
name|pid
operator|=
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No current process: you must name one."
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Have pid, will travel. 	 First see if it's a process we're already debugging. */
name|process
operator|=
name|find_procinfo
argument_list|(
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|process
operator|==
name|NULL
condition|)
block|{
comment|/* No.  So open a procinfo for it, but  	      remember to close it again when finished.  */
name|process
operator|=
name|create_procinfo
argument_list|(
name|pid
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|do_destroy_procinfo_cleanup
argument_list|,
name|process
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|open_procinfo_files
argument_list|(
name|process
argument_list|,
name|FD_CTL
argument_list|)
condition|)
name|proc_error
argument_list|(
name|process
argument_list|,
literal|"info proc, open_procinfo_files"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tid
operator|!=
literal|0
condition|)
name|thread
operator|=
name|create_procinfo
argument_list|(
name|pid
argument_list|,
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|process
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"process %d flags:\n"
argument_list|,
name|process
operator|->
name|pid
argument_list|)
expr_stmt|;
name|proc_prettyprint_flags
argument_list|(
name|proc_flags
argument_list|(
name|process
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc_flags
argument_list|(
name|process
argument_list|)
operator|&
operator|(
name|PR_STOPPED
operator||
name|PR_ISTOP
operator|)
condition|)
name|proc_prettyprint_why
argument_list|(
name|proc_why
argument_list|(
name|process
argument_list|)
argument_list|,
name|proc_what
argument_list|(
name|process
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc_get_nthreads
argument_list|(
name|process
argument_list|)
operator|>
literal|1
condition|)
name|printf_filtered
argument_list|(
literal|"Process has %d threads.\n"
argument_list|,
name|proc_get_nthreads
argument_list|(
name|process
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|thread
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"thread %d flags:\n"
argument_list|,
name|thread
operator|->
name|tid
argument_list|)
expr_stmt|;
name|proc_prettyprint_flags
argument_list|(
name|proc_flags
argument_list|(
name|thread
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc_flags
argument_list|(
name|thread
argument_list|)
operator|&
operator|(
name|PR_STOPPED
operator||
name|PR_ISTOP
operator|)
condition|)
name|proc_prettyprint_why
argument_list|(
name|proc_why
argument_list|(
name|thread
argument_list|)
argument_list|,
name|proc_what
argument_list|(
name|thread
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mappings
condition|)
block|{
name|info_proc_mappings
argument_list|(
name|process
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|proc_trace_syscalls
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|,
name|int
name|entry_or_exit
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|procinfo
modifier|*
name|pi
decl_stmt|;
name|sysset_t
modifier|*
name|sysset
decl_stmt|;
name|int
name|syscallnum
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
operator|<=
literal|0
condition|)
name|error
argument_list|(
literal|"you must be debugging a process to use this command."
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|==
name|NULL
operator|||
name|args
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|error_no_arg
argument_list|(
literal|"system call to trace"
argument_list|)
expr_stmt|;
name|pi
operator|=
name|find_procinfo_or_die
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|syscallnum
operator|=
name|atoi
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry_or_exit
operator|==
name|PR_SYSENTRY
condition|)
name|sysset
operator|=
name|proc_get_traced_sysentry
argument_list|(
name|pi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|sysset
operator|=
name|proc_get_traced_sysexit
argument_list|(
name|pi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysset
operator|==
name|NULL
condition|)
name|proc_error
argument_list|(
name|pi
argument_list|,
literal|"proc-trace, get_traced_sysset"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|FLAG_SET
condition|)
name|gdb_praddsysset
argument_list|(
name|sysset
argument_list|,
name|syscallnum
argument_list|)
expr_stmt|;
else|else
name|gdb_prdelsysset
argument_list|(
name|sysset
argument_list|,
name|syscallnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry_or_exit
operator|==
name|PR_SYSENTRY
condition|)
block|{
if|if
condition|(
operator|!
name|proc_set_traced_sysentry
argument_list|(
name|pi
argument_list|,
name|sysset
argument_list|)
condition|)
name|proc_error
argument_list|(
name|pi
argument_list|,
literal|"proc-trace, set_traced_sysentry"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|proc_set_traced_sysexit
argument_list|(
name|pi
argument_list|,
name|sysset
argument_list|)
condition|)
name|proc_error
argument_list|(
name|pi
argument_list|,
literal|"proc-trace, set_traced_sysexit"
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|proc_trace_sysentry_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|proc_trace_syscalls
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|,
name|PR_SYSENTRY
argument_list|,
name|FLAG_SET
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|proc_trace_sysexit_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|proc_trace_syscalls
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|,
name|PR_SYSEXIT
argument_list|,
name|FLAG_SET
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|proc_untrace_sysentry_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|proc_trace_syscalls
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|,
name|PR_SYSENTRY
argument_list|,
name|FLAG_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|proc_untrace_sysexit_cmd
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|proc_trace_syscalls
argument_list|(
name|args
argument_list|,
name|from_tty
argument_list|,
name|PR_SYSEXIT
argument_list|,
name|FLAG_RESET
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_procfs
parameter_list|(
name|void
parameter_list|)
block|{
name|init_procfs_ops
argument_list|()
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|procfs_ops
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"proc"
argument_list|,
name|info_proc_cmd
argument_list|,
literal|"Show /proc process information about any running process.\n\ Specify process id, or use the program being debugged by default.\n\ Specify keyword 'mappings' for detailed info on memory mappings."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"proc-trace-entry"
argument_list|,
name|no_class
argument_list|,
name|proc_trace_sysentry_cmd
argument_list|,
literal|"Give a trace of entries into the syscall."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"proc-trace-exit"
argument_list|,
name|no_class
argument_list|,
name|proc_trace_sysexit_cmd
argument_list|,
literal|"Give a trace of exits from the syscall."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"proc-untrace-entry"
argument_list|,
name|no_class
argument_list|,
name|proc_untrace_sysentry_cmd
argument_list|,
literal|"Cancel a trace of entries into the syscall."
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"proc-untrace-exit"
argument_list|,
name|no_class
argument_list|,
name|proc_untrace_sysexit_cmd
argument_list|,
literal|"Cancel a trace of exits from the syscall."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =================== END, GDB  "MODULE" =================== */
end_comment

begin_comment
comment|/* miscellaneous stubs:                                             */
end_comment

begin_comment
comment|/* The following satisfy a few random symbols mostly created by    */
end_comment

begin_comment
comment|/* the solaris threads implementation, which I will chase down     */
end_comment

begin_comment
comment|/* later.        */
end_comment

begin_comment
comment|/*  * Return a pid for which we guarantee  * we will be able to find a 'live' procinfo.  */
end_comment

begin_function
name|ptid_t
name|procfs_first_available
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|pid_to_ptid
argument_list|(
name|procinfo_list
condition|?
name|procinfo_list
operator|->
name|pid
else|:
operator|-
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ===================  GCORE .NOTE "MODULE" =================== */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|UNIXWARE
argument_list|)
operator|||
name|defined
argument_list|(
name|PIOCOPENLWP
argument_list|)
operator|||
name|defined
argument_list|(
name|PCAGENT
argument_list|)
end_if

begin_comment
comment|/* gcore only implemented on solaris and unixware (so far) */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|procfs_do_thread_registers
parameter_list|(
name|bfd
modifier|*
name|obfd
parameter_list|,
name|ptid_t
name|ptid
parameter_list|,
name|char
modifier|*
name|note_data
parameter_list|,
name|int
modifier|*
name|note_size
parameter_list|)
block|{
name|gdb_gregset_t
name|gregs
decl_stmt|;
name|gdb_fpregset_t
name|fpregs
decl_stmt|;
name|unsigned
name|long
name|merged_pid
decl_stmt|;
name|merged_pid
operator|=
name|TIDGET
argument_list|(
name|ptid
argument_list|)
operator|<<
literal|16
operator||
name|PIDGET
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
name|fill_gregset
argument_list|(
operator|&
name|gregs
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|UNIXWARE
argument_list|)
name|note_data
operator|=
operator|(
name|char
operator|*
operator|)
name|elfcore_write_lwpstatus
argument_list|(
name|obfd
argument_list|,
name|note_data
argument_list|,
name|note_size
argument_list|,
name|merged_pid
argument_list|,
name|stop_signal
argument_list|,
operator|&
name|gregs
argument_list|)
expr_stmt|;
else|#
directive|else
name|note_data
operator|=
operator|(
name|char
operator|*
operator|)
name|elfcore_write_prstatus
argument_list|(
name|obfd
argument_list|,
name|note_data
argument_list|,
name|note_size
argument_list|,
name|merged_pid
argument_list|,
name|stop_signal
argument_list|,
operator|&
name|gregs
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fill_fpregset
argument_list|(
operator|&
name|fpregs
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|note_data
operator|=
operator|(
name|char
operator|*
operator|)
name|elfcore_write_prfpreg
argument_list|(
name|obfd
argument_list|,
name|note_data
argument_list|,
name|note_size
argument_list|,
operator|&
name|fpregs
argument_list|,
sizeof|sizeof
argument_list|(
name|fpregs
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|note_data
return|;
block|}
end_function

begin_struct
struct|struct
name|procfs_corefile_thread_data
block|{
name|bfd
modifier|*
name|obfd
decl_stmt|;
name|char
modifier|*
name|note_data
decl_stmt|;
name|int
modifier|*
name|note_size
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|procfs_corefile_thread_callback
parameter_list|(
name|procinfo
modifier|*
name|pi
parameter_list|,
name|procinfo
modifier|*
name|thread
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|procfs_corefile_thread_data
modifier|*
name|args
init|=
name|data
decl_stmt|;
if|if
condition|(
name|pi
operator|!=
name|NULL
operator|&&
name|thread
operator|->
name|tid
operator|!=
literal|0
condition|)
block|{
name|ptid_t
name|saved_ptid
init|=
name|inferior_ptid
decl_stmt|;
name|inferior_ptid
operator|=
name|MERGEPID
argument_list|(
name|pi
operator|->
name|pid
argument_list|,
name|thread
operator|->
name|tid
argument_list|)
expr_stmt|;
name|args
operator|->
name|note_data
operator|=
name|procfs_do_thread_registers
argument_list|(
name|args
operator|->
name|obfd
argument_list|,
name|inferior_ptid
argument_list|,
name|args
operator|->
name|note_data
argument_list|,
name|args
operator|->
name|note_size
argument_list|)
expr_stmt|;
name|inferior_ptid
operator|=
name|saved_ptid
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|procfs_make_note_section
parameter_list|(
name|bfd
modifier|*
name|obfd
parameter_list|,
name|int
modifier|*
name|note_size
parameter_list|)
block|{
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|gdb_gregset_t
name|gregs
decl_stmt|;
name|gdb_fpregset_t
name|fpregs
decl_stmt|;
name|char
name|fname
index|[
literal|16
index|]
init|=
block|{
literal|'\0'
block|}
decl_stmt|;
name|char
name|psargs
index|[
literal|80
index|]
init|=
block|{
literal|'\0'
block|}
decl_stmt|;
name|procinfo
modifier|*
name|pi
init|=
name|find_procinfo_or_die
argument_list|(
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|char
modifier|*
name|note_data
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|inf_args
decl_stmt|;
name|struct
name|procfs_corefile_thread_data
name|thread_args
decl_stmt|;
if|if
condition|(
name|get_exec_file
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|strncpy
argument_list|(
name|fname
argument_list|,
name|strrchr
argument_list|(
name|get_exec_file
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|'/'
argument_list|)
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|fname
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|psargs
argument_list|,
name|get_exec_file
argument_list|(
literal|0
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|psargs
argument_list|)
argument_list|)
expr_stmt|;
name|inf_args
operator|=
name|get_inferior_args
argument_list|()
expr_stmt|;
if|if
condition|(
name|inf_args
operator|&&
operator|*
name|inf_args
operator|&&
name|strlen
argument_list|(
name|inf_args
argument_list|)
operator|<
operator|(
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|psargs
argument_list|)
operator|-
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|psargs
argument_list|)
operator|)
condition|)
block|{
name|strncat
argument_list|(
name|psargs
argument_list|,
literal|" "
argument_list|,
sizeof|sizeof
argument_list|(
name|psargs
argument_list|)
operator|-
name|strlen
argument_list|(
name|psargs
argument_list|)
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|psargs
argument_list|,
name|inf_args
argument_list|,
sizeof|sizeof
argument_list|(
name|psargs
argument_list|)
operator|-
name|strlen
argument_list|(
name|psargs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|note_data
operator|=
operator|(
name|char
operator|*
operator|)
name|elfcore_write_prpsinfo
argument_list|(
name|obfd
argument_list|,
name|note_data
argument_list|,
name|note_size
argument_list|,
name|fname
argument_list|,
name|psargs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UNIXWARE
name|fill_gregset
argument_list|(
operator|&
name|gregs
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|note_data
operator|=
name|elfcore_write_pstatus
argument_list|(
name|obfd
argument_list|,
name|note_data
argument_list|,
name|note_size
argument_list|,
name|PIDGET
argument_list|(
name|inferior_ptid
argument_list|)
argument_list|,
name|stop_signal
argument_list|,
operator|&
name|gregs
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|thread_args
operator|.
name|obfd
operator|=
name|obfd
expr_stmt|;
name|thread_args
operator|.
name|note_data
operator|=
name|note_data
expr_stmt|;
name|thread_args
operator|.
name|note_size
operator|=
name|note_size
expr_stmt|;
name|proc_iterate_over_threads
argument_list|(
name|pi
argument_list|,
name|procfs_corefile_thread_callback
argument_list|,
operator|&
name|thread_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|thread_args
operator|.
name|note_data
operator|==
name|note_data
condition|)
block|{
comment|/* iterate_over_threads didn't come up with any threads; 	 just use inferior_ptid. */
name|note_data
operator|=
name|procfs_do_thread_registers
argument_list|(
name|obfd
argument_list|,
name|inferior_ptid
argument_list|,
name|note_data
argument_list|,
name|note_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|note_data
operator|=
name|thread_args
operator|.
name|note_data
expr_stmt|;
block|}
name|make_cleanup
argument_list|(
name|xfree
argument_list|,
name|note_data
argument_list|)
expr_stmt|;
return|return
name|note_data
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !(Solaris or Unixware) */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|procfs_make_note_section
parameter_list|(
name|bfd
modifier|*
name|obfd
parameter_list|,
name|int
modifier|*
name|note_size
parameter_list|)
block|{
name|error
argument_list|(
literal|"gcore not implemented for this host."
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
comment|/* lint */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Solaris or Unixware */
end_comment

begin_comment
comment|/* ===================  END GCORE .NOTE "MODULE" =================== */
end_comment

end_unit

