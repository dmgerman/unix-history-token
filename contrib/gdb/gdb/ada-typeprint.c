begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Support for printing Ada types for GDB, the GNU debugger.    Copyright 1986, 1988, 1989, 1991, 1997, 2003 Free Software    Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_obstack.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_comment
comment|/* Binary File Description */
end_comment

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"c-lang.h"
end_include

begin_include
include|#
directive|include
file|"typeprint.h"
end_include

begin_include
include|#
directive|include
file|"ada-lang.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_function_decl
specifier|static
name|int
name|print_record_field_types
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_array_type
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_choices
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|,
name|struct
name|type
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_range
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_range_bound
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_dynamic_range_bound
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|print_range_type_named
parameter_list|(
name|char
modifier|*
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|char
modifier|*
name|name_buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|name_buffer_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The (demangled) Ada name of TYPE. This value persists until the    next call. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|demangled_type_name
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|)
block|{
if|if
condition|(
name|ada_type_name
argument_list|(
name|type
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
else|else
block|{
name|char
modifier|*
name|raw_name
init|=
name|ada_type_name
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|name_buffer
operator|==
name|NULL
operator|||
name|name_buffer_len
operator|<=
name|strlen
argument_list|(
name|raw_name
argument_list|)
condition|)
block|{
name|name_buffer_len
operator|=
literal|16
operator|+
literal|2
operator|*
name|strlen
argument_list|(
name|raw_name
argument_list|)
expr_stmt|;
name|name_buffer
operator|=
name|xrealloc
argument_list|(
name|name_buffer
argument_list|,
name|name_buffer_len
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|name_buffer
argument_list|,
name|raw_name
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|strstr
argument_list|(
name|name_buffer
argument_list|,
literal|"___"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|NULL
condition|)
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|s
operator|=
name|name_buffer
operator|+
name|strlen
argument_list|(
name|name_buffer
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|s
operator|>
name|name_buffer
operator|&&
operator|(
name|s
index|[
literal|0
index|]
operator|!=
literal|'_'
operator|||
name|s
index|[
operator|-
literal|1
index|]
operator|!=
literal|'_'
operator|)
condition|)
name|s
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|name_buffer
condition|)
return|return
name|name_buffer
return|;
if|if
condition|(
operator|!
name|islower
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|s
operator|=
name|q
operator|=
name|name_buffer
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|q
operator|+=
literal|1
control|)
block|{
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|s
index|[
literal|1
index|]
operator|==
literal|'_'
condition|)
block|{
operator|*
name|q
operator|=
literal|'.'
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
operator|*
name|q
operator|=
operator|*
name|s
expr_stmt|;
name|s
operator|+=
literal|1
expr_stmt|;
block|}
block|}
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
return|return
name|name_buffer
return|;
block|}
block|}
end_function

begin_comment
comment|/* Print a description of a type in the format of a     typedef for the current language.    NEW is the new name for a type TYPE. */
end_comment

begin_function
name|void
name|ada_typedef_print
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|symbol
modifier|*
name|new
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"type %.*s is "
argument_list|,
name|ada_name_prefix_len
argument_list|(
name|SYMBOL_PRINT_NAME
argument_list|(
name|new
argument_list|)
argument_list|)
argument_list|,
name|SYMBOL_PRINT_NAME
argument_list|(
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print range type TYPE on STREAM. */
end_comment

begin_function
specifier|static
name|void
name|print_range
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|target_type
decl_stmt|;
name|target_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_type
operator|==
name|NULL
condition|)
name|target_type
operator|=
name|type
expr_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|target_type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_RANGE
case|:
case|case
name|TYPE_CODE_INT
case|:
case|case
name|TYPE_CODE_BOOL
case|:
case|case
name|TYPE_CODE_CHAR
case|:
case|case
name|TYPE_CODE_ENUM
case|:
break|break;
default|default:
name|target_type
operator|=
name|builtin_type_ada_int
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|<
literal|2
condition|)
block|{
comment|/* A range needs at least 2 bounds to be printed. If there are less          than 2, just print the type name instead of the range itself.          This check handles cases such as characters, for example.            Note that if the name is not defined, then we don't print anything.        */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%.*s"
argument_list|,
name|ada_name_prefix_len
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
argument_list|,
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We extract the range type bounds respectively from the first element          and the last element of the type->fields array */
specifier|const
name|LONGEST
name|lower_bound
init|=
operator|(
name|LONGEST
operator|)
name|TYPE_LOW_BOUND
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|const
name|LONGEST
name|upper_bound
init|=
operator|(
name|LONGEST
operator|)
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|-
literal|1
argument_list|)
decl_stmt|;
name|ada_print_scalar
argument_list|(
name|target_type
argument_list|,
name|lower_bound
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" .. "
argument_list|)
expr_stmt|;
name|ada_print_scalar
argument_list|(
name|target_type
argument_list|,
name|upper_bound
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print the number or discriminant bound at BOUNDS+*N on STREAM, and    set *N past the bound and its delimiter, if any. */
end_comment

begin_function
specifier|static
name|void
name|print_range_bound
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|bounds
parameter_list|,
name|int
modifier|*
name|n
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|LONGEST
name|B
decl_stmt|;
if|if
condition|(
name|ada_scan_number
argument_list|(
name|bounds
argument_list|,
operator|*
name|n
argument_list|,
operator|&
name|B
argument_list|,
name|n
argument_list|)
condition|)
block|{
name|ada_print_scalar
argument_list|(
name|type
argument_list|,
name|B
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|bounds
index|[
operator|*
name|n
index|]
operator|==
literal|'_'
condition|)
operator|*
name|n
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|int
name|bound_len
decl_stmt|;
name|char
modifier|*
name|bound
init|=
name|bounds
operator|+
operator|*
name|n
decl_stmt|;
name|char
modifier|*
name|pend
decl_stmt|;
name|pend
operator|=
name|strstr
argument_list|(
name|bound
argument_list|,
literal|"__"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pend
operator|==
name|NULL
condition|)
operator|*
name|n
operator|+=
name|bound_len
operator|=
name|strlen
argument_list|(
name|bound
argument_list|)
expr_stmt|;
else|else
block|{
name|bound_len
operator|=
name|pend
operator|-
name|bound
expr_stmt|;
operator|*
name|n
operator|+=
name|bound_len
operator|+
literal|2
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%.*s"
argument_list|,
name|bound_len
argument_list|,
name|bound
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Assuming NAME[0 .. NAME_LEN-1] is the name of a range type, print    the value (if found) of the bound indicated by SUFFIX ("___L" or    "___U") according to the ___XD conventions. */
end_comment

begin_function
specifier|static
name|void
name|print_dynamic_range_bound
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|name_len
parameter_list|,
specifier|const
name|char
modifier|*
name|suffix
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|name_buf
init|=
name|NULL
decl_stmt|;
specifier|static
name|size_t
name|name_buf_len
init|=
literal|0
decl_stmt|;
name|LONGEST
name|B
decl_stmt|;
name|int
name|OK
decl_stmt|;
name|GROW_VECT
argument_list|(
name|name_buf
argument_list|,
name|name_buf_len
argument_list|,
name|name_len
operator|+
name|strlen
argument_list|(
name|suffix
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|name_buf
argument_list|,
name|name
argument_list|,
name|name_len
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name_buf
operator|+
name|name_len
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
name|B
operator|=
name|get_int_var_value
argument_list|(
name|name_buf
argument_list|,
literal|0
argument_list|,
operator|&
name|OK
argument_list|)
expr_stmt|;
if|if
condition|(
name|OK
condition|)
name|ada_print_scalar
argument_list|(
name|type
argument_list|,
name|B
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"?"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the range type named NAME. */
end_comment

begin_function
specifier|static
name|void
name|print_range_type_named
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|raw_type
init|=
name|ada_find_any_type
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|base_type
decl_stmt|;
name|LONGEST
name|low
decl_stmt|,
name|high
decl_stmt|;
name|char
modifier|*
name|subtype_info
decl_stmt|;
if|if
condition|(
name|raw_type
operator|==
name|NULL
condition|)
name|base_type
operator|=
name|builtin_type_int
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|raw_type
argument_list|)
operator|==
name|TYPE_CODE_RANGE
condition|)
name|base_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|raw_type
argument_list|)
expr_stmt|;
else|else
name|base_type
operator|=
name|raw_type
expr_stmt|;
name|subtype_info
operator|=
name|strstr
argument_list|(
name|name
argument_list|,
literal|"___XD"
argument_list|)
expr_stmt|;
if|if
condition|(
name|subtype_info
operator|==
name|NULL
operator|&&
name|raw_type
operator|==
name|NULL
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"? .. ?"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|subtype_info
operator|==
name|NULL
condition|)
name|print_range
argument_list|(
name|raw_type
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|prefix_len
init|=
name|subtype_info
operator|-
name|name
decl_stmt|;
name|char
modifier|*
name|bounds_str
decl_stmt|;
name|int
name|n
decl_stmt|;
name|subtype_info
operator|+=
literal|5
expr_stmt|;
name|bounds_str
operator|=
name|strchr
argument_list|(
name|subtype_info
argument_list|,
literal|'_'
argument_list|)
expr_stmt|;
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|subtype_info
operator|==
literal|'L'
condition|)
block|{
name|print_range_bound
argument_list|(
name|raw_type
argument_list|,
name|bounds_str
argument_list|,
operator|&
name|n
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|subtype_info
operator|+=
literal|1
expr_stmt|;
block|}
else|else
name|print_dynamic_range_bound
argument_list|(
name|raw_type
argument_list|,
name|name
argument_list|,
name|prefix_len
argument_list|,
literal|"___L"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" .. "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|subtype_info
operator|==
literal|'U'
condition|)
name|print_range_bound
argument_list|(
name|raw_type
argument_list|,
name|bounds_str
argument_list|,
operator|&
name|n
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|print_dynamic_range_bound
argument_list|(
name|raw_type
argument_list|,
name|name
argument_list|,
name|prefix_len
argument_list|,
literal|"___U"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print enumerated type TYPE on STREAM. */
end_comment

begin_function
specifier|static
name|void
name|print_enum_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|int
name|len
init|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|lastval
decl_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|lastval
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|ada_enum_name
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastval
operator|!=
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" => %d"
argument_list|,
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|lastval
operator|=
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|lastval
operator|+=
literal|1
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print representation of Ada fixed-point type TYPE on STREAM. */
end_comment

begin_function
specifier|static
name|void
name|print_fixed_point_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|DOUBLEST
name|delta
init|=
name|ada_delta
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|DOUBLEST
name|small
init|=
name|ada_fixed_to_float
argument_list|(
name|type
argument_list|,
literal|1.0
argument_list|)
decl_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0.0
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"delta ??"
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"delta %g"
argument_list|,
operator|(
name|double
operator|)
name|delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|!=
name|small
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<'small = %g>"
argument_list|,
operator|(
name|double
operator|)
name|small
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print representation of special VAX floating-point type TYPE on STREAM. */
end_comment

begin_function
specifier|static
name|void
name|print_vax_floating_point_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<float format %c>"
argument_list|,
name|ada_vax_float_type_suffix
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print simple (constrained) array type TYPE on STREAM.  LEVEL is the     recursion (indentation) level, in case the element type itself has     nested structure, and SHOW is the number of levels of internal    structure to show (see ada_print_type). */
end_comment

begin_function
specifier|static
name|void
name|print_array_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|show
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|int
name|bitsize
decl_stmt|;
name|int
name|n_indices
decl_stmt|;
name|bitsize
operator|=
literal|0
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"array ("
argument_list|)
expr_stmt|;
name|n_indices
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|show
operator|<
literal|0
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ada_is_packed_array_type
argument_list|(
name|type
argument_list|)
condition|)
name|type
operator|=
name|ada_coerce_to_simple_array_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ada_is_simple_array
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|struct
name|type
modifier|*
name|range_desc_type
init|=
name|ada_find_parallel_type
argument_list|(
name|type
argument_list|,
literal|"___XA"
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|arr_type
decl_stmt|;
name|bitsize
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|range_desc_type
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|arr_type
operator|=
name|type
init|;
name|TYPE_CODE
argument_list|(
name|arr_type
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
condition|;
name|arr_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|arr_type
argument_list|)
control|)
block|{
if|if
condition|(
name|arr_type
operator|!=
name|type
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|print_range
argument_list|(
name|TYPE_INDEX_TYPE
argument_list|(
name|arr_type
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FIELD_BITSIZE
argument_list|(
name|arr_type
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
name|bitsize
operator|=
name|TYPE_FIELD_BITSIZE
argument_list|(
name|arr_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|k
decl_stmt|;
name|n_indices
operator|=
name|TYPE_NFIELDS
argument_list|(
name|range_desc_type
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
operator|,
name|arr_type
operator|=
name|type
init|;
name|k
operator|<
name|n_indices
condition|;
name|k
operator|+=
literal|1
operator|,
name|arr_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|arr_type
argument_list|)
control|)
block|{
if|if
condition|(
name|k
operator|>
literal|0
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|print_range_type_named
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|range_desc_type
argument_list|,
name|k
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FIELD_BITSIZE
argument_list|(
name|arr_type
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
name|bitsize
operator|=
name|TYPE_FIELD_BITSIZE
argument_list|(
name|arr_type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|int
name|i
decl_stmt|,
name|i0
decl_stmt|;
for|for
control|(
name|i
operator|=
name|i0
operator|=
name|ada_array_arity
argument_list|(
name|type
argument_list|)
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|-=
literal|1
control|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s<>"
argument_list|,
name|i
operator|==
name|i0
condition|?
literal|""
else|:
literal|", "
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|") of "
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|ada_print_type
argument_list|(
name|ada_array_element_type
argument_list|(
name|type
argument_list|,
name|n_indices
argument_list|)
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
name|show
operator|==
literal|0
condition|?
literal|0
else|:
name|show
operator|-
literal|1
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitsize
operator|>
literal|0
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<packed: %d-bit elements>"
argument_list|,
name|bitsize
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the choices encoded by field FIELD_NUM of variant-part TYPE on    STREAM, assuming the VAL_TYPE is the type of the values. */
end_comment

begin_function
specifier|static
name|void
name|print_choices
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|field_num
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|struct
name|type
modifier|*
name|val_type
parameter_list|)
block|{
name|int
name|have_output
decl_stmt|;
name|int
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|field_num
argument_list|)
decl_stmt|;
name|have_output
operator|=
literal|0
expr_stmt|;
comment|/* Skip over leading 'V': NOTE soon to be obsolete. */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'V'
condition|)
block|{
if|if
condition|(
operator|!
name|ada_scan_number
argument_list|(
name|name
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
operator|&
name|p
argument_list|)
condition|)
goto|goto
name|Huh
goto|;
block|}
else|else
name|p
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
switch|switch
condition|(
name|name
index|[
name|p
index|]
condition|)
block|{
default|default:
return|return;
case|case
literal|'S'
case|:
case|case
literal|'R'
case|:
case|case
literal|'O'
case|:
if|if
condition|(
name|have_output
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" | "
argument_list|)
expr_stmt|;
name|have_output
operator|=
literal|1
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|name
index|[
name|p
index|]
condition|)
block|{
case|case
literal|'S'
case|:
block|{
name|LONGEST
name|W
decl_stmt|;
if|if
condition|(
operator|!
name|ada_scan_number
argument_list|(
name|name
argument_list|,
name|p
operator|+
literal|1
argument_list|,
operator|&
name|W
argument_list|,
operator|&
name|p
argument_list|)
condition|)
goto|goto
name|Huh
goto|;
name|ada_print_scalar
argument_list|(
name|val_type
argument_list|,
name|W
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'R'
case|:
block|{
name|LONGEST
name|L
decl_stmt|,
name|U
decl_stmt|;
if|if
condition|(
operator|!
name|ada_scan_number
argument_list|(
name|name
argument_list|,
name|p
operator|+
literal|1
argument_list|,
operator|&
name|L
argument_list|,
operator|&
name|p
argument_list|)
operator|||
name|name
index|[
name|p
index|]
operator|!=
literal|'T'
operator|||
operator|!
name|ada_scan_number
argument_list|(
name|name
argument_list|,
name|p
operator|+
literal|1
argument_list|,
operator|&
name|U
argument_list|,
operator|&
name|p
argument_list|)
condition|)
goto|goto
name|Huh
goto|;
name|ada_print_scalar
argument_list|(
name|val_type
argument_list|,
name|L
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" .. "
argument_list|)
expr_stmt|;
name|ada_print_scalar
argument_list|(
name|val_type
argument_list|,
name|U
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'O'
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"others"
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|Huh
label|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"??"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Assuming that field FIELD_NUM of TYPE is a VARIANTS field whose     discriminant is contained in OUTER_TYPE, print its variants on STREAM.      LEVEL is the recursion    (indentation) level, in case any of the fields themselves have    nested structure, and SHOW is the number of levels of internal structure    to show (see ada_print_type). For this purpose, fields nested in a    variant part are taken to be at the same level as the fields    immediately outside the variant part. */
end_comment

begin_function
specifier|static
name|void
name|print_variant_clauses
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|field_num
parameter_list|,
name|struct
name|type
modifier|*
name|outer_type
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|show
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|type
modifier|*
name|var_type
decl_stmt|;
name|struct
name|type
modifier|*
name|discr_type
decl_stmt|;
name|var_type
operator|=
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|field_num
argument_list|)
expr_stmt|;
name|discr_type
operator|=
name|ada_variant_discrim_type
argument_list|(
name|var_type
argument_list|,
name|outer_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|var_type
argument_list|)
operator|==
name|TYPE_CODE_PTR
condition|)
block|{
name|var_type
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|var_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FLAGS
argument_list|(
name|var_type
argument_list|)
operator|&
name|TYPE_FLAG_STUB
condition|)
block|{
name|var_type
operator|=
name|ada_find_parallel_type
argument_list|(
name|var_type
argument_list|,
literal|"___XVU"
argument_list|)
expr_stmt|;
if|if
condition|(
name|var_type
operator|==
name|NULL
condition|)
return|return;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_NFIELDS
argument_list|(
name|var_type
argument_list|)
condition|;
name|i
operator|+=
literal|1
control|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n%*swhen "
argument_list|,
name|level
operator|+
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|print_choices
argument_list|(
name|var_type
argument_list|,
name|i
argument_list|,
name|stream
argument_list|,
name|discr_type
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" =>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|print_record_field_types
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|var_type
argument_list|,
name|i
argument_list|)
argument_list|,
name|outer_type
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
name|level
operator|+
literal|4
argument_list|)
operator|<=
literal|0
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" null;"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Assuming that field FIELD_NUM of TYPE is a variant part whose     discriminants are contained in OUTER_TYPE, print a description of it    on STREAM.  LEVEL is the recursion (indentation) level, in case any of     the fields themselves have nested structure, and SHOW is the number of     levels of internal structure to show (see ada_print_type). For this     purpose, fields nested in a variant part are taken to be at the same     level as the fields immediately outside the variant part. */
end_comment

begin_function
specifier|static
name|void
name|print_variant_part
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|field_num
parameter_list|,
name|struct
name|type
modifier|*
name|outer_type
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|show
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n%*scase %s is"
argument_list|,
name|level
operator|+
literal|4
argument_list|,
literal|""
argument_list|,
name|ada_variant_discrim_name
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|field_num
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|print_variant_clauses
argument_list|(
name|type
argument_list|,
name|field_num
argument_list|,
name|outer_type
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
name|level
operator|+
literal|4
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n%*send case;"
argument_list|,
name|level
operator|+
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a description on STREAM of the fields in record type TYPE, whose     discriminants are in OUTER_TYPE.  LEVEL is the recursion (indentation)     level, in case any of the fields themselves have nested structure,     and SHOW is the number of levels of internal structure to show     (see ada_print_type).  Does not print parent type information of TYPE.     Returns 0 if no fields printed, -1 for an incomplete type, else> 0.     Prints each field beginning on a new line, but does not put a new line at    end. */
end_comment

begin_function
specifier|static
name|int
name|print_record_field_types
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|type
modifier|*
name|outer_type
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|show
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|i
decl_stmt|,
name|flds
decl_stmt|;
name|flds
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
operator|&&
operator|(
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&
name|TYPE_FLAG_STUB
operator|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
literal|1
control|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|ada_is_parent_field
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|||
name|ada_is_ignored_field
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|ada_is_wrapper_field
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
name|flds
operator|+=
name|print_record_field_types
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|type
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
name|level
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ada_is_variant_part
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|print_variant_part
argument_list|(
name|type
argument_list|,
name|i
argument_list|,
name|outer_type
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|flds
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|flds
operator|+=
literal|1
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n%*s"
argument_list|,
name|level
operator|+
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|ada_print_type
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|stream
argument_list|,
name|show
operator|-
literal|1
argument_list|,
name|level
operator|+
literal|4
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|flds
return|;
block|}
end_function

begin_comment
comment|/* Print record type TYPE on STREAM.  LEVEL is the recursion (indentation)     level, in case the element type itself has nested structure, and SHOW is     the number of levels of internal structure to show (see ada_print_type). */
end_comment

begin_function
specifier|static
name|void
name|print_record_type
parameter_list|(
name|struct
name|type
modifier|*
name|type0
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|show
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|parent_type
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|type
operator|=
name|type0
expr_stmt|;
if|if
condition|(
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&
name|TYPE_FLAG_STUB
condition|)
block|{
name|struct
name|type
modifier|*
name|type1
init|=
name|ada_find_parallel_type
argument_list|(
name|type
argument_list|,
literal|"___XVE"
argument_list|)
decl_stmt|;
if|if
condition|(
name|type1
operator|!=
name|NULL
condition|)
name|type
operator|=
name|type1
expr_stmt|;
block|}
name|parent_type
operator|=
name|ada_parent_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ada_type_name
argument_list|(
name|parent_type
argument_list|)
operator|!=
name|NULL
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"new %s with "
argument_list|,
name|demangled_type_name
argument_list|(
name|parent_type
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|parent_type
operator|==
name|NULL
operator|&&
name|ada_is_tagged_type
argument_list|(
name|type
argument_list|)
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"tagged "
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"record"
argument_list|)
expr_stmt|;
if|if
condition|(
name|show
operator|<
literal|0
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" ... end record"
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|flds
decl_stmt|;
name|flds
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|parent_type
operator|!=
name|NULL
operator|&&
name|ada_type_name
argument_list|(
name|parent_type
argument_list|)
operator|==
name|NULL
condition|)
name|flds
operator|+=
name|print_record_field_types
argument_list|(
name|parent_type
argument_list|,
name|parent_type
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|flds
operator|+=
name|print_record_field_types
argument_list|(
name|type
argument_list|,
name|type
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
name|level
argument_list|)
expr_stmt|;
if|if
condition|(
name|flds
operator|>
literal|0
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n%*send record"
argument_list|,
name|level
argument_list|,
literal|""
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flds
operator|<
literal|0
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<incomplete type> end record"
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" null; end record"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print the unchecked union type TYPE in something resembling Ada    format on STREAM. LEVEL is the recursion (indentation) level    in case the element type itself has nested structure, and SHOW is the    number of levels of internal structure to show (see ada_print_type). */
end_comment

begin_function
specifier|static
name|void
name|print_unchecked_union_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|show
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"record (?) is"
argument_list|)
expr_stmt|;
if|if
condition|(
name|show
operator|<
literal|0
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" ... end record"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|==
literal|0
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" null; end record"
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n%*scase ? is"
argument_list|,
name|level
operator|+
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
condition|;
name|i
operator|+=
literal|1
control|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n%*swhen ? =>\n%*s"
argument_list|,
name|level
operator|+
literal|8
argument_list|,
literal|""
argument_list|,
name|level
operator|+
literal|12
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|ada_print_type
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|stream
argument_list|,
name|show
operator|-
literal|1
argument_list|,
name|level
operator|+
literal|12
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|";"
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n%*send case;\n%*send record"
argument_list|,
name|level
operator|+
literal|4
argument_list|,
literal|""
argument_list|,
name|level
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print function or procedure type TYPE on STREAM.  Make it a header    for function or procedure NAME if NAME is not null. */
end_comment

begin_function
specifier|static
name|void
name|print_func_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|len
init|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_VOID
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"procedure"
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"function"
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
operator|&&
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
literal|1
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"; "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"a%d: "
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ada_print_type
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_VOID
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" return "
argument_list|)
expr_stmt|;
name|ada_print_type
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print a description of a type TYPE0.    Output goes to STREAM (via stdio).    If VARSTRING is a non-empty string, print as an Ada variable/field        declaration.    SHOW+1 is the maximum number of levels of internal type structure        to show (this applies to record types, enumerated types, and       array types).    SHOW is the number of levels of internal type structure to show       when there is a type name for the SHOWth deepest level (0th is        outer level).    When SHOW<0, no inner structure is shown.    LEVEL indicates level of recursion (for nested definitions). */
end_comment

begin_function
name|void
name|ada_print_type
parameter_list|(
name|struct
name|type
modifier|*
name|type0
parameter_list|,
name|char
modifier|*
name|varstring
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|show
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|enum
name|type_code
name|code
decl_stmt|;
name|int
name|demangled_args
decl_stmt|;
name|struct
name|type
modifier|*
name|type
init|=
name|ada_completed_type
argument_list|(
name|ada_get_base_type
argument_list|(
name|type0
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|type_name
init|=
name|demangled_type_name
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|is_var_decl
init|=
operator|(
name|varstring
operator|!=
name|NULL
operator|&&
name|varstring
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|is_var_decl
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%.*s: "
argument_list|,
name|ada_name_prefix_len
argument_list|(
name|varstring
argument_list|)
argument_list|,
name|varstring
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<null type?>"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|show
operator|>
literal|0
condition|)
name|CHECK_TYPEDEF
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_var_decl
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|!=
name|TYPE_CODE_FUNC
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%.*s: "
argument_list|,
name|ada_name_prefix_len
argument_list|(
name|varstring
argument_list|)
argument_list|,
name|varstring
argument_list|)
expr_stmt|;
if|if
condition|(
name|type_name
operator|!=
name|NULL
operator|&&
name|show
operator|<=
literal|0
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%.*s"
argument_list|,
name|ada_name_prefix_len
argument_list|(
name|type_name
argument_list|)
argument_list|,
name|type_name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ada_is_aligner_type
argument_list|(
name|type
argument_list|)
condition|)
name|ada_print_type
argument_list|(
name|ada_aligned_type
argument_list|(
name|type
argument_list|)
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
name|level
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ada_is_packed_array_type
argument_list|(
name|type
argument_list|)
condition|)
name|print_array_type
argument_list|(
name|type
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
name|level
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
default|default:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<"
argument_list|)
expr_stmt|;
name|c_print_type
argument_list|(
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|">"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_PTR
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"access "
argument_list|)
expr_stmt|;
name|ada_print_type
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
name|level
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_REF
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<ref> "
argument_list|)
expr_stmt|;
name|ada_print_type
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
name|level
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_ARRAY
case|:
name|print_array_type
argument_list|(
name|type
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
name|level
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_INT
case|:
if|if
condition|(
name|ada_is_fixed_point_type
argument_list|(
name|type
argument_list|)
condition|)
name|print_fixed_point_type
argument_list|(
name|type
argument_list|,
name|stream
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ada_is_vax_floating_type
argument_list|(
name|type
argument_list|)
condition|)
name|print_vax_floating_point_type
argument_list|(
name|type
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|name
init|=
name|ada_type_name
argument_list|(
name|type
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ada_is_range_type_name
argument_list|(
name|name
argument_list|)
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<%d-byte integer>"
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"range "
argument_list|)
expr_stmt|;
name|print_range_type_named
argument_list|(
name|name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|TYPE_CODE_RANGE
case|:
if|if
condition|(
name|ada_is_fixed_point_type
argument_list|(
name|type
argument_list|)
condition|)
name|print_fixed_point_type
argument_list|(
name|type
argument_list|,
name|stream
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ada_is_vax_floating_type
argument_list|(
name|type
argument_list|)
condition|)
name|print_vax_floating_point_type
argument_list|(
name|type
argument_list|,
name|stream
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ada_is_modular_type
argument_list|(
name|type
argument_list|)
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"mod %ld"
argument_list|,
operator|(
name|long
operator|)
name|ada_modulus
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"range "
argument_list|)
expr_stmt|;
name|print_range
argument_list|(
name|type
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_FLT
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<%d-byte float>"
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_ENUM
case|:
if|if
condition|(
name|show
operator|<
literal|0
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"(...)"
argument_list|)
expr_stmt|;
else|else
name|print_enum_type
argument_list|(
name|type
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_STRUCT
case|:
if|if
condition|(
name|ada_is_array_descriptor
argument_list|(
name|type
argument_list|)
condition|)
name|print_array_type
argument_list|(
name|type
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
name|level
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ada_is_bogus_array_descriptor
argument_list|(
name|type
argument_list|)
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"array (?) of ? (<mal-formed descriptor>)"
argument_list|)
expr_stmt|;
else|else
name|print_record_type
argument_list|(
name|type
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
name|level
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_UNION
case|:
name|print_unchecked_union_type
argument_list|(
name|type
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
name|level
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_FUNC
case|:
name|print_func_type
argument_list|(
name|type
argument_list|,
name|stream
argument_list|,
name|varstring
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

end_unit

