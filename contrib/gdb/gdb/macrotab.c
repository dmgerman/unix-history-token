begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* C preprocessor macro tables for GDB.    Copyright 2002 Free Software Foundation, Inc.    Contributed by Red Hat, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_obstack.h"
end_include

begin_include
include|#
directive|include
file|"splay-tree.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"macrotab.h"
end_include

begin_include
include|#
directive|include
file|"gdb_assert.h"
end_include

begin_include
include|#
directive|include
file|"bcache.h"
end_include

begin_include
include|#
directive|include
file|"complaints.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* The macro table structure.  */
end_comment

begin_struct
struct|struct
name|macro_table
block|{
comment|/* The obstack this table's data should be allocated in, or zero if      we should use xmalloc.  */
name|struct
name|obstack
modifier|*
name|obstack
decl_stmt|;
comment|/* The bcache we should use to hold macro names, argument names, and      definitions, or zero if we should use xmalloc.  */
name|struct
name|bcache
modifier|*
name|bcache
decl_stmt|;
comment|/* The main source file for this compilation unit --- the one whose      name was given to the compiler.  This is the root of the      #inclusion tree; everything else is #included from here.  */
name|struct
name|macro_source_file
modifier|*
name|main_source
decl_stmt|;
comment|/* The table of macro definitions.  This is a splay tree (an ordered      binary tree that stays balanced, effectively), sorted by macro      name.  Where a macro gets defined more than once (presumably with      an #undefinition in between), we sort the definitions by the      order they would appear in the preprocessor's output.  That is,      if `a.c' #includes `m.h' and then #includes `n.h', and both      header files #define X (with an #undef somewhere in between),      then the definition from `m.h' appears in our splay tree before      the one from `n.h'.       The splay tree's keys are `struct macro_key' pointers;      the values are `struct macro_definition' pointers.       The splay tree, its nodes, and the keys and values are allocated      in obstack, if it's non-zero, or with xmalloc otherwise.  The      macro names, argument names, argument name arrays, and definition      strings are all allocated in bcache, if non-zero, or with xmalloc      otherwise.  */
name|splay_tree
name|definitions
decl_stmt|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* Allocation and freeing functions.  */
end_comment

begin_comment
comment|/* Allocate SIZE bytes of memory appropriately for the macro table T.    This just checks whether T has an obstack, or whether its pieces    should be allocated with xmalloc.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|macro_alloc
parameter_list|(
name|int
name|size
parameter_list|,
name|struct
name|macro_table
modifier|*
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|->
name|obstack
condition|)
return|return
name|obstack_alloc
argument_list|(
name|t
operator|->
name|obstack
argument_list|,
name|size
argument_list|)
return|;
else|else
return|return
name|xmalloc
argument_list|(
name|size
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|macro_free
parameter_list|(
name|void
modifier|*
name|object
parameter_list|,
name|struct
name|macro_table
modifier|*
name|t
parameter_list|)
block|{
name|gdb_assert
argument_list|(
operator|!
name|t
operator|->
name|obstack
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|object
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If the macro table T has a bcache, then cache the LEN bytes at ADDR    there, and return the cached copy.  Otherwise, just xmalloc a copy    of the bytes, and return a pointer to that.  */
end_comment

begin_function
specifier|static
specifier|const
name|void
modifier|*
name|macro_bcache
parameter_list|(
name|struct
name|macro_table
modifier|*
name|t
parameter_list|,
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|t
operator|->
name|bcache
condition|)
return|return
name|bcache
argument_list|(
name|addr
argument_list|,
name|len
argument_list|,
name|t
operator|->
name|bcache
argument_list|)
return|;
else|else
block|{
name|void
modifier|*
name|copy
init|=
name|xmalloc
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|copy
argument_list|,
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|copy
return|;
block|}
block|}
end_function

begin_comment
comment|/* If the macro table T has a bcache, cache the null-terminated string    S there, and return a pointer to the cached copy.  Otherwise,    xmalloc a copy and return that.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|macro_bcache_str
parameter_list|(
name|struct
name|macro_table
modifier|*
name|t
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
return|return
operator|(
name|char
operator|*
operator|)
name|macro_bcache
argument_list|(
name|t
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Free a possibly bcached object OBJ.  That is, if the macro table T    has a bcache, it's an error; otherwise, xfree OBJ.  */
end_comment

begin_function
specifier|static
name|void
name|macro_bcache_free
parameter_list|(
name|struct
name|macro_table
modifier|*
name|t
parameter_list|,
name|void
modifier|*
name|obj
parameter_list|)
block|{
name|gdb_assert
argument_list|(
operator|!
name|t
operator|->
name|bcache
argument_list|)
expr_stmt|;
name|xfree
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Macro tree keys, w/their comparison, allocation, and freeing functions.  */
end_comment

begin_comment
comment|/* A key in the splay tree.  */
end_comment

begin_struct
struct|struct
name|macro_key
block|{
comment|/* The table we're in.  We only need this in order to free it, since      the splay tree library's key and value freeing functions require      that the key or value contain all the information needed to free      themselves.  */
name|struct
name|macro_table
modifier|*
name|table
decl_stmt|;
comment|/* The name of the macro.  This is in the table's bcache, if it has      one. */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The source file and line number where the definition's scope      begins.  This is also the line of the definition itself.  */
name|struct
name|macro_source_file
modifier|*
name|start_file
decl_stmt|;
name|int
name|start_line
decl_stmt|;
comment|/* The first source file and line after the definition's scope.      (That is, the scope does not include this endpoint.)  If end_file      is zero, then the definition extends to the end of the      compilation unit.  */
name|struct
name|macro_source_file
modifier|*
name|end_file
decl_stmt|;
name|int
name|end_line
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Return the #inclusion depth of the source file FILE.  This is the    number of #inclusions it took to reach this file.  For the main    source file, the #inclusion depth is zero; for a file it #includes    directly, the depth would be one; and so on.  */
end_comment

begin_function
specifier|static
name|int
name|inclusion_depth
parameter_list|(
name|struct
name|macro_source_file
modifier|*
name|file
parameter_list|)
block|{
name|int
name|depth
decl_stmt|;
for|for
control|(
name|depth
operator|=
literal|0
init|;
name|file
operator|->
name|included_by
condition|;
name|depth
operator|++
control|)
name|file
operator|=
name|file
operator|->
name|included_by
expr_stmt|;
return|return
name|depth
return|;
block|}
end_function

begin_comment
comment|/* Compare two source locations (from the same compilation unit).    This is part of the comparison function for the tree of    definitions.     LINE1 and LINE2 are line numbers in the source files FILE1 and    FILE2.  Return a value:    - less than zero if {LINE,FILE}1 comes before {LINE,FILE}2,    - greater than zero if {LINE,FILE}1 comes after {LINE,FILE}2, or    - zero if they are equal.     When the two locations are in different source files --- perhaps    one is in a header, while another is in the main source file --- we    order them by where they would appear in the fully pre-processed    sources, where all the #included files have been substituted into    their places.  */
end_comment

begin_function
specifier|static
name|int
name|compare_locations
parameter_list|(
name|struct
name|macro_source_file
modifier|*
name|file1
parameter_list|,
name|int
name|line1
parameter_list|,
name|struct
name|macro_source_file
modifier|*
name|file2
parameter_list|,
name|int
name|line2
parameter_list|)
block|{
comment|/* We want to treat positions in an #included file as coming *after*      the line containing the #include, but *before* the line after the      include.  As we walk up the #inclusion tree toward the main      source file, we update fileX and lineX as we go; includedX      indicates whether the original position was from the #included      file.  */
name|int
name|included1
init|=
literal|0
decl_stmt|;
name|int
name|included2
init|=
literal|0
decl_stmt|;
comment|/* If a file is zero, that means "end of compilation unit."  Handle      that specially.  */
if|if
condition|(
operator|!
name|file1
condition|)
block|{
if|if
condition|(
operator|!
name|file2
condition|)
return|return
literal|0
return|;
else|else
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|file2
condition|)
return|return
operator|-
literal|1
return|;
comment|/* If the two files are not the same, find their common ancestor in      the #inclusion tree.  */
if|if
condition|(
name|file1
operator|!=
name|file2
condition|)
block|{
comment|/* If one file is deeper than the other, walk up the #inclusion          chain until the two files are at least at the same *depth*.          Then, walk up both files in synchrony until they're the same          file.  That file is the common ancestor.  */
name|int
name|depth1
init|=
name|inclusion_depth
argument_list|(
name|file1
argument_list|)
decl_stmt|;
name|int
name|depth2
init|=
name|inclusion_depth
argument_list|(
name|file2
argument_list|)
decl_stmt|;
comment|/* Only one of these while loops will ever execute in any given          case.  */
while|while
condition|(
name|depth1
operator|>
name|depth2
condition|)
block|{
name|line1
operator|=
name|file1
operator|->
name|included_at_line
expr_stmt|;
name|file1
operator|=
name|file1
operator|->
name|included_by
expr_stmt|;
name|included1
operator|=
literal|1
expr_stmt|;
name|depth1
operator|--
expr_stmt|;
block|}
while|while
condition|(
name|depth2
operator|>
name|depth1
condition|)
block|{
name|line2
operator|=
name|file2
operator|->
name|included_at_line
expr_stmt|;
name|file2
operator|=
name|file2
operator|->
name|included_by
expr_stmt|;
name|included2
operator|=
literal|1
expr_stmt|;
name|depth2
operator|--
expr_stmt|;
block|}
comment|/* Now both file1 and file2 are at the same depth.  Walk toward          the root of the tree until we find where the branches meet.  */
while|while
condition|(
name|file1
operator|!=
name|file2
condition|)
block|{
name|line1
operator|=
name|file1
operator|->
name|included_at_line
expr_stmt|;
name|file1
operator|=
name|file1
operator|->
name|included_by
expr_stmt|;
comment|/* At this point, we know that the case the includedX flags              are trying to deal with won't come up, but we'll just              maintain them anyway.  */
name|included1
operator|=
literal|1
expr_stmt|;
name|line2
operator|=
name|file2
operator|->
name|included_at_line
expr_stmt|;
name|file2
operator|=
name|file2
operator|->
name|included_by
expr_stmt|;
name|included2
operator|=
literal|1
expr_stmt|;
comment|/* Sanity check.  If file1 and file2 are really from the              same compilation unit, then they should both be part of              the same tree, and this shouldn't happen.  */
name|gdb_assert
argument_list|(
name|file1
operator|&&
name|file2
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now we've got two line numbers in the same file.  */
if|if
condition|(
name|line1
operator|==
name|line2
condition|)
block|{
comment|/* They can't both be from #included files.  Then we shouldn't          have walked up this far.  */
name|gdb_assert
argument_list|(
operator|!
name|included1
operator|||
operator|!
name|included2
argument_list|)
expr_stmt|;
comment|/* Any #included position comes after a non-#included position          with the same line number in the #including file.  */
if|if
condition|(
name|included1
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|included2
condition|)
return|return
operator|-
literal|1
return|;
else|else
return|return
literal|0
return|;
block|}
else|else
return|return
name|line1
operator|-
name|line2
return|;
block|}
end_function

begin_comment
comment|/* Compare a macro key KEY against NAME, the source file FILE, and    line number LINE.     Sort definitions by name; for two definitions with the same name,    place the one whose definition comes earlier before the one whose    definition comes later.     Return -1, 0, or 1 if key comes before, is identical to, or comes    after NAME, FILE, and LINE.  */
end_comment

begin_function
specifier|static
name|int
name|key_compare
parameter_list|(
name|struct
name|macro_key
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|macro_source_file
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|int
name|names
init|=
name|strcmp
argument_list|(
name|key
operator|->
name|name
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|names
condition|)
return|return
name|names
return|;
return|return
name|compare_locations
argument_list|(
name|key
operator|->
name|start_file
argument_list|,
name|key
operator|->
name|start_line
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The macro tree comparison function, typed for the splay tree    library's happiness.  */
end_comment

begin_function
specifier|static
name|int
name|macro_tree_compare
parameter_list|(
name|splay_tree_key
name|untyped_key1
parameter_list|,
name|splay_tree_key
name|untyped_key2
parameter_list|)
block|{
name|struct
name|macro_key
modifier|*
name|key1
init|=
operator|(
expr|struct
name|macro_key
operator|*
operator|)
name|untyped_key1
decl_stmt|;
name|struct
name|macro_key
modifier|*
name|key2
init|=
operator|(
expr|struct
name|macro_key
operator|*
operator|)
name|untyped_key2
decl_stmt|;
return|return
name|key_compare
argument_list|(
name|key1
argument_list|,
name|key2
operator|->
name|name
argument_list|,
name|key2
operator|->
name|start_file
argument_list|,
name|key2
operator|->
name|start_line
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Construct a new macro key node for a macro in table T whose name is    NAME, and whose scope starts at LINE in FILE; register the name in    the bcache.  */
end_comment

begin_function
specifier|static
name|struct
name|macro_key
modifier|*
name|new_macro_key
parameter_list|(
name|struct
name|macro_table
modifier|*
name|t
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|macro_source_file
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|struct
name|macro_key
modifier|*
name|k
init|=
name|macro_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|k
argument_list|)
argument_list|,
name|t
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|k
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|k
argument_list|)
argument_list|)
expr_stmt|;
name|k
operator|->
name|table
operator|=
name|t
expr_stmt|;
name|k
operator|->
name|name
operator|=
name|macro_bcache_str
argument_list|(
name|t
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|k
operator|->
name|start_file
operator|=
name|file
expr_stmt|;
name|k
operator|->
name|start_line
operator|=
name|line
expr_stmt|;
name|k
operator|->
name|end_file
operator|=
literal|0
expr_stmt|;
return|return
name|k
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|macro_tree_delete_key
parameter_list|(
name|void
modifier|*
name|untyped_key
parameter_list|)
block|{
name|struct
name|macro_key
modifier|*
name|key
init|=
operator|(
expr|struct
name|macro_key
operator|*
operator|)
name|untyped_key
decl_stmt|;
name|macro_bcache_free
argument_list|(
name|key
operator|->
name|table
argument_list|,
operator|(
name|char
operator|*
operator|)
name|key
operator|->
name|name
argument_list|)
expr_stmt|;
name|macro_free
argument_list|(
name|key
argument_list|,
name|key
operator|->
name|table
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Building and querying the tree of #included files.  */
end_comment

begin_comment
comment|/* Allocate and initialize a new source file structure.  */
end_comment

begin_function
specifier|static
name|struct
name|macro_source_file
modifier|*
name|new_source_file
parameter_list|(
name|struct
name|macro_table
modifier|*
name|t
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
comment|/* Get space for the source file structure itself.  */
name|struct
name|macro_source_file
modifier|*
name|f
init|=
name|macro_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|f
argument_list|)
argument_list|,
name|t
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|f
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|f
argument_list|)
argument_list|)
expr_stmt|;
name|f
operator|->
name|table
operator|=
name|t
expr_stmt|;
name|f
operator|->
name|filename
operator|=
name|macro_bcache_str
argument_list|(
name|t
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|f
operator|->
name|includes
operator|=
literal|0
expr_stmt|;
return|return
name|f
return|;
block|}
end_function

begin_comment
comment|/* Free a source file, and all the source files it #included.  */
end_comment

begin_function
specifier|static
name|void
name|free_macro_source_file
parameter_list|(
name|struct
name|macro_source_file
modifier|*
name|src
parameter_list|)
block|{
name|struct
name|macro_source_file
modifier|*
name|child
decl_stmt|,
modifier|*
name|next_child
decl_stmt|;
comment|/* Free this file's children.  */
for|for
control|(
name|child
operator|=
name|src
operator|->
name|includes
init|;
name|child
condition|;
name|child
operator|=
name|next_child
control|)
block|{
name|next_child
operator|=
name|child
operator|->
name|next_included
expr_stmt|;
name|free_macro_source_file
argument_list|(
name|child
argument_list|)
expr_stmt|;
block|}
name|macro_bcache_free
argument_list|(
name|src
operator|->
name|table
argument_list|,
operator|(
name|char
operator|*
operator|)
name|src
operator|->
name|filename
argument_list|)
expr_stmt|;
name|macro_free
argument_list|(
name|src
argument_list|,
name|src
operator|->
name|table
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|macro_source_file
modifier|*
name|macro_set_main
parameter_list|(
name|struct
name|macro_table
modifier|*
name|t
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
comment|/* You can't change a table's main source file.  What would that do      to the tree?  */
name|gdb_assert
argument_list|(
operator|!
name|t
operator|->
name|main_source
argument_list|)
expr_stmt|;
name|t
operator|->
name|main_source
operator|=
name|new_source_file
argument_list|(
name|t
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
name|t
operator|->
name|main_source
return|;
block|}
end_function

begin_function
name|struct
name|macro_source_file
modifier|*
name|macro_main
parameter_list|(
name|struct
name|macro_table
modifier|*
name|t
parameter_list|)
block|{
name|gdb_assert
argument_list|(
name|t
operator|->
name|main_source
argument_list|)
expr_stmt|;
return|return
name|t
operator|->
name|main_source
return|;
block|}
end_function

begin_function
name|struct
name|macro_source_file
modifier|*
name|macro_include
parameter_list|(
name|struct
name|macro_source_file
modifier|*
name|source
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|included
parameter_list|)
block|{
name|struct
name|macro_source_file
modifier|*
name|new
decl_stmt|;
name|struct
name|macro_source_file
modifier|*
modifier|*
name|link
decl_stmt|;
comment|/* Find the right position in SOURCE's `includes' list for the new      file.  Skip inclusions at earlier lines, until we find one at the      same line or later --- or until the end of the list.  */
for|for
control|(
name|link
operator|=
operator|&
name|source
operator|->
name|includes
init|;
operator|*
name|link
operator|&&
operator|(
operator|*
name|link
operator|)
operator|->
name|included_at_line
operator|<
name|line
condition|;
name|link
operator|=
operator|&
operator|(
operator|*
name|link
operator|)
operator|->
name|next_included
control|)
empty_stmt|;
comment|/* Did we find another file already #included at the same line as      the new one?  */
if|if
condition|(
operator|*
name|link
operator|&&
name|line
operator|==
operator|(
operator|*
name|link
operator|)
operator|->
name|included_at_line
condition|)
block|{
comment|/* This means the compiler is emitting bogus debug info.  (GCC          circa March 2002 did this.)  It also means that the splay          tree ordering function, macro_tree_compare, will abort,          because it can't tell which #inclusion came first.  But GDB          should tolerate bad debug info.  So:           First, squawk.  */
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"both `%s' and `%s' allegedly #included at %s:%d"
argument_list|,
name|included
argument_list|,
operator|(
operator|*
name|link
operator|)
operator|->
name|filename
argument_list|,
name|source
operator|->
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* Now, choose a new, unoccupied line number for this          #inclusion, after the alleged #inclusion line.  */
while|while
condition|(
operator|*
name|link
operator|&&
name|line
operator|==
operator|(
operator|*
name|link
operator|)
operator|->
name|included_at_line
condition|)
block|{
comment|/* This line number is taken, so try the next line.  */
name|line
operator|++
expr_stmt|;
name|link
operator|=
operator|&
operator|(
operator|*
name|link
operator|)
operator|->
name|next_included
expr_stmt|;
block|}
block|}
comment|/* At this point, we know that LINE is an unused line number, and      *LINK points to the entry an #inclusion at that line should      precede.  */
name|new
operator|=
name|new_source_file
argument_list|(
name|source
operator|->
name|table
argument_list|,
name|included
argument_list|)
expr_stmt|;
name|new
operator|->
name|included_by
operator|=
name|source
expr_stmt|;
name|new
operator|->
name|included_at_line
operator|=
name|line
expr_stmt|;
name|new
operator|->
name|next_included
operator|=
operator|*
name|link
expr_stmt|;
operator|*
name|link
operator|=
name|new
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
name|struct
name|macro_source_file
modifier|*
name|macro_lookup_inclusion
parameter_list|(
name|struct
name|macro_source_file
modifier|*
name|source
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
comment|/* Is SOURCE itself named NAME?  */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|source
operator|->
name|filename
argument_list|)
operator|==
literal|0
condition|)
return|return
name|source
return|;
comment|/* The filename in the source structure is probably a full path, but      NAME could be just the final component of the name.  */
block|{
name|int
name|name_len
init|=
name|strlen
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|int
name|src_name_len
init|=
name|strlen
argument_list|(
name|source
operator|->
name|filename
argument_list|)
decl_stmt|;
comment|/* We do mean< here, and not<=; if the lengths are the same,        then the strcmp above should have triggered, and we need to        check for a slash here.  */
if|if
condition|(
name|name_len
operator|<
name|src_name_len
operator|&&
name|source
operator|->
name|filename
index|[
name|src_name_len
operator|-
name|name_len
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|source
operator|->
name|filename
operator|+
name|src_name_len
operator|-
name|name_len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|source
return|;
block|}
comment|/* It's not us.  Try all our children, and return the lowest.  */
block|{
name|struct
name|macro_source_file
modifier|*
name|child
decl_stmt|;
name|struct
name|macro_source_file
modifier|*
name|best
init|=
name|NULL
decl_stmt|;
name|int
name|best_depth
init|=
literal|0
decl_stmt|;
for|for
control|(
name|child
operator|=
name|source
operator|->
name|includes
init|;
name|child
condition|;
name|child
operator|=
name|child
operator|->
name|next_included
control|)
block|{
name|struct
name|macro_source_file
modifier|*
name|result
init|=
name|macro_lookup_inclusion
argument_list|(
name|child
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
condition|)
block|{
name|int
name|result_depth
init|=
name|inclusion_depth
argument_list|(
name|result
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|best
operator|||
name|result_depth
operator|<
name|best_depth
condition|)
block|{
name|best
operator|=
name|result
expr_stmt|;
name|best_depth
operator|=
name|result_depth
expr_stmt|;
block|}
block|}
block|}
return|return
name|best
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Registering and looking up macro definitions.  */
end_comment

begin_comment
comment|/* Construct a definition for a macro in table T.  Cache all strings,    and the macro_definition structure itself, in T's bcache.  */
end_comment

begin_function
specifier|static
name|struct
name|macro_definition
modifier|*
name|new_macro_definition
parameter_list|(
name|struct
name|macro_table
modifier|*
name|t
parameter_list|,
name|enum
name|macro_kind
name|kind
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|replacement
parameter_list|)
block|{
name|struct
name|macro_definition
modifier|*
name|d
init|=
name|macro_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|d
argument_list|)
argument_list|,
name|t
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|d
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|d
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|table
operator|=
name|t
expr_stmt|;
name|d
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
name|d
operator|->
name|replacement
operator|=
name|macro_bcache_str
argument_list|(
name|t
argument_list|,
name|replacement
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|macro_function_like
condition|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|cached_argv
decl_stmt|;
name|int
name|cached_argv_size
init|=
name|argc
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cached_argv
argument_list|)
decl_stmt|;
comment|/* Bcache all the arguments.  */
name|cached_argv
operator|=
name|alloca
argument_list|(
name|cached_argv_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
name|cached_argv
index|[
name|i
index|]
operator|=
name|macro_bcache_str
argument_list|(
name|t
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Now bcache the array of argument pointers itself.  */
name|d
operator|->
name|argv
operator|=
name|macro_bcache
argument_list|(
name|t
argument_list|,
name|cached_argv
argument_list|,
name|cached_argv_size
argument_list|)
expr_stmt|;
name|d
operator|->
name|argc
operator|=
name|argc
expr_stmt|;
block|}
comment|/* We don't bcache the entire definition structure because it's got      a pointer to the macro table in it; since each compilation unit      has its own macro table, you'd only get bcache hits for identical      definitions within a compilation unit, which seems unlikely.       "So, why do macro definitions have pointers to their macro tables      at all?"  Well, when the splay tree library wants to free a      node's value, it calls the value freeing function with nothing      but the value itself.  It makes the (apparently reasonable)      assumption that the value carries enough information to free      itself.  But not all macro tables have bcaches, so not all macro      definitions would be bcached.  There's no way to tell whether a      given definition is bcached without knowing which table the      definition belongs to.  ...  blah.  The thing's only sixteen      bytes anyway, and we can still bcache the name, args, and      definition, so we just don't bother bcaching the definition      structure itself.  */
return|return
name|d
return|;
block|}
end_function

begin_comment
comment|/* Free a macro definition.  */
end_comment

begin_function
specifier|static
name|void
name|macro_tree_delete_value
parameter_list|(
name|void
modifier|*
name|untyped_definition
parameter_list|)
block|{
name|struct
name|macro_definition
modifier|*
name|d
init|=
operator|(
expr|struct
name|macro_definition
operator|*
operator|)
name|untyped_definition
decl_stmt|;
name|struct
name|macro_table
modifier|*
name|t
init|=
name|d
operator|->
name|table
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|kind
operator|==
name|macro_function_like
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
operator|->
name|argc
condition|;
name|i
operator|++
control|)
name|macro_bcache_free
argument_list|(
name|t
argument_list|,
operator|(
name|char
operator|*
operator|)
name|d
operator|->
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|macro_bcache_free
argument_list|(
name|t
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|d
operator|->
name|argv
argument_list|)
expr_stmt|;
block|}
name|macro_bcache_free
argument_list|(
name|t
argument_list|,
operator|(
name|char
operator|*
operator|)
name|d
operator|->
name|replacement
argument_list|)
expr_stmt|;
name|macro_free
argument_list|(
name|d
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find the splay tree node for the definition of NAME at LINE in    SOURCE, or zero if there is none.  */
end_comment

begin_function
specifier|static
name|splay_tree_node
name|find_definition
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|macro_source_file
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|struct
name|macro_table
modifier|*
name|t
init|=
name|file
operator|->
name|table
decl_stmt|;
name|splay_tree_node
name|n
decl_stmt|;
comment|/* Construct a macro_key object, just for the query.  */
name|struct
name|macro_key
name|query
decl_stmt|;
name|query
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|query
operator|.
name|start_file
operator|=
name|file
expr_stmt|;
name|query
operator|.
name|start_line
operator|=
name|line
expr_stmt|;
name|query
operator|.
name|end_file
operator|=
name|NULL
expr_stmt|;
name|n
operator|=
name|splay_tree_lookup
argument_list|(
name|t
operator|->
name|definitions
argument_list|,
operator|(
name|splay_tree_key
operator|)
operator|&
name|query
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n
condition|)
block|{
comment|/* It's okay for us to do two queries like this: the real work          of the searching is done when we splay, and splaying the tree          a second time at the same key is a constant time operation.          If this still bugs you, you could always just extend the          splay tree library with a predecessor-or-equal operation, and          use that.  */
name|splay_tree_node
name|pred
init|=
name|splay_tree_predecessor
argument_list|(
name|t
operator|->
name|definitions
argument_list|,
operator|(
name|splay_tree_key
operator|)
operator|&
name|query
argument_list|)
decl_stmt|;
if|if
condition|(
name|pred
condition|)
block|{
comment|/* Make sure this predecessor actually has the right name.              We just want to search within a given name's definitions.  */
name|struct
name|macro_key
modifier|*
name|found
init|=
operator|(
expr|struct
name|macro_key
operator|*
operator|)
name|pred
operator|->
name|key
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|found
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
name|n
operator|=
name|pred
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
condition|)
block|{
name|struct
name|macro_key
modifier|*
name|found
init|=
operator|(
expr|struct
name|macro_key
operator|*
operator|)
name|n
operator|->
name|key
decl_stmt|;
comment|/* Okay, so this definition has the right name, and its scope          begins before the given source location.  But does its scope          end after the given source location?  */
if|if
condition|(
name|compare_locations
argument_list|(
name|file
argument_list|,
name|line
argument_list|,
name|found
operator|->
name|end_file
argument_list|,
name|found
operator|->
name|end_line
argument_list|)
operator|<
literal|0
condition|)
return|return
name|n
return|;
else|else
return|return
literal|0
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* If NAME already has a definition in scope at LINE in SOURCE, return    the key.  If the old definition is different from the definition    given by KIND, ARGC, ARGV, and REPLACEMENT, complain, too.    Otherwise, return zero.  (ARGC and ARGV are meaningless unless KIND    is `macro_function_like'.)  */
end_comment

begin_function
specifier|static
name|struct
name|macro_key
modifier|*
name|check_for_redefinition
parameter_list|(
name|struct
name|macro_source_file
modifier|*
name|source
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|enum
name|macro_kind
name|kind
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|replacement
parameter_list|)
block|{
name|splay_tree_node
name|n
init|=
name|find_definition
argument_list|(
name|name
argument_list|,
name|source
argument_list|,
name|line
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|struct
name|macro_key
modifier|*
name|found_key
init|=
operator|(
expr|struct
name|macro_key
operator|*
operator|)
name|n
operator|->
name|key
decl_stmt|;
name|struct
name|macro_definition
modifier|*
name|found_def
init|=
operator|(
expr|struct
name|macro_definition
operator|*
operator|)
name|n
operator|->
name|value
decl_stmt|;
name|int
name|same
init|=
literal|1
decl_stmt|;
comment|/* Is this definition the same as the existing one?          According to the standard, this comparison needs to be done          on lists of tokens, not byte-by-byte, as we do here.  But          that's too hard for us at the moment, and comparing          byte-by-byte will only yield false negatives (i.e., extra          warning messages), not false positives (i.e., unnoticed          definition changes).  */
if|if
condition|(
name|kind
operator|!=
name|found_def
operator|->
name|kind
condition|)
name|same
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|replacement
argument_list|,
name|found_def
operator|->
name|replacement
argument_list|)
condition|)
name|same
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|kind
operator|==
name|macro_function_like
condition|)
block|{
if|if
condition|(
name|argc
operator|!=
name|found_def
operator|->
name|argc
condition|)
name|same
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|found_def
operator|->
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
name|same
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|same
condition|)
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"macro `%s' redefined at %s:%d; original definition at %s:%d"
argument_list|,
name|name
argument_list|,
name|source
operator|->
name|filename
argument_list|,
name|line
argument_list|,
name|found_key
operator|->
name|start_file
operator|->
name|filename
argument_list|,
name|found_key
operator|->
name|start_line
argument_list|)
expr_stmt|;
block|}
return|return
name|found_key
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|macro_define_object
parameter_list|(
name|struct
name|macro_source_file
modifier|*
name|source
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|replacement
parameter_list|)
block|{
name|struct
name|macro_table
modifier|*
name|t
init|=
name|source
operator|->
name|table
decl_stmt|;
name|struct
name|macro_key
modifier|*
name|k
decl_stmt|;
name|struct
name|macro_definition
modifier|*
name|d
decl_stmt|;
name|k
operator|=
name|check_for_redefinition
argument_list|(
name|source
argument_list|,
name|line
argument_list|,
name|name
argument_list|,
name|macro_object_like
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|replacement
argument_list|)
expr_stmt|;
comment|/* If we're redefining a symbol, and the existing key would be      identical to our new key, then the splay_tree_insert function      will try to delete the old definition.  When the definition is      living on an obstack, this isn't a happy thing.       Since this only happens in the presence of questionable debug      info, we just ignore all definitions after the first.  The only      case I know of where this arises is in GCC's output for      predefined macros, and all the definitions are the same in that      case.  */
if|if
condition|(
name|k
operator|&&
operator|!
name|key_compare
argument_list|(
name|k
argument_list|,
name|name
argument_list|,
name|source
argument_list|,
name|line
argument_list|)
condition|)
return|return;
name|k
operator|=
name|new_macro_key
argument_list|(
name|t
argument_list|,
name|name
argument_list|,
name|source
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|d
operator|=
name|new_macro_definition
argument_list|(
name|t
argument_list|,
name|macro_object_like
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|replacement
argument_list|)
expr_stmt|;
name|splay_tree_insert
argument_list|(
name|t
operator|->
name|definitions
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|k
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|macro_define_function
parameter_list|(
name|struct
name|macro_source_file
modifier|*
name|source
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
name|replacement
parameter_list|)
block|{
name|struct
name|macro_table
modifier|*
name|t
init|=
name|source
operator|->
name|table
decl_stmt|;
name|struct
name|macro_key
modifier|*
name|k
decl_stmt|;
name|struct
name|macro_definition
modifier|*
name|d
decl_stmt|;
name|k
operator|=
name|check_for_redefinition
argument_list|(
name|source
argument_list|,
name|line
argument_list|,
name|name
argument_list|,
name|macro_function_like
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|replacement
argument_list|)
expr_stmt|;
comment|/* See comments about duplicate keys in macro_define_object.  */
if|if
condition|(
name|k
operator|&&
operator|!
name|key_compare
argument_list|(
name|k
argument_list|,
name|name
argument_list|,
name|source
argument_list|,
name|line
argument_list|)
condition|)
return|return;
comment|/* We should also check here that all the argument names in ARGV are      distinct.  */
name|k
operator|=
name|new_macro_key
argument_list|(
name|t
argument_list|,
name|name
argument_list|,
name|source
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|d
operator|=
name|new_macro_definition
argument_list|(
name|t
argument_list|,
name|macro_function_like
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|replacement
argument_list|)
expr_stmt|;
name|splay_tree_insert
argument_list|(
name|t
operator|->
name|definitions
argument_list|,
operator|(
name|splay_tree_key
operator|)
name|k
argument_list|,
operator|(
name|splay_tree_value
operator|)
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|macro_undef
parameter_list|(
name|struct
name|macro_source_file
modifier|*
name|source
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|splay_tree_node
name|n
init|=
name|find_definition
argument_list|(
name|name
argument_list|,
name|source
argument_list|,
name|line
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
block|{
comment|/* This function is the only place a macro's end-of-scope          location gets set to anything other than "end of the          compilation unit" (i.e., end_file is zero).  So if this macro          already has its end-of-scope set, then we're probably seeing          a second #undefinition for the same #definition.  */
name|struct
name|macro_key
modifier|*
name|key
init|=
operator|(
expr|struct
name|macro_key
operator|*
operator|)
name|n
operator|->
name|key
decl_stmt|;
if|if
condition|(
name|key
operator|->
name|end_file
condition|)
block|{
name|complaint
argument_list|(
operator|&
name|symfile_complaints
argument_list|,
literal|"macro '%s' is #undefined twice, at %s:%d and %s:%d"
argument_list|,
name|name
argument_list|,
name|source
operator|->
name|filename
argument_list|,
name|line
argument_list|,
name|key
operator|->
name|end_file
operator|->
name|filename
argument_list|,
name|key
operator|->
name|end_line
argument_list|)
expr_stmt|;
block|}
comment|/* Whatever the case, wipe out the old ending point, and           make this the ending point.  */
name|key
operator|->
name|end_file
operator|=
name|source
expr_stmt|;
name|key
operator|->
name|end_line
operator|=
name|line
expr_stmt|;
block|}
else|else
block|{
comment|/* According to the ISO C standard, an #undef for a symbol that          has no macro definition in scope is ignored.  So we should          ignore it too.  */
if|#
directive|if
literal|0
block|complaint (&symfile_complaints, 		 "no definition for macro `%s' in scope to #undef at %s:%d", 		 name, source->filename, line);
endif|#
directive|endif
block|}
block|}
end_function

begin_function
name|struct
name|macro_definition
modifier|*
name|macro_lookup_definition
parameter_list|(
name|struct
name|macro_source_file
modifier|*
name|source
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|splay_tree_node
name|n
init|=
name|find_definition
argument_list|(
name|name
argument_list|,
name|source
argument_list|,
name|line
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
return|return
operator|(
expr|struct
name|macro_definition
operator|*
operator|)
name|n
operator|->
name|value
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
name|struct
name|macro_source_file
modifier|*
name|macro_definition_location
parameter_list|(
name|struct
name|macro_source_file
modifier|*
name|source
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
modifier|*
name|definition_line
parameter_list|)
block|{
name|splay_tree_node
name|n
init|=
name|find_definition
argument_list|(
name|name
argument_list|,
name|source
argument_list|,
name|line
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|struct
name|macro_key
modifier|*
name|key
init|=
operator|(
expr|struct
name|macro_key
operator|*
operator|)
name|n
operator|->
name|key
decl_stmt|;
operator|*
name|definition_line
operator|=
name|key
operator|->
name|start_line
expr_stmt|;
return|return
name|key
operator|->
name|start_file
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Creating and freeing macro tables.  */
end_comment

begin_function
name|struct
name|macro_table
modifier|*
name|new_macro_table
parameter_list|(
name|struct
name|obstack
modifier|*
name|obstack
parameter_list|,
name|struct
name|bcache
modifier|*
name|b
parameter_list|)
block|{
name|struct
name|macro_table
modifier|*
name|t
decl_stmt|;
comment|/* First, get storage for the `struct macro_table' itself.  */
if|if
condition|(
name|obstack
condition|)
name|t
operator|=
name|obstack_alloc
argument_list|(
name|obstack
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|t
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|t
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|t
operator|->
name|obstack
operator|=
name|obstack
expr_stmt|;
name|t
operator|->
name|bcache
operator|=
name|b
expr_stmt|;
name|t
operator|->
name|main_source
operator|=
name|NULL
expr_stmt|;
name|t
operator|->
name|definitions
operator|=
operator|(
name|splay_tree_new_with_allocator
argument_list|(
name|macro_tree_compare
argument_list|,
operator|(
operator|(
name|splay_tree_delete_key_fn
operator|)
name|macro_tree_delete_key
operator|)
argument_list|,
operator|(
operator|(
name|splay_tree_delete_value_fn
operator|)
name|macro_tree_delete_value
operator|)
argument_list|,
operator|(
operator|(
name|splay_tree_allocate_fn
operator|)
name|macro_alloc
operator|)
argument_list|,
operator|(
operator|(
name|splay_tree_deallocate_fn
operator|)
name|macro_free
operator|)
argument_list|,
name|t
argument_list|)
operator|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
name|void
name|free_macro_table
parameter_list|(
name|struct
name|macro_table
modifier|*
name|table
parameter_list|)
block|{
comment|/* Free the source file tree.  */
name|free_macro_source_file
argument_list|(
name|table
operator|->
name|main_source
argument_list|)
expr_stmt|;
comment|/* Free the table of macro definitions.  */
name|splay_tree_delete
argument_list|(
name|table
operator|->
name|definitions
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

