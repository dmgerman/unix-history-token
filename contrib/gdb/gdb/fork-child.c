begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Fork a Unix child process, and set up to debug it, for GDB.    Copyright 1990, 1991, 1992, 1993, 1994, 1996 Free Software Foundation, Inc.    Contributed by Cygnus Support.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_comment
comment|/* required by inferior.h */
end_comment

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"terminal.h"
end_include

begin_include
include|#
directive|include
file|"gdbthread.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DEBUGGING
value|0
end_define

begin_comment
comment|/* This just gets used as a default if we can't find SHELL */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SHELL_FILE
end_ifndef

begin_define
define|#
directive|define
name|SHELL_FILE
value|"/bin/sh"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This function breaks up an argument string into an argument  * vector suitable for passing to execvp().  * E.g., on "run a b c d" this routine would get as input  * the string "a b c d", and as output it would fill in argv with  * the four arguments "a", "b", "c", "d".  */
end_comment

begin_function
specifier|static
name|void
name|breakup_args
parameter_list|(
name|scratch
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
name|scratch
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|cp
init|=
name|scratch
decl_stmt|;
if|#
directive|if
name|DEBUGGING
name|printf
argument_list|(
literal|"breakup_args: input = %s\n"
argument_list|,
name|scratch
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Scan past leading separators */
while|while
condition|(
operator|*
name|cp
operator|==
literal|' '
operator|||
operator|*
name|cp
operator|==
literal|'\t'
operator|||
operator|*
name|cp
operator|==
literal|'\n'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
comment|/* Break if at end of string */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
break|break;
comment|/* Take an arg */
operator|*
name|argv
operator|++
operator|=
name|cp
expr_stmt|;
comment|/* Scan for next arg separator */
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* No separators => end of string => break */
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
break|break;
comment|/* Replace the separator with a terminator */
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* execv requires a null-terminated arg vector */
operator|*
name|argv
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start an inferior Unix child process and sets inferior_pid to its pid.    EXEC_FILE is the file to run.    ALLARGS is a string containing the arguments to the program.    ENV is the environment vector to pass.  SHELL_FILE is the shell file,    or NULL if we should pick one.  Errors reported with error().  */
end_comment

begin_function_decl
name|void
name|fork_inferior
parameter_list|(
name|exec_file
parameter_list|,
name|allargs
parameter_list|,
name|env
parameter_list|,
name|traceme_fun
parameter_list|,
name|init_trace_fun
parameter_list|,
name|pre_trace_fun
parameter_list|,
name|shell_file
parameter_list|)
name|char
modifier|*
name|exec_file
decl_stmt|;
name|char
modifier|*
name|allargs
decl_stmt|;
name|char
modifier|*
modifier|*
name|env
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*traceme_fun
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|void
argument_list|(
argument|*init_trace_fun
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|void
argument_list|(
argument|*pre_trace_fun
argument_list|)
end_macro

begin_expr_stmt
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|shell_file
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|pid
decl_stmt|;
name|char
modifier|*
name|shell_command
decl_stmt|;
specifier|static
name|char
name|default_shell_file
index|[]
init|=
name|SHELL_FILE
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* Set debug_fork then attach to the child while it sleeps, to debug. */
specifier|static
name|int
name|debug_fork
init|=
literal|0
decl_stmt|;
comment|/* This is set to the result of setpgrp, which if vforked, will be visible      to you in the parent process.  It's only used by humans for debugging.  */
specifier|static
name|int
name|debug_setpgrp
init|=
literal|657473
decl_stmt|;
name|char
modifier|*
modifier|*
name|save_our_env
decl_stmt|;
name|int
name|shell
init|=
literal|0
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|char
modifier|*
name|tryname
decl_stmt|;
comment|/* If no exec file handed to us, get it from the exec-file command -- with      a good, common error message if none is specified.  */
if|if
condition|(
name|exec_file
operator|==
literal|0
condition|)
name|exec_file
operator|=
name|get_exec_file
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* STARTUP_WITH_SHELL is defined in inferior.h.    * If 0, we'll just do a fork/exec, no shell, so don't    * bother figuring out what shell.    */
if|if
condition|(
name|STARTUP_WITH_SHELL
condition|)
block|{
comment|/* Figure out what shell to start up the user program under. */
if|if
condition|(
name|shell_file
operator|==
name|NULL
condition|)
name|shell_file
operator|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|shell_file
operator|==
name|NULL
condition|)
name|shell_file
operator|=
name|default_shell_file
expr_stmt|;
name|shell
operator|=
literal|1
expr_stmt|;
block|}
if|#
directive|if
name|DEBUGGING
name|printf
argument_list|(
literal|"shell is %s\n"
argument_list|,
name|shell_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Multiplying the length of exec_file by 4 is to account for the fact      that it may expand when quoted; it is a worst-case number based on      every character being '.  */
name|len
operator|=
literal|5
operator|+
literal|4
operator|*
name|strlen
argument_list|(
name|exec_file
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|allargs
argument_list|)
operator|+
literal|1
operator|+
comment|/*slop*/
literal|12
expr_stmt|;
comment|/* If desired, concat something onto the front of ALLARGS.      SHELL_COMMAND is the result.  */
ifdef|#
directive|ifdef
name|SHELL_COMMAND_CONCAT
name|shell_command
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|SHELL_COMMAND_CONCAT
argument_list|)
operator|+
name|len
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|shell_command
argument_list|,
name|SHELL_COMMAND_CONCAT
argument_list|)
expr_stmt|;
else|#
directive|else
name|shell_command
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|shell_command
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|shell
condition|)
block|{
comment|/* We're going to call execvp. Create argv */
comment|/* Largest case: every other character is a separate arg */
if|#
directive|if
name|DEBUGGING
name|printf
argument_list|(
literal|"allocating argv, length = %d\n"
argument_list|,
operator|(
operator|(
name|strlen
argument_list|(
name|allargs
argument_list|)
operator|+
literal|1
operator|)
operator|/
operator|(
name|unsigned
operator|)
literal|2
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|argv
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
operator|(
name|strlen
argument_list|(
name|allargs
argument_list|)
operator|+
literal|1
operator|)
operator|/
operator|(
name|unsigned
operator|)
literal|2
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|argv
argument_list|)
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
name|exec_file
expr_stmt|;
name|breakup_args
argument_list|(
name|allargs
argument_list|,
operator|&
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We're going to call a shell */
comment|/* Now add exec_file, quoting as necessary.  */
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|need_to_quote
decl_stmt|;
name|strcat
argument_list|(
name|shell_command
argument_list|,
literal|"exec "
argument_list|)
expr_stmt|;
comment|/* Quoting in this style is said to work with all shells.  But csh        on IRIX 4.0.1 can't deal with it.  So we only quote it if we need        to.  */
name|p
operator|=
name|exec_file
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'\''
case|:
case|case
literal|'"'
case|:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
case|case
literal|'$'
case|:
case|case
literal|'&'
case|:
case|case
literal|';'
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|' '
case|:
case|case
literal|'\n'
case|:
case|case
literal|'\t'
case|:
name|need_to_quote
operator|=
literal|1
expr_stmt|;
goto|goto
name|end_scan
goto|;
case|case
literal|'\0'
case|:
name|need_to_quote
operator|=
literal|0
expr_stmt|;
goto|goto
name|end_scan
goto|;
default|default:
break|break;
block|}
operator|++
name|p
expr_stmt|;
block|}
name|end_scan
label|:
if|if
condition|(
name|need_to_quote
condition|)
block|{
name|strcat
argument_list|(
name|shell_command
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|exec_file
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\''
condition|)
name|strcat
argument_list|(
name|shell_command
argument_list|,
literal|"'\\''"
argument_list|)
expr_stmt|;
else|else
name|strncat
argument_list|(
name|shell_command
argument_list|,
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|shell_command
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
block|}
else|else
name|strcat
argument_list|(
name|shell_command
argument_list|,
name|exec_file
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|shell_command
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|shell_command
argument_list|,
name|allargs
argument_list|)
expr_stmt|;
block|}
comment|/* exec is said to fail if the executable is open.  */
name|close_exec_file
argument_list|()
expr_stmt|;
comment|/* Retain a copy of our environment variables, since the child will      replace the value of  environ  and if we're vforked, we have to      restore it.  */
name|save_our_env
operator|=
name|environ
expr_stmt|;
comment|/* Tell the terminal handling subsystem what tty we plan to run on;      it will just record the information for later.  */
name|new_tty_prefork
argument_list|(
name|inferior_io_terminal
argument_list|)
expr_stmt|;
comment|/* It is generally good practice to flush any possible pending stdio      output prior to doing a fork, to avoid the possibility of both the      parent and child flushing the same data after the fork. */
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
comment|/* If there's any initialization of the target layers that must happen    to prepare to handle the child we're about fork, do it now...    */
if|if
condition|(
name|pre_trace_fun
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|pre_trace_fun
call|)
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_VFORK
argument_list|)
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|debug_fork
condition|)
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
else|else
name|pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"vfork"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|debug_fork
condition|)
name|sleep
argument_list|(
name|debug_fork
argument_list|)
expr_stmt|;
comment|/* Run inferior in a separate process group.  */
name|debug_setpgrp
operator|=
name|gdb_setpgid
argument_list|()
expr_stmt|;
if|if
condition|(
name|debug_setpgrp
operator|==
operator|-
literal|1
condition|)
name|perror
argument_list|(
literal|"setpgrp failed in child"
argument_list|)
expr_stmt|;
comment|/* Ask the tty subsystem to switch to the one we specified earlier 	 (or to share the current terminal, if none was specified).  */
name|new_tty
argument_list|()
expr_stmt|;
comment|/* Changing the signal handlers for the inferior after 	 a vfork can also change them for the superior, so we don't mess 	 with signals here.  See comments in 	 initialize_signals for how we get the right signal handlers 	 for the inferior.  */
comment|/* "Trace me, Dr. Memory!" */
call|(
modifier|*
name|traceme_fun
call|)
argument_list|()
expr_stmt|;
comment|/* The call above set this process (the "child") as debuggable        * by the original gdb process (the "parent").  Since processes        * (unlike people) can have only one parent, if you are        * debugging gdb itself (and your debugger is thus _already_ the        * controller/parent for this child),  code from here on out        * is undebuggable.  Indeed, you probably got an error message        * saying "not parent".  Sorry--you'll have to use print statements!        */
comment|/* There is no execlpe call, so we have to set the environment 	 for our child in the global variable.  If we've vforked, this 	 clobbers the parent, but environ is restored a few lines down 	 in the parent.  By the way, yes we do need to look down the 	 path to find $SHELL.  Rich Pixley says so, and I agree.  */
name|environ
operator|=
name|env
expr_stmt|;
comment|/* If we decided above to start up with a shell,        * we exec the shell,        * "-c" says to interpret the next arg as a shell command        * to execute, and this command is "exec<target-program><args>".        * "-f" means "fast startup" to the c-shell, which means        * don't do .cshrc file. Doing .cshrc may cause fork/exec        * events which will confuse debugger start-up code.        */
if|if
condition|(
name|shell
condition|)
block|{
if|#
directive|if
literal|0
comment|/* HP change is problematic. The -f option has different meanings 	   for different shells. It is particularly inappropriate for 	   bourne shells. */
block|execlp (shell_file, shell_file, "-f", "-c", shell_command, (char *) 0);
else|#
directive|else
name|execlp
argument_list|(
name|shell_file
argument_list|,
name|shell_file
argument_list|,
literal|"-c"
argument_list|,
name|shell_command
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If we get here, it's an error */
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Cannot exec %s: %s.\n"
argument_list|,
name|shell_file
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|0177
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise, we directly exec the target program with execvp. */
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|errstring
decl_stmt|;
if|#
directive|if
name|DEBUGGING
name|printf
argument_list|(
literal|"about to exec target, exec_file = %s\n"
argument_list|,
name|exec_file
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|argv
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"strlen(argv[%d]) is %d\n"
argument_list|,
name|i
argument_list|,
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"argv[%d] is %s\n"
argument_list|,
name|i
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
name|execvp
argument_list|(
name|exec_file
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/* If we get here, it's an error */
name|errstring
operator|=
name|safe_strerror
argument_list|(
name|errno
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Cannot exec %s "
argument_list|,
name|exec_file
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|argv
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|i
operator|!=
literal|1
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"%s"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
comment|/* This extra info seems to be useless         fprintf_unfiltered (gdb_stderr, "Got error %s.\n", errstring);          */
name|gdb_flush
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|0177
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Restore our environment in case a vforked child clob'd it.  */
name|environ
operator|=
name|save_our_env
expr_stmt|;
name|init_thread_list
argument_list|()
expr_stmt|;
name|inferior_pid
operator|=
name|pid
expr_stmt|;
comment|/* Needed for wait_for_inferior stuff below */
comment|/* Now that we have a child process, make it our target, and      initialize anything target-vector-specific that needs initializing.  */
call|(
modifier|*
name|init_trace_fun
call|)
argument_list|(
name|pid
argument_list|)
expr_stmt|;
comment|/* We are now in the child process of interest, having exec'd the      correct program, and are poised at the first instruction of the      new program.  */
comment|/* Allow target dependant code to play with the new process.  This might be      used to have target-specific code initialize a variable in the new process      prior to executing the first instruction.  */
name|TARGET_CREATE_INFERIOR_HOOK
argument_list|(
name|pid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SOLIB_CREATE_INFERIOR_HOOK
name|SOLIB_CREATE_INFERIOR_HOOK
argument_list|(
name|pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_comment
comment|/* An inferior Unix process CHILD_PID has been created by a call to    fork() (or variants like vfork).  It is presently stopped, and waiting    to be resumed.  clone_and_follow_inferior will fork the debugger,    and that clone will "follow" (attach to) CHILD_PID.  The original copy    of the debugger will not touch CHILD_PID again.     Also, the original debugger will set FOLLOWED_CHILD FALSE, while the    clone will set it TRUE.    */
end_comment

begin_function
name|void
name|clone_and_follow_inferior
parameter_list|(
name|child_pid
parameter_list|,
name|followed_child
parameter_list|)
name|int
name|child_pid
decl_stmt|;
name|int
modifier|*
name|followed_child
decl_stmt|;
block|{
specifier|extern
name|int
name|auto_solib_add
decl_stmt|;
name|int
name|debugger_pid
decl_stmt|;
name|int
name|status
decl_stmt|;
name|char
name|pid_spelling
index|[
literal|100
index|]
decl_stmt|;
comment|/* Arbitrary but sufficient length. */
comment|/* This semaphore is used to coordinate the two debuggers' handoff      of CHILD_PID.  The original debugger will detach from CHILD_PID,      and then the clone debugger will attach to it.  (It must be done      this way because on some targets, only one process at a time can      trace another.  Thus, the original debugger must relinquish its      tracing rights before the clone can pick them up.)      */
define|#
directive|define
name|SEM_TALK
value|(1)
define|#
directive|define
name|SEM_LISTEN
value|(0)
name|int
name|handoff_semaphore
index|[
literal|2
index|]
decl_stmt|;
comment|/* Original "talks" to [1], clone "listens" to [0] */
name|int
name|talk_value
init|=
literal|99
decl_stmt|;
name|int
name|listen_value
decl_stmt|;
comment|/* Set debug_fork then attach to the child while it sleeps, to debug. */
specifier|static
name|int
name|debug_fork
init|=
literal|0
decl_stmt|;
comment|/* It is generally good practice to flush any possible pending stdio      output prior to doing a fork, to avoid the possibility of both the      parent and child flushing the same data after the fork. */
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
comment|/* Open the semaphore pipes.      */
name|status
operator|=
name|pipe
argument_list|(
name|handoff_semaphore
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|<
literal|0
condition|)
name|error
argument_list|(
literal|"error getting pipe for handoff semaphore"
argument_list|)
expr_stmt|;
comment|/* Clone the debugger. */
if|#
directive|if
name|defined
argument_list|(
name|USG
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_VFORK
argument_list|)
name|debugger_pid
operator|=
name|fork
argument_list|()
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|debug_fork
condition|)
name|debugger_pid
operator|=
name|fork
argument_list|()
expr_stmt|;
else|else
name|debugger_pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|debugger_pid
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"fork"
argument_list|)
expr_stmt|;
comment|/* Are we the original debugger?  If so, we must relinquish all claims    to CHILD_PID. */
if|if
condition|(
name|debugger_pid
operator|!=
literal|0
condition|)
block|{
name|char
name|signal_spelling
index|[
literal|100
index|]
decl_stmt|;
comment|/* Arbitrary but sufficient length */
comment|/* Detach from CHILD_PID.  Deliver a "stop" signal when we do, though,        so that it remains stopped until the clone debugger can attach        to it.        */
name|detach_breakpoints
argument_list|(
name|child_pid
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|signal_spelling
argument_list|,
literal|"%d"
argument_list|,
name|target_signal_to_host
argument_list|(
name|TARGET_SIGNAL_STOP
argument_list|)
argument_list|)
expr_stmt|;
name|target_require_detach
argument_list|(
name|child_pid
argument_list|,
name|signal_spelling
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Notify the clone debugger that it should attach to CHILD_PID. */
name|write
argument_list|(
name|handoff_semaphore
index|[
name|SEM_TALK
index|]
argument_list|,
operator|&
name|talk_value
argument_list|,
sizeof|sizeof
argument_list|(
name|talk_value
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|followed_child
operator|=
literal|0
expr_stmt|;
block|}
comment|/* We're the child. */
else|else
block|{
if|if
condition|(
name|debug_fork
condition|)
name|sleep
argument_list|(
name|debug_fork
argument_list|)
expr_stmt|;
comment|/* The child (i.e., the cloned debugger) must now attach to          CHILD_PID.  inferior_pid is presently set to the parent process          of the fork, while CHILD_PID should be the child process of the          fork.           Wait until the original debugger relinquishes control of CHILD_PID,          though.          */
name|read
argument_list|(
name|handoff_semaphore
index|[
name|SEM_LISTEN
index|]
argument_list|,
operator|&
name|listen_value
argument_list|,
sizeof|sizeof
argument_list|(
name|listen_value
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Note that we DON'T want to actually detach from inferior_pid,          because that would allow it to run free.  The original          debugger wants to retain control of the process.  So, we          just reset inferior_pid to CHILD_PID, and then ensure that all          breakpoints are really set in CHILD_PID.          */
name|target_mourn_inferior
argument_list|()
expr_stmt|;
comment|/* Ask the tty subsystem to switch to the one we specified earlier          (or to share the current terminal, if none was specified).  */
name|new_tty
argument_list|()
expr_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|pid_spelling
argument_list|,
literal|"%d"
argument_list|,
name|child_pid
argument_list|)
expr_stmt|;
name|target_require_attach
argument_list|(
name|pid_spelling
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Perform any necessary cleanup, after attachment.  (This form          of attaching can behave differently on some targets than the          standard method, where a process formerly not under debugger          control was suddenly attached to..)          */
name|target_post_follow_inferior_by_clone
argument_list|()
expr_stmt|;
operator|*
name|followed_child
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Discard the handoff sempahore. */
operator|(
name|void
operator|)
name|close
argument_list|(
name|handoff_semaphore
index|[
name|SEM_LISTEN
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|handoff_semaphore
index|[
name|SEM_TALK
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Accept NTRAPS traps from the inferior.  */
end_comment

begin_function
name|void
name|startup_inferior
parameter_list|(
name|ntraps
parameter_list|)
name|int
name|ntraps
decl_stmt|;
block|{
name|int
name|pending_execs
init|=
name|ntraps
decl_stmt|;
name|int
name|terminal_initted
decl_stmt|;
comment|/* The process was started by the fork that created it,      but it will have stopped one instruction after execing the shell.      Here we must get it up to actual execution of the real program.  */
name|clear_proceed_status
argument_list|()
expr_stmt|;
name|init_wait_for_inferior
argument_list|()
expr_stmt|;
name|terminal_initted
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|STARTUP_WITH_SHELL
condition|)
name|inferior_ignoring_startup_exec_events
operator|=
name|ntraps
expr_stmt|;
else|else
name|inferior_ignoring_startup_exec_events
operator|=
literal|0
expr_stmt|;
name|inferior_ignoring_leading_exec_events
operator|=
name|target_reported_exec_events_per_exec_call
argument_list|()
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|STARTUP_INFERIOR
name|STARTUP_INFERIOR
argument_list|(
name|pending_execs
argument_list|)
expr_stmt|;
else|#
directive|else
while|while
condition|(
literal|1
condition|)
block|{
name|stop_soon_quietly
operator|=
literal|1
expr_stmt|;
comment|/* Make wait_for_inferior be quiet */
name|wait_for_inferior
argument_list|()
expr_stmt|;
if|if
condition|(
name|stop_signal
operator|!=
name|TARGET_SIGNAL_TRAP
condition|)
block|{
comment|/* Let shell child handle its own signals in its own way */
comment|/* FIXME, what if child has exit()ed?  Must exit loop somehow */
name|resume
argument_list|(
literal|0
argument_list|,
name|stop_signal
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We handle SIGTRAP, however; it means child did an exec.  */
if|if
condition|(
operator|!
name|terminal_initted
condition|)
block|{
comment|/* Now that the child has exec'd we know it has already set its 		 process group.  On POSIX systems, tcsetpgrp will fail with 		 EPERM if we try it before the child's setpgid.  */
comment|/* Set up the "saved terminal modes" of the inferior 		 based on what modes we are starting it with.  */
name|target_terminal_init
argument_list|()
expr_stmt|;
comment|/* Install inferior's terminal modes.  */
name|target_terminal_inferior
argument_list|()
expr_stmt|;
name|terminal_initted
operator|=
literal|1
expr_stmt|;
block|}
name|pending_execs
operator|=
name|pending_execs
operator|-
literal|1
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|pending_execs
condition|)
break|break;
name|resume
argument_list|(
literal|0
argument_list|,
name|TARGET_SIGNAL_0
argument_list|)
expr_stmt|;
comment|/* Just make it go on */
block|}
block|}
endif|#
directive|endif
comment|/* STARTUP_INFERIOR */
name|stop_soon_quietly
operator|=
literal|0
expr_stmt|;
block|}
end_function

end_unit

