begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Fork a Unix child process, and set up to debug it, for GDB.    Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000,    2001 Free Software Foundation, Inc.    Contributed by Cygnus Support.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_comment
comment|/* required by inferior.h */
end_comment

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdb_wait.h"
end_include

begin_include
include|#
directive|include
file|"gdb_vfork.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"terminal.h"
end_include

begin_include
include|#
directive|include
file|"gdbthread.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_comment
comment|/* for dont_repeat () */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_comment
comment|/* This just gets used as a default if we can't find SHELL */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SHELL_FILE
end_ifndef

begin_define
define|#
directive|define
name|SHELL_FILE
value|"/bin/sh"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This function breaks up an argument string into an argument  * vector suitable for passing to execvp().  * E.g., on "run a b c d" this routine would get as input  * the string "a b c d", and as output it would fill in argv with  * the four arguments "a", "b", "c", "d".  */
end_comment

begin_function
specifier|static
name|void
name|breakup_args
parameter_list|(
name|char
modifier|*
name|scratch
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
modifier|*
name|cp
init|=
name|scratch
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Scan past leading separators */
while|while
condition|(
operator|*
name|cp
operator|==
literal|' '
operator|||
operator|*
name|cp
operator|==
literal|'\t'
operator|||
operator|*
name|cp
operator|==
literal|'\n'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
comment|/* Break if at end of string */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
break|break;
comment|/* Take an arg */
operator|*
name|argv
operator|++
operator|=
name|cp
expr_stmt|;
comment|/* Scan for next arg separator */
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* No separators => end of string => break */
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
break|break;
comment|/* Replace the separator with a terminator */
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* execv requires a null-terminated arg vector */
operator|*
name|argv
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* When executing a command under the given shell, return non-zero    if the '!' character should be escaped when embedded in a quoted    command-line argument.  */
end_comment

begin_function
specifier|static
name|int
name|escape_bang_in_quoted_argument
parameter_list|(
specifier|const
name|char
modifier|*
name|shell_file
parameter_list|)
block|{
specifier|const
name|int
name|shell_file_len
init|=
name|strlen
argument_list|(
name|shell_file
argument_list|)
decl_stmt|;
comment|/* Bang should be escaped only in C Shells.  For now, simply check      that the shell name ends with 'csh', which covers at least csh      and tcsh.  This should be good enough for now.  */
if|if
condition|(
name|shell_file_len
operator|<
literal|3
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|shell_file
index|[
name|shell_file_len
operator|-
literal|3
index|]
operator|==
literal|'c'
operator|&&
name|shell_file
index|[
name|shell_file_len
operator|-
literal|2
index|]
operator|==
literal|'s'
operator|&&
name|shell_file
index|[
name|shell_file_len
operator|-
literal|1
index|]
operator|==
literal|'h'
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Start an inferior Unix child process and sets inferior_ptid to its pid.    EXEC_FILE is the file to run.    ALLARGS is a string containing the arguments to the program.    ENV is the environment vector to pass.  SHELL_FILE is the shell file,    or NULL if we should pick one.  Errors reported with error().  */
end_comment

begin_comment
comment|/* This function is NOT-REENTRANT.  Some of the variables have been    made static to ensure that they survive the vfork() call.  */
end_comment

begin_function
name|void
name|fork_inferior
parameter_list|(
name|char
modifier|*
name|exec_file_arg
parameter_list|,
name|char
modifier|*
name|allargs
parameter_list|,
name|char
modifier|*
modifier|*
name|env
parameter_list|,
name|void
function_decl|(
modifier|*
name|traceme_fun
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|init_trace_fun
function_decl|)
parameter_list|(
name|int
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|pre_trace_fun
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|,
name|char
modifier|*
name|shell_file_arg
parameter_list|)
block|{
name|int
name|pid
decl_stmt|;
name|char
modifier|*
name|shell_command
decl_stmt|;
specifier|static
name|char
name|default_shell_file
index|[]
init|=
name|SHELL_FILE
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* Set debug_fork then attach to the child while it sleeps, to debug. */
specifier|static
name|int
name|debug_fork
init|=
literal|0
decl_stmt|;
comment|/* This is set to the result of setpgrp, which if vforked, will be visible      to you in the parent process.  It's only used by humans for debugging.  */
specifier|static
name|int
name|debug_setpgrp
init|=
literal|657473
decl_stmt|;
specifier|static
name|char
modifier|*
name|shell_file
decl_stmt|;
specifier|static
name|char
modifier|*
name|exec_file
decl_stmt|;
name|char
modifier|*
modifier|*
name|save_our_env
decl_stmt|;
name|int
name|shell
init|=
literal|0
decl_stmt|;
specifier|static
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
comment|/* If no exec file handed to us, get it from the exec-file command -- with      a good, common error message if none is specified.  */
name|exec_file
operator|=
name|exec_file_arg
expr_stmt|;
if|if
condition|(
name|exec_file
operator|==
literal|0
condition|)
name|exec_file
operator|=
name|get_exec_file
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* STARTUP_WITH_SHELL is defined in inferior.h.    * If 0, we'll just do a fork/exec, no shell, so don't    * bother figuring out what shell.    */
name|shell_file
operator|=
name|shell_file_arg
expr_stmt|;
if|if
condition|(
name|STARTUP_WITH_SHELL
condition|)
block|{
comment|/* Figure out what shell to start up the user program under. */
if|if
condition|(
name|shell_file
operator|==
name|NULL
condition|)
name|shell_file
operator|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|shell_file
operator|==
name|NULL
condition|)
name|shell_file
operator|=
name|default_shell_file
expr_stmt|;
name|shell
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Multiplying the length of exec_file by 4 is to account for the fact      that it may expand when quoted; it is a worst-case number based on      every character being '.  */
name|len
operator|=
literal|5
operator|+
literal|4
operator|*
name|strlen
argument_list|(
name|exec_file
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|allargs
argument_list|)
operator|+
literal|1
operator|+
comment|/*slop */
literal|12
expr_stmt|;
comment|/* If desired, concat something onto the front of ALLARGS.      SHELL_COMMAND is the result.  */
ifdef|#
directive|ifdef
name|SHELL_COMMAND_CONCAT
name|shell_command
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|SHELL_COMMAND_CONCAT
argument_list|)
operator|+
name|len
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|shell_command
argument_list|,
name|SHELL_COMMAND_CONCAT
argument_list|)
expr_stmt|;
else|#
directive|else
name|shell_command
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|shell_command
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|shell
condition|)
block|{
comment|/* We're going to call execvp. Create argv */
comment|/* Largest case: every other character is a separate arg */
name|argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
operator|(
name|strlen
argument_list|(
name|allargs
argument_list|)
operator|+
literal|1
operator|)
operator|/
operator|(
name|unsigned
operator|)
literal|2
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|argv
argument_list|)
argument_list|)
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
name|exec_file
expr_stmt|;
name|breakup_args
argument_list|(
name|allargs
argument_list|,
operator|&
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We're going to call a shell */
comment|/* Now add exec_file, quoting as necessary.  */
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|need_to_quote
decl_stmt|;
specifier|const
name|int
name|escape_bang
init|=
name|escape_bang_in_quoted_argument
argument_list|(
name|shell_file
argument_list|)
decl_stmt|;
name|strcat
argument_list|(
name|shell_command
argument_list|,
literal|"exec "
argument_list|)
expr_stmt|;
comment|/* Quoting in this style is said to work with all shells.  But csh          on IRIX 4.0.1 can't deal with it.  So we only quote it if we need          to.  */
name|p
operator|=
name|exec_file
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'\''
case|:
case|case
literal|'!'
case|:
case|case
literal|'"'
case|:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
case|case
literal|'$'
case|:
case|case
literal|'&'
case|:
case|case
literal|';'
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|' '
case|:
case|case
literal|'\n'
case|:
case|case
literal|'\t'
case|:
name|need_to_quote
operator|=
literal|1
expr_stmt|;
goto|goto
name|end_scan
goto|;
case|case
literal|'\0'
case|:
name|need_to_quote
operator|=
literal|0
expr_stmt|;
goto|goto
name|end_scan
goto|;
default|default:
break|break;
block|}
operator|++
name|p
expr_stmt|;
block|}
name|end_scan
label|:
if|if
condition|(
name|need_to_quote
condition|)
block|{
name|strcat
argument_list|(
name|shell_command
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|exec_file
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\''
condition|)
name|strcat
argument_list|(
name|shell_command
argument_list|,
literal|"'\\''"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'!'
operator|&&
name|escape_bang
condition|)
name|strcat
argument_list|(
name|shell_command
argument_list|,
literal|"\\!"
argument_list|)
expr_stmt|;
else|else
name|strncat
argument_list|(
name|shell_command
argument_list|,
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|shell_command
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
block|}
else|else
name|strcat
argument_list|(
name|shell_command
argument_list|,
name|exec_file
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|shell_command
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|shell_command
argument_list|,
name|allargs
argument_list|)
expr_stmt|;
block|}
comment|/* exec is said to fail if the executable is open.  */
name|close_exec_file
argument_list|()
expr_stmt|;
comment|/* Retain a copy of our environment variables, since the child will      replace the value of  environ  and if we're vforked, we have to      restore it.  */
name|save_our_env
operator|=
name|environ
expr_stmt|;
comment|/* Tell the terminal handling subsystem what tty we plan to run on;      it will just record the information for later.  */
name|new_tty_prefork
argument_list|(
name|inferior_io_terminal
argument_list|)
expr_stmt|;
comment|/* It is generally good practice to flush any possible pending stdio      output prior to doing a fork, to avoid the possibility of both the      parent and child flushing the same data after the fork. */
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
comment|/* If there's any initialization of the target layers that must happen      to prepare to handle the child we're about fork, do it now...    */
if|if
condition|(
name|pre_trace_fun
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|pre_trace_fun
call|)
argument_list|()
expr_stmt|;
comment|/* Create the child process.  Note that the apparent call to vfork()      below *might* actually be a call to fork() due to the fact that      autoconf will ``#define vfork fork'' on certain platforms.  */
if|if
condition|(
name|debug_fork
condition|)
name|pid
operator|=
name|fork
argument_list|()
expr_stmt|;
else|else
name|pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
name|perror_with_name
argument_list|(
literal|"vfork"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|debug_fork
condition|)
name|sleep
argument_list|(
name|debug_fork
argument_list|)
expr_stmt|;
comment|/* Run inferior in a separate process group.  */
name|debug_setpgrp
operator|=
name|gdb_setpgid
argument_list|()
expr_stmt|;
if|if
condition|(
name|debug_setpgrp
operator|==
operator|-
literal|1
condition|)
name|perror
argument_list|(
literal|"setpgrp failed in child"
argument_list|)
expr_stmt|;
comment|/* Ask the tty subsystem to switch to the one we specified earlier          (or to share the current terminal, if none was specified).  */
name|new_tty
argument_list|()
expr_stmt|;
comment|/* Changing the signal handlers for the inferior after          a vfork can also change them for the superior, so we don't mess          with signals here.  See comments in          initialize_signals for how we get the right signal handlers          for the inferior.  */
comment|/* "Trace me, Dr. Memory!" */
call|(
modifier|*
name|traceme_fun
call|)
argument_list|()
expr_stmt|;
comment|/* The call above set this process (the "child") as debuggable        * by the original gdb process (the "parent").  Since processes        * (unlike people) can have only one parent, if you are        * debugging gdb itself (and your debugger is thus _already_ the        * controller/parent for this child),  code from here on out        * is undebuggable.  Indeed, you probably got an error message        * saying "not parent".  Sorry--you'll have to use print statements!        */
comment|/* There is no execlpe call, so we have to set the environment          for our child in the global variable.  If we've vforked, this          clobbers the parent, but environ is restored a few lines down          in the parent.  By the way, yes we do need to look down the          path to find $SHELL.  Rich Pixley says so, and I agree.  */
name|environ
operator|=
name|env
expr_stmt|;
comment|/* If we decided above to start up with a shell,        * we exec the shell,        * "-c" says to interpret the next arg as a shell command        * to execute, and this command is "exec<target-program><args>".        * "-f" means "fast startup" to the c-shell, which means        * don't do .cshrc file. Doing .cshrc may cause fork/exec        * events which will confuse debugger start-up code.        */
if|if
condition|(
name|shell
condition|)
block|{
name|execlp
argument_list|(
name|shell_file
argument_list|,
name|shell_file
argument_list|,
literal|"-c"
argument_list|,
name|shell_command
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* If we get here, it's an error */
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Cannot exec %s: %s.\n"
argument_list|,
name|shell_file
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|0177
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise, we directly exec the target program with execvp. */
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|errstring
decl_stmt|;
name|execvp
argument_list|(
name|exec_file
argument_list|,
name|argv
argument_list|)
expr_stmt|;
comment|/* If we get here, it's an error */
name|errstring
operator|=
name|safe_strerror
argument_list|(
name|errno
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Cannot exec %s "
argument_list|,
name|exec_file
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|argv
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|i
operator|!=
literal|1
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"%s"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
comment|/* This extra info seems to be useless 	     fprintf_unfiltered (gdb_stderr, "Got error %s.\n", errstring); 	   */
name|gdb_flush
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|0177
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Restore our environment in case a vforked child clob'd it.  */
name|environ
operator|=
name|save_our_env
expr_stmt|;
name|init_thread_list
argument_list|()
expr_stmt|;
name|inferior_ptid
operator|=
name|pid_to_ptid
argument_list|(
name|pid
argument_list|)
expr_stmt|;
comment|/* Needed for wait_for_inferior stuff below */
comment|/* Now that we have a child process, make it our target, and      initialize anything target-vector-specific that needs initializing.  */
call|(
modifier|*
name|init_trace_fun
call|)
argument_list|(
name|pid
argument_list|)
expr_stmt|;
comment|/* We are now in the child process of interest, having exec'd the      correct program, and are poised at the first instruction of the      new program.  */
comment|/* Allow target dependent code to play with the new process.  This might be      used to have target-specific code initialize a variable in the new process      prior to executing the first instruction.  */
name|TARGET_CREATE_INFERIOR_HOOK
argument_list|(
name|pid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SOLIB_CREATE_INFERIOR_HOOK
name|SOLIB_CREATE_INFERIOR_HOOK
argument_list|(
name|pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Accept NTRAPS traps from the inferior.  */
end_comment

begin_function
name|void
name|startup_inferior
parameter_list|(
name|int
name|ntraps
parameter_list|)
block|{
name|int
name|pending_execs
init|=
name|ntraps
decl_stmt|;
name|int
name|terminal_initted
decl_stmt|;
comment|/* The process was started by the fork that created it,      but it will have stopped one instruction after execing the shell.      Here we must get it up to actual execution of the real program.  */
name|clear_proceed_status
argument_list|()
expr_stmt|;
name|init_wait_for_inferior
argument_list|()
expr_stmt|;
name|terminal_initted
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|STARTUP_WITH_SHELL
condition|)
name|inferior_ignoring_startup_exec_events
operator|=
name|ntraps
expr_stmt|;
else|else
name|inferior_ignoring_startup_exec_events
operator|=
literal|0
expr_stmt|;
name|inferior_ignoring_leading_exec_events
operator|=
name|target_reported_exec_events_per_exec_call
argument_list|()
operator|-
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Make wait_for_inferior be quiet */
name|stop_soon
operator|=
name|STOP_QUIETLY
expr_stmt|;
name|wait_for_inferior
argument_list|()
expr_stmt|;
if|if
condition|(
name|stop_signal
operator|!=
name|TARGET_SIGNAL_TRAP
condition|)
block|{
comment|/* Let shell child handle its own signals in its own way */
comment|/* FIXME, what if child has exit()ed?  Must exit loop somehow */
name|resume
argument_list|(
literal|0
argument_list|,
name|stop_signal
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We handle SIGTRAP, however; it means child did an exec.  */
if|if
condition|(
operator|!
name|terminal_initted
condition|)
block|{
comment|/* Now that the child has exec'd we know it has already set its 	         process group.  On POSIX systems, tcsetpgrp will fail with 	         EPERM if we try it before the child's setpgid.  */
comment|/* Set up the "saved terminal modes" of the inferior 	         based on what modes we are starting it with.  */
name|target_terminal_init
argument_list|()
expr_stmt|;
comment|/* Install inferior's terminal modes.  */
name|target_terminal_inferior
argument_list|()
expr_stmt|;
name|terminal_initted
operator|=
literal|1
expr_stmt|;
block|}
name|pending_execs
operator|=
name|pending_execs
operator|-
literal|1
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|pending_execs
condition|)
break|break;
name|resume
argument_list|(
literal|0
argument_list|,
name|TARGET_SIGNAL_0
argument_list|)
expr_stmt|;
comment|/* Just make it go on */
block|}
block|}
name|stop_soon
operator|=
name|NO_STOP_QUIETLY
expr_stmt|;
block|}
end_function

end_unit

