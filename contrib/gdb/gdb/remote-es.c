begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Memory-access and commands for remote es1800 processes, for GDB.    Copyright (C) 1988, 1992 Free Software Foundation, Inc.     This file is added to GDB to make it possible to do debugging via an    ES-1800 emulator. The code was originally written by Johan Holmberg    TT/SJ Ericsson Telecom AB and later modified by Johan Henriksson    TT/SJ. It was modified for gdb 4.0 by TX/DK Jan Nordenand by TX/DKG    Harald Johansen.  This file is part of GDB.  GDB is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GDB is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Emulator communication protocol.    All values are encoded in ascii hex digits.          Request Command Reply 	read registers: DR<cr>      - 0 -    - 1 -    - 2 -    - 3 -      - 4 -    - 5 -    -- 6 -   - 7 -  D = XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX   XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX A = XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX   XXXXXXXX XXXXXXXX XXXXXXXX      PC = XXXXXX       SSP = XXXXXX    USP = XXXXXX     SR = XXXXXXXX> Each byte of register data is described by two hex digits.  	write regs D0=XXXXXXXX<cr>>D1=XXXXXXXX<cr>>D2=XXXXXXXX<cr>>D3=XXXXXXXX<cr>>D4=XXXXXXXX<cr>>D5=XXXXXXXX<cr>>D6=XXXXXXXX<cr>>D7=XXXXXXXX<cr>>A0=XXXXXXXX<cr>>A1=XXXXXXXX<cr>>A2=XXXXXXXX<cr>>A3=XXXXXXXX<cr>>A4=XXXXXXXX<cr>>A5=XXXXXXXX<cr>>A6=XXXXXXXX<cr>>A7=XXXXXXXX<cr>>SR=XXXXXXXX<cr>>PC=XXXXXX<cr>> Each byte of register data is described by two hex digits.  	read mem @.BAA..AA $FFFFFFXX> AA..AA is address, XXXXXXX is the contents  	write mem 	@.BAA..AA=$XXXXXXXX> AA..AA is address, XXXXXXXX is data  	cont PC=$AA..AA>RBK R> AA..AA is address to resume. If AA..AA is omitted, resume at same address.  	step PC=$AA..AA>STP R> AA..AA is address to resume. If AA..AA is omitted, resume at same address.  	kill req STP> */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_include
include|#
directive|include
file|"remote-utils.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_decl_stmt
specifier|static
name|void
name|es1800_child_detach
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|es1800_child_open
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|es1800_transparent
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|es1800_create_inferior
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|es1800_load
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|es1800_kill
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|verify_break
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|es1800_remove_breakpoint
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|es1800_insert_breakpoint
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|es1800_files_info
name|PARAMS
argument_list|(
operator|(
expr|struct
name|target_ops
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|es1800_xfer_inferior_memory
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
expr|struct
name|target_ops
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|es1800_prepare_to_store
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|es1800_wait
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|target_waitstatus
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|es1800_resume
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
expr|enum
name|target_signal
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|es1800_detach
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|es1800_attach
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|damn_b
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|es1800_open
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|es1800_timer
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|es1800_reset
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|es1800_request_quit
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|readchar
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expect
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|expect_prompt
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|download
name|PARAMS
argument_list|(
operator|(
name|FILE
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void bfd_copy PARAMS ((bfd *, bfd *));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|get_break_addr
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|CORE_ADDR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|fromhex
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tohex
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|es1800_close
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|es1800_fetch_registers
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|es1800_fetch_register
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|es1800_store_register
name|PARAMS
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|es1800_read_bytes
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|es1800_write_bytes
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|send_with_reply
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|send_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|send
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|getmessage
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|es1800_mourn_inferior
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|es1800_create_break_insn
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|es1800_init_break
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local variables */
end_comment

begin_comment
comment|/* FIXME: Convert this to use "set remotedebug" instead.  */
end_comment

begin_define
define|#
directive|define
name|LOG_FILE
value|"es1800.log"
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LOG_FILE
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|log_file
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|es1800_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward decl */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|es1800_child_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward decl */
end_comment

begin_decl_stmt
specifier|static
name|int
name|kiodebug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|timeout
init|=
literal|100
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|savename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of i/o device used */
end_comment

begin_decl_stmt
specifier|static
name|serial_ttystate
name|es1800_saved_ttystate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|es1800_fc_save
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Save fcntl state */
end_comment

begin_comment
comment|/* indicates that the emulator uses 32-bit data-adress (68020-mode)     instead of 24-bit (68000 -mode) */
end_comment

begin_decl_stmt
specifier|static
name|int
name|m68020
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MODE
value|(m68020 ? "M68020" : "M68000" )
end_define

begin_define
define|#
directive|define
name|ES1800_BREAK_VEC
value|(0xf)
end_define

begin_comment
comment|/* Descriptor for I/O to remote machine.  Initialize it to NULL so that    es1800_open knows that we don't have a file open when the program    starts.  */
end_comment

begin_decl_stmt
specifier|static
name|serial_t
name|es1800_desc
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PBUFSIZ
value|1000
end_define

begin_define
define|#
directive|define
name|HDRLEN
value|sizeof("@.BAAAAAAAA=$VV\r")
end_define

begin_comment
comment|/* Maximum number of bytes to read/write at once.  The value here    is chosen to fill up a packet.  */
end_comment

begin_define
define|#
directive|define
name|MAXBUFBYTES
value|((PBUFSIZ-150)*16/75 )
end_define

begin_decl_stmt
specifier|static
name|int
name|es1800_break_vec
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|es1800_break_insn
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|es1800_break_address
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|old_sigint
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Old signal-handler for sigint */
end_comment

begin_decl_stmt
specifier|static
name|jmp_buf
name|interrupt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Local signalhandler to allow breaking tranfers or program run.    Rely on global variables: old_sigint(), interrupt */
end_comment

begin_function
specifier|static
name|void
name|es1800_request_quit
parameter_list|()
block|{
comment|/* restore original signalhandler */
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|old_sigint
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|interrupt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reset emulator.    Sending reset character(octal 32) to emulator.    quit - return to '(esgdb)' prompt or continue	*/
end_comment

begin_function
specifier|static
name|void
name|es1800_reset
parameter_list|(
name|quit
parameter_list|)
name|char
modifier|*
name|quit
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
if|if
condition|(
name|quit
condition|)
block|{
name|printf
argument_list|(
literal|"\nResetting emulator...  "
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"\032"
argument_list|)
expr_stmt|;
name|send
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|()
expr_stmt|;
if|if
condition|(
name|quit
condition|)
block|{
name|error
argument_list|(
literal|"done\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Open a connection to a remote debugger and push the new target    onto the stack. Check if the emulator is responding and find out    what kind of processor the emulator is connected to.    Initiate the breakpoint handling in the emulator.     name     - the filename used for communication (ex. '/dev/tta')    from_tty - says whether to be verbose or not */
end_comment

begin_function
specifier|static
name|void
name|es1800_open
parameter_list|(
name|name
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|fcflag
decl_stmt|;
name|m68020
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
comment|/* no device name given in target command */
block|{
name|error_no_arg
argument_list|(
literal|"serial port device name"
argument_list|)
expr_stmt|;
block|}
name|target_preopen
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
name|es1800_close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* open the device and configure it for communication */
ifndef|#
directive|ifndef
name|DEBUG_STDIN
name|es1800_desc
operator|=
name|SERIAL_OPEN
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|es1800_desc
operator|==
name|NULL
condition|)
block|{
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
name|savename
operator|=
name|savestring
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|es1800_saved_ttystate
operator|=
name|SERIAL_GET_TTY_STATE
argument_list|(
name|es1800_desc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fcflag
operator|=
name|fcntl
argument_list|(
name|es1800_desc
operator|->
name|fd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror_with_name
argument_list|(
literal|"fcntl serial"
argument_list|)
expr_stmt|;
block|}
name|es1800_fc_save
operator|=
name|fcflag
expr_stmt|;
name|fcflag
operator|=
operator|(
name|fcflag
operator|&
operator|(
name|FREAD
operator||
name|FWRITE
operator|)
operator|)
expr_stmt|;
comment|/* mask out any funny stuff */
if|if
condition|(
name|fcntl
argument_list|(
name|es1800_desc
operator|->
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|fcflag
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror_with_name
argument_list|(
literal|"fcntl serial"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|baud_rate
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|SERIAL_SETBAUDRATE
argument_list|(
name|es1800_desc
argument_list|,
name|baud_rate
argument_list|)
condition|)
block|{
name|SERIAL_CLOSE
argument_list|(
name|es1800_desc
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|SERIAL_RAW
argument_list|(
name|es1800_desc
argument_list|)
expr_stmt|;
comment|/* If there is something sitting in the buffer we might take it as a      response to a command, which would be bad.  */
name|SERIAL_FLUSH_INPUT
argument_list|(
name|es1800_desc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG_STDIN */
name|push_target
argument_list|(
operator|&
name|es1800_ops
argument_list|)
expr_stmt|;
comment|/* Switch to using remote target now */
if|if
condition|(
name|from_tty
condition|)
block|{
name|printf
argument_list|(
literal|"Remote ES1800 debugging using %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|LOG_FILE
argument_list|)
name|log_file
operator|=
name|fopen
argument_list|(
name|LOG_FILE
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|log_file
operator|==
name|NULL
condition|)
block|{
name|perror_with_name
argument_list|(
name|LOG_FILE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* LOG_FILE */
comment|/* Hello?  Are you there?, also check mode  */
comment|/*  send_with_reply( "DB 0 TO 1", buf, sizeof(buf)); */
comment|/*  for (p = buf, i = 0; *p++ =='0';)  */
comment|/* count the number of zeros */
comment|/*      i++; */
name|send
argument_list|(
literal|"\032"
argument_list|)
expr_stmt|;
name|getmessage
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* send reset character */
if|if
condition|(
name|from_tty
condition|)
block|{
name|printf
argument_list|(
literal|"Checking mode.... "
argument_list|)
expr_stmt|;
block|}
comment|/*  m68020 = (i==8); */
comment|/* if eight zeros then we are in m68020 mode */
comment|/* What kind of processor am i talking to ?*/
name|p
operator|=
name|buf
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'\n'
condition|)
block|{
empty_stmt|;
block|}
while|while
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'\n'
condition|)
block|{
empty_stmt|;
block|}
while|while
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'\n'
condition|)
block|{
empty_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
block|{
empty_stmt|;
block|}
name|m68020
operator|=
operator|!
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"68020"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|printf
argument_list|(
literal|"You are in %s(%c%c%c%c%c)-mode\n"
argument_list|,
name|MODE
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
name|p
index|[
literal|2
index|]
argument_list|,
name|p
index|[
literal|3
index|]
argument_list|,
name|p
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* if no init_break statement is present in .gdb file we have to check       whether to download a breakpoint routine or not */
if|#
directive|if
literal|0
block|if ((es1800_break_vec == 0) || (verify_break (es1800_break_vec) != 0)&& query ("No breakpoint routine in ES 1800 emulator!\nDownload a breakpoint routine to the emulator? "))     {       CORE_ADDR memaddress;       printf ("Give the start address of the breakpoint routine: ");       scanf ("%li",&memaddress);       es1800_init_break ((es1800_break_vec ? es1800_break_vec : 			  ES1800_BREAK_VEC), memaddress);     }
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  Close out all files and local state before this target loses control.     quitting - are we quitting gdb now? */
end_comment

begin_function
specifier|static
name|void
name|es1800_close
parameter_list|(
name|quitting
parameter_list|)
name|int
name|quitting
decl_stmt|;
block|{
if|if
condition|(
name|es1800_desc
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"\nClosing connection to emulator...\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|SERIAL_SET_TTY_STATE
argument_list|(
name|es1800_desc
argument_list|,
name|es1800_saved_ttystate
argument_list|)
operator|<
literal|0
condition|)
name|print_sys_errmsg
argument_list|(
literal|"warning: unable to restore tty state"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|fcntl
argument_list|(
name|es1800_desc
operator|->
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|es1800_fc_save
argument_list|)
expr_stmt|;
name|SERIAL_CLOSE
argument_list|(
name|es1800_desc
argument_list|)
expr_stmt|;
name|es1800_desc
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|savename
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|savename
argument_list|)
expr_stmt|;
block|}
name|savename
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|LOG_FILE
argument_list|)
if|if
condition|(
name|log_file
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|log_file
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Error writing log file.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|log_file
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Error closing log file.\n"
argument_list|)
expr_stmt|;
block|}
name|log_file
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* LOG_FILE */
block|}
end_function

begin_comment
comment|/*  Attaches to a process on the target side     proc_id  - the id of the process to be attached.     from_tty - says whether to be verbose or not */
end_comment

begin_function
specifier|static
name|void
name|es1800_attach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|error
argument_list|(
literal|"Cannot attach to pid %s, this feature is not implemented yet."
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Takes a program previously attached to and detaches it.    We better not have left any breakpoints    in the program or it'll die when it hits one.    Close the open connection to the remote debugger.    Use this when you want to detach and do something else    with your gdb.      args     - arguments given to the 'detach' command    from_tty - says whether to be verbose or not */
end_comment

begin_function
specifier|static
name|void
name|es1800_detach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|args
condition|)
block|{
name|error
argument_list|(
literal|"Argument given to \"detach\" when remotely debugging."
argument_list|)
expr_stmt|;
block|}
name|pop_target
argument_list|()
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|printf
argument_list|(
literal|"Ending es1800 remote debugging.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Tell the remote machine to resume.    step    - single-step or run free    siggnal - the signal value to be given to the target (0 = no signal) */
end_comment

begin_function
specifier|static
name|void
name|es1800_resume
parameter_list|(
name|pid
parameter_list|,
name|step
parameter_list|,
name|siggnal
parameter_list|)
name|int
name|pid
decl_stmt|;
name|int
name|step
decl_stmt|;
name|enum
name|target_signal
name|siggnal
decl_stmt|;
block|{
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|siggnal
condition|)
block|{
name|error
argument_list|(
literal|"Can't send signals to a remote system."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|step
condition|)
block|{
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"STP\r"
argument_list|)
expr_stmt|;
name|send
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|send_command
argument_list|(
literal|"RBK"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Wait until the remote machine stops, then return,    storing status in STATUS just as `wait' would.    status -  */
end_comment

begin_function
specifier|static
name|int
name|es1800_wait
parameter_list|(
name|pid
parameter_list|,
name|status
parameter_list|)
name|int
name|pid
decl_stmt|;
name|struct
name|target_waitstatus
modifier|*
name|status
decl_stmt|;
block|{
name|unsigned
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|int
name|old_timeout
init|=
name|timeout
decl_stmt|;
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|integer
operator|=
literal|0
expr_stmt|;
name|timeout
operator|=
literal|0
expr_stmt|;
comment|/* Don't time out -- user program is running. */
if|if
condition|(
operator|!
name|setjmp
argument_list|(
name|interrupt
argument_list|)
condition|)
block|{
name|old_sigint
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|es1800_request_quit
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|getmessage
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"\r\n* BREAK *"
argument_list|,
literal|11
argument_list|)
operator|==
literal|0
condition|)
block|{
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
name|send_command
argument_list|(
literal|"STP"
argument_list|)
expr_stmt|;
comment|/* Restore stack and PC and such */
if|if
condition|(
name|m68020
condition|)
block|{
name|send_command
argument_list|(
literal|"STP"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"STP\r\n "
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|2
index|]
operator|==
literal|'R'
condition|)
block|{
name|printf
argument_list|(
literal|"Unexpected emulator reply: \n%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Unexpected stop: \n%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_QUIT
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|fflush
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nStopping emulator..."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|setjmp
argument_list|(
name|interrupt
argument_list|)
condition|)
block|{
name|old_sigint
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|es1800_request_quit
argument_list|)
expr_stmt|;
name|send_command
argument_list|(
literal|"STP"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" emulator stopped\n"
argument_list|)
expr_stmt|;
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_INT
expr_stmt|;
block|}
else|else
block|{
name|fflush
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|es1800_reset
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|old_sigint
argument_list|)
expr_stmt|;
name|timeout
operator|=
name|old_timeout
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Fetch register values from remote machine.    regno - the register to be fetched (fetch all registers if -1) */
end_comment

begin_function
specifier|static
name|void
name|es1800_fetch_register
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|int
name|k
decl_stmt|;
name|int
name|r
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
specifier|static
name|char
name|regtab
index|[
literal|18
index|]
index|[
literal|4
index|]
init|=
block|{
literal|"D0 "
block|,
literal|"D1 "
block|,
literal|"D2 "
block|,
literal|"D3 "
block|,
literal|"D4 "
block|,
literal|"D5 "
block|,
literal|"D6 "
block|,
literal|"D7 "
block|,
literal|"A0 "
block|,
literal|"A1 "
block|,
literal|"A2 "
block|,
literal|"A3 "
block|,
literal|"A4 "
block|,
literal|"A5 "
block|,
literal|"A6 "
block|,
literal|"SSP"
block|,
literal|"SR "
block|,
literal|"PC "
block|}
decl_stmt|;
if|if
condition|(
operator|(
name|regno
operator|<
literal|15
operator|)
operator|||
operator|(
name|regno
operator|==
literal|16
operator|)
operator|||
operator|(
name|regno
operator|==
literal|17
operator|)
condition|)
block|{
name|r
operator|=
name|regno
operator|*
literal|4
expr_stmt|;
name|send_with_reply
argument_list|(
name|regtab
index|[
name|regno
index|]
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|4
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|p
index|[
name|k
operator|*
literal|2
operator|+
literal|1
index|]
operator|==
literal|0
operator|)
operator|||
operator|(
name|p
index|[
name|k
operator|*
literal|2
operator|+
literal|2
index|]
operator|==
literal|0
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"Emulator reply is too short: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|registers
index|[
name|r
operator|++
index|]
operator|=
operator|(
name|fromhex
argument_list|(
name|p
index|[
name|k
operator|*
literal|2
operator|+
literal|1
index|]
argument_list|)
operator|*
literal|16
operator|)
operator|+
name|fromhex
argument_list|(
name|p
index|[
name|k
operator|*
literal|2
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|es1800_fetch_registers
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Read the remote registers into REGISTERS.    Always fetches all registers. */
end_comment

begin_function
specifier|static
name|void
name|es1800_fetch_registers
parameter_list|()
block|{
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|char
name|SR_buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|k
decl_stmt|;
name|int
name|r
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|send_with_reply
argument_list|(
literal|"DR"
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Reply is edited to a string that describes registers byte by byte,      each byte encoded as two hex characters.  */
name|p
operator|=
name|buf
expr_stmt|;
name|r
operator|=
literal|0
expr_stmt|;
comment|/*  parsing row one - D0-D7-registers  */
while|while
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'\n'
condition|)
block|{
empty_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|4
init|;
name|i
operator|<
literal|70
condition|;
name|i
operator|+=
operator|(
name|i
operator|==
literal|39
condition|?
literal|3
else|:
literal|1
operator|)
control|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|4
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
name|i
operator|+
literal|0
index|]
operator|==
literal|0
operator|||
name|p
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Emulator reply is too short: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|registers
index|[
name|r
operator|++
index|]
operator|=
operator|(
name|fromhex
argument_list|(
name|p
index|[
name|i
operator|+
literal|0
index|]
argument_list|)
operator|*
literal|16
operator|)
operator|+
name|fromhex
argument_list|(
name|p
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
block|}
block|}
name|p
operator|+=
name|i
expr_stmt|;
comment|/*  parsing row two - A0-A6-registers  */
while|while
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'\n'
condition|)
block|{
empty_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|4
init|;
name|i
operator|<
literal|61
condition|;
name|i
operator|+=
operator|(
name|i
operator|==
literal|39
condition|?
literal|3
else|:
literal|1
operator|)
control|)
block|{
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|4
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
name|i
operator|+
literal|0
index|]
operator|==
literal|0
operator|||
name|p
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Emulator reply is too short: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|registers
index|[
name|r
operator|++
index|]
operator|=
operator|(
name|fromhex
argument_list|(
name|p
index|[
name|i
operator|+
literal|0
index|]
argument_list|)
operator|)
operator|*
literal|16
operator|+
name|fromhex
argument_list|(
name|p
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
block|}
block|}
name|p
operator|+=
name|i
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'\n'
condition|)
block|{
empty_stmt|;
block|}
comment|/* fetch SSP-, SR- and PC-registers  */
comment|/* first - check STATUS-word and decide which stackpointer to use */
name|send_with_reply
argument_list|(
literal|"SR"
argument_list|,
name|SR_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|SR_buf
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|SR_buf
expr_stmt|;
name|p
operator|+=
literal|5
expr_stmt|;
if|if
condition|(
name|m68020
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'3'
condition|)
comment|/* use masterstackpointer MSP */
block|{
name|send_with_reply
argument_list|(
literal|"MSP"
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'2'
condition|)
comment|/* use interruptstackpointer ISP  */
block|{
name|send_with_reply
argument_list|(
literal|"ISP"
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* use userstackpointer USP  */
block|{
name|send_with_reply
argument_list|(
literal|"USP"
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|4
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
name|k
operator|*
literal|2
operator|+
literal|1
index|]
operator|==
literal|0
operator|||
name|p
index|[
name|k
operator|*
literal|2
operator|+
literal|2
index|]
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Emulator reply is too short: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|registers
index|[
name|r
operator|++
index|]
operator|=
name|fromhex
argument_list|(
name|buf
index|[
name|k
operator|*
literal|2
operator|+
literal|1
index|]
argument_list|)
operator|*
literal|16
operator|+
name|fromhex
argument_list|(
name|buf
index|[
name|k
operator|*
literal|2
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|SR_buf
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|4
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
name|k
operator|*
literal|2
operator|+
literal|1
index|]
operator|==
literal|0
operator|||
name|p
index|[
name|k
operator|*
literal|2
operator|+
literal|2
index|]
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Emulator reply is too short: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|registers
index|[
name|r
operator|++
index|]
operator|=
name|fromhex
argument_list|(
name|SR_buf
index|[
name|k
operator|*
literal|2
operator|+
literal|1
index|]
argument_list|)
operator|*
literal|16
operator|+
name|fromhex
argument_list|(
name|SR_buf
index|[
name|k
operator|*
literal|2
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
name|send_with_reply
argument_list|(
literal|"PC"
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|4
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
name|k
operator|*
literal|2
operator|+
literal|1
index|]
operator|==
literal|0
operator|||
name|p
index|[
name|k
operator|*
literal|2
operator|+
literal|2
index|]
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Emulator reply is too short: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|registers
index|[
name|r
operator|++
index|]
operator|=
name|fromhex
argument_list|(
name|buf
index|[
name|k
operator|*
literal|2
operator|+
literal|1
index|]
argument_list|)
operator|*
literal|16
operator|+
name|fromhex
argument_list|(
name|buf
index|[
name|k
operator|*
literal|2
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* 68000-mode */
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'2'
condition|)
comment|/* use supervisorstackpointer SSP  */
block|{
name|send_with_reply
argument_list|(
literal|"SSP"
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* use userstackpointer USP  */
block|{
name|send_with_reply
argument_list|(
literal|"USP"
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* fetch STACKPOINTER */
name|p
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|4
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
name|k
operator|*
literal|2
operator|+
literal|1
index|]
operator|==
literal|0
operator|||
name|p
index|[
name|k
operator|*
literal|2
operator|+
literal|2
index|]
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Emulator reply is too short: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|registers
index|[
name|r
operator|++
index|]
operator|=
name|fromhex
argument_list|(
name|buf
index|[
name|k
operator|*
literal|2
operator|+
literal|1
index|]
argument_list|)
operator|*
literal|16
operator|+
name|fromhex
argument_list|(
name|buf
index|[
name|k
operator|*
literal|2
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* fetch STATUS */
name|p
operator|=
name|SR_buf
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|4
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
name|k
operator|*
literal|2
operator|+
literal|1
index|]
operator|==
literal|0
operator|||
name|p
index|[
name|k
operator|*
literal|2
operator|+
literal|2
index|]
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Emulator reply is too short: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|registers
index|[
name|r
operator|++
index|]
operator|=
name|fromhex
argument_list|(
name|SR_buf
index|[
name|k
operator|*
literal|2
operator|+
literal|1
index|]
argument_list|)
operator|*
literal|16
operator|+
name|fromhex
argument_list|(
name|SR_buf
index|[
name|k
operator|*
literal|2
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* fetch PC */
name|send_with_reply
argument_list|(
literal|"PC"
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|4
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
name|p
index|[
name|k
operator|*
literal|2
operator|+
literal|1
index|]
operator|==
literal|0
operator|||
name|p
index|[
name|k
operator|*
literal|2
operator|+
literal|2
index|]
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Emulator reply is too short: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|registers
index|[
name|r
operator|++
index|]
operator|=
name|fromhex
argument_list|(
name|buf
index|[
name|k
operator|*
literal|2
operator|+
literal|1
index|]
argument_list|)
operator|*
literal|16
operator|+
name|fromhex
argument_list|(
name|buf
index|[
name|k
operator|*
literal|2
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Store register value, located in REGISTER, on the target processor.    regno - the register-number of the register to store            (-1 means store them all)    FIXME: Return errno value.  */
end_comment

begin_function
specifier|static
name|void
name|es1800_store_register
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
specifier|static
name|char
name|regtab
index|[
literal|18
index|]
index|[
literal|4
index|]
init|=
block|{
literal|"D0 "
block|,
literal|"D1 "
block|,
literal|"D2 "
block|,
literal|"D3 "
block|,
literal|"D4 "
block|,
literal|"D5 "
block|,
literal|"D6 "
block|,
literal|"D7 "
block|,
literal|"A0 "
block|,
literal|"A1 "
block|,
literal|"A2 "
block|,
literal|"A3 "
block|,
literal|"A4 "
block|,
literal|"A5 "
block|,
literal|"A6 "
block|,
literal|"SSP"
block|,
literal|"SR "
block|,
literal|"PC "
block|}
decl_stmt|;
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|char
name|SR_buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|char
name|stack_pointer
index|[
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|k
decl_stmt|;
name|unsigned
name|char
modifier|*
name|r
decl_stmt|;
name|r
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|registers
expr_stmt|;
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
comment|/* write all registers */
block|{
name|j
operator|=
literal|0
expr_stmt|;
name|k
operator|=
literal|18
expr_stmt|;
block|}
else|else
comment|/* write one register */
block|{
name|j
operator|=
name|regno
expr_stmt|;
name|k
operator|=
name|regno
operator|+
literal|1
expr_stmt|;
name|r
operator|+=
name|regno
operator|*
literal|4
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
literal|15
operator|)
condition|)
block|{
comment|/* fetch current status */
name|send_with_reply
argument_list|(
literal|"SR"
argument_list|,
name|SR_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|SR_buf
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|SR_buf
expr_stmt|;
name|p
operator|+=
literal|5
expr_stmt|;
if|if
condition|(
name|m68020
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'3'
condition|)
comment|/* use masterstackpointer MSP */
block|{
name|strcpy
argument_list|(
name|stack_pointer
argument_list|,
literal|"MSP"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'2'
condition|)
comment|/* use interruptstackpointer ISP  */
block|{
name|strcpy
argument_list|(
name|stack_pointer
argument_list|,
literal|"ISP"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|stack_pointer
argument_list|,
literal|"USP"
argument_list|)
expr_stmt|;
comment|/* use userstackpointer USP  */
block|}
block|}
block|}
else|else
comment|/* 68000-mode */
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'2'
condition|)
comment|/* use supervisorstackpointer SSP  */
block|{
name|strcpy
argument_list|(
name|stack_pointer
argument_list|,
literal|"SSP"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|stack_pointer
argument_list|,
literal|"USP"
argument_list|)
expr_stmt|;
comment|/* use userstackpointer USP  */
block|}
block|}
name|strcpy
argument_list|(
name|regtab
index|[
literal|15
index|]
argument_list|,
name|stack_pointer
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|j
init|;
name|i
operator|<
name|k
condition|;
name|i
operator|++
control|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|regtab
index|[
name|i
index|]
index|[
literal|0
index|]
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|regtab
index|[
name|i
index|]
index|[
literal|1
index|]
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
name|regtab
index|[
name|i
index|]
index|[
literal|2
index|]
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
literal|'='
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
literal|'$'
expr_stmt|;
name|buf
index|[
literal|5
index|]
operator|=
name|tohex
argument_list|(
operator|(
operator|*
name|r
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
name|buf
index|[
literal|6
index|]
operator|=
name|tohex
argument_list|(
operator|*
name|r
operator|++
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
name|buf
index|[
literal|7
index|]
operator|=
name|tohex
argument_list|(
operator|(
operator|*
name|r
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
name|buf
index|[
literal|8
index|]
operator|=
name|tohex
argument_list|(
operator|*
name|r
operator|++
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
name|buf
index|[
literal|9
index|]
operator|=
name|tohex
argument_list|(
operator|(
operator|*
name|r
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
name|buf
index|[
literal|10
index|]
operator|=
name|tohex
argument_list|(
operator|*
name|r
operator|++
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
name|buf
index|[
literal|11
index|]
operator|=
name|tohex
argument_list|(
operator|(
operator|*
name|r
operator|>>
literal|4
operator|)
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
name|buf
index|[
literal|12
index|]
operator|=
name|tohex
argument_list|(
operator|*
name|r
operator|++
operator|&
literal|0x0f
argument_list|)
expr_stmt|;
name|buf
index|[
literal|13
index|]
operator|=
literal|0
expr_stmt|;
name|send_with_reply
argument_list|(
name|buf
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FIXME, reply not used? */
block|}
block|}
end_function

begin_comment
comment|/* Prepare to store registers.  */
end_comment

begin_function
specifier|static
name|void
name|es1800_prepare_to_store
parameter_list|()
block|{
comment|/* Do nothing, since we can store individual regs */
block|}
end_function

begin_comment
comment|/* Convert hex digit A to a number.  */
end_comment

begin_function
specifier|static
name|int
name|fromhex
parameter_list|(
name|a
parameter_list|)
name|int
name|a
decl_stmt|;
block|{
if|if
condition|(
name|a
operator|>=
literal|'0'
operator|&&
name|a
operator|<=
literal|'9'
condition|)
block|{
return|return
name|a
operator|-
literal|'0'
return|;
block|}
elseif|else
if|if
condition|(
name|a
operator|>=
literal|'a'
operator|&&
name|a
operator|<=
literal|'f'
condition|)
block|{
return|return
name|a
operator|-
literal|'a'
operator|+
literal|10
return|;
block|}
elseif|else
if|if
condition|(
name|a
operator|>=
literal|'A'
operator|&&
name|a
operator|<=
literal|'F'
condition|)
block|{
return|return
name|a
operator|-
literal|'A'
operator|+
literal|10
return|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"Reply contains invalid hex digit"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Convert number NIB to a hex digit.  */
end_comment

begin_function
specifier|static
name|int
name|tohex
parameter_list|(
name|nib
parameter_list|)
name|int
name|nib
decl_stmt|;
block|{
if|if
condition|(
name|nib
operator|<
literal|10
condition|)
block|{
return|return
operator|(
literal|'0'
operator|+
name|nib
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|'A'
operator|+
name|nib
operator|-
literal|10
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Read or write LEN bytes from inferior memory at MEMADDR, transferring    to or from debugger address MYADDR.  Write to inferior if WRITE is    nonzero.  Returns length of data written or read; 0 for error.       memaddr - the target's address    myaddr  - gdb's address    len     - number of bytes     write   - write if != 0 otherwise read	*/
end_comment

begin_function
specifier|static
name|int
name|es1800_xfer_inferior_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|write
parameter_list|,
name|tops
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|write
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|tops
decl_stmt|;
comment|/* Unused */
block|{
name|int
name|origlen
init|=
name|len
decl_stmt|;
name|int
name|xfersize
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|xfersize
operator|=
name|len
operator|>
name|MAXBUFBYTES
condition|?
name|MAXBUFBYTES
else|:
name|len
expr_stmt|;
if|if
condition|(
name|write
condition|)
block|{
name|es1800_write_bytes
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|xfersize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|es1800_read_bytes
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|xfersize
argument_list|)
expr_stmt|;
block|}
name|memaddr
operator|+=
name|xfersize
expr_stmt|;
name|myaddr
operator|+=
name|xfersize
expr_stmt|;
name|len
operator|-=
name|xfersize
expr_stmt|;
block|}
return|return
operator|(
name|origlen
operator|)
return|;
comment|/* no error possible */
block|}
end_function

begin_comment
comment|/* Write memory data directly to the emulator.    This does not inform the data cache; the data cache uses this.    MEMADDR is the address in the remote memory space.    MYADDR is the address of the buffer in our space.    LEN is the number of bytes.      memaddr - the target's address    myaddr  - gdb's address    len     - number of bytes   */
end_comment

begin_function
specifier|static
name|void
name|es1800_write_bytes
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|myaddr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"@.B$%x=$%x"
argument_list|,
name|memaddr
operator|+
name|i
argument_list|,
operator|(
operator|*
name|p
operator|++
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|send_with_reply
argument_list|(
name|buf
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FIXME send_command? */
block|}
block|}
end_function

begin_comment
comment|/* Read memory data directly from the emulator.    This does not use the data cache; the data cache uses this.      memaddr - the target's address    myaddr  - gdb's address    len     - number of bytes   */
end_comment

begin_function
specifier|static
name|void
name|es1800_read_bytes
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|static
name|int
name|DB_tab
index|[
literal|16
index|]
init|=
block|{
literal|8
block|,
literal|11
block|,
literal|14
block|,
literal|17
block|,
literal|20
block|,
literal|23
block|,
literal|26
block|,
literal|29
block|,
literal|34
block|,
literal|37
block|,
literal|40
block|,
literal|43
block|,
literal|46
block|,
literal|49
block|,
literal|52
block|,
literal|55
block|}
decl_stmt|;
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|low_addr
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|b
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|PBUFSIZ
operator|/
literal|2
operator|-
literal|1
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|==
literal|1
condition|)
comment|/* The emulator does not like expressions like:  */
block|{
name|len
operator|=
literal|2
expr_stmt|;
comment|/* DB.B $20018 TO $20018                       */
block|}
comment|/* Reply describes registers byte by byte, each byte encoded as two hex      characters.  */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"DB.B $%x TO $%x"
argument_list|,
name|memaddr
argument_list|,
name|memaddr
operator|+
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|send_with_reply
argument_list|(
name|buf
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|=
name|buf
expr_stmt|;
name|low_addr
operator|=
name|memaddr
operator|&
literal|0x0f
expr_stmt|;
for|for
control|(
name|i
operator|=
name|low_addr
init|;
name|i
operator|<
name|low_addr
operator|+
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|!
operator|(
name|i
operator|%
literal|16
operator|)
operator|)
operator|&&
name|i
condition|)
block|{
comment|/* if (i = 16,32,48)  */
while|while
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'\n'
condition|)
block|{
empty_stmt|;
block|}
name|b
operator|=
name|p
expr_stmt|;
block|}
name|p
operator|=
name|b
operator|+
name|DB_tab
index|[
name|i
operator|%
literal|16
index|]
operator|+
operator|(
name|m68020
condition|?
literal|2
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|32
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|32
condition|)
block|{
name|error
argument_list|(
literal|"Emulator reply is too short: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|myaddr
index|[
name|i
operator|-
name|low_addr
index|]
operator|=
name|fromhex
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
operator|*
literal|16
operator|+
name|fromhex
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Information about the current target  */
end_comment

begin_function
specifier|static
name|void
name|es1800_files_info
parameter_list|(
name|tops
parameter_list|)
name|struct
name|target_ops
modifier|*
name|tops
decl_stmt|;
comment|/* Unused */
block|{
name|printf
argument_list|(
literal|"ES1800 Attached to %s at %d baud in %s mode\n"
argument_list|,
name|savename
argument_list|,
literal|19200
argument_list|,
name|MODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* We read the contents of the target location and stash it,    then overwrite it with a breakpoint instruction.      addr           - is the target location in the target machine.    contents_cache - is a pointer to memory allocated for saving the target contents.                     It is guaranteed by the caller to be long enough to save sizeof                      BREAKPOINT bytes.      FIXME: This size is target_arch dependent and should be available in    the target_arch transfer vector, if we ever have one...  */
end_comment

begin_function
specifier|static
name|int
name|es1800_insert_breakpoint
parameter_list|(
name|addr
parameter_list|,
name|contents_cache
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|contents_cache
decl_stmt|;
block|{
name|int
name|val
decl_stmt|;
name|val
operator|=
name|target_read_memory
argument_list|(
name|addr
argument_list|,
name|contents_cache
argument_list|,
sizeof|sizeof
argument_list|(
name|es1800_break_insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
name|val
operator|=
name|target_write_memory
argument_list|(
name|addr
argument_list|,
name|es1800_break_insn
argument_list|,
sizeof|sizeof
argument_list|(
name|es1800_break_insn
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Write back the stashed instruction      addr           - is the target location in the target machine.    contents_cache - is a pointer to memory allocated for saving the target contents.                     It is guaranteed by the caller to be long enough to save sizeof                      BREAKPOINT bytes.	*/
end_comment

begin_function
specifier|static
name|int
name|es1800_remove_breakpoint
parameter_list|(
name|addr
parameter_list|,
name|contents_cache
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|contents_cache
decl_stmt|;
block|{
return|return
operator|(
name|target_write_memory
argument_list|(
name|addr
argument_list|,
name|contents_cache
argument_list|,
sizeof|sizeof
argument_list|(
name|es1800_break_insn
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* create_break_insn ()    Primitive datastructures containing the es1800 breakpoint instruction  */
end_comment

begin_function
specifier|static
name|void
name|es1800_create_break_insn
parameter_list|(
name|ins
parameter_list|,
name|vec
parameter_list|)
name|char
modifier|*
name|ins
decl_stmt|;
name|int
name|vec
decl_stmt|;
block|{
if|if
condition|(
name|vec
operator|==
literal|15
condition|)
block|{
name|ins
index|[
literal|0
index|]
operator|=
literal|0x4e
expr_stmt|;
name|ins
index|[
literal|1
index|]
operator|=
literal|0x4f
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* verify_break ()    Seach for breakpoint routine in emulator memory.    returns non-zero on failure    vec - trap vector used for breakpoints  */
end_comment

begin_function
specifier|static
name|int
name|verify_break
parameter_list|(
name|vec
parameter_list|)
name|int
name|vec
decl_stmt|;
block|{
name|CORE_ADDR
name|memaddress
decl_stmt|;
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|char
modifier|*
name|instr
init|=
literal|"NqNqNqNs"
decl_stmt|;
comment|/* breakpoint routine */
name|int
name|status
decl_stmt|;
name|get_break_addr
argument_list|(
name|vec
argument_list|,
operator|&
name|memaddress
argument_list|)
expr_stmt|;
if|if
condition|(
name|memaddress
condition|)
block|{
name|status
operator|=
name|target_read_memory
argument_list|(
name|memaddress
argument_list|,
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|memory_error
argument_list|(
name|status
argument_list|,
name|memaddress
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|STRCMP
argument_list|(
name|instr
argument_list|,
name|buf
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* get_break_addr ()    find address of breakpint routine    vec - trap vector used for breakpoints    addrp - store the address here	*/
end_comment

begin_function
specifier|static
name|void
name|get_break_addr
parameter_list|(
name|vec
parameter_list|,
name|addrp
parameter_list|)
name|int
name|vec
decl_stmt|;
name|CORE_ADDR
modifier|*
name|addrp
decl_stmt|;
block|{
name|CORE_ADDR
name|memaddress
init|=
literal|0
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|k
decl_stmt|;
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|char
name|base_addr
index|[
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|m68020
condition|)
block|{
name|send_with_reply
argument_list|(
literal|"VBR "
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|4
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|p
index|[
name|k
operator|*
literal|2
operator|+
literal|1
index|]
operator|==
literal|0
operator|)
operator|||
operator|(
name|p
index|[
name|k
operator|*
literal|2
operator|+
literal|2
index|]
operator|==
literal|0
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"Emulator reply is too short: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|base_addr
index|[
name|k
index|]
operator|=
operator|(
name|fromhex
argument_list|(
name|p
index|[
name|k
operator|*
literal|2
operator|+
literal|1
index|]
argument_list|)
operator|*
literal|16
operator|)
operator|+
name|fromhex
argument_list|(
name|p
index|[
name|k
operator|*
literal|2
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* base addr of exception vector table */
name|memaddress
operator|=
operator|*
operator|(
operator|(
name|CORE_ADDR
operator|*
operator|)
name|base_addr
operator|)
expr_stmt|;
block|}
name|memaddress
operator|+=
operator|(
name|vec
operator|+
literal|32
operator|)
operator|*
literal|4
expr_stmt|;
comment|/* address of trap vector */
name|status
operator|=
name|target_read_memory
argument_list|(
name|memaddress
argument_list|,
operator|(
name|char
operator|*
operator|)
name|addrp
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
name|memory_error
argument_list|(
name|status
argument_list|,
name|memaddress
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Kill an inferior process */
end_comment

begin_function
specifier|static
name|void
name|es1800_kill
parameter_list|()
block|{
if|if
condition|(
name|inferior_pid
operator|!=
literal|0
condition|)
block|{
name|inferior_pid
operator|=
literal|0
expr_stmt|;
name|es1800_mourn_inferior
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Load a file to the ES1800 emulator.     Converts the file from a.out format into Extended Tekhex format    before the file is loaded.    Also loads the trap routine, and sets the ES1800 breakpoint on it    filename - the a.out to be loaded    from_tty - says whether to be verbose or not    FIXME Uses emulator overlay memory for trap routine	*/
end_comment

begin_function
specifier|static
name|void
name|es1800_load
parameter_list|(
name|filename
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|FILE
modifier|*
name|instream
decl_stmt|;
name|char
name|loadname
index|[
literal|15
index|]
decl_stmt|;
name|char
name|buf
index|[
literal|160
index|]
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|int
name|es1800_load_format
init|=
literal|5
decl_stmt|;
if|if
condition|(
name|es1800_desc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"No emulator attached, type emulator-command first\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|filename
operator|=
name|tilde_expand
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|filename
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|es1800_load_format
condition|)
block|{
case|case
literal|2
case|:
comment|/* Extended Tekhex  */
if|if
condition|(
name|from_tty
condition|)
block|{
name|printf
argument_list|(
literal|"Converting \"%s\" to Extended Tekhex Format\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"tekhex %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|loadname
argument_list|,
literal|"out.hex"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* Motorola S-rec  */
if|if
condition|(
name|from_tty
condition|)
block|{
name|printf
argument_list|(
literal|"Converting \"%s\" to Motorola S-record format\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
comment|/* in the future the source code in copy (part of binutils-1.93) will 	   be included in this file */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"copy -s \"a.out-sunos-big\" -d \"srec\" %s /tmp/out.hex"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|loadname
argument_list|,
literal|"/tmp/out.hex"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Downloading format not defined\n"
argument_list|)
expr_stmt|;
block|}
name|breakpoint_init_inferior
argument_list|()
expr_stmt|;
name|inferior_pid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|printf
argument_list|(
literal|"Downloading \"%s\" to the ES 1800\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|instream
operator|=
name|fopen
argument_list|(
name|loadname
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror_with_name
argument_list|(
literal|"fopen:"
argument_list|)
expr_stmt|;
block|}
name|old_chain
operator|=
name|make_cleanup
argument_list|(
name|fclose
argument_list|,
name|instream
argument_list|)
expr_stmt|;
name|immediate_quit
operator|++
expr_stmt|;
name|es1800_reset
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|download
argument_list|(
name|instream
argument_list|,
name|from_tty
argument_list|,
name|es1800_load_format
argument_list|)
expr_stmt|;
comment|/* if breakpoint routine is not present anymore we have to check       whether to download a new breakpoint routine or not */
if|if
condition|(
operator|(
name|verify_break
argument_list|(
name|es1800_break_vec
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
name|query
argument_list|(
literal|"No breakpoint routine in ES 1800 emulator!\nDownload a breakpoint routine to the emulator? "
argument_list|)
condition|)
block|{
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"Using break vector 0x%x\n"
argument_list|,
name|es1800_break_vec
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"0x%x "
argument_list|,
name|es1800_break_vec
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Give the start address of the breakpoint routine: "
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|es1800_init_break
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|()
expr_stmt|;
name|readchar
argument_list|()
expr_stmt|;
comment|/* FIXME I am getting a ^G = 7 after the prompt  */
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fclose
argument_list|(
name|instream
argument_list|)
operator|==
name|EOF
condition|)
block|{
empty_stmt|;
block|}
if|if
condition|(
name|es1800_load_format
operator|!=
literal|2
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"/usr/bin/rm %s"
argument_list|,
name|loadname
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|symbol_file_command
argument_list|(
name|filename
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
comment|/* reading symbol table */
name|immediate_quit
operator|--
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_define
define|#
directive|define
name|NUMCPYBYTES
value|20
end_define

begin_endif
unit|static void bfd_copy (from_bfd, to_bfd)      bfd *from_bfd;      bfd *to_bfd; {   asection *p, *new;   int i;   char buf[NUMCPYBYTES];    for (p = from_bfd->sections; p != NULL; p = p->next)     {       printf ("  Copying section %s. Size = %x.\n", p->name, p->_cooked_size);       printf ("    vma = %x,  offset = %x,  output_sec = %x\n", 	      p->vma, p->output_offset, p->output_section);       new = bfd_make_section (to_bfd, p->name);       if (p->_cooked_size&& 	  !bfd_set_section_size (to_bfd, new, p->_cooked_size)) 	{ 	  error ("Wrong BFD size!\n"); 	}       if (!bfd_set_section_flags (to_bfd, new, p->flags)) 	{ 	  error ("bfd_set_section_flags"); 	}       new->vma = p->vma;              for (i = 0; (i + NUMCPYBYTES)< p->_cooked_size ; i += NUMCPYBYTES) 	{ 	  if (!bfd_get_section_contents (from_bfd, p, (PTR) buf, (file_ptr) i, 					(bfd_size_type) NUMCPYBYTES)) 	    { 	      error ("bfd_get_section_contents\n"); 	    } 	if (!bfd_set_section_contents (to_bfd, new, (PTR) buf, (file_ptr) i, 				      (bfd_size_type) NUMCPYBYTES)) 	  { 	    error ("bfd_set_section_contents\n"); 	  }       }       bfd_get_section_contents (from_bfd, p, (PTR) buf, (file_ptr) i, 				(bfd_size_type) (p->_cooked_size - i));       bfd_set_section_contents (to_bfd, new, (PTR) buf,(file_ptr) i, 				(bfd_size_type) (p->_cooked_size - i));     } }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Start an process on the es1800 and set inferior_pid to the new    process' pid.    execfile - the file to run    args     - arguments passed to the program    env      - the environment vector to pass	*/
end_comment

begin_function
specifier|static
name|void
name|es1800_create_inferior
parameter_list|(
name|execfile
parameter_list|,
name|args
parameter_list|,
name|env
parameter_list|)
name|char
modifier|*
name|execfile
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
name|char
modifier|*
modifier|*
name|env
decl_stmt|;
block|{
name|int
name|entry_pt
decl_stmt|;
name|int
name|pid
decl_stmt|;
if|#
directive|if
literal|0
block|struct expression *expr;   register struct cleanup *old_chain = 0;   register value val;
endif|#
directive|endif
if|if
condition|(
name|args
operator|&&
operator|*
name|args
condition|)
block|{
name|error
argument_list|(
literal|"Can't pass arguments to remote ES1800 process"
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|if (query ("Use 'start' as entry point? "))     {       expr = parse_c_expression ("start");       old_chain = make_cleanup (free_current_contents,&expr);       val = evaluate_expression (expr);       entry_pt = (val->location).address;     }   else     {       printf ("Enter the program's entry point (in hexadecimal): ");       scanf ("%x",&entry_pt);     }
endif|#
directive|endif
if|if
condition|(
name|execfile
operator|==
literal|0
operator|||
name|exec_bfd
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"No exec file specified"
argument_list|)
expr_stmt|;
block|}
name|entry_pt
operator|=
operator|(
name|int
operator|)
name|bfd_get_start_address
argument_list|(
name|exec_bfd
argument_list|)
expr_stmt|;
name|pid
operator|=
literal|42
expr_stmt|;
comment|/* Now that we have a child process, make it our target.  */
name|push_target
argument_list|(
operator|&
name|es1800_child_ops
argument_list|)
expr_stmt|;
comment|/* The "process" (board) is already stopped awaiting our commands, and      the program is already downloaded.  We just set its PC and go.  */
name|inferior_pid
operator|=
name|pid
expr_stmt|;
comment|/* Needed for wait_for_inferior below */
name|clear_proceed_status
argument_list|()
expr_stmt|;
comment|/* Tell wait_for_inferior that we've started a new process.  */
name|init_wait_for_inferior
argument_list|()
expr_stmt|;
comment|/* Set up the "saved terminal modes" of the inferior      based on what modes we are starting it with.  */
name|target_terminal_init
argument_list|()
expr_stmt|;
comment|/* Install inferior's terminal modes.  */
name|target_terminal_inferior
argument_list|()
expr_stmt|;
comment|/* remote_start (args); */
comment|/* trap_expected = 0; */
comment|/* insert_step_breakpoint ();  FIXME, do we need this?  */
comment|/* Let 'er rip... */
name|proceed
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|entry_pt
argument_list|,
name|TARGET_SIGNAL_DEFAULT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The process has died, clean up.  */
end_comment

begin_function
specifier|static
name|void
name|es1800_mourn_inferior
parameter_list|()
block|{
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|es1800_child_ops
argument_list|)
expr_stmt|;
name|generic_mourn_inferior
argument_list|()
expr_stmt|;
comment|/* Do all the proper things now */
block|}
end_function

begin_comment
comment|/* ES1800-protocol specific routines */
end_comment

begin_comment
comment|/* Keep discarding input from the remote system, until STRING is found.     Let the user break out immediately.     string - the string to expect    nowait - break out if string not the emulator's first respond otherwise             read until string is found (== 0)   */
end_comment

begin_function
specifier|static
name|void
name|expect
parameter_list|(
name|string
parameter_list|,
name|nowait
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
name|int
name|nowait
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|string
decl_stmt|;
name|immediate_quit
operator|++
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|readchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|isalpha
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|c
operator|=
name|toupper
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|toupper
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|immediate_quit
operator|--
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|nowait
condition|)
block|{
name|p
operator|=
name|string
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\'%s\' expected\n"
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"char %d is %d"
argument_list|,
name|p
operator|-
name|string
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Keep discarding input until we see the prompt.  */
end_comment

begin_function
specifier|static
name|void
name|expect_prompt
parameter_list|()
block|{
name|expect
argument_list|(
literal|">"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read one character */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_STDIN
end_ifdef

begin_comment
comment|/* read from stdin */
end_comment

begin_function
specifier|static
name|int
name|readchar
parameter_list|()
block|{
name|char
name|buf
index|[
literal|1
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|printf
argument_list|(
literal|"readchar, give one character\n"
argument_list|)
expr_stmt|;
name|read
argument_list|(
literal|0
argument_list|,
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|LOG_FILE
argument_list|)
name|putc
argument_list|(
name|buf
index|[
literal|0
index|]
operator|&
literal|0x7f
argument_list|,
name|log_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|buf
index|[
literal|0
index|]
operator|&
literal|0x7f
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !DEBUG_STDIN */
end_comment

begin_comment
comment|/* Read a character from the remote system, doing all the fancy    timeout stuff.  */
end_comment

begin_function
specifier|static
name|int
name|readchar
parameter_list|()
block|{
name|int
name|ch
decl_stmt|;
name|ch
operator|=
name|SERIAL_READCHAR
argument_list|(
name|es1800_desc
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
comment|/* FIXME: doing an error() here will probably cause trouble, at least if from      es1800_wait.  */
if|if
condition|(
name|ch
operator|==
name|SERIAL_TIMEOUT
condition|)
name|error
argument_list|(
literal|"Timeout reading from remote system."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
name|SERIAL_ERROR
condition|)
name|perror_with_name
argument_list|(
literal|"remote read"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|LOG_FILE
argument_list|)
name|putc
argument_list|(
name|ch
operator|&
literal|0x7f
argument_list|,
name|log_file
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|log_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ch
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG_STDIN */
end_comment

begin_comment
comment|/* Send a command to the emulator and save the reply.    Report an error if we get an error reply.    string - the es1800 command    buf    - containing the emulator reply on return    len    - size of buf  */
end_comment

begin_function
specifier|static
name|void
name|send_with_reply
parameter_list|(
name|string
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|,
decl|*
name|buf
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|send
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|SERIAL_WRITE
argument_list|(
name|es1800_desc
argument_list|,
literal|"\r"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|DEBUG_STDIN
name|expect
argument_list|(
name|string
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"\r\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|getmessage
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Send the command in STR to the emulator adding \r. check    the echo for consistency.     string - the es1800 command  */
end_comment

begin_function
specifier|static
name|void
name|send_command
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|send
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|SERIAL_WRITE
argument_list|(
name|es1800_desc
argument_list|,
literal|"\r"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|DEBUG_STDIN
name|expect
argument_list|(
name|string
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|expect_prompt
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Send a string    string - the es1800 command  */
end_comment

begin_function
specifier|static
name|void
name|send
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
if|if
condition|(
name|kiodebug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Sending: %s\n"
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
name|SERIAL_WRITE
argument_list|(
name|es1800_desc
argument_list|,
name|string
argument_list|,
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read a message from the emulator and store it in BUF.     buf    - containing the emulator reply on return    len    - size of buf  */
end_comment

begin_function
specifier|static
name|void
name|getmessage
parameter_list|(
name|buf
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|char
modifier|*
name|bp
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|prompt_found
init|=
literal|0
decl_stmt|;
extern|extern kiodebug;
if|#
directive|if
name|defined
argument_list|(
name|LOG_FILE
argument_list|)
comment|/* This is a convenient place to do this.  The idea is to do it often      enough that we never lose much data if we terminate abnormally.  */
name|fflush
argument_list|(
name|log_file
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bp
operator|=
name|buf
expr_stmt|;
name|c
operator|=
name|readchar
argument_list|()
expr_stmt|;
do|do
block|{
if|if
condition|(
name|c
condition|)
block|{
if|if
condition|(
name|len
operator|--
operator|<
literal|2
condition|)
comment|/* char and terminaling NULL */
block|{
name|error
argument_list|(
literal|"input buffer overrun\n"
argument_list|)
expr_stmt|;
block|}
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
block|}
name|c
operator|=
name|readchar
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'>'
operator|)
operator|&&
operator|(
operator|*
operator|(
name|bp
operator|-
literal|1
operator|)
operator|==
literal|' '
operator|)
condition|)
block|{
name|prompt_found
operator|=
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
name|prompt_found
condition|)
do|;
operator|*
name|bp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|kiodebug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"message received :%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|download
parameter_list|(
name|instream
parameter_list|,
name|from_tty
parameter_list|,
name|format
parameter_list|)
name|FILE
modifier|*
name|instream
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|int
name|format
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
name|char
name|buf
index|[
literal|160
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|send_command
argument_list|(
literal|"SET #2,$1A"
argument_list|)
expr_stmt|;
comment|/* reset char = ^Z */
name|send_command
argument_list|(
literal|"SET #3,$11,$13"
argument_list|)
expr_stmt|;
comment|/* XON  XOFF */
if|if
condition|(
name|format
operator|==
literal|2
condition|)
block|{
name|send_command
argument_list|(
literal|"SET #26,#2"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|send_command
argument_list|(
literal|"SET #26,#5"
argument_list|)
expr_stmt|;
comment|/* Format=Extended Tekhex */
block|}
name|send_command
argument_list|(
literal|"DFB = $10"
argument_list|)
expr_stmt|;
name|send_command
argument_list|(
literal|"PUR"
argument_list|)
expr_stmt|;
name|send_command
argument_list|(
literal|"CES"
argument_list|)
expr_stmt|;
name|send
argument_list|(
literal|"DNL\r"
argument_list|)
expr_stmt|;
name|expect
argument_list|(
literal|"DNL"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|printf
argument_list|(
literal|"    0 records loaded...\r"
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
literal|160
argument_list|,
name|instream
argument_list|)
condition|)
block|{
name|send
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|printf
argument_list|(
literal|"%5d\b\b\b\b\b"
argument_list|,
operator|++
name|i
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|c
operator|=
name|readchar
argument_list|()
operator|)
operator|!=
literal|006
condition|)
block|{
name|error
argument_list|(
literal|"expected ACK"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|from_tty
condition|)
block|{
name|printf
argument_list|(
literal|"- All"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Additional commands */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|TIOCGETP
argument_list|)
operator|&&
name|defined
argument_list|(
name|FNDELAY
argument_list|)
operator|&&
name|defined
argument_list|(
name|EWOULDBLOCK
argument_list|)
end_if

begin_define
define|#
directive|define
name|PROVIDE_TRANSPARENT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PROVIDE_TRANSPARENT
end_ifdef

begin_comment
comment|/* Talk directly to the emulator    FIXME, uses busy wait, and is SUNOS (or at least BSD) specific  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|es1800_transparent
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|console
decl_stmt|;
name|struct
name|sgttyb
name|modebl
decl_stmt|;
name|int
name|fcflag
decl_stmt|;
name|int
name|cc
decl_stmt|;
name|struct
name|sgttyb
name|console_mode_save
decl_stmt|;
name|int
name|console_fc_save
decl_stmt|;
name|int
name|es1800_fc_save
decl_stmt|;
name|int
name|inputcnt
init|=
literal|80
decl_stmt|;
name|char
name|inputbuf
index|[
literal|80
index|]
decl_stmt|;
name|int
name|consolecnt
init|=
literal|0
decl_stmt|;
name|char
name|consolebuf
index|[
literal|80
index|]
decl_stmt|;
name|int
name|es1800_cnt
init|=
literal|0
decl_stmt|;
name|char
name|es1800_buf
index|[
literal|80
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|dont_repeat
argument_list|()
expr_stmt|;
if|if
condition|(
name|es1800_desc
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"No emulator attached, type emulator-command first\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"You are now communicating directly with the ES 1800 emulator.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"To leave this mode (transparent mode), press ^E.\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|">"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|console
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror_with_name
argument_list|(
literal|"/dev/tty:"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fcflag
operator|=
name|fcntl
argument_list|(
name|console
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror_with_name
argument_list|(
literal|"fcntl console"
argument_list|)
expr_stmt|;
block|}
name|console_fc_save
operator|=
name|fcflag
expr_stmt|;
name|fcflag
operator|=
name|fcflag
operator||
name|FNDELAY
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
name|console
argument_list|,
name|F_SETFL
argument_list|,
name|fcflag
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror_with_name
argument_list|(
literal|"fcntl console"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|console
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|modebl
argument_list|)
condition|)
block|{
name|perror_with_name
argument_list|(
literal|"ioctl console"
argument_list|)
expr_stmt|;
block|}
name|console_mode_save
operator|=
name|modebl
expr_stmt|;
name|modebl
operator|.
name|sg_flags
operator|=
name|RAW
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|console
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|modebl
argument_list|)
condition|)
block|{
name|perror_with_name
argument_list|(
literal|"ioctl console"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fcflag
operator|=
name|fcntl
argument_list|(
name|es1800_desc
operator|->
name|fd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror_with_name
argument_list|(
literal|"fcntl serial"
argument_list|)
expr_stmt|;
block|}
name|es1800_fc_save
operator|=
name|fcflag
expr_stmt|;
name|fcflag
operator|=
name|fcflag
operator||
name|FNDELAY
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
name|es1800_desc
operator|->
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|fcflag
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror_with_name
argument_list|(
literal|"fcntl serial"
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|cc
operator|=
name|read
argument_list|(
name|console
argument_list|,
name|inputbuf
argument_list|,
name|inputcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|inputbuf
operator|&
literal|0x7f
operator|)
operator|==
literal|0x05
condition|)
block|{
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cc
condition|;
control|)
block|{
name|es1800_buf
index|[
name|es1800_cnt
operator|++
index|]
operator|=
name|inputbuf
index|[
name|i
operator|++
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cc
operator|=
name|SERIAL_WRITE
argument_list|(
name|es1800_desc
argument_list|,
name|es1800_buf
argument_list|,
name|es1800_cnt
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror_with_name
argument_list|(
literal|"FEL! write:"
argument_list|)
expr_stmt|;
block|}
name|es1800_cnt
operator|-=
name|cc
expr_stmt|;
if|if
condition|(
name|es1800_cnt
operator|&&
name|cc
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|es1800_cnt
condition|;
name|i
operator|++
control|)
block|{
name|es1800_buf
index|[
name|i
index|]
operator|=
name|es1800_buf
index|[
name|cc
operator|+
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|errno
operator|!=
name|EWOULDBLOCK
condition|)
block|{
name|perror_with_name
argument_list|(
literal|"FEL! read:"
argument_list|)
expr_stmt|;
block|}
name|cc
operator|=
name|read
argument_list|(
name|es1800_desc
operator|->
name|fd
argument_list|,
name|inputbuf
argument_list|,
name|inputcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|!=
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cc
condition|;
control|)
block|{
name|consolebuf
index|[
name|consolecnt
operator|++
index|]
operator|=
name|inputbuf
index|[
name|i
operator|++
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cc
operator|=
name|write
argument_list|(
name|console
argument_list|,
name|consolebuf
argument_list|,
name|consolecnt
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror_with_name
argument_list|(
literal|"FEL! write:"
argument_list|)
expr_stmt|;
block|}
name|consolecnt
operator|-=
name|cc
expr_stmt|;
if|if
condition|(
name|consolecnt
operator|&&
name|cc
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|consolecnt
condition|;
name|i
operator|++
control|)
block|{
name|consolebuf
index|[
name|i
index|]
operator|=
name|consolebuf
index|[
name|cc
operator|+
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|errno
operator|!=
name|EWOULDBLOCK
condition|)
block|{
name|perror_with_name
argument_list|(
literal|"FEL! read:"
argument_list|)
expr_stmt|;
block|}
block|}
name|console_fc_save
operator|=
name|console_fc_save
operator|&
operator|!
name|FNDELAY
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
name|console
argument_list|,
name|F_SETFL
argument_list|,
name|console_fc_save
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror_with_name
argument_list|(
literal|"FEL! fcntl"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ioctl
argument_list|(
name|console
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|console_mode_save
argument_list|)
condition|)
block|{
name|perror_with_name
argument_list|(
literal|"FEL! ioctl"
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|console
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
name|es1800_desc
operator|->
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|es1800_fc_save
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror_with_name
argument_list|(
literal|"FEL! fcntl"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PROVIDE_TRANSPARENT */
end_comment

begin_function
specifier|static
name|void
name|es1800_init_break
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|CORE_ADDR
name|memaddress
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|char
name|base_addr
index|[
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|space_index
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|k
decl_stmt|;
if|if
condition|(
name|args
operator|==
name|NULL
condition|)
block|{
name|error_no_arg
argument_list|(
literal|"a trap vector"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|space_index
operator|=
name|strchr
argument_list|(
name|args
argument_list|,
literal|' '
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"Two arguments needed (trap vector and address of break routine).\n"
argument_list|)
expr_stmt|;
block|}
operator|*
name|space_index
operator|=
literal|'\0'
expr_stmt|;
name|es1800_break_vec
operator|=
name|strtol
argument_list|(
name|args
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|es1800_break_address
operator|=
name|parse_and_eval_address
argument_list|(
name|space_index
operator|+
literal|1
argument_list|)
expr_stmt|;
name|es1800_create_break_insn
argument_list|(
name|es1800_break_insn
argument_list|,
name|es1800_break_vec
argument_list|)
expr_stmt|;
if|if
condition|(
name|m68020
condition|)
block|{
name|send_with_reply
argument_list|(
literal|"VBR "
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|4
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|p
index|[
name|k
operator|*
literal|2
operator|+
literal|1
index|]
operator|==
literal|0
operator|)
operator|||
operator|(
name|p
index|[
name|k
operator|*
literal|2
operator|+
literal|2
index|]
operator|==
literal|0
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"Emulator reply is too short: %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|base_addr
index|[
name|k
index|]
operator|=
operator|(
name|fromhex
argument_list|(
name|p
index|[
name|k
operator|*
literal|2
operator|+
literal|1
index|]
argument_list|)
operator|*
literal|16
operator|)
operator|+
name|fromhex
argument_list|(
name|p
index|[
name|k
operator|*
literal|2
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* base addr of exception vector table */
name|memaddress
operator|=
operator|*
operator|(
operator|(
name|CORE_ADDR
operator|*
operator|)
name|base_addr
operator|)
expr_stmt|;
block|}
name|memaddress
operator|+=
operator|(
name|es1800_break_vec
operator|+
literal|32
operator|)
operator|*
literal|4
expr_stmt|;
comment|/* address of trap vector */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"@.L%lx=$%lx"
argument_list|,
name|memaddress
argument_list|,
name|es1800_break_address
argument_list|)
expr_stmt|;
name|send_command
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* set the address of the break routine in the */
comment|/* trap vector */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"@.L%lx=$4E714E71"
argument_list|,
name|es1800_break_address
argument_list|)
expr_stmt|;
comment|/* NOP; NOP */
name|send_command
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"@.L%lx=$4E714E73"
argument_list|,
name|es1800_break_address
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* NOP; RTE */
name|send_command
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"AC2=$%lx"
argument_list|,
name|es1800_break_address
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* breakpoint at es1800-break_address */
name|send_command
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|send_command
argument_list|(
literal|"WHEN AC2 THEN BRK"
argument_list|)
expr_stmt|;
comment|/* ie in exception routine */
if|if
condition|(
name|from_tty
condition|)
block|{
name|printf
argument_list|(
literal|"Breakpoint (trap $%x) routine at address: %lx\n"
argument_list|,
name|es1800_break_vec
argument_list|,
name|es1800_break_address
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|es1800_child_open
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|error
argument_list|(
literal|"Use the \"run\" command to start a child process."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|es1800_child_detach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|args
condition|)
block|{
name|error
argument_list|(
literal|"Argument given to \"detach\" when remotely debugging."
argument_list|)
expr_stmt|;
block|}
name|pop_target
argument_list|()
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|printf
argument_list|(
literal|"Ending debugging the process %d.\n"
argument_list|,
name|inferior_pid
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Define the target subroutine names  */
end_comment

begin_decl_stmt
name|struct
name|target_ops
name|es1800_ops
init|=
block|{
literal|"es1800"
block|,
comment|/* to_shortname */
comment|/* to_longname */
literal|"Remote serial target in ES1800-emulator protocol"
block|,
comment|/* to_doc */
literal|"Remote debugging on the es1800 emulator via a serial line.\n\ Specify the serial device it is connected to (e.g. /dev/ttya)."
block|,
name|es1800_open
block|,
comment|/* to_open */
name|es1800_close
block|,
comment|/* to_close */
name|es1800_attach
block|,
comment|/* to_attach */
name|es1800_detach
block|,
comment|/* to_detach */
name|es1800_resume
block|,
comment|/* to_resume */
name|NULL
block|,
comment|/* to_wait */
name|NULL
block|,
comment|/* to_fetch_registers */
name|NULL
block|,
comment|/* to_store_registers */
name|es1800_prepare_to_store
block|,
comment|/* to_prepare_to_store */
name|es1800_xfer_inferior_memory
block|,
comment|/* to_xfer_memory */
name|es1800_files_info
block|,
comment|/* to_files_info */
name|es1800_insert_breakpoint
block|,
comment|/* to_insert_breakpoint */
name|es1800_remove_breakpoint
block|,
comment|/* to_remove_breakpoint */
name|NULL
block|,
comment|/* to_terminal_init */
name|NULL
block|,
comment|/* to_terminal_inferior */
name|NULL
block|,
comment|/* to_terminal_ours_for_output */
name|NULL
block|,
comment|/* to_terminal_ours */
name|NULL
block|,
comment|/* to_terminal_info */
name|NULL
block|,
comment|/* to_kill */
name|es1800_load
block|,
comment|/* to_load */
name|NULL
block|,
comment|/* to_lookup_symbol */
name|es1800_create_inferior
block|,
comment|/* to_create_inferior */
name|NULL
block|,
comment|/* to_mourn_inferior */
literal|0
block|,
comment|/* to_can_run */
literal|0
block|,
comment|/* to_notice_signals */
literal|0
block|,
comment|/* to_thread_alive */
literal|0
block|,
comment|/* to_stop */
name|core_stratum
block|,
comment|/* to_stratum */
literal|0
block|,
comment|/* to_next */
literal|0
block|,
comment|/* to_has_all_memory */
literal|1
block|,
comment|/* to_has_memory */
literal|0
block|,
comment|/* to_has_stack */
literal|0
block|,
comment|/* to_has_registers */
literal|0
block|,
comment|/* to_has_execution */
name|NULL
block|,
comment|/* to_sections */
name|NULL
block|,
comment|/* to_sections_end */
name|OPS_MAGIC
comment|/* to_magic (always last) */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Define the target subroutine names  */
end_comment

begin_decl_stmt
name|struct
name|target_ops
name|es1800_child_ops
init|=
block|{
literal|"es1800_process"
block|,
comment|/* to_shortname */
comment|/* to_longname */
literal|"Remote serial target in ES1800-emulator protocol"
block|,
comment|/* to_doc */
literal|"Remote debugging on the es1800 emulator via a serial line.\n\ Specify the serial device it is connected to (e.g. /dev/ttya)."
block|,
name|es1800_child_open
block|,
comment|/* to_open */
name|NULL
block|,
comment|/* to_close */
name|es1800_attach
block|,
comment|/* to_attach */
name|es1800_child_detach
block|,
comment|/* to_detach */
name|es1800_resume
block|,
comment|/* to_resume */
name|es1800_wait
block|,
comment|/* to_wait */
name|es1800_fetch_register
block|,
comment|/* to_fetch_registers */
name|es1800_store_register
block|,
comment|/* to_store_registers */
name|es1800_prepare_to_store
block|,
comment|/* to_prepare_to_store */
name|es1800_xfer_inferior_memory
block|,
comment|/* to_xfer_memory */
name|es1800_files_info
block|,
comment|/* to_files_info */
name|es1800_insert_breakpoint
block|,
comment|/* to_insert_breakpoint */
name|es1800_remove_breakpoint
block|,
comment|/* to_remove_breakpoint */
name|NULL
block|,
comment|/* to_terminal_init */
name|NULL
block|,
comment|/* to_terminal_inferior */
name|NULL
block|,
comment|/* to_terminal_ours_for_output */
name|NULL
block|,
comment|/* to_terminal_ours */
name|NULL
block|,
comment|/* to_terminal_info */
name|es1800_kill
block|,
comment|/* to_kill */
name|es1800_load
block|,
comment|/* to_load */
name|NULL
block|,
comment|/* to_lookup_symbol */
name|es1800_create_inferior
block|,
comment|/* to_create_inferior */
name|es1800_mourn_inferior
block|,
comment|/* to_mourn_inferior */
literal|0
block|,
comment|/* to_can_run */
literal|0
block|,
comment|/* notice_signals */
literal|0
block|,
comment|/* to_thread_alive */
literal|0
block|,
comment|/* to_stop */
name|process_stratum
block|,
comment|/* to_stratum */
literal|0
block|,
comment|/* to_next */
literal|1
block|,
comment|/* to_has_all_memory */
literal|1
block|,
comment|/* to_has_memory */
literal|1
block|,
comment|/* to_has_stack */
literal|1
block|,
comment|/* to_has_registers */
literal|1
block|,
comment|/* to_has_execution */
name|NULL
block|,
comment|/* to_sections */
name|NULL
block|,
comment|/* to_sections_end */
name|OPS_MAGIC
comment|/* to_magic (always last) */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_es1800
parameter_list|()
block|{
name|add_target
argument_list|(
operator|&
name|es1800_ops
argument_list|)
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|es1800_child_ops
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PROVIDE_TRANSPARENT
name|add_com
argument_list|(
literal|"transparent"
argument_list|,
name|class_support
argument_list|,
name|es1800_transparent
argument_list|,
literal|"Start transparent communication with the ES 1800 emulator."
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PROVIDE_TRANSPARENT */
name|add_com
argument_list|(
literal|"init_break"
argument_list|,
name|class_support
argument_list|,
name|es1800_init_break
argument_list|,
literal|"Download break routine and initialize break facility on ES 1800"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

