begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Native dependent code for Mach 386's for GDB, the GNU debugger.    Copyright (C) 1986, 1987, 1989, 1991, 1992 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|"gdb_stat.h"
end_include

begin_include
include|#
directive|include
file|<sys/core.h>
end_include

begin_decl_stmt
specifier|static
name|void
name|fetch_core_registers
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
operator|,
name|int
operator|,
name|CORE_ADDR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|fetch_inferior_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
comment|/* Original value discarded */
block|{
name|struct
name|regs
name|inferior_registers
decl_stmt|;
name|struct
name|fp_state
name|inferior_fp_registers
decl_stmt|;
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
name|registers_fetched
argument_list|()
expr_stmt|;
name|ptrace
argument_list|(
name|PTRACE_GETREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|inferior_registers
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
name|PTRACE_GETFPREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|inferior_fp_registers
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|registers
argument_list|,
operator|&
name|inferior_registers
argument_list|,
sizeof|sizeof
name|inferior_registers
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
argument_list|)
index|]
argument_list|,
name|inferior_fp_registers
operator|.
name|f_st
argument_list|,
sizeof|sizeof
name|inferior_fp_registers
operator|.
name|f_st
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FPC_REGNUM
argument_list|)
index|]
argument_list|,
operator|&
name|inferior_fp_registers
operator|.
name|f_ctrl
argument_list|,
sizeof|sizeof
name|inferior_fp_registers
operator|-
sizeof|sizeof
name|inferior_fp_registers
operator|.
name|f_st
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store our register values back into the inferior.    If REGNO is -1, do this for all registers.    Otherwise, REGNO specifies which register (so we can save time).  */
end_comment

begin_function
name|void
name|store_inferior_registers
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
name|struct
name|regs
name|inferior_registers
decl_stmt|;
name|struct
name|fp_state
name|inferior_fp_registers
decl_stmt|;
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|inferior_registers
argument_list|,
name|registers
argument_list|,
literal|20
operator|*
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|inferior_fp_registers
operator|.
name|f_st
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
argument_list|)
index|]
argument_list|,
sizeof|sizeof
name|inferior_fp_registers
operator|.
name|f_st
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|inferior_fp_registers
operator|.
name|f_ctrl
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FPC_REGNUM
argument_list|)
index|]
argument_list|,
sizeof|sizeof
name|inferior_fp_registers
operator|-
sizeof|sizeof
name|inferior_fp_registers
operator|.
name|f_st
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PTRACE_FP_BUG
if|if
condition|(
name|regno
operator|==
name|FP_REGNUM
operator|||
name|regno
operator|==
operator|-
literal|1
condition|)
comment|/* Storing the frame pointer requires a gross hack, in which an        instruction that moves eax into ebp gets single-stepped.  */
block|{
name|int
name|stack
init|=
name|inferior_registers
operator|.
name|r_reg
index|[
name|SP_REGNUM
index|]
decl_stmt|;
name|int
name|stuff
init|=
name|ptrace
argument_list|(
name|PTRACE_PEEKDATA
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|stack
argument_list|)
decl_stmt|;
name|int
name|reg
init|=
name|inferior_registers
operator|.
name|r_reg
index|[
name|EAX
index|]
decl_stmt|;
name|inferior_registers
operator|.
name|r_reg
index|[
name|EAX
index|]
operator|=
name|inferior_registers
operator|.
name|r_reg
index|[
name|FP_REGNUM
index|]
expr_stmt|;
name|ptrace
argument_list|(
name|PTRACE_SETREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|inferior_registers
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
name|PTRACE_POKEDATA
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|stack
argument_list|,
literal|0xc589
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
name|PTRACE_SINGLESTEP
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|stack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wait
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
name|PTRACE_POKEDATA
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
name|stack
argument_list|,
name|stuff
argument_list|)
expr_stmt|;
name|inferior_registers
operator|.
name|r_reg
index|[
name|EAX
index|]
operator|=
name|reg
expr_stmt|;
block|}
endif|#
directive|endif
name|ptrace
argument_list|(
name|PTRACE_SETREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|inferior_registers
argument_list|)
expr_stmt|;
name|ptrace
argument_list|(
name|PTRACE_SETFPREGS
argument_list|,
name|inferior_pid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
operator|&
name|inferior_fp_registers
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Work with core files, for GDB. */
end_comment

begin_function
specifier|static
name|void
name|fetch_core_registers
parameter_list|(
name|core_reg_sect
parameter_list|,
name|core_reg_size
parameter_list|,
name|which
parameter_list|,
name|reg_addr
parameter_list|)
name|char
modifier|*
name|core_reg_sect
decl_stmt|;
name|unsigned
name|core_reg_size
decl_stmt|;
name|int
name|which
decl_stmt|;
name|CORE_ADDR
name|reg_addr
decl_stmt|;
comment|/* Unused in this version */
block|{
name|int
name|val
decl_stmt|;
specifier|extern
name|char
name|registers
index|[]
decl_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
name|memcpy
argument_list|(
name|registers
argument_list|,
name|core_reg_sect
argument_list|,
name|core_reg_size
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
ifdef|#
directive|ifdef
name|FP0_REGNUM
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FP0_REGNUM
argument_list|)
index|]
argument_list|,
name|core_reg_sect
argument_list|,
name|core_reg_size
argument_list|)
expr_stmt|;
comment|/* FIXME, probably bogus */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FPC_REGNUM
name|memcpy
argument_list|(
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|FPC_REGNUM
argument_list|)
index|]
argument_list|,
operator|&
name|corestr
operator|.
name|c_fpu
operator|.
name|f_fpstatus
operator|.
name|f_ctrl
argument_list|,
sizeof|sizeof
name|corestr
operator|.
name|c_fpu
operator|.
name|f_fpstatus
operator|-
sizeof|sizeof
name|corestr
operator|.
name|c_fpu
operator|.
name|f_fpstatus
operator|.
name|f_st
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Register that we are able to handle i386mach core file formats.    FIXME: is this really bfd_target_unknown_flavour? */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|core_fns
name|i386mach_core_fns
init|=
block|{
name|bfd_target_unknown_flavour
block|,
name|fetch_core_registers
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_core_i386mach
parameter_list|()
block|{
name|add_core_fns
argument_list|(
operator|&
name|i386mach_core_fns
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

