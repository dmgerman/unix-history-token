begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Pascal language support routines for GDB, the GNU debugger.    Copyright 2000, 2002, 2003, 2004 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This file is derived from c-lang.c */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"parser-defs.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"p-lang.h"
end_include

begin_include
include|#
directive|include
file|"valprint.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_function_decl
specifier|extern
name|void
name|_initialize_pascal_language
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Determines if type TYPE is a pascal string type.    Returns 1 if the type is a known pascal type    This function is used by p-valprint.c code to allow better string display.    If it is a pascal string type, then it also sets info needed    to get the length and the data of the string    length_pos, length_size and string_pos are given in bytes.    char_size gives the element size in bytes.    FIXME: if the position or the size of these fields    are not multiple of TARGET_CHAR_BIT then the results are wrong    but this does not happen for Free Pascal nor for GPC.  */
end_comment

begin_function
name|int
name|is_pascal_string_type
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
modifier|*
name|length_pos
parameter_list|,
name|int
modifier|*
name|length_size
parameter_list|,
name|int
modifier|*
name|string_pos
parameter_list|,
name|int
modifier|*
name|char_size
parameter_list|,
name|char
modifier|*
modifier|*
name|arrayname
parameter_list|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
condition|)
block|{
comment|/* Old Borland type pascal strings from Free Pascal Compiler.  */
comment|/* Two fields: length and st.  */
if|if
condition|(
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|==
literal|2
operator|&&
name|strcmp
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
index|[
literal|0
index|]
operator|.
name|name
argument_list|,
literal|"length"
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
index|[
literal|1
index|]
operator|.
name|name
argument_list|,
literal|"st"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|length_pos
condition|)
operator|*
name|length_pos
operator|=
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
operator|/
name|TARGET_CHAR_BIT
expr_stmt|;
if|if
condition|(
name|length_size
condition|)
operator|*
name|length_size
operator|=
name|TYPE_LENGTH
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|string_pos
condition|)
operator|*
name|string_pos
operator|=
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
operator|/
name|TARGET_CHAR_BIT
expr_stmt|;
if|if
condition|(
name|char_size
condition|)
operator|*
name|char_size
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|arrayname
condition|)
operator|*
name|arrayname
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
index|[
literal|1
index|]
operator|.
name|name
expr_stmt|;
return|return
literal|2
return|;
block|}
empty_stmt|;
comment|/* GNU pascal strings.  */
comment|/* Three fields: Capacity, length and schema$ or _p_schema.  */
if|if
condition|(
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|==
literal|3
operator|&&
name|strcmp
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
index|[
literal|0
index|]
operator|.
name|name
argument_list|,
literal|"Capacity"
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
index|[
literal|1
index|]
operator|.
name|name
argument_list|,
literal|"length"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|length_pos
condition|)
operator|*
name|length_pos
operator|=
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
operator|/
name|TARGET_CHAR_BIT
expr_stmt|;
if|if
condition|(
name|length_size
condition|)
operator|*
name|length_size
operator|=
name|TYPE_LENGTH
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|string_pos
condition|)
operator|*
name|string_pos
operator|=
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
literal|2
argument_list|)
operator|/
name|TARGET_CHAR_BIT
expr_stmt|;
comment|/* FIXME: how can I detect wide chars in GPC ?? */
if|if
condition|(
name|char_size
condition|)
operator|*
name|char_size
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|arrayname
condition|)
operator|*
name|arrayname
operator|=
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
index|[
literal|2
index|]
operator|.
name|name
expr_stmt|;
return|return
literal|3
return|;
block|}
empty_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function_decl
specifier|static
name|void
name|pascal_one_char
parameter_list|(
name|int
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Print the character C on STREAM as part of the contents of a literal    string.    In_quotes is reset to 0 if a char is written with #4 notation */
end_comment

begin_function
specifier|static
name|void
name|pascal_one_char
parameter_list|(
name|int
name|c
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
modifier|*
name|in_quotes
parameter_list|)
block|{
name|c
operator|&=
literal|0xFF
expr_stmt|;
comment|/* Avoid sign bit follies */
if|if
condition|(
operator|(
name|c
operator|==
literal|'\''
operator|)
operator|||
operator|(
name|PRINT_LITERAL_FORM
argument_list|(
name|c
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|*
name|in_quotes
operator|)
condition|)
name|fputs_filtered
argument_list|(
literal|"'"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
operator|*
name|in_quotes
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\''
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"''"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|in_quotes
condition|)
name|fputs_filtered
argument_list|(
literal|"'"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
operator|*
name|in_quotes
operator|=
literal|0
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"#%d"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function_decl
specifier|static
name|void
name|pascal_emit_char
parameter_list|(
name|int
name|c
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|quoter
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Print the character C on STREAM as part of the contents of a literal    string whose delimiter is QUOTER.  Note that that format for printing    characters and strings is language specific. */
end_comment

begin_function
specifier|static
name|void
name|pascal_emit_char
parameter_list|(
name|int
name|c
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|quoter
parameter_list|)
block|{
name|int
name|in_quotes
init|=
literal|0
decl_stmt|;
name|pascal_one_char
argument_list|(
name|c
argument_list|,
name|stream
argument_list|,
operator|&
name|in_quotes
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_quotes
condition|)
name|fputs_filtered
argument_list|(
literal|"'"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pascal_printchar
parameter_list|(
name|int
name|c
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|int
name|in_quotes
init|=
literal|0
decl_stmt|;
name|pascal_one_char
argument_list|(
name|c
argument_list|,
name|stream
argument_list|,
operator|&
name|in_quotes
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_quotes
condition|)
name|fputs_filtered
argument_list|(
literal|"'"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the character string STRING, printing at most LENGTH characters.    Printing stops early if the number hits print_max; repeat counts    are printed as appropriate.  Print ellipses at the end if we    had to stop before printing LENGTH characters, or if FORCE_ELLIPSES.  */
end_comment

begin_function
name|void
name|pascal_printstr
parameter_list|(
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|char
modifier|*
name|string
parameter_list|,
name|unsigned
name|int
name|length
parameter_list|,
name|int
name|width
parameter_list|,
name|int
name|force_ellipses
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|things_printed
init|=
literal|0
decl_stmt|;
name|int
name|in_quotes
init|=
literal|0
decl_stmt|;
name|int
name|need_comma
init|=
literal|0
decl_stmt|;
comment|/* If the string was not truncated due to `set print elements', and      the last byte of it is a null, we don't print that, in traditional C      style.  */
if|if
condition|(
operator|(
operator|!
name|force_ellipses
operator|)
operator|&&
name|length
operator|>
literal|0
operator|&&
name|string
index|[
name|length
operator|-
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|length
operator|--
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"''"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
operator|&&
name|things_printed
operator|<
name|print_max
condition|;
operator|++
name|i
control|)
block|{
comment|/* Position of the character we are examining          to see whether it is repeated.  */
name|unsigned
name|int
name|rep1
decl_stmt|;
comment|/* Number of repetitions we have detected so far.  */
name|unsigned
name|int
name|reps
decl_stmt|;
name|QUIT
expr_stmt|;
if|if
condition|(
name|need_comma
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|0
expr_stmt|;
block|}
name|rep1
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|reps
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|rep1
operator|<
name|length
operator|&&
name|string
index|[
name|rep1
index|]
operator|==
name|string
index|[
name|i
index|]
condition|)
block|{
operator|++
name|rep1
expr_stmt|;
operator|++
name|reps
expr_stmt|;
block|}
if|if
condition|(
name|reps
operator|>
name|repeat_count_threshold
condition|)
block|{
if|if
condition|(
name|in_quotes
condition|)
block|{
if|if
condition|(
name|inspect_it
condition|)
name|fputs_filtered
argument_list|(
literal|"\\', "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|"', "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|in_quotes
operator|=
literal|0
expr_stmt|;
block|}
name|pascal_printchar
argument_list|(
name|string
index|[
name|i
index|]
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<repeats %u times>"
argument_list|,
name|reps
argument_list|)
expr_stmt|;
name|i
operator|=
name|rep1
operator|-
literal|1
expr_stmt|;
name|things_printed
operator|+=
name|repeat_count_threshold
expr_stmt|;
name|need_comma
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|int
name|c
init|=
name|string
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|in_quotes
operator|)
operator|&&
operator|(
name|PRINT_LITERAL_FORM
argument_list|(
name|c
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|inspect_it
condition|)
name|fputs_filtered
argument_list|(
literal|"\\'"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|"'"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|in_quotes
operator|=
literal|1
expr_stmt|;
block|}
name|pascal_one_char
argument_list|(
name|c
argument_list|,
name|stream
argument_list|,
operator|&
name|in_quotes
argument_list|)
expr_stmt|;
operator|++
name|things_printed
expr_stmt|;
block|}
block|}
comment|/* Terminate the quotes if necessary.  */
if|if
condition|(
name|in_quotes
condition|)
block|{
if|if
condition|(
name|inspect_it
condition|)
name|fputs_filtered
argument_list|(
literal|"\\'"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|"'"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|force_ellipses
operator|||
name|i
operator|<
name|length
condition|)
name|fputs_filtered
argument_list|(
literal|"..."
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create a fundamental Pascal type using default reasonable for the current    target machine.     Some object/debugging file formats (DWARF version 1, COFF, etc) do not    define fundamental types such as "int" or "double".  Others (stabs or    DWARF version 2, etc) do define fundamental types.  For the formats which    don't provide fundamental types, gdb can create such types using this    function.     FIXME:  Some compilers distinguish explicitly signed integral types    (signed short, signed int, signed long) from "regular" integral types    (short, int, long) in the debugging information.  There is some dis-    agreement as to how useful this feature is.  In particular, gcc does    not support this.  Also, only some debugging formats allow the    distinction to be passed on to a debugger.  For now, we always just    use "short", "int", or "long" as the type name, for both the implicit    and explicitly signed types.  This also makes life easier for the    gdb test suite since we don't have to account for the differences    in output depending upon what the compiler and debugging format    support.  We will probably have to re-examine the issue when gdb    starts taking it's fundamental type information directly from the    debugging information supplied by the compiler.  fnf@cygnus.com */
end_comment

begin_comment
comment|/* Note there might be some discussion about the choosen correspondance    because it mainly reflects Free Pascal Compiler setup for now PM */
end_comment

begin_function
name|struct
name|type
modifier|*
name|pascal_create_fundamental_type
parameter_list|(
name|struct
name|objfile
modifier|*
name|objfile
parameter_list|,
name|int
name|typeid
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|typeid
condition|)
block|{
default|default:
comment|/* FIXME:  For now, if we are asked to produce a type not in this          language, create the equivalent of a C integer type with the          name "<?type?>".  When all the dust settles from the type          reconstruction work, this should probably become an error. */
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"<?type?>"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"internal error: no Pascal fundamental type %d"
argument_list|,
name|typeid
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_VOID
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_VOID
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"void"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_CHAR
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_CHAR
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"char"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SIGNED_CHAR
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"shortint"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_UNSIGNED_CHAR
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_CHAR_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"byte"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SHORT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_SHORT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"integer"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SIGNED_SHORT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_SHORT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"integer"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* FIXME-fnf */
break|break;
case|case
name|FT_UNSIGNED_SHORT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_SHORT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"word"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_INTEGER
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"longint"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SIGNED_INTEGER
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"longint"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* FIXME -fnf */
break|break;
case|case
name|FT_UNSIGNED_INTEGER
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_INT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"cardinal"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SIGNED_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* FIXME -fnf */
break|break;
case|case
name|FT_UNSIGNED_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_LONG_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"long long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_SIGNED_LONG_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"signed long long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_UNSIGNED_LONG_LONG
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_INT
argument_list|,
name|TARGET_LONG_LONG_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
name|TYPE_FLAG_UNSIGNED
argument_list|,
literal|"unsigned long long"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_FLOAT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_FLOAT_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"float"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_DBL_PREC_FLOAT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"double"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_EXT_PREC_FLOAT
case|:
name|type
operator|=
name|init_type
argument_list|(
name|TYPE_CODE_FLT
argument_list|,
name|TARGET_LONG_DOUBLE_BIT
operator|/
name|TARGET_CHAR_BIT
argument_list|,
literal|0
argument_list|,
literal|"extended"
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Table mapping opcodes into strings for printing operators    and precedences of the operators.  */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|op_print
name|pascal_op_print_tab
index|[]
init|=
block|{
block|{
literal|","
block|,
name|BINOP_COMMA
block|,
name|PREC_COMMA
block|,
literal|0
block|}
block|,
block|{
literal|":="
block|,
name|BINOP_ASSIGN
block|,
name|PREC_ASSIGN
block|,
literal|1
block|}
block|,
block|{
literal|"or"
block|,
name|BINOP_BITWISE_IOR
block|,
name|PREC_BITWISE_IOR
block|,
literal|0
block|}
block|,
block|{
literal|"xor"
block|,
name|BINOP_BITWISE_XOR
block|,
name|PREC_BITWISE_XOR
block|,
literal|0
block|}
block|,
block|{
literal|"and"
block|,
name|BINOP_BITWISE_AND
block|,
name|PREC_BITWISE_AND
block|,
literal|0
block|}
block|,
block|{
literal|"="
block|,
name|BINOP_EQUAL
block|,
name|PREC_EQUAL
block|,
literal|0
block|}
block|,
block|{
literal|"<>"
block|,
name|BINOP_NOTEQUAL
block|,
name|PREC_EQUAL
block|,
literal|0
block|}
block|,
block|{
literal|"<="
block|,
name|BINOP_LEQ
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|">="
block|,
name|BINOP_GEQ
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|">"
block|,
name|BINOP_GTR
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|"<"
block|,
name|BINOP_LESS
block|,
name|PREC_ORDER
block|,
literal|0
block|}
block|,
block|{
literal|"shr"
block|,
name|BINOP_RSH
block|,
name|PREC_SHIFT
block|,
literal|0
block|}
block|,
block|{
literal|"shl"
block|,
name|BINOP_LSH
block|,
name|PREC_SHIFT
block|,
literal|0
block|}
block|,
block|{
literal|"+"
block|,
name|BINOP_ADD
block|,
name|PREC_ADD
block|,
literal|0
block|}
block|,
block|{
literal|"-"
block|,
name|BINOP_SUB
block|,
name|PREC_ADD
block|,
literal|0
block|}
block|,
block|{
literal|"*"
block|,
name|BINOP_MUL
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"/"
block|,
name|BINOP_DIV
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"div"
block|,
name|BINOP_INTDIV
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"mod"
block|,
name|BINOP_REM
block|,
name|PREC_MUL
block|,
literal|0
block|}
block|,
block|{
literal|"@"
block|,
name|BINOP_REPEAT
block|,
name|PREC_REPEAT
block|,
literal|0
block|}
block|,
block|{
literal|"-"
block|,
name|UNOP_NEG
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"not"
block|,
name|UNOP_LOGICAL_NOT
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"^"
block|,
name|UNOP_IND
block|,
name|PREC_SUFFIX
block|,
literal|1
block|}
block|,
block|{
literal|"@"
block|,
name|UNOP_ADDR
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
literal|"sizeof"
block|,
name|UNOP_SIZEOF
block|,
name|PREC_PREFIX
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function_decl
name|struct
name|type
modifier|*
modifier|*
function_decl|const (
name|pascal_builtin_types
function_decl|[]
end_function_decl

begin_expr_stmt
unit|)
operator|=
block|{
operator|&
name|builtin_type_int
block|,
operator|&
name|builtin_type_long
block|,
operator|&
name|builtin_type_short
block|,
operator|&
name|builtin_type_char
block|,
operator|&
name|builtin_type_float
block|,
operator|&
name|builtin_type_double
block|,
operator|&
name|builtin_type_void
block|,
operator|&
name|builtin_type_long_long
block|,
operator|&
name|builtin_type_signed_char
block|,
operator|&
name|builtin_type_unsigned_char
block|,
operator|&
name|builtin_type_unsigned_short
block|,
operator|&
name|builtin_type_unsigned_int
block|,
operator|&
name|builtin_type_unsigned_long
block|,
operator|&
name|builtin_type_unsigned_long_long
block|,
operator|&
name|builtin_type_long_double
block|,
operator|&
name|builtin_type_complex
block|,
operator|&
name|builtin_type_double_complex
block|,
literal|0
block|}
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|const
name|struct
name|language_defn
name|pascal_language_defn
init|=
block|{
literal|"pascal"
block|,
comment|/* Language name */
name|language_pascal
block|,
name|pascal_builtin_types
block|,
name|range_check_on
block|,
name|type_check_on
block|,
name|case_sensitive_on
block|,
operator|&
name|exp_descriptor_standard
block|,
name|pascal_parse
block|,
name|pascal_error
block|,
name|pascal_printchar
block|,
comment|/* Print a character constant */
name|pascal_printstr
block|,
comment|/* Function to print string constant */
name|pascal_emit_char
block|,
comment|/* Print a single char */
name|pascal_create_fundamental_type
block|,
comment|/* Create fundamental type in this language */
name|pascal_print_type
block|,
comment|/* Print a type using appropriate syntax */
name|pascal_val_print
block|,
comment|/* Print a value using appropriate syntax */
name|pascal_value_print
block|,
comment|/* Print a top-level value */
name|NULL
block|,
comment|/* Language specific skip_trampoline */
name|value_of_this
block|,
comment|/* value_of_this */
name|basic_lookup_symbol_nonlocal
block|,
comment|/* lookup_symbol_nonlocal */
name|basic_lookup_transparent_type
block|,
comment|/* lookup_transparent_type */
name|NULL
block|,
comment|/* Language specific symbol demangler */
block|{
literal|""
block|,
literal|"%"
block|,
literal|"b"
block|,
literal|""
block|}
block|,
comment|/* Binary format info */
block|{
literal|"0%lo"
block|,
literal|"0"
block|,
literal|"o"
block|,
literal|""
block|}
block|,
comment|/* Octal format info */
block|{
literal|"%ld"
block|,
literal|""
block|,
literal|"d"
block|,
literal|""
block|}
block|,
comment|/* Decimal format info */
block|{
literal|"$%lx"
block|,
literal|"$"
block|,
literal|"x"
block|,
literal|""
block|}
block|,
comment|/* Hex format info */
name|pascal_op_print_tab
block|,
comment|/* expression operators for printing */
literal|1
block|,
comment|/* c-style arrays */
literal|0
block|,
comment|/* String lower bound */
operator|&
name|builtin_type_char
block|,
comment|/* Type of string elements */
name|default_word_break_characters
block|,
name|LANG_MAGIC
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_pascal_language
parameter_list|(
name|void
parameter_list|)
block|{
name|add_language
argument_list|(
operator|&
name|pascal_language_defn
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

