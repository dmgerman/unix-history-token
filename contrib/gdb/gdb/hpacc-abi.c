begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Abstraction of HP aCC ABI.    Contributed by Daniel Berlin<dberlin@redhat.com>    Most of the real code is from HP, i've just fiddled it to fit in    the C++ ABI abstraction framework.     Copyright 2001 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or    modify    it under the terms of the GNU General Public License as published    by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"gdb_regex.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"cp-abi.h"
end_include

begin_decl_stmt
name|struct
name|cp_abi_ops
name|hpacc_abi_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* It appears the is_*_name stuff is never used when we try the hpACC  * ABI. As such, I have no clue what the real answers are. Shouldn't  * have any more effect than it does now.  */
end_comment

begin_decl_stmt
specifier|static
name|regex_t
name|constructor_pattern
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|regex_t
name|destructor_pattern
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|regex_t
name|operator_pattern
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|enum
name|dtor_kinds
name|hpacc_is_destructor_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|regexec
argument_list|(
operator|&
name|destructor_pattern
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return
name|complete_object_dtor
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|ctor_kinds
name|hpacc_is_constructor_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|regexec
argument_list|(
operator|&
name|constructor_pattern
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
return|return
name|complete_object_ctor
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hpacc_is_operator_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|regexec
argument_list|(
operator|&
name|operator_pattern
argument_list|,
name|name
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hpacc_is_vtable_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"This will never match anything, please fill it in"
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return a virtual function as a value.    ARG1 is the object which provides the virtual function    table pointer.  *ARG1P is side-effected in calling this function.    F is the list of member functions which contains the desired virtual    function.    J is an index into F which provides the desired virtual function.     TYPE is the type in which F is located.  */
end_comment

begin_function
specifier|static
name|struct
name|value
modifier|*
name|hpacc_virtual_fn_field
parameter_list|(
name|struct
name|value
modifier|*
modifier|*
name|arg1p
parameter_list|,
name|struct
name|fn_field
modifier|*
name|f
parameter_list|,
name|int
name|j
parameter_list|,
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|arg1
init|=
operator|*
name|arg1p
decl_stmt|;
name|struct
name|type
modifier|*
name|type1
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg1
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Deal with HP/Taligent runtime model for virtual functions */
name|struct
name|value
modifier|*
name|vp
decl_stmt|;
name|struct
name|value
modifier|*
name|argp
decl_stmt|;
comment|/* arg1 cast to base */
name|CORE_ADDR
name|coreptr
decl_stmt|;
comment|/* pointer to target address */
name|int
name|class_index
decl_stmt|;
comment|/* which class segment pointer to use */
name|struct
name|type
modifier|*
name|ftype
init|=
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
decl_stmt|;
comment|/* method type */
name|argp
operator|=
name|value_cast
argument_list|(
name|type
argument_list|,
operator|*
name|arg1p
argument_list|)
expr_stmt|;
if|if
condition|(
name|VALUE_ADDRESS
argument_list|(
name|argp
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Address of object is null; object may not have been created."
argument_list|)
expr_stmt|;
comment|/* pai: FIXME -- 32x64 possible problem? */
comment|/* First word (4 bytes) in object layout is the vtable pointer */
name|coreptr
operator|=
operator|*
operator|(
name|CORE_ADDR
operator|*
operator|)
operator|(
name|VALUE_CONTENTS
argument_list|(
name|argp
argument_list|)
operator|)
expr_stmt|;
comment|/* pai: (temp)  */
comment|/* + offset + VALUE_EMBEDDED_OFFSET (argp)); */
if|if
condition|(
operator|!
name|coreptr
condition|)
name|error
argument_list|(
literal|"Virtual table pointer is null for object; object may not have been created."
argument_list|)
expr_stmt|;
comment|/* pai/1997-05-09    * FIXME: The code here currently handles only    * the non-RRBC case of the Taligent/HP runtime spec; when RRBC    * is introduced, the condition for the "if" below will have to    * be changed to be a test for the RRBC case.  */
if|if
condition|(
literal|1
condition|)
block|{
comment|/* Non-RRBC case; the virtual function pointers are stored at fixed        * offsets in the virtual table. */
comment|/* Retrieve the offset in the virtual table from the debug        * info.  The offset of the vfunc's entry is in words from        * the beginning of the vtable; but first we have to adjust        * by HP_ACC_VFUNC_START to account for other entries */
comment|/* pai: FIXME: 32x64 problem here, a word may be 8 bytes in        * which case the multiplier should be 8 and values should be long */
name|vp
operator|=
name|value_at
argument_list|(
name|builtin_type_int
argument_list|,
name|coreptr
operator|+
literal|4
operator|*
operator|(
name|TYPE_FN_FIELD_VOFFSET
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
operator|+
name|HP_ACC_VFUNC_START
operator|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|coreptr
operator|=
operator|*
operator|(
name|CORE_ADDR
operator|*
operator|)
operator|(
name|VALUE_CONTENTS
argument_list|(
name|vp
argument_list|)
operator|)
expr_stmt|;
comment|/* coreptr now contains the address of the virtual function */
comment|/* (Actually, it contains the pointer to the plabel for the function. */
block|}
else|else
block|{
comment|/* RRBC case; the virtual function pointers are found by double        * indirection through the class segment tables. */
comment|/* Choose class segment depending on type we were passed */
name|class_index
operator|=
name|class_index_in_primary_list
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* Find class segment pointer.  These are in the vtable slots after        * some other entries, so adjust by HP_ACC_VFUNC_START for that. */
comment|/* pai: FIXME 32x64 problem here, if words are 8 bytes long        * the multiplier below has to be 8 and value should be long. */
name|vp
operator|=
name|value_at
argument_list|(
name|builtin_type_int
argument_list|,
name|coreptr
operator|+
literal|4
operator|*
operator|(
name|HP_ACC_VFUNC_START
operator|+
name|class_index
operator|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Indirect once more, offset by function index */
comment|/* pai: FIXME 32x64 problem here, again multiplier could be 8 and value long */
name|coreptr
operator|=
operator|*
operator|(
name|CORE_ADDR
operator|*
operator|)
operator|(
name|VALUE_CONTENTS
argument_list|(
name|vp
argument_list|)
operator|+
literal|4
operator|*
name|TYPE_FN_FIELD_VOFFSET
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
operator|)
expr_stmt|;
name|vp
operator|=
name|value_at
argument_list|(
name|builtin_type_int
argument_list|,
name|coreptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|coreptr
operator|=
operator|*
operator|(
name|CORE_ADDR
operator|*
operator|)
operator|(
name|VALUE_CONTENTS
argument_list|(
name|vp
argument_list|)
operator|)
expr_stmt|;
comment|/* coreptr now contains the address of the virtual function */
comment|/* (Actually, it contains the pointer to the plabel for the function.) */
block|}
if|if
condition|(
operator|!
name|coreptr
condition|)
name|error
argument_list|(
literal|"Address of virtual function is null; error in virtual table?"
argument_list|)
expr_stmt|;
comment|/* Wrap this addr in a value and return pointer */
name|vp
operator|=
name|allocate_value
argument_list|(
name|ftype
argument_list|)
expr_stmt|;
name|VALUE_TYPE
argument_list|(
name|vp
argument_list|)
operator|=
name|ftype
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|vp
argument_list|)
operator|=
name|coreptr
expr_stmt|;
comment|/* pai: (temp) do we need the value_ind stuff in value_fn_field? */
return|return
name|vp
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|type
modifier|*
name|hpacc_value_rtti_type
parameter_list|(
name|struct
name|value
modifier|*
name|v
parameter_list|,
name|int
modifier|*
name|full
parameter_list|,
name|int
modifier|*
name|top
parameter_list|,
name|int
modifier|*
name|using_enc
parameter_list|)
block|{
name|struct
name|type
modifier|*
name|known_type
decl_stmt|;
name|struct
name|type
modifier|*
name|rtti_type
decl_stmt|;
name|CORE_ADDR
name|coreptr
decl_stmt|;
name|struct
name|value
modifier|*
name|vp
decl_stmt|;
name|int
name|using_enclosing
init|=
literal|0
decl_stmt|;
name|long
name|top_offset
init|=
literal|0
decl_stmt|;
name|char
name|rtti_type_name
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|full
condition|)
operator|*
name|full
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|top
condition|)
operator|*
name|top
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|using_enc
condition|)
operator|*
name|using_enc
operator|=
literal|0
expr_stmt|;
comment|/* Get declared type */
name|known_type
operator|=
name|VALUE_TYPE
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|known_type
argument_list|)
expr_stmt|;
comment|/* RTTI works only or class objects */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|known_type
argument_list|)
operator|!=
name|TYPE_CODE_CLASS
condition|)
return|return
name|NULL
return|;
comment|/* If neither the declared type nor the enclosing type of the    * value structure has a HP ANSI C++ style virtual table,    * we can't do anything. */
if|if
condition|(
operator|!
name|TYPE_HAS_VTABLE
argument_list|(
name|known_type
argument_list|)
condition|)
block|{
name|known_type
operator|=
name|VALUE_ENCLOSING_TYPE
argument_list|(
name|v
argument_list|)
expr_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|known_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TYPE_CODE
argument_list|(
name|known_type
argument_list|)
operator|!=
name|TYPE_CODE_CLASS
operator|)
operator|||
operator|!
name|TYPE_HAS_VTABLE
argument_list|(
name|known_type
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* No RTTI, or not HP-compiled types */
name|CHECK_TYPEDEF
argument_list|(
name|known_type
argument_list|)
expr_stmt|;
name|using_enclosing
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|using_enclosing
operator|&&
name|using_enc
condition|)
operator|*
name|using_enc
operator|=
literal|1
expr_stmt|;
comment|/* First get the virtual table address */
name|coreptr
operator|=
operator|*
operator|(
name|CORE_ADDR
operator|*
operator|)
operator|(
operator|(
name|VALUE_CONTENTS_ALL
argument_list|(
name|v
argument_list|)
operator|)
operator|+
name|VALUE_OFFSET
argument_list|(
name|v
argument_list|)
operator|+
operator|(
name|using_enclosing
condition|?
literal|0
else|:
name|VALUE_EMBEDDED_OFFSET
argument_list|(
name|v
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|coreptr
operator|==
literal|0
condition|)
comment|/* return silently -- maybe called on gdb-generated value */
return|return
name|NULL
return|;
comment|/* Fetch the top offset of the object */
comment|/* FIXME possible 32x64 problem with pointer size& arithmetic */
name|vp
operator|=
name|value_at
argument_list|(
name|builtin_type_int
argument_list|,
name|coreptr
operator|+
literal|4
operator|*
name|HP_ACC_TOP_OFFSET_OFFSET
argument_list|,
name|VALUE_BFD_SECTION
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|top_offset
operator|=
name|value_as_long
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|top
condition|)
operator|*
name|top
operator|=
name|top_offset
expr_stmt|;
comment|/* Fetch the typeinfo pointer */
comment|/* FIXME possible 32x64 problem with pointer size& arithmetic */
name|vp
operator|=
name|value_at
argument_list|(
name|builtin_type_int
argument_list|,
name|coreptr
operator|+
literal|4
operator|*
name|HP_ACC_TYPEINFO_OFFSET
argument_list|,
name|VALUE_BFD_SECTION
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Indirect through the typeinfo pointer and retrieve the pointer    * to the string name */
name|coreptr
operator|=
operator|*
operator|(
name|CORE_ADDR
operator|*
operator|)
operator|(
name|VALUE_CONTENTS
argument_list|(
name|vp
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|coreptr
condition|)
name|error
argument_list|(
literal|"Retrieved null typeinfo pointer in trying to determine "
literal|"run-time type"
argument_list|)
expr_stmt|;
comment|/* 4 -> offset of name field */
name|vp
operator|=
name|value_at
argument_list|(
name|builtin_type_int
argument_list|,
name|coreptr
operator|+
literal|4
argument_list|,
name|VALUE_BFD_SECTION
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
comment|/* FIXME possible 32x64 problem */
name|coreptr
operator|=
operator|*
operator|(
name|CORE_ADDR
operator|*
operator|)
operator|(
name|VALUE_CONTENTS
argument_list|(
name|vp
argument_list|)
operator|)
expr_stmt|;
name|read_memory_string
argument_list|(
name|coreptr
argument_list|,
name|rtti_type_name
argument_list|,
literal|256
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|rtti_type_name
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Retrieved null type name from typeinfo"
argument_list|)
expr_stmt|;
comment|/* search for type */
name|rtti_type
operator|=
name|lookup_typename
argument_list|(
name|rtti_type_name
argument_list|,
operator|(
expr|struct
name|block
operator|*
operator|)
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rtti_type
condition|)
name|error
argument_list|(
literal|"Could not find run-time type: invalid type name %s in typeinfo??"
argument_list|,
name|rtti_type_name
argument_list|)
expr_stmt|;
name|CHECK_TYPEDEF
argument_list|(
name|rtti_type
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf ("RTTI type name %s, tag %s, full? %d\n", TYPE_NAME (rtti_type),           TYPE_TAG_NAME (rtti_type), full ? *full : -1);
endif|#
directive|endif
comment|/* Check whether we have the entire object */
if|if
condition|(
name|full
comment|/* Non-null pointer passed */
operator|&&
comment|/* Either we checked on the whole object in hand and found the          top offset to be zero */
operator|(
operator|(
operator|(
name|top_offset
operator|==
literal|0
operator|)
operator|&&
name|using_enclosing
operator|&&
name|TYPE_LENGTH
argument_list|(
name|known_type
argument_list|)
operator|==
name|TYPE_LENGTH
argument_list|(
name|rtti_type
argument_list|)
operator|)
operator|||
comment|/* Or we checked on the embedded object and top offset was the           same as the embedded offset */
operator|(
operator|(
name|top_offset
operator|==
name|VALUE_EMBEDDED_OFFSET
argument_list|(
name|v
argument_list|)
operator|)
operator|&&
operator|!
name|using_enclosing
operator|&&
name|TYPE_LENGTH
argument_list|(
name|VALUE_ENCLOSING_TYPE
argument_list|(
name|v
argument_list|)
argument_list|)
operator|==
name|TYPE_LENGTH
argument_list|(
name|rtti_type
argument_list|)
operator|)
operator|)
condition|)
operator|*
name|full
operator|=
literal|1
expr_stmt|;
return|return
name|rtti_type
return|;
block|}
end_function

begin_function_decl
specifier|extern
name|int
name|gnuv2_baseclass_offset
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|int
name|index
parameter_list|,
name|char
modifier|*
name|valaddr
parameter_list|,
name|CORE_ADDR
name|address
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|init_hpacc_ops
parameter_list|(
name|void
parameter_list|)
block|{
name|hpacc_abi_ops
operator|.
name|shortname
operator|=
literal|"hpaCC"
expr_stmt|;
name|hpacc_abi_ops
operator|.
name|longname
operator|=
literal|"HP aCC ABI"
expr_stmt|;
name|hpacc_abi_ops
operator|.
name|doc
operator|=
literal|"HP aCC ABI"
expr_stmt|;
name|hpacc_abi_ops
operator|.
name|is_destructor_name
operator|=
name|hpacc_is_destructor_name
expr_stmt|;
name|hpacc_abi_ops
operator|.
name|is_constructor_name
operator|=
name|hpacc_is_constructor_name
expr_stmt|;
name|hpacc_abi_ops
operator|.
name|is_vtable_name
operator|=
name|hpacc_is_vtable_name
expr_stmt|;
name|hpacc_abi_ops
operator|.
name|is_operator_name
operator|=
name|hpacc_is_operator_name
expr_stmt|;
name|hpacc_abi_ops
operator|.
name|virtual_fn_field
operator|=
name|hpacc_virtual_fn_field
expr_stmt|;
name|hpacc_abi_ops
operator|.
name|rtti_type
operator|=
name|hpacc_value_rtti_type
expr_stmt|;
comment|/* It seems that this function is specific to GNU G++< 3.0.      However, it is called for data members even in the HP      case (although not for member functions).      FIXME: Is that correct?  */
name|hpacc_abi_ops
operator|.
name|baseclass_offset
operator|=
name|gnuv2_baseclass_offset
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|initialize_file_ftype
name|_initialize_hpacc_abi
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -Wmissing-prototypes */
end_comment

begin_function
name|void
name|_initialize_hpacc_abi
parameter_list|(
name|void
parameter_list|)
block|{
name|init_hpacc_ops
argument_list|()
expr_stmt|;
name|regcomp
argument_list|(
operator|&
name|constructor_pattern
argument_list|,
literal|"^This will never match anything, please fill it in$"
argument_list|,
name|REG_NOSUB
argument_list|)
expr_stmt|;
name|regcomp
argument_list|(
operator|&
name|destructor_pattern
argument_list|,
literal|"^This will never match anything, please fill it in$"
argument_list|,
name|REG_NOSUB
argument_list|)
expr_stmt|;
name|regcomp
argument_list|(
operator|&
name|operator_pattern
argument_list|,
literal|"^This will never match anything, please fill it in$"
argument_list|,
name|REG_NOSUB
argument_list|)
expr_stmt|;
name|register_cp_abi
argument_list|(
operator|&
name|hpacc_abi_ops
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

