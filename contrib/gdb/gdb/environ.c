begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* environ.c -- library for manipulating environments for GNU.    Copyright (C) 1986, 1989 Free Software Foundation, Inc.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"environ.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Return a new environment object.  */
end_comment

begin_function
name|struct
name|environ
modifier|*
name|make_environ
parameter_list|()
block|{
specifier|register
name|struct
name|environ
modifier|*
name|e
decl_stmt|;
name|e
operator|=
operator|(
expr|struct
name|environ
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|environ
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|allocated
operator|=
literal|10
expr_stmt|;
name|e
operator|->
name|vector
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
name|e
operator|->
name|allocated
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|vector
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|e
return|;
block|}
end_function

begin_comment
comment|/* Free an environment and all the strings in it.  */
end_comment

begin_function
name|void
name|free_environ
parameter_list|(
name|e
parameter_list|)
specifier|register
name|struct
name|environ
modifier|*
name|e
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|vector
init|=
name|e
operator|->
name|vector
decl_stmt|;
while|while
condition|(
operator|*
name|vector
condition|)
name|free
argument_list|(
operator|*
name|vector
operator|++
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy the environment given to this process into E.    Also copies all the strings in it, so we can be sure    that all strings in these environments are safe to free.  */
end_comment

begin_function
name|void
name|init_environ
parameter_list|(
name|e
parameter_list|)
specifier|register
name|struct
name|environ
modifier|*
name|e
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|environ
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|environ
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
comment|/*EMPTY*/
empty_stmt|;
if|if
condition|(
name|e
operator|->
name|allocated
operator|<
name|i
condition|)
block|{
name|e
operator|->
name|allocated
operator|=
name|max
argument_list|(
name|i
argument_list|,
name|e
operator|->
name|allocated
operator|+
literal|10
argument_list|)
expr_stmt|;
name|e
operator|->
name|vector
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|e
operator|->
name|vector
argument_list|,
operator|(
name|e
operator|->
name|allocated
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|e
operator|->
name|vector
argument_list|,
name|environ
argument_list|,
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
block|{
specifier|register
name|int
name|len
init|=
name|strlen
argument_list|(
name|e
operator|->
name|vector
index|[
name|i
index|]
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|new
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|new
argument_list|,
name|e
operator|->
name|vector
index|[
name|i
index|]
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|e
operator|->
name|vector
index|[
name|i
index|]
operator|=
name|new
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the vector of environment E.    This is used to get something to pass to execve.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|environ_vector
parameter_list|(
name|e
parameter_list|)
name|struct
name|environ
modifier|*
name|e
decl_stmt|;
block|{
return|return
name|e
operator|->
name|vector
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the value in environment E of variable VAR.  */
end_comment

begin_function
name|char
modifier|*
name|get_in_environ
parameter_list|(
name|e
parameter_list|,
name|var
parameter_list|)
specifier|const
name|struct
name|environ
modifier|*
name|e
decl_stmt|;
specifier|const
name|char
modifier|*
name|var
decl_stmt|;
block|{
specifier|register
name|int
name|len
init|=
name|strlen
argument_list|(
name|var
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|vector
init|=
name|e
operator|->
name|vector
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
for|for
control|(
init|;
operator|(
name|s
operator|=
operator|*
name|vector
operator|)
operator|!=
name|NULL
condition|;
name|vector
operator|++
control|)
if|if
condition|(
name|STREQN
argument_list|(
name|s
argument_list|,
name|var
argument_list|,
name|len
argument_list|)
operator|&&
name|s
index|[
name|len
index|]
operator|==
literal|'='
condition|)
return|return
operator|&
name|s
index|[
name|len
operator|+
literal|1
index|]
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Store the value in E of VAR as VALUE.  */
end_comment

begin_function
name|void
name|set_in_environ
parameter_list|(
name|e
parameter_list|,
name|var
parameter_list|,
name|value
parameter_list|)
name|struct
name|environ
modifier|*
name|e
decl_stmt|;
specifier|const
name|char
modifier|*
name|var
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|len
init|=
name|strlen
argument_list|(
name|var
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|vector
init|=
name|e
operator|->
name|vector
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|s
operator|=
name|vector
index|[
name|i
index|]
operator|)
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|STREQN
argument_list|(
name|s
argument_list|,
name|var
argument_list|,
name|len
argument_list|)
operator|&&
name|s
index|[
name|len
index|]
operator|==
literal|'='
condition|)
break|break;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|e
operator|->
name|allocated
condition|)
block|{
name|e
operator|->
name|allocated
operator|+=
literal|10
expr_stmt|;
name|vector
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|vector
argument_list|,
operator|(
name|e
operator|->
name|allocated
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|e
operator|->
name|vector
operator|=
name|vector
expr_stmt|;
block|}
name|vector
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len
operator|+
name|strlen
argument_list|(
name|value
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|var
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|s
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|s
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|vector
index|[
name|i
index|]
operator|=
name|s
expr_stmt|;
comment|/* This used to handle setting the PATH and GNUTARGET variables      specially.  The latter has been replaced by "set gnutarget"      (which has worked since GDB 4.11).  The former affects searching      the PATH to find SHELL, and searching the PATH to find the      argument of "symbol-file" or "exec-file".  Maybe we should have      some kind of "set exec-path" for that.  But in any event, having      "set env" affect anything besides the inferior is a bad idea.      What if we want to change the environment we pass to the program      without afecting GDB's behavior?  */
return|return;
block|}
end_function

begin_comment
comment|/* Remove the setting for variable VAR from environment E.  */
end_comment

begin_function
name|void
name|unset_in_environ
parameter_list|(
name|e
parameter_list|,
name|var
parameter_list|)
name|struct
name|environ
modifier|*
name|e
decl_stmt|;
name|char
modifier|*
name|var
decl_stmt|;
block|{
specifier|register
name|int
name|len
init|=
name|strlen
argument_list|(
name|var
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|vector
init|=
name|e
operator|->
name|vector
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
for|for
control|(
init|;
operator|(
name|s
operator|=
operator|*
name|vector
operator|)
operator|!=
name|NULL
condition|;
name|vector
operator|++
control|)
block|{
if|if
condition|(
name|STREQN
argument_list|(
name|s
argument_list|,
name|var
argument_list|,
name|len
argument_list|)
operator|&&
name|s
index|[
name|len
index|]
operator|==
literal|'='
condition|)
block|{
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Walk through the vector, shuffling args down by one, including 	     the NULL terminator.  Can't use memcpy() here since the regions 	     overlap, and memmove() might not be available. */
while|while
condition|(
operator|(
name|vector
index|[
literal|0
index|]
operator|=
name|vector
index|[
literal|1
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
name|vector
operator|++
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_function

end_unit

