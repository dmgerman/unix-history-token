begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* DWARF debugging format support for GDB.    Copyright (C) 1991, 1992, 1993, 1994, 1995, 1996, 1998    Free Software Foundation, Inc.    Written by Fred Fish at Cygnus Support.  Portions based on dbxread.c,    mipsread.c, coffread.c, and dwarfread.c from a Data General SVR4 gdb port.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/*  FIXME: Do we need to generate dependencies in partial symtabs? (Perhaps we don't need to).  FIXME: Resolve minor differences between what information we put in the partial symbol table and what dbxread puts in.  For example, we don't yet put enum constants there.  And dbxread seems to invent a lot of typedefs we never see.  Use the new printpsym command to see the partial symbol table contents.  FIXME: Figure out a better way to tell gdb about the name of the function contain the user's entry point (I.E. main())  FIXME: See other FIXME's and "ifdef 0" scattered throughout the code for other things to work on, if you get bored. :-)  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"elf/dwarf.h"
end_include

begin_include
include|#
directive|include
file|"buildsym.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_comment
comment|/* Needed for enum exp_opcode in language.h, sigh... */
end_comment

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"complaints.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_comment
comment|/* Some macros to provide DIE info for complaints. */
end_comment

begin_define
define|#
directive|define
name|DIE_ID
value|(curdie!=NULL ? curdie->die_ref : 0)
end_define

begin_define
define|#
directive|define
name|DIE_NAME
value|(curdie!=NULL&& curdie->at_name!=NULL) ? curdie->at_name : ""
end_define

begin_comment
comment|/* Complaints that can be issued during DWARF debug info reading. */
end_comment

begin_decl_stmt
name|struct
name|complaint
name|no_bfd_get_N
init|=
block|{
literal|"DIE @ 0x%x \"%s\", no bfd support for %d byte data object"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|malformed_die
init|=
block|{
literal|"DIE @ 0x%x \"%s\", malformed DIE, bad length (%d bytes)"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|bad_die_ref
init|=
block|{
literal|"DIE @ 0x%x \"%s\", reference to DIE (0x%x) outside compilation unit"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|unknown_attribute_form
init|=
block|{
literal|"DIE @ 0x%x \"%s\", unknown attribute form (0x%x)"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|unknown_attribute_length
init|=
block|{
literal|"DIE @ 0x%x \"%s\", unknown attribute length, skipped remaining attributes"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|unexpected_fund_type
init|=
block|{
literal|"DIE @ 0x%x \"%s\", unexpected fundamental type 0x%x"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|unknown_type_modifier
init|=
block|{
literal|"DIE @ 0x%x \"%s\", unknown type modifier %u"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|volatile_ignored
init|=
block|{
literal|"DIE @ 0x%x \"%s\", type modifier 'volatile' ignored"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|const_ignored
init|=
block|{
literal|"DIE @ 0x%x \"%s\", type modifier 'const' ignored"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|botched_modified_type
init|=
block|{
literal|"DIE @ 0x%x \"%s\", botched modified type decoding (mtype 0x%x)"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|op_deref2
init|=
block|{
literal|"DIE @ 0x%x \"%s\", OP_DEREF2 address 0x%x not handled"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|op_deref4
init|=
block|{
literal|"DIE @ 0x%x \"%s\", OP_DEREF4 address 0x%x not handled"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|basereg_not_handled
init|=
block|{
literal|"DIE @ 0x%x \"%s\", BASEREG %d not handled"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|dup_user_type_allocation
init|=
block|{
literal|"DIE @ 0x%x \"%s\", internal error: duplicate user type allocation"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|dup_user_type_definition
init|=
block|{
literal|"DIE @ 0x%x \"%s\", internal error: duplicate user type definition"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|missing_tag
init|=
block|{
literal|"DIE @ 0x%x \"%s\", missing class, structure, or union tag"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|bad_array_element_type
init|=
block|{
literal|"DIE @ 0x%x \"%s\", bad array element type attribute 0x%x"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|subscript_data_items
init|=
block|{
literal|"DIE @ 0x%x \"%s\", can't decode subscript data items"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|unhandled_array_subscript_format
init|=
block|{
literal|"DIE @ 0x%x \"%s\", array subscript format 0x%x not handled yet"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|unknown_array_subscript_format
init|=
block|{
literal|"DIE @ 0x%x \"%s\", unknown array subscript format %x"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|not_row_major
init|=
block|{
literal|"DIE @ 0x%x \"%s\", array not row major; not handled correctly"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|complaint
name|missing_at_name
init|=
block|{
literal|"DIE @ 0x%x, AT_name tag missing"
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|unsigned
name|int
name|DIE_REF
typedef|;
end_typedef

begin_comment
comment|/* Reference to a DIE */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|GCC_PRODUCER
end_ifndef

begin_define
define|#
directive|define
name|GCC_PRODUCER
value|"GNU C "
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|GPLUS_PRODUCER
end_ifndef

begin_define
define|#
directive|define
name|GPLUS_PRODUCER
value|"GNU C++ "
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LCC_PRODUCER
end_ifndef

begin_define
define|#
directive|define
name|LCC_PRODUCER
value|"NCR C/C++"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CHILL_PRODUCER
end_ifndef

begin_define
define|#
directive|define
name|CHILL_PRODUCER
value|"GNU Chill "
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Provide a default mapping from a DWARF register number to a gdb REGNUM.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DWARF_REG_TO_REGNUM
end_ifndef

begin_define
define|#
directive|define
name|DWARF_REG_TO_REGNUM
parameter_list|(
name|num
parameter_list|)
value|(num)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Flags to target_to_host() that tell whether or not the data object is    expected to be signed.  Used, for example, when fetching a signed    integer in the target environment which is used as a signed integer    in the host environment, and the two environments have different sized    ints.  In this case, *somebody* has to sign extend the smaller sized    int. */
end_comment

begin_define
define|#
directive|define
name|GET_UNSIGNED
value|0
end_define

begin_comment
comment|/* No sign extension required */
end_comment

begin_define
define|#
directive|define
name|GET_SIGNED
value|1
end_define

begin_comment
comment|/* Sign extension required */
end_comment

begin_comment
comment|/* Defines for things which are specified in the document "DWARF Debugging    Information Format" published by UNIX International, Programming Languages    SIG.  These defines are based on revision 1.0.0, Jan 20, 1992. */
end_comment

begin_define
define|#
directive|define
name|SIZEOF_DIE_LENGTH
value|4
end_define

begin_define
define|#
directive|define
name|SIZEOF_DIE_TAG
value|2
end_define

begin_define
define|#
directive|define
name|SIZEOF_ATTRIBUTE
value|2
end_define

begin_define
define|#
directive|define
name|SIZEOF_FORMAT_SPECIFIER
value|1
end_define

begin_define
define|#
directive|define
name|SIZEOF_FMT_FT
value|2
end_define

begin_define
define|#
directive|define
name|SIZEOF_LINETBL_LENGTH
value|4
end_define

begin_define
define|#
directive|define
name|SIZEOF_LINETBL_LINENO
value|4
end_define

begin_define
define|#
directive|define
name|SIZEOF_LINETBL_STMT
value|2
end_define

begin_define
define|#
directive|define
name|SIZEOF_LINETBL_DELTA
value|4
end_define

begin_define
define|#
directive|define
name|SIZEOF_LOC_ATOM_CODE
value|1
end_define

begin_define
define|#
directive|define
name|FORM_FROM_ATTR
parameter_list|(
name|attr
parameter_list|)
value|((attr)& 0xF)
end_define

begin_comment
comment|/* Implicitly specified */
end_comment

begin_comment
comment|/* Macros that return the sizes of various types of data in the target    environment.     FIXME:  Currently these are just compile time constants (as they are in    other parts of gdb as well).  They need to be able to get the right size    either from the bfd or possibly from the DWARF info.  It would be nice if    the DWARF producer inserted DIES that describe the fundamental types in    the target environment into the DWARF info, similar to the way dbx stabs    producers produce information about their fundamental types. */
end_comment

begin_define
define|#
directive|define
name|TARGET_FT_POINTER_SIZE
parameter_list|(
name|objfile
parameter_list|)
value|(TARGET_PTR_BIT / TARGET_CHAR_BIT)
end_define

begin_define
define|#
directive|define
name|TARGET_FT_LONG_SIZE
parameter_list|(
name|objfile
parameter_list|)
value|(TARGET_LONG_BIT / TARGET_CHAR_BIT)
end_define

begin_comment
comment|/* The Amiga SVR4 header file<dwarf.h> defines AT_element_list as a    FORM_BLOCK2, and this is the value emitted by the AT&T compiler.    However, the Issue 2 DWARF specification from AT&T defines it as    a FORM_BLOCK4, as does the latest specification from UI/PLSIG.    For backwards compatibility with the AT&T compiler produced executables    we define AT_short_element_list for this variant. */
end_comment

begin_define
define|#
directive|define
name|AT_short_element_list
value|(0x00f0|FORM_BLOCK2)
end_define

begin_comment
comment|/* External variables referenced. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|info_verbose
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* From main.c; nonzero => verbose */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|warning_pre_print
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* From utils.c */
end_comment

begin_comment
comment|/* The DWARF debugging information consists of two major pieces,    one is a block of DWARF Information Entries (DIE's) and the other    is a line number table.  The "struct dieinfo" structure contains    the information for a single DIE, the one currently being processed.     In order to make it easier to randomly access the attribute fields    of the current DIE, which are specifically unordered within the DIE,    each DIE is scanned and an instance of the "struct dieinfo"    structure is initialized.     Initialization is done in two levels.  The first, done by basicdieinfo(),    just initializes those fields that are vital to deciding whether or not    to use this DIE, how to skip past it, etc.  The second, done by the    function completedieinfo(), fills in the rest of the information.     Attributes which have block forms are not interpreted at the time    the DIE is scanned, instead we just save pointers to the start    of their value fields.     Some fields have a flag<name>_p that is set when the value of the    field is valid (I.E. we found a matching attribute in the DIE).  Since    we may want to test for the presence of some attributes in the DIE,    such as AT_low_pc, without restricting the values of the field,    we need someway to note that we found such an attribute.      */
end_comment

begin_typedef
typedef|typedef
name|char
name|BLOCK
typedef|;
end_typedef

begin_struct
struct|struct
name|dieinfo
block|{
name|char
modifier|*
name|die
decl_stmt|;
comment|/* Pointer to the raw DIE data */
name|unsigned
name|long
name|die_length
decl_stmt|;
comment|/* Length of the raw DIE data */
name|DIE_REF
name|die_ref
decl_stmt|;
comment|/* Offset of this DIE */
name|unsigned
name|short
name|die_tag
decl_stmt|;
comment|/* Tag for this DIE */
name|unsigned
name|long
name|at_padding
decl_stmt|;
name|unsigned
name|long
name|at_sibling
decl_stmt|;
name|BLOCK
modifier|*
name|at_location
decl_stmt|;
name|char
modifier|*
name|at_name
decl_stmt|;
name|unsigned
name|short
name|at_fund_type
decl_stmt|;
name|BLOCK
modifier|*
name|at_mod_fund_type
decl_stmt|;
name|unsigned
name|long
name|at_user_def_type
decl_stmt|;
name|BLOCK
modifier|*
name|at_mod_u_d_type
decl_stmt|;
name|unsigned
name|short
name|at_ordering
decl_stmt|;
name|BLOCK
modifier|*
name|at_subscr_data
decl_stmt|;
name|unsigned
name|long
name|at_byte_size
decl_stmt|;
name|unsigned
name|short
name|at_bit_offset
decl_stmt|;
name|unsigned
name|long
name|at_bit_size
decl_stmt|;
name|BLOCK
modifier|*
name|at_element_list
decl_stmt|;
name|unsigned
name|long
name|at_stmt_list
decl_stmt|;
name|CORE_ADDR
name|at_low_pc
decl_stmt|;
name|CORE_ADDR
name|at_high_pc
decl_stmt|;
name|unsigned
name|long
name|at_language
decl_stmt|;
name|unsigned
name|long
name|at_member
decl_stmt|;
name|unsigned
name|long
name|at_discr
decl_stmt|;
name|BLOCK
modifier|*
name|at_discr_value
decl_stmt|;
name|BLOCK
modifier|*
name|at_string_length
decl_stmt|;
name|char
modifier|*
name|at_comp_dir
decl_stmt|;
name|char
modifier|*
name|at_producer
decl_stmt|;
name|unsigned
name|long
name|at_start_scope
decl_stmt|;
name|unsigned
name|long
name|at_stride_size
decl_stmt|;
name|unsigned
name|long
name|at_src_info
decl_stmt|;
name|char
modifier|*
name|at_prototyped
decl_stmt|;
name|unsigned
name|int
name|has_at_low_pc
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|has_at_stmt_list
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|has_at_byte_size
range|:
literal|1
decl_stmt|;
name|unsigned
name|int
name|short_element_list
range|:
literal|1
decl_stmt|;
comment|/* Kludge to identify register variables */
name|unsigned
name|int
name|isreg
decl_stmt|;
comment|/* Kludge to identify optimized out variables */
name|unsigned
name|int
name|optimized_out
decl_stmt|;
comment|/* Kludge to identify basereg references.      Nonzero if we have an offset relative to a basereg.  */
name|unsigned
name|int
name|offreg
decl_stmt|;
comment|/* Kludge to identify which base register is it relative to.  */
name|unsigned
name|int
name|basereg
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|diecount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Approximate count of dies for compilation unit */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|dieinfo
modifier|*
name|curdie
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For warnings and such */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dbbase
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Base pointer to dwarf info */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dbsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Size of dwarf info in bytes */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dbroff
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Relative offset from start of .debug section */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|lnbase
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Base pointer to line section */
end_comment

begin_comment
comment|/* This value is added to each symbol value.  FIXME:  Generalize to     the section_offsets structure used by dbxread (once this is done,    pass the appropriate section number to end_symtab).  */
end_comment

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|baseaddr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add to each symbol value */
end_comment

begin_comment
comment|/* The section offsets used in the current psymtab or symtab.  FIXME,    only used to pass one value (baseaddr) at the moment.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|section_offsets
modifier|*
name|base_section_offsets
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We put a pointer to this structure in the read_symtab_private field    of the psymtab.  */
end_comment

begin_struct
struct|struct
name|dwfinfo
block|{
comment|/* Always the absolute file offset to the start of the ".debug"      section for the file containing the DIE's being accessed.  */
name|file_ptr
name|dbfoff
decl_stmt|;
comment|/* Relative offset from the start of the ".debug" section to the      first DIE to be accessed.  When building the partial symbol      table, this value will be zero since we are accessing the      entire ".debug" section.  When expanding a partial symbol      table entry, this value will be the offset to the first      DIE for the compilation unit containing the symbol that      triggers the expansion.  */
name|int
name|dbroff
decl_stmt|;
comment|/* The size of the chunk of DIE's being examined, in bytes.  */
name|int
name|dblength
decl_stmt|;
comment|/* The absolute file offset to the line table fragment.  Ignored      when building partial symbol tables, but used when expanding      them, and contains the absolute file offset to the fragment      of the ".line" section containing the line numbers for the      current compilation unit.  */
name|file_ptr
name|lnfoff
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DBFOFF
parameter_list|(
name|p
parameter_list|)
value|(((struct dwfinfo *)((p)->read_symtab_private))->dbfoff)
end_define

begin_define
define|#
directive|define
name|DBROFF
parameter_list|(
name|p
parameter_list|)
value|(((struct dwfinfo *)((p)->read_symtab_private))->dbroff)
end_define

begin_define
define|#
directive|define
name|DBLENGTH
parameter_list|(
name|p
parameter_list|)
value|(((struct dwfinfo *)((p)->read_symtab_private))->dblength)
end_define

begin_define
define|#
directive|define
name|LNFOFF
parameter_list|(
name|p
parameter_list|)
value|(((struct dwfinfo *)((p)->read_symtab_private))->lnfoff)
end_define

begin_comment
comment|/* The generic symbol table building routines have separate lists for    file scope symbols and all all other scopes (local scopes).  So    we need to select the right one to pass to add_symbol_to_list().    We do it by keeping a pointer to the correct list in list_in_scope.     FIXME:  The original dwarf code just treated the file scope as the first    local scope, and all other local scopes as nested local scopes, and worked    fine.  Check to see if we really need to distinguish these in buildsym.c */
end_comment

begin_decl_stmt
name|struct
name|pending
modifier|*
modifier|*
name|list_in_scope
init|=
operator|&
name|file_symbols
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* DIES which have user defined types or modified user defined types refer to    other DIES for the type information.  Thus we need to associate the offset    of a DIE for a user defined type with a pointer to the type information.     Originally this was done using a simple but expensive algorithm, with an    array of unsorted structures, each containing an offset/type-pointer pair.    This array was scanned linearly each time a lookup was done.  The result    was that gdb was spending over half it's startup time munging through this    array of pointers looking for a structure that had the right offset member.     The second attempt used the same array of structures, but the array was    sorted using qsort each time a new offset/type was recorded, and a binary    search was used to find the type pointer for a given DIE offset.  This was    even slower, due to the overhead of sorting the array each time a new    offset/type pair was entered.     The third attempt uses a fixed size array of type pointers, indexed by a    value derived from the DIE offset.  Since the minimum DIE size is 4 bytes,    we can divide any DIE offset by 4 to obtain a unique index into this fixed    size array.  Since each element is a 4 byte pointer, it takes exactly as    much memory to hold this array as to hold the DWARF info for a given    compilation unit.  But it gets freed as soon as we are done with it.    This has worked well in practice, as a reasonable tradeoff between memory    consumption and speed, without having to resort to much more complicated    algorithms. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
modifier|*
name|utypes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to array of user type pointers */
end_comment

begin_decl_stmt
specifier|static
name|int
name|numutypes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Max number of user type pointers */
end_comment

begin_comment
comment|/* Maintain an array of referenced fundamental types for the current    compilation unit being read.  For DWARF version 1, we have to construct    the fundamental types on the fly, since no information about the    fundamental types is supplied.  Each such fundamental type is created by    calling a language dependent routine to create the type, and then a    pointer to that type is then placed in the array at the index specified    by it's FT_<TYPENAME> value.  The array has a fixed size set by the    FT_NUM_MEMBERS compile time constant, which is the number of predefined    fundamental types gdb knows how to construct. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|ftypes
index|[
name|FT_NUM_MEMBERS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Fundamental types */
end_comment

begin_comment
comment|/* Record the language for the compilation unit which is currently being    processed.  We know it once we have seen the TAG_compile_unit DIE,    and we need it while processing the DIE's for that compilation unit.    It is eventually saved in the symtab structure, but we don't finalize    the symtab struct until we have processed all the DIE's for the    compilation unit.  We also need to get and save a pointer to the     language struct for this language, so we can call the language    dependent routines for doing things such as creating fundamental    types. */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|language
name|cu_language
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|language_defn
modifier|*
name|cu_language_defn
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations of static functions so we don't have to worry    about ordering within this file.  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|free_utypes
name|PARAMS
argument_list|(
operator|(
name|PTR
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|attribute_size
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CORE_ADDR
name|target_to_host
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_enum_psymbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|dieinfo
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|handle_producer
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_file_scope
name|PARAMS
argument_list|(
operator|(
expr|struct
name|dieinfo
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_func_scope
name|PARAMS
argument_list|(
operator|(
expr|struct
name|dieinfo
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_lexical_block_scope
name|PARAMS
argument_list|(
operator|(
expr|struct
name|dieinfo
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|scan_partial_symbols
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|scan_compilation_units
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|file_ptr
operator|,
name|file_ptr
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|add_partial_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|dieinfo
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|basicdieinfo
name|PARAMS
argument_list|(
operator|(
expr|struct
name|dieinfo
operator|*
operator|,
name|char
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|completedieinfo
name|PARAMS
argument_list|(
operator|(
expr|struct
name|dieinfo
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dwarf_psymtab_to_symtab
name|PARAMS
argument_list|(
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|psymtab_to_symtab_1
name|PARAMS
argument_list|(
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_ofile_symtab
name|PARAMS
argument_list|(
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|process_dies
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_structure_scope
name|PARAMS
argument_list|(
operator|(
expr|struct
name|dieinfo
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|decode_array_element_type
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|decode_subscript_data_item
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dwarf_read_array_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|dieinfo
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_tag_pointer_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|dieinfo
operator|*
name|dip
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_tag_string_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|dieinfo
operator|*
name|dip
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_subroutine_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|dieinfo
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_enumeration
name|PARAMS
argument_list|(
operator|(
expr|struct
name|dieinfo
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|struct_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|dieinfo
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|enum_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|dieinfo
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|decode_line_numbers
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|decode_die_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|dieinfo
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|decode_mod_fund_type
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|decode_mod_u_d_type
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|decode_modified_type
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|unsigned
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|decode_fund_type
name|PARAMS
argument_list|(
operator|(
name|unsigned
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|create_name
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|obstack
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|lookup_utype
name|PARAMS
argument_list|(
operator|(
name|DIE_REF
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|alloc_utype
name|PARAMS
argument_list|(
operator|(
name|DIE_REF
operator|,
expr|struct
name|type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|symbol
modifier|*
name|new_symbol
name|PARAMS
argument_list|(
operator|(
expr|struct
name|dieinfo
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|synthesize_typedef
name|PARAMS
argument_list|(
operator|(
expr|struct
name|dieinfo
operator|*
operator|,
expr|struct
name|objfile
operator|*
operator|,
expr|struct
name|type
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|locval
name|PARAMS
argument_list|(
operator|(
expr|struct
name|dieinfo
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|set_cu_language
name|PARAMS
argument_list|(
operator|(
expr|struct
name|dieinfo
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|type
modifier|*
name|dwarf_fundamental_type
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  LOCAL FUNCTION  	dwarf_fundamental_type -- lookup or create a fundamental type  SYNOPSIS  	struct type * 	dwarf_fundamental_type (struct objfile *objfile, int typeid)  DESCRIPTION  	DWARF version 1 doesn't supply any fundamental type information, 	so gdb has to construct such types.  It has a fixed number of 	fundamental types that it knows how to construct, which is the 	union of all types that it knows how to construct for all languages 	that it knows about.  These are enumerated in gdbtypes.h.  	As an example, assume we find a DIE that references a DWARF 	fundamental type of FT_integer.  We first look in the ftypes 	array to see if we already have such a type, indexed by the 	gdb internal value of FT_INTEGER.  If so, we simply return a 	pointer to that type.  If not, then we ask an appropriate 	language dependent routine to create a type FT_INTEGER, using 	defaults reasonable for the current target machine, and install 	that type in ftypes for future reference.  RETURNS  	Pointer to a fundamental type.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|dwarf_fundamental_type
parameter_list|(
name|objfile
parameter_list|,
name|typeid
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|int
name|typeid
decl_stmt|;
block|{
if|if
condition|(
name|typeid
operator|<
literal|0
operator|||
name|typeid
operator|>=
name|FT_NUM_MEMBERS
condition|)
block|{
name|error
argument_list|(
literal|"internal error - invalid fundamental type id %d"
argument_list|,
name|typeid
argument_list|)
expr_stmt|;
block|}
comment|/* Look for this particular type in the fundamental type vector.  If one is      not found, create and install one appropriate for the current language      and the current target machine. */
if|if
condition|(
name|ftypes
index|[
name|typeid
index|]
operator|==
name|NULL
condition|)
block|{
name|ftypes
index|[
name|typeid
index|]
operator|=
name|cu_language_defn
operator|->
name|la_fund_type
argument_list|(
name|objfile
argument_list|,
name|typeid
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ftypes
index|[
name|typeid
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	set_cu_language -- set local copy of language for compilation unit  SYNOPSIS  	void 	set_cu_language (struct dieinfo *dip)  DESCRIPTION  	Decode the language attribute for a compilation unit DIE and 	remember what the language was.  We use this at various times 	when processing DIE's for a given compilation unit.  RETURNS  	No return value.   */
end_comment

begin_function
specifier|static
name|void
name|set_cu_language
parameter_list|(
name|dip
parameter_list|)
name|struct
name|dieinfo
modifier|*
name|dip
decl_stmt|;
block|{
switch|switch
condition|(
name|dip
operator|->
name|at_language
condition|)
block|{
case|case
name|LANG_C89
case|:
case|case
name|LANG_C
case|:
name|cu_language
operator|=
name|language_c
expr_stmt|;
break|break;
case|case
name|LANG_C_PLUS_PLUS
case|:
name|cu_language
operator|=
name|language_cplus
expr_stmt|;
break|break;
case|case
name|LANG_CHILL
case|:
name|cu_language
operator|=
name|language_chill
expr_stmt|;
break|break;
case|case
name|LANG_MODULA2
case|:
name|cu_language
operator|=
name|language_m2
expr_stmt|;
break|break;
case|case
name|LANG_FORTRAN77
case|:
case|case
name|LANG_FORTRAN90
case|:
name|cu_language
operator|=
name|language_fortran
expr_stmt|;
break|break;
case|case
name|LANG_ADA83
case|:
case|case
name|LANG_COBOL74
case|:
case|case
name|LANG_COBOL85
case|:
case|case
name|LANG_PASCAL83
case|:
comment|/* We don't know anything special about these yet. */
name|cu_language
operator|=
name|language_unknown
expr_stmt|;
break|break;
default|default:
comment|/* If no at_language, try to deduce one from the filename */
name|cu_language
operator|=
name|deduce_language_from_filename
argument_list|(
name|dip
operator|->
name|at_name
argument_list|)
expr_stmt|;
break|break;
block|}
name|cu_language_defn
operator|=
name|language_def
argument_list|(
name|cu_language
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  GLOBAL FUNCTION  	dwarf_build_psymtabs -- build partial symtabs from DWARF debug info  SYNOPSIS  	void dwarf_build_psymtabs (struct objfile *objfile, 	     struct section_offsets *section_offsets, 	     int mainline, file_ptr dbfoff, unsigned int dbfsize, 	     file_ptr lnoffset, unsigned int lnsize)  DESCRIPTION  	This function is called upon to build partial symtabs from files 	containing DIE's (Dwarf Information Entries) and DWARF line numbers.  	It is passed a bfd* containing the DIES 	and line number information, the corresponding filename for that 	file, a base address for relocating the symbols, a flag indicating 	whether or not this debugging information is from a "main symbol 	table" rather than a shared library or dynamically linked file, 	and file offset/size pairs for the DIE information and line number 	information.  RETURNS  	No return value.   */
end_comment

begin_function
name|void
name|dwarf_build_psymtabs
parameter_list|(
name|objfile
parameter_list|,
name|section_offsets
parameter_list|,
name|mainline
parameter_list|,
name|dbfoff
parameter_list|,
name|dbfsize
parameter_list|,
name|lnoffset
parameter_list|,
name|lnsize
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|int
name|mainline
decl_stmt|;
name|file_ptr
name|dbfoff
decl_stmt|;
name|unsigned
name|int
name|dbfsize
decl_stmt|;
name|file_ptr
name|lnoffset
decl_stmt|;
name|unsigned
name|int
name|lnsize
decl_stmt|;
block|{
name|bfd
modifier|*
name|abfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
decl_stmt|;
name|current_objfile
operator|=
name|objfile
expr_stmt|;
name|dbsize
operator|=
name|dbfsize
expr_stmt|;
name|dbbase
operator|=
name|xmalloc
argument_list|(
name|dbsize
argument_list|)
expr_stmt|;
name|dbroff
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|dbfoff
argument_list|,
name|SEEK_SET
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|bfd_read
argument_list|(
name|dbbase
argument_list|,
name|dbsize
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|dbsize
operator|)
condition|)
block|{
name|free
argument_list|(
name|dbbase
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"can't read DWARF data from '%s'"
argument_list|,
name|bfd_get_filename
argument_list|(
name|abfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|back_to
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|dbbase
argument_list|)
expr_stmt|;
comment|/* If we are reinitializing, or if we have never loaded syms yet, init.      Since we have no idea how many DIES we are looking at, we just guess      some arbitrary value. */
if|if
condition|(
name|mainline
operator|||
name|objfile
operator|->
name|global_psymbols
operator|.
name|size
operator|==
literal|0
operator|||
name|objfile
operator|->
name|static_psymbols
operator|.
name|size
operator|==
literal|0
condition|)
block|{
name|init_psymbol_list
argument_list|(
name|objfile
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
block|}
comment|/* Save the relocation factor where everybody can see it.  */
name|base_section_offsets
operator|=
name|section_offsets
expr_stmt|;
name|baseaddr
operator|=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Follow the compilation unit sibling chain, building a partial symbol      table entry for each one.  Save enough information about each compilation      unit to locate the full DWARF information later. */
name|scan_compilation_units
argument_list|(
name|dbbase
argument_list|,
name|dbbase
operator|+
name|dbsize
argument_list|,
name|dbfoff
argument_list|,
name|lnoffset
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
name|current_objfile
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	read_lexical_block_scope -- process all dies in a lexical block  SYNOPSIS  	static void read_lexical_block_scope (struct dieinfo *dip, 		char *thisdie, char *enddie)  DESCRIPTION  	Process all the DIES contained within a lexical block scope. 	Start a new scope, process the dies, and then close the scope.   */
end_comment

begin_function
specifier|static
name|void
name|read_lexical_block_scope
parameter_list|(
name|dip
parameter_list|,
name|thisdie
parameter_list|,
name|enddie
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|dieinfo
modifier|*
name|dip
decl_stmt|;
name|char
modifier|*
name|thisdie
decl_stmt|;
name|char
modifier|*
name|enddie
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
specifier|register
name|struct
name|context_stack
modifier|*
name|new
decl_stmt|;
name|push_context
argument_list|(
literal|0
argument_list|,
name|dip
operator|->
name|at_low_pc
argument_list|)
expr_stmt|;
name|process_dies
argument_list|(
name|thisdie
operator|+
name|dip
operator|->
name|die_length
argument_list|,
name|enddie
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|new
operator|=
name|pop_context
argument_list|()
expr_stmt|;
if|if
condition|(
name|local_symbols
operator|!=
name|NULL
condition|)
block|{
name|finish_block
argument_list|(
literal|0
argument_list|,
operator|&
name|local_symbols
argument_list|,
name|new
operator|->
name|old_blocks
argument_list|,
name|new
operator|->
name|start_addr
argument_list|,
name|dip
operator|->
name|at_high_pc
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
name|local_symbols
operator|=
name|new
operator|->
name|locals
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	lookup_utype -- look up a user defined type from die reference  SYNOPSIS  	static type *lookup_utype (DIE_REF die_ref)  DESCRIPTION  	Given a DIE reference, lookup the user defined type associated with 	that DIE, if it has been registered already.  If not registered, then 	return NULL.  Alloc_utype() can be called to register an empty 	type for this reference, which will be filled in later when the 	actual referenced DIE is processed.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|lookup_utype
parameter_list|(
name|die_ref
parameter_list|)
name|DIE_REF
name|die_ref
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|NULL
decl_stmt|;
name|int
name|utypeidx
decl_stmt|;
name|utypeidx
operator|=
operator|(
name|die_ref
operator|-
name|dbroff
operator|)
operator|/
literal|4
expr_stmt|;
if|if
condition|(
operator|(
name|utypeidx
operator|<
literal|0
operator|)
operator|||
operator|(
name|utypeidx
operator|>=
name|numutypes
operator|)
condition|)
block|{
name|complain
argument_list|(
operator|&
name|bad_die_ref
argument_list|,
name|DIE_ID
argument_list|,
name|DIE_NAME
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
operator|*
operator|(
name|utypes
operator|+
name|utypeidx
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	alloc_utype  -- add a user defined type for die reference  SYNOPSIS  	static type *alloc_utype (DIE_REF die_ref, struct type *utypep)  DESCRIPTION  	Given a die reference DIE_REF, and a possible pointer to a user 	defined type UTYPEP, register that this reference has a user 	defined type and either use the specified type in UTYPEP or 	make a new empty type that will be filled in later.  	We should only be called after calling lookup_utype() to verify that 	there is not currently a type registered for DIE_REF.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|alloc_utype
parameter_list|(
name|die_ref
parameter_list|,
name|utypep
parameter_list|)
name|DIE_REF
name|die_ref
decl_stmt|;
name|struct
name|type
modifier|*
name|utypep
decl_stmt|;
block|{
name|struct
name|type
modifier|*
modifier|*
name|typep
decl_stmt|;
name|int
name|utypeidx
decl_stmt|;
name|utypeidx
operator|=
operator|(
name|die_ref
operator|-
name|dbroff
operator|)
operator|/
literal|4
expr_stmt|;
name|typep
operator|=
name|utypes
operator|+
name|utypeidx
expr_stmt|;
if|if
condition|(
operator|(
name|utypeidx
operator|<
literal|0
operator|)
operator|||
operator|(
name|utypeidx
operator|>=
name|numutypes
operator|)
condition|)
block|{
name|utypep
operator|=
name|dwarf_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_INTEGER
argument_list|)
expr_stmt|;
name|complain
argument_list|(
operator|&
name|bad_die_ref
argument_list|,
name|DIE_ID
argument_list|,
name|DIE_NAME
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|typep
operator|!=
name|NULL
condition|)
block|{
name|utypep
operator|=
operator|*
name|typep
expr_stmt|;
name|complain
argument_list|(
operator|&
name|dup_user_type_allocation
argument_list|,
name|DIE_ID
argument_list|,
name|DIE_NAME
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|utypep
operator|==
name|NULL
condition|)
block|{
name|utypep
operator|=
name|alloc_type
argument_list|(
name|current_objfile
argument_list|)
expr_stmt|;
block|}
operator|*
name|typep
operator|=
name|utypep
expr_stmt|;
block|}
return|return
operator|(
name|utypep
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	free_utypes -- free the utypes array and reset pointer& count  SYNOPSIS  	static void free_utypes (PTR dummy)  DESCRIPTION  	Called via do_cleanups to free the utypes array, reset the pointer to NULL, 	and set numutypes back to zero.  This ensures that the utypes does not get 	referenced after being freed.  */
end_comment

begin_function
specifier|static
name|void
name|free_utypes
parameter_list|(
name|dummy
parameter_list|)
name|PTR
name|dummy
decl_stmt|;
block|{
name|free
argument_list|(
name|utypes
argument_list|)
expr_stmt|;
name|utypes
operator|=
name|NULL
expr_stmt|;
name|numutypes
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	decode_die_type -- return a type for a specified die  SYNOPSIS  	static struct type *decode_die_type (struct dieinfo *dip)  DESCRIPTION  	Given a pointer to a die information structure DIP, decode the 	type of the die and return a pointer to the decoded type.  All 	dies without specific types default to type int.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|decode_die_type
parameter_list|(
name|dip
parameter_list|)
name|struct
name|dieinfo
modifier|*
name|dip
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|type
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|dip
operator|->
name|at_fund_type
operator|!=
literal|0
condition|)
block|{
name|type
operator|=
name|decode_fund_type
argument_list|(
name|dip
operator|->
name|at_fund_type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dip
operator|->
name|at_mod_fund_type
operator|!=
name|NULL
condition|)
block|{
name|type
operator|=
name|decode_mod_fund_type
argument_list|(
name|dip
operator|->
name|at_mod_fund_type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dip
operator|->
name|at_user_def_type
condition|)
block|{
if|if
condition|(
operator|(
name|type
operator|=
name|lookup_utype
argument_list|(
name|dip
operator|->
name|at_user_def_type
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|type
operator|=
name|alloc_utype
argument_list|(
name|dip
operator|->
name|at_user_def_type
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dip
operator|->
name|at_mod_u_d_type
condition|)
block|{
name|type
operator|=
name|decode_mod_u_d_type
argument_list|(
name|dip
operator|->
name|at_mod_u_d_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|dwarf_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_VOID
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	struct_type -- compute and return the type for a struct or union  SYNOPSIS  	static struct type *struct_type (struct dieinfo *dip, char *thisdie, 	    char *enddie, struct objfile *objfile)  DESCRIPTION  	Given pointer to a die information structure for a die which 	defines a union or structure (and MUST define one or the other), 	and pointers to the raw die data that define the range of dies which 	define the members, compute and return the user defined type for the 	structure or union.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|struct_type
parameter_list|(
name|dip
parameter_list|,
name|thisdie
parameter_list|,
name|enddie
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|dieinfo
modifier|*
name|dip
decl_stmt|;
name|char
modifier|*
name|thisdie
decl_stmt|;
name|char
modifier|*
name|enddie
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
struct|struct
name|nextfield
block|{
name|struct
name|nextfield
modifier|*
name|next
decl_stmt|;
name|struct
name|field
name|field
decl_stmt|;
block|}
struct|;
name|struct
name|nextfield
modifier|*
name|list
init|=
name|NULL
decl_stmt|;
name|struct
name|nextfield
modifier|*
name|new
decl_stmt|;
name|int
name|nfields
init|=
literal|0
decl_stmt|;
name|int
name|n
decl_stmt|;
name|struct
name|dieinfo
name|mbr
decl_stmt|;
name|char
modifier|*
name|nextdie
decl_stmt|;
name|int
name|anonymous_size
decl_stmt|;
if|if
condition|(
operator|(
name|type
operator|=
name|lookup_utype
argument_list|(
name|dip
operator|->
name|die_ref
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* No forward references created an empty type, so install one now */
name|type
operator|=
name|alloc_utype
argument_list|(
name|dip
operator|->
name|die_ref
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|INIT_CPLUS_SPECIFIC
argument_list|(
name|type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dip
operator|->
name|die_tag
condition|)
block|{
case|case
name|TAG_class_type
case|:
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_CLASS
expr_stmt|;
break|break;
case|case
name|TAG_structure_type
case|:
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_STRUCT
expr_stmt|;
break|break;
case|case
name|TAG_union_type
case|:
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_UNION
expr_stmt|;
break|break;
default|default:
comment|/* Should never happen */
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_UNDEF
expr_stmt|;
name|complain
argument_list|(
operator|&
name|missing_tag
argument_list|,
name|DIE_ID
argument_list|,
name|DIE_NAME
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Some compilers try to be helpful by inventing "fake" names for      anonymous enums, structures, and unions, like "~0fake" or ".0fake".      Thanks, but no thanks... */
if|if
condition|(
name|dip
operator|->
name|at_name
operator|!=
name|NULL
operator|&&
operator|*
name|dip
operator|->
name|at_name
operator|!=
literal|'~'
operator|&&
operator|*
name|dip
operator|->
name|at_name
operator|!=
literal|'.'
condition|)
block|{
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|obconcat
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|dip
operator|->
name|at_name
argument_list|)
expr_stmt|;
block|}
comment|/* Use whatever size is known.  Zero is a valid size.  We might however      wish to check has_at_byte_size to make sure that some byte size was      given explicitly, but DWARF doesn't specify that explicit sizes of      zero have to present, so complaining about missing sizes should       probably not be the default. */
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|dip
operator|->
name|at_byte_size
expr_stmt|;
name|thisdie
operator|+=
name|dip
operator|->
name|die_length
expr_stmt|;
while|while
condition|(
name|thisdie
operator|<
name|enddie
condition|)
block|{
name|basicdieinfo
argument_list|(
operator|&
name|mbr
argument_list|,
name|thisdie
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|completedieinfo
argument_list|(
operator|&
name|mbr
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbr
operator|.
name|die_length
operator|<=
name|SIZEOF_DIE_LENGTH
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|mbr
operator|.
name|at_sibling
operator|!=
literal|0
condition|)
block|{
name|nextdie
operator|=
name|dbbase
operator|+
name|mbr
operator|.
name|at_sibling
operator|-
name|dbroff
expr_stmt|;
block|}
else|else
block|{
name|nextdie
operator|=
name|thisdie
operator|+
name|mbr
operator|.
name|die_length
expr_stmt|;
block|}
switch|switch
condition|(
name|mbr
operator|.
name|die_tag
condition|)
block|{
case|case
name|TAG_member
case|:
comment|/* Get space to record the next field's data.  */
name|new
operator|=
operator|(
expr|struct
name|nextfield
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|new
expr_stmt|;
comment|/* Save the data.  */
name|list
operator|->
name|field
operator|.
name|name
operator|=
name|obsavestring
argument_list|(
name|mbr
operator|.
name|at_name
argument_list|,
name|strlen
argument_list|(
name|mbr
operator|.
name|at_name
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|)
expr_stmt|;
name|FIELD_TYPE
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
name|decode_die_type
argument_list|(
operator|&
name|mbr
argument_list|)
expr_stmt|;
name|FIELD_BITPOS
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
literal|8
operator|*
name|locval
argument_list|(
operator|&
name|mbr
argument_list|)
expr_stmt|;
comment|/* Handle bit fields. */
name|FIELD_BITSIZE
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
name|mbr
operator|.
name|at_bit_size
expr_stmt|;
if|if
condition|(
name|BITS_BIG_ENDIAN
condition|)
block|{
comment|/* For big endian bits, the at_bit_offset gives the 		 additional bit offset from the MSB of the containing 		 anonymous object to the MSB of the field.  We don't 		 have to do anything special since we don't need to 		 know the size of the anonymous object. */
name|FIELD_BITPOS
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|+=
name|mbr
operator|.
name|at_bit_offset
expr_stmt|;
block|}
else|else
block|{
comment|/* For little endian bits, we need to have a non-zero 		 at_bit_size, so that we know we are in fact dealing 		 with a bitfield.  Compute the bit offset to the MSB 		 of the anonymous object, subtract off the number of 		 bits from the MSB of the field to the MSB of the 		 object, and then subtract off the number of bits of 		 the field itself.  The result is the bit offset of 		 the LSB of the field. */
if|if
condition|(
name|mbr
operator|.
name|at_bit_size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|mbr
operator|.
name|has_at_byte_size
condition|)
block|{
comment|/* The size of the anonymous object containing 			 the bit field is explicit, so use the 			 indicated size (in bytes). */
name|anonymous_size
operator|=
name|mbr
operator|.
name|at_byte_size
expr_stmt|;
block|}
else|else
block|{
comment|/* The size of the anonymous object containing 			 the bit field matches the size of an object 			 of the bit field's type.  DWARF allows 			 at_byte_size to be left out in such cases, as 			 a debug information size optimization. */
name|anonymous_size
operator|=
name|TYPE_LENGTH
argument_list|(
name|list
operator|->
name|field
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
name|FIELD_BITPOS
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|+=
name|anonymous_size
operator|*
literal|8
operator|-
name|mbr
operator|.
name|at_bit_offset
operator|-
name|mbr
operator|.
name|at_bit_size
expr_stmt|;
block|}
block|}
name|nfields
operator|++
expr_stmt|;
break|break;
default|default:
name|process_dies
argument_list|(
name|thisdie
argument_list|,
name|nextdie
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
block|}
name|thisdie
operator|=
name|nextdie
expr_stmt|;
block|}
comment|/* Now create the vector of fields, and record how big it is.  We may      not even have any fields, if this DIE was generated due to a reference      to an anonymous structure or union.  In this case, TYPE_FLAG_STUB is      set, which clues gdb in to the fact that it needs to search elsewhere      for the full structure definition. */
if|if
condition|(
name|nfields
operator|==
literal|0
condition|)
block|{
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator||=
name|TYPE_FLAG_STUB
expr_stmt|;
block|}
else|else
block|{
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|nfields
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|TYPE_ALLOC
argument_list|(
name|type
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|nfields
argument_list|)
expr_stmt|;
comment|/* Copy the saved-up fields into the field vector.  */
for|for
control|(
name|n
operator|=
name|nfields
init|;
name|list
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
block|{
name|TYPE_FIELD
argument_list|(
name|type
argument_list|,
operator|--
name|n
argument_list|)
operator|=
name|list
operator|->
name|field
expr_stmt|;
block|}
block|}
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	read_structure_scope -- process all dies within struct or union  SYNOPSIS  	static void read_structure_scope (struct dieinfo *dip, 		char *thisdie, char *enddie, struct objfile *objfile)  DESCRIPTION  	Called when we find the DIE that starts a structure or union 	scope (definition) to process all dies that define the members 	of the structure or union.  DIP is a pointer to the die info 	struct for the DIE that names the structure or union.  NOTES  	Note that we need to call struct_type regardless of whether or not 	the DIE has an at_name attribute, since it might be an anonymous 	structure or union.  This gets the type entered into our set of 	user defined types.  	However, if the structure is incomplete (an opaque struct/union) 	then suppress creating a symbol table entry for it since gdb only 	wants to find the one with the complete definition.  Note that if 	it is complete, we just call new_symbol, which does it's own 	checking about whether the struct/union is anonymous or not (and 	suppresses creating a symbol table entry itself). 	  */
end_comment

begin_function
specifier|static
name|void
name|read_structure_scope
parameter_list|(
name|dip
parameter_list|,
name|thisdie
parameter_list|,
name|enddie
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|dieinfo
modifier|*
name|dip
decl_stmt|;
name|char
modifier|*
name|thisdie
decl_stmt|;
name|char
modifier|*
name|enddie
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|type
operator|=
name|struct_type
argument_list|(
name|dip
argument_list|,
name|thisdie
argument_list|,
name|enddie
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&
name|TYPE_FLAG_STUB
operator|)
condition|)
block|{
name|sym
operator|=
name|new_symbol
argument_list|(
name|dip
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
block|{
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|cu_language
operator|==
name|language_cplus
condition|)
block|{
name|synthesize_typedef
argument_list|(
name|dip
argument_list|,
name|objfile
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	decode_array_element_type -- decode type of the array elements  SYNOPSIS  	static struct type *decode_array_element_type (char *scan, char *end)  DESCRIPTION  	As the last step in decoding the array subscript information for an 	array DIE, we need to decode the type of the array elements.  We are 	passed a pointer to this last part of the subscript information and 	must return the appropriate type.  If the type attribute is not 	recognized, just warn about the problem and return type int.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|decode_array_element_type
parameter_list|(
name|scan
parameter_list|)
name|char
modifier|*
name|scan
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|typep
decl_stmt|;
name|DIE_REF
name|die_ref
decl_stmt|;
name|unsigned
name|short
name|attribute
decl_stmt|;
name|unsigned
name|short
name|fundtype
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
name|attribute
operator|=
name|target_to_host
argument_list|(
name|scan
argument_list|,
name|SIZEOF_ATTRIBUTE
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|current_objfile
argument_list|)
expr_stmt|;
name|scan
operator|+=
name|SIZEOF_ATTRIBUTE
expr_stmt|;
if|if
condition|(
operator|(
name|nbytes
operator|=
name|attribute_size
argument_list|(
name|attribute
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|complain
argument_list|(
operator|&
name|bad_array_element_type
argument_list|,
name|DIE_ID
argument_list|,
name|DIE_NAME
argument_list|,
name|attribute
argument_list|)
expr_stmt|;
name|typep
operator|=
name|dwarf_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_INTEGER
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|attribute
condition|)
block|{
case|case
name|AT_fund_type
case|:
name|fundtype
operator|=
name|target_to_host
argument_list|(
name|scan
argument_list|,
name|nbytes
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|current_objfile
argument_list|)
expr_stmt|;
name|typep
operator|=
name|decode_fund_type
argument_list|(
name|fundtype
argument_list|)
expr_stmt|;
break|break;
case|case
name|AT_mod_fund_type
case|:
name|typep
operator|=
name|decode_mod_fund_type
argument_list|(
name|scan
argument_list|)
expr_stmt|;
break|break;
case|case
name|AT_user_def_type
case|:
name|die_ref
operator|=
name|target_to_host
argument_list|(
name|scan
argument_list|,
name|nbytes
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|current_objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|typep
operator|=
name|lookup_utype
argument_list|(
name|die_ref
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|typep
operator|=
name|alloc_utype
argument_list|(
name|die_ref
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|AT_mod_u_d_type
case|:
name|typep
operator|=
name|decode_mod_u_d_type
argument_list|(
name|scan
argument_list|)
expr_stmt|;
break|break;
default|default:
name|complain
argument_list|(
operator|&
name|bad_array_element_type
argument_list|,
name|DIE_ID
argument_list|,
name|DIE_NAME
argument_list|,
name|attribute
argument_list|)
expr_stmt|;
name|typep
operator|=
name|dwarf_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_INTEGER
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|typep
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	decode_subscript_data_item -- decode array subscript item  SYNOPSIS  	static struct type * 	decode_subscript_data_item (char *scan, char *end)  DESCRIPTION  	The array subscripts and the data type of the elements of an 	array are described by a list of data items, stored as a block 	of contiguous bytes.  There is a data item describing each array 	dimension, and a final data item describing the element type. 	The data items are ordered the same as their appearance in the 	source (I.E. leftmost dimension first, next to leftmost second, 	etc).  	The data items describing each array dimension consist of four 	parts: (1) a format specifier, (2) type type of the subscript 	index, (3) a description of the low bound of the array dimension, 	and (4) a description of the high bound of the array dimension.  	The last data item is the description of the type of each of 	the array elements.  	We are passed a pointer to the start of the block of bytes 	containing the remaining data items, and a pointer to the first 	byte past the data.  This function recursively decodes the 	remaining data items and returns a type.  	If we somehow fail to decode some data, we complain about it 	and return a type "array of int".  BUGS 	FIXME:  This code only implements the forms currently used 	by the AT&T and GNU C compilers.  	The end pointer is supplied for error checking, maybe we should 	use it for that...  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|decode_subscript_data_item
parameter_list|(
name|scan
parameter_list|,
name|end
parameter_list|)
name|char
modifier|*
name|scan
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|typep
init|=
name|NULL
decl_stmt|;
comment|/* Array type we are building */
name|struct
name|type
modifier|*
name|nexttype
decl_stmt|;
comment|/* Type of each element (may be array) */
name|struct
name|type
modifier|*
name|indextype
decl_stmt|;
comment|/* Type of this index */
name|struct
name|type
modifier|*
name|rangetype
decl_stmt|;
name|unsigned
name|int
name|format
decl_stmt|;
name|unsigned
name|short
name|fundtype
decl_stmt|;
name|unsigned
name|long
name|lowbound
decl_stmt|;
name|unsigned
name|long
name|highbound
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
name|format
operator|=
name|target_to_host
argument_list|(
name|scan
argument_list|,
name|SIZEOF_FORMAT_SPECIFIER
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|current_objfile
argument_list|)
expr_stmt|;
name|scan
operator|+=
name|SIZEOF_FORMAT_SPECIFIER
expr_stmt|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|FMT_ET
case|:
name|typep
operator|=
name|decode_array_element_type
argument_list|(
name|scan
argument_list|)
expr_stmt|;
break|break;
case|case
name|FMT_FT_C_C
case|:
name|fundtype
operator|=
name|target_to_host
argument_list|(
name|scan
argument_list|,
name|SIZEOF_FMT_FT
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|current_objfile
argument_list|)
expr_stmt|;
name|indextype
operator|=
name|decode_fund_type
argument_list|(
name|fundtype
argument_list|)
expr_stmt|;
name|scan
operator|+=
name|SIZEOF_FMT_FT
expr_stmt|;
name|nbytes
operator|=
name|TARGET_FT_LONG_SIZE
argument_list|(
name|current_objfile
argument_list|)
expr_stmt|;
name|lowbound
operator|=
name|target_to_host
argument_list|(
name|scan
argument_list|,
name|nbytes
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|current_objfile
argument_list|)
expr_stmt|;
name|scan
operator|+=
name|nbytes
expr_stmt|;
name|highbound
operator|=
name|target_to_host
argument_list|(
name|scan
argument_list|,
name|nbytes
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|current_objfile
argument_list|)
expr_stmt|;
name|scan
operator|+=
name|nbytes
expr_stmt|;
name|nexttype
operator|=
name|decode_subscript_data_item
argument_list|(
name|scan
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|nexttype
operator|==
name|NULL
condition|)
block|{
comment|/* Munged subscript data or other problem, fake it. */
name|complain
argument_list|(
operator|&
name|subscript_data_items
argument_list|,
name|DIE_ID
argument_list|,
name|DIE_NAME
argument_list|)
expr_stmt|;
name|nexttype
operator|=
name|dwarf_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_INTEGER
argument_list|)
expr_stmt|;
block|}
name|rangetype
operator|=
name|create_range_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|indextype
argument_list|,
name|lowbound
argument_list|,
name|highbound
argument_list|)
expr_stmt|;
name|typep
operator|=
name|create_array_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|nexttype
argument_list|,
name|rangetype
argument_list|)
expr_stmt|;
break|break;
case|case
name|FMT_FT_C_X
case|:
case|case
name|FMT_FT_X_C
case|:
case|case
name|FMT_FT_X_X
case|:
case|case
name|FMT_UT_C_C
case|:
case|case
name|FMT_UT_C_X
case|:
case|case
name|FMT_UT_X_C
case|:
case|case
name|FMT_UT_X_X
case|:
name|complain
argument_list|(
operator|&
name|unhandled_array_subscript_format
argument_list|,
name|DIE_ID
argument_list|,
name|DIE_NAME
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|nexttype
operator|=
name|dwarf_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_INTEGER
argument_list|)
expr_stmt|;
name|rangetype
operator|=
name|create_range_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|nexttype
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typep
operator|=
name|create_array_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|nexttype
argument_list|,
name|rangetype
argument_list|)
expr_stmt|;
break|break;
default|default:
name|complain
argument_list|(
operator|&
name|unknown_array_subscript_format
argument_list|,
name|DIE_ID
argument_list|,
name|DIE_NAME
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|nexttype
operator|=
name|dwarf_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_INTEGER
argument_list|)
expr_stmt|;
name|rangetype
operator|=
name|create_range_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|nexttype
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|typep
operator|=
name|create_array_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|nexttype
argument_list|,
name|rangetype
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|typep
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	dwarf_read_array_type -- read TAG_array_type DIE  SYNOPSIS  	static void dwarf_read_array_type (struct dieinfo *dip)  DESCRIPTION  	Extract all information from a TAG_array_type DIE and add to 	the user defined type vector.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf_read_array_type
parameter_list|(
name|dip
parameter_list|)
name|struct
name|dieinfo
modifier|*
name|dip
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|type
modifier|*
name|utype
decl_stmt|;
name|char
modifier|*
name|sub
decl_stmt|;
name|char
modifier|*
name|subend
decl_stmt|;
name|unsigned
name|short
name|blocksz
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
if|if
condition|(
name|dip
operator|->
name|at_ordering
operator|!=
name|ORD_row_major
condition|)
block|{
comment|/* FIXME:  Can gdb even handle column major arrays? */
name|complain
argument_list|(
operator|&
name|not_row_major
argument_list|,
name|DIE_ID
argument_list|,
name|DIE_NAME
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sub
operator|=
name|dip
operator|->
name|at_subscr_data
operator|)
operator|!=
name|NULL
condition|)
block|{
name|nbytes
operator|=
name|attribute_size
argument_list|(
name|AT_subscr_data
argument_list|)
expr_stmt|;
name|blocksz
operator|=
name|target_to_host
argument_list|(
name|sub
argument_list|,
name|nbytes
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|current_objfile
argument_list|)
expr_stmt|;
name|subend
operator|=
name|sub
operator|+
name|nbytes
operator|+
name|blocksz
expr_stmt|;
name|sub
operator|+=
name|nbytes
expr_stmt|;
name|type
operator|=
name|decode_subscript_data_item
argument_list|(
name|sub
argument_list|,
name|subend
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|utype
operator|=
name|lookup_utype
argument_list|(
name|dip
operator|->
name|die_ref
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* Install user defined type that has not been referenced yet. */
name|alloc_utype
argument_list|(
name|dip
operator|->
name|die_ref
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|utype
argument_list|)
operator|==
name|TYPE_CODE_UNDEF
condition|)
block|{
comment|/* Ick!  A forward ref has already generated a blank type in our 	     slot, and this type probably already has things pointing to it 	     (which is what caused it to be created in the first place). 	     If it's just a place holder we can plop our fully defined type 	     on top of it.  We can't recover the space allocated for our 	     new type since it might be on an obstack, but we could reuse 	     it if we kept a list of them, but it might not be worth it 	     (FIXME). */
operator|*
name|utype
operator|=
operator|*
name|type
expr_stmt|;
block|}
else|else
block|{
comment|/* Double ick!  Not only is a type already in our slot, but 	     someone has decorated it.  Complain and leave it alone. */
name|complain
argument_list|(
operator|&
name|dup_user_type_definition
argument_list|,
name|DIE_ID
argument_list|,
name|DIE_NAME
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	read_tag_pointer_type -- read TAG_pointer_type DIE  SYNOPSIS  	static void read_tag_pointer_type (struct dieinfo *dip)  DESCRIPTION  	Extract all information from a TAG_pointer_type DIE and add to 	the user defined type vector.  */
end_comment

begin_function
specifier|static
name|void
name|read_tag_pointer_type
parameter_list|(
name|dip
parameter_list|)
name|struct
name|dieinfo
modifier|*
name|dip
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|type
modifier|*
name|utype
decl_stmt|;
name|type
operator|=
name|decode_die_type
argument_list|(
name|dip
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|utype
operator|=
name|lookup_utype
argument_list|(
name|dip
operator|->
name|die_ref
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|utype
operator|=
name|lookup_pointer_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|alloc_utype
argument_list|(
name|dip
operator|->
name|die_ref
argument_list|,
name|utype
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TYPE_TARGET_TYPE
argument_list|(
name|utype
argument_list|)
operator|=
name|type
expr_stmt|;
name|TYPE_POINTER_TYPE
argument_list|(
name|type
argument_list|)
operator|=
name|utype
expr_stmt|;
comment|/* We assume the machine has only one representation for pointers!  */
comment|/* FIXME:  Possably a poor assumption  */
name|TYPE_LENGTH
argument_list|(
name|utype
argument_list|)
operator|=
name|TARGET_PTR_BIT
operator|/
name|TARGET_CHAR_BIT
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|utype
argument_list|)
operator|=
name|TYPE_CODE_PTR
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	read_tag_string_type -- read TAG_string_type DIE  SYNOPSIS  	static void read_tag_string_type (struct dieinfo *dip)  DESCRIPTION  	Extract all information from a TAG_string_type DIE and add to 	the user defined type vector.  It isn't really a user defined 	type, but it behaves like one, with other DIE's using an 	AT_user_def_type attribute to reference it.  */
end_comment

begin_function
specifier|static
name|void
name|read_tag_string_type
parameter_list|(
name|dip
parameter_list|)
name|struct
name|dieinfo
modifier|*
name|dip
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|utype
decl_stmt|;
name|struct
name|type
modifier|*
name|indextype
decl_stmt|;
name|struct
name|type
modifier|*
name|rangetype
decl_stmt|;
name|unsigned
name|long
name|lowbound
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|highbound
decl_stmt|;
if|if
condition|(
name|dip
operator|->
name|has_at_byte_size
condition|)
block|{
comment|/* A fixed bounds string */
name|highbound
operator|=
name|dip
operator|->
name|at_byte_size
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* A varying length string.  Stub for now.  (FIXME) */
name|highbound
operator|=
literal|1
expr_stmt|;
block|}
name|indextype
operator|=
name|dwarf_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_INTEGER
argument_list|)
expr_stmt|;
name|rangetype
operator|=
name|create_range_type
argument_list|(
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|,
name|indextype
argument_list|,
name|lowbound
argument_list|,
name|highbound
argument_list|)
expr_stmt|;
name|utype
operator|=
name|lookup_utype
argument_list|(
name|dip
operator|->
name|die_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|utype
operator|==
name|NULL
condition|)
block|{
comment|/* No type defined, go ahead and create a blank one to use. */
name|utype
operator|=
name|alloc_utype
argument_list|(
name|dip
operator|->
name|die_ref
argument_list|,
operator|(
expr|struct
name|type
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Already a type in our slot due to a forward reference. Make sure it 	 is a blank one.  If not, complain and leave it alone. */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|utype
argument_list|)
operator|!=
name|TYPE_CODE_UNDEF
condition|)
block|{
name|complain
argument_list|(
operator|&
name|dup_user_type_definition
argument_list|,
name|DIE_ID
argument_list|,
name|DIE_NAME
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Create the string type using the blank type we either found or created. */
name|utype
operator|=
name|create_string_type
argument_list|(
name|utype
argument_list|,
name|rangetype
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	read_subroutine_type -- process TAG_subroutine_type dies  SYNOPSIS  	static void read_subroutine_type (struct dieinfo *dip, char thisdie, 		char *enddie)  DESCRIPTION  	Handle DIES due to C code like:  	struct foo { 	    int (*funcp)(int a, long l);  (Generates TAG_subroutine_type DIE) 	    int b; 	};  NOTES  	The parameter DIES are currently ignored.  See if gdb has a way to 	include this info in it's type system, and decode them if so.  Is 	this what the type structure's "arg_types" field is for?  (FIXME)  */
end_comment

begin_function
specifier|static
name|void
name|read_subroutine_type
parameter_list|(
name|dip
parameter_list|,
name|thisdie
parameter_list|,
name|enddie
parameter_list|)
name|struct
name|dieinfo
modifier|*
name|dip
decl_stmt|;
name|char
modifier|*
name|thisdie
decl_stmt|;
name|char
modifier|*
name|enddie
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
comment|/* Type that this function returns */
name|struct
name|type
modifier|*
name|ftype
decl_stmt|;
comment|/* Function that returns above type */
comment|/* Decode the type that this subroutine returns */
name|type
operator|=
name|decode_die_type
argument_list|(
name|dip
argument_list|)
expr_stmt|;
comment|/* Check to see if we already have a partially constructed user      defined type for this DIE, from a forward reference. */
if|if
condition|(
operator|(
name|ftype
operator|=
name|lookup_utype
argument_list|(
name|dip
operator|->
name|die_ref
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* This is the first reference to one of these types.  Make 	 a new one and place it in the user defined types. */
name|ftype
operator|=
name|lookup_function_type
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|alloc_utype
argument_list|(
name|dip
operator|->
name|die_ref
argument_list|,
name|ftype
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|ftype
argument_list|)
operator|==
name|TYPE_CODE_UNDEF
condition|)
block|{
comment|/* We have an existing partially constructed type, so bash it 	 into the correct type. */
name|TYPE_TARGET_TYPE
argument_list|(
name|ftype
argument_list|)
operator|=
name|type
expr_stmt|;
name|TYPE_LENGTH
argument_list|(
name|ftype
argument_list|)
operator|=
literal|1
expr_stmt|;
name|TYPE_CODE
argument_list|(
name|ftype
argument_list|)
operator|=
name|TYPE_CODE_FUNC
expr_stmt|;
block|}
else|else
block|{
name|complain
argument_list|(
operator|&
name|dup_user_type_definition
argument_list|,
name|DIE_ID
argument_list|,
name|DIE_NAME
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	read_enumeration -- process dies which define an enumeration  SYNOPSIS  	static void read_enumeration (struct dieinfo *dip, char *thisdie, 		char *enddie, struct objfile *objfile)  DESCRIPTION  	Given a pointer to a die which begins an enumeration, process all 	the dies that define the members of the enumeration.  NOTES  	Note that we need to call enum_type regardless of whether or not we 	have a symbol, since we might have an enum without a tag name (thus 	no symbol for the tagname).  */
end_comment

begin_function
specifier|static
name|void
name|read_enumeration
parameter_list|(
name|dip
parameter_list|,
name|thisdie
parameter_list|,
name|enddie
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|dieinfo
modifier|*
name|dip
decl_stmt|;
name|char
modifier|*
name|thisdie
decl_stmt|;
name|char
modifier|*
name|enddie
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|type
operator|=
name|enum_type
argument_list|(
name|dip
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|sym
operator|=
name|new_symbol
argument_list|(
name|dip
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|!=
name|NULL
condition|)
block|{
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|cu_language
operator|==
name|language_cplus
condition|)
block|{
name|synthesize_typedef
argument_list|(
name|dip
argument_list|,
name|objfile
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	enum_type -- decode and return a type for an enumeration  SYNOPSIS  	static type *enum_type (struct dieinfo *dip, struct objfile *objfile)  DESCRIPTION  	Given a pointer to a die information structure for the die which 	starts an enumeration, process all the dies that define the members 	of the enumeration and return a type pointer for the enumeration.  	At the same time, for each member of the enumeration, create a 	symbol for it with namespace VAR_NAMESPACE and class LOC_CONST, 	and give it the type of the enumeration itself.  NOTES  	Note that the DWARF specification explicitly mandates that enum 	constants occur in reverse order from the source program order, 	for "consistency" and because this ordering is easier for many 	compilers to generate. (Draft 6, sec 3.8.5, Enumeration type 	Entries).  Because gdb wants to see the enum members in program 	source order, we have to ensure that the order gets reversed while 	we are processing them.  */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|enum_type
parameter_list|(
name|dip
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|dieinfo
modifier|*
name|dip
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|type
decl_stmt|;
struct|struct
name|nextfield
block|{
name|struct
name|nextfield
modifier|*
name|next
decl_stmt|;
name|struct
name|field
name|field
decl_stmt|;
block|}
struct|;
name|struct
name|nextfield
modifier|*
name|list
init|=
name|NULL
decl_stmt|;
name|struct
name|nextfield
modifier|*
name|new
decl_stmt|;
name|int
name|nfields
init|=
literal|0
decl_stmt|;
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|scan
decl_stmt|;
name|char
modifier|*
name|listend
decl_stmt|;
name|unsigned
name|short
name|blocksz
decl_stmt|;
name|struct
name|symbol
modifier|*
name|sym
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
name|int
name|unsigned_enum
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|(
name|type
operator|=
name|lookup_utype
argument_list|(
name|dip
operator|->
name|die_ref
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* No forward references created an empty type, so install one now */
name|type
operator|=
name|alloc_utype
argument_list|(
name|dip
operator|->
name|die_ref
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|=
name|TYPE_CODE_ENUM
expr_stmt|;
comment|/* Some compilers try to be helpful by inventing "fake" names for      anonymous enums, structures, and unions, like "~0fake" or ".0fake".      Thanks, but no thanks... */
if|if
condition|(
name|dip
operator|->
name|at_name
operator|!=
name|NULL
operator|&&
operator|*
name|dip
operator|->
name|at_name
operator|!=
literal|'~'
operator|&&
operator|*
name|dip
operator|->
name|at_name
operator|!=
literal|'.'
condition|)
block|{
name|TYPE_TAG_NAME
argument_list|(
name|type
argument_list|)
operator|=
name|obconcat
argument_list|(
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|dip
operator|->
name|at_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dip
operator|->
name|at_byte_size
operator|!=
literal|0
condition|)
block|{
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|=
name|dip
operator|->
name|at_byte_size
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|scan
operator|=
name|dip
operator|->
name|at_element_list
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dip
operator|->
name|short_element_list
condition|)
block|{
name|nbytes
operator|=
name|attribute_size
argument_list|(
name|AT_short_element_list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nbytes
operator|=
name|attribute_size
argument_list|(
name|AT_element_list
argument_list|)
expr_stmt|;
block|}
name|blocksz
operator|=
name|target_to_host
argument_list|(
name|scan
argument_list|,
name|nbytes
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|listend
operator|=
name|scan
operator|+
name|nbytes
operator|+
name|blocksz
expr_stmt|;
name|scan
operator|+=
name|nbytes
expr_stmt|;
while|while
condition|(
name|scan
operator|<
name|listend
condition|)
block|{
name|new
operator|=
operator|(
expr|struct
name|nextfield
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nextfield
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|list
expr_stmt|;
name|list
operator|=
name|new
expr_stmt|;
name|FIELD_TYPE
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|FIELD_BITSIZE
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
literal|0
expr_stmt|;
name|FIELD_BITPOS
argument_list|(
name|list
operator|->
name|field
argument_list|)
operator|=
name|target_to_host
argument_list|(
name|scan
argument_list|,
name|TARGET_FT_LONG_SIZE
argument_list|(
name|objfile
argument_list|)
argument_list|,
name|GET_SIGNED
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|scan
operator|+=
name|TARGET_FT_LONG_SIZE
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|list
operator|->
name|field
operator|.
name|name
operator|=
name|obsavestring
argument_list|(
name|scan
argument_list|,
name|strlen
argument_list|(
name|scan
argument_list|)
argument_list|,
operator|&
name|objfile
operator|->
name|type_obstack
argument_list|)
expr_stmt|;
name|scan
operator|+=
name|strlen
argument_list|(
name|scan
argument_list|)
operator|+
literal|1
expr_stmt|;
name|nfields
operator|++
expr_stmt|;
comment|/* Handcraft a new symbol for this enum member. */
name|sym
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|create_name
argument_list|(
name|list
operator|->
name|field
operator|.
name|name
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
name|SYMBOL_INIT_LANGUAGE_SPECIFIC
argument_list|(
name|sym
argument_list|,
name|cu_language
argument_list|)
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_CONST
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|type
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|FIELD_BITPOS
argument_list|(
name|list
operator|->
name|field
argument_list|)
expr_stmt|;
if|if
condition|(
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|<
literal|0
condition|)
name|unsigned_enum
operator|=
literal|0
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
name|list_in_scope
argument_list|)
expr_stmt|;
block|}
comment|/* Now create the vector of fields, and record how big it is. This is 	 where we reverse the order, by pulling the members off the list in 	 reverse order from how they were inserted.  If we have no fields 	 (this is apparently possible in C++) then skip building a field 	 vector. */
if|if
condition|(
name|nfields
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|unsigned_enum
condition|)
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator||=
name|TYPE_FLAG_UNSIGNED
expr_stmt|;
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
operator|=
name|nfields
expr_stmt|;
name|TYPE_FIELDS
argument_list|(
name|type
argument_list|)
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
operator|*
name|nfields
argument_list|)
expr_stmt|;
comment|/* Copy the saved-up fields into the field vector.  */
for|for
control|(
name|n
operator|=
literal|0
init|;
operator|(
name|n
operator|<
name|nfields
operator|)
operator|&&
operator|(
name|list
operator|!=
name|NULL
operator|)
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
block|{
name|TYPE_FIELD
argument_list|(
name|type
argument_list|,
name|n
operator|++
argument_list|)
operator|=
name|list
operator|->
name|field
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	read_func_scope -- process all dies within a function scope  DESCRIPTION  	Process all dies within a given function scope.  We are passed 	a die information structure pointer DIP for the die which 	starts the function scope, and pointers into the raw die data 	that define the dies within the function scope.  	For now, we ignore lexical block scopes within the function. 	The problem is that AT&T cc does not define a DWARF lexical 	block scope for the function itself, while gcc defines a 	lexical block scope for the function.  We need to think about 	how to handle this difference, or if it is even a problem. 	(FIXME)  */
end_comment

begin_function
specifier|static
name|void
name|read_func_scope
parameter_list|(
name|dip
parameter_list|,
name|thisdie
parameter_list|,
name|enddie
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|dieinfo
modifier|*
name|dip
decl_stmt|;
name|char
modifier|*
name|thisdie
decl_stmt|;
name|char
modifier|*
name|enddie
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
specifier|register
name|struct
name|context_stack
modifier|*
name|new
decl_stmt|;
comment|/* AT_name is absent if the function is described with an      AT_abstract_origin tag.      Ignore the function description for now to avoid GDB core dumps.      FIXME: Add code to handle AT_abstract_origin tags properly.  */
if|if
condition|(
name|dip
operator|->
name|at_name
operator|==
name|NULL
condition|)
block|{
name|complain
argument_list|(
operator|&
name|missing_at_name
argument_list|,
name|DIE_ID
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|objfile
operator|->
name|ei
operator|.
name|entry_point
operator|>=
name|dip
operator|->
name|at_low_pc
operator|&&
name|objfile
operator|->
name|ei
operator|.
name|entry_point
operator|<
name|dip
operator|->
name|at_high_pc
condition|)
block|{
name|objfile
operator|->
name|ei
operator|.
name|entry_func_lowpc
operator|=
name|dip
operator|->
name|at_low_pc
expr_stmt|;
name|objfile
operator|->
name|ei
operator|.
name|entry_func_highpc
operator|=
name|dip
operator|->
name|at_high_pc
expr_stmt|;
block|}
if|if
condition|(
name|STREQ
argument_list|(
name|dip
operator|->
name|at_name
argument_list|,
literal|"main"
argument_list|)
condition|)
comment|/* FIXME: hardwired name */
block|{
name|objfile
operator|->
name|ei
operator|.
name|main_func_lowpc
operator|=
name|dip
operator|->
name|at_low_pc
expr_stmt|;
name|objfile
operator|->
name|ei
operator|.
name|main_func_highpc
operator|=
name|dip
operator|->
name|at_high_pc
expr_stmt|;
block|}
name|new
operator|=
name|push_context
argument_list|(
literal|0
argument_list|,
name|dip
operator|->
name|at_low_pc
argument_list|)
expr_stmt|;
name|new
operator|->
name|name
operator|=
name|new_symbol
argument_list|(
name|dip
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|list_in_scope
operator|=
operator|&
name|local_symbols
expr_stmt|;
name|process_dies
argument_list|(
name|thisdie
operator|+
name|dip
operator|->
name|die_length
argument_list|,
name|enddie
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|new
operator|=
name|pop_context
argument_list|()
expr_stmt|;
comment|/* Make a block for the local symbols within.  */
name|finish_block
argument_list|(
name|new
operator|->
name|name
argument_list|,
operator|&
name|local_symbols
argument_list|,
name|new
operator|->
name|old_blocks
argument_list|,
name|new
operator|->
name|start_addr
argument_list|,
name|dip
operator|->
name|at_high_pc
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|list_in_scope
operator|=
operator|&
name|file_symbols
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	handle_producer -- process the AT_producer attribute  DESCRIPTION  	Perform any operations that depend on finding a particular 	AT_producer attribute.   */
end_comment

begin_function
specifier|static
name|void
name|handle_producer
parameter_list|(
name|producer
parameter_list|)
name|char
modifier|*
name|producer
decl_stmt|;
block|{
comment|/* If this compilation unit was compiled with g++ or gcc, then set the      processing_gcc_compilation flag. */
if|if
condition|(
name|STREQN
argument_list|(
name|producer
argument_list|,
name|GCC_PRODUCER
argument_list|,
name|strlen
argument_list|(
name|GCC_PRODUCER
argument_list|)
argument_list|)
condition|)
block|{
name|char
name|version
init|=
name|producer
index|[
name|strlen
argument_list|(
name|GCC_PRODUCER
argument_list|)
index|]
decl_stmt|;
name|processing_gcc_compilation
operator|=
operator|(
name|version
operator|==
literal|'2'
condition|?
literal|2
else|:
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|processing_gcc_compilation
operator|=
name|STREQN
argument_list|(
name|producer
argument_list|,
name|GPLUS_PRODUCER
argument_list|,
name|strlen
argument_list|(
name|GPLUS_PRODUCER
argument_list|)
argument_list|)
operator|||
name|STREQN
argument_list|(
name|producer
argument_list|,
name|CHILL_PRODUCER
argument_list|,
name|strlen
argument_list|(
name|CHILL_PRODUCER
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Select a demangling style if we can identify the producer and if      the current style is auto.  We leave the current style alone if it      is not auto.  We also leave the demangling style alone if we find a      gcc (cc1) producer, as opposed to a g++ (cc1plus) producer. */
if|if
condition|(
name|AUTO_DEMANGLING
condition|)
block|{
if|if
condition|(
name|STREQN
argument_list|(
name|producer
argument_list|,
name|GPLUS_PRODUCER
argument_list|,
name|strlen
argument_list|(
name|GPLUS_PRODUCER
argument_list|)
argument_list|)
condition|)
block|{
name|set_demangling_style
argument_list|(
name|GNU_DEMANGLING_STYLE_STRING
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQN
argument_list|(
name|producer
argument_list|,
name|LCC_PRODUCER
argument_list|,
name|strlen
argument_list|(
name|LCC_PRODUCER
argument_list|)
argument_list|)
condition|)
block|{
name|set_demangling_style
argument_list|(
name|LUCID_DEMANGLING_STYLE_STRING
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	read_file_scope -- process all dies within a file scope  DESCRIPTION  	Process all dies within a given file scope.  We are passed a 	pointer to the die information structure for the die which 	starts the file scope, and pointers into the raw die data which 	mark the range of dies within the file scope.  	When the partial symbol table is built, the file offset for the line 	number table for each compilation unit is saved in the partial symbol 	table entry for that compilation unit.  As the symbols for each 	compilation unit are read, the line number table is read into memory 	and the variable lnbase is set to point to it.  Thus all we have to 	do is use lnbase to access the line number table for the current 	compilation unit.  */
end_comment

begin_function
specifier|static
name|void
name|read_file_scope
parameter_list|(
name|dip
parameter_list|,
name|thisdie
parameter_list|,
name|enddie
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|dieinfo
modifier|*
name|dip
decl_stmt|;
name|char
modifier|*
name|thisdie
decl_stmt|;
name|char
modifier|*
name|enddie
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|cleanup
modifier|*
name|back_to
decl_stmt|;
name|struct
name|symtab
modifier|*
name|symtab
decl_stmt|;
if|if
condition|(
name|objfile
operator|->
name|ei
operator|.
name|entry_point
operator|>=
name|dip
operator|->
name|at_low_pc
operator|&&
name|objfile
operator|->
name|ei
operator|.
name|entry_point
operator|<
name|dip
operator|->
name|at_high_pc
condition|)
block|{
name|objfile
operator|->
name|ei
operator|.
name|entry_file_lowpc
operator|=
name|dip
operator|->
name|at_low_pc
expr_stmt|;
name|objfile
operator|->
name|ei
operator|.
name|entry_file_highpc
operator|=
name|dip
operator|->
name|at_high_pc
expr_stmt|;
block|}
name|set_cu_language
argument_list|(
name|dip
argument_list|)
expr_stmt|;
if|if
condition|(
name|dip
operator|->
name|at_producer
operator|!=
name|NULL
condition|)
block|{
name|handle_producer
argument_list|(
name|dip
operator|->
name|at_producer
argument_list|)
expr_stmt|;
block|}
name|numutypes
operator|=
operator|(
name|enddie
operator|-
name|thisdie
operator|)
operator|/
literal|4
expr_stmt|;
name|utypes
operator|=
operator|(
expr|struct
name|type
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|numutypes
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|back_to
operator|=
name|make_cleanup
argument_list|(
name|free_utypes
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|utypes
argument_list|,
literal|0
argument_list|,
name|numutypes
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ftypes
argument_list|,
literal|0
argument_list|,
name|FT_NUM_MEMBERS
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|type
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|start_symtab
argument_list|(
name|dip
operator|->
name|at_name
argument_list|,
name|dip
operator|->
name|at_comp_dir
argument_list|,
name|dip
operator|->
name|at_low_pc
argument_list|)
expr_stmt|;
name|record_debugformat
argument_list|(
literal|"DWARF 1"
argument_list|)
expr_stmt|;
name|decode_line_numbers
argument_list|(
name|lnbase
argument_list|)
expr_stmt|;
name|process_dies
argument_list|(
name|thisdie
operator|+
name|dip
operator|->
name|die_length
argument_list|,
name|enddie
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|symtab
operator|=
name|end_symtab
argument_list|(
name|dip
operator|->
name|at_high_pc
argument_list|,
name|objfile
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
block|{
name|symtab
operator|->
name|language
operator|=
name|cu_language
expr_stmt|;
block|}
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	process_dies -- process a range of DWARF Information Entries  SYNOPSIS  	static void process_dies (char *thisdie, char *enddie, 				  struct objfile *objfile)  DESCRIPTION  	Process all DIE's in a specified range.  May be (and almost 	certainly will be) called recursively.  */
end_comment

begin_function
specifier|static
name|void
name|process_dies
parameter_list|(
name|thisdie
parameter_list|,
name|enddie
parameter_list|,
name|objfile
parameter_list|)
name|char
modifier|*
name|thisdie
decl_stmt|;
name|char
modifier|*
name|enddie
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|char
modifier|*
name|nextdie
decl_stmt|;
name|struct
name|dieinfo
name|di
decl_stmt|;
while|while
condition|(
name|thisdie
operator|<
name|enddie
condition|)
block|{
name|basicdieinfo
argument_list|(
operator|&
name|di
argument_list|,
name|thisdie
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|di
operator|.
name|die_length
operator|<
name|SIZEOF_DIE_LENGTH
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|di
operator|.
name|die_tag
operator|==
name|TAG_padding
condition|)
block|{
name|nextdie
operator|=
name|thisdie
operator|+
name|di
operator|.
name|die_length
expr_stmt|;
block|}
else|else
block|{
name|completedieinfo
argument_list|(
operator|&
name|di
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|di
operator|.
name|at_sibling
operator|!=
literal|0
condition|)
block|{
name|nextdie
operator|=
name|dbbase
operator|+
name|di
operator|.
name|at_sibling
operator|-
name|dbroff
expr_stmt|;
block|}
else|else
block|{
name|nextdie
operator|=
name|thisdie
operator|+
name|di
operator|.
name|die_length
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SMASH_TEXT_ADDRESS
comment|/* I think that these are always text, not data, addresses.  */
name|SMASH_TEXT_ADDRESS
argument_list|(
name|di
operator|.
name|at_low_pc
argument_list|)
expr_stmt|;
name|SMASH_TEXT_ADDRESS
argument_list|(
name|di
operator|.
name|at_high_pc
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|di
operator|.
name|die_tag
condition|)
block|{
case|case
name|TAG_compile_unit
case|:
comment|/* Skip Tag_compile_unit if we are already inside a compilation 		 unit, we are unable to handle nested compilation units 		 properly (FIXME).  */
if|if
condition|(
name|current_subfile
operator|==
name|NULL
condition|)
name|read_file_scope
argument_list|(
operator|&
name|di
argument_list|,
name|thisdie
argument_list|,
name|nextdie
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
else|else
name|nextdie
operator|=
name|thisdie
operator|+
name|di
operator|.
name|die_length
expr_stmt|;
break|break;
case|case
name|TAG_global_subroutine
case|:
case|case
name|TAG_subroutine
case|:
if|if
condition|(
name|di
operator|.
name|has_at_low_pc
condition|)
block|{
name|read_func_scope
argument_list|(
operator|&
name|di
argument_list|,
name|thisdie
argument_list|,
name|nextdie
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TAG_lexical_block
case|:
name|read_lexical_block_scope
argument_list|(
operator|&
name|di
argument_list|,
name|thisdie
argument_list|,
name|nextdie
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|TAG_class_type
case|:
case|case
name|TAG_structure_type
case|:
case|case
name|TAG_union_type
case|:
name|read_structure_scope
argument_list|(
operator|&
name|di
argument_list|,
name|thisdie
argument_list|,
name|nextdie
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|TAG_enumeration_type
case|:
name|read_enumeration
argument_list|(
operator|&
name|di
argument_list|,
name|thisdie
argument_list|,
name|nextdie
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|TAG_subroutine_type
case|:
name|read_subroutine_type
argument_list|(
operator|&
name|di
argument_list|,
name|thisdie
argument_list|,
name|nextdie
argument_list|)
expr_stmt|;
break|break;
case|case
name|TAG_array_type
case|:
name|dwarf_read_array_type
argument_list|(
operator|&
name|di
argument_list|)
expr_stmt|;
break|break;
case|case
name|TAG_pointer_type
case|:
name|read_tag_pointer_type
argument_list|(
operator|&
name|di
argument_list|)
expr_stmt|;
break|break;
case|case
name|TAG_string_type
case|:
name|read_tag_string_type
argument_list|(
operator|&
name|di
argument_list|)
expr_stmt|;
break|break;
default|default:
name|new_symbol
argument_list|(
operator|&
name|di
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|thisdie
operator|=
name|nextdie
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	decode_line_numbers -- decode a line number table fragment  SYNOPSIS  	static void decode_line_numbers (char *tblscan, char *tblend, 		long length, long base, long line, long pc)  DESCRIPTION  	Translate the DWARF line number information to gdb form.  	The ".line" section contains one or more line number tables, one for 	each ".line" section from the objects that were linked.  	The AT_stmt_list attribute for each TAG_source_file entry in the 	".debug" section contains the offset into the ".line" section for the 	start of the table for that file.  	The table itself has the following structure:<table length><base address><source statement entry> 	4 bytes       4 bytes       10 bytes  	The table length is the total size of the table, including the 4 bytes 	for the length information.  	The base address is the address of the first instruction generated 	for the source file.  	Each source statement entry has the following structure:<line number><statement position><address delta> 	4 bytes      2 bytes             4 bytes  	The line number is relative to the start of the file, starting with 	line 1.  	The statement position either -1 (0xFFFF) or the number of characters 	from the beginning of the line to the beginning of the statement.  	The address delta is the difference between the base address and 	the address of the first instruction for the statement.  	Note that we must copy the bytes from the packed table to our local 	variables before attempting to use them, to avoid alignment problems 	on some machines, particularly RISC processors.  BUGS  	Does gdb expect the line numbers to be sorted?  They are now by 	chance/luck, but are not required to be.  (FIXME)  	The line with number 0 is unused, gdb apparently can discover the 	span of the last line some other way. How?  (FIXME)  */
end_comment

begin_function
specifier|static
name|void
name|decode_line_numbers
parameter_list|(
name|linetable
parameter_list|)
name|char
modifier|*
name|linetable
decl_stmt|;
block|{
name|char
modifier|*
name|tblscan
decl_stmt|;
name|char
modifier|*
name|tblend
decl_stmt|;
name|unsigned
name|long
name|length
decl_stmt|;
name|unsigned
name|long
name|base
decl_stmt|;
name|unsigned
name|long
name|line
decl_stmt|;
name|unsigned
name|long
name|pc
decl_stmt|;
if|if
condition|(
name|linetable
operator|!=
name|NULL
condition|)
block|{
name|tblscan
operator|=
name|tblend
operator|=
name|linetable
expr_stmt|;
name|length
operator|=
name|target_to_host
argument_list|(
name|tblscan
argument_list|,
name|SIZEOF_LINETBL_LENGTH
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|current_objfile
argument_list|)
expr_stmt|;
name|tblscan
operator|+=
name|SIZEOF_LINETBL_LENGTH
expr_stmt|;
name|tblend
operator|+=
name|length
expr_stmt|;
name|base
operator|=
name|target_to_host
argument_list|(
name|tblscan
argument_list|,
name|TARGET_FT_POINTER_SIZE
argument_list|(
name|objfile
argument_list|)
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|current_objfile
argument_list|)
expr_stmt|;
name|tblscan
operator|+=
name|TARGET_FT_POINTER_SIZE
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|base
operator|+=
name|baseaddr
expr_stmt|;
while|while
condition|(
name|tblscan
operator|<
name|tblend
condition|)
block|{
name|line
operator|=
name|target_to_host
argument_list|(
name|tblscan
argument_list|,
name|SIZEOF_LINETBL_LINENO
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|current_objfile
argument_list|)
expr_stmt|;
name|tblscan
operator|+=
name|SIZEOF_LINETBL_LINENO
operator|+
name|SIZEOF_LINETBL_STMT
expr_stmt|;
name|pc
operator|=
name|target_to_host
argument_list|(
name|tblscan
argument_list|,
name|SIZEOF_LINETBL_DELTA
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|current_objfile
argument_list|)
expr_stmt|;
name|tblscan
operator|+=
name|SIZEOF_LINETBL_DELTA
expr_stmt|;
name|pc
operator|+=
name|base
expr_stmt|;
if|if
condition|(
name|line
operator|!=
literal|0
condition|)
block|{
name|record_line
argument_list|(
name|current_subfile
argument_list|,
name|line
argument_list|,
name|pc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	locval -- compute the value of a location attribute  SYNOPSIS  	static int locval (struct dieinfo *dip)  DESCRIPTION  	Given pointer to a string of bytes that define a location, compute 	the location and return the value. 	A location description containing no atoms indicates that the 	object is optimized out. The optimized_out flag is set for those, 	the return value is meaningless.  	When computing values involving the current value of the frame pointer, 	the value zero is used, which results in a value relative to the frame 	pointer, rather than the absolute value.  This is what GDB wants 	anyway.      	When the result is a register number, the isreg flag is set, otherwise 	it is cleared.  This is a kludge until we figure out a better 	way to handle the problem.  Gdb's design does not mesh well with the 	DWARF notion of a location computing interpreter, which is a shame 	because the flexibility goes unused.  NOTES  	Note that stack[0] is unused except as a default error return. 	Note that stack overflow is not yet handled.  */
end_comment

begin_function
specifier|static
name|int
name|locval
parameter_list|(
name|dip
parameter_list|)
name|struct
name|dieinfo
modifier|*
name|dip
decl_stmt|;
block|{
name|unsigned
name|short
name|nbytes
decl_stmt|;
name|unsigned
name|short
name|locsize
decl_stmt|;
specifier|auto
name|long
name|stack
index|[
literal|64
index|]
decl_stmt|;
name|int
name|stacki
decl_stmt|;
name|char
modifier|*
name|loc
decl_stmt|;
name|char
modifier|*
name|end
decl_stmt|;
name|int
name|loc_atom_code
decl_stmt|;
name|int
name|loc_value_size
decl_stmt|;
name|loc
operator|=
name|dip
operator|->
name|at_location
expr_stmt|;
name|nbytes
operator|=
name|attribute_size
argument_list|(
name|AT_location
argument_list|)
expr_stmt|;
name|locsize
operator|=
name|target_to_host
argument_list|(
name|loc
argument_list|,
name|nbytes
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|current_objfile
argument_list|)
expr_stmt|;
name|loc
operator|+=
name|nbytes
expr_stmt|;
name|end
operator|=
name|loc
operator|+
name|locsize
expr_stmt|;
name|stacki
operator|=
literal|0
expr_stmt|;
name|stack
index|[
name|stacki
index|]
operator|=
literal|0
expr_stmt|;
name|dip
operator|->
name|isreg
operator|=
literal|0
expr_stmt|;
name|dip
operator|->
name|offreg
operator|=
literal|0
expr_stmt|;
name|dip
operator|->
name|optimized_out
operator|=
literal|1
expr_stmt|;
name|loc_value_size
operator|=
name|TARGET_FT_LONG_SIZE
argument_list|(
name|current_objfile
argument_list|)
expr_stmt|;
while|while
condition|(
name|loc
operator|<
name|end
condition|)
block|{
name|dip
operator|->
name|optimized_out
operator|=
literal|0
expr_stmt|;
name|loc_atom_code
operator|=
name|target_to_host
argument_list|(
name|loc
argument_list|,
name|SIZEOF_LOC_ATOM_CODE
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|current_objfile
argument_list|)
expr_stmt|;
name|loc
operator|+=
name|SIZEOF_LOC_ATOM_CODE
expr_stmt|;
switch|switch
condition|(
name|loc_atom_code
condition|)
block|{
case|case
literal|0
case|:
comment|/* error */
name|loc
operator|=
name|end
expr_stmt|;
break|break;
case|case
name|OP_REG
case|:
comment|/* push register (number) */
name|stack
index|[
operator|++
name|stacki
index|]
operator|=
name|DWARF_REG_TO_REGNUM
argument_list|(
name|target_to_host
argument_list|(
name|loc
argument_list|,
name|loc_value_size
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|current_objfile
argument_list|)
argument_list|)
expr_stmt|;
name|loc
operator|+=
name|loc_value_size
expr_stmt|;
name|dip
operator|->
name|isreg
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|OP_BASEREG
case|:
comment|/* push value of register (number) */
comment|/* Actually, we compute the value as if register has 0, so the 	       value ends up being the offset from that register.  */
name|dip
operator|->
name|offreg
operator|=
literal|1
expr_stmt|;
name|dip
operator|->
name|basereg
operator|=
name|target_to_host
argument_list|(
name|loc
argument_list|,
name|loc_value_size
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|current_objfile
argument_list|)
expr_stmt|;
name|loc
operator|+=
name|loc_value_size
expr_stmt|;
name|stack
index|[
operator|++
name|stacki
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OP_ADDR
case|:
comment|/* push address (relocated address) */
name|stack
index|[
operator|++
name|stacki
index|]
operator|=
name|target_to_host
argument_list|(
name|loc
argument_list|,
name|loc_value_size
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|current_objfile
argument_list|)
expr_stmt|;
name|loc
operator|+=
name|loc_value_size
expr_stmt|;
break|break;
case|case
name|OP_CONST
case|:
comment|/* push constant (number)   FIXME: signed or unsigned! */
name|stack
index|[
operator|++
name|stacki
index|]
operator|=
name|target_to_host
argument_list|(
name|loc
argument_list|,
name|loc_value_size
argument_list|,
name|GET_SIGNED
argument_list|,
name|current_objfile
argument_list|)
expr_stmt|;
name|loc
operator|+=
name|loc_value_size
expr_stmt|;
break|break;
case|case
name|OP_DEREF2
case|:
comment|/* pop, deref and push 2 bytes (as a long) */
name|complain
argument_list|(
operator|&
name|op_deref2
argument_list|,
name|DIE_ID
argument_list|,
name|DIE_NAME
argument_list|,
name|stack
index|[
name|stacki
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_DEREF4
case|:
comment|/* pop, deref and push 4 bytes (as a long) */
name|complain
argument_list|(
operator|&
name|op_deref4
argument_list|,
name|DIE_ID
argument_list|,
name|DIE_NAME
argument_list|,
name|stack
index|[
name|stacki
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_ADD
case|:
comment|/* pop top 2 items, add, push result */
name|stack
index|[
name|stacki
operator|-
literal|1
index|]
operator|+=
name|stack
index|[
name|stacki
index|]
expr_stmt|;
name|stacki
operator|--
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|stack
index|[
name|stacki
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	read_ofile_symtab -- build a full symtab entry from chunk of DIE's  SYNOPSIS  	static void read_ofile_symtab (struct partial_symtab *pst)  DESCRIPTION  	When expanding a partial symbol table entry to a full symbol table 	entry, this is the function that gets called to read in the symbols 	for the compilation unit.  A pointer to the newly constructed symtab, 	which is now the new first one on the objfile's symtab list, is 	stashed in the partial symbol table entry.  */
end_comment

begin_function
specifier|static
name|void
name|read_ofile_symtab
parameter_list|(
name|pst
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
block|{
name|struct
name|cleanup
modifier|*
name|back_to
decl_stmt|;
name|unsigned
name|long
name|lnsize
decl_stmt|;
name|file_ptr
name|foffset
decl_stmt|;
name|bfd
modifier|*
name|abfd
decl_stmt|;
name|char
name|lnsizedata
index|[
name|SIZEOF_LINETBL_LENGTH
index|]
decl_stmt|;
name|abfd
operator|=
name|pst
operator|->
name|objfile
operator|->
name|obfd
expr_stmt|;
name|current_objfile
operator|=
name|pst
operator|->
name|objfile
expr_stmt|;
comment|/* Allocate a buffer for the entire chunk of DIE's for this compilation      unit, seek to the location in the file, and read in all the DIE's. */
name|diecount
operator|=
literal|0
expr_stmt|;
name|dbsize
operator|=
name|DBLENGTH
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|dbbase
operator|=
name|xmalloc
argument_list|(
name|dbsize
argument_list|)
expr_stmt|;
name|dbroff
operator|=
name|DBROFF
argument_list|(
name|pst
argument_list|)
expr_stmt|;
name|foffset
operator|=
name|DBFOFF
argument_list|(
name|pst
argument_list|)
operator|+
name|dbroff
expr_stmt|;
name|base_section_offsets
operator|=
name|pst
operator|->
name|section_offsets
expr_stmt|;
name|baseaddr
operator|=
name|ANOFFSET
argument_list|(
name|pst
operator|->
name|section_offsets
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|foffset
argument_list|,
name|SEEK_SET
argument_list|)
operator|||
operator|(
name|bfd_read
argument_list|(
name|dbbase
argument_list|,
name|dbsize
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|dbsize
operator|)
condition|)
block|{
name|free
argument_list|(
name|dbbase
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"can't read DWARF data"
argument_list|)
expr_stmt|;
block|}
name|back_to
operator|=
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|dbbase
argument_list|)
expr_stmt|;
comment|/* If there is a line number table associated with this compilation unit      then read the size of this fragment in bytes, from the fragment itself.      Allocate a buffer for the fragment and read it in for future       processing. */
name|lnbase
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|LNFOFF
argument_list|(
name|pst
argument_list|)
condition|)
block|{
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|LNFOFF
argument_list|(
name|pst
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|||
operator|(
name|bfd_read
argument_list|(
operator|(
name|PTR
operator|)
name|lnsizedata
argument_list|,
sizeof|sizeof
argument_list|(
name|lnsizedata
argument_list|)
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|lnsizedata
argument_list|)
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"can't read DWARF line number table size"
argument_list|)
expr_stmt|;
block|}
name|lnsize
operator|=
name|target_to_host
argument_list|(
name|lnsizedata
argument_list|,
name|SIZEOF_LINETBL_LENGTH
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|pst
operator|->
name|objfile
argument_list|)
expr_stmt|;
name|lnbase
operator|=
name|xmalloc
argument_list|(
name|lnsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|bfd_seek
argument_list|(
name|abfd
argument_list|,
name|LNFOFF
argument_list|(
name|pst
argument_list|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|||
operator|(
name|bfd_read
argument_list|(
name|lnbase
argument_list|,
name|lnsize
argument_list|,
literal|1
argument_list|,
name|abfd
argument_list|)
operator|!=
name|lnsize
operator|)
condition|)
block|{
name|free
argument_list|(
name|lnbase
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"can't read DWARF line numbers"
argument_list|)
expr_stmt|;
block|}
name|make_cleanup
argument_list|(
name|free
argument_list|,
name|lnbase
argument_list|)
expr_stmt|;
block|}
name|process_dies
argument_list|(
name|dbbase
argument_list|,
name|dbbase
operator|+
name|dbsize
argument_list|,
name|pst
operator|->
name|objfile
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
name|current_objfile
operator|=
name|NULL
expr_stmt|;
name|pst
operator|->
name|symtab
operator|=
name|pst
operator|->
name|objfile
operator|->
name|symtabs
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	psymtab_to_symtab_1 -- do grunt work for building a full symtab entry  SYNOPSIS  	static void psymtab_to_symtab_1 (struct partial_symtab *pst)  DESCRIPTION  	Called once for each partial symbol table entry that needs to be 	expanded into a full symbol table entry.  */
end_comment

begin_function
specifier|static
name|void
name|psymtab_to_symtab_1
parameter_list|(
name|pst
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
if|if
condition|(
name|pst
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pst
operator|->
name|readin
condition|)
block|{
name|warning
argument_list|(
literal|"psymtab for %s already read in.  Shouldn't happen."
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Read in all partial symtabs on which this one is dependent */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pst
operator|->
name|number_of_dependencies
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|pst
operator|->
name|dependencies
index|[
name|i
index|]
operator|->
name|readin
condition|)
block|{
comment|/* Inform about additional files that need to be read in. */
if|if
condition|(
name|info_verbose
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"and "
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"%s..."
argument_list|,
name|pst
operator|->
name|dependencies
index|[
name|i
index|]
operator|->
name|filename
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
comment|/* Flush output */
block|}
name|psymtab_to_symtab_1
argument_list|(
name|pst
operator|->
name|dependencies
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|DBLENGTH
argument_list|(
name|pst
argument_list|)
condition|)
comment|/* Otherwise it's a dummy */
block|{
name|buildsym_init
argument_list|()
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|really_free_pendings
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|read_ofile_symtab
argument_list|(
name|pst
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_verbose
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"%d DIE's, sorting..."
argument_list|,
name|diecount
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|sort_symtab_syms
argument_list|(
name|pst
operator|->
name|symtab
argument_list|)
expr_stmt|;
name|do_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
name|pst
operator|->
name|readin
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	dwarf_psymtab_to_symtab -- build a full symtab entry from partial one  SYNOPSIS  	static void dwarf_psymtab_to_symtab (struct partial_symtab *pst)  DESCRIPTION  	This is the DWARF support entry point for building a full symbol 	table entry from a partial symbol table entry.  We are passed a 	pointer to the partial symbol table entry that needs to be expanded.  */
end_comment

begin_function
specifier|static
name|void
name|dwarf_psymtab_to_symtab
parameter_list|(
name|pst
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
block|{
if|if
condition|(
name|pst
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pst
operator|->
name|readin
condition|)
block|{
name|warning
argument_list|(
literal|"psymtab for %s already read in.  Shouldn't happen."
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|DBLENGTH
argument_list|(
name|pst
argument_list|)
operator|||
name|pst
operator|->
name|number_of_dependencies
condition|)
block|{
comment|/* Print the message now, before starting serious work, to avoid 		 disconcerting pauses.  */
if|if
condition|(
name|info_verbose
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"Reading in symbols for %s..."
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
name|psymtab_to_symtab_1
argument_list|(
name|pst
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* FIXME:  Check to see what dbxread is doing here and see if 		 we need to do an equivalent or is this something peculiar to 		 stabs/a.out format. 		 Match with global symbols.  This only needs to be done once, 		 after all of the symtabs and dependencies have been read in. 		 */
block|scan_file_globals (pst -> objfile);
endif|#
directive|endif
comment|/* Finish up the verbose info message.  */
if|if
condition|(
name|info_verbose
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"done.\n"
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	add_enum_psymbol -- add enumeration members to partial symbol table  DESCRIPTION  	Given pointer to a DIE that is known to be for an enumeration, 	extract the symbolic names of the enumeration members and add 	partial symbols for them. */
end_comment

begin_function
specifier|static
name|void
name|add_enum_psymbol
parameter_list|(
name|dip
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|dieinfo
modifier|*
name|dip
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|char
modifier|*
name|scan
decl_stmt|;
name|char
modifier|*
name|listend
decl_stmt|;
name|unsigned
name|short
name|blocksz
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
if|if
condition|(
operator|(
name|scan
operator|=
name|dip
operator|->
name|at_element_list
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dip
operator|->
name|short_element_list
condition|)
block|{
name|nbytes
operator|=
name|attribute_size
argument_list|(
name|AT_short_element_list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nbytes
operator|=
name|attribute_size
argument_list|(
name|AT_element_list
argument_list|)
expr_stmt|;
block|}
name|blocksz
operator|=
name|target_to_host
argument_list|(
name|scan
argument_list|,
name|nbytes
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|scan
operator|+=
name|nbytes
expr_stmt|;
name|listend
operator|=
name|scan
operator|+
name|blocksz
expr_stmt|;
while|while
condition|(
name|scan
operator|<
name|listend
condition|)
block|{
name|scan
operator|+=
name|TARGET_FT_LONG_SIZE
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
name|add_psymbol_to_list
argument_list|(
name|scan
argument_list|,
name|strlen
argument_list|(
name|scan
argument_list|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_CONST
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|cu_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|scan
operator|+=
name|strlen
argument_list|(
name|scan
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	add_partial_symbol -- add symbol to partial symbol table  DESCRIPTION  	Given a DIE, if it is one of the types that we want to 	add to a partial symbol table, finish filling in the die info 	and then add a partial symbol table entry for it.  NOTES  	The caller must ensure that the DIE has a valid name attribute. */
end_comment

begin_function
specifier|static
name|void
name|add_partial_symbol
parameter_list|(
name|dip
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|dieinfo
modifier|*
name|dip
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
switch|switch
condition|(
name|dip
operator|->
name|die_tag
condition|)
block|{
case|case
name|TAG_global_subroutine
case|:
name|add_psymbol_to_list
argument_list|(
name|dip
operator|->
name|at_name
argument_list|,
name|strlen
argument_list|(
name|dip
operator|->
name|at_name
argument_list|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_BLOCK
argument_list|,
operator|&
name|objfile
operator|->
name|global_psymbols
argument_list|,
literal|0
argument_list|,
name|dip
operator|->
name|at_low_pc
argument_list|,
name|cu_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|TAG_global_variable
case|:
name|add_psymbol_to_list
argument_list|(
name|dip
operator|->
name|at_name
argument_list|,
name|strlen
argument_list|(
name|dip
operator|->
name|at_name
argument_list|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_STATIC
argument_list|,
operator|&
name|objfile
operator|->
name|global_psymbols
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|cu_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|TAG_subroutine
case|:
name|add_psymbol_to_list
argument_list|(
name|dip
operator|->
name|at_name
argument_list|,
name|strlen
argument_list|(
name|dip
operator|->
name|at_name
argument_list|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_BLOCK
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
literal|0
argument_list|,
name|dip
operator|->
name|at_low_pc
argument_list|,
name|cu_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|TAG_local_variable
case|:
name|add_psymbol_to_list
argument_list|(
name|dip
operator|->
name|at_name
argument_list|,
name|strlen
argument_list|(
name|dip
operator|->
name|at_name
argument_list|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_STATIC
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|cu_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|TAG_typedef
case|:
name|add_psymbol_to_list
argument_list|(
name|dip
operator|->
name|at_name
argument_list|,
name|strlen
argument_list|(
name|dip
operator|->
name|at_name
argument_list|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_TYPEDEF
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|cu_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|TAG_class_type
case|:
case|case
name|TAG_structure_type
case|:
case|case
name|TAG_union_type
case|:
case|case
name|TAG_enumeration_type
case|:
comment|/* Do not add opaque aggregate definitions to the psymtab.  */
if|if
condition|(
operator|!
name|dip
operator|->
name|has_at_byte_size
condition|)
break|break;
name|add_psymbol_to_list
argument_list|(
name|dip
operator|->
name|at_name
argument_list|,
name|strlen
argument_list|(
name|dip
operator|->
name|at_name
argument_list|)
argument_list|,
name|STRUCT_NAMESPACE
argument_list|,
name|LOC_TYPEDEF
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|cu_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|cu_language
operator|==
name|language_cplus
condition|)
block|{
comment|/* For C++, these implicitly act as typedefs as well. */
name|add_psymbol_to_list
argument_list|(
name|dip
operator|->
name|at_name
argument_list|,
name|strlen
argument_list|(
name|dip
operator|->
name|at_name
argument_list|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_TYPEDEF
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|cu_language
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	scan_partial_symbols -- scan DIE's within a single compilation unit  DESCRIPTION  	Process the DIE's within a single compilation unit, looking for 	interesting DIE's that contribute to the partial symbol table entry 	for this compilation unit.  NOTES  	There are some DIE's that may appear both at file scope and within 	the scope of a function.  We are only interested in the ones at file 	scope, and the only way to tell them apart is to keep track of the 	scope.  For example, consider the test case:  		static int i; 		main () { int j; }  	for which the relevant DWARF segment has the structure: 	 		0x51: 		0x23   global subrtn   sibling     0x9b 		                       name        main 		                       fund_type   FT_integer 		                       low_pc      0x800004cc 		                       high_pc     0x800004d4 		                             		0x74: 		0x23   local var       sibling     0x97 		                       name        j 		                       fund_type   FT_integer 		                       location    OP_BASEREG 0xe 		                                   OP_CONST 0xfffffffc 		                                   OP_ADD 		0x97: 		0x4          		 		0x9b: 		0x1d   local var       sibling     0xb8 		                       name        i 		                       fund_type   FT_integer 		                       location    OP_ADDR 0x800025dc 		                             		0xb8: 		0x4           	We want to include the symbol 'i' in the partial symbol table, but 	not the symbol 'j'.  In essence, we want to skip all the dies within 	the scope of a TAG_global_subroutine DIE.  	Don't attempt to add anonymous structures or unions since they have 	no name.  Anonymous enumerations however are processed, because we 	want to extract their member names (the check for a tag name is 	done later).  	Also, for variables and subroutines, check that this is the place 	where the actual definition occurs, rather than just a reference 	to an external.  */
end_comment

begin_function
specifier|static
name|void
name|scan_partial_symbols
parameter_list|(
name|thisdie
parameter_list|,
name|enddie
parameter_list|,
name|objfile
parameter_list|)
name|char
modifier|*
name|thisdie
decl_stmt|;
name|char
modifier|*
name|enddie
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|char
modifier|*
name|nextdie
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
name|struct
name|dieinfo
name|di
decl_stmt|;
while|while
condition|(
name|thisdie
operator|<
name|enddie
condition|)
block|{
name|basicdieinfo
argument_list|(
operator|&
name|di
argument_list|,
name|thisdie
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|di
operator|.
name|die_length
operator|<
name|SIZEOF_DIE_LENGTH
condition|)
block|{
break|break;
block|}
else|else
block|{
name|nextdie
operator|=
name|thisdie
operator|+
name|di
operator|.
name|die_length
expr_stmt|;
comment|/* To avoid getting complete die information for every die, we 	     only do it (below) for the cases we are interested in. */
switch|switch
condition|(
name|di
operator|.
name|die_tag
condition|)
block|{
case|case
name|TAG_global_subroutine
case|:
case|case
name|TAG_subroutine
case|:
name|completedieinfo
argument_list|(
operator|&
name|di
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|di
operator|.
name|at_name
operator|&&
operator|(
name|di
operator|.
name|has_at_low_pc
operator|||
name|di
operator|.
name|at_location
operator|)
condition|)
block|{
name|add_partial_symbol
argument_list|(
operator|&
name|di
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* If there is a sibling attribute, adjust the nextdie 		     pointer to skip the entire scope of the subroutine. 		     Apply some sanity checking to make sure we don't  		     overrun or underrun the range of remaining DIE's */
if|if
condition|(
name|di
operator|.
name|at_sibling
operator|!=
literal|0
condition|)
block|{
name|temp
operator|=
name|dbbase
operator|+
name|di
operator|.
name|at_sibling
operator|-
name|dbroff
expr_stmt|;
if|if
condition|(
operator|(
name|temp
operator|<
name|thisdie
operator|)
operator|||
operator|(
name|temp
operator|>=
name|enddie
operator|)
condition|)
block|{
name|complain
argument_list|(
operator|&
name|bad_die_ref
argument_list|,
name|DIE_ID
argument_list|,
name|DIE_NAME
argument_list|,
name|di
operator|.
name|at_sibling
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nextdie
operator|=
name|temp
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|TAG_global_variable
case|:
case|case
name|TAG_local_variable
case|:
name|completedieinfo
argument_list|(
operator|&
name|di
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|di
operator|.
name|at_name
operator|&&
operator|(
name|di
operator|.
name|has_at_low_pc
operator|||
name|di
operator|.
name|at_location
operator|)
condition|)
block|{
name|add_partial_symbol
argument_list|(
operator|&
name|di
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TAG_typedef
case|:
case|case
name|TAG_class_type
case|:
case|case
name|TAG_structure_type
case|:
case|case
name|TAG_union_type
case|:
name|completedieinfo
argument_list|(
operator|&
name|di
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|di
operator|.
name|at_name
condition|)
block|{
name|add_partial_symbol
argument_list|(
operator|&
name|di
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TAG_enumeration_type
case|:
name|completedieinfo
argument_list|(
operator|&
name|di
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|di
operator|.
name|at_name
condition|)
block|{
name|add_partial_symbol
argument_list|(
operator|&
name|di
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
name|add_enum_psymbol
argument_list|(
operator|&
name|di
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|thisdie
operator|=
name|nextdie
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	scan_compilation_units -- build a psymtab entry for each compilation  DESCRIPTION  	This is the top level dwarf parsing routine for building partial 	symbol tables.  	It scans from the beginning of the DWARF table looking for the first 	TAG_compile_unit DIE, and then follows the sibling chain to locate 	each additional TAG_compile_unit DIE.     	For each TAG_compile_unit DIE it creates a partial symtab structure, 	calls a subordinate routine to collect all the compilation unit's 	global DIE's, file scope DIEs, typedef DIEs, etc, and then links the 	new partial symtab structure into the partial symbol table.  It also 	records the appropriate information in the partial symbol table entry 	to allow the chunk of DIE's and line number table for this compilation 	unit to be located and re-read later, to generate a complete symbol 	table entry for the compilation unit.  	Thus it effectively partitions up a chunk of DIE's for multiple 	compilation units into smaller DIE chunks and line number tables, 	and associates them with a partial symbol table entry.  NOTES  	If any compilation unit has no line number table associated with 	it for some reason (a missing at_stmt_list attribute, rather than 	just one with a value of zero, which is valid) then we ensure that 	the recorded file offset is zero so that the routine which later 	reads line number table fragments knows that there is no fragment 	to read.  RETURNS  	Returns no value.   */
end_comment

begin_function
specifier|static
name|void
name|scan_compilation_units
parameter_list|(
name|thisdie
parameter_list|,
name|enddie
parameter_list|,
name|dbfoff
parameter_list|,
name|lnoffset
parameter_list|,
name|objfile
parameter_list|)
name|char
modifier|*
name|thisdie
decl_stmt|;
name|char
modifier|*
name|enddie
decl_stmt|;
name|file_ptr
name|dbfoff
decl_stmt|;
name|file_ptr
name|lnoffset
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|char
modifier|*
name|nextdie
decl_stmt|;
name|struct
name|dieinfo
name|di
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
name|int
name|culength
decl_stmt|;
name|int
name|curoff
decl_stmt|;
name|file_ptr
name|curlnoffset
decl_stmt|;
while|while
condition|(
name|thisdie
operator|<
name|enddie
condition|)
block|{
name|basicdieinfo
argument_list|(
operator|&
name|di
argument_list|,
name|thisdie
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|di
operator|.
name|die_length
operator|<
name|SIZEOF_DIE_LENGTH
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|di
operator|.
name|die_tag
operator|!=
name|TAG_compile_unit
condition|)
block|{
name|nextdie
operator|=
name|thisdie
operator|+
name|di
operator|.
name|die_length
expr_stmt|;
block|}
else|else
block|{
name|completedieinfo
argument_list|(
operator|&
name|di
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|set_cu_language
argument_list|(
operator|&
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|di
operator|.
name|at_sibling
operator|!=
literal|0
condition|)
block|{
name|nextdie
operator|=
name|dbbase
operator|+
name|di
operator|.
name|at_sibling
operator|-
name|dbroff
expr_stmt|;
block|}
else|else
block|{
name|nextdie
operator|=
name|thisdie
operator|+
name|di
operator|.
name|die_length
expr_stmt|;
block|}
name|curoff
operator|=
name|thisdie
operator|-
name|dbbase
expr_stmt|;
name|culength
operator|=
name|nextdie
operator|-
name|thisdie
expr_stmt|;
name|curlnoffset
operator|=
name|di
operator|.
name|has_at_stmt_list
condition|?
name|lnoffset
operator|+
name|di
operator|.
name|at_stmt_list
else|:
literal|0
expr_stmt|;
comment|/* First allocate a new partial symbol table structure */
name|pst
operator|=
name|start_psymtab_common
argument_list|(
name|objfile
argument_list|,
name|base_section_offsets
argument_list|,
name|di
operator|.
name|at_name
argument_list|,
name|di
operator|.
name|at_low_pc
argument_list|,
name|objfile
operator|->
name|global_psymbols
operator|.
name|next
argument_list|,
name|objfile
operator|->
name|static_psymbols
operator|.
name|next
argument_list|)
expr_stmt|;
name|pst
operator|->
name|texthigh
operator|=
name|di
operator|.
name|at_high_pc
expr_stmt|;
name|pst
operator|->
name|read_symtab_private
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dwfinfo
argument_list|)
argument_list|)
expr_stmt|;
name|DBFOFF
argument_list|(
name|pst
argument_list|)
operator|=
name|dbfoff
expr_stmt|;
name|DBROFF
argument_list|(
name|pst
argument_list|)
operator|=
name|curoff
expr_stmt|;
name|DBLENGTH
argument_list|(
name|pst
argument_list|)
operator|=
name|culength
expr_stmt|;
name|LNFOFF
argument_list|(
name|pst
argument_list|)
operator|=
name|curlnoffset
expr_stmt|;
name|pst
operator|->
name|read_symtab
operator|=
name|dwarf_psymtab_to_symtab
expr_stmt|;
comment|/* Now look for partial symbols */
name|scan_partial_symbols
argument_list|(
name|thisdie
operator|+
name|di
operator|.
name|die_length
argument_list|,
name|nextdie
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|pst
operator|->
name|n_global_syms
operator|=
name|objfile
operator|->
name|global_psymbols
operator|.
name|next
operator|-
operator|(
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|pst
operator|->
name|globals_offset
operator|)
expr_stmt|;
name|pst
operator|->
name|n_static_syms
operator|=
name|objfile
operator|->
name|static_psymbols
operator|.
name|next
operator|-
operator|(
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|pst
operator|->
name|statics_offset
operator|)
expr_stmt|;
name|sort_pst_symbols
argument_list|(
name|pst
argument_list|)
expr_stmt|;
comment|/* If there is already a psymtab or symtab for a file of this name, 	     remove it. (If there is a symtab, more drastic things also 	     happen.)  This happens in VxWorks.  */
name|free_named_symtabs
argument_list|(
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
name|thisdie
operator|=
name|nextdie
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	new_symbol -- make a symbol table entry for a new symbol  SYNOPSIS  	static struct symbol *new_symbol (struct dieinfo *dip, 					  struct objfile *objfile)  DESCRIPTION  	Given a pointer to a DWARF information entry, figure out if we need 	to make a symbol table entry for it, and if so, create a new entry 	and return a pointer to it.  */
end_comment

begin_function
specifier|static
name|struct
name|symbol
modifier|*
name|new_symbol
parameter_list|(
name|dip
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|dieinfo
modifier|*
name|dip
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|struct
name|symbol
modifier|*
name|sym
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|dip
operator|->
name|at_name
operator|!=
name|NULL
condition|)
block|{
name|sym
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|OBJSTAT
argument_list|(
name|objfile
argument_list|,
name|n_syms
operator|++
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|create_name
argument_list|(
name|dip
operator|->
name|at_name
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
comment|/* default assumptions */
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_STATIC
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|decode_die_type
argument_list|(
name|dip
argument_list|)
expr_stmt|;
comment|/* If this symbol is from a C++ compilation, then attempt to cache the 	 demangled form for future reference.  This is a typical time versus 	 space tradeoff, that was decided in favor of time because it sped up 	 C++ symbol lookups by a factor of about 20. */
name|SYMBOL_LANGUAGE
argument_list|(
name|sym
argument_list|)
operator|=
name|cu_language
expr_stmt|;
name|SYMBOL_INIT_DEMANGLED_NAME
argument_list|(
name|sym
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dip
operator|->
name|die_tag
condition|)
block|{
case|case
name|TAG_label
case|:
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|=
name|dip
operator|->
name|at_low_pc
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_LABEL
expr_stmt|;
break|break;
case|case
name|TAG_global_subroutine
case|:
case|case
name|TAG_subroutine
case|:
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|=
name|dip
operator|->
name|at_low_pc
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|lookup_function_type
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dip
operator|->
name|at_prototyped
condition|)
name|TYPE_FLAGS
argument_list|(
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
argument_list|)
operator||=
name|TYPE_FLAG_PROTOTYPED
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_BLOCK
expr_stmt|;
if|if
condition|(
name|dip
operator|->
name|die_tag
operator|==
name|TAG_global_subroutine
condition|)
block|{
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
name|list_in_scope
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TAG_global_variable
case|:
if|if
condition|(
name|dip
operator|->
name|at_location
operator|!=
name|NULL
condition|)
block|{
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|=
name|locval
argument_list|(
name|dip
argument_list|)
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
operator|&
name|global_symbols
argument_list|)
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_STATIC
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|+=
name|baseaddr
expr_stmt|;
block|}
break|break;
case|case
name|TAG_local_variable
case|:
if|if
condition|(
name|dip
operator|->
name|at_location
operator|!=
name|NULL
condition|)
block|{
name|int
name|loc
init|=
name|locval
argument_list|(
name|dip
argument_list|)
decl_stmt|;
if|if
condition|(
name|dip
operator|->
name|optimized_out
condition|)
block|{
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_OPTIMIZED_OUT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dip
operator|->
name|isreg
condition|)
block|{
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_REGISTER
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dip
operator|->
name|offreg
condition|)
block|{
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_BASEREG
expr_stmt|;
name|SYMBOL_BASEREG
argument_list|(
name|sym
argument_list|)
operator|=
name|dip
operator|->
name|basereg
expr_stmt|;
block|}
else|else
block|{
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_STATIC
expr_stmt|;
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|+=
name|baseaddr
expr_stmt|;
block|}
if|if
condition|(
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|==
name|LOC_STATIC
condition|)
block|{
comment|/* LOC_STATIC address class MUST use SYMBOL_VALUE_ADDRESS, 		     which may store to a bigger location than SYMBOL_VALUE. */
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|sym
argument_list|)
operator|=
name|loc
expr_stmt|;
block|}
else|else
block|{
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|loc
expr_stmt|;
block|}
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
name|list_in_scope
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TAG_formal_parameter
case|:
if|if
condition|(
name|dip
operator|->
name|at_location
operator|!=
name|NULL
condition|)
block|{
name|SYMBOL_VALUE
argument_list|(
name|sym
argument_list|)
operator|=
name|locval
argument_list|(
name|dip
argument_list|)
expr_stmt|;
block|}
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
name|list_in_scope
argument_list|)
expr_stmt|;
if|if
condition|(
name|dip
operator|->
name|isreg
condition|)
block|{
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_REGPARM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dip
operator|->
name|offreg
condition|)
block|{
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_BASEREG_ARG
expr_stmt|;
name|SYMBOL_BASEREG
argument_list|(
name|sym
argument_list|)
operator|=
name|dip
operator|->
name|basereg
expr_stmt|;
block|}
else|else
block|{
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_ARG
expr_stmt|;
block|}
break|break;
case|case
name|TAG_unspecified_parameters
case|:
comment|/* From varargs functions; gdb doesn't seem to have any interest in 	     this information, so just ignore it for now. (FIXME?) */
break|break;
case|case
name|TAG_class_type
case|:
case|case
name|TAG_structure_type
case|:
case|case
name|TAG_union_type
case|:
case|case
name|TAG_enumeration_type
case|:
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_TYPEDEF
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|STRUCT_NAMESPACE
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
name|list_in_scope
argument_list|)
expr_stmt|;
break|break;
case|case
name|TAG_typedef
case|:
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_TYPEDEF
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
name|list_in_scope
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Not a tag we recognize.  Hopefully we aren't processing trash 	     data, but since we must specifically ignore things we don't 	     recognize, there is nothing else we should do at this point. */
break|break;
block|}
block|}
return|return
operator|(
name|sym
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	synthesize_typedef -- make a symbol table entry for a "fake" typedef  SYNOPSIS  	static void synthesize_typedef (struct dieinfo *dip, 					struct objfile *objfile, 					struct type *type);  DESCRIPTION  	Given a pointer to a DWARF information entry, synthesize a typedef 	for the name in the DIE, using the specified type.  	This is used for C++ class, structs, unions, and enumerations to 	set up the tag name as a type.   */
end_comment

begin_function
specifier|static
name|void
name|synthesize_typedef
parameter_list|(
name|dip
parameter_list|,
name|objfile
parameter_list|,
name|type
parameter_list|)
name|struct
name|dieinfo
modifier|*
name|dip
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
name|struct
name|symbol
modifier|*
name|sym
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|dip
operator|->
name|at_name
operator|!=
name|NULL
condition|)
block|{
name|sym
operator|=
operator|(
expr|struct
name|symbol
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|OBJSTAT
argument_list|(
name|objfile
argument_list|,
name|n_syms
operator|++
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
operator|=
name|create_name
argument_list|(
name|dip
operator|->
name|at_name
argument_list|,
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|)
expr_stmt|;
name|SYMBOL_INIT_LANGUAGE_SPECIFIC
argument_list|(
name|sym
argument_list|,
name|cu_language
argument_list|)
expr_stmt|;
name|SYMBOL_TYPE
argument_list|(
name|sym
argument_list|)
operator|=
name|type
expr_stmt|;
name|SYMBOL_CLASS
argument_list|(
name|sym
argument_list|)
operator|=
name|LOC_TYPEDEF
expr_stmt|;
name|SYMBOL_NAMESPACE
argument_list|(
name|sym
argument_list|)
operator|=
name|VAR_NAMESPACE
expr_stmt|;
name|add_symbol_to_list
argument_list|(
name|sym
argument_list|,
name|list_in_scope
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	decode_mod_fund_type -- decode a modified fundamental type  SYNOPSIS  	static struct type *decode_mod_fund_type (char *typedata)  DESCRIPTION  	Decode a block of data containing a modified fundamental 	type specification.  TYPEDATA is a pointer to the block, 	which starts with a length containing the size of the rest 	of the block.  At the end of the block is a fundmental type 	code value that gives the fundamental type.  Everything 	in between are type modifiers.  	We simply compute the number of modifiers and call the general 	function decode_modified_type to do the actual work. */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|decode_mod_fund_type
parameter_list|(
name|typedata
parameter_list|)
name|char
modifier|*
name|typedata
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|typep
init|=
name|NULL
decl_stmt|;
name|unsigned
name|short
name|modcount
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
comment|/* Get the total size of the block, exclusive of the size itself */
name|nbytes
operator|=
name|attribute_size
argument_list|(
name|AT_mod_fund_type
argument_list|)
expr_stmt|;
name|modcount
operator|=
name|target_to_host
argument_list|(
name|typedata
argument_list|,
name|nbytes
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|current_objfile
argument_list|)
expr_stmt|;
name|typedata
operator|+=
name|nbytes
expr_stmt|;
comment|/* Deduct the size of the fundamental type bytes at the end of the block. */
name|modcount
operator|-=
name|attribute_size
argument_list|(
name|AT_fund_type
argument_list|)
expr_stmt|;
comment|/* Now do the actual decoding */
name|typep
operator|=
name|decode_modified_type
argument_list|(
name|typedata
argument_list|,
name|modcount
argument_list|,
name|AT_mod_fund_type
argument_list|)
expr_stmt|;
return|return
operator|(
name|typep
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	decode_mod_u_d_type -- decode a modified user defined type  SYNOPSIS  	static struct type *decode_mod_u_d_type (char *typedata)  DESCRIPTION  	Decode a block of data containing a modified user defined 	type specification.  TYPEDATA is a pointer to the block, 	which consists of a two byte length, containing the size 	of the rest of the block.  At the end of the block is a 	four byte value that gives a reference to a user defined type. 	Everything in between are type modifiers.  	We simply compute the number of modifiers and call the general 	function decode_modified_type to do the actual work. */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|decode_mod_u_d_type
parameter_list|(
name|typedata
parameter_list|)
name|char
modifier|*
name|typedata
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|typep
init|=
name|NULL
decl_stmt|;
name|unsigned
name|short
name|modcount
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
comment|/* Get the total size of the block, exclusive of the size itself */
name|nbytes
operator|=
name|attribute_size
argument_list|(
name|AT_mod_u_d_type
argument_list|)
expr_stmt|;
name|modcount
operator|=
name|target_to_host
argument_list|(
name|typedata
argument_list|,
name|nbytes
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|current_objfile
argument_list|)
expr_stmt|;
name|typedata
operator|+=
name|nbytes
expr_stmt|;
comment|/* Deduct the size of the reference type bytes at the end of the block. */
name|modcount
operator|-=
name|attribute_size
argument_list|(
name|AT_user_def_type
argument_list|)
expr_stmt|;
comment|/* Now do the actual decoding */
name|typep
operator|=
name|decode_modified_type
argument_list|(
name|typedata
argument_list|,
name|modcount
argument_list|,
name|AT_mod_u_d_type
argument_list|)
expr_stmt|;
return|return
operator|(
name|typep
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	decode_modified_type -- decode modified user or fundamental type  SYNOPSIS  	static struct type *decode_modified_type (char *modifiers, 	    unsigned short modcount, int mtype)  DESCRIPTION  	Decode a modified type, either a modified fundamental type or 	a modified user defined type.  MODIFIERS is a pointer to the 	block of bytes that define MODCOUNT modifiers.  Immediately 	following the last modifier is a short containing the fundamental 	type or a long containing the reference to the user defined 	type.  Which one is determined by MTYPE, which is either 	AT_mod_fund_type or AT_mod_u_d_type to indicate what modified 	type we are generating.  	We call ourself recursively to generate each modified type,` 	until MODCOUNT reaches zero, at which point we have consumed 	all the modifiers and generate either the fundamental type or 	user defined type.  When the recursion unwinds, each modifier 	is applied in turn to generate the full modified type.  NOTES  	If we find a modifier that we don't recognize, and it is not one 	of those reserved for application specific use, then we issue a 	warning and simply ignore the modifier.  BUGS  	We currently ignore MOD_const and MOD_volatile.  (FIXME)   */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|decode_modified_type
parameter_list|(
name|modifiers
parameter_list|,
name|modcount
parameter_list|,
name|mtype
parameter_list|)
name|char
modifier|*
name|modifiers
decl_stmt|;
name|unsigned
name|int
name|modcount
decl_stmt|;
name|int
name|mtype
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|typep
init|=
name|NULL
decl_stmt|;
name|unsigned
name|short
name|fundtype
decl_stmt|;
name|DIE_REF
name|die_ref
decl_stmt|;
name|char
name|modifier
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
if|if
condition|(
name|modcount
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|mtype
condition|)
block|{
case|case
name|AT_mod_fund_type
case|:
name|nbytes
operator|=
name|attribute_size
argument_list|(
name|AT_fund_type
argument_list|)
expr_stmt|;
name|fundtype
operator|=
name|target_to_host
argument_list|(
name|modifiers
argument_list|,
name|nbytes
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|current_objfile
argument_list|)
expr_stmt|;
name|typep
operator|=
name|decode_fund_type
argument_list|(
name|fundtype
argument_list|)
expr_stmt|;
break|break;
case|case
name|AT_mod_u_d_type
case|:
name|nbytes
operator|=
name|attribute_size
argument_list|(
name|AT_user_def_type
argument_list|)
expr_stmt|;
name|die_ref
operator|=
name|target_to_host
argument_list|(
name|modifiers
argument_list|,
name|nbytes
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|current_objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|typep
operator|=
name|lookup_utype
argument_list|(
name|die_ref
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|typep
operator|=
name|alloc_utype
argument_list|(
name|die_ref
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|complain
argument_list|(
operator|&
name|botched_modified_type
argument_list|,
name|DIE_ID
argument_list|,
name|DIE_NAME
argument_list|,
name|mtype
argument_list|)
expr_stmt|;
name|typep
operator|=
name|dwarf_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_INTEGER
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|modifier
operator|=
operator|*
name|modifiers
operator|++
expr_stmt|;
name|typep
operator|=
name|decode_modified_type
argument_list|(
name|modifiers
argument_list|,
operator|--
name|modcount
argument_list|,
name|mtype
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|modifier
condition|)
block|{
case|case
name|MOD_pointer_to
case|:
name|typep
operator|=
name|lookup_pointer_type
argument_list|(
name|typep
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_reference_to
case|:
name|typep
operator|=
name|lookup_reference_type
argument_list|(
name|typep
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_const
case|:
name|complain
argument_list|(
operator|&
name|const_ignored
argument_list|,
name|DIE_ID
argument_list|,
name|DIE_NAME
argument_list|)
expr_stmt|;
comment|/* FIXME */
break|break;
case|case
name|MOD_volatile
case|:
name|complain
argument_list|(
operator|&
name|volatile_ignored
argument_list|,
name|DIE_ID
argument_list|,
name|DIE_NAME
argument_list|)
expr_stmt|;
comment|/* FIXME */
break|break;
default|default:
if|if
condition|(
operator|!
operator|(
name|MOD_lo_user
operator|<=
operator|(
name|unsigned
name|char
operator|)
name|modifier
operator|&&
operator|(
name|unsigned
name|char
operator|)
name|modifier
operator|<=
name|MOD_hi_user
operator|)
condition|)
block|{
name|complain
argument_list|(
operator|&
name|unknown_type_modifier
argument_list|,
name|DIE_ID
argument_list|,
name|DIE_NAME
argument_list|,
name|modifier
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
return|return
operator|(
name|typep
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	decode_fund_type -- translate basic DWARF type to gdb base type  DESCRIPTION  	Given an integer that is one of the fundamental DWARF types, 	translate it to one of the basic internal gdb types and return 	a pointer to the appropriate gdb type (a "struct type *").  NOTES  	For robustness, if we are asked to translate a fundamental 	type that we are unprepared to deal with, we return int so 	callers can always depend upon a valid type being returned, 	and so gdb may at least do something reasonable by default. 	If the type is not in the range of those types defined as 	application specific types, we also issue a warning. */
end_comment

begin_function
specifier|static
name|struct
name|type
modifier|*
name|decode_fund_type
parameter_list|(
name|fundtype
parameter_list|)
name|unsigned
name|int
name|fundtype
decl_stmt|;
block|{
name|struct
name|type
modifier|*
name|typep
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|fundtype
condition|)
block|{
case|case
name|FT_void
case|:
name|typep
operator|=
name|dwarf_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_VOID
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_boolean
case|:
comment|/* Was FT_set in AT&T version */
name|typep
operator|=
name|dwarf_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_BOOLEAN
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_pointer
case|:
comment|/* (void *) */
name|typep
operator|=
name|dwarf_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_VOID
argument_list|)
expr_stmt|;
name|typep
operator|=
name|lookup_pointer_type
argument_list|(
name|typep
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_char
case|:
name|typep
operator|=
name|dwarf_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_CHAR
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_signed_char
case|:
name|typep
operator|=
name|dwarf_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_SIGNED_CHAR
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_unsigned_char
case|:
name|typep
operator|=
name|dwarf_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_UNSIGNED_CHAR
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_short
case|:
name|typep
operator|=
name|dwarf_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_SHORT
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_signed_short
case|:
name|typep
operator|=
name|dwarf_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_SIGNED_SHORT
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_unsigned_short
case|:
name|typep
operator|=
name|dwarf_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_UNSIGNED_SHORT
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_integer
case|:
name|typep
operator|=
name|dwarf_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_INTEGER
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_signed_integer
case|:
name|typep
operator|=
name|dwarf_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_SIGNED_INTEGER
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_unsigned_integer
case|:
name|typep
operator|=
name|dwarf_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_UNSIGNED_INTEGER
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_long
case|:
name|typep
operator|=
name|dwarf_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_LONG
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_signed_long
case|:
name|typep
operator|=
name|dwarf_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_SIGNED_LONG
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_unsigned_long
case|:
name|typep
operator|=
name|dwarf_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_UNSIGNED_LONG
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_long_long
case|:
name|typep
operator|=
name|dwarf_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_LONG_LONG
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_signed_long_long
case|:
name|typep
operator|=
name|dwarf_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_SIGNED_LONG_LONG
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_unsigned_long_long
case|:
name|typep
operator|=
name|dwarf_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_UNSIGNED_LONG_LONG
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_float
case|:
name|typep
operator|=
name|dwarf_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_FLOAT
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_dbl_prec_float
case|:
name|typep
operator|=
name|dwarf_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_DBL_PREC_FLOAT
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_ext_prec_float
case|:
name|typep
operator|=
name|dwarf_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_EXT_PREC_FLOAT
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_complex
case|:
name|typep
operator|=
name|dwarf_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_COMPLEX
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_dbl_prec_complex
case|:
name|typep
operator|=
name|dwarf_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_DBL_PREC_COMPLEX
argument_list|)
expr_stmt|;
break|break;
case|case
name|FT_ext_prec_complex
case|:
name|typep
operator|=
name|dwarf_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_EXT_PREC_COMPLEX
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|typep
operator|==
name|NULL
condition|)
block|{
name|typep
operator|=
name|dwarf_fundamental_type
argument_list|(
name|current_objfile
argument_list|,
name|FT_INTEGER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|FT_lo_user
operator|<=
name|fundtype
operator|&&
name|fundtype
operator|<=
name|FT_hi_user
operator|)
condition|)
block|{
name|complain
argument_list|(
operator|&
name|unexpected_fund_type
argument_list|,
name|DIE_ID
argument_list|,
name|DIE_NAME
argument_list|,
name|fundtype
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|typep
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	create_name -- allocate a fresh copy of a string on an obstack  DESCRIPTION  	Given a pointer to a string and a pointer to an obstack, allocates 	a fresh copy of the string on the specified obstack.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|create_name
parameter_list|(
name|name
parameter_list|,
name|obstackp
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|obstack
modifier|*
name|obstackp
decl_stmt|;
block|{
name|int
name|length
decl_stmt|;
name|char
modifier|*
name|newname
decl_stmt|;
name|length
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|newname
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|obstackp
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|newname
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|newname
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	basicdieinfo -- extract the minimal die info from raw die data  SYNOPSIS  	void basicdieinfo (char *diep, struct dieinfo *dip, 			   struct objfile *objfile)  DESCRIPTION  	Given a pointer to raw DIE data, and a pointer to an instance of a 	die info structure, this function extracts the basic information 	from the DIE data required to continue processing this DIE, along 	with some bookkeeping information about the DIE.  	The information we absolutely must have includes the DIE tag, 	and the DIE length.  If we need the sibling reference, then we 	will have to call completedieinfo() to process all the remaining 	DIE information.  	Note that since there is no guarantee that the data is properly 	aligned in memory for the type of access required (indirection 	through anything other than a char pointer), and there is no 	guarantee that it is in the same byte order as the gdb host, 	we call a function which deals with both alignment and byte 	swapping issues.  Possibly inefficient, but quite portable.  	We also take care of some other basic things at this point, such 	as ensuring that the instance of the die info structure starts 	out completely zero'd and that curdie is initialized for use 	in error reporting if we have a problem with the current die.  NOTES  	All DIE's must have at least a valid length, thus the minimum 	DIE size is SIZEOF_DIE_LENGTH.  In order to have a valid tag, the 	DIE size must be at least SIZEOF_DIE_TAG larger, otherwise they 	are forced to be TAG_padding DIES.  	Padding DIES must be at least SIZEOF_DIE_LENGTH in length, implying 	that if a padding DIE is used for alignment and the amount needed is 	less than SIZEOF_DIE_LENGTH, then the padding DIE has to be big 	enough to align to the next alignment boundry.  	We do some basic sanity checking here, such as verifying that the 	length of the die would not cause it to overrun the recorded end of 	the buffer holding the DIE info.  If we find a DIE that is either 	too small or too large, we force it's length to zero which should 	cause the caller to take appropriate action.  */
end_comment

begin_function
specifier|static
name|void
name|basicdieinfo
parameter_list|(
name|dip
parameter_list|,
name|diep
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|dieinfo
modifier|*
name|dip
decl_stmt|;
name|char
modifier|*
name|diep
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|curdie
operator|=
name|dip
expr_stmt|;
name|memset
argument_list|(
name|dip
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dieinfo
argument_list|)
argument_list|)
expr_stmt|;
name|dip
operator|->
name|die
operator|=
name|diep
expr_stmt|;
name|dip
operator|->
name|die_ref
operator|=
name|dbroff
operator|+
operator|(
name|diep
operator|-
name|dbbase
operator|)
expr_stmt|;
name|dip
operator|->
name|die_length
operator|=
name|target_to_host
argument_list|(
name|diep
argument_list|,
name|SIZEOF_DIE_LENGTH
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dip
operator|->
name|die_length
operator|<
name|SIZEOF_DIE_LENGTH
operator|)
operator|||
operator|(
operator|(
name|diep
operator|+
name|dip
operator|->
name|die_length
operator|)
operator|>
operator|(
name|dbbase
operator|+
name|dbsize
operator|)
operator|)
condition|)
block|{
name|complain
argument_list|(
operator|&
name|malformed_die
argument_list|,
name|DIE_ID
argument_list|,
name|DIE_NAME
argument_list|,
name|dip
operator|->
name|die_length
argument_list|)
expr_stmt|;
name|dip
operator|->
name|die_length
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dip
operator|->
name|die_length
operator|<
operator|(
name|SIZEOF_DIE_LENGTH
operator|+
name|SIZEOF_DIE_TAG
operator|)
condition|)
block|{
name|dip
operator|->
name|die_tag
operator|=
name|TAG_padding
expr_stmt|;
block|}
else|else
block|{
name|diep
operator|+=
name|SIZEOF_DIE_LENGTH
expr_stmt|;
name|dip
operator|->
name|die_tag
operator|=
name|target_to_host
argument_list|(
name|diep
argument_list|,
name|SIZEOF_DIE_TAG
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	completedieinfo -- finish reading the information for a given DIE  SYNOPSIS  	void completedieinfo (struct dieinfo *dip, struct objfile *objfile)  DESCRIPTION  	Given a pointer to an already partially initialized die info structure, 	scan the raw DIE data and finish filling in the die info structure 	from the various attributes found.     	Note that since there is no guarantee that the data is properly 	aligned in memory for the type of access required (indirection 	through anything other than a char pointer), and there is no 	guarantee that it is in the same byte order as the gdb host, 	we call a function which deals with both alignment and byte 	swapping issues.  Possibly inefficient, but quite portable.  NOTES  	Each time we are called, we increment the diecount variable, which 	keeps an approximate count of the number of dies processed for 	each compilation unit.  This information is presented to the user 	if the info_verbose flag is set.   */
end_comment

begin_function
specifier|static
name|void
name|completedieinfo
parameter_list|(
name|dip
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|dieinfo
modifier|*
name|dip
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|char
modifier|*
name|diep
decl_stmt|;
comment|/* Current pointer into raw DIE data */
name|char
modifier|*
name|end
decl_stmt|;
comment|/* Terminate DIE scan here */
name|unsigned
name|short
name|attr
decl_stmt|;
comment|/* Current attribute being scanned */
name|unsigned
name|short
name|form
decl_stmt|;
comment|/* Form of the attribute */
name|int
name|nbytes
decl_stmt|;
comment|/* Size of next field to read */
name|diecount
operator|++
expr_stmt|;
name|diep
operator|=
name|dip
operator|->
name|die
expr_stmt|;
name|end
operator|=
name|diep
operator|+
name|dip
operator|->
name|die_length
expr_stmt|;
name|diep
operator|+=
name|SIZEOF_DIE_LENGTH
operator|+
name|SIZEOF_DIE_TAG
expr_stmt|;
while|while
condition|(
name|diep
operator|<
name|end
condition|)
block|{
name|attr
operator|=
name|target_to_host
argument_list|(
name|diep
argument_list|,
name|SIZEOF_ATTRIBUTE
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|diep
operator|+=
name|SIZEOF_ATTRIBUTE
expr_stmt|;
if|if
condition|(
operator|(
name|nbytes
operator|=
name|attribute_size
argument_list|(
name|attr
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|complain
argument_list|(
operator|&
name|unknown_attribute_length
argument_list|,
name|DIE_ID
argument_list|,
name|DIE_NAME
argument_list|)
expr_stmt|;
name|diep
operator|=
name|end
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|attr
condition|)
block|{
case|case
name|AT_fund_type
case|:
name|dip
operator|->
name|at_fund_type
operator|=
name|target_to_host
argument_list|(
name|diep
argument_list|,
name|nbytes
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|AT_ordering
case|:
name|dip
operator|->
name|at_ordering
operator|=
name|target_to_host
argument_list|(
name|diep
argument_list|,
name|nbytes
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|AT_bit_offset
case|:
name|dip
operator|->
name|at_bit_offset
operator|=
name|target_to_host
argument_list|(
name|diep
argument_list|,
name|nbytes
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|AT_sibling
case|:
name|dip
operator|->
name|at_sibling
operator|=
name|target_to_host
argument_list|(
name|diep
argument_list|,
name|nbytes
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|AT_stmt_list
case|:
name|dip
operator|->
name|at_stmt_list
operator|=
name|target_to_host
argument_list|(
name|diep
argument_list|,
name|nbytes
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|dip
operator|->
name|has_at_stmt_list
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|AT_low_pc
case|:
name|dip
operator|->
name|at_low_pc
operator|=
name|target_to_host
argument_list|(
name|diep
argument_list|,
name|nbytes
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|dip
operator|->
name|at_low_pc
operator|+=
name|baseaddr
expr_stmt|;
name|dip
operator|->
name|has_at_low_pc
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|AT_high_pc
case|:
name|dip
operator|->
name|at_high_pc
operator|=
name|target_to_host
argument_list|(
name|diep
argument_list|,
name|nbytes
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|dip
operator|->
name|at_high_pc
operator|+=
name|baseaddr
expr_stmt|;
break|break;
case|case
name|AT_language
case|:
name|dip
operator|->
name|at_language
operator|=
name|target_to_host
argument_list|(
name|diep
argument_list|,
name|nbytes
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|AT_user_def_type
case|:
name|dip
operator|->
name|at_user_def_type
operator|=
name|target_to_host
argument_list|(
name|diep
argument_list|,
name|nbytes
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|AT_byte_size
case|:
name|dip
operator|->
name|at_byte_size
operator|=
name|target_to_host
argument_list|(
name|diep
argument_list|,
name|nbytes
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|dip
operator|->
name|has_at_byte_size
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|AT_bit_size
case|:
name|dip
operator|->
name|at_bit_size
operator|=
name|target_to_host
argument_list|(
name|diep
argument_list|,
name|nbytes
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|AT_member
case|:
name|dip
operator|->
name|at_member
operator|=
name|target_to_host
argument_list|(
name|diep
argument_list|,
name|nbytes
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|AT_discr
case|:
name|dip
operator|->
name|at_discr
operator|=
name|target_to_host
argument_list|(
name|diep
argument_list|,
name|nbytes
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|AT_location
case|:
name|dip
operator|->
name|at_location
operator|=
name|diep
expr_stmt|;
break|break;
case|case
name|AT_mod_fund_type
case|:
name|dip
operator|->
name|at_mod_fund_type
operator|=
name|diep
expr_stmt|;
break|break;
case|case
name|AT_subscr_data
case|:
name|dip
operator|->
name|at_subscr_data
operator|=
name|diep
expr_stmt|;
break|break;
case|case
name|AT_mod_u_d_type
case|:
name|dip
operator|->
name|at_mod_u_d_type
operator|=
name|diep
expr_stmt|;
break|break;
case|case
name|AT_element_list
case|:
name|dip
operator|->
name|at_element_list
operator|=
name|diep
expr_stmt|;
name|dip
operator|->
name|short_element_list
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|AT_short_element_list
case|:
name|dip
operator|->
name|at_element_list
operator|=
name|diep
expr_stmt|;
name|dip
operator|->
name|short_element_list
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|AT_discr_value
case|:
name|dip
operator|->
name|at_discr_value
operator|=
name|diep
expr_stmt|;
break|break;
case|case
name|AT_string_length
case|:
name|dip
operator|->
name|at_string_length
operator|=
name|diep
expr_stmt|;
break|break;
case|case
name|AT_name
case|:
name|dip
operator|->
name|at_name
operator|=
name|diep
expr_stmt|;
break|break;
case|case
name|AT_comp_dir
case|:
comment|/* For now, ignore any "hostname:" portion, since gdb doesn't 	     know how to deal with it.  (FIXME). */
name|dip
operator|->
name|at_comp_dir
operator|=
name|strrchr
argument_list|(
name|diep
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|dip
operator|->
name|at_comp_dir
operator|!=
name|NULL
condition|)
block|{
name|dip
operator|->
name|at_comp_dir
operator|++
expr_stmt|;
block|}
else|else
block|{
name|dip
operator|->
name|at_comp_dir
operator|=
name|diep
expr_stmt|;
block|}
break|break;
case|case
name|AT_producer
case|:
name|dip
operator|->
name|at_producer
operator|=
name|diep
expr_stmt|;
break|break;
case|case
name|AT_start_scope
case|:
name|dip
operator|->
name|at_start_scope
operator|=
name|target_to_host
argument_list|(
name|diep
argument_list|,
name|nbytes
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|AT_stride_size
case|:
name|dip
operator|->
name|at_stride_size
operator|=
name|target_to_host
argument_list|(
name|diep
argument_list|,
name|nbytes
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|AT_src_info
case|:
name|dip
operator|->
name|at_src_info
operator|=
name|target_to_host
argument_list|(
name|diep
argument_list|,
name|nbytes
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|AT_prototyped
case|:
name|dip
operator|->
name|at_prototyped
operator|=
name|diep
expr_stmt|;
break|break;
default|default:
comment|/* Found an attribute that we are unprepared to handle.  However 	     it is specifically one of the design goals of DWARF that 	     consumers should ignore unknown attributes.  As long as the 	     form is one that we recognize (so we know how to skip it), 	     we can just ignore the unknown attribute. */
break|break;
block|}
name|form
operator|=
name|FORM_FROM_ATTR
argument_list|(
name|attr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|form
condition|)
block|{
case|case
name|FORM_DATA2
case|:
name|diep
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|FORM_DATA4
case|:
case|case
name|FORM_REF
case|:
name|diep
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
name|FORM_DATA8
case|:
name|diep
operator|+=
literal|8
expr_stmt|;
break|break;
case|case
name|FORM_ADDR
case|:
name|diep
operator|+=
name|TARGET_FT_POINTER_SIZE
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FORM_BLOCK2
case|:
name|diep
operator|+=
literal|2
operator|+
name|target_to_host
argument_list|(
name|diep
argument_list|,
name|nbytes
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FORM_BLOCK4
case|:
name|diep
operator|+=
literal|4
operator|+
name|target_to_host
argument_list|(
name|diep
argument_list|,
name|nbytes
argument_list|,
name|GET_UNSIGNED
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
break|break;
case|case
name|FORM_STRING
case|:
name|diep
operator|+=
name|strlen
argument_list|(
name|diep
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
default|default:
name|complain
argument_list|(
operator|&
name|unknown_attribute_form
argument_list|,
name|DIE_ID
argument_list|,
name|DIE_NAME
argument_list|,
name|form
argument_list|)
expr_stmt|;
name|diep
operator|=
name|end
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	target_to_host -- swap in target data to host  SYNOPSIS  	target_to_host (char *from, int nbytes, int signextend, 			struct objfile *objfile)  DESCRIPTION  	Given pointer to data in target format in FROM, a byte count for 	the size of the data in NBYTES, a flag indicating whether or not 	the data is signed in SIGNEXTEND, and a pointer to the current 	objfile in OBJFILE, convert the data to host format and return 	the converted value.  NOTES  	FIXME:  If we read data that is known to be signed, and expect to 	use it as signed data, then we need to explicitly sign extend the 	result until the bfd library is able to do this for us.  	FIXME: Would a 32 bit target ever need an 8 byte result?   */
end_comment

begin_function
specifier|static
name|CORE_ADDR
name|target_to_host
parameter_list|(
name|from
parameter_list|,
name|nbytes
parameter_list|,
name|signextend
parameter_list|,
name|objfile
parameter_list|)
name|char
modifier|*
name|from
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
name|int
name|signextend
decl_stmt|;
comment|/* FIXME:  Unused */
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|CORE_ADDR
name|rtnval
decl_stmt|;
switch|switch
condition|(
name|nbytes
condition|)
block|{
case|case
literal|8
case|:
name|rtnval
operator|=
name|bfd_get_64
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|from
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|rtnval
operator|=
name|bfd_get_32
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|from
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|rtnval
operator|=
name|bfd_get_16
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|from
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|rtnval
operator|=
name|bfd_get_8
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|from
argument_list|)
expr_stmt|;
break|break;
default|default:
name|complain
argument_list|(
operator|&
name|no_bfd_get_N
argument_list|,
name|DIE_ID
argument_list|,
name|DIE_NAME
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|rtnval
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|rtnval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  LOCAL FUNCTION  	attribute_size -- compute size of data for a DWARF attribute  SYNOPSIS  	static int attribute_size (unsigned int attr)  DESCRIPTION  	Given a DWARF attribute in ATTR, compute the size of the first 	piece of data associated with this attribute and return that 	size.  	Returns -1 for unrecognized attributes.   */
end_comment

begin_function
specifier|static
name|int
name|attribute_size
parameter_list|(
name|attr
parameter_list|)
name|unsigned
name|int
name|attr
decl_stmt|;
block|{
name|int
name|nbytes
decl_stmt|;
comment|/* Size of next data for this attribute */
name|unsigned
name|short
name|form
decl_stmt|;
comment|/* Form of the attribute */
name|form
operator|=
name|FORM_FROM_ATTR
argument_list|(
name|attr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|form
condition|)
block|{
case|case
name|FORM_STRING
case|:
comment|/* A variable length field is next */
name|nbytes
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FORM_DATA2
case|:
comment|/* Next 2 byte field is the data itself */
case|case
name|FORM_BLOCK2
case|:
comment|/* Next 2 byte field is a block length */
name|nbytes
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|FORM_DATA4
case|:
comment|/* Next 4 byte field is the data itself */
case|case
name|FORM_BLOCK4
case|:
comment|/* Next 4 byte field is a block length */
case|case
name|FORM_REF
case|:
comment|/* Next 4 byte field is a DIE offset */
name|nbytes
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|FORM_DATA8
case|:
comment|/* Next 8 byte field is the data itself */
name|nbytes
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|FORM_ADDR
case|:
comment|/* Next field size is target sizeof(void *) */
name|nbytes
operator|=
name|TARGET_FT_POINTER_SIZE
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
break|break;
default|default:
name|complain
argument_list|(
operator|&
name|unknown_attribute_form
argument_list|,
name|DIE_ID
argument_list|,
name|DIE_NAME
argument_list|,
name|form
argument_list|)
expr_stmt|;
name|nbytes
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|nbytes
operator|)
return|;
block|}
end_function

end_unit

