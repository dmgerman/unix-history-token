begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Target-dependent code for the Fujitsu FR30.    Copyright 1999, Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_comment
comment|/* Function: pop_frame    This routine gets called when either the user uses the `return'    command, or the call dummy breakpoint gets hit.  */
end_comment

begin_function
name|void
name|fr30_pop_frame
parameter_list|()
block|{
name|struct
name|frame_info
modifier|*
name|frame
init|=
name|get_current_frame
argument_list|()
decl_stmt|;
name|int
name|regnum
decl_stmt|;
name|CORE_ADDR
name|sp
init|=
name|read_register
argument_list|(
name|SP_REGNUM
argument_list|)
decl_stmt|;
if|if
condition|(
name|PC_IN_CALL_DUMMY
argument_list|(
name|frame
operator|->
name|pc
argument_list|,
name|frame
operator|->
name|frame
argument_list|,
name|frame
operator|->
name|frame
argument_list|)
condition|)
name|generic_pop_dummy_frame
argument_list|()
expr_stmt|;
else|else
block|{
name|write_register
argument_list|(
name|PC_REGNUM
argument_list|,
name|FRAME_SAVED_PC
argument_list|(
name|frame
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|regnum
operator|=
literal|0
init|;
name|regnum
operator|<
name|NUM_REGS
condition|;
name|regnum
operator|++
control|)
if|if
condition|(
name|frame
operator|->
name|fsr
operator|.
name|regs
index|[
name|regnum
index|]
operator|!=
literal|0
condition|)
block|{
name|write_register
argument_list|(
name|regnum
argument_list|,
name|read_memory_unsigned_integer
argument_list|(
name|frame
operator|->
name|fsr
operator|.
name|regs
index|[
name|regnum
index|]
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|write_register
argument_list|(
name|SP_REGNUM
argument_list|,
name|sp
operator|+
name|frame
operator|->
name|framesize
argument_list|)
expr_stmt|;
block|}
name|flush_cached_frames
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function: skip_prologue    Return the address of the first code past the prologue of the function.  */
end_comment

begin_function
name|CORE_ADDR
name|fr30_skip_prologue
parameter_list|(
name|CORE_ADDR
name|pc
parameter_list|)
block|{
name|CORE_ADDR
name|func_addr
decl_stmt|,
name|func_end
decl_stmt|;
comment|/* See what the symbol table says */
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|pc
argument_list|,
name|NULL
argument_list|,
operator|&
name|func_addr
argument_list|,
operator|&
name|func_end
argument_list|)
condition|)
block|{
name|struct
name|symtab_and_line
name|sal
decl_stmt|;
name|sal
operator|=
name|find_pc_line
argument_list|(
name|func_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sal
operator|.
name|line
operator|!=
literal|0
operator|&&
name|sal
operator|.
name|end
operator|<
name|func_end
condition|)
block|{
return|return
name|sal
operator|.
name|end
return|;
block|}
block|}
comment|/* Either we didn't find the start of this function (nothing we can do),    or there's no line info, or the line after the prologue is after    the end of the function (there probably isn't a prologue). */
return|return
name|pc
return|;
block|}
end_function

begin_comment
comment|/* Function: push_arguments    Setup arguments and RP for a call to the target.  First four args    go in FIRST_ARGREG -> LAST_ARGREG, subsequent args go on stack...    Structs are passed by reference.  XXX not right now Z.R.    64 bit quantities (doubles and long longs) may be split between    the regs and the stack.    When calling a function that returns a struct, a pointer to the struct    is passed in as a secret first argument (always in FIRST_ARGREG).     Stack space for the args has NOT been allocated: that job is up to us. */
end_comment

begin_function
name|CORE_ADDR
name|fr30_push_arguments
parameter_list|(
name|nargs
parameter_list|,
name|args
parameter_list|,
name|sp
parameter_list|,
name|struct_return
parameter_list|,
name|struct_addr
parameter_list|)
name|int
name|nargs
decl_stmt|;
name|value_ptr
modifier|*
name|args
decl_stmt|;
name|CORE_ADDR
name|sp
decl_stmt|;
name|int
name|struct_return
decl_stmt|;
name|CORE_ADDR
name|struct_addr
decl_stmt|;
block|{
name|int
name|argreg
decl_stmt|;
name|int
name|argnum
decl_stmt|;
name|int
name|stack_offset
decl_stmt|;
struct|struct
name|stack_arg
block|{
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|}
struct|;
name|struct
name|stack_arg
modifier|*
name|stack_args
init|=
operator|(
expr|struct
name|stack_arg
operator|*
operator|)
name|alloca
argument_list|(
name|nargs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|stack_arg
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|nstack_args
init|=
literal|0
decl_stmt|;
name|argreg
operator|=
name|FIRST_ARGREG
expr_stmt|;
comment|/* the struct_return pointer occupies the first parameter-passing reg */
if|if
condition|(
name|struct_return
condition|)
name|write_register
argument_list|(
name|argreg
operator|++
argument_list|,
name|struct_addr
argument_list|)
expr_stmt|;
name|stack_offset
operator|=
literal|0
expr_stmt|;
comment|/* Process args from left to right.  Store as many as allowed in 	registers, save the rest to be pushed on the stack */
for|for
control|(
name|argnum
operator|=
literal|0
init|;
name|argnum
operator|<
name|nargs
condition|;
name|argnum
operator|++
control|)
block|{
name|char
modifier|*
name|val
decl_stmt|;
name|value_ptr
name|arg
init|=
name|args
index|[
name|argnum
index|]
decl_stmt|;
name|struct
name|type
modifier|*
name|arg_type
init|=
name|check_typedef
argument_list|(
name|VALUE_TYPE
argument_list|(
name|arg
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|target_type
init|=
name|TYPE_TARGET_TYPE
argument_list|(
name|arg_type
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|arg_type
argument_list|)
decl_stmt|;
name|enum
name|type_code
name|typecode
init|=
name|TYPE_CODE
argument_list|(
name|arg_type
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|regval
decl_stmt|;
name|int
name|newarg
decl_stmt|;
name|val
operator|=
operator|(
name|char
operator|*
operator|)
name|VALUE_CONTENTS
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|{
comment|/* Copy the argument to general registers or the stack in 	     register-sized pieces.  Large arguments are split between 	     registers and stack.  */
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|argreg
operator|<=
name|LAST_ARGREG
condition|)
block|{
name|int
name|partial_len
init|=
name|len
operator|<
name|REGISTER_SIZE
condition|?
name|len
else|:
name|REGISTER_SIZE
decl_stmt|;
name|regval
operator|=
name|extract_address
argument_list|(
name|val
argument_list|,
name|partial_len
argument_list|)
expr_stmt|;
comment|/* It's a simple argument being passed in a general 		     register.  */
name|write_register
argument_list|(
name|argreg
argument_list|,
name|regval
argument_list|)
expr_stmt|;
name|argreg
operator|++
expr_stmt|;
name|len
operator|-=
name|partial_len
expr_stmt|;
name|val
operator|+=
name|partial_len
expr_stmt|;
block|}
else|else
block|{
comment|/* keep for later pushing */
name|stack_args
index|[
name|nstack_args
index|]
operator|.
name|val
operator|=
name|val
expr_stmt|;
name|stack_args
index|[
name|nstack_args
operator|++
index|]
operator|.
name|len
operator|=
name|len
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/* now do the real stack pushing, process args right to left */
while|while
condition|(
name|nstack_args
operator|--
condition|)
block|{
name|sp
operator|-=
name|stack_args
index|[
name|nstack_args
index|]
operator|.
name|len
expr_stmt|;
name|write_memory
argument_list|(
name|sp
argument_list|,
name|stack_args
index|[
name|nstack_args
index|]
operator|.
name|val
argument_list|,
name|stack_args
index|[
name|nstack_args
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* Return adjusted stack pointer.  */
return|return
name|sp
return|;
block|}
end_function

begin_macro
name|_initialize_fr30_tdep
argument_list|()
end_macro

begin_block
block|{
specifier|extern
name|int
name|print_insn_fr30
parameter_list|(
name|bfd_vma
parameter_list|,
name|disassemble_info
modifier|*
parameter_list|)
function_decl|;
name|tm_print_insn
operator|=
name|print_insn_fr30
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Function: check_prologue_cache    Check if prologue for this frame's PC has already been scanned.    If it has, copy the relevant information about that prologue and    return non-zero.  Otherwise do not copy anything and return zero.     The information saved in the cache includes:      * the frame register number;      * the size of the stack frame;      * the offsets of saved regs (relative to the old SP); and      * the offset from the stack pointer to the frame pointer     The cache contains only one entry, since this is adequate    for the typical sequence of prologue scan requests we get.    When performing a backtrace, GDB will usually ask to scan    the same function twice in a row (once to get the frame chain,    and once to fill in the extra frame information). */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|frame_info
name|prologue_cache
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|check_prologue_cache
parameter_list|(
name|fi
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|fi
operator|->
name|pc
operator|==
name|prologue_cache
operator|.
name|pc
condition|)
block|{
name|fi
operator|->
name|framereg
operator|=
name|prologue_cache
operator|.
name|framereg
expr_stmt|;
name|fi
operator|->
name|framesize
operator|=
name|prologue_cache
operator|.
name|framesize
expr_stmt|;
name|fi
operator|->
name|frameoffset
operator|=
name|prologue_cache
operator|.
name|frameoffset
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|NUM_REGS
condition|;
name|i
operator|++
control|)
name|fi
operator|->
name|fsr
operator|.
name|regs
index|[
name|i
index|]
operator|=
name|prologue_cache
operator|.
name|fsr
operator|.
name|regs
index|[
name|i
index|]
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Function: save_prologue_cache    Copy the prologue information from fi to the prologue cache. */
end_comment

begin_function
specifier|static
name|void
name|save_prologue_cache
parameter_list|(
name|fi
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|prologue_cache
operator|.
name|pc
operator|=
name|fi
operator|->
name|pc
expr_stmt|;
name|prologue_cache
operator|.
name|framereg
operator|=
name|fi
operator|->
name|framereg
expr_stmt|;
name|prologue_cache
operator|.
name|framesize
operator|=
name|fi
operator|->
name|framesize
expr_stmt|;
name|prologue_cache
operator|.
name|frameoffset
operator|=
name|fi
operator|->
name|frameoffset
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|NUM_REGS
condition|;
name|i
operator|++
control|)
block|{
name|prologue_cache
operator|.
name|fsr
operator|.
name|regs
index|[
name|i
index|]
operator|=
name|fi
operator|->
name|fsr
operator|.
name|regs
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Function: scan_prologue    Scan the prologue of the function that contains PC, and record what    we find in PI.  PI->fsr must be zeroed by the called.  Returns the    pc after the prologue.  Note that the addresses saved in pi->fsr    are actually just frame relative (negative offsets from the frame    pointer).  This is because we don't know the actual value of the    frame pointer yet.  In some circumstances, the frame pointer can't    be determined till after we have scanned the prologue.  */
end_comment

begin_function
specifier|static
name|void
name|fr30_scan_prologue
parameter_list|(
name|fi
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
block|{
name|int
name|sp_offset
decl_stmt|,
name|fp_offset
decl_stmt|;
name|CORE_ADDR
name|prologue_start
decl_stmt|,
name|prologue_end
decl_stmt|,
name|current_pc
decl_stmt|;
comment|/* Check if this function is already in the cache of frame information. */
if|if
condition|(
name|check_prologue_cache
argument_list|(
name|fi
argument_list|)
condition|)
return|return;
comment|/* Assume there is no frame until proven otherwise.  */
name|fi
operator|->
name|framereg
operator|=
name|SP_REGNUM
expr_stmt|;
name|fi
operator|->
name|framesize
operator|=
literal|0
expr_stmt|;
name|fi
operator|->
name|frameoffset
operator|=
literal|0
expr_stmt|;
comment|/* Find the function prologue.  If we can't find the function in      the symbol table, peek in the stack frame to find the PC.  */
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
name|NULL
argument_list|,
operator|&
name|prologue_start
argument_list|,
operator|&
name|prologue_end
argument_list|)
condition|)
block|{
comment|/* Assume the prologue is everything between the first instruction          in the function and the first source line.  */
name|struct
name|symtab_and_line
name|sal
init|=
name|find_pc_line
argument_list|(
name|prologue_start
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|sal
operator|.
name|line
operator|==
literal|0
condition|)
comment|/* no line info, use current PC */
name|prologue_end
operator|=
name|fi
operator|->
name|pc
expr_stmt|;
elseif|else
if|if
condition|(
name|sal
operator|.
name|end
operator|<
name|prologue_end
condition|)
comment|/* next line begins after fn end */
name|prologue_end
operator|=
name|sal
operator|.
name|end
expr_stmt|;
comment|/* (probably means no prologue)  */
block|}
else|else
block|{
comment|/* XXX Z.R. What now??? The following is entirely bogus */
name|prologue_start
operator|=
operator|(
name|read_memory_integer
argument_list|(
name|fi
operator|->
name|frame
argument_list|,
literal|4
argument_list|)
operator|&
literal|0x03fffffc
operator|)
operator|-
literal|12
expr_stmt|;
name|prologue_end
operator|=
name|prologue_start
operator|+
literal|40
expr_stmt|;
block|}
comment|/* Now search the prologue looking for instructions that set up the      frame pointer, adjust the stack pointer, and save registers.  */
name|sp_offset
operator|=
name|fp_offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|current_pc
operator|=
name|prologue_start
init|;
name|current_pc
operator|<
name|prologue_end
condition|;
name|current_pc
operator|+=
literal|2
control|)
block|{
name|unsigned
name|int
name|insn
decl_stmt|;
name|insn
operator|=
name|read_memory_unsigned_integer
argument_list|(
name|current_pc
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xfe00
operator|)
operator|==
literal|0x8e00
condition|)
comment|/* stm0 or stm1 */
block|{
name|int
name|reg
decl_stmt|,
name|mask
init|=
name|insn
operator|&
literal|0xff
decl_stmt|;
comment|/* scan in one sweep - create virtual 16-bit mask from either insn's mask */
if|if
condition|(
operator|(
name|insn
operator|&
literal|0x0100
operator|)
operator|==
literal|0
condition|)
block|{
name|mask
operator|<<=
literal|8
expr_stmt|;
comment|/* stm0 - move to upper byte in virtual mask */
block|}
comment|/* Calculate offsets of saved registers (to be turned later into addresses). */
for|for
control|(
name|reg
operator|=
name|R4_REGNUM
init|;
name|reg
operator|<=
name|R11_REGNUM
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|mask
operator|&
operator|(
literal|1
operator|<<
operator|(
literal|15
operator|-
name|reg
operator|)
operator|)
condition|)
block|{
name|sp_offset
operator|-=
literal|4
expr_stmt|;
name|fi
operator|->
name|fsr
operator|.
name|regs
index|[
name|reg
index|]
operator|=
name|sp_offset
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xfff0
operator|)
operator|==
literal|0x1700
condition|)
comment|/* st rx,@-r15 */
block|{
name|int
name|reg
init|=
name|insn
operator|&
literal|0xf
decl_stmt|;
name|sp_offset
operator|-=
literal|4
expr_stmt|;
name|fi
operator|->
name|fsr
operator|.
name|regs
index|[
name|reg
index|]
operator|=
name|sp_offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xff00
operator|)
operator|==
literal|0x0f00
condition|)
comment|/* enter */
block|{
name|fp_offset
operator|=
name|fi
operator|->
name|fsr
operator|.
name|regs
index|[
name|FP_REGNUM
index|]
operator|=
name|sp_offset
operator|-
literal|4
expr_stmt|;
name|sp_offset
operator|-=
literal|4
operator|*
operator|(
name|insn
operator|&
literal|0xff
operator|)
expr_stmt|;
name|fi
operator|->
name|framereg
operator|=
name|FP_REGNUM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|insn
operator|==
literal|0x1781
condition|)
comment|/* st rp,@-sp */
block|{
name|sp_offset
operator|-=
literal|4
expr_stmt|;
name|fi
operator|->
name|fsr
operator|.
name|regs
index|[
name|RP_REGNUM
index|]
operator|=
name|sp_offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|insn
operator|==
literal|0x170e
condition|)
comment|/* st fp,@-sp */
block|{
name|sp_offset
operator|-=
literal|4
expr_stmt|;
name|fi
operator|->
name|fsr
operator|.
name|regs
index|[
name|FP_REGNUM
index|]
operator|=
name|sp_offset
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|insn
operator|==
literal|0x8bfe
condition|)
comment|/* mov sp,fp */
block|{
name|fi
operator|->
name|framereg
operator|=
name|FP_REGNUM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xff00
operator|)
operator|==
literal|0xa300
condition|)
comment|/* addsp xx */
block|{
name|sp_offset
operator|+=
literal|4
operator|*
call|(
name|signed
name|char
call|)
argument_list|(
name|insn
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|insn
operator|&
literal|0xff0f
operator|)
operator|==
literal|0x9b00
operator|&&
comment|/* ldi:20 xx,r0 */
name|read_memory_unsigned_integer
argument_list|(
name|current_pc
operator|+
literal|4
argument_list|,
literal|2
argument_list|)
operator|==
literal|0xac0f
condition|)
comment|/* sub r0,sp */
block|{
comment|/* large stack adjustment */
name|sp_offset
operator|-=
operator|(
operator|(
operator|(
name|insn
operator|&
literal|0xf0
operator|)
operator|<<
literal|12
operator|)
operator||
name|read_memory_unsigned_integer
argument_list|(
name|current_pc
operator|+
literal|2
argument_list|,
literal|2
argument_list|)
operator|)
expr_stmt|;
name|current_pc
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|insn
operator|==
literal|0x9f80
operator|&&
comment|/* ldi:32 xx,r0 */
name|read_memory_unsigned_integer
argument_list|(
name|current_pc
operator|+
literal|6
argument_list|,
literal|2
argument_list|)
operator|==
literal|0xac0f
condition|)
comment|/* sub r0,sp */
block|{
comment|/* large stack adjustment */
name|sp_offset
operator|-=
operator|(
name|read_memory_unsigned_integer
argument_list|(
name|current_pc
operator|+
literal|2
argument_list|,
literal|2
argument_list|)
operator|<<
literal|16
operator||
name|read_memory_unsigned_integer
argument_list|(
name|current_pc
operator|+
literal|4
argument_list|,
literal|2
argument_list|)
operator|)
expr_stmt|;
name|current_pc
operator|+=
literal|6
expr_stmt|;
block|}
block|}
comment|/* The frame size is just the negative of the offset (from the original SP)      of the last thing thing we pushed on the stack.  The frame offset is      [new FP] - [new SP].  */
name|fi
operator|->
name|framesize
operator|=
operator|-
name|sp_offset
expr_stmt|;
name|fi
operator|->
name|frameoffset
operator|=
name|fp_offset
operator|-
name|sp_offset
expr_stmt|;
name|save_prologue_cache
argument_list|(
name|fi
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Function: init_extra_frame_info    Setup the frame's frame pointer, pc, and frame addresses for saved    registers.  Most of the work is done in scan_prologue().     Note that when we are called for the last frame (currently active frame),    that fi->pc and fi->frame will already be setup.  However, fi->frame will    be valid only if this routine uses FP.  For previous frames, fi-frame will    always be correct (since that is derived from fr30_frame_chain ()).     We can be called with the PC in the call dummy under two circumstances.    First, during normal backtracing, second, while figuring out the frame    pointer just prior to calling the target function (see run_stack_dummy).  */
end_comment

begin_function
name|void
name|fr30_init_extra_frame_info
parameter_list|(
name|fi
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
block|{
name|int
name|reg
decl_stmt|;
if|if
condition|(
name|fi
operator|->
name|next
condition|)
name|fi
operator|->
name|pc
operator|=
name|FRAME_SAVED_PC
argument_list|(
name|fi
operator|->
name|next
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|fi
operator|->
name|fsr
operator|.
name|regs
argument_list|,
literal|'\000'
argument_list|,
sizeof|sizeof
name|fi
operator|->
name|fsr
operator|.
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|PC_IN_CALL_DUMMY
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
name|fi
operator|->
name|frame
argument_list|,
name|fi
operator|->
name|frame
argument_list|)
condition|)
block|{
comment|/* We need to setup fi->frame here because run_stack_dummy gets it wrong 	 by assuming it's always FP.  */
name|fi
operator|->
name|frame
operator|=
name|generic_read_register_dummy
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
name|fi
operator|->
name|frame
argument_list|,
name|SP_REGNUM
argument_list|)
expr_stmt|;
name|fi
operator|->
name|framesize
operator|=
literal|0
expr_stmt|;
name|fi
operator|->
name|frameoffset
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|fr30_scan_prologue
argument_list|(
name|fi
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fi
operator|->
name|next
condition|)
comment|/* this is the innermost frame? */
name|fi
operator|->
name|frame
operator|=
name|read_register
argument_list|(
name|fi
operator|->
name|framereg
argument_list|)
expr_stmt|;
elseif|else
comment|/* not the innermost frame */
comment|/* If we have an FP,  the callee saved it. */
if|if
condition|(
name|fi
operator|->
name|framereg
operator|==
name|FP_REGNUM
condition|)
if|if
condition|(
name|fi
operator|->
name|next
operator|->
name|fsr
operator|.
name|regs
index|[
name|fi
operator|->
name|framereg
index|]
operator|!=
literal|0
condition|)
name|fi
operator|->
name|frame
operator|=
name|read_memory_integer
argument_list|(
name|fi
operator|->
name|next
operator|->
name|fsr
operator|.
name|regs
index|[
name|fi
operator|->
name|framereg
index|]
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Calculate actual addresses of saved registers using offsets determined          by fr30_scan_prologue.  */
for|for
control|(
name|reg
operator|=
literal|0
init|;
name|reg
operator|<
name|NUM_REGS
condition|;
name|reg
operator|++
control|)
if|if
condition|(
name|fi
operator|->
name|fsr
operator|.
name|regs
index|[
name|reg
index|]
operator|!=
literal|0
condition|)
block|{
name|fi
operator|->
name|fsr
operator|.
name|regs
index|[
name|reg
index|]
operator|+=
name|fi
operator|->
name|frame
operator|+
name|fi
operator|->
name|framesize
operator|-
name|fi
operator|->
name|frameoffset
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Function: find_callers_reg    Find REGNUM on the stack.  Otherwise, it's in an active register.    One thing we might want to do here is to check REGNUM against the    clobber mask, and somehow flag it as invalid if it isn't saved on    the stack somewhere.  This would provide a graceful failure mode    when trying to get the value of caller-saves registers for an inner    frame.  */
end_comment

begin_function
name|CORE_ADDR
name|fr30_find_callers_reg
parameter_list|(
name|fi
parameter_list|,
name|regnum
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|int
name|regnum
decl_stmt|;
block|{
for|for
control|(
init|;
name|fi
condition|;
name|fi
operator|=
name|fi
operator|->
name|next
control|)
if|if
condition|(
name|PC_IN_CALL_DUMMY
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
name|fi
operator|->
name|frame
argument_list|,
name|fi
operator|->
name|frame
argument_list|)
condition|)
return|return
name|generic_read_register_dummy
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
name|fi
operator|->
name|frame
argument_list|,
name|regnum
argument_list|)
return|;
elseif|else
if|if
condition|(
name|fi
operator|->
name|fsr
operator|.
name|regs
index|[
name|regnum
index|]
operator|!=
literal|0
condition|)
return|return
name|read_memory_unsigned_integer
argument_list|(
name|fi
operator|->
name|fsr
operator|.
name|regs
index|[
name|regnum
index|]
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
return|;
return|return
name|read_register
argument_list|(
name|regnum
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Function: frame_chain    Figure out the frame prior to FI.  Unfortunately, this involves    scanning the prologue of the caller, which will also be done    shortly by fr30_init_extra_frame_info.  For the dummy frame, we    just return the stack pointer that was in use at the time the    function call was made.  */
end_comment

begin_function
name|CORE_ADDR
name|fr30_frame_chain
parameter_list|(
name|fi
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
block|{
name|CORE_ADDR
name|fn_start
decl_stmt|,
name|callers_pc
decl_stmt|,
name|fp
decl_stmt|;
name|struct
name|frame_info
name|caller_fi
decl_stmt|;
name|int
name|framereg
decl_stmt|;
comment|/* is this a dummy frame? */
if|if
condition|(
name|PC_IN_CALL_DUMMY
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
name|fi
operator|->
name|frame
argument_list|,
name|fi
operator|->
name|frame
argument_list|)
condition|)
return|return
name|fi
operator|->
name|frame
return|;
comment|/* dummy frame same as caller's frame */
comment|/* is caller-of-this a dummy frame? */
name|callers_pc
operator|=
name|FRAME_SAVED_PC
argument_list|(
name|fi
argument_list|)
expr_stmt|;
comment|/* find out who called us: */
name|fp
operator|=
name|fr30_find_callers_reg
argument_list|(
name|fi
argument_list|,
name|FP_REGNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|PC_IN_CALL_DUMMY
argument_list|(
name|callers_pc
argument_list|,
name|fp
argument_list|,
name|fp
argument_list|)
condition|)
return|return
name|fp
return|;
comment|/* dummy frame's frame may bear no relation to ours */
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
literal|0
argument_list|,
operator|&
name|fn_start
argument_list|,
literal|0
argument_list|)
condition|)
if|if
condition|(
name|fn_start
operator|==
name|entry_point_address
argument_list|()
condition|)
return|return
literal|0
return|;
comment|/* in _start fn, don't chain further */
name|framereg
operator|=
name|fi
operator|->
name|framereg
expr_stmt|;
comment|/* If the caller is the startup code, we're at the end of the chain.  */
if|if
condition|(
name|find_pc_partial_function
argument_list|(
name|callers_pc
argument_list|,
literal|0
argument_list|,
operator|&
name|fn_start
argument_list|,
literal|0
argument_list|)
condition|)
if|if
condition|(
name|fn_start
operator|==
name|entry_point_address
argument_list|()
condition|)
return|return
literal|0
return|;
name|memset
argument_list|(
operator|&
name|caller_fi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|caller_fi
argument_list|)
argument_list|)
expr_stmt|;
name|caller_fi
operator|.
name|pc
operator|=
name|callers_pc
expr_stmt|;
name|fr30_scan_prologue
argument_list|(
operator|&
name|caller_fi
argument_list|)
expr_stmt|;
name|framereg
operator|=
name|caller_fi
operator|.
name|framereg
expr_stmt|;
comment|/* If the caller used a frame register, return its value.      Otherwise, return the caller's stack pointer.  */
if|if
condition|(
name|framereg
operator|==
name|FP_REGNUM
condition|)
return|return
name|fr30_find_callers_reg
argument_list|(
name|fi
argument_list|,
name|framereg
argument_list|)
return|;
else|else
return|return
name|fi
operator|->
name|frame
operator|+
name|fi
operator|->
name|framesize
return|;
block|}
end_function

begin_comment
comment|/* Function: frame_saved_pc     Find the caller of this frame.  We do this by seeing if RP_REGNUM    is saved in the stack anywhere, otherwise we get it from the    registers.  If the inner frame is a dummy frame, return its PC    instead of RP, because that's where "caller" of the dummy-frame    will be found.  */
end_comment

begin_function
name|CORE_ADDR
name|fr30_frame_saved_pc
parameter_list|(
name|fi
parameter_list|)
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
block|{
if|if
condition|(
name|PC_IN_CALL_DUMMY
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
name|fi
operator|->
name|frame
argument_list|,
name|fi
operator|->
name|frame
argument_list|)
condition|)
return|return
name|generic_read_register_dummy
argument_list|(
name|fi
operator|->
name|pc
argument_list|,
name|fi
operator|->
name|frame
argument_list|,
name|PC_REGNUM
argument_list|)
return|;
else|else
return|return
name|fr30_find_callers_reg
argument_list|(
name|fi
argument_list|,
name|RP_REGNUM
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Function: fix_call_dummy    Pokes the callee function's address into the CALL_DUMMY assembly stub.    Assumes that the CALL_DUMMY looks like this: 	jarl<offset24>, r31 	trap    */
end_comment

begin_function
name|int
name|fr30_fix_call_dummy
parameter_list|(
name|dummy
parameter_list|,
name|sp
parameter_list|,
name|fun
parameter_list|,
name|nargs
parameter_list|,
name|args
parameter_list|,
name|type
parameter_list|,
name|gcc_p
parameter_list|)
name|char
modifier|*
name|dummy
decl_stmt|;
name|CORE_ADDR
name|sp
decl_stmt|;
name|CORE_ADDR
name|fun
decl_stmt|;
name|int
name|nargs
decl_stmt|;
name|value_ptr
modifier|*
name|args
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|gcc_p
decl_stmt|;
block|{
name|long
name|offset24
decl_stmt|;
name|offset24
operator|=
operator|(
name|long
operator|)
name|fun
operator|-
operator|(
name|long
operator|)
name|entry_point_address
argument_list|()
expr_stmt|;
name|offset24
operator|&=
literal|0x3fffff
expr_stmt|;
name|offset24
operator||=
literal|0xff800000
expr_stmt|;
comment|/* jarl<offset24>, r31 */
name|store_unsigned_integer
argument_list|(
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|&
name|dummy
index|[
literal|2
index|]
argument_list|,
literal|2
argument_list|,
name|offset24
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|store_unsigned_integer
argument_list|(
operator|(
name|unsigned
name|int
operator|*
operator|)
operator|&
name|dummy
index|[
literal|0
index|]
argument_list|,
literal|2
argument_list|,
name|offset24
operator|>>
literal|16
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

