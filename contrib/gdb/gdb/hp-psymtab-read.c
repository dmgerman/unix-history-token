begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Read hp debug symbols and convert to internal format, for GDB.    Copyright 1993, 1996, 1998, 1999 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.     Written by the Center for Software Science at the University of Utah    and by Cygnus Support.  */
end_comment

begin_comment
comment|/* Common include file for hp_symtab_read.c and hp_psymtab_read.c.    This has nested includes of a bunch of stuff. */
end_comment

begin_include
include|#
directive|include
file|"hpread.h"
end_include

begin_include
include|#
directive|include
file|"demangle.h"
end_include

begin_comment
comment|/* To generate dumping code, uncomment this define.  The dumping    itself is controlled by routine-local statics called "dumping". */
end_comment

begin_comment
comment|/* #define DUMPING         1 */
end_comment

begin_comment
comment|/* To use the quick look-up tables, uncomment this define. */
end_comment

begin_define
define|#
directive|define
name|QUICK_LOOK_UP
value|1
end_define

begin_comment
comment|/* To call PXDB to process un-processed files, uncomment this define. */
end_comment

begin_define
define|#
directive|define
name|USE_PXDB
value|1
end_define

begin_comment
comment|/* Forward procedure declarations */
end_comment

begin_decl_stmt
name|void
name|hpread_symfile_init
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|do_pxdb
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|hpread_build_psymtabs
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|,
expr|struct
name|section_offsets
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|hpread_symfile_finish
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|union
name|dnttentry
modifier|*
name|hpread_get_gntt
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|hpread_get_textlow
name|PARAMS
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
expr|struct
name|objfile
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|partial_symtab
modifier|*
name|hpread_start_psymtab
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|,
expr|struct
name|section_offsets
operator|*
operator|,
name|char
operator|*
operator|,
name|CORE_ADDR
operator|,
name|int
operator|,
expr|struct
name|partial_symbol
operator|*
operator|*
operator|,
expr|struct
name|partial_symbol
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|partial_symtab
modifier|*
name|hpread_end_psymtab
name|PARAMS
argument_list|(
operator|(
expr|struct
name|partial_symtab
operator|*
operator|,
name|char
operator|*
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|CORE_ADDR
operator|,
expr|struct
name|partial_symtab
operator|*
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* End of forward routine declarations */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_PXDB
end_ifdef

begin_comment
comment|/* NOTE use of system files!  May not be portable. */
end_comment

begin_define
define|#
directive|define
name|PXDB_SVR4
value|"/opt/langtools/bin/pxdb"
end_define

begin_define
define|#
directive|define
name|PXDB_BSD
value|"/usr/bin/pxdb"
end_define

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/* check for the existance of a file, given its full pathname */
end_comment

begin_function
name|int
name|file_exists
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
if|if
condition|(
name|filename
condition|)
return|return
operator|(
name|access
argument_list|(
name|filename
argument_list|,
name|F_OK
argument_list|)
operator|==
literal|0
operator|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Translate from the "hp_language" enumeration in hp-symtab.h    used in the debug info to gdb's generic enumeration in defs.h. */
end_comment

begin_function
specifier|static
name|enum
name|language
name|trans_lang
parameter_list|(
name|in_lang
parameter_list|)
name|enum
name|hp_language
name|in_lang
decl_stmt|;
block|{
if|if
condition|(
name|in_lang
operator|==
name|HP_LANGUAGE_C
condition|)
return|return
name|language_c
return|;
elseif|else
if|if
condition|(
name|in_lang
operator|==
name|HP_LANGUAGE_CPLUSPLUS
condition|)
return|return
name|language_cplus
return|;
elseif|else
if|if
condition|(
name|in_lang
operator|==
name|HP_LANGUAGE_F77
condition|)
return|return
name|language_fortran
return|;
else|else
return|return
name|language_unknown
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|main_string
index|[]
init|=
literal|"main"
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Call PXDB to process our file.     Approach copied from DDE's "dbgk_run_pxdb".  Note: we    don't check for BSD location of pxdb, nor for existance    of pxdb itself, etc.     NOTE: uses system function and string functions directly.     Return value: 1 if ok, 0 if not */
end_comment

begin_function
name|int
name|hpread_call_pxdb
parameter_list|(
name|file_name
parameter_list|)
name|char
modifier|*
name|file_name
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|status
decl_stmt|;
name|int
name|retval
decl_stmt|;
if|if
condition|(
name|file_exists
argument_list|(
name|PXDB_SVR4
argument_list|)
condition|)
block|{
name|p
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|PXDB_SVR4
argument_list|)
operator|+
name|strlen
argument_list|(
name|file_name
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|PXDB_SVR4
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|p
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|p
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
name|warning
argument_list|(
literal|"File not processed by pxdb--about to process now.\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|system
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|(
name|status
operator|==
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|warning
argument_list|(
literal|"pxdb not found at standard location: /opt/langtools/bin\ngdb will not be able to debug %s.\nPlease install pxdb at the above location and then restart gdb.\nYou can also run pxdb on %s with the command\n\"pxdb %s\" and then restart gdb."
argument_list|,
name|file_name
argument_list|,
name|file_name
argument_list|,
name|file_name
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* hpread_call_pxdb */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Return 1 if the file turns out to need pre-processing    by PXDB, and we have thus called PXDB to do this processing    and the file therefore needs to be re-loaded.  Otherwise    return 0. */
end_comment

begin_function
name|int
name|hpread_pxdb_needed
parameter_list|(
name|sym_bfd
parameter_list|)
name|bfd
modifier|*
name|sym_bfd
decl_stmt|;
block|{
name|asection
modifier|*
name|pinfo_section
decl_stmt|,
modifier|*
name|debug_section
decl_stmt|,
modifier|*
name|header_section
decl_stmt|;
name|unsigned
name|int
name|do_pxdb
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|bfd_size_type
name|header_section_size
decl_stmt|;
name|unsigned
name|long
name|tmp
decl_stmt|;
name|unsigned
name|int
name|pxdbed
decl_stmt|;
name|header_section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|sym_bfd
argument_list|,
literal|"$HEADER$"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|header_section
condition|)
block|{
return|return
literal|0
return|;
comment|/* No header at all, can't recover... */
block|}
name|debug_section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|sym_bfd
argument_list|,
literal|"$DEBUG$"
argument_list|)
expr_stmt|;
name|pinfo_section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|sym_bfd
argument_list|,
literal|"$PINFO$"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pinfo_section
operator|&&
operator|!
name|debug_section
condition|)
block|{
comment|/* Debug info with DOC, has different header format.           this only happens if the file was pxdbed and compiled optimized          otherwise the PINFO section is not there. */
name|header_section_size
operator|=
name|bfd_section_size
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|header_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|header_section_size
operator|==
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
name|DOC_info_PXDB_header
argument_list|)
condition|)
block|{
name|buf
operator|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|DOC_info_PXDB_header
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|sym_bfd
argument_list|,
name|header_section
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|header_section_size
argument_list|)
condition|)
name|error
argument_list|(
literal|"bfd_get_section_contents\n"
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|bfd_get_32
argument_list|(
name|sym_bfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
operator|(
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
literal|4
operator|)
argument_list|)
expr_stmt|;
name|pxdbed
operator|=
operator|(
name|tmp
operator|>>
literal|31
operator|)
operator|&
literal|0x1
expr_stmt|;
if|if
condition|(
operator|!
name|pxdbed
condition|)
name|error
argument_list|(
literal|"file debug header info invalid\n"
argument_list|)
expr_stmt|;
name|do_pxdb
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"invalid $HEADER$ size in executable \n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* this can be three different cases:          1. pxdbed and not doc          - DEBUG and HEADER sections are there          - header is PXDB_header type          - pxdbed flag is set to 1           2. not pxdbed and doc          - DEBUG and HEADER  sections are there          - header is DOC_info_header type          - pxdbed flag is set to 0           3. not pxdbed and not doc          - DEBUG and HEADER sections are there          - header is XDB_header type          - pxdbed flag is set to 0           NOTE: the pxdbed flag is meaningful also in the not          already pxdb processed version of the header,          because in case on non-already processed by pxdb files          that same bit in the header would be always zero.          Why? Because the bit is the leftmost bit of a word          which contains a 'length' which is always a positive value          so that bit is never set to 1 (otherwise it would be negative)           Given the above, we have two choices : either we ignore the          size of the header itself and just look at the pxdbed field,          or we check the size and then we (for safety and paranoia related          issues) check the bit.          The first solution is used by DDE, the second by PXDB itself.          I am using the second one here, because I already wrote it,          and it is the end of a long day.          Also, using the first approach would still involve size issues          because we need to read in the contents of the header section, and          give the correct amount of stuff we want to read to the          get_bfd_section_contents function.  */
comment|/* decide which case depending on the size of the header section.          The size is as defined in hp-symtab.h  */
name|header_section_size
operator|=
name|bfd_section_size
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|header_section
argument_list|)
expr_stmt|;
if|if
condition|(
name|header_section_size
operator|==
operator|(
name|bfd_size_type
operator|)
sizeof|sizeof
argument_list|(
name|PXDB_header
argument_list|)
condition|)
comment|/* pxdb and not doc */
block|{
name|buf
operator|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|PXDB_header
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|sym_bfd
argument_list|,
name|header_section
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|,
name|header_section_size
argument_list|)
condition|)
name|error
argument_list|(
literal|"bfd_get_section_contents\n"
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|bfd_get_32
argument_list|(
name|sym_bfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
operator|(
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
literal|3
operator|)
argument_list|)
expr_stmt|;
name|pxdbed
operator|=
operator|(
name|tmp
operator|>>
literal|31
operator|)
operator|&
literal|0x1
expr_stmt|;
if|if
condition|(
name|pxdbed
condition|)
name|do_pxdb
operator|=
literal|0
expr_stmt|;
else|else
name|error
argument_list|(
literal|"file debug header invalid\n"
argument_list|)
expr_stmt|;
block|}
else|else
comment|/*not pxdbed and doc OR not pxdbed and non doc */
name|do_pxdb
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|do_pxdb
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* hpread_pxdb_needed */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Check whether the file needs to be preprocessed by pxdb.     If so, call pxdb. */
end_comment

begin_function
name|void
name|do_pxdb
parameter_list|(
name|sym_bfd
parameter_list|)
name|bfd
modifier|*
name|sym_bfd
decl_stmt|;
block|{
comment|/* The following code is HP-specific.  The "right" way of      doing this is unknown, but we bet would involve a target-      specific pre-file-load check using a generic mechanism. */
comment|/* This code will not be executed if the file is not in SOM      format (i.e. if compiled with gcc) */
if|if
condition|(
name|hpread_pxdb_needed
argument_list|(
name|sym_bfd
argument_list|)
condition|)
block|{
comment|/*This file has not been pre-processed. Preprocess now */
if|if
condition|(
name|hpread_call_pxdb
argument_list|(
name|sym_bfd
operator|->
name|filename
argument_list|)
condition|)
block|{
comment|/* The call above has changed the on-disk file,                 we can close the file anyway, because the 	       symbols will be reread in when the target is run */
name|bfd_close
argument_list|(
name|sym_bfd
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|QUICK_LOOK_UP
end_ifdef

begin_comment
comment|/* Code to handle quick lookup-tables follows. */
end_comment

begin_comment
comment|/* Some useful macros */
end_comment

begin_define
define|#
directive|define
name|VALID_FILE
parameter_list|(
name|i
parameter_list|)
value|((i)< pxdb_header_p->fd_entries)
end_define

begin_define
define|#
directive|define
name|VALID_MODULE
parameter_list|(
name|i
parameter_list|)
value|((i)< pxdb_header_p->md_entries)
end_define

begin_define
define|#
directive|define
name|VALID_PROC
parameter_list|(
name|i
parameter_list|)
value|((i)< pxdb_header_p->pd_entries)
end_define

begin_define
define|#
directive|define
name|VALID_CLASS
parameter_list|(
name|i
parameter_list|)
value|((i)< pxdb_header_p->cd_entries)
end_define

begin_define
define|#
directive|define
name|FILE_START
parameter_list|(
name|i
parameter_list|)
value|(qFD[i].adrStart)
end_define

begin_define
define|#
directive|define
name|MODULE_START
parameter_list|(
name|i
parameter_list|)
value|(qMD[i].adrStart)
end_define

begin_define
define|#
directive|define
name|PROC_START
parameter_list|(
name|i
parameter_list|)
value|(qPD[i].adrStart)
end_define

begin_define
define|#
directive|define
name|FILE_END
parameter_list|(
name|i
parameter_list|)
value|(qFD[i].adrEnd)
end_define

begin_define
define|#
directive|define
name|MODULE_END
parameter_list|(
name|i
parameter_list|)
value|(qMD[i].adrEnd)
end_define

begin_define
define|#
directive|define
name|PROC_END
parameter_list|(
name|i
parameter_list|)
value|(qPD[i].adrEnd)
end_define

begin_define
define|#
directive|define
name|FILE_ISYM
parameter_list|(
name|i
parameter_list|)
value|(qFD[i].isym)
end_define

begin_define
define|#
directive|define
name|MODULE_ISYM
parameter_list|(
name|i
parameter_list|)
value|(qMD[i].isym)
end_define

begin_define
define|#
directive|define
name|PROC_ISYM
parameter_list|(
name|i
parameter_list|)
value|(qPD[i].isym)
end_define

begin_define
define|#
directive|define
name|VALID_CURR_FILE
value|(curr_fd< pxdb_header_p->fd_entries)
end_define

begin_define
define|#
directive|define
name|VALID_CURR_MODULE
value|(curr_md< pxdb_header_p->md_entries)
end_define

begin_define
define|#
directive|define
name|VALID_CURR_PROC
value|(curr_pd< pxdb_header_p->pd_entries)
end_define

begin_define
define|#
directive|define
name|VALID_CURR_CLASS
value|(curr_cd< pxdb_header_p->cd_entries)
end_define

begin_define
define|#
directive|define
name|CURR_FILE_START
value|(qFD[curr_fd].adrStart)
end_define

begin_define
define|#
directive|define
name|CURR_MODULE_START
value|(qMD[curr_md].adrStart)
end_define

begin_define
define|#
directive|define
name|CURR_PROC_START
value|(qPD[curr_pd].adrStart)
end_define

begin_define
define|#
directive|define
name|CURR_FILE_END
value|(qFD[curr_fd].adrEnd)
end_define

begin_define
define|#
directive|define
name|CURR_MODULE_END
value|(qMD[curr_md].adrEnd)
end_define

begin_define
define|#
directive|define
name|CURR_PROC_END
value|(qPD[curr_pd].adrEnd)
end_define

begin_define
define|#
directive|define
name|CURR_FILE_ISYM
value|(qFD[curr_fd].isym)
end_define

begin_define
define|#
directive|define
name|CURR_MODULE_ISYM
value|(qMD[curr_md].isym)
end_define

begin_define
define|#
directive|define
name|CURR_PROC_ISYM
value|(qPD[curr_pd].isym)
end_define

begin_define
define|#
directive|define
name|TELL_OBJFILE
define|\
value|do {                                          \                if( !told_objfile ) {                      \                    told_objfile = 1;                      \                    warning ("\nIn object file \"%s\":\n", \                             objfile->name);               \                }                                          \             } while (0)
end_define

begin_escape
end_escape

begin_comment
comment|/* Keeping track of the start/end symbol table (LNTT) indices of    psymtabs created so far */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|start
decl_stmt|;
name|int
name|end
decl_stmt|;
block|}
name|pst_syms_struct
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|pst_syms_struct
modifier|*
name|pst_syms_array
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|pst_syms_count
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|pst_syms_size
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* used by the TELL_OBJFILE macro */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|told_objfile
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set up psymtab symbol index stuff */
end_comment

begin_function
specifier|static
name|void
name|init_pst_syms
parameter_list|()
block|{
name|pst_syms_count
operator|=
literal|0
expr_stmt|;
name|pst_syms_size
operator|=
literal|20
expr_stmt|;
name|pst_syms_array
operator|=
operator|(
name|pst_syms_struct
operator|*
operator|)
name|xmalloc
argument_list|(
literal|20
operator|*
sizeof|sizeof
argument_list|(
name|pst_syms_struct
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Clean up psymtab symbol index stuff */
end_comment

begin_function
specifier|static
name|void
name|clear_pst_syms
parameter_list|()
block|{
name|pst_syms_count
operator|=
literal|0
expr_stmt|;
name|pst_syms_size
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|pst_syms_array
argument_list|)
expr_stmt|;
name|pst_syms_array
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add information about latest psymtab to symbol index table */
end_comment

begin_function
specifier|static
name|void
name|record_pst_syms
parameter_list|(
name|start_sym
parameter_list|,
name|end_sym
parameter_list|)
name|int
name|start_sym
decl_stmt|;
name|int
name|end_sym
decl_stmt|;
block|{
if|if
condition|(
operator|++
name|pst_syms_count
operator|>
name|pst_syms_size
condition|)
block|{
name|pst_syms_array
operator|=
operator|(
name|pst_syms_struct
operator|*
operator|)
name|xrealloc
argument_list|(
name|pst_syms_array
argument_list|,
literal|2
operator|*
name|pst_syms_size
operator|*
sizeof|sizeof
argument_list|(
name|pst_syms_struct
argument_list|)
argument_list|)
expr_stmt|;
name|pst_syms_size
operator|*=
literal|2
expr_stmt|;
block|}
name|pst_syms_array
index|[
name|pst_syms_count
operator|-
literal|1
index|]
operator|.
name|start
operator|=
name|start_sym
expr_stmt|;
name|pst_syms_array
index|[
name|pst_syms_count
operator|-
literal|1
index|]
operator|.
name|end
operator|=
name|end_sym
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find a suitable symbol table index which can serve as the upper    bound of a psymtab that starts at INDEX     This scans backwards in the psymtab symbol index table to find a    "hole" in which the given index can fit.  This is a heuristic!!    We don't search the entire table to check for multiple holes,    we don't care about overlaps, etc.      Return 0 => not found */
end_comment

begin_function
specifier|static
name|int
name|find_next_pst_start
parameter_list|(
name|index
parameter_list|)
name|int
name|index
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|pst_syms_count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|pst_syms_array
index|[
name|i
index|]
operator|.
name|end
operator|<=
name|index
condition|)
return|return
operator|(
name|i
operator|==
name|pst_syms_count
operator|-
literal|1
operator|)
condition|?
literal|0
else|:
name|pst_syms_array
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|start
operator|-
literal|1
return|;
if|if
condition|(
name|pst_syms_array
index|[
literal|0
index|]
operator|.
name|start
operator|>
name|index
condition|)
return|return
name|pst_syms_array
index|[
literal|0
index|]
operator|.
name|start
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Utility functions to find the ending symbol index for a psymtab */
end_comment

begin_comment
comment|/* Find the next file entry that begins beyond INDEX, and return    its starting symbol index - 1.    QFD is the file table, CURR_FD is the file entry from where to start,    PXDB_HEADER_P as in hpread_quick_traverse (to allow macros to work).     Return 0 => not found */
end_comment

begin_function
specifier|static
name|int
name|find_next_file_isym
parameter_list|(
name|index
parameter_list|,
name|qFD
parameter_list|,
name|curr_fd
parameter_list|,
name|pxdb_header_p
parameter_list|)
name|int
name|index
decl_stmt|;
name|quick_file_entry
modifier|*
name|qFD
decl_stmt|;
name|int
name|curr_fd
decl_stmt|;
name|PXDB_header_ptr
name|pxdb_header_p
decl_stmt|;
block|{
while|while
condition|(
name|VALID_CURR_FILE
condition|)
block|{
if|if
condition|(
name|CURR_FILE_ISYM
operator|>=
name|index
condition|)
return|return
name|CURR_FILE_ISYM
operator|-
literal|1
return|;
name|curr_fd
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Find the next procedure entry that begins beyond INDEX, and return    its starting symbol index - 1.    QPD is the procedure table, CURR_PD is the proc entry from where to start,    PXDB_HEADER_P as in hpread_quick_traverse (to allow macros to work).     Return 0 => not found */
end_comment

begin_function
specifier|static
name|int
name|find_next_proc_isym
parameter_list|(
name|index
parameter_list|,
name|qPD
parameter_list|,
name|curr_pd
parameter_list|,
name|pxdb_header_p
parameter_list|)
name|int
name|index
decl_stmt|;
name|quick_procedure_entry
modifier|*
name|qPD
decl_stmt|;
name|int
name|curr_pd
decl_stmt|;
name|PXDB_header_ptr
name|pxdb_header_p
decl_stmt|;
block|{
while|while
condition|(
name|VALID_CURR_PROC
condition|)
block|{
if|if
condition|(
name|CURR_PROC_ISYM
operator|>=
name|index
condition|)
return|return
name|CURR_PROC_ISYM
operator|-
literal|1
return|;
name|curr_pd
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Find the next module entry that begins beyond INDEX, and return    its starting symbol index - 1.    QMD is the module table, CURR_MD is the modue entry from where to start,    PXDB_HEADER_P as in hpread_quick_traverse (to allow macros to work).     Return 0 => not found */
end_comment

begin_function
specifier|static
name|int
name|find_next_module_isym
parameter_list|(
name|index
parameter_list|,
name|qMD
parameter_list|,
name|curr_md
parameter_list|,
name|pxdb_header_p
parameter_list|)
name|int
name|index
decl_stmt|;
name|quick_module_entry
modifier|*
name|qMD
decl_stmt|;
name|int
name|curr_md
decl_stmt|;
name|PXDB_header_ptr
name|pxdb_header_p
decl_stmt|;
block|{
while|while
condition|(
name|VALID_CURR_MODULE
condition|)
block|{
if|if
condition|(
name|CURR_MODULE_ISYM
operator|>=
name|index
condition|)
return|return
name|CURR_MODULE_ISYM
operator|-
literal|1
return|;
name|curr_md
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Scan and record partial symbols for all functions starting from index    pointed to by CURR_PD_P, and between code addresses START_ADR and END_ADR.    Other parameters are explained in comments below. */
end_comment

begin_comment
comment|/* This used to be inline in hpread_quick_traverse, but now that we do essentially the    same thing for two different cases (modules and module-less files), it's better    organized in a separate routine, although it does take lots of arguments. pai/1997-10-08 */
end_comment

begin_function
specifier|static
name|int
name|scan_procs
parameter_list|(
name|curr_pd_p
parameter_list|,
name|qPD
parameter_list|,
name|max_procs
parameter_list|,
name|start_adr
parameter_list|,
name|end_adr
parameter_list|,
name|pst
parameter_list|,
name|vt_bits
parameter_list|,
name|objfile
parameter_list|,
name|section_offsets
parameter_list|)
name|int
modifier|*
name|curr_pd_p
decl_stmt|;
comment|/* pointer to current proc index */
name|quick_procedure_entry
modifier|*
name|qPD
decl_stmt|;
comment|/* the procedure quick lookup table */
name|int
name|max_procs
decl_stmt|;
comment|/* number of entries in proc. table */
name|CORE_ADDR
name|start_adr
decl_stmt|;
comment|/* beginning of code range for current psymtab */
name|CORE_ADDR
name|end_adr
decl_stmt|;
comment|/* end of code range for current psymtab */
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
comment|/* current psymtab */
name|char
modifier|*
name|vt_bits
decl_stmt|;
comment|/* strings table of SOM debug space */
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
comment|/* current object file */
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
comment|/* not really used for HP-UX currently */
block|{
name|union
name|dnttentry
modifier|*
name|dn_bufp
decl_stmt|;
name|int
name|symbol_count
init|=
literal|0
decl_stmt|;
comment|/* Total number of symbols in this psymtab */
name|int
name|curr_pd
init|=
operator|*
name|curr_pd_p
decl_stmt|;
comment|/* Convenience variable -- avoid dereferencing pointer all the time */
ifdef|#
directive|ifdef
name|DUMPING
comment|/* Turn this on for lots of debugging information in this routine */
specifier|static
name|int
name|dumping
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DUMPING
if|if
condition|(
name|dumping
condition|)
block|{
name|printf
argument_list|(
literal|"Scan_procs called, addresses %x to %x, proc %x\n"
argument_list|,
name|start_adr
argument_list|,
name|end_adr
argument_list|,
name|curr_pd
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
while|while
condition|(
operator|(
name|CURR_PROC_START
operator|<=
name|end_adr
operator|)
operator|&&
operator|(
name|curr_pd
operator|<
name|max_procs
operator|)
condition|)
block|{
name|char
modifier|*
name|rtn_name
decl_stmt|;
comment|/* mangled name */
name|char
modifier|*
name|rtn_dem_name
decl_stmt|;
comment|/* qualified demangled name */
name|char
modifier|*
name|class_name
decl_stmt|;
name|int
name|class
decl_stmt|;
if|if
condition|(
operator|(
name|trans_lang
argument_list|(
operator|(
expr|enum
name|hp_language
operator|)
name|qPD
index|[
name|curr_pd
index|]
operator|.
name|language
argument_list|)
operator|==
name|language_cplus
operator|)
operator|&&
name|vt_bits
index|[
operator|(
name|long
operator|)
name|qPD
index|[
name|curr_pd
index|]
operator|.
name|sbAlias
index|]
condition|)
comment|/* not a null string */
block|{
comment|/* Get mangled name for the procedure, and demangle it */
name|rtn_name
operator|=
operator|&
name|vt_bits
index|[
operator|(
name|long
operator|)
name|qPD
index|[
name|curr_pd
index|]
operator|.
name|sbAlias
index|]
expr_stmt|;
name|rtn_dem_name
operator|=
name|cplus_demangle
argument_list|(
name|rtn_name
argument_list|,
name|DMGL_ANSI
operator||
name|DMGL_PARAMS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rtn_name
operator|=
operator|&
name|vt_bits
index|[
operator|(
name|long
operator|)
name|qPD
index|[
name|curr_pd
index|]
operator|.
name|sbProc
index|]
expr_stmt|;
name|rtn_dem_name
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Hack to get around HP C/C++ compilers' insistence on providing          "_MAIN_" as an alternate name for "main" */
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|rtn_name
argument_list|,
literal|"_MAIN_"
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
operator|&
name|vt_bits
index|[
operator|(
name|long
operator|)
name|qPD
index|[
name|curr_pd
index|]
operator|.
name|sbProc
index|]
argument_list|,
literal|"main"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|rtn_dem_name
operator|=
name|rtn_name
operator|=
name|main_string
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMPING
if|if
condition|(
name|dumping
condition|)
block|{
name|printf
argument_list|(
literal|"..add %s (demangled %s), index %x to this psymtab\n"
argument_list|,
name|rtn_name
argument_list|,
name|rtn_dem_name
argument_list|,
name|curr_pd
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Check for module-spanning routines. */
if|if
condition|(
name|CURR_PROC_END
operator|>
name|end_adr
condition|)
block|{
name|TELL_OBJFILE
expr_stmt|;
name|warning
argument_list|(
literal|"Procedure \"%s\" [0x%x] spans file or module boundaries."
argument_list|,
name|rtn_name
argument_list|,
name|curr_pd
argument_list|)
expr_stmt|;
block|}
comment|/* Add this routine symbol to the list in the objfile.           Unfortunately we have to go to the LNTT to determine the          correct list to put it on. An alternative (which the          code used to do) would be to not check and always throw          it on the "static" list. But if we go that route, then          symbol_lookup() needs to be tweaked a bit to account          for the fact that the function might not be found on          the correct list in the psymtab. - RT */
name|dn_bufp
operator|=
name|hpread_get_lntt
argument_list|(
name|qPD
index|[
name|curr_pd
index|]
operator|.
name|isym
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn_bufp
operator|->
name|dfunc
operator|.
name|global
condition|)
name|add_psymbol_with_dem_name_to_list
argument_list|(
name|rtn_name
argument_list|,
name|strlen
argument_list|(
name|rtn_name
argument_list|)
argument_list|,
name|rtn_dem_name
argument_list|,
name|strlen
argument_list|(
name|rtn_dem_name
argument_list|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_BLOCK
argument_list|,
comment|/* "I am a routine"        */
operator|&
name|objfile
operator|->
name|global_psymbols
argument_list|,
operator|(
name|qPD
index|[
name|curr_pd
index|]
operator|.
name|adrStart
operator|+
comment|/* Starting address of rtn */
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
comment|/* core addr?? */
name|trans_lang
argument_list|(
operator|(
expr|enum
name|hp_language
operator|)
name|qPD
index|[
name|curr_pd
index|]
operator|.
name|language
argument_list|)
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
else|else
name|add_psymbol_with_dem_name_to_list
argument_list|(
name|rtn_name
argument_list|,
name|strlen
argument_list|(
name|rtn_name
argument_list|)
argument_list|,
name|rtn_dem_name
argument_list|,
name|strlen
argument_list|(
name|rtn_dem_name
argument_list|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_BLOCK
argument_list|,
comment|/* "I am a routine"        */
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
operator|(
name|qPD
index|[
name|curr_pd
index|]
operator|.
name|adrStart
operator|+
comment|/* Starting address of rtn */
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
comment|/* core addr?? */
name|trans_lang
argument_list|(
operator|(
expr|enum
name|hp_language
operator|)
name|qPD
index|[
name|curr_pd
index|]
operator|.
name|language
argument_list|)
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|symbol_count
operator|++
expr_stmt|;
operator|*
name|curr_pd_p
operator|=
operator|++
name|curr_pd
expr_stmt|;
comment|/* bump up count& reflect in caller */
block|}
comment|/* loop over procedures */
ifdef|#
directive|ifdef
name|DUMPING
if|if
condition|(
name|dumping
condition|)
block|{
if|if
condition|(
name|symbol_count
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"Scan_procs: no symbols found!\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|symbol_count
return|;
block|}
end_function

begin_comment
comment|/* Traverse the quick look-up tables, building a set of psymtabs.     This constructs a psymtab for modules and files in the quick lookup    tables.     Mostly, modules correspond to compilation units, so we try to    create psymtabs that correspond to modules; however, in some cases    a file can result in a compiled object which does not have a module    entry for it, so in such cases we create a psymtab for the file.  */
end_comment

begin_function
name|int
name|hpread_quick_traverse
parameter_list|(
name|objfile
parameter_list|,
name|section_offsets
parameter_list|,
name|gntt_bits
parameter_list|,
name|vt_bits
parameter_list|,
name|pxdb_header_p
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
comment|/* The object file descriptor */
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
comment|/* ?? Null for HP */
name|char
modifier|*
name|gntt_bits
decl_stmt|;
comment|/* GNTT entries, loaded in from the file */
name|char
modifier|*
name|vt_bits
decl_stmt|;
comment|/* VT (string) entries ditto. */
name|PXDB_header_ptr
name|pxdb_header_p
decl_stmt|;
comment|/* Pointer to pxdb header ditto */
block|{
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
name|quick_procedure_entry
modifier|*
name|qPD
decl_stmt|;
name|quick_file_entry
modifier|*
name|qFD
decl_stmt|;
name|quick_module_entry
modifier|*
name|qMD
decl_stmt|;
name|quick_class_entry
modifier|*
name|qCD
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|int
name|i
decl_stmt|;
name|CORE_ADDR
name|start_adr
decl_stmt|;
comment|/* current psymtab's starting code addr   */
name|CORE_ADDR
name|end_adr
decl_stmt|;
comment|/* current psymtab's ending code addr     */
name|CORE_ADDR
name|next_mod_adr
decl_stmt|;
comment|/* next module's starting code addr    */
name|int
name|curr_pd
decl_stmt|;
comment|/* current procedure */
name|int
name|curr_fd
decl_stmt|;
comment|/* current file      */
name|int
name|curr_md
decl_stmt|;
comment|/* current module    */
name|int
name|start_sym
decl_stmt|;
comment|/* current psymtab's starting symbol index */
name|int
name|end_sym
decl_stmt|;
comment|/* current psymtab's ending symbol index   */
name|int
name|max_LNTT_sym_index
decl_stmt|;
name|int
name|syms_in_pst
decl_stmt|;
name|B_TYPE
modifier|*
name|class_entered
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
modifier|*
name|global_syms
decl_stmt|;
comment|/* We'll be filling in the "global"   */
name|struct
name|partial_symbol
modifier|*
modifier|*
name|static_syms
decl_stmt|;
comment|/* and "static" tables in the objfile                                            as we go, so we need a pair of                                                 current pointers. */
ifdef|#
directive|ifdef
name|DUMPING
comment|/* Turn this on for lots of debugging information in this routine.      You get a blow-by-blow account of quick lookup table reading */
specifier|static
name|int
name|dumping
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|pst
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* Clear out some globals */
name|init_pst_syms
argument_list|()
expr_stmt|;
name|told_objfile
operator|=
literal|0
expr_stmt|;
comment|/* Demangling style -- if EDG style already set, don't change it,      as HP style causes some problems with the KAI EDG compiler */
if|if
condition|(
name|current_demangling_style
operator|!=
name|edg_demangling
condition|)
block|{
comment|/* Otherwise, ensure that we are using HP style demangling */
name|set_demangling_style
argument_list|(
name|HP_DEMANGLING_STYLE_STRING
argument_list|)
expr_stmt|;
block|}
comment|/* First we need to find the starting points of the quick      look-up tables in the GNTT. */
name|addr
operator|=
name|gntt_bits
expr_stmt|;
name|qPD
operator|=
operator|(
name|quick_procedure_entry_ptr
operator|)
name|addr
expr_stmt|;
name|addr
operator|+=
name|pxdb_header_p
operator|->
name|pd_entries
operator|*
sizeof|sizeof
argument_list|(
name|quick_procedure_entry
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMPING
if|if
condition|(
name|dumping
condition|)
block|{
name|printf
argument_list|(
literal|"\n Printing routines as we see them\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VALID_PROC
argument_list|(
name|i
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|idx
operator|=
operator|(
name|long
operator|)
name|qPD
index|[
name|i
index|]
operator|.
name|sbProc
expr_stmt|;
name|printf
argument_list|(
literal|"%s %x..%x\n"
argument_list|,
operator|&
name|vt_bits
index|[
name|idx
index|]
argument_list|,
operator|(
name|int
operator|)
name|PROC_START
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|PROC_END
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|qFD
operator|=
operator|(
name|quick_file_entry_ptr
operator|)
name|addr
expr_stmt|;
name|addr
operator|+=
name|pxdb_header_p
operator|->
name|fd_entries
operator|*
sizeof|sizeof
argument_list|(
name|quick_file_entry
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMPING
if|if
condition|(
name|dumping
condition|)
block|{
name|printf
argument_list|(
literal|"\n Printing files as we see them\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VALID_FILE
argument_list|(
name|i
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|idx
operator|=
operator|(
name|long
operator|)
name|qFD
index|[
name|i
index|]
operator|.
name|sbFile
expr_stmt|;
name|printf
argument_list|(
literal|"%s %x..%x\n"
argument_list|,
operator|&
name|vt_bits
index|[
name|idx
index|]
argument_list|,
operator|(
name|int
operator|)
name|FILE_START
argument_list|(
name|i
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|FILE_END
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|qMD
operator|=
operator|(
name|quick_module_entry_ptr
operator|)
name|addr
expr_stmt|;
name|addr
operator|+=
name|pxdb_header_p
operator|->
name|md_entries
operator|*
sizeof|sizeof
argument_list|(
name|quick_module_entry
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMPING
if|if
condition|(
name|dumping
condition|)
block|{
name|printf
argument_list|(
literal|"\n Printing modules as we see them\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pxdb_header_p
operator|->
name|md_entries
condition|;
name|i
operator|++
control|)
block|{
name|idx
operator|=
operator|(
name|long
operator|)
name|qMD
index|[
name|i
index|]
operator|.
name|sbMod
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
operator|&
name|vt_bits
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|qCD
operator|=
operator|(
name|quick_class_entry_ptr
operator|)
name|addr
expr_stmt|;
name|addr
operator|+=
name|pxdb_header_p
operator|->
name|cd_entries
operator|*
sizeof|sizeof
argument_list|(
name|quick_class_entry
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMPING
if|if
condition|(
name|dumping
condition|)
block|{
name|printf
argument_list|(
literal|"\n Printing classes as we see them\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|VALID_CLASS
argument_list|(
name|i
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|idx
operator|=
operator|(
name|long
operator|)
name|qCD
index|[
name|i
index|]
operator|.
name|sbClass
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
operator|&
name|vt_bits
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n Done with dump, on to build!\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* We need this index only while hp-symtab-read.c expects      a byte offset to the end of the LNTT entries for a given      psymtab.  Thus the need for it should go away someday.       When it goes away, then we won't have any need to load the      LNTT from the objfile at psymtab-time, and start-up will be      faster.  To make that work, we'll need some way to create      a null pst for the "globals" pseudo-module. */
name|max_LNTT_sym_index
operator|=
name|LNTT_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
comment|/* Scan the module descriptors and make a psymtab for each.       We know the MDs, FDs and the PDs are in order by starting      address.  We use that fact to traverse all three arrays in      parallel, knowing when the next PD is in a new file      and we need to create a new psymtab. */
name|curr_pd
operator|=
literal|0
expr_stmt|;
comment|/* Current procedure entry */
name|curr_fd
operator|=
literal|0
expr_stmt|;
comment|/* Current file entry */
name|curr_md
operator|=
literal|0
expr_stmt|;
comment|/* Current module entry */
name|start_adr
operator|=
literal|0
expr_stmt|;
comment|/* Current psymtab code range */
name|end_adr
operator|=
literal|0
expr_stmt|;
name|start_sym
operator|=
literal|0
expr_stmt|;
comment|/* Current psymtab symbol range */
name|end_sym
operator|=
literal|0
expr_stmt|;
name|syms_in_pst
operator|=
literal|0
expr_stmt|;
comment|/* Symbol count for psymtab */
comment|/* Psts actually just have pointers into the objfile's      symbol table, not their own symbol tables. */
name|global_syms
operator|=
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
expr_stmt|;
name|static_syms
operator|=
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
expr_stmt|;
comment|/* First skip over pseudo-entries with address 0.  These represent inlined      routines and abstract (uninstantiated) template routines.      FIXME: These should be read in and available -- even if we can't set      breakpoints, etc., there's some information that can be presented      to the user. pai/1997-10-08  */
while|while
condition|(
name|VALID_CURR_PROC
operator|&&
operator|(
name|CURR_PROC_START
operator|==
literal|0
operator|)
condition|)
name|curr_pd
operator|++
expr_stmt|;
comment|/* Loop over files, modules, and procedures in code address order. Each      time we enter an iteration of this loop, curr_pd points to the first      unprocessed procedure, curr_fd points to the first unprocessed file, and      curr_md to the first unprocessed module.  Each iteration of this loop      updates these as required -- any or all of them may be bumpd up      each time around.  When we exit this loop, we are done with all files      and modules in the tables -- there may still be some procedures, however.       Note: This code used to loop only over module entries, under the assumption      that files can occur via inclusions and are thus unreliable, while a      compiled object always corresponds to a module.  With CTTI in the HP aCC      compiler, it turns out that compiled objects may have only files and no      modules; so we have to loop over files and modules, creating psymtabs for      either as appropriate.  Unfortunately there are some problems (notably:      1. the lack of "SRC_FILE_END" entries in the LNTT, 2. the lack of pointers      to the ending symbol indices of a module or a file) which make it quite hard      to do this correctly.  Currently it uses a bunch of heuristics to start and      end psymtabs; they seem to work well with most objects generated by aCC, but      who knows when that will change...   */
while|while
condition|(
name|VALID_CURR_FILE
operator|||
name|VALID_CURR_MODULE
condition|)
block|{
name|char
modifier|*
name|mod_name_string
decl_stmt|;
name|char
modifier|*
name|full_name_string
decl_stmt|;
comment|/* First check for modules like "version.c", which have no code          in them but still have qMD entries.  They also have no qFD or          qPD entries.  Their start address is -1 and their end address          is 0.  */
if|if
condition|(
name|VALID_CURR_MODULE
operator|&&
operator|(
name|CURR_MODULE_START
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|CURR_MODULE_END
operator|==
literal|0
operator|)
condition|)
block|{
name|mod_name_string
operator|=
operator|&
name|vt_bits
index|[
operator|(
name|long
operator|)
name|qMD
index|[
name|curr_md
index|]
operator|.
name|sbMod
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMPING
if|if
condition|(
name|dumping
condition|)
name|printf
argument_list|(
literal|"Module with data only %s\n"
argument_list|,
name|mod_name_string
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* We'll skip the rest (it makes error-checking easier), and 	     just make an empty pst.  Right now empty psts are not put 	     in the pst chain, so all this is for naught, but later it 	     might help.  */
name|pst
operator|=
name|hpread_start_psymtab
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|,
comment|/* ?? */
name|mod_name_string
argument_list|,
name|CURR_MODULE_START
argument_list|,
comment|/* Low text address: bogus! */
operator|(
name|CURR_MODULE_ISYM
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
operator|)
argument_list|,
comment|/* ldsymoff */
name|global_syms
argument_list|,
name|static_syms
argument_list|)
expr_stmt|;
name|pst
operator|=
name|hpread_end_psymtab
argument_list|(
name|pst
argument_list|,
name|NULL
argument_list|,
comment|/* psymtab_include_list */
literal|0
argument_list|,
comment|/* includes_used        */
name|end_sym
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
argument_list|,
comment|/* byte index in LNTT of end  				                   = capping symbol offset   				                   = LDSYMOFF of nextfile */
literal|0
argument_list|,
comment|/* text high            */
name|NULL
argument_list|,
comment|/* dependency_list      */
literal|0
argument_list|)
expr_stmt|;
comment|/* dependencies_used    */
name|global_syms
operator|=
name|objfile
operator|->
name|global_psymbols
operator|.
name|next
expr_stmt|;
name|static_syms
operator|=
name|objfile
operator|->
name|static_psymbols
operator|.
name|next
expr_stmt|;
name|curr_md
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|VALID_CURR_MODULE
operator|&&
operator|(
operator|(
name|CURR_MODULE_START
operator|==
literal|0
operator|)
operator|||
operator|(
name|CURR_MODULE_START
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|CURR_MODULE_END
operator|==
literal|0
operator|)
operator|||
operator|(
name|CURR_MODULE_END
operator|==
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|TELL_OBJFILE
expr_stmt|;
name|warning
argument_list|(
literal|"Module \"%s\" [0x%x] has non-standard addresses.  It starts at 0x%x, ends at 0x%x, and will be skipped."
argument_list|,
name|mod_name_string
argument_list|,
name|curr_md
argument_list|,
name|start_adr
argument_list|,
name|end_adr
argument_list|)
expr_stmt|;
comment|/* On to next module */
name|curr_md
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* First check if we are looking at a file with code in it 	     that does not overlap the current module's code range */
if|if
condition|(
name|VALID_CURR_FILE
condition|?
operator|(
name|VALID_CURR_MODULE
condition|?
operator|(
name|CURR_FILE_END
operator|<
name|CURR_MODULE_START
operator|)
else|:
literal|1
operator|)
else|:
literal|0
condition|)
block|{
comment|/* Looking at file not corresponding to any module, 	         create a psymtab for it */
name|full_name_string
operator|=
operator|&
name|vt_bits
index|[
operator|(
name|long
operator|)
name|qFD
index|[
name|curr_fd
index|]
operator|.
name|sbFile
index|]
expr_stmt|;
name|start_adr
operator|=
name|CURR_FILE_START
expr_stmt|;
name|end_adr
operator|=
name|CURR_FILE_END
expr_stmt|;
name|start_sym
operator|=
name|CURR_FILE_ISYM
expr_stmt|;
comment|/* Check if there are any procedures not handled until now, that 	         begin before the start address of this file, and if so, adjust 	         this module's start address to include them.  This handles routines that 	         are in between file or module ranges for some reason (probably 	         indicates a compiler bug */
if|if
condition|(
name|CURR_PROC_START
operator|<
name|start_adr
condition|)
block|{
name|TELL_OBJFILE
expr_stmt|;
name|warning
argument_list|(
literal|"Found procedure \"%s\" [0x%x] that is not in any file or module."
argument_list|,
operator|&
name|vt_bits
index|[
operator|(
name|long
operator|)
name|qPD
index|[
name|curr_pd
index|]
operator|.
name|sbProc
index|]
argument_list|,
name|curr_pd
argument_list|)
expr_stmt|;
name|start_adr
operator|=
name|CURR_PROC_START
expr_stmt|;
if|if
condition|(
name|CURR_PROC_ISYM
operator|<
name|start_sym
condition|)
name|start_sym
operator|=
name|CURR_PROC_ISYM
expr_stmt|;
block|}
comment|/* Sometimes (compiler bug -- COBOL) the module end address is higher 	         than the start address of the next module, so check for that and 	         adjust accordingly */
if|if
condition|(
name|VALID_FILE
argument_list|(
name|curr_fd
operator|+
literal|1
argument_list|)
operator|&&
operator|(
name|FILE_START
argument_list|(
name|curr_fd
operator|+
literal|1
argument_list|)
operator|<=
name|end_adr
operator|)
condition|)
block|{
name|TELL_OBJFILE
expr_stmt|;
name|warning
argument_list|(
literal|"File \"%s\" [0x%x] has ending address after starting address of next file; adjusting ending address down."
argument_list|,
name|full_name_string
argument_list|,
name|curr_fd
argument_list|)
expr_stmt|;
name|end_adr
operator|=
name|FILE_START
argument_list|(
name|curr_fd
operator|+
literal|1
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* Is -4 (or -8 for 64-bit) better? */
block|}
if|if
condition|(
name|VALID_MODULE
argument_list|(
name|curr_md
argument_list|)
operator|&&
operator|(
name|CURR_MODULE_START
operator|<=
name|end_adr
operator|)
condition|)
block|{
name|TELL_OBJFILE
expr_stmt|;
name|warning
argument_list|(
literal|"File \"%s\" [0x%x] has ending address after starting address of next module; adjusting ending address down."
argument_list|,
name|full_name_string
argument_list|,
name|curr_fd
argument_list|)
expr_stmt|;
name|end_adr
operator|=
name|CURR_MODULE_START
operator|-
literal|1
expr_stmt|;
comment|/* Is -4 (or -8 for 64-bit) better? */
block|}
ifdef|#
directive|ifdef
name|DUMPING
if|if
condition|(
name|dumping
condition|)
block|{
name|printf
argument_list|(
literal|"Make new psymtab for file %s (%x to %x).\n"
argument_list|,
name|full_name_string
argument_list|,
name|start_adr
argument_list|,
name|end_adr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Create the basic psymtab, connecting it in the list 	         for this objfile and pointing its symbol entries 	         to the current end of the symbol areas in the objfile.  	         The "ldsymoff" parameter is the byte offset in the LNTT 	         of the first symbol in this file.  Some day we should 	         turn this into an index (fix in hp-symtab-read.c as well). 	         And it's not even the right byte offset, as we're using 	         the size of a union! FIXME!  */
name|pst
operator|=
name|hpread_start_psymtab
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|,
comment|/* ?? */
name|full_name_string
argument_list|,
name|start_adr
argument_list|,
comment|/* Low text address */
operator|(
name|start_sym
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
operator|)
argument_list|,
comment|/* ldsymoff */
name|global_syms
argument_list|,
name|static_syms
argument_list|)
expr_stmt|;
comment|/* Set up to only enter each class referenced in this module once.  */
name|class_entered
operator|=
name|malloc
argument_list|(
name|B_BYTES
argument_list|(
name|pxdb_header_p
operator|->
name|cd_entries
argument_list|)
argument_list|)
expr_stmt|;
name|B_CLRALL
argument_list|(
name|class_entered
argument_list|,
name|pxdb_header_p
operator|->
name|cd_entries
argument_list|)
expr_stmt|;
comment|/* Scan the procedure descriptors for procedures in the current 	         file, based on the starting addresses. */
name|syms_in_pst
operator|=
name|scan_procs
argument_list|(
operator|&
name|curr_pd
argument_list|,
name|qPD
argument_list|,
name|pxdb_header_p
operator|->
name|pd_entries
argument_list|,
name|start_adr
argument_list|,
name|end_adr
argument_list|,
name|pst
argument_list|,
name|vt_bits
argument_list|,
name|objfile
argument_list|,
name|section_offsets
argument_list|)
expr_stmt|;
comment|/* Get ending symbol offset */
name|end_sym
operator|=
literal|0
expr_stmt|;
comment|/* First check for starting index before previous psymtab */
if|if
condition|(
name|pst_syms_count
operator|&&
name|start_sym
operator|<
name|pst_syms_array
index|[
name|pst_syms_count
operator|-
literal|1
index|]
operator|.
name|end
condition|)
block|{
name|end_sym
operator|=
name|find_next_pst_start
argument_list|(
name|start_sym
argument_list|)
expr_stmt|;
block|}
comment|/* Look for next start index of a file or module, or procedure */
if|if
condition|(
operator|!
name|end_sym
condition|)
block|{
name|int
name|next_file_isym
init|=
name|find_next_file_isym
argument_list|(
name|start_sym
argument_list|,
name|qFD
argument_list|,
name|curr_fd
operator|+
literal|1
argument_list|,
name|pxdb_header_p
argument_list|)
decl_stmt|;
name|int
name|next_module_isym
init|=
name|find_next_module_isym
argument_list|(
name|start_sym
argument_list|,
name|qMD
argument_list|,
name|curr_md
argument_list|,
name|pxdb_header_p
argument_list|)
decl_stmt|;
name|int
name|next_proc_isym
init|=
name|find_next_proc_isym
argument_list|(
name|start_sym
argument_list|,
name|qPD
argument_list|,
name|curr_pd
argument_list|,
name|pxdb_header_p
argument_list|)
decl_stmt|;
if|if
condition|(
name|next_file_isym
operator|&&
name|next_module_isym
condition|)
block|{
comment|/* pick lower of next file or module start index */
name|end_sym
operator|=
name|min
argument_list|(
name|next_file_isym
argument_list|,
name|next_module_isym
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* one of them is zero, pick the other */
name|end_sym
operator|=
name|max
argument_list|(
name|next_file_isym
argument_list|,
name|next_module_isym
argument_list|)
expr_stmt|;
block|}
comment|/* As a precaution, check next procedure index too */
if|if
condition|(
operator|!
name|end_sym
condition|)
name|end_sym
operator|=
name|next_proc_isym
expr_stmt|;
else|else
name|end_sym
operator|=
name|min
argument_list|(
name|end_sym
argument_list|,
name|next_proc_isym
argument_list|)
expr_stmt|;
block|}
comment|/* Couldn't find procedure, file, or module, use globals as default */
if|if
condition|(
operator|!
name|end_sym
condition|)
name|end_sym
operator|=
name|pxdb_header_p
operator|->
name|globals
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMPING
if|if
condition|(
name|dumping
condition|)
block|{
name|printf
argument_list|(
literal|"File psymtab indices: %x to %x\n"
argument_list|,
name|start_sym
argument_list|,
name|end_sym
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|pst
operator|=
name|hpread_end_psymtab
argument_list|(
name|pst
argument_list|,
name|NULL
argument_list|,
comment|/* psymtab_include_list */
literal|0
argument_list|,
comment|/* includes_used        */
name|end_sym
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
argument_list|,
comment|/* byte index in LNTT of end  						   = capping symbol offset    						   = LDSYMOFF of nextfile */
name|end_adr
argument_list|,
comment|/* text high */
name|NULL
argument_list|,
comment|/* dependency_list */
literal|0
argument_list|)
expr_stmt|;
comment|/* dependencies_used */
name|record_pst_syms
argument_list|(
name|start_sym
argument_list|,
name|end_sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|pst
condition|)
name|warning
argument_list|(
literal|"No symbols in psymtab for file \"%s\" [0x%x]."
argument_list|,
name|full_name_string
argument_list|,
name|curr_fd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMPING
if|if
condition|(
name|dumping
condition|)
block|{
name|printf
argument_list|(
literal|"Made new psymtab for file %s (%x to %x), sym %x to %x.\n"
argument_list|,
name|full_name_string
argument_list|,
name|start_adr
argument_list|,
name|end_adr
argument_list|,
name|CURR_FILE_ISYM
argument_list|,
name|end_sym
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Prepare for the next psymtab. */
name|global_syms
operator|=
name|objfile
operator|->
name|global_psymbols
operator|.
name|next
expr_stmt|;
name|static_syms
operator|=
name|objfile
operator|->
name|static_psymbols
operator|.
name|next
expr_stmt|;
name|free
argument_list|(
name|class_entered
argument_list|)
expr_stmt|;
name|curr_fd
operator|++
expr_stmt|;
block|}
comment|/* Psymtab for file */
else|else
block|{
comment|/* We have a module for which we create a psymtab */
name|mod_name_string
operator|=
operator|&
name|vt_bits
index|[
operator|(
name|long
operator|)
name|qMD
index|[
name|curr_md
index|]
operator|.
name|sbMod
index|]
expr_stmt|;
comment|/* We will include the code ranges of any files that happen to 	         overlap with this module */
comment|/* So, first pick the lower of the file's and module's start addresses */
name|start_adr
operator|=
name|CURR_MODULE_START
expr_stmt|;
if|if
condition|(
name|VALID_CURR_FILE
condition|)
block|{
if|if
condition|(
name|CURR_FILE_START
operator|<
name|CURR_MODULE_START
condition|)
block|{
name|TELL_OBJFILE
expr_stmt|;
name|warning
argument_list|(
literal|"File \"%s\" [0x%x] crosses beginning of module \"%s\"."
argument_list|,
operator|&
name|vt_bits
index|[
operator|(
name|long
operator|)
name|qFD
index|[
name|curr_fd
index|]
operator|.
name|sbFile
index|]
argument_list|,
name|curr_fd
argument_list|,
name|mod_name_string
argument_list|)
expr_stmt|;
name|start_adr
operator|=
name|CURR_FILE_START
expr_stmt|;
block|}
block|}
comment|/* Also pick the lower of the file's and the module's start symbol indices */
name|start_sym
operator|=
name|CURR_MODULE_ISYM
expr_stmt|;
if|if
condition|(
name|VALID_CURR_FILE
operator|&&
operator|(
name|CURR_FILE_ISYM
operator|<
name|CURR_MODULE_ISYM
operator|)
condition|)
name|start_sym
operator|=
name|CURR_FILE_ISYM
expr_stmt|;
comment|/* For the end address, we scan through the files till we find one 	         that overlaps the current module but ends beyond it; if no such file exists we 	         simply use the module's start address.   	         (Note, if file entries themselves overlap 	         we take the longest overlapping extension beyond the end of the module...) 	         We assume that modules never overlap. */
name|end_adr
operator|=
name|CURR_MODULE_END
expr_stmt|;
if|if
condition|(
name|VALID_CURR_FILE
condition|)
block|{
while|while
condition|(
name|VALID_CURR_FILE
operator|&&
operator|(
name|CURR_FILE_START
operator|<
name|end_adr
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DUMPING
if|if
condition|(
name|dumping
condition|)
name|printf
argument_list|(
literal|"Maybe skipping file %s which overlaps with module %s\n"
argument_list|,
operator|&
name|vt_bits
index|[
operator|(
name|long
operator|)
name|qFD
index|[
name|curr_fd
index|]
operator|.
name|sbFile
index|]
argument_list|,
name|mod_name_string
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|CURR_FILE_END
operator|>
name|end_adr
condition|)
block|{
name|TELL_OBJFILE
expr_stmt|;
name|warning
argument_list|(
literal|"File \"%s\" [0x%x] crosses end of module \"%s\"."
argument_list|,
operator|&
name|vt_bits
index|[
operator|(
name|long
operator|)
name|qFD
index|[
name|curr_fd
index|]
operator|.
name|sbFile
index|]
argument_list|,
name|curr_fd
argument_list|,
name|mod_name_string
argument_list|)
expr_stmt|;
name|end_adr
operator|=
name|CURR_FILE_END
expr_stmt|;
block|}
name|curr_fd
operator|++
expr_stmt|;
block|}
name|curr_fd
operator|--
expr_stmt|;
comment|/* back up after going too far */
block|}
comment|/* Sometimes (compiler bug -- COBOL) the module end address is higher 	         than the start address of the next module, so check for that and 	         adjust accordingly */
if|if
condition|(
name|VALID_MODULE
argument_list|(
name|curr_md
operator|+
literal|1
argument_list|)
operator|&&
operator|(
name|MODULE_START
argument_list|(
name|curr_md
operator|+
literal|1
argument_list|)
operator|<=
name|end_adr
operator|)
condition|)
block|{
name|TELL_OBJFILE
expr_stmt|;
name|warning
argument_list|(
literal|"Module \"%s\" [0x%x] has ending address after starting address of next module; adjusting ending address down."
argument_list|,
name|mod_name_string
argument_list|,
name|curr_md
argument_list|)
expr_stmt|;
name|end_adr
operator|=
name|MODULE_START
argument_list|(
name|curr_md
operator|+
literal|1
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* Is -4 (or -8 for 64-bit) better? */
block|}
if|if
condition|(
name|VALID_FILE
argument_list|(
name|curr_fd
operator|+
literal|1
argument_list|)
operator|&&
operator|(
name|FILE_START
argument_list|(
name|curr_fd
operator|+
literal|1
argument_list|)
operator|<=
name|end_adr
operator|)
condition|)
block|{
name|TELL_OBJFILE
expr_stmt|;
name|warning
argument_list|(
literal|"Module \"%s\" [0x%x] has ending address after starting address of next file; adjusting ending address down."
argument_list|,
name|mod_name_string
argument_list|,
name|curr_md
argument_list|)
expr_stmt|;
name|end_adr
operator|=
name|FILE_START
argument_list|(
name|curr_fd
operator|+
literal|1
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* Is -4 (or -8 for 64-bit) better? */
block|}
comment|/* Use one file to get the full name for the module.  This 	         situation can arise if there is executable code in a #include 	         file.  Each file with code in it gets a qFD.  Files which don't 	         contribute code don't get a qFD, even if they include files 	         which do, e.g.:   	         body.c:                    rtn.h: 	         int x;                     int main() { 	         #include "rtn.h"               return x; 	         }  	         There will a qFD for "rtn.h",and a qMD for "body.c", 	         but no qMD for "rtn.h" or qFD for "body.c"!  	         We pick the name of the last file to overlap with this 	         module.  C convention is to put include files first.  In a 	         perfect world, we could check names and use the file whose full 	         path name ends with the module name. */
if|if
condition|(
name|VALID_CURR_FILE
condition|)
name|full_name_string
operator|=
operator|&
name|vt_bits
index|[
operator|(
name|long
operator|)
name|qFD
index|[
name|curr_fd
index|]
operator|.
name|sbFile
index|]
expr_stmt|;
else|else
name|full_name_string
operator|=
name|mod_name_string
expr_stmt|;
comment|/* Check if there are any procedures not handled until now, that 	         begin before the start address we have now, and if so, adjust 	         this psymtab's start address to include them.  This handles routines that 	         are in between file or module ranges for some reason (probably 	         indicates a compiler bug */
if|if
condition|(
name|CURR_PROC_START
operator|<
name|start_adr
condition|)
block|{
name|TELL_OBJFILE
expr_stmt|;
name|warning
argument_list|(
literal|"Found procedure \"%s\" [0x%x] that is not in any file or module."
argument_list|,
operator|&
name|vt_bits
index|[
operator|(
name|long
operator|)
name|qPD
index|[
name|curr_pd
index|]
operator|.
name|sbProc
index|]
argument_list|,
name|curr_pd
argument_list|)
expr_stmt|;
name|start_adr
operator|=
name|CURR_PROC_START
expr_stmt|;
if|if
condition|(
name|CURR_PROC_ISYM
operator|<
name|start_sym
condition|)
name|start_sym
operator|=
name|CURR_PROC_ISYM
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DUMPING
if|if
condition|(
name|dumping
condition|)
block|{
name|printf
argument_list|(
literal|"Make new psymtab for module %s (%x to %x), using file %s\n"
argument_list|,
name|mod_name_string
argument_list|,
name|start_adr
argument_list|,
name|end_adr
argument_list|,
name|full_name_string
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Create the basic psymtab, connecting it in the list 	         for this objfile and pointing its symbol entries 	         to the current end of the symbol areas in the objfile.  	         The "ldsymoff" parameter is the byte offset in the LNTT 	         of the first symbol in this file.  Some day we should 	         turn this into an index (fix in hp-symtab-read.c as well). 	         And it's not even the right byte offset, as we're using 	         the size of a union! FIXME!  */
name|pst
operator|=
name|hpread_start_psymtab
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|,
comment|/* ?? */
name|full_name_string
argument_list|,
name|start_adr
argument_list|,
comment|/* Low text address */
operator|(
name|start_sym
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
operator|)
argument_list|,
comment|/* ldsymoff */
name|global_syms
argument_list|,
name|static_syms
argument_list|)
expr_stmt|;
comment|/* Set up to only enter each class referenced in this module once.  */
name|class_entered
operator|=
name|malloc
argument_list|(
name|B_BYTES
argument_list|(
name|pxdb_header_p
operator|->
name|cd_entries
argument_list|)
argument_list|)
expr_stmt|;
name|B_CLRALL
argument_list|(
name|class_entered
argument_list|,
name|pxdb_header_p
operator|->
name|cd_entries
argument_list|)
expr_stmt|;
comment|/* Scan the procedure descriptors for procedures in the current 	         module, based on the starting addresses. */
name|syms_in_pst
operator|=
name|scan_procs
argument_list|(
operator|&
name|curr_pd
argument_list|,
name|qPD
argument_list|,
name|pxdb_header_p
operator|->
name|pd_entries
argument_list|,
name|start_adr
argument_list|,
name|end_adr
argument_list|,
name|pst
argument_list|,
name|vt_bits
argument_list|,
name|objfile
argument_list|,
name|section_offsets
argument_list|)
expr_stmt|;
comment|/* Get ending symbol offset */
name|end_sym
operator|=
literal|0
expr_stmt|;
comment|/* First check for starting index before previous psymtab */
if|if
condition|(
name|pst_syms_count
operator|&&
name|start_sym
operator|<
name|pst_syms_array
index|[
name|pst_syms_count
operator|-
literal|1
index|]
operator|.
name|end
condition|)
block|{
name|end_sym
operator|=
name|find_next_pst_start
argument_list|(
name|start_sym
argument_list|)
expr_stmt|;
block|}
comment|/* Look for next start index of a file or module, or procedure */
if|if
condition|(
operator|!
name|end_sym
condition|)
block|{
name|int
name|next_file_isym
init|=
name|find_next_file_isym
argument_list|(
name|start_sym
argument_list|,
name|qFD
argument_list|,
name|curr_fd
operator|+
literal|1
argument_list|,
name|pxdb_header_p
argument_list|)
decl_stmt|;
name|int
name|next_module_isym
init|=
name|find_next_module_isym
argument_list|(
name|start_sym
argument_list|,
name|qMD
argument_list|,
name|curr_md
operator|+
literal|1
argument_list|,
name|pxdb_header_p
argument_list|)
decl_stmt|;
name|int
name|next_proc_isym
init|=
name|find_next_proc_isym
argument_list|(
name|start_sym
argument_list|,
name|qPD
argument_list|,
name|curr_pd
argument_list|,
name|pxdb_header_p
argument_list|)
decl_stmt|;
if|if
condition|(
name|next_file_isym
operator|&&
name|next_module_isym
condition|)
block|{
comment|/* pick lower of next file or module start index */
name|end_sym
operator|=
name|min
argument_list|(
name|next_file_isym
argument_list|,
name|next_module_isym
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* one of them is zero, pick the other */
name|end_sym
operator|=
name|max
argument_list|(
name|next_file_isym
argument_list|,
name|next_module_isym
argument_list|)
expr_stmt|;
block|}
comment|/* As a precaution, check next procedure index too */
if|if
condition|(
operator|!
name|end_sym
condition|)
name|end_sym
operator|=
name|next_proc_isym
expr_stmt|;
else|else
name|end_sym
operator|=
name|min
argument_list|(
name|end_sym
argument_list|,
name|next_proc_isym
argument_list|)
expr_stmt|;
block|}
comment|/* Couldn't find procedure, file, or module, use globals as default */
if|if
condition|(
operator|!
name|end_sym
condition|)
name|end_sym
operator|=
name|pxdb_header_p
operator|->
name|globals
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMPING
if|if
condition|(
name|dumping
condition|)
block|{
name|printf
argument_list|(
literal|"Module psymtab indices: %x to %x\n"
argument_list|,
name|start_sym
argument_list|,
name|end_sym
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|pst
operator|=
name|hpread_end_psymtab
argument_list|(
name|pst
argument_list|,
name|NULL
argument_list|,
comment|/* psymtab_include_list */
literal|0
argument_list|,
comment|/* includes_used        */
name|end_sym
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
argument_list|,
comment|/* byte index in LNTT of end  						   = capping symbol offset    						   = LDSYMOFF of nextfile */
name|end_adr
argument_list|,
comment|/* text high */
name|NULL
argument_list|,
comment|/* dependency_list      */
literal|0
argument_list|)
expr_stmt|;
comment|/* dependencies_used    */
name|record_pst_syms
argument_list|(
name|start_sym
argument_list|,
name|end_sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|NULL
operator|==
name|pst
condition|)
name|warning
argument_list|(
literal|"No symbols in psymtab for module \"%s\" [0x%x]."
argument_list|,
name|mod_name_string
argument_list|,
name|curr_md
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMPING
if|if
condition|(
name|dumping
condition|)
block|{
name|printf
argument_list|(
literal|"Made new psymtab for module %s (%x to %x), sym %x to %x.\n"
argument_list|,
name|mod_name_string
argument_list|,
name|start_adr
argument_list|,
name|end_adr
argument_list|,
name|CURR_MODULE_ISYM
argument_list|,
name|end_sym
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Prepare for the next psymtab. */
name|global_syms
operator|=
name|objfile
operator|->
name|global_psymbols
operator|.
name|next
expr_stmt|;
name|static_syms
operator|=
name|objfile
operator|->
name|static_psymbols
operator|.
name|next
expr_stmt|;
name|free
argument_list|(
name|class_entered
argument_list|)
expr_stmt|;
name|curr_md
operator|++
expr_stmt|;
name|curr_fd
operator|++
expr_stmt|;
block|}
comment|/* psymtab for module */
block|}
comment|/* psymtab for non-bogus file or module */
block|}
comment|/* End of while loop over all files& modules */
comment|/* There may be some routines after all files and modules -- these will get      inserted in a separate new module of their own */
if|if
condition|(
name|VALID_CURR_PROC
condition|)
block|{
name|start_adr
operator|=
name|CURR_PROC_START
expr_stmt|;
name|end_adr
operator|=
name|qPD
index|[
name|pxdb_header_p
operator|->
name|pd_entries
operator|-
literal|1
index|]
operator|.
name|adrEnd
expr_stmt|;
name|TELL_OBJFILE
expr_stmt|;
name|warning
argument_list|(
literal|"Found functions beyond end of all files and modules [0x%x]."
argument_list|,
name|curr_pd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMPING
if|if
condition|(
name|dumping
condition|)
block|{
name|printf
argument_list|(
literal|"Orphan functions at end, PD %d and beyond (%x to %x)\n"
argument_list|,
name|curr_pd
argument_list|,
name|start_adr
argument_list|,
name|end_adr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|pst
operator|=
name|hpread_start_psymtab
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|,
comment|/* ?? */
literal|"orphans"
argument_list|,
name|start_adr
argument_list|,
comment|/* Low text address */
operator|(
name|CURR_PROC_ISYM
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
operator|)
argument_list|,
comment|/* ldsymoff */
name|global_syms
argument_list|,
name|static_syms
argument_list|)
expr_stmt|;
name|scan_procs
argument_list|(
operator|&
name|curr_pd
argument_list|,
name|qPD
argument_list|,
name|pxdb_header_p
operator|->
name|pd_entries
argument_list|,
name|start_adr
argument_list|,
name|end_adr
argument_list|,
name|pst
argument_list|,
name|vt_bits
argument_list|,
name|objfile
argument_list|,
name|section_offsets
argument_list|)
expr_stmt|;
name|pst
operator|=
name|hpread_end_psymtab
argument_list|(
name|pst
argument_list|,
name|NULL
argument_list|,
comment|/* psymtab_include_list */
literal|0
argument_list|,
comment|/* includes_used */
name|pxdb_header_p
operator|->
name|globals
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
argument_list|,
comment|/* byte index in LNTT of end  					   = capping symbol offset    					   = LDSYMOFF of nextfile */
name|end_adr
argument_list|,
comment|/* text high  */
name|NULL
argument_list|,
comment|/* dependency_list */
literal|0
argument_list|)
expr_stmt|;
comment|/* dependencies_used */
block|}
ifdef|#
directive|ifdef
name|NEVER_NEVER
comment|/* Now build psts for non-module things (in the tail of      the LNTT, after the last END MODULE entry).       If null psts were kept on the chain, this would be      a solution.  FIXME */
name|pst
operator|=
name|hpread_start_psymtab
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|,
literal|"globals"
argument_list|,
literal|0
argument_list|,
operator|(
name|pxdb_header_p
operator|->
name|globals
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
operator|)
argument_list|,
name|objfile
operator|->
name|global_psymbols
operator|.
name|next
argument_list|,
name|objfile
operator|->
name|static_psymbols
operator|.
name|next
argument_list|)
expr_stmt|;
name|hpread_end_psymtab
argument_list|(
name|pst
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|(
name|max_LNTT_sym_index
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|clear_pst_syms
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* End of hpread_quick_traverse. */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Get appropriate header, based on pxdb type.     Return value: 1 if ok, 0 if not */
end_comment

begin_function
name|int
name|hpread_get_header
parameter_list|(
name|objfile
parameter_list|,
name|pxdb_header_p
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|PXDB_header_ptr
name|pxdb_header_p
decl_stmt|;
block|{
name|asection
modifier|*
name|pinfo_section
decl_stmt|,
modifier|*
name|debug_section
decl_stmt|,
modifier|*
name|header_section
decl_stmt|;
ifdef|#
directive|ifdef
name|DUMPING
comment|/* Turn on for debugging information */
specifier|static
name|int
name|dumping
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|header_section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
literal|"$HEADER$"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|header_section
condition|)
block|{
comment|/* We don't have either PINFO or DEBUG sections.  But          stuff like "libc.sl" has no debug info.  There's no          need to warn the user of this, as it may be ok. The          caller will figure it out and issue any needed          messages. */
ifdef|#
directive|ifdef
name|DUMPING
if|if
condition|(
name|dumping
condition|)
name|printf
argument_list|(
literal|"==No debug info at all for %s.\n"
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
comment|/* We would like either a $DEBUG$ or $PINFO$ section.      Once we know which, we can understand the header      data (which we have defined to suit the more common      $DEBUG$ case). */
name|debug_section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
literal|"$DEBUG$"
argument_list|)
expr_stmt|;
name|pinfo_section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
literal|"$PINFO$"
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_section
condition|)
block|{
comment|/* The expected case: normal pxdb header. */
name|bfd_get_section_contents
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|header_section
argument_list|,
name|pxdb_header_p
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|PXDB_header
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pxdb_header_p
operator|->
name|pxdbed
condition|)
block|{
comment|/* This shouldn't happen if we check in "symfile.c". */
return|return
literal|0
return|;
block|}
comment|/* DEBUG section */
block|}
elseif|else
if|if
condition|(
name|pinfo_section
condition|)
block|{
comment|/* The DOC case; we need to translate this into a          regular header. */
name|DOC_info_PXDB_header
name|doc_header
decl_stmt|;
ifdef|#
directive|ifdef
name|DUMPING
if|if
condition|(
name|dumping
condition|)
block|{
name|printf
argument_list|(
literal|"==OOps, PINFO, let's try to handle this, %s.\n"
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|bfd_get_section_contents
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|header_section
argument_list|,
operator|&
name|doc_header
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|DOC_info_PXDB_header
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|doc_header
operator|.
name|pxdbed
condition|)
block|{
comment|/* This shouldn't happen if we check in "symfile.c". */
name|warning
argument_list|(
literal|"File \"%s\" not processed by pxdb!"
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Copy relevent fields to standard header passed in. */
name|pxdb_header_p
operator|->
name|pd_entries
operator|=
name|doc_header
operator|.
name|pd_entries
expr_stmt|;
name|pxdb_header_p
operator|->
name|fd_entries
operator|=
name|doc_header
operator|.
name|fd_entries
expr_stmt|;
name|pxdb_header_p
operator|->
name|md_entries
operator|=
name|doc_header
operator|.
name|md_entries
expr_stmt|;
name|pxdb_header_p
operator|->
name|pxdbed
operator|=
name|doc_header
operator|.
name|pxdbed
expr_stmt|;
name|pxdb_header_p
operator|->
name|bighdr
operator|=
name|doc_header
operator|.
name|bighdr
expr_stmt|;
name|pxdb_header_p
operator|->
name|sa_header
operator|=
name|doc_header
operator|.
name|sa_header
expr_stmt|;
name|pxdb_header_p
operator|->
name|inlined
operator|=
name|doc_header
operator|.
name|inlined
expr_stmt|;
name|pxdb_header_p
operator|->
name|globals
operator|=
name|doc_header
operator|.
name|globals
expr_stmt|;
name|pxdb_header_p
operator|->
name|time
operator|=
name|doc_header
operator|.
name|time
expr_stmt|;
name|pxdb_header_p
operator|->
name|pg_entries
operator|=
name|doc_header
operator|.
name|pg_entries
expr_stmt|;
name|pxdb_header_p
operator|->
name|functions
operator|=
name|doc_header
operator|.
name|functions
expr_stmt|;
name|pxdb_header_p
operator|->
name|files
operator|=
name|doc_header
operator|.
name|files
expr_stmt|;
name|pxdb_header_p
operator|->
name|cd_entries
operator|=
name|doc_header
operator|.
name|cd_entries
expr_stmt|;
name|pxdb_header_p
operator|->
name|aa_entries
operator|=
name|doc_header
operator|.
name|aa_entries
expr_stmt|;
name|pxdb_header_p
operator|->
name|oi_entries
operator|=
name|doc_header
operator|.
name|oi_entries
expr_stmt|;
name|pxdb_header_p
operator|->
name|version
operator|=
name|doc_header
operator|.
name|version
expr_stmt|;
block|}
comment|/* PINFO section */
else|else
block|{
ifdef|#
directive|ifdef
name|DUMPING
if|if
condition|(
name|dumping
condition|)
name|printf
argument_list|(
literal|"==No debug info at all for %s.\n"
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* End of hpread_get_header */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* QUICK_LOOK_UP */
end_comment

begin_escape
end_escape

begin_comment
comment|/* Initialization for reading native HP C debug symbols from OBJFILE.     Its only purpose in life is to set up the symbol reader's private    per-objfile data structures, and read in the raw contents of the debug    sections (attaching pointers to the debug info into the private data    structures).     Since BFD doesn't know how to read debug symbols in a format-independent    way (and may never do so...), we have to do it ourselves.  Note we may    be called on a file without native HP C debugging symbols.     FIXME, there should be a cleaner peephole into the BFD environment    here. */
end_comment

begin_function
name|void
name|hpread_symfile_init
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|asection
modifier|*
name|vt_section
decl_stmt|,
modifier|*
name|slt_section
decl_stmt|,
modifier|*
name|lntt_section
decl_stmt|,
modifier|*
name|gntt_section
decl_stmt|;
comment|/* Allocate struct to keep track of the symfile */
name|objfile
operator|->
name|sym_private
operator|=
operator|(
name|PTR
operator|)
name|xmmalloc
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hpread_symfile_info
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|objfile
operator|->
name|sym_private
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hpread_symfile_info
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We haven't read in any types yet.  */
name|TYPE_VECTOR
argument_list|(
name|objfile
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* Read in data from the $GNTT$ subspace.  */
name|gntt_section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
literal|"$GNTT$"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gntt_section
condition|)
return|return;
name|GNTT
argument_list|(
name|objfile
argument_list|)
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
name|bfd_section_size
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|gntt_section
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_get_section_contents
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|gntt_section
argument_list|,
name|GNTT
argument_list|(
name|objfile
argument_list|)
argument_list|,
literal|0
argument_list|,
name|bfd_section_size
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|gntt_section
argument_list|)
argument_list|)
expr_stmt|;
name|GNTT_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
operator|=
name|bfd_section_size
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|gntt_section
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
expr_stmt|;
comment|/* Read in data from the $LNTT$ subspace.   Also keep track of the number      of LNTT symbols.       FIXME: this could be moved into the psymtab-to-symtab expansion      code, and save startup time.  At the moment this data is      still used, though.  We'd need a way to tell hp-symtab-read.c      whether or not to load the LNTT. */
name|lntt_section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
literal|"$LNTT$"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lntt_section
condition|)
return|return;
name|LNTT
argument_list|(
name|objfile
argument_list|)
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
name|bfd_section_size
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|lntt_section
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_get_section_contents
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|lntt_section
argument_list|,
name|LNTT
argument_list|(
name|objfile
argument_list|)
argument_list|,
literal|0
argument_list|,
name|bfd_section_size
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|lntt_section
argument_list|)
argument_list|)
expr_stmt|;
name|LNTT_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
operator|=
name|bfd_section_size
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|lntt_section
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
expr_stmt|;
comment|/* Read in data from the $SLT$ subspace.  $SLT$ contains information      on source line numbers.  */
name|slt_section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
literal|"$SLT$"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|slt_section
condition|)
return|return;
name|SLT
argument_list|(
name|objfile
argument_list|)
operator|=
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
name|bfd_section_size
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|slt_section
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_get_section_contents
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|slt_section
argument_list|,
name|SLT
argument_list|(
name|objfile
argument_list|)
argument_list|,
literal|0
argument_list|,
name|bfd_section_size
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|slt_section
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read in data from the $VT$ subspace.  $VT$ contains things like      names and constants.  Keep track of the number of symbols in the VT.  */
name|vt_section
operator|=
name|bfd_get_section_by_name
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
literal|"$VT$"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vt_section
condition|)
return|return;
name|VT_SIZE
argument_list|(
name|objfile
argument_list|)
operator|=
name|bfd_section_size
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|vt_section
argument_list|)
expr_stmt|;
name|VT
argument_list|(
name|objfile
argument_list|)
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|symbol_obstack
argument_list|,
name|VT_SIZE
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_get_section_contents
argument_list|(
name|objfile
operator|->
name|obfd
argument_list|,
name|vt_section
argument_list|,
name|VT
argument_list|(
name|objfile
argument_list|)
argument_list|,
literal|0
argument_list|,
name|VT_SIZE
argument_list|(
name|objfile
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Scan and build partial symbols for a symbol file.     The minimal symbol table (either SOM or HP a.out) has already been    read in; all we need to do is setup partial symbols based on the    native debugging information.     Note that the minimal table is produced by the linker, and has    only global routines in it; the psymtab is based on compiler-    generated debug information and has non-global    routines in it as well as files and class information.     We assume hpread_symfile_init has been called to initialize the    symbol reader's private data structures.     SECTION_OFFSETS contains offsets relative to which the symbols in the    various sections are (depending where the sections were actually loaded).    MAINLINE is true if we are reading the main symbol table (as    opposed to a shared lib or dynamically loaded file). */
end_comment

begin_function
name|void
name|hpread_build_psymtabs
parameter_list|(
name|objfile
parameter_list|,
name|section_offsets
parameter_list|,
name|mainline
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|int
name|mainline
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|DUMPING
comment|/* Turn this on to get debugging output. */
specifier|static
name|int
name|dumping
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|namestring
decl_stmt|;
name|int
name|past_first_source_file
init|=
literal|0
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|old_chain
decl_stmt|;
name|int
name|hp_symnum
decl_stmt|,
name|symcount
decl_stmt|,
name|i
decl_stmt|;
name|int
name|scan_start
init|=
literal|0
decl_stmt|;
name|union
name|dnttentry
modifier|*
name|dn_bufp
decl_stmt|;
name|unsigned
name|long
name|valu
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|texthigh
init|=
literal|0
decl_stmt|;
name|int
name|have_name
init|=
literal|0
decl_stmt|;
comment|/* Current partial symtab */
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
comment|/* List of current psymtab's include files */
name|char
modifier|*
modifier|*
name|psymtab_include_list
decl_stmt|;
name|int
name|includes_allocated
decl_stmt|;
name|int
name|includes_used
decl_stmt|;
comment|/* Index within current psymtab dependency list */
name|struct
name|partial_symtab
modifier|*
modifier|*
name|dependency_list
decl_stmt|;
name|int
name|dependencies_used
decl_stmt|,
name|dependencies_allocated
decl_stmt|;
comment|/* Just in case the stabs reader left turds lying around.  */
name|free_pending_blocks
argument_list|()
expr_stmt|;
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|really_free_pendings
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pst
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* We shouldn't use alloca, instead use malloc/free.  Doing so avoids      a number of problems with cross compilation and creating useless holes      in the stack when we have to allocate new entries.  FIXME.  */
name|includes_allocated
operator|=
literal|30
expr_stmt|;
name|includes_used
operator|=
literal|0
expr_stmt|;
name|psymtab_include_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|includes_allocated
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|dependencies_allocated
operator|=
literal|30
expr_stmt|;
name|dependencies_used
operator|=
literal|0
expr_stmt|;
name|dependency_list
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|*
operator|)
name|alloca
argument_list|(
name|dependencies_allocated
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|old_chain
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|free_objfile
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|last_source_file
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|QUICK_LOOK_UP
block|{
comment|/* Begin code for new-style loading of quick look-up tables. */
comment|/* elz: this checks whether the file has beeen processed by pxdb.        If not we would like to try to read the psymbols in        anyway, but it turns out to be not so easy. So this could         actually be commented out, but I leave it in, just in case        we decide to add support for non-pxdb-ed stuff in the future. */
name|PXDB_header
name|pxdb_header
decl_stmt|;
name|int
name|found_modules_in_program
decl_stmt|;
if|if
condition|(
name|hpread_get_header
argument_list|(
name|objfile
argument_list|,
operator|&
name|pxdb_header
argument_list|)
condition|)
block|{
comment|/* Build a minimal table.  No types, no global variables, 	   no include files.... */
ifdef|#
directive|ifdef
name|DUMPING
if|if
condition|(
name|dumping
condition|)
name|printf
argument_list|(
literal|"\nNew method for %s\n"
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* elz: quick_traverse returns true if it found 	   some modules in the main source file, other 	   than those in end.c 	   In C and C++, all the files have MODULES entries 	   in the LNTT, and the quick table traverse is all  	   based on finding these MODULES entries. Without  	   those it cannot work.  	   It happens that F77 programs don't have MODULES 	   so the quick traverse gets confused. F90 programs 	   have modules, and the quick method still works. 	   So, if modules (other than those in end.c) are 	   not found we give up on the quick table stuff,  	   and fall back on the slower method  */
name|found_modules_in_program
operator|=
name|hpread_quick_traverse
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|,
name|GNTT
argument_list|(
name|objfile
argument_list|)
argument_list|,
name|VT
argument_list|(
name|objfile
argument_list|)
argument_list|,
operator|&
name|pxdb_header
argument_list|)
expr_stmt|;
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
comment|/* Set up to scan the global section of the LNTT.  		   This field is not always correct: if there are 		   no globals, it will point to the last record in 		   the regular LNTT, which is usually an END MODULE.  		   Since it might happen that there could be a file 		   with just one global record, there's no way to 		   tell other than by looking at the record, so that's 		   done below. */
if|if
condition|(
name|found_modules_in_program
condition|)
name|scan_start
operator|=
name|pxdb_header
operator|.
name|globals
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DUMPING
else|else
block|{
if|if
condition|(
name|dumping
condition|)
name|printf
argument_list|(
literal|"\nGoing on to old method for %s\n"
argument_list|,
name|objfile
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* QUICK_LOOK_UP */
comment|/* Make two passes, one over the GNTT symbols, the other for the        LNTT symbols.       JB comment: above isn't true--they only make one pass, over      the LNTT.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|int
name|within_function
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|i
condition|)
name|symcount
operator|=
name|GNTT_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
else|else
name|symcount
operator|=
name|LNTT_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
for|for
control|(
name|hp_symnum
operator|=
name|scan_start
init|;
name|hp_symnum
operator|<
name|symcount
condition|;
name|hp_symnum
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|dn_bufp
operator|=
name|hpread_get_gntt
argument_list|(
name|hp_symnum
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
else|else
name|dn_bufp
operator|=
name|hpread_get_lntt
argument_list|(
name|hp_symnum
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|extension
condition|)
continue|continue;
comment|/* Only handle things which are necessary for minimal symbols. 	     everything else is ignored.  */
switch|switch
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
condition|)
block|{
case|case
name|DNTT_TYPE_SRCFILE
case|:
block|{
ifdef|#
directive|ifdef
name|QUICK_LOOK_UP
if|if
condition|(
name|scan_start
operator|==
name|hp_symnum
operator|&&
name|symcount
operator|==
name|hp_symnum
operator|+
literal|1
condition|)
block|{
comment|/* If there are NO globals in an executable, 		       PXDB's index to the globals will point to 		       the last record in the file, which  		       could be this record. (this happened for F77 libraries) 		       ignore it and be done! */
continue|continue;
block|}
endif|#
directive|endif
comment|/* QUICK_LOOK_UP */
comment|/* A source file of some kind.  Note this may simply 		   be an included file.  */
name|SET_NAMESTRING
argument_list|(
name|dn_bufp
argument_list|,
operator|&
name|namestring
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Check if this is the source file we are already working 		   with.  */
if|if
condition|(
name|pst
operator|&&
operator|!
name|strcmp
argument_list|(
name|namestring
argument_list|,
name|pst
operator|->
name|filename
argument_list|)
condition|)
continue|continue;
comment|/* Check if this is an include file, if so check if we have 		   already seen it.  Add it to the include list */
name|p
operator|=
name|strrchr
argument_list|(
name|namestring
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
argument_list|,
literal|".h"
argument_list|)
condition|)
block|{
name|int
name|j
decl_stmt|,
name|found
decl_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|includes_used
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|namestring
argument_list|,
name|psymtab_include_list
index|[
name|j
index|]
argument_list|)
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|found
condition|)
continue|continue;
comment|/* Add it to the list of includes seen so far and 		       allocate more include space if necessary.  */
name|psymtab_include_list
index|[
name|includes_used
operator|++
index|]
operator|=
name|namestring
expr_stmt|;
if|if
condition|(
name|includes_used
operator|>=
name|includes_allocated
condition|)
block|{
name|char
modifier|*
modifier|*
name|orig
init|=
name|psymtab_include_list
decl_stmt|;
name|psymtab_include_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|includes_allocated
operator|*=
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|PTR
operator|)
name|psymtab_include_list
argument_list|,
operator|(
name|PTR
operator|)
name|orig
argument_list|,
name|includes_used
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|pst
condition|)
block|{
if|if
condition|(
operator|!
name|have_name
condition|)
block|{
name|pst
operator|->
name|filename
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|pst
operator|->
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
name|strlen
argument_list|(
name|namestring
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|pst
operator|->
name|filename
argument_list|,
name|namestring
argument_list|)
expr_stmt|;
name|have_name
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
continue|continue;
block|}
comment|/* This is a bonafide new source file. 		   End the current partial symtab and start a new one.  */
if|if
condition|(
name|pst
operator|&&
name|past_first_source_file
condition|)
block|{
name|hpread_end_psymtab
argument_list|(
name|pst
argument_list|,
name|psymtab_include_list
argument_list|,
name|includes_used
argument_list|,
operator|(
name|hp_symnum
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
operator|)
argument_list|,
name|texthigh
argument_list|,
name|dependency_list
argument_list|,
name|dependencies_used
argument_list|)
expr_stmt|;
name|pst
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
literal|0
expr_stmt|;
name|includes_used
operator|=
literal|0
expr_stmt|;
name|dependencies_used
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|past_first_source_file
operator|=
literal|1
expr_stmt|;
name|valu
operator|=
name|hpread_get_textlow
argument_list|(
name|i
argument_list|,
name|hp_symnum
argument_list|,
name|objfile
argument_list|,
name|symcount
argument_list|)
expr_stmt|;
name|valu
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
name|pst
operator|=
name|hpread_start_psymtab
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|,
name|namestring
argument_list|,
name|valu
argument_list|,
operator|(
name|hp_symnum
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
operator|)
argument_list|,
name|objfile
operator|->
name|global_psymbols
operator|.
name|next
argument_list|,
name|objfile
operator|->
name|static_psymbols
operator|.
name|next
argument_list|)
expr_stmt|;
name|texthigh
operator|=
name|valu
expr_stmt|;
name|have_name
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
case|case
name|DNTT_TYPE_MODULE
case|:
comment|/* A source file.  It's still unclear to me what the 	         real difference between a DNTT_TYPE_SRCFILE and DNTT_TYPE_MODULE 	         is supposed to be.  */
comment|/* First end the previous psymtab */
if|if
condition|(
name|pst
condition|)
block|{
name|hpread_end_psymtab
argument_list|(
name|pst
argument_list|,
name|psymtab_include_list
argument_list|,
name|includes_used
argument_list|,
operator|(
operator|(
name|hp_symnum
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
operator|)
argument_list|,
name|texthigh
argument_list|,
name|dependency_list
argument_list|,
name|dependencies_used
argument_list|)
expr_stmt|;
name|pst
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
literal|0
expr_stmt|;
name|includes_used
operator|=
literal|0
expr_stmt|;
name|dependencies_used
operator|=
literal|0
expr_stmt|;
name|have_name
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Now begin a new module and a new psymtab for it */
name|SET_NAMESTRING
argument_list|(
name|dn_bufp
argument_list|,
operator|&
name|namestring
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|valu
operator|=
name|hpread_get_textlow
argument_list|(
name|i
argument_list|,
name|hp_symnum
argument_list|,
name|objfile
argument_list|,
name|symcount
argument_list|)
expr_stmt|;
name|valu
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pst
condition|)
block|{
name|pst
operator|=
name|hpread_start_psymtab
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|,
name|namestring
argument_list|,
name|valu
argument_list|,
operator|(
name|hp_symnum
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
operator|)
argument_list|,
name|objfile
operator|->
name|global_psymbols
operator|.
name|next
argument_list|,
name|objfile
operator|->
name|static_psymbols
operator|.
name|next
argument_list|)
expr_stmt|;
name|texthigh
operator|=
name|valu
expr_stmt|;
name|have_name
operator|=
literal|0
expr_stmt|;
block|}
continue|continue;
case|case
name|DNTT_TYPE_FUNCTION
case|:
case|case
name|DNTT_TYPE_ENTRY
case|:
comment|/* The beginning of a function.  DNTT_TYPE_ENTRY may also denote 	         a secondary entry point.  */
name|valu
operator|=
name|dn_bufp
operator|->
name|dfunc
operator|.
name|hiaddr
operator|+
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|valu
operator|>
name|texthigh
condition|)
name|texthigh
operator|=
name|valu
expr_stmt|;
name|valu
operator|=
name|dn_bufp
operator|->
name|dfunc
operator|.
name|lowaddr
operator|+
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
name|SET_NAMESTRING
argument_list|(
name|dn_bufp
argument_list|,
operator|&
name|namestring
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn_bufp
operator|->
name|dfunc
operator|.
name|global
condition|)
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|strlen
argument_list|(
name|namestring
argument_list|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_BLOCK
argument_list|,
operator|&
name|objfile
operator|->
name|global_psymbols
argument_list|,
name|valu
argument_list|,
literal|0
argument_list|,
name|language_unknown
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
else|else
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|strlen
argument_list|(
name|namestring
argument_list|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_BLOCK
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
name|valu
argument_list|,
literal|0
argument_list|,
name|language_unknown
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|within_function
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
name|DNTT_TYPE_DOC_FUNCTION
case|:
name|valu
operator|=
name|dn_bufp
operator|->
name|ddocfunc
operator|.
name|hiaddr
operator|+
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|valu
operator|>
name|texthigh
condition|)
name|texthigh
operator|=
name|valu
expr_stmt|;
name|valu
operator|=
name|dn_bufp
operator|->
name|ddocfunc
operator|.
name|lowaddr
operator|+
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
name|SET_NAMESTRING
argument_list|(
name|dn_bufp
argument_list|,
operator|&
name|namestring
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn_bufp
operator|->
name|ddocfunc
operator|.
name|global
condition|)
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|strlen
argument_list|(
name|namestring
argument_list|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_BLOCK
argument_list|,
operator|&
name|objfile
operator|->
name|global_psymbols
argument_list|,
name|valu
argument_list|,
literal|0
argument_list|,
name|language_unknown
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
else|else
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|strlen
argument_list|(
name|namestring
argument_list|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_BLOCK
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
name|valu
argument_list|,
literal|0
argument_list|,
name|language_unknown
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
name|within_function
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
name|DNTT_TYPE_BEGIN
case|:
case|case
name|DNTT_TYPE_END
case|:
comment|/* We don't check MODULE end here, because there can be 	         symbols beyond the module end which properly belong to the 	         current psymtab -- so we wait till the next MODULE start */
ifdef|#
directive|ifdef
name|QUICK_LOOK_UP
if|if
condition|(
name|scan_start
operator|==
name|hp_symnum
operator|&&
name|symcount
operator|==
name|hp_symnum
operator|+
literal|1
condition|)
block|{
comment|/* If there are NO globals in an executable, 		     PXDB's index to the globals will point to 		     the last record in the file, which is 		     probably an END MODULE, i.e. this record. 		     ignore it and be done! */
continue|continue;
block|}
endif|#
directive|endif
comment|/* QUICK_LOOK_UP */
comment|/* Scope block begin/end.  We only care about function 	         and file blocks right now.  */
if|if
condition|(
operator|(
name|dn_bufp
operator|->
name|dend
operator|.
name|endkind
operator|==
name|DNTT_TYPE_FUNCTION
operator|)
operator|||
operator|(
name|dn_bufp
operator|->
name|dend
operator|.
name|endkind
operator|==
name|DNTT_TYPE_DOC_FUNCTION
operator|)
condition|)
name|within_function
operator|=
literal|0
expr_stmt|;
continue|continue;
case|case
name|DNTT_TYPE_SVAR
case|:
case|case
name|DNTT_TYPE_DVAR
case|:
case|case
name|DNTT_TYPE_TYPEDEF
case|:
case|case
name|DNTT_TYPE_TAGDEF
case|:
block|{
comment|/* Variables, typedefs an the like.  */
name|enum
name|address_class
name|storage
decl_stmt|;
name|namespace_enum
name|namespace
decl_stmt|;
comment|/* Don't add locals to the partial symbol table.  */
if|if
condition|(
name|within_function
operator|&&
operator|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_SVAR
operator|||
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_DVAR
operator|)
condition|)
continue|continue;
comment|/* TAGDEFs go into the structure namespace.  */
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_TAGDEF
condition|)
name|namespace
operator|=
name|STRUCT_NAMESPACE
expr_stmt|;
else|else
name|namespace
operator|=
name|VAR_NAMESPACE
expr_stmt|;
comment|/* What kind of "storage" does this use?  */
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_SVAR
condition|)
name|storage
operator|=
name|LOC_STATIC
expr_stmt|;
elseif|else
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_DVAR
operator|&&
name|dn_bufp
operator|->
name|ddvar
operator|.
name|regvar
condition|)
name|storage
operator|=
name|LOC_REGISTER
expr_stmt|;
elseif|else
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_DVAR
condition|)
name|storage
operator|=
name|LOC_LOCAL
expr_stmt|;
else|else
name|storage
operator|=
name|LOC_UNDEF
expr_stmt|;
name|SET_NAMESTRING
argument_list|(
name|dn_bufp
argument_list|,
operator|&
name|namestring
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pst
condition|)
block|{
name|pst
operator|=
name|hpread_start_psymtab
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|,
literal|"globals"
argument_list|,
literal|0
argument_list|,
operator|(
name|hp_symnum
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
operator|)
argument_list|,
name|objfile
operator|->
name|global_psymbols
operator|.
name|next
argument_list|,
name|objfile
operator|->
name|static_psymbols
operator|.
name|next
argument_list|)
expr_stmt|;
block|}
comment|/* Compute address of the data symbol */
name|valu
operator|=
name|dn_bufp
operator|->
name|dsvar
operator|.
name|location
expr_stmt|;
comment|/* Relocate in case it's in a shared library */
if|if
condition|(
name|storage
operator|==
name|LOC_STATIC
condition|)
name|valu
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_DATA
argument_list|)
expr_stmt|;
comment|/* Luckily, dvar, svar, typedef, and tagdef all 		   have their "global" bit in the same place, so it works 		   (though it's bad programming practice) to reference 		   "dsvar.global" even though we may be looking at 		   any of the above four types. */
if|if
condition|(
name|dn_bufp
operator|->
name|dsvar
operator|.
name|global
condition|)
block|{
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|strlen
argument_list|(
name|namestring
argument_list|)
argument_list|,
name|namespace
argument_list|,
name|storage
argument_list|,
operator|&
name|objfile
operator|->
name|global_psymbols
argument_list|,
name|valu
argument_list|,
literal|0
argument_list|,
name|language_unknown
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|strlen
argument_list|(
name|namestring
argument_list|)
argument_list|,
name|namespace
argument_list|,
name|storage
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
name|valu
argument_list|,
literal|0
argument_list|,
name|language_unknown
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
comment|/* For TAGDEF's, the above code added the tagname to the 		   struct namespace. This will cause tag "t" to be found 		   on a reference of the form "(struct t) x". But for 		   C++ classes, "t" will also be a typename, which we 		   want to find on a reference of the form "ptype t". 		   Therefore, we also add "t" to the var namespace. 		   Do the same for enum's due to the way aCC generates 		   debug info for these (see more extended comment 		   in hp-symtab-read.c). 		   We do the same for templates, so that "ptype t" 		   where "t" is a template also works. */
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_TAGDEF
operator|&&
name|dn_bufp
operator|->
name|dtype
operator|.
name|type
operator|.
name|dnttp
operator|.
name|index
operator|<
name|LNTT_SYMCOUNT
argument_list|(
name|objfile
argument_list|)
condition|)
block|{
name|int
name|global
init|=
name|dn_bufp
operator|->
name|dtag
operator|.
name|global
decl_stmt|;
comment|/* Look ahead to see if it's a C++ class */
name|dn_bufp
operator|=
name|hpread_get_lntt
argument_list|(
name|dn_bufp
operator|->
name|dtype
operator|.
name|type
operator|.
name|dnttp
operator|.
name|index
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_CLASS
operator|||
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_ENUM
operator|||
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_TEMPLATE
condition|)
block|{
if|if
condition|(
name|global
condition|)
block|{
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|strlen
argument_list|(
name|namestring
argument_list|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|storage
argument_list|,
operator|&
name|objfile
operator|->
name|global_psymbols
argument_list|,
name|dn_bufp
operator|->
name|dsvar
operator|.
name|location
argument_list|,
literal|0
argument_list|,
name|language_unknown
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|strlen
argument_list|(
name|namestring
argument_list|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|storage
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
name|dn_bufp
operator|->
name|dsvar
operator|.
name|location
argument_list|,
literal|0
argument_list|,
name|language_unknown
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
continue|continue;
case|case
name|DNTT_TYPE_MEMENUM
case|:
case|case
name|DNTT_TYPE_CONST
case|:
comment|/* Constants and members of enumerated types.  */
name|SET_NAMESTRING
argument_list|(
name|dn_bufp
argument_list|,
operator|&
name|namestring
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pst
condition|)
block|{
name|pst
operator|=
name|hpread_start_psymtab
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|,
literal|"globals"
argument_list|,
literal|0
argument_list|,
operator|(
name|hp_symnum
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
operator|)
argument_list|,
name|objfile
operator|->
name|global_psymbols
operator|.
name|next
argument_list|,
name|objfile
operator|->
name|static_psymbols
operator|.
name|next
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dn_bufp
operator|->
name|dconst
operator|.
name|global
condition|)
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|strlen
argument_list|(
name|namestring
argument_list|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_CONST
argument_list|,
operator|&
name|objfile
operator|->
name|global_psymbols
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|language_unknown
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
else|else
name|add_psymbol_to_list
argument_list|(
name|namestring
argument_list|,
name|strlen
argument_list|(
name|namestring
argument_list|)
argument_list|,
name|VAR_NAMESPACE
argument_list|,
name|LOC_CONST
argument_list|,
operator|&
name|objfile
operator|->
name|static_psymbols
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|language_unknown
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
continue|continue;
default|default:
continue|continue;
block|}
block|}
block|}
comment|/* End any pending partial symbol table. */
if|if
condition|(
name|pst
condition|)
block|{
name|hpread_end_psymtab
argument_list|(
name|pst
argument_list|,
name|psymtab_include_list
argument_list|,
name|includes_used
argument_list|,
name|hp_symnum
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
argument_list|,
literal|0
argument_list|,
name|dependency_list
argument_list|,
name|dependencies_used
argument_list|)
expr_stmt|;
block|}
name|discard_cleanups
argument_list|(
name|old_chain
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform any local cleanups required when we are done with a particular    objfile.  I.E, we are in the process of discarding all symbol information    for an objfile, freeing up all memory held for it, and unlinking the    objfile struct from the global list of known objfiles. */
end_comment

begin_function
name|void
name|hpread_symfile_finish
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
if|if
condition|(
name|objfile
operator|->
name|sym_private
operator|!=
name|NULL
condition|)
block|{
name|mfree
argument_list|(
name|objfile
operator|->
name|md
argument_list|,
name|objfile
operator|->
name|sym_private
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The remaining functions are all for internal use only.  */
end_comment

begin_comment
comment|/* Various small functions to get entries in the debug symbol sections.  */
end_comment

begin_function
name|union
name|dnttentry
modifier|*
name|hpread_get_lntt
parameter_list|(
name|index
parameter_list|,
name|objfile
parameter_list|)
name|int
name|index
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
return|return
operator|(
expr|union
name|dnttentry
operator|*
operator|)
operator|&
operator|(
name|LNTT
argument_list|(
name|objfile
argument_list|)
index|[
operator|(
name|index
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
operator|)
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|union
name|dnttentry
modifier|*
name|hpread_get_gntt
parameter_list|(
name|index
parameter_list|,
name|objfile
parameter_list|)
name|int
name|index
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
return|return
operator|(
expr|union
name|dnttentry
operator|*
operator|)
operator|&
operator|(
name|GNTT
argument_list|(
name|objfile
argument_list|)
index|[
operator|(
name|index
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
operator|)
index|]
operator|)
return|;
block|}
end_function

begin_function
name|union
name|sltentry
modifier|*
name|hpread_get_slt
parameter_list|(
name|index
parameter_list|,
name|objfile
parameter_list|)
name|int
name|index
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
return|return
operator|(
expr|union
name|sltentry
operator|*
operator|)
operator|&
operator|(
name|SLT
argument_list|(
name|objfile
argument_list|)
index|[
name|index
operator|*
sizeof|sizeof
argument_list|(
expr|union
name|sltentry
argument_list|)
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get the low address associated with some symbol (typically the start    of a particular source file or module).  Since that information is not    stored as part of the DNTT_TYPE_MODULE or DNTT_TYPE_SRCFILE symbol we must infer it from    the existance of DNTT_TYPE_FUNCTION symbols.  */
end_comment

begin_function
specifier|static
name|unsigned
name|long
name|hpread_get_textlow
parameter_list|(
name|global
parameter_list|,
name|index
parameter_list|,
name|objfile
parameter_list|,
name|symcount
parameter_list|)
name|int
name|global
decl_stmt|;
name|int
name|index
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|int
name|symcount
decl_stmt|;
block|{
name|union
name|dnttentry
modifier|*
name|dn_bufp
decl_stmt|;
name|struct
name|minimal_symbol
modifier|*
name|msymbol
decl_stmt|;
comment|/* Look for a DNTT_TYPE_FUNCTION symbol.  */
if|if
condition|(
name|index
operator|<
name|symcount
condition|)
comment|/* symcount is the number of symbols in */
block|{
comment|/*   the dbinfo, LNTT table */
do|do
block|{
if|if
condition|(
name|global
condition|)
name|dn_bufp
operator|=
name|hpread_get_gntt
argument_list|(
name|index
operator|++
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
else|else
name|dn_bufp
operator|=
name|hpread_get_lntt
argument_list|(
name|index
operator|++
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|!=
name|DNTT_TYPE_FUNCTION
operator|&&
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|!=
name|DNTT_TYPE_DOC_FUNCTION
operator|&&
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|!=
name|DNTT_TYPE_END
operator|&&
name|index
operator|<
name|symcount
condition|)
do|;
block|}
comment|/* Avoid going past a DNTT_TYPE_END when looking for a DNTT_TYPE_FUNCTION.  This      might happen when a sourcefile has no functions.  */
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_END
condition|)
return|return
literal|0
return|;
comment|/* Avoid going past the end of the LNTT file */
if|if
condition|(
name|index
operator|==
name|symcount
condition|)
return|return
literal|0
return|;
comment|/* The minimal symbols are typically more accurate for some reason.  */
if|if
condition|(
name|dn_bufp
operator|->
name|dblock
operator|.
name|kind
operator|==
name|DNTT_TYPE_FUNCTION
condition|)
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
name|dn_bufp
operator|->
name|dfunc
operator|.
name|name
operator|+
name|VT
argument_list|(
name|objfile
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
else|else
comment|/* must be a DNTT_TYPE_DOC_FUNCTION */
name|msymbol
operator|=
name|lookup_minimal_symbol
argument_list|(
name|dn_bufp
operator|->
name|ddocfunc
operator|.
name|name
operator|+
name|VT
argument_list|(
name|objfile
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|msymbol
condition|)
return|return
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|msymbol
argument_list|)
return|;
else|else
return|return
name|dn_bufp
operator|->
name|dfunc
operator|.
name|lowaddr
return|;
block|}
end_function

begin_comment
comment|/* Allocate and partially fill a partial symtab.  It will be    completely filled at the end of the symbol list.     SYMFILE_NAME is the name of the symbol-file we are reading from, and ADDR    is the address relative to which its symbols are (incremental) or 0    (normal). */
end_comment

begin_function
specifier|static
name|struct
name|partial_symtab
modifier|*
name|hpread_start_psymtab
parameter_list|(
name|objfile
parameter_list|,
name|section_offsets
parameter_list|,
name|filename
parameter_list|,
name|textlow
parameter_list|,
name|ldsymoff
parameter_list|,
name|global_syms
parameter_list|,
name|static_syms
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|char
modifier|*
name|filename
decl_stmt|;
name|CORE_ADDR
name|textlow
decl_stmt|;
name|int
name|ldsymoff
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
modifier|*
name|global_syms
decl_stmt|;
name|struct
name|partial_symbol
modifier|*
modifier|*
name|static_syms
decl_stmt|;
block|{
name|int
name|offset
init|=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
decl_stmt|;
specifier|extern
name|void
name|hpread_psymtab_to_symtab
parameter_list|()
function_decl|;
name|struct
name|partial_symtab
modifier|*
name|result
init|=
name|start_psymtab_common
argument_list|(
name|objfile
argument_list|,
name|section_offsets
argument_list|,
name|filename
argument_list|,
name|textlow
argument_list|,
name|global_syms
argument_list|,
name|static_syms
argument_list|)
decl_stmt|;
name|result
operator|->
name|textlow
operator|+=
name|offset
expr_stmt|;
name|result
operator|->
name|read_symtab_private
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symloc
argument_list|)
argument_list|)
expr_stmt|;
name|LDSYMOFF
argument_list|(
name|result
argument_list|)
operator|=
name|ldsymoff
expr_stmt|;
name|result
operator|->
name|read_symtab
operator|=
name|hpread_psymtab_to_symtab
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Close off the current usage of PST.      Returns PST or NULL if the partial symtab was empty and thrown away.     capping_symbol_offset  --Byte index in LNTT or GNTT of the    last symbol processed during the build    of the previous pst.     FIXME:  List variables and peculiarities of same.  */
end_comment

begin_function
specifier|static
name|struct
name|partial_symtab
modifier|*
name|hpread_end_psymtab
parameter_list|(
name|pst
parameter_list|,
name|include_list
parameter_list|,
name|num_includes
parameter_list|,
name|capping_symbol_offset
parameter_list|,
name|capping_text
parameter_list|,
name|dependency_list
parameter_list|,
name|number_dependencies
parameter_list|)
name|struct
name|partial_symtab
modifier|*
name|pst
decl_stmt|;
name|char
modifier|*
modifier|*
name|include_list
decl_stmt|;
name|int
name|num_includes
decl_stmt|;
name|int
name|capping_symbol_offset
decl_stmt|;
name|CORE_ADDR
name|capping_text
decl_stmt|;
name|struct
name|partial_symtab
modifier|*
modifier|*
name|dependency_list
decl_stmt|;
name|int
name|number_dependencies
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
init|=
name|pst
operator|->
name|objfile
decl_stmt|;
name|int
name|offset
init|=
name|ANOFFSET
argument_list|(
name|pst
operator|->
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|DUMPING
comment|/* Turn on to see what kind of a psymtab we've built. */
specifier|static
name|int
name|dumping
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|capping_symbol_offset
operator|!=
operator|-
literal|1
condition|)
name|LDSYMLEN
argument_list|(
name|pst
argument_list|)
operator|=
name|capping_symbol_offset
operator|-
name|LDSYMOFF
argument_list|(
name|pst
argument_list|)
expr_stmt|;
else|else
name|LDSYMLEN
argument_list|(
name|pst
argument_list|)
operator|=
literal|0
expr_stmt|;
name|pst
operator|->
name|texthigh
operator|=
name|capping_text
operator|+
name|offset
expr_stmt|;
name|pst
operator|->
name|n_global_syms
operator|=
name|objfile
operator|->
name|global_psymbols
operator|.
name|next
operator|-
operator|(
name|objfile
operator|->
name|global_psymbols
operator|.
name|list
operator|+
name|pst
operator|->
name|globals_offset
operator|)
expr_stmt|;
name|pst
operator|->
name|n_static_syms
operator|=
name|objfile
operator|->
name|static_psymbols
operator|.
name|next
operator|-
operator|(
name|objfile
operator|->
name|static_psymbols
operator|.
name|list
operator|+
name|pst
operator|->
name|statics_offset
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMPING
if|if
condition|(
name|dumping
condition|)
block|{
name|printf
argument_list|(
literal|"\nPst %s, LDSYMOFF %x (%x), LDSYMLEN %x (%x), globals %d, statics %d\n"
argument_list|,
name|pst
operator|->
name|filename
argument_list|,
name|LDSYMOFF
argument_list|(
name|pst
argument_list|)
argument_list|,
name|LDSYMOFF
argument_list|(
name|pst
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
argument_list|,
name|LDSYMLEN
argument_list|(
name|pst
argument_list|)
argument_list|,
name|LDSYMLEN
argument_list|(
name|pst
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|dntt_type_block
argument_list|)
argument_list|,
name|pst
operator|->
name|n_global_syms
argument_list|,
name|pst
operator|->
name|n_static_syms
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|pst
operator|->
name|number_of_dependencies
operator|=
name|number_dependencies
expr_stmt|;
if|if
condition|(
name|number_dependencies
condition|)
block|{
name|pst
operator|->
name|dependencies
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
name|number_dependencies
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pst
operator|->
name|dependencies
argument_list|,
name|dependency_list
argument_list|,
name|number_dependencies
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|pst
operator|->
name|dependencies
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_includes
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|partial_symtab
modifier|*
name|subpst
init|=
name|allocate_psymtab
argument_list|(
name|include_list
index|[
name|i
index|]
argument_list|,
name|objfile
argument_list|)
decl_stmt|;
name|subpst
operator|->
name|section_offsets
operator|=
name|pst
operator|->
name|section_offsets
expr_stmt|;
name|subpst
operator|->
name|read_symtab_private
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|symloc
argument_list|)
argument_list|)
expr_stmt|;
name|LDSYMOFF
argument_list|(
name|subpst
argument_list|)
operator|=
name|LDSYMLEN
argument_list|(
name|subpst
argument_list|)
operator|=
name|subpst
operator|->
name|textlow
operator|=
name|subpst
operator|->
name|texthigh
operator|=
literal|0
expr_stmt|;
comment|/* We could save slight bits of space by only making one of these,          shared by the entire set of include files.  FIXME-someday.  */
name|subpst
operator|->
name|dependencies
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|*
operator|)
name|obstack_alloc
argument_list|(
operator|&
name|objfile
operator|->
name|psymbol_obstack
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|partial_symtab
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|subpst
operator|->
name|dependencies
index|[
literal|0
index|]
operator|=
name|pst
expr_stmt|;
name|subpst
operator|->
name|number_of_dependencies
operator|=
literal|1
expr_stmt|;
name|subpst
operator|->
name|globals_offset
operator|=
name|subpst
operator|->
name|n_global_syms
operator|=
name|subpst
operator|->
name|statics_offset
operator|=
name|subpst
operator|->
name|n_static_syms
operator|=
literal|0
expr_stmt|;
name|subpst
operator|->
name|readin
operator|=
literal|0
expr_stmt|;
name|subpst
operator|->
name|symtab
operator|=
literal|0
expr_stmt|;
name|subpst
operator|->
name|read_symtab
operator|=
name|pst
operator|->
name|read_symtab
expr_stmt|;
block|}
name|sort_pst_symbols
argument_list|(
name|pst
argument_list|)
expr_stmt|;
comment|/* If there is already a psymtab or symtab for a file of this name, remove it.      (If there is a symtab, more drastic things also happen.)      This happens in VxWorks.  */
name|free_named_symtabs
argument_list|(
name|pst
operator|->
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_includes
operator|==
literal|0
operator|&&
name|number_dependencies
operator|==
literal|0
operator|&&
name|pst
operator|->
name|n_global_syms
operator|==
literal|0
operator|&&
name|pst
operator|->
name|n_static_syms
operator|==
literal|0
condition|)
block|{
comment|/* Throw away this psymtab, it's empty.  We can't deallocate it, since          it is on the obstack, but we can forget to chain it on the list.           Empty psymtabs happen as a result of header files which don't have          any symbols in them.  There can be a lot of them.  But this check          is wrong, in that a psymtab with N_SLINE entries but nothing else          is not empty, but we don't realize that.  Fixing that without slowing          things down might be tricky.          It's also wrong if we're using the quick look-up tables, as          we can get empty psymtabs from modules with no routines in          them. */
name|discard_psymtab
argument_list|(
name|pst
argument_list|)
expr_stmt|;
comment|/* Indicate that psymtab was thrown away.  */
name|pst
operator|=
operator|(
expr|struct
name|partial_symtab
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
return|return
name|pst
return|;
block|}
end_function

begin_comment
comment|/* End of hp-psymtab-read.c */
end_comment

begin_comment
comment|/* Set indentation to 4 spaces for Emacs; this file is    mostly non-GNU-ish in its style :-( */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|***Local Variables: ***c - basic - offset:4 *** End:
endif|#
directive|endif
end_endif

end_unit

