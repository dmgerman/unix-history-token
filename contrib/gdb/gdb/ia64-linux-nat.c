begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Functions specific to running gdb native on IA-64 running    GNU/Linux.     Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_REG_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/reg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<asm/ptrace_offsets.h>
end_include

begin_include
include|#
directive|include
file|<sys/procfs.h>
end_include

begin_comment
comment|/* Prototypes for supply_gregset etc. */
end_comment

begin_include
include|#
directive|include
file|"gregset.h"
end_include

begin_comment
comment|/* These must match the order of the register names.     Some sort of lookup table is needed because the offsets associated    with the registers are all over the board.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|u_offsets
index|[]
init|=
block|{
comment|/* general registers */
operator|-
literal|1
block|,
comment|/* gr0 not available; i.e, it's always zero */
name|PT_R1
block|,
name|PT_R2
block|,
name|PT_R3
block|,
name|PT_R4
block|,
name|PT_R5
block|,
name|PT_R6
block|,
name|PT_R7
block|,
name|PT_R8
block|,
name|PT_R9
block|,
name|PT_R10
block|,
name|PT_R11
block|,
name|PT_R12
block|,
name|PT_R13
block|,
name|PT_R14
block|,
name|PT_R15
block|,
name|PT_R16
block|,
name|PT_R17
block|,
name|PT_R18
block|,
name|PT_R19
block|,
name|PT_R20
block|,
name|PT_R21
block|,
name|PT_R22
block|,
name|PT_R23
block|,
name|PT_R24
block|,
name|PT_R25
block|,
name|PT_R26
block|,
name|PT_R27
block|,
name|PT_R28
block|,
name|PT_R29
block|,
name|PT_R30
block|,
name|PT_R31
block|,
comment|/* gr32 through gr127 not directly available via the ptrace interface */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* Floating point registers */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* f0 and f1 not available (f0 is +0.0 and f1 is +1.0) */
name|PT_F2
block|,
name|PT_F3
block|,
name|PT_F4
block|,
name|PT_F5
block|,
name|PT_F6
block|,
name|PT_F7
block|,
name|PT_F8
block|,
name|PT_F9
block|,
name|PT_F10
block|,
name|PT_F11
block|,
name|PT_F12
block|,
name|PT_F13
block|,
name|PT_F14
block|,
name|PT_F15
block|,
name|PT_F16
block|,
name|PT_F17
block|,
name|PT_F18
block|,
name|PT_F19
block|,
name|PT_F20
block|,
name|PT_F21
block|,
name|PT_F22
block|,
name|PT_F23
block|,
name|PT_F24
block|,
name|PT_F25
block|,
name|PT_F26
block|,
name|PT_F27
block|,
name|PT_F28
block|,
name|PT_F29
block|,
name|PT_F30
block|,
name|PT_F31
block|,
name|PT_F32
block|,
name|PT_F33
block|,
name|PT_F34
block|,
name|PT_F35
block|,
name|PT_F36
block|,
name|PT_F37
block|,
name|PT_F38
block|,
name|PT_F39
block|,
name|PT_F40
block|,
name|PT_F41
block|,
name|PT_F42
block|,
name|PT_F43
block|,
name|PT_F44
block|,
name|PT_F45
block|,
name|PT_F46
block|,
name|PT_F47
block|,
name|PT_F48
block|,
name|PT_F49
block|,
name|PT_F50
block|,
name|PT_F51
block|,
name|PT_F52
block|,
name|PT_F53
block|,
name|PT_F54
block|,
name|PT_F55
block|,
name|PT_F56
block|,
name|PT_F57
block|,
name|PT_F58
block|,
name|PT_F59
block|,
name|PT_F60
block|,
name|PT_F61
block|,
name|PT_F62
block|,
name|PT_F63
block|,
name|PT_F64
block|,
name|PT_F65
block|,
name|PT_F66
block|,
name|PT_F67
block|,
name|PT_F68
block|,
name|PT_F69
block|,
name|PT_F70
block|,
name|PT_F71
block|,
name|PT_F72
block|,
name|PT_F73
block|,
name|PT_F74
block|,
name|PT_F75
block|,
name|PT_F76
block|,
name|PT_F77
block|,
name|PT_F78
block|,
name|PT_F79
block|,
name|PT_F80
block|,
name|PT_F81
block|,
name|PT_F82
block|,
name|PT_F83
block|,
name|PT_F84
block|,
name|PT_F85
block|,
name|PT_F86
block|,
name|PT_F87
block|,
name|PT_F88
block|,
name|PT_F89
block|,
name|PT_F90
block|,
name|PT_F91
block|,
name|PT_F92
block|,
name|PT_F93
block|,
name|PT_F94
block|,
name|PT_F95
block|,
name|PT_F96
block|,
name|PT_F97
block|,
name|PT_F98
block|,
name|PT_F99
block|,
name|PT_F100
block|,
name|PT_F101
block|,
name|PT_F102
block|,
name|PT_F103
block|,
name|PT_F104
block|,
name|PT_F105
block|,
name|PT_F106
block|,
name|PT_F107
block|,
name|PT_F108
block|,
name|PT_F109
block|,
name|PT_F110
block|,
name|PT_F111
block|,
name|PT_F112
block|,
name|PT_F113
block|,
name|PT_F114
block|,
name|PT_F115
block|,
name|PT_F116
block|,
name|PT_F117
block|,
name|PT_F118
block|,
name|PT_F119
block|,
name|PT_F120
block|,
name|PT_F121
block|,
name|PT_F122
block|,
name|PT_F123
block|,
name|PT_F124
block|,
name|PT_F125
block|,
name|PT_F126
block|,
name|PT_F127
block|,
comment|/* predicate registers - we don't fetch these individually */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* branch registers */
name|PT_B0
block|,
name|PT_B1
block|,
name|PT_B2
block|,
name|PT_B3
block|,
name|PT_B4
block|,
name|PT_B5
block|,
name|PT_B6
block|,
name|PT_B7
block|,
comment|/* virtual frame pointer and virtual return address pointer */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* other registers */
name|PT_PR
block|,
name|PT_CR_IIP
block|,
comment|/* ip */
name|PT_CR_IPSR
block|,
comment|/* psr */
name|PT_CFM
block|,
comment|/* cfm */
comment|/* kernel registers not visible via ptrace interface (?) */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* hole */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|PT_AR_RSC
block|,
name|PT_AR_BSP
block|,
name|PT_AR_BSPSTORE
block|,
name|PT_AR_RNAT
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* Not available: FCR, IA32 floating control register */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* Not available: EFLAG */
operator|-
literal|1
block|,
comment|/* Not available: CSD */
operator|-
literal|1
block|,
comment|/* Not available: SSD */
operator|-
literal|1
block|,
comment|/* Not available: CFLG */
operator|-
literal|1
block|,
comment|/* Not available: FSR */
operator|-
literal|1
block|,
comment|/* Not available: FIR */
operator|-
literal|1
block|,
comment|/* Not available: FDR */
operator|-
literal|1
block|,
name|PT_AR_CCV
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|PT_AR_UNAT
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|PT_AR_FPSR
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* Not available: ITC */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|PT_AR_PFS
block|,
name|PT_AR_LC
block|,
operator|-
literal|1
block|,
comment|/* Not available: EC, the Epilog Count register */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
comment|/* nat bits - not fetched directly; instead we obtain these bits from        either rnat or unat or from memory. */
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,   }
decl_stmt|;
end_decl_stmt

begin_function
name|CORE_ADDR
name|register_addr
parameter_list|(
name|int
name|regno
parameter_list|,
name|CORE_ADDR
name|blockend
parameter_list|)
block|{
name|CORE_ADDR
name|addr
decl_stmt|;
if|if
condition|(
name|regno
operator|<
literal|0
operator|||
name|regno
operator|>=
name|NUM_REGS
condition|)
name|error
argument_list|(
literal|"Invalid register number %d."
argument_list|,
name|regno
argument_list|)
expr_stmt|;
if|if
condition|(
name|u_offsets
index|[
name|regno
index|]
operator|==
operator|-
literal|1
condition|)
name|addr
operator|=
literal|0
expr_stmt|;
else|else
name|addr
operator|=
operator|(
name|CORE_ADDR
operator|)
name|u_offsets
index|[
name|regno
index|]
expr_stmt|;
return|return
name|addr
return|;
block|}
end_function

begin_function
name|int
name|ia64_cannot_fetch_register
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
return|return
name|regno
operator|<
literal|0
operator|||
name|regno
operator|>=
name|NUM_REGS
operator|||
name|u_offsets
index|[
name|regno
index|]
operator|==
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ia64_cannot_store_register
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
comment|/* Rationale behind not permitting stores to bspstore...         The IA-64 architecture provides bspstore and bsp which refer      memory locations in the RSE's backing store.  bspstore is the      next location which will be written when the RSE needs to write      to memory.  bsp is the address at which r32 in the current frame      would be found if it were written to the backing store.       The IA-64 architecture provides read-only access to bsp and      read/write access to bspstore (but only when the RSE is in      the enforced lazy mode).  It should be noted that stores      to bspstore also affect the value of bsp.  Changing bspstore      does not affect the number of dirty entries between bspstore      and bsp, so changing bspstore by N words will also cause bsp      to be changed by (roughly) N as well.  (It could be N-1 or N+1      depending upon where the NaT collection bits fall.)       OTOH, the Linux kernel provides read/write access to bsp (and      currently read/write access to bspstore as well).  But it      is definitely the case that if you change one, the other      will change at the same time.  It is more useful to gdb to      be able to change bsp.  So in order to prevent strange and      undesirable things from happening when a dummy stack frame      is popped (after calling an inferior function), we allow      bspstore to be read, but not written.  (Note that popping      a (generic) dummy stack frame causes all registers that      were previously read from the inferior process to be written      back.)  */
return|return
name|regno
operator|<
literal|0
operator|||
name|regno
operator|>=
name|NUM_REGS
operator|||
name|u_offsets
index|[
name|regno
index|]
operator|==
operator|-
literal|1
operator|||
name|regno
operator|==
name|IA64_BSPSTORE_REGNUM
return|;
block|}
end_function

begin_function
name|void
name|supply_gregset
parameter_list|(
name|gregset_t
modifier|*
name|gregsetp
parameter_list|)
block|{
name|int
name|regi
decl_stmt|;
name|greg_t
modifier|*
name|regp
init|=
operator|(
name|greg_t
operator|*
operator|)
name|gregsetp
decl_stmt|;
for|for
control|(
name|regi
operator|=
name|IA64_GR0_REGNUM
init|;
name|regi
operator|<=
name|IA64_GR31_REGNUM
condition|;
name|regi
operator|++
control|)
block|{
name|supply_register
argument_list|(
name|regi
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
operator|(
name|regi
operator|-
name|IA64_GR0_REGNUM
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME: NAT collection bits are at index 32; gotta deal with these      somehow... */
name|supply_register
argument_list|(
name|IA64_PR_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
literal|33
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|regi
operator|=
name|IA64_BR0_REGNUM
init|;
name|regi
operator|<=
name|IA64_BR7_REGNUM
condition|;
name|regi
operator|++
control|)
block|{
name|supply_register
argument_list|(
name|regi
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
literal|34
operator|+
operator|(
name|regi
operator|-
name|IA64_BR0_REGNUM
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|supply_register
argument_list|(
name|IA64_IP_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
literal|42
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|IA64_CFM_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
literal|43
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|IA64_PSR_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
literal|44
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|IA64_RSC_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
literal|45
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|IA64_BSP_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
literal|46
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|IA64_BSPSTORE_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
literal|47
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|IA64_RNAT_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
literal|48
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|IA64_CCV_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
literal|49
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|IA64_UNAT_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
literal|50
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|IA64_FPSR_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
literal|51
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|IA64_PFS_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
literal|52
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|IA64_LC_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
literal|53
operator|)
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|IA64_EC_REGNUM
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|regp
operator|+
literal|54
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fill_gregset
parameter_list|(
name|gregset_t
modifier|*
name|gregsetp
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|int
name|regi
decl_stmt|;
name|greg_t
modifier|*
name|regp
init|=
operator|(
name|greg_t
operator|*
operator|)
name|gregsetp
decl_stmt|;
define|#
directive|define
name|COPY_REG
parameter_list|(
name|_idx_
parameter_list|,
name|_regi_
parameter_list|)
define|\
value|if ((regno == -1) || regno == _regi_) \     memcpy (regp + _idx_,&registers[REGISTER_BYTE (_regi_)], \ 	    REGISTER_RAW_SIZE (_regi_))
for|for
control|(
name|regi
operator|=
name|IA64_GR0_REGNUM
init|;
name|regi
operator|<=
name|IA64_GR31_REGNUM
condition|;
name|regi
operator|++
control|)
block|{
name|COPY_REG
argument_list|(
name|regi
operator|-
name|IA64_GR0_REGNUM
argument_list|,
name|regi
argument_list|)
expr_stmt|;
block|}
comment|/* FIXME: NAT collection bits at index 32? */
name|COPY_REG
argument_list|(
literal|33
argument_list|,
name|IA64_PR_REGNUM
argument_list|)
expr_stmt|;
for|for
control|(
name|regi
operator|=
name|IA64_BR0_REGNUM
init|;
name|regi
operator|<=
name|IA64_BR7_REGNUM
condition|;
name|regi
operator|++
control|)
block|{
name|COPY_REG
argument_list|(
literal|34
operator|+
operator|(
name|regi
operator|-
name|IA64_BR0_REGNUM
operator|)
argument_list|,
name|regi
argument_list|)
expr_stmt|;
block|}
name|COPY_REG
argument_list|(
literal|42
argument_list|,
name|IA64_IP_REGNUM
argument_list|)
expr_stmt|;
name|COPY_REG
argument_list|(
literal|43
argument_list|,
name|IA64_CFM_REGNUM
argument_list|)
expr_stmt|;
name|COPY_REG
argument_list|(
literal|44
argument_list|,
name|IA64_PSR_REGNUM
argument_list|)
expr_stmt|;
name|COPY_REG
argument_list|(
literal|45
argument_list|,
name|IA64_RSC_REGNUM
argument_list|)
expr_stmt|;
name|COPY_REG
argument_list|(
literal|46
argument_list|,
name|IA64_BSP_REGNUM
argument_list|)
expr_stmt|;
name|COPY_REG
argument_list|(
literal|47
argument_list|,
name|IA64_BSPSTORE_REGNUM
argument_list|)
expr_stmt|;
name|COPY_REG
argument_list|(
literal|48
argument_list|,
name|IA64_RNAT_REGNUM
argument_list|)
expr_stmt|;
name|COPY_REG
argument_list|(
literal|49
argument_list|,
name|IA64_CCV_REGNUM
argument_list|)
expr_stmt|;
name|COPY_REG
argument_list|(
literal|50
argument_list|,
name|IA64_UNAT_REGNUM
argument_list|)
expr_stmt|;
name|COPY_REG
argument_list|(
literal|51
argument_list|,
name|IA64_FPSR_REGNUM
argument_list|)
expr_stmt|;
name|COPY_REG
argument_list|(
literal|52
argument_list|,
name|IA64_PFS_REGNUM
argument_list|)
expr_stmt|;
name|COPY_REG
argument_list|(
literal|53
argument_list|,
name|IA64_LC_REGNUM
argument_list|)
expr_stmt|;
name|COPY_REG
argument_list|(
literal|54
argument_list|,
name|IA64_EC_REGNUM
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  Given a pointer to a floating point register set in /proc format    (fpregset_t *), unpack the register contents and supply them as gdb's    idea of the current floating point register values. */
end_comment

begin_function
name|void
name|supply_fpregset
parameter_list|(
name|fpregset_t
modifier|*
name|fpregsetp
parameter_list|)
block|{
specifier|register
name|int
name|regi
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|;
for|for
control|(
name|regi
operator|=
name|IA64_FR0_REGNUM
init|;
name|regi
operator|<=
name|IA64_FR127_REGNUM
condition|;
name|regi
operator|++
control|)
block|{
name|from
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
operator|(
operator|*
name|fpregsetp
operator|)
index|[
name|regi
operator|-
name|IA64_FR0_REGNUM
index|]
operator|)
expr_stmt|;
name|supply_register
argument_list|(
name|regi
argument_list|,
name|from
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  Given a pointer to a floating point register set in /proc format    (fpregset_t *), update the register specified by REGNO from gdb's idea    of the current floating point register set.  If REGNO is -1, update    them all. */
end_comment

begin_function
name|void
name|fill_fpregset
parameter_list|(
name|fpregset_t
modifier|*
name|fpregsetp
parameter_list|,
name|int
name|regno
parameter_list|)
block|{
name|int
name|regi
decl_stmt|;
name|char
modifier|*
name|to
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|;
for|for
control|(
name|regi
operator|=
name|IA64_FR0_REGNUM
init|;
name|regi
operator|<=
name|IA64_FR127_REGNUM
condition|;
name|regi
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|regno
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|regno
operator|==
name|regi
operator|)
condition|)
block|{
name|from
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regi
argument_list|)
index|]
expr_stmt|;
name|to
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
operator|(
operator|*
name|fpregsetp
operator|)
index|[
name|regi
operator|-
name|IA64_FR0_REGNUM
index|]
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regi
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_define
define|#
directive|define
name|IA64_PSR_DB
value|(1UL<< 24)
end_define

begin_define
define|#
directive|define
name|IA64_PSR_DD
value|(1UL<< 39)
end_define

begin_function
specifier|static
name|void
name|enable_watchpoints_in_psr
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
name|CORE_ADDR
name|psr
decl_stmt|;
name|psr
operator|=
name|read_register_pid
argument_list|(
name|IA64_PSR_REGNUM
argument_list|,
name|ptid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|psr
operator|&
name|IA64_PSR_DB
operator|)
condition|)
block|{
name|psr
operator||=
name|IA64_PSR_DB
expr_stmt|;
comment|/* Set the db bit - this enables hardware 			           watchpoints and breakpoints. */
name|write_register_pid
argument_list|(
name|IA64_PSR_REGNUM
argument_list|,
name|psr
argument_list|,
name|ptid
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|long
name|fetch_debug_register
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|long
name|val
decl_stmt|;
name|int
name|tid
decl_stmt|;
name|tid
operator|=
name|TIDGET
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
if|if
condition|(
name|tid
operator|==
literal|0
condition|)
name|tid
operator|=
name|PIDGET
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
name|val
operator|=
name|ptrace
argument_list|(
name|PT_READ_U
argument_list|,
name|tid
argument_list|,
call|(
name|PTRACE_ARG3_TYPE
call|)
argument_list|(
name|PT_DBR
operator|+
literal|8
operator|*
name|idx
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|store_debug_register
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|idx
parameter_list|,
name|long
name|val
parameter_list|)
block|{
name|int
name|tid
decl_stmt|;
name|tid
operator|=
name|TIDGET
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
if|if
condition|(
name|tid
operator|==
literal|0
condition|)
name|tid
operator|=
name|PIDGET
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ptrace
argument_list|(
name|PT_WRITE_U
argument_list|,
name|tid
argument_list|,
call|(
name|PTRACE_ARG3_TYPE
call|)
argument_list|(
name|PT_DBR
operator|+
literal|8
operator|*
name|idx
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fetch_debug_register_pair
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|idx
parameter_list|,
name|long
modifier|*
name|dbr_addr
parameter_list|,
name|long
modifier|*
name|dbr_mask
parameter_list|)
block|{
if|if
condition|(
name|dbr_addr
condition|)
operator|*
name|dbr_addr
operator|=
name|fetch_debug_register
argument_list|(
name|ptid
argument_list|,
literal|2
operator|*
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbr_mask
condition|)
operator|*
name|dbr_mask
operator|=
name|fetch_debug_register
argument_list|(
name|ptid
argument_list|,
literal|2
operator|*
name|idx
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|store_debug_register_pair
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|idx
parameter_list|,
name|long
modifier|*
name|dbr_addr
parameter_list|,
name|long
modifier|*
name|dbr_mask
parameter_list|)
block|{
if|if
condition|(
name|dbr_addr
condition|)
name|store_debug_register
argument_list|(
name|ptid
argument_list|,
literal|2
operator|*
name|idx
argument_list|,
operator|*
name|dbr_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbr_mask
condition|)
name|store_debug_register
argument_list|(
name|ptid
argument_list|,
literal|2
operator|*
name|idx
operator|+
literal|1
argument_list|,
operator|*
name|dbr_mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_power_of_2
parameter_list|(
name|int
name|val
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|onecount
decl_stmt|;
name|onecount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|val
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|val
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|onecount
operator|++
expr_stmt|;
return|return
name|onecount
operator|<=
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ia64_linux_insert_watchpoint
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|rw
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
name|long
name|dbr_addr
decl_stmt|,
name|dbr_mask
decl_stmt|;
name|int
name|max_watchpoints
init|=
literal|4
decl_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
operator|||
operator|!
name|is_power_of_2
argument_list|(
name|len
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|max_watchpoints
condition|;
name|idx
operator|++
control|)
block|{
name|fetch_debug_register_pair
argument_list|(
name|ptid
argument_list|,
name|idx
argument_list|,
name|NULL
argument_list|,
operator|&
name|dbr_mask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dbr_mask
operator|&
operator|(
literal|0x3UL
operator|<<
literal|62
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Exit loop if both r and w bits clear */
break|break;
block|}
block|}
if|if
condition|(
name|idx
operator|==
name|max_watchpoints
condition|)
return|return
operator|-
literal|1
return|;
name|dbr_addr
operator|=
operator|(
name|long
operator|)
name|addr
expr_stmt|;
name|dbr_mask
operator|=
operator|(
operator|~
operator|(
name|len
operator|-
literal|1
operator|)
operator|&
literal|0x00ffffffffffffffL
operator|)
expr_stmt|;
comment|/* construct mask to match */
name|dbr_mask
operator||=
literal|0x0800000000000000L
expr_stmt|;
comment|/* Only match privilege level 3 */
switch|switch
condition|(
name|rw
condition|)
block|{
case|case
name|hw_write
case|:
name|dbr_mask
operator||=
operator|(
literal|1L
operator|<<
literal|62
operator|)
expr_stmt|;
comment|/* Set w bit */
break|break;
case|case
name|hw_read
case|:
name|dbr_mask
operator||=
operator|(
literal|1L
operator|<<
literal|63
operator|)
expr_stmt|;
comment|/* Set r bit */
break|break;
case|case
name|hw_access
case|:
name|dbr_mask
operator||=
operator|(
literal|3L
operator|<<
literal|62
operator|)
expr_stmt|;
comment|/* Set both r and w bits */
break|break;
default|default:
return|return
operator|-
literal|1
return|;
block|}
name|store_debug_register_pair
argument_list|(
name|ptid
argument_list|,
name|idx
argument_list|,
operator|&
name|dbr_addr
argument_list|,
operator|&
name|dbr_mask
argument_list|)
expr_stmt|;
name|enable_watchpoints_in_psr
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ia64_linux_remove_watchpoint
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|CORE_ADDR
name|addr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
name|long
name|dbr_addr
decl_stmt|,
name|dbr_mask
decl_stmt|;
name|int
name|max_watchpoints
init|=
literal|4
decl_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
operator|||
operator|!
name|is_power_of_2
argument_list|(
name|len
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|max_watchpoints
condition|;
name|idx
operator|++
control|)
block|{
name|fetch_debug_register_pair
argument_list|(
name|ptid
argument_list|,
name|idx
argument_list|,
operator|&
name|dbr_addr
argument_list|,
operator|&
name|dbr_mask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dbr_mask
operator|&
operator|(
literal|0x3UL
operator|<<
literal|62
operator|)
operator|)
operator|&&
name|addr
operator|==
operator|(
name|CORE_ADDR
operator|)
name|dbr_addr
condition|)
block|{
name|dbr_addr
operator|=
literal|0
expr_stmt|;
name|dbr_mask
operator|=
literal|0
expr_stmt|;
name|store_debug_register_pair
argument_list|(
name|ptid
argument_list|,
name|idx
argument_list|,
operator|&
name|dbr_addr
argument_list|,
operator|&
name|dbr_mask
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|CORE_ADDR
name|ia64_linux_stopped_by_watchpoint
parameter_list|(
name|ptid_t
name|ptid
parameter_list|)
block|{
name|CORE_ADDR
name|psr
decl_stmt|;
name|int
name|tid
decl_stmt|;
name|struct
name|siginfo
name|siginfo
decl_stmt|;
name|tid
operator|=
name|TIDGET
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
if|if
condition|(
name|tid
operator|==
literal|0
condition|)
name|tid
operator|=
name|PIDGET
argument_list|(
name|ptid
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|ptrace
argument_list|(
name|PTRACE_GETSIGINFO
argument_list|,
name|tid
argument_list|,
operator|(
name|PTRACE_ARG3_TYPE
operator|)
literal|0
argument_list|,
operator|&
name|siginfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
operator|||
operator|(
name|siginfo
operator|.
name|si_code
operator|&
literal|0xffff
operator|)
operator|!=
literal|0x0004
comment|/* TRAP_HWBKPT */
condition|)
return|return
literal|0
return|;
name|psr
operator|=
name|read_register_pid
argument_list|(
name|IA64_PSR_REGNUM
argument_list|,
name|ptid
argument_list|)
expr_stmt|;
name|psr
operator||=
name|IA64_PSR_DD
expr_stmt|;
comment|/* Set the dd bit - this will disable the watchpoint                            for the next instruction */
name|write_register_pid
argument_list|(
name|IA64_PSR_REGNUM
argument_list|,
name|psr
argument_list|,
name|ptid
argument_list|)
expr_stmt|;
return|return
operator|(
name|CORE_ADDR
operator|)
name|siginfo
operator|.
name|si_addr
return|;
block|}
end_function

end_unit

