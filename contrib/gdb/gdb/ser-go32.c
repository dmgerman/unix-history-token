begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Remote serial interface for local (hardwired) serial ports for    GO32.  Copyright 1992, 1993 Free Software Foundation, Inc.     Contributed by Nigel Stephens, Algorithmics Ltd. (nigel@algor.co.uk).     This version uses DPMI interrupts to handle buffered i/o     without the separate "asynctsr" program.     This file is part of GDB.       This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_comment
comment|/*  * NS16550 UART registers  */
end_comment

begin_define
define|#
directive|define
name|COM1ADDR
value|0x3f8
end_define

begin_define
define|#
directive|define
name|COM2ADDR
value|0x2f8
end_define

begin_define
define|#
directive|define
name|COM3ADDR
value|0x3e8
end_define

begin_define
define|#
directive|define
name|COM4ADDR
value|0x3e0
end_define

begin_define
define|#
directive|define
name|com_data
value|0
end_define

begin_comment
comment|/* data register (R/W) */
end_comment

begin_define
define|#
directive|define
name|com_dlbl
value|0
end_define

begin_comment
comment|/* divisor latch low (W) */
end_comment

begin_define
define|#
directive|define
name|com_ier
value|1
end_define

begin_comment
comment|/* interrupt enable (W) */
end_comment

begin_define
define|#
directive|define
name|com_dlbh
value|1
end_define

begin_comment
comment|/* divisor latch high (W) */
end_comment

begin_define
define|#
directive|define
name|com_iir
value|2
end_define

begin_comment
comment|/* interrupt identification (R) */
end_comment

begin_define
define|#
directive|define
name|com_fifo
value|2
end_define

begin_comment
comment|/* FIFO control (W) */
end_comment

begin_define
define|#
directive|define
name|com_lctl
value|3
end_define

begin_comment
comment|/* line control register (R/W) */
end_comment

begin_define
define|#
directive|define
name|com_cfcr
value|3
end_define

begin_comment
comment|/* line control register (R/W) */
end_comment

begin_define
define|#
directive|define
name|com_mcr
value|4
end_define

begin_comment
comment|/* modem control register (R/W) */
end_comment

begin_define
define|#
directive|define
name|com_lsr
value|5
end_define

begin_comment
comment|/* line status register (R/W) */
end_comment

begin_define
define|#
directive|define
name|com_msr
value|6
end_define

begin_comment
comment|/* modem status register (R/W) */
end_comment

begin_comment
comment|/*  * Constants for computing 16 bit baud rate divisor (lower byte  * in com_dlbl, upper in com_dlbh) from 1.8432MHz crystal.  Divisor is  * 1.8432 MHz / (16 * X) for X bps.  If the baud rate can't be set  * to within +- (desired_rate*SPEED_TOLERANCE/1000) bps, we fail.  */
end_comment

begin_define
define|#
directive|define
name|COMTICK
value|(1843200/16)
end_define

begin_define
define|#
directive|define
name|SPEED_TOLERANCE
value|30
end_define

begin_comment
comment|/* thousandths; real == desired +- 3.0% */
end_comment

begin_comment
comment|/* interrupt enable register */
end_comment

begin_define
define|#
directive|define
name|IER_ERXRDY
value|0x1
end_define

begin_comment
comment|/* int on rx ready */
end_comment

begin_define
define|#
directive|define
name|IER_ETXRDY
value|0x2
end_define

begin_comment
comment|/* int on tx ready */
end_comment

begin_define
define|#
directive|define
name|IER_ERLS
value|0x4
end_define

begin_comment
comment|/* int on line status change */
end_comment

begin_define
define|#
directive|define
name|IER_EMSC
value|0x8
end_define

begin_comment
comment|/* int on modem status change */
end_comment

begin_comment
comment|/* interrupt identification register */
end_comment

begin_define
define|#
directive|define
name|IIR_FIFO_MASK
value|0xc0
end_define

begin_comment
comment|/* set if FIFOs are enabled */
end_comment

begin_define
define|#
directive|define
name|IIR_IMASK
value|0xf
end_define

begin_comment
comment|/* interrupt cause mask */
end_comment

begin_define
define|#
directive|define
name|IIR_NOPEND
value|0x1
end_define

begin_comment
comment|/* nothing pending */
end_comment

begin_define
define|#
directive|define
name|IIR_RLS
value|0x6
end_define

begin_comment
comment|/* receive line status */
end_comment

begin_define
define|#
directive|define
name|IIR_RXRDY
value|0x4
end_define

begin_comment
comment|/* receive ready */
end_comment

begin_define
define|#
directive|define
name|IIR_RXTOUT
value|0xc
end_define

begin_comment
comment|/* receive timeout */
end_comment

begin_define
define|#
directive|define
name|IIR_TXRDY
value|0x2
end_define

begin_comment
comment|/* transmit ready */
end_comment

begin_define
define|#
directive|define
name|IIR_MLSC
value|0x0
end_define

begin_comment
comment|/* modem status */
end_comment

begin_comment
comment|/* fifo control register */
end_comment

begin_define
define|#
directive|define
name|FIFO_ENABLE
value|0x01
end_define

begin_comment
comment|/* enable fifo */
end_comment

begin_define
define|#
directive|define
name|FIFO_RCV_RST
value|0x02
end_define

begin_comment
comment|/* reset receive fifo */
end_comment

begin_define
define|#
directive|define
name|FIFO_XMT_RST
value|0x04
end_define

begin_comment
comment|/* reset transmit fifo */
end_comment

begin_define
define|#
directive|define
name|FIFO_DMA_MODE
value|0x08
end_define

begin_comment
comment|/* enable dma mode */
end_comment

begin_define
define|#
directive|define
name|FIFO_TRIGGER_1
value|0x00
end_define

begin_comment
comment|/* trigger at 1 char */
end_comment

begin_define
define|#
directive|define
name|FIFO_TRIGGER_4
value|0x40
end_define

begin_comment
comment|/* trigger at 4 chars */
end_comment

begin_define
define|#
directive|define
name|FIFO_TRIGGER_8
value|0x80
end_define

begin_comment
comment|/* trigger at 8 chars */
end_comment

begin_define
define|#
directive|define
name|FIFO_TRIGGER_14
value|0xc0
end_define

begin_comment
comment|/* trigger at 14 chars */
end_comment

begin_comment
comment|/* character format control register */
end_comment

begin_define
define|#
directive|define
name|CFCR_DLAB
value|0x80
end_define

begin_comment
comment|/* divisor latch */
end_comment

begin_define
define|#
directive|define
name|CFCR_SBREAK
value|0x40
end_define

begin_comment
comment|/* send break */
end_comment

begin_define
define|#
directive|define
name|CFCR_PZERO
value|0x30
end_define

begin_comment
comment|/* zero parity */
end_comment

begin_define
define|#
directive|define
name|CFCR_PONE
value|0x20
end_define

begin_comment
comment|/* one parity */
end_comment

begin_define
define|#
directive|define
name|CFCR_PEVEN
value|0x10
end_define

begin_comment
comment|/* even parity */
end_comment

begin_define
define|#
directive|define
name|CFCR_PODD
value|0x00
end_define

begin_comment
comment|/* odd parity */
end_comment

begin_define
define|#
directive|define
name|CFCR_PENAB
value|0x08
end_define

begin_comment
comment|/* parity enable */
end_comment

begin_define
define|#
directive|define
name|CFCR_STOPB
value|0x04
end_define

begin_comment
comment|/* 2 stop bits */
end_comment

begin_define
define|#
directive|define
name|CFCR_8BITS
value|0x03
end_define

begin_comment
comment|/* 8 data bits */
end_comment

begin_define
define|#
directive|define
name|CFCR_7BITS
value|0x02
end_define

begin_comment
comment|/* 7 data bits */
end_comment

begin_define
define|#
directive|define
name|CFCR_6BITS
value|0x01
end_define

begin_comment
comment|/* 6 data bits */
end_comment

begin_define
define|#
directive|define
name|CFCR_5BITS
value|0x00
end_define

begin_comment
comment|/* 5 data bits */
end_comment

begin_comment
comment|/* modem control register */
end_comment

begin_define
define|#
directive|define
name|MCR_LOOPBACK
value|0x10
end_define

begin_comment
comment|/* loopback */
end_comment

begin_define
define|#
directive|define
name|MCR_IENABLE
value|0x08
end_define

begin_comment
comment|/* output 2 = int enable */
end_comment

begin_define
define|#
directive|define
name|MCR_DRS
value|0x04
end_define

begin_comment
comment|/* output 1 = xxx */
end_comment

begin_define
define|#
directive|define
name|MCR_RTS
value|0x02
end_define

begin_comment
comment|/* enable RTS */
end_comment

begin_define
define|#
directive|define
name|MCR_DTR
value|0x01
end_define

begin_comment
comment|/* enable DTR */
end_comment

begin_comment
comment|/* line status register */
end_comment

begin_define
define|#
directive|define
name|LSR_RCV_FIFO
value|0x80
end_define

begin_comment
comment|/* error in receive fifo */
end_comment

begin_define
define|#
directive|define
name|LSR_TSRE
value|0x40
end_define

begin_comment
comment|/* transmitter empty */
end_comment

begin_define
define|#
directive|define
name|LSR_TXRDY
value|0x20
end_define

begin_comment
comment|/* transmitter ready */
end_comment

begin_define
define|#
directive|define
name|LSR_BI
value|0x10
end_define

begin_comment
comment|/* break detected */
end_comment

begin_define
define|#
directive|define
name|LSR_FE
value|0x08
end_define

begin_comment
comment|/* framing error */
end_comment

begin_define
define|#
directive|define
name|LSR_PE
value|0x04
end_define

begin_comment
comment|/* parity error */
end_comment

begin_define
define|#
directive|define
name|LSR_OE
value|0x02
end_define

begin_comment
comment|/* overrun error */
end_comment

begin_define
define|#
directive|define
name|LSR_RXRDY
value|0x01
end_define

begin_comment
comment|/* receiver ready */
end_comment

begin_define
define|#
directive|define
name|LSR_RCV_MASK
value|0x1f
end_define

begin_comment
comment|/* modem status register */
end_comment

begin_define
define|#
directive|define
name|MSR_DCD
value|0x80
end_define

begin_define
define|#
directive|define
name|MSR_RI
value|0x40
end_define

begin_define
define|#
directive|define
name|MSR_DSR
value|0x20
end_define

begin_define
define|#
directive|define
name|MSR_CTS
value|0x10
end_define

begin_define
define|#
directive|define
name|MSR_DDCD
value|0x08
end_define

begin_define
define|#
directive|define
name|MSR_TERI
value|0x04
end_define

begin_define
define|#
directive|define
name|MSR_DDSR
value|0x02
end_define

begin_define
define|#
directive|define
name|MSR_DCTS
value|0x01
end_define

begin_include
include|#
directive|include
file|<sys/dos.h>
end_include

begin_include
include|#
directive|include
file|<sys/go32.h>
end_include

begin_include
include|#
directive|include
file|<sys/dpmi.h>
end_include

begin_comment
comment|/* DPMI Communication */
end_comment

begin_decl_stmt
specifier|static
name|union
name|REGS
name|dpmi_regs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|SREGS
name|dpmi_sregs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 16550 rx fifo trigger point */
end_comment

begin_define
define|#
directive|define
name|FIFO_TRIGGER
value|FIFO_TRIGGER_4
end_define

begin_comment
comment|/* input buffer size */
end_comment

begin_define
define|#
directive|define
name|CBSIZE
value|4096
end_define

begin_comment
comment|/* return raw 18Hz clock count */
end_comment

begin_function_decl
specifier|extern
name|long
name|rawclock
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|RAWHZ
value|18
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|DOS_STATS
end_ifdef

begin_define
define|#
directive|define
name|CNT_RX
value|16
end_define

begin_define
define|#
directive|define
name|CNT_TX
value|17
end_define

begin_define
define|#
directive|define
name|CNT_STRAY
value|18
end_define

begin_define
define|#
directive|define
name|CNT_ORUN
value|19
end_define

begin_define
define|#
directive|define
name|NCNT
value|20
end_define

begin_decl_stmt
specifier|static
name|int
name|intrcnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cnts
index|[
name|NCNT
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cntnames
index|[
name|NCNT
index|]
init|=
block|{
comment|/* h/w interrupt counts. */
literal|"mlsc"
block|,
literal|"nopend"
block|,
literal|"txrdy"
block|,
literal|"?3"
block|,
literal|"rxrdy"
block|,
literal|"?5"
block|,
literal|"rls"
block|,
literal|"?7"
block|,
literal|"?8"
block|,
literal|"?9"
block|,
literal|"?a"
block|,
literal|"?b"
block|,
literal|"rxtout"
block|,
literal|"?d"
block|,
literal|"?e"
block|,
literal|"?f"
block|,
comment|/* s/w counts. */
literal|"rxcnt"
block|,
literal|"txcnt"
block|,
literal|"stray"
block|,
literal|"swoflo"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|COUNT
parameter_list|(
name|x
parameter_list|)
value|cnts[x]++
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|COUNT
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Main interrupt controller port addresses. */
end_comment

begin_define
define|#
directive|define
name|ICU_BASE
value|0x20
end_define

begin_define
define|#
directive|define
name|ICU_OCW2
value|(ICU_BASE + 0)
end_define

begin_define
define|#
directive|define
name|ICU_MASK
value|(ICU_BASE + 1)
end_define

begin_comment
comment|/* Original interrupt controller mask register. */
end_comment

begin_decl_stmt
name|unsigned
name|char
name|icu_oldmask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum of 8 interrupts (we don't handle the slave icu yet). */
end_comment

begin_define
define|#
directive|define
name|NINTR
value|8
end_define

begin_struct
specifier|static
struct|struct
name|intrupt
block|{
name|char
name|inuse
decl_stmt|;
name|struct
name|dos_ttystate
modifier|*
name|port
decl_stmt|;
name|_go32_dpmi_seginfo
name|old_rmhandler
decl_stmt|;
name|_go32_dpmi_seginfo
name|old_pmhandler
decl_stmt|;
name|_go32_dpmi_seginfo
name|new_rmhandler
decl_stmt|;
name|_go32_dpmi_seginfo
name|new_pmhandler
decl_stmt|;
name|_go32_dpmi_registers
name|regs
decl_stmt|;
block|}
name|intrupts
index|[
name|NINTR
index|]
struct|;
end_struct

begin_struct
specifier|static
struct|struct
name|dos_ttystate
block|{
name|int
name|base
decl_stmt|;
name|int
name|irq
decl_stmt|;
name|int
name|refcnt
decl_stmt|;
name|struct
name|intrupt
modifier|*
name|intrupt
decl_stmt|;
name|int
name|fifo
decl_stmt|;
name|int
name|baudrate
decl_stmt|;
name|unsigned
name|char
name|cbuf
index|[
name|CBSIZE
index|]
decl_stmt|;
name|unsigned
name|int
name|first
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|int
name|txbusy
decl_stmt|;
name|unsigned
name|char
name|old_mcr
decl_stmt|;
name|int
name|ferr
decl_stmt|;
name|int
name|perr
decl_stmt|;
name|int
name|oflo
decl_stmt|;
name|int
name|msr
decl_stmt|;
block|}
name|ports
index|[
literal|4
index|]
init|=
block|{
block|{
name|COM1ADDR
block|,
literal|4
block|}
block|,
block|{
name|COM2ADDR
block|,
literal|3
block|}
block|,
block|{
name|COM3ADDR
block|,
literal|4
block|}
block|,
block|{
name|COM4ADDR
block|,
literal|3
block|}
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|dos_open
name|PARAMS
argument_list|(
operator|(
name|serial_t
name|scb
operator|,
specifier|const
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dos_raw
name|PARAMS
argument_list|(
operator|(
name|serial_t
name|scb
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dos_readchar
name|PARAMS
argument_list|(
operator|(
name|serial_t
name|scb
operator|,
name|int
name|timeout
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dos_setbaudrate
name|PARAMS
argument_list|(
operator|(
name|serial_t
name|scb
operator|,
name|int
name|rate
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dos_write
name|PARAMS
argument_list|(
operator|(
name|serial_t
name|scb
operator|,
specifier|const
name|char
operator|*
name|str
operator|,
name|int
name|len
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|dos_close
name|PARAMS
argument_list|(
operator|(
name|serial_t
name|scb
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|serial_ttystate
name|dos_get_tty_state
name|PARAMS
argument_list|(
operator|(
name|serial_t
name|scb
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dos_set_tty_state
name|PARAMS
argument_list|(
operator|(
name|serial_t
name|scb
operator|,
name|serial_ttystate
name|state
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dos_baudconv
name|PARAMS
argument_list|(
operator|(
name|int
name|rate
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|inb
parameter_list|(
name|p
parameter_list|,
name|a
parameter_list|)
value|inportb((p)->base + (a))
end_define

begin_define
define|#
directive|define
name|outb
parameter_list|(
name|p
parameter_list|,
name|a
parameter_list|,
name|v
parameter_list|)
value|outportb((p)->base + (a), (v))
end_define

begin_define
define|#
directive|define
name|disable
parameter_list|()
value|asm volatile ("cli");
end_define

begin_define
define|#
directive|define
name|enable
parameter_list|()
value|asm volatile ("sti");
end_define

begin_function
specifier|static
name|int
name|dos_getc
parameter_list|(
name|port
parameter_list|)
specifier|volatile
name|struct
name|dos_ttystate
modifier|*
name|port
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
if|if
condition|(
name|port
operator|->
name|count
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|c
operator|=
name|port
operator|->
name|cbuf
index|[
name|port
operator|->
name|first
index|]
expr_stmt|;
name|disable
argument_list|()
expr_stmt|;
name|port
operator|->
name|first
operator|=
operator|(
name|port
operator|->
name|first
operator|+
literal|1
operator|)
operator|&
operator|(
name|CBSIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|port
operator|->
name|count
operator|--
expr_stmt|;
name|enable
argument_list|()
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dos_putc
parameter_list|(
name|c
parameter_list|,
name|port
parameter_list|)
name|int
name|c
decl_stmt|;
name|struct
name|dos_ttystate
modifier|*
name|port
decl_stmt|;
block|{
if|if
condition|(
name|port
operator|->
name|count
operator|>=
name|CBSIZE
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|port
operator|->
name|cbuf
index|[
operator|(
name|port
operator|->
name|first
operator|+
name|port
operator|->
name|count
operator|)
operator|&
operator|(
name|CBSIZE
operator|-
literal|1
operator|)
index|]
operator|=
name|c
expr_stmt|;
name|port
operator|->
name|count
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|dos_comisr
parameter_list|(
name|irq
parameter_list|)
name|int
name|irq
decl_stmt|;
block|{
name|struct
name|dos_ttystate
modifier|*
name|port
decl_stmt|;
name|unsigned
name|char
name|iir
decl_stmt|,
name|lsr
decl_stmt|,
name|c
decl_stmt|;
name|disable
argument_list|()
expr_stmt|;
comment|/* Paranoia */
name|outportb
argument_list|(
name|ICU_OCW2
argument_list|,
literal|0x20
argument_list|)
expr_stmt|;
comment|/* End-Of-Interrupt */
ifdef|#
directive|ifdef
name|DOS_STATS
operator|++
name|intrcnt
expr_stmt|;
endif|#
directive|endif
name|port
operator|=
name|intrupts
index|[
name|irq
index|]
operator|.
name|port
expr_stmt|;
if|if
condition|(
operator|!
name|port
condition|)
block|{
name|COUNT
argument_list|(
name|CNT_STRAY
argument_list|)
expr_stmt|;
return|return;
comment|/* not open */
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|iir
operator|=
name|inb
argument_list|(
name|port
argument_list|,
name|com_iir
argument_list|)
operator|&
name|IIR_IMASK
expr_stmt|;
switch|switch
condition|(
name|iir
condition|)
block|{
case|case
name|IIR_RLS
case|:
name|lsr
operator|=
name|inb
argument_list|(
name|port
argument_list|,
name|com_lsr
argument_list|)
expr_stmt|;
goto|goto
name|rx
goto|;
case|case
name|IIR_RXTOUT
case|:
case|case
name|IIR_RXRDY
case|:
name|lsr
operator|=
literal|0
expr_stmt|;
name|rx
label|:
do|do
block|{
name|c
operator|=
name|inb
argument_list|(
name|port
argument_list|,
name|com_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|lsr
operator|&
operator|(
name|LSR_BI
operator||
name|LSR_FE
operator||
name|LSR_PE
operator||
name|LSR_OE
operator|)
condition|)
block|{
if|if
condition|(
name|lsr
operator|&
operator|(
name|LSR_BI
operator||
name|LSR_FE
operator|)
condition|)
name|port
operator|->
name|ferr
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|lsr
operator|&
name|LSR_PE
condition|)
name|port
operator|->
name|perr
operator|++
expr_stmt|;
if|if
condition|(
name|lsr
operator|&
name|LSR_OE
condition|)
name|port
operator|->
name|oflo
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|dos_putc
argument_list|(
name|c
argument_list|,
name|port
argument_list|)
operator|<
literal|0
condition|)
block|{
name|COUNT
argument_list|(
name|CNT_ORUN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|COUNT
argument_list|(
name|CNT_RX
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|lsr
operator|=
name|inb
argument_list|(
name|port
argument_list|,
name|com_lsr
argument_list|)
operator|)
operator|&
name|LSR_RXRDY
condition|)
do|;
break|break;
case|case
name|IIR_MLSC
case|:
comment|/* could be used to flowcontrol Tx */
name|port
operator|->
name|msr
operator|=
name|inb
argument_list|(
name|port
argument_list|,
name|com_msr
argument_list|)
expr_stmt|;
break|break;
case|case
name|IIR_TXRDY
case|:
name|port
operator|->
name|txbusy
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|IIR_NOPEND
case|:
comment|/* no more pending interrupts, all done */
return|return;
default|default:
comment|/* unexpected interrupt, ignore */
break|break;
block|}
name|COUNT
argument_list|(
name|iir
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|ISRNAME
parameter_list|(
name|x
parameter_list|)
value|dos_comisr##x
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ISRNAME
parameter_list|(
name|x
parameter_list|)
value|dos_comisr
comment|/**/
value|x
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ISR
parameter_list|(
name|x
parameter_list|)
value|static void ISRNAME(x)() {dos_comisr(x);}
end_define

begin_macro
name|ISR
argument_list|(
literal|0
argument_list|)
end_macro

begin_macro
name|ISR
argument_list|(
literal|1
argument_list|)
end_macro

begin_macro
name|ISR
argument_list|(
literal|2
argument_list|)
end_macro

begin_macro
name|ISR
argument_list|(
literal|3
argument_list|)
end_macro

begin_macro
name|ISR
argument_list|(
literal|4
argument_list|)
end_macro

begin_macro
name|ISR
argument_list|(
literal|5
argument_list|)
end_macro

begin_macro
name|ISR
argument_list|(
literal|6
argument_list|)
end_macro

begin_macro
name|ISR
argument_list|(
literal|7
argument_list|)
end_macro

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|isr_t
function_decl|)
parameter_list|()
function_decl|;
end_typedef

begin_decl_stmt
specifier|static
name|isr_t
name|isrs
index|[
name|NINTR
index|]
init|=
block|{
name|ISRNAME
argument_list|(
literal|0
argument_list|)
block|,
name|ISRNAME
argument_list|(
literal|1
argument_list|)
block|,
name|ISRNAME
argument_list|(
literal|2
argument_list|)
block|,
name|ISRNAME
argument_list|(
literal|3
argument_list|)
block|,
name|ISRNAME
argument_list|(
literal|4
argument_list|)
block|,
name|ISRNAME
argument_list|(
literal|5
argument_list|)
block|,
name|ISRNAME
argument_list|(
literal|6
argument_list|)
block|,
name|ISRNAME
argument_list|(
literal|7
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_function
specifier|static
name|struct
name|intrupt
modifier|*
name|dos_hookirq
parameter_list|(
name|irq
parameter_list|)
name|unsigned
name|int
name|irq
decl_stmt|;
block|{
name|struct
name|intrupt
modifier|*
name|intr
decl_stmt|;
name|unsigned
name|int
name|vec
decl_stmt|;
name|isr_t
name|isr
decl_stmt|;
if|if
condition|(
name|irq
operator|>=
name|NINTR
condition|)
return|return
literal|0
return|;
name|intr
operator|=
operator|&
name|intrupts
index|[
name|irq
index|]
expr_stmt|;
if|if
condition|(
name|intr
operator|->
name|inuse
condition|)
return|return
literal|0
return|;
name|vec
operator|=
literal|0x08
operator|+
name|irq
expr_stmt|;
name|isr
operator|=
name|isrs
index|[
name|irq
index|]
expr_stmt|;
comment|/* setup real mode handler */
name|_go32_dpmi_get_real_mode_interrupt_vector
argument_list|(
name|vec
argument_list|,
operator|&
name|intr
operator|->
name|old_rmhandler
argument_list|)
expr_stmt|;
name|intr
operator|->
name|new_rmhandler
operator|.
name|pm_selector
operator|=
name|_go32_my_cs
argument_list|()
expr_stmt|;
name|intr
operator|->
name|new_rmhandler
operator|.
name|pm_offset
operator|=
operator|(
name|u_long
operator|)
name|isr
expr_stmt|;
if|if
condition|(
name|_go32_dpmi_allocate_real_mode_callback_iret
argument_list|(
operator|&
name|intr
operator|->
name|new_rmhandler
argument_list|,
operator|&
name|intr
operator|->
name|regs
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|_go32_dpmi_set_real_mode_interrupt_vector
argument_list|(
name|vec
argument_list|,
operator|&
name|intr
operator|->
name|new_rmhandler
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* setup protected mode handler */
name|_go32_dpmi_get_protected_mode_interrupt_vector
argument_list|(
name|vec
argument_list|,
operator|&
name|intr
operator|->
name|old_pmhandler
argument_list|)
expr_stmt|;
name|intr
operator|->
name|new_pmhandler
operator|.
name|pm_selector
operator|=
name|_go32_my_cs
argument_list|()
expr_stmt|;
name|intr
operator|->
name|new_pmhandler
operator|.
name|pm_offset
operator|=
operator|(
name|u_long
operator|)
name|isr
expr_stmt|;
name|_go32_dpmi_allocate_iret_wrapper
argument_list|(
operator|&
name|intr
operator|->
name|new_pmhandler
argument_list|)
expr_stmt|;
if|if
condition|(
name|_go32_dpmi_set_protected_mode_interrupt_vector
argument_list|(
name|vec
argument_list|,
operator|&
name|intr
operator|->
name|new_pmhandler
argument_list|)
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* setup interrupt controller mask */
name|disable
argument_list|()
expr_stmt|;
name|outportb
argument_list|(
name|ICU_MASK
argument_list|,
name|inportb
argument_list|(
name|ICU_MASK
argument_list|)
operator|&
operator|~
operator|(
literal|1
operator|<<
name|irq
operator|)
argument_list|)
expr_stmt|;
name|enable
argument_list|()
expr_stmt|;
name|intr
operator|->
name|inuse
operator|=
literal|1
expr_stmt|;
return|return
name|intr
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dos_unhookirq
parameter_list|(
name|intr
parameter_list|)
name|struct
name|intrupt
modifier|*
name|intr
decl_stmt|;
block|{
name|unsigned
name|int
name|irq
decl_stmt|,
name|vec
decl_stmt|;
name|unsigned
name|char
name|mask
decl_stmt|;
name|irq
operator|=
name|intr
operator|-
name|intrupts
expr_stmt|;
name|vec
operator|=
literal|0x08
operator|+
name|irq
expr_stmt|;
comment|/* restore old interrupt mask bit */
name|mask
operator|=
literal|1
operator|<<
name|irq
expr_stmt|;
name|disable
argument_list|()
expr_stmt|;
name|outportb
argument_list|(
name|ICU_MASK
argument_list|,
name|inportb
argument_list|(
name|ICU_MASK
argument_list|)
operator||
operator|(
name|mask
operator|&
name|icu_oldmask
operator|)
argument_list|)
expr_stmt|;
name|enable
argument_list|()
expr_stmt|;
comment|/* remove real mode handler */
name|_go32_dpmi_set_real_mode_interrupt_vector
argument_list|(
name|vec
argument_list|,
operator|&
name|intr
operator|->
name|old_rmhandler
argument_list|)
expr_stmt|;
name|_go32_dpmi_free_real_mode_callback
argument_list|(
operator|&
name|intr
operator|->
name|new_rmhandler
argument_list|)
expr_stmt|;
comment|/* remove protected mode handler */
name|_go32_dpmi_set_protected_mode_interrupt_vector
argument_list|(
name|vec
argument_list|,
operator|&
name|intr
operator|->
name|old_pmhandler
argument_list|)
expr_stmt|;
name|_go32_dpmi_free_iret_wrapper
argument_list|(
operator|&
name|intr
operator|->
name|new_pmhandler
argument_list|)
expr_stmt|;
name|intr
operator|->
name|inuse
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|dos_open
parameter_list|(
name|scb
parameter_list|,
name|name
parameter_list|)
name|serial_t
name|scb
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|struct
name|dos_ttystate
modifier|*
name|port
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"/dev/"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
name|name
operator|+=
literal|5
expr_stmt|;
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"\\dev\\"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
name|name
operator|+=
literal|5
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|!=
literal|4
operator|||
name|strncasecmp
argument_list|(
name|name
argument_list|,
literal|"com"
argument_list|,
literal|3
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|errno
operator|=
name|ENOENT
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|name
index|[
literal|3
index|]
operator|<
literal|'1'
operator|||
name|name
index|[
literal|3
index|]
operator|>
literal|'4'
condition|)
block|{
name|errno
operator|=
name|ENOENT
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|fd
operator|=
name|name
index|[
literal|3
index|]
operator|-
literal|'1'
expr_stmt|;
name|port
operator|=
operator|&
name|ports
index|[
name|fd
index|]
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|refcnt
operator|++
operator|>
literal|0
condition|)
block|{
comment|/* Device already opened another user.  Just point at it. */
name|scb
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* force access to ID reg */
name|outb
argument_list|(
name|port
argument_list|,
name|com_cfcr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|port
argument_list|,
name|com_iir
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|17
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|inb
argument_list|(
name|port
argument_list|,
name|com_iir
argument_list|)
operator|&
literal|0x38
operator|)
operator|==
literal|0
condition|)
goto|goto
name|ok
goto|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|port
argument_list|,
name|com_data
argument_list|)
expr_stmt|;
comment|/* clear recv */
block|}
name|errno
operator|=
name|ENODEV
expr_stmt|;
return|return
operator|-
literal|1
return|;
name|ok
label|:
comment|/* disable all interrupts in chip */
name|outb
argument_list|(
name|port
argument_list|,
name|com_ier
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* tentatively enable 16550 fifo, and see if it responds */
name|outb
argument_list|(
name|port
argument_list|,
name|com_fifo
argument_list|,
name|FIFO_ENABLE
operator||
name|FIFO_RCV_RST
operator||
name|FIFO_XMT_RST
operator||
name|FIFO_TRIGGER
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|port
operator|->
name|fifo
operator|=
operator|(
operator|(
name|inb
argument_list|(
name|port
argument_list|,
name|com_iir
argument_list|)
operator|&
name|IIR_FIFO_MASK
operator|)
operator|==
name|IIR_FIFO_MASK
operator|)
expr_stmt|;
comment|/* clear pending status reports. */
operator|(
name|void
operator|)
name|inb
argument_list|(
name|port
argument_list|,
name|com_lsr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|inb
argument_list|(
name|port
argument_list|,
name|com_msr
argument_list|)
expr_stmt|;
comment|/* enable external interrupt gate (to avoid floating IRQ) */
name|outb
argument_list|(
name|port
argument_list|,
name|com_mcr
argument_list|,
name|MCR_IENABLE
argument_list|)
expr_stmt|;
comment|/* hook up interrupt handler and initialise icu */
name|port
operator|->
name|intrupt
operator|=
name|dos_hookirq
argument_list|(
name|port
operator|->
name|irq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|port
operator|->
name|intrupt
condition|)
block|{
name|outb
argument_list|(
name|port
argument_list|,
name|com_mcr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|port
argument_list|,
name|com_fifo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ENODEV
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|disable
argument_list|()
expr_stmt|;
comment|/* record port */
name|port
operator|->
name|intrupt
operator|->
name|port
operator|=
name|port
expr_stmt|;
name|scb
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
comment|/* clear rx buffer, tx busy flag and overflow count */
name|port
operator|->
name|first
operator|=
name|port
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|port
operator|->
name|txbusy
operator|=
literal|0
expr_stmt|;
name|port
operator|->
name|oflo
operator|=
literal|0
expr_stmt|;
comment|/* set default baud rate and mode: 9600,8,n,1 */
name|i
operator|=
name|dos_baudconv
argument_list|(
name|port
operator|->
name|baudrate
operator|=
literal|9600
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|port
argument_list|,
name|com_cfcr
argument_list|,
name|CFCR_DLAB
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|port
argument_list|,
name|com_dlbl
argument_list|,
name|i
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|port
argument_list|,
name|com_dlbh
argument_list|,
name|i
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|port
argument_list|,
name|com_cfcr
argument_list|,
name|CFCR_8BITS
argument_list|)
expr_stmt|;
comment|/* enable all interrupts */
name|outb
argument_list|(
name|port
argument_list|,
name|com_ier
argument_list|,
name|IER_ETXRDY
operator||
name|IER_ERXRDY
operator||
name|IER_ERLS
operator||
name|IER_EMSC
argument_list|)
expr_stmt|;
comment|/* enable DTR& RTS */
name|outb
argument_list|(
name|port
argument_list|,
name|com_mcr
argument_list|,
name|MCR_DTR
operator||
name|MCR_RTS
operator||
name|MCR_IENABLE
argument_list|)
expr_stmt|;
name|enable
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dos_close
parameter_list|(
name|scb
parameter_list|)
name|serial_t
name|scb
decl_stmt|;
block|{
name|struct
name|dos_ttystate
modifier|*
name|port
decl_stmt|;
name|struct
name|intrupt
modifier|*
name|intrupt
decl_stmt|;
if|if
condition|(
operator|!
name|scb
condition|)
return|return;
name|port
operator|=
operator|&
name|ports
index|[
name|scb
operator|->
name|fd
index|]
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|refcnt
operator|--
operator|>
literal|1
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|intrupt
operator|=
name|port
operator|->
name|intrupt
operator|)
condition|)
return|return;
comment|/* disable interrupts, fifo, flow control */
name|disable
argument_list|()
expr_stmt|;
name|port
operator|->
name|intrupt
operator|=
literal|0
expr_stmt|;
name|intrupt
operator|->
name|port
operator|=
literal|0
expr_stmt|;
name|outb
argument_list|(
name|port
argument_list|,
name|com_fifo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|port
argument_list|,
name|com_ier
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|enable
argument_list|()
expr_stmt|;
comment|/* unhook handler, and disable interrupt gate */
name|dos_unhookirq
argument_list|(
name|intrupt
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|port
argument_list|,
name|com_mcr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Check for overflow errors */
if|if
condition|(
name|port
operator|->
name|oflo
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Serial input overruns occurred.\n"
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"This system %s handle %d baud.\n"
argument_list|,
name|port
operator|->
name|fifo
condition|?
literal|"cannot"
else|:
literal|"needs a 16550 to"
argument_list|,
name|port
operator|->
name|baudrate
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|int
name|dos_noop
parameter_list|(
name|scb
parameter_list|)
name|serial_t
name|scb
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dos_raw
parameter_list|(
name|scb
parameter_list|)
name|serial_t
name|scb
decl_stmt|;
block|{
comment|/* Always in raw mode */
block|}
end_function

begin_function
specifier|static
name|int
name|dos_readchar
parameter_list|(
name|scb
parameter_list|,
name|timeout
parameter_list|)
name|serial_t
name|scb
decl_stmt|;
name|int
name|timeout
decl_stmt|;
block|{
name|struct
name|dos_ttystate
modifier|*
name|port
init|=
operator|&
name|ports
index|[
name|scb
operator|->
name|fd
index|]
decl_stmt|;
name|long
name|then
decl_stmt|;
name|int
name|c
decl_stmt|;
name|then
operator|=
name|rawclock
argument_list|()
operator|+
operator|(
name|timeout
operator|*
name|RAWHZ
operator|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|dos_getc
argument_list|(
name|port
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|timeout
operator|>=
literal|0
operator|&&
operator|(
name|rawclock
argument_list|()
operator|-
name|then
operator|)
operator|>=
literal|0
condition|)
return|return
name|SERIAL_TIMEOUT
return|;
name|notice_quit
argument_list|()
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
end_function

begin_function
specifier|static
name|serial_ttystate
name|dos_get_tty_state
parameter_list|(
name|scb
parameter_list|)
name|serial_t
name|scb
decl_stmt|;
block|{
name|struct
name|dos_ttystate
modifier|*
name|port
init|=
operator|&
name|ports
index|[
name|scb
operator|->
name|fd
index|]
decl_stmt|;
name|struct
name|dos_ttystate
modifier|*
name|state
decl_stmt|;
name|state
operator|=
operator|(
expr|struct
name|dos_ttystate
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
expr|*
name|state
argument_list|)
expr_stmt|;
operator|*
name|state
operator|=
operator|*
name|port
expr_stmt|;
return|return
operator|(
name|serial_ttystate
operator|)
name|state
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dos_set_tty_state
parameter_list|(
name|scb
parameter_list|,
name|ttystate
parameter_list|)
name|serial_t
name|scb
decl_stmt|;
name|serial_ttystate
name|ttystate
decl_stmt|;
block|{
name|struct
name|dos_ttystate
modifier|*
name|state
decl_stmt|;
name|state
operator|=
operator|(
expr|struct
name|dos_ttystate
operator|*
operator|)
name|ttystate
expr_stmt|;
name|dos_setbaudrate
argument_list|(
name|scb
argument_list|,
name|state
operator|->
name|baudrate
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dos_noflush_set_tty_state
parameter_list|(
name|scb
parameter_list|,
name|new_ttystate
parameter_list|,
name|old_ttystate
parameter_list|)
name|serial_t
name|scb
decl_stmt|;
name|serial_ttystate
name|new_ttystate
decl_stmt|;
name|serial_ttystate
name|old_ttystate
decl_stmt|;
block|{
name|struct
name|dos_ttystate
modifier|*
name|state
decl_stmt|;
name|state
operator|=
operator|(
expr|struct
name|dos_ttystate
operator|*
operator|)
name|new_ttystate
expr_stmt|;
name|dos_setbaudrate
argument_list|(
name|scb
argument_list|,
name|state
operator|->
name|baudrate
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dos_flush_input
parameter_list|(
name|scb
parameter_list|)
name|serial_t
name|scb
decl_stmt|;
block|{
name|struct
name|dos_ttystate
modifier|*
name|port
init|=
operator|&
name|ports
index|[
name|scb
operator|->
name|fd
index|]
decl_stmt|;
name|disable
argument_list|()
expr_stmt|;
name|port
operator|->
name|first
operator|=
name|port
operator|->
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|port
operator|->
name|fifo
condition|)
name|outb
argument_list|(
name|port
argument_list|,
name|com_fifo
argument_list|,
name|FIFO_ENABLE
operator||
name|FIFO_RCV_RST
operator||
name|FIFO_TRIGGER
argument_list|)
expr_stmt|;
name|enable
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dos_print_tty_state
parameter_list|(
name|scb
parameter_list|,
name|ttystate
parameter_list|)
name|serial_t
name|scb
decl_stmt|;
name|serial_ttystate
name|ttystate
decl_stmt|;
block|{
comment|/* Nothing to print */
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|dos_baudconv
parameter_list|(
name|rate
parameter_list|)
name|int
name|rate
decl_stmt|;
block|{
name|long
name|x
decl_stmt|,
name|err
decl_stmt|;
if|if
condition|(
name|rate
operator|<=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
define|#
directive|define
name|divrnd
parameter_list|(
name|n
parameter_list|,
name|q
parameter_list|)
value|(((n) * 2 / (q) + 1) / 2)
comment|/* divide and round off */
name|x
operator|=
name|divrnd
argument_list|(
name|COMTICK
argument_list|,
name|rate
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|err
operator|=
name|divrnd
argument_list|(
literal|1000
operator|*
name|COMTICK
argument_list|,
name|x
operator|*
name|rate
argument_list|)
operator|-
literal|1000
expr_stmt|;
if|if
condition|(
name|err
operator|<
literal|0
condition|)
name|err
operator|=
operator|-
name|err
expr_stmt|;
if|if
condition|(
name|err
operator|>
name|SPEED_TOLERANCE
condition|)
return|return
operator|-
literal|1
return|;
undef|#
directive|undef
name|divrnd
return|return
name|x
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dos_setbaudrate
parameter_list|(
name|scb
parameter_list|,
name|rate
parameter_list|)
name|serial_t
name|scb
decl_stmt|;
name|int
name|rate
decl_stmt|;
block|{
name|struct
name|dos_ttystate
modifier|*
name|port
init|=
operator|&
name|ports
index|[
name|scb
operator|->
name|fd
index|]
decl_stmt|;
if|if
condition|(
name|port
operator|->
name|baudrate
operator|!=
name|rate
condition|)
block|{
name|int
name|x
decl_stmt|;
name|unsigned
name|char
name|cfcr
decl_stmt|;
name|x
operator|=
name|dos_baudconv
argument_list|(
name|rate
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<=
literal|0
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"%d: impossible baudrate\n"
argument_list|,
name|rate
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|disable
argument_list|()
expr_stmt|;
name|cfcr
operator|=
name|inb
argument_list|(
name|port
argument_list|,
name|com_cfcr
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|port
argument_list|,
name|com_cfcr
argument_list|,
name|CFCR_DLAB
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|port
argument_list|,
name|com_dlbl
argument_list|,
name|x
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|port
argument_list|,
name|com_dlbh
argument_list|,
name|x
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|port
argument_list|,
name|com_cfcr
argument_list|,
name|cfcr
argument_list|)
expr_stmt|;
name|port
operator|->
name|baudrate
operator|=
name|rate
expr_stmt|;
name|enable
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dos_setstopbits
parameter_list|(
name|scb
parameter_list|,
name|num
parameter_list|)
name|serial_t
name|scb
decl_stmt|;
name|int
name|num
decl_stmt|;
block|{
name|struct
name|dos_ttystate
modifier|*
name|port
init|=
operator|&
name|ports
index|[
name|scb
operator|->
name|fd
index|]
decl_stmt|;
name|unsigned
name|char
name|cfcr
decl_stmt|;
name|disable
argument_list|()
expr_stmt|;
name|cfcr
operator|=
name|inb
argument_list|(
name|port
argument_list|,
name|com_cfcr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|num
condition|)
block|{
case|case
name|SERIAL_1_STOPBITS
case|:
name|outb
argument_list|(
name|port
argument_list|,
name|com_cfcr
argument_list|,
name|cfcr
operator|&
operator|~
name|CFCR_STOPB
argument_list|)
expr_stmt|;
break|break;
case|case
name|SERIAL_1_AND_A_HALF_STOPBITS
case|:
case|case
name|SERIAL_2_STOPBITS
case|:
name|outb
argument_list|(
name|port
argument_list|,
name|com_cfcr
argument_list|,
name|cfcr
operator||
name|CFCR_STOPB
argument_list|)
expr_stmt|;
break|break;
default|default:
name|enable
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
name|enable
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dos_write
parameter_list|(
name|scb
parameter_list|,
name|str
parameter_list|,
name|len
parameter_list|)
name|serial_t
name|scb
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|volatile
name|struct
name|dos_ttystate
modifier|*
name|port
init|=
operator|&
name|ports
index|[
name|scb
operator|->
name|fd
index|]
decl_stmt|;
name|int
name|fifosize
init|=
name|port
operator|->
name|fifo
condition|?
literal|16
else|:
literal|1
decl_stmt|;
name|long
name|then
decl_stmt|;
name|int
name|cnt
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* send the data, fifosize bytes at a time */
name|cnt
operator|=
name|fifosize
operator|>
name|len
condition|?
name|len
else|:
name|fifosize
expr_stmt|;
name|port
operator|->
name|txbusy
operator|=
literal|1
expr_stmt|;
name|outportsb
argument_list|(
name|port
operator|->
name|base
operator|+
name|com_data
argument_list|,
name|str
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|str
operator|+=
name|cnt
expr_stmt|;
name|len
operator|-=
name|cnt
expr_stmt|;
ifdef|#
directive|ifdef
name|DOS_STATS
name|cnts
index|[
name|CNT_TX
index|]
operator|+=
name|cnt
expr_stmt|;
endif|#
directive|endif
comment|/* wait for transmission to complete (max 1 sec) */
name|then
operator|=
name|rawclock
argument_list|()
operator|+
name|RAWHZ
expr_stmt|;
while|while
condition|(
name|port
operator|->
name|txbusy
condition|)
block|{
if|if
condition|(
operator|(
name|rawclock
argument_list|()
operator|-
name|then
operator|)
operator|>=
literal|0
condition|)
block|{
name|errno
operator|=
name|EIO
expr_stmt|;
return|return
name|SERIAL_ERROR
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dos_sendbreak
parameter_list|(
name|scb
parameter_list|)
name|serial_t
name|scb
decl_stmt|;
block|{
specifier|volatile
name|struct
name|dos_ttystate
modifier|*
name|port
init|=
operator|&
name|ports
index|[
name|scb
operator|->
name|fd
index|]
decl_stmt|;
name|unsigned
name|char
name|cfcr
decl_stmt|;
name|long
name|then
decl_stmt|;
name|cfcr
operator|=
name|inb
argument_list|(
name|port
argument_list|,
name|com_cfcr
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|port
argument_list|,
name|com_cfcr
argument_list|,
name|cfcr
operator||
name|CFCR_SBREAK
argument_list|)
expr_stmt|;
comment|/* 0.25 sec delay */
name|then
operator|=
name|rawclock
argument_list|()
operator|+
name|RAWHZ
operator|/
literal|4
expr_stmt|;
while|while
condition|(
operator|(
name|rawclock
argument_list|()
operator|-
name|then
operator|)
operator|<
literal|0
condition|)
continue|continue;
name|outb
argument_list|(
name|port
argument_list|,
name|com_cfcr
argument_list|,
name|cfcr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|serial_ops
name|dos_ops
init|=
block|{
literal|"hardwire"
block|,
literal|0
block|,
name|dos_open
block|,
name|dos_close
block|,
name|dos_readchar
block|,
name|dos_write
block|,
name|dos_noop
block|,
comment|/* flush output */
name|dos_flush_input
block|,
name|dos_sendbreak
block|,
name|dos_raw
block|,
name|dos_get_tty_state
block|,
name|dos_set_tty_state
block|,
name|dos_print_tty_state
block|,
name|dos_noflush_set_tty_state
block|,
name|dos_setbaudrate
block|,
name|dos_setstopbits
block|,
name|dos_noop
block|,
comment|/* wait for output to drain */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|dos_info
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|dos_ttystate
modifier|*
name|port
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|port
operator|=
name|ports
init|;
name|port
operator|<
operator|&
name|ports
index|[
literal|4
index|]
condition|;
name|port
operator|++
control|)
block|{
if|if
condition|(
name|port
operator|->
name|baudrate
operator|==
literal|0
condition|)
continue|continue;
name|printf_filtered
argument_list|(
literal|"Port:\tCOM%d (%sactive)\n"
argument_list|,
name|port
operator|-
name|ports
operator|+
literal|1
argument_list|,
name|port
operator|->
name|intrupt
condition|?
literal|""
else|:
literal|"not "
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Addr:\t0x%03x (irq %d)\n"
argument_list|,
name|port
operator|->
name|base
argument_list|,
name|port
operator|->
name|irq
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"16550:\t%s\n"
argument_list|,
name|port
operator|->
name|fifo
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Speed:\t%d baud\n"
argument_list|,
name|port
operator|->
name|baudrate
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Errs:\tframing %d parity %d overflow %d\n\n"
argument_list|,
name|port
operator|->
name|ferr
argument_list|,
name|port
operator|->
name|perr
argument_list|,
name|port
operator|->
name|oflo
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DOS_STATS
name|printf_filtered
argument_list|(
literal|"\nTotal interrupts: %d\n"
argument_list|,
name|intrcnt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCNT
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|cnts
index|[
name|i
index|]
condition|)
name|printf_filtered
argument_list|(
literal|"%s:\t%d\n"
argument_list|,
name|cntnames
index|[
name|i
index|]
argument_list|,
name|cnts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|_initialize_ser_dos
parameter_list|()
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|serial_add_interface
argument_list|(
operator|&
name|dos_ops
argument_list|)
expr_stmt|;
comment|/* Save original interrupt mask register. */
name|icu_oldmask
operator|=
name|inportb
argument_list|(
name|ICU_MASK
argument_list|)
expr_stmt|;
comment|/* Mark fixed motherboard irqs as inuse. */
name|intrupts
index|[
literal|0
index|]
operator|.
name|inuse
operator|=
comment|/* timer tick */
name|intrupts
index|[
literal|1
index|]
operator|.
name|inuse
operator|=
comment|/* keyboard */
name|intrupts
index|[
literal|2
index|]
operator|.
name|inuse
operator|=
literal|1
expr_stmt|;
comment|/* slave icu */
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"com1base"
argument_list|,
name|class_obscure
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ports
index|[
literal|0
index|]
operator|.
name|base
argument_list|,
literal|"Set COM1 base i/o port address."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"com1irq"
argument_list|,
name|class_obscure
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ports
index|[
literal|0
index|]
operator|.
name|irq
argument_list|,
literal|"Set COM1 interrupt request."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"com2base"
argument_list|,
name|class_obscure
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ports
index|[
literal|1
index|]
operator|.
name|base
argument_list|,
literal|"Set COM2 base i/o port address."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"com2irq"
argument_list|,
name|class_obscure
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ports
index|[
literal|1
index|]
operator|.
name|irq
argument_list|,
literal|"Set COM2 interrupt request."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"com3base"
argument_list|,
name|class_obscure
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ports
index|[
literal|2
index|]
operator|.
name|base
argument_list|,
literal|"Set COM3 base i/o port address."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"com3irq"
argument_list|,
name|class_obscure
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ports
index|[
literal|2
index|]
operator|.
name|irq
argument_list|,
literal|"Set COM3 interrupt request."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"com4base"
argument_list|,
name|class_obscure
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ports
index|[
literal|3
index|]
operator|.
name|base
argument_list|,
literal|"Set COM4 base i/o port address."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"com4irq"
argument_list|,
name|class_obscure
argument_list|,
name|var_zinteger
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ports
index|[
literal|3
index|]
operator|.
name|irq
argument_list|,
literal|"Set COM4 interrupt request."
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"serial"
argument_list|,
name|dos_info
argument_list|,
literal|"Print DOS serial port status."
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

