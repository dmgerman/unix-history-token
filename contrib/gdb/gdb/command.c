begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Handle lists of commands, their decoding and documentation, for GDB.    Copyright 1986, 1989, 1990, 1991, 1998 Free Software Foundation, Inc.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_WAIT_H
end_ifdef

begin_include
include|#
directive|include
file|<wait.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_WAIT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_decl_stmt
specifier|static
name|void
name|undef_cmd_error
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|show_user
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|show_user_1
name|PARAMS
argument_list|(
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|,
name|GDB_FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|make_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|shell_escape
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|parse_binary_operation
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|print_doc_line
name|PARAMS
argument_list|(
operator|(
name|GDB_FILE
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|_initialize_command
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add element named NAME.    CLASS is the top level category into which commands are broken down    for "help" purposes.    FUN should be the function to execute the command;    it will get a character string as argument, with leading    and trailing blanks already eliminated.     DOC is a documentation string for the command.    Its first line should be a complete sentence.    It should start with ? for a command that is an abbreviation    or with * for a command that most users don't need to know about.     Add this command to command list *LIST.       Returns a pointer to the added command (not necessarily the head     of *LIST). */
end_comment

begin_function_decl
name|struct
name|cmd_list_element
modifier|*
name|add_cmd
parameter_list|(
name|name
parameter_list|,
name|class
parameter_list|,
name|fun
parameter_list|,
name|doc
parameter_list|,
name|list
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|enum
name|command_class
name|class
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*fun
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|doc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|list
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|cmd_list_element
modifier|*
name|c
init|=
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cmd_list_element
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|p
decl_stmt|;
name|delete_cmd
argument_list|(
name|name
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|list
operator|==
name|NULL
operator|||
name|STRCMP
argument_list|(
operator|(
operator|*
name|list
operator|)
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|c
operator|->
name|next
operator|=
operator|*
name|list
expr_stmt|;
operator|*
name|list
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
operator|*
name|list
expr_stmt|;
while|while
condition|(
name|p
operator|->
name|next
operator|&&
name|STRCMP
argument_list|(
name|p
operator|->
name|next
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
name|c
operator|->
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|c
expr_stmt|;
block|}
name|c
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|c
operator|->
name|class
operator|=
name|class
expr_stmt|;
name|c
operator|->
name|function
operator|.
name|cfunc
operator|=
name|fun
expr_stmt|;
name|c
operator|->
name|doc
operator|=
name|doc
expr_stmt|;
name|c
operator|->
name|hook
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|prefixlist
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|prefixname
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|allow_unknown
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|abbrev_flag
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|completer
operator|=
name|make_symbol_completion_list
expr_stmt|;
name|c
operator|->
name|type
operator|=
name|not_set_cmd
expr_stmt|;
name|c
operator|->
name|var
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|var_type
operator|=
name|var_boolean
expr_stmt|;
name|c
operator|->
name|enums
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|user_commands
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|hookee
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|cmd_pointer
operator|=
name|NULL
expr_stmt|;
return|return
name|c
return|;
block|}
end_block

begin_comment
comment|/* Same as above, except that the abbrev_flag is set. */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Currently unused */
end_comment

begin_endif
unit|struct cmd_list_element * add_abbrev_cmd (name, class, fun, doc, list)      char *name;      enum command_class class;      void (*fun) PARAMS ((char *, int));      char *doc;      struct cmd_list_element **list; {   register struct cmd_list_element *c     = add_cmd (name, class, fun, doc, list);    c->abbrev_flag = 1;   return c; }
endif|#
directive|endif
end_endif

begin_function
name|struct
name|cmd_list_element
modifier|*
name|add_alias_cmd
parameter_list|(
name|name
parameter_list|,
name|oldname
parameter_list|,
name|class
parameter_list|,
name|abbrev_flag
parameter_list|,
name|list
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|oldname
decl_stmt|;
name|enum
name|command_class
name|class
decl_stmt|;
name|int
name|abbrev_flag
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|list
decl_stmt|;
block|{
comment|/* Must do this since lookup_cmd tries to side-effect its first arg */
name|char
modifier|*
name|copied_name
decl_stmt|;
specifier|register
name|struct
name|cmd_list_element
modifier|*
name|old
decl_stmt|;
specifier|register
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|copied_name
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|oldname
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|copied_name
argument_list|,
name|oldname
argument_list|)
expr_stmt|;
name|old
operator|=
name|lookup_cmd
argument_list|(
operator|&
name|copied_name
argument_list|,
operator|*
name|list
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
literal|0
condition|)
block|{
name|delete_cmd
argument_list|(
name|name
argument_list|,
name|list
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|c
operator|=
name|add_cmd
argument_list|(
name|name
argument_list|,
name|class
argument_list|,
name|old
operator|->
name|function
operator|.
name|cfunc
argument_list|,
name|old
operator|->
name|doc
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|c
operator|->
name|prefixlist
operator|=
name|old
operator|->
name|prefixlist
expr_stmt|;
name|c
operator|->
name|prefixname
operator|=
name|old
operator|->
name|prefixname
expr_stmt|;
name|c
operator|->
name|allow_unknown
operator|=
name|old
operator|->
name|allow_unknown
expr_stmt|;
name|c
operator|->
name|abbrev_flag
operator|=
name|abbrev_flag
expr_stmt|;
name|c
operator|->
name|cmd_pointer
operator|=
name|old
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* Like add_cmd but adds an element for a command prefix:    a name that should be followed by a subcommand to be looked up    in another command list.  PREFIXLIST should be the address    of the variable containing that list.  */
end_comment

begin_function_decl
name|struct
name|cmd_list_element
modifier|*
name|add_prefix_cmd
parameter_list|(
name|name
parameter_list|,
name|class
parameter_list|,
name|fun
parameter_list|,
name|doc
parameter_list|,
name|prefixlist
parameter_list|,
name|prefixname
parameter_list|,
name|allow_unknown
parameter_list|,
name|list
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|enum
name|command_class
name|class
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*fun
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|doc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|prefixlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|prefixname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|allow_unknown
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|list
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|cmd_list_element
modifier|*
name|c
init|=
name|add_cmd
argument_list|(
name|name
argument_list|,
name|class
argument_list|,
name|fun
argument_list|,
name|doc
argument_list|,
name|list
argument_list|)
decl_stmt|;
name|c
operator|->
name|prefixlist
operator|=
name|prefixlist
expr_stmt|;
name|c
operator|->
name|prefixname
operator|=
name|prefixname
expr_stmt|;
name|c
operator|->
name|allow_unknown
operator|=
name|allow_unknown
expr_stmt|;
return|return
name|c
return|;
block|}
end_block

begin_comment
comment|/* Like add_prefix_cmd but sets the abbrev_flag on the new command. */
end_comment

begin_function_decl
name|struct
name|cmd_list_element
modifier|*
name|add_abbrev_prefix_cmd
parameter_list|(
name|name
parameter_list|,
name|class
parameter_list|,
name|fun
parameter_list|,
name|doc
parameter_list|,
name|prefixlist
parameter_list|,
name|prefixname
parameter_list|,
name|allow_unknown
parameter_list|,
name|list
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|enum
name|command_class
name|class
decl_stmt|;
function_decl|void
parameter_list|(
function_decl|*fun
end_function_decl

begin_expr_stmt
unit|)
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|doc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|prefixlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|prefixname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|allow_unknown
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|list
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|cmd_list_element
modifier|*
name|c
init|=
name|add_cmd
argument_list|(
name|name
argument_list|,
name|class
argument_list|,
name|fun
argument_list|,
name|doc
argument_list|,
name|list
argument_list|)
decl_stmt|;
name|c
operator|->
name|prefixlist
operator|=
name|prefixlist
expr_stmt|;
name|c
operator|->
name|prefixname
operator|=
name|prefixname
expr_stmt|;
name|c
operator|->
name|allow_unknown
operator|=
name|allow_unknown
expr_stmt|;
name|c
operator|->
name|abbrev_flag
operator|=
literal|1
expr_stmt|;
return|return
name|c
return|;
block|}
end_block

begin_comment
comment|/* This is an empty "cfunc".  */
end_comment

begin_function
name|void
name|not_just_help_class_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{ }
end_function

begin_comment
comment|/* This is an empty "sfunc".  */
end_comment

begin_decl_stmt
specifier|static
name|void
name|empty_sfunc
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
expr|struct
name|cmd_list_element
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|empty_sfunc
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|,
name|c
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
block|{ }
end_function

begin_comment
comment|/* Add element named NAME to command list LIST (the list for set    or some sublist thereof).    CLASS is as in add_cmd.    VAR_TYPE is the kind of thing we are setting.    VAR is address of the variable being controlled by this command.    DOC is the documentation string.  */
end_comment

begin_function
name|struct
name|cmd_list_element
modifier|*
name|add_set_cmd
parameter_list|(
name|name
parameter_list|,
name|class
parameter_list|,
name|var_type
parameter_list|,
name|var
parameter_list|,
name|doc
parameter_list|,
name|list
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|enum
name|command_class
name|class
decl_stmt|;
name|var_types
name|var_type
decl_stmt|;
name|char
modifier|*
name|var
decl_stmt|;
name|char
modifier|*
name|doc
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|list
decl_stmt|;
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
init|=
name|add_cmd
argument_list|(
name|name
argument_list|,
name|class
argument_list|,
name|NO_FUNCTION
argument_list|,
name|doc
argument_list|,
name|list
argument_list|)
decl_stmt|;
name|c
operator|->
name|type
operator|=
name|set_cmd
expr_stmt|;
name|c
operator|->
name|var_type
operator|=
name|var_type
expr_stmt|;
name|c
operator|->
name|var
operator|=
name|var
expr_stmt|;
comment|/* This needs to be something besides NO_FUNCTION so that this isn't      treated as a help class.  */
name|c
operator|->
name|function
operator|.
name|sfunc
operator|=
name|empty_sfunc
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* Add element named NAME to command list LIST (the list for set    or some sublist thereof).    CLASS is as in add_cmd.    ENUMLIST is a list of strings which may follow NAME.    VAR is address of the variable which will contain the matching string      (from ENUMLIST).    DOC is the documentation string.  */
end_comment

begin_function
name|struct
name|cmd_list_element
modifier|*
name|add_set_enum_cmd
parameter_list|(
name|name
parameter_list|,
name|class
parameter_list|,
name|enumlist
parameter_list|,
name|var
parameter_list|,
name|doc
parameter_list|,
name|list
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|enum
name|command_class
name|class
decl_stmt|;
name|char
modifier|*
name|enumlist
index|[]
decl_stmt|;
name|char
modifier|*
name|var
decl_stmt|;
name|char
modifier|*
name|doc
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|list
decl_stmt|;
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
init|=
name|add_set_cmd
argument_list|(
name|name
argument_list|,
name|class
argument_list|,
name|var_enum
argument_list|,
name|var
argument_list|,
name|doc
argument_list|,
name|list
argument_list|)
decl_stmt|;
name|c
operator|->
name|enums
operator|=
name|enumlist
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_comment
comment|/* Where SETCMD has already been added, add the corresponding show    command to LIST and return a pointer to the added command (not     necessarily the head of LIST).  */
end_comment

begin_function
name|struct
name|cmd_list_element
modifier|*
name|add_show_from_set
parameter_list|(
name|setcmd
parameter_list|,
name|list
parameter_list|)
name|struct
name|cmd_list_element
modifier|*
name|setcmd
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|list
decl_stmt|;
block|{
name|struct
name|cmd_list_element
modifier|*
name|showcmd
init|=
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cmd_list_element
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|p
decl_stmt|;
name|memcpy
argument_list|(
name|showcmd
argument_list|,
name|setcmd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cmd_list_element
argument_list|)
argument_list|)
expr_stmt|;
name|delete_cmd
argument_list|(
name|showcmd
operator|->
name|name
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|showcmd
operator|->
name|type
operator|=
name|show_cmd
expr_stmt|;
comment|/* Replace "set " at start of docstring with "show ".  */
if|if
condition|(
name|setcmd
operator|->
name|doc
index|[
literal|0
index|]
operator|==
literal|'S'
operator|&&
name|setcmd
operator|->
name|doc
index|[
literal|1
index|]
operator|==
literal|'e'
operator|&&
name|setcmd
operator|->
name|doc
index|[
literal|2
index|]
operator|==
literal|'t'
operator|&&
name|setcmd
operator|->
name|doc
index|[
literal|3
index|]
operator|==
literal|' '
condition|)
name|showcmd
operator|->
name|doc
operator|=
name|concat
argument_list|(
literal|"Show "
argument_list|,
name|setcmd
operator|->
name|doc
operator|+
literal|4
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"GDB internal error: Bad docstring for set command\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|list
operator|==
name|NULL
operator|||
name|STRCMP
argument_list|(
operator|(
operator|*
name|list
operator|)
operator|->
name|name
argument_list|,
name|showcmd
operator|->
name|name
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|showcmd
operator|->
name|next
operator|=
operator|*
name|list
expr_stmt|;
operator|*
name|list
operator|=
name|showcmd
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
operator|*
name|list
expr_stmt|;
while|while
condition|(
name|p
operator|->
name|next
operator|&&
name|STRCMP
argument_list|(
name|p
operator|->
name|next
operator|->
name|name
argument_list|,
name|showcmd
operator|->
name|name
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
name|showcmd
operator|->
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|showcmd
expr_stmt|;
block|}
return|return
name|showcmd
return|;
block|}
end_function

begin_comment
comment|/* Remove the command named NAME from the command list.  */
end_comment

begin_function
name|void
name|delete_cmd
parameter_list|(
name|name
parameter_list|,
name|list
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
modifier|*
name|list
decl_stmt|;
block|{
specifier|register
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|p
decl_stmt|;
while|while
condition|(
operator|*
name|list
operator|&&
name|STREQ
argument_list|(
operator|(
operator|*
name|list
operator|)
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|list
operator|)
operator|->
name|hookee
condition|)
operator|(
operator|*
name|list
operator|)
operator|->
name|hookee
operator|->
name|hook
operator|=
literal|0
expr_stmt|;
comment|/* Hook slips out of its mouth */
name|p
operator|=
operator|(
operator|*
name|list
operator|)
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
operator|*
name|list
argument_list|)
expr_stmt|;
operator|*
name|list
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|list
condition|)
for|for
control|(
name|c
operator|=
operator|*
name|list
init|;
name|c
operator|->
name|next
condition|;
control|)
block|{
if|if
condition|(
name|STREQ
argument_list|(
name|c
operator|->
name|next
operator|->
name|name
argument_list|,
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|next
operator|->
name|hookee
condition|)
name|c
operator|->
name|next
operator|->
name|hookee
operator|->
name|hook
operator|=
literal|0
expr_stmt|;
comment|/* hooked cmd gets away.  */
name|p
operator|=
name|c
operator|->
name|next
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|c
operator|->
name|next
argument_list|)
expr_stmt|;
name|c
operator|->
name|next
operator|=
name|p
expr_stmt|;
block|}
else|else
name|c
operator|=
name|c
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This command really has to deal with two things:  *     1) I want documentation on *this string* (usually called by  * "help commandname").  *     2) I want documentation on *this list* (usually called by  * giving a command that requires subcommands.  Also called by saying  * just "help".)  *  *   I am going to split this into two seperate comamnds, help_cmd and  * help_list.   */
end_comment

begin_function
name|void
name|help_cmd
parameter_list|(
name|command
parameter_list|,
name|stream
parameter_list|)
name|char
modifier|*
name|command
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|cmdlist
decl_stmt|;
if|if
condition|(
operator|!
name|command
condition|)
block|{
name|help_list
argument_list|(
name|cmdlist
argument_list|,
literal|""
argument_list|,
name|all_classes
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
block|}
name|c
operator|=
name|lookup_cmd
argument_list|(
operator|&
name|command
argument_list|,
name|cmdlist
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return;
comment|/* There are three cases here.      If c->prefixlist is nonzero, we have a prefix command.      Print its documentation, then list its subcommands.            If c->function is nonzero, we really have a command.      Print its documentation and return.            If c->function is zero, we have a class name.      Print its documentation (as if it were a command)      and then set class to the number of this class      so that the commands in the class will be listed.  */
name|fputs_filtered
argument_list|(
name|c
operator|->
name|doc
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|prefixlist
operator|==
literal|0
operator|&&
name|c
operator|->
name|function
operator|.
name|cfunc
operator|!=
name|NULL
condition|)
return|return;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* If this is a prefix command, print it's subcommands */
if|if
condition|(
name|c
operator|->
name|prefixlist
condition|)
name|help_list
argument_list|(
operator|*
name|c
operator|->
name|prefixlist
argument_list|,
name|c
operator|->
name|prefixname
argument_list|,
name|all_commands
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* If this is a class name, print all of the commands in the class */
if|if
condition|(
name|c
operator|->
name|function
operator|.
name|cfunc
operator|==
name|NULL
condition|)
name|help_list
argument_list|(
name|cmdlist
argument_list|,
literal|""
argument_list|,
name|c
operator|->
name|class
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|hook
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\nThis command has a hook defined: %s\n"
argument_list|,
name|c
operator|->
name|hook
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get a specific kind of help on a command list.  *  * LIST is the list.  * CMDTYPE is the prefix to use in the title string.  * CLASS is the class with which to list the nodes of this list (see  * documentation for help_cmd_list below),  As usual, ALL_COMMANDS for  * everything, ALL_CLASSES for just classes, and non-negative for only things  * in a specific class.  * and STREAM is the output stream on which to print things.  * If you call this routine with a class>= 0, it recurses.  */
end_comment

begin_function
name|void
name|help_list
parameter_list|(
name|list
parameter_list|,
name|cmdtype
parameter_list|,
name|class
parameter_list|,
name|stream
parameter_list|)
name|struct
name|cmd_list_element
modifier|*
name|list
decl_stmt|;
name|char
modifier|*
name|cmdtype
decl_stmt|;
name|enum
name|command_class
name|class
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|cmdtype1
decl_stmt|,
modifier|*
name|cmdtype2
decl_stmt|;
comment|/* If CMDTYPE is "foo ", CMDTYPE1 gets " foo" and CMDTYPE2 gets "foo sub"  */
name|len
operator|=
name|strlen
argument_list|(
name|cmdtype
argument_list|)
expr_stmt|;
name|cmdtype1
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|cmdtype1
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|cmdtype2
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|4
argument_list|)
expr_stmt|;
name|cmdtype2
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
condition|)
block|{
name|cmdtype1
index|[
literal|0
index|]
operator|=
literal|' '
expr_stmt|;
name|strncpy
argument_list|(
name|cmdtype1
operator|+
literal|1
argument_list|,
name|cmdtype
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cmdtype1
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|strncpy
argument_list|(
name|cmdtype2
argument_list|,
name|cmdtype
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cmdtype2
operator|+
name|len
operator|-
literal|1
argument_list|,
literal|" sub"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|class
operator|==
name|all_classes
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"List of classes of %scommands:\n\n"
argument_list|,
name|cmdtype2
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"List of %scommands:\n\n"
argument_list|,
name|cmdtype2
argument_list|)
expr_stmt|;
name|help_cmd_list
argument_list|(
name|list
argument_list|,
name|class
argument_list|,
name|cmdtype
argument_list|,
operator|(
name|int
operator|)
name|class
operator|>=
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|all_classes
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n\ Type \"help%s\" followed by a class name for a list of commands in that class."
argument_list|,
name|cmdtype1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n\ Type \"help%s\" followed by %scommand name for full documentation.\n\ Command name abbreviations are allowed if unambiguous.\n"
argument_list|,
name|cmdtype1
argument_list|,
name|cmdtype2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print only the first line of STR on STREAM.  */
end_comment

begin_function
specifier|static
name|void
name|print_doc_line
parameter_list|(
name|stream
parameter_list|,
name|str
parameter_list|)
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|line_buffer
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|line_size
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|line_buffer
condition|)
block|{
name|line_size
operator|=
literal|80
expr_stmt|;
name|line_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|line_size
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|str
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
operator|&&
operator|*
name|p
operator|!=
literal|'.'
operator|&&
operator|*
name|p
operator|!=
literal|','
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|-
name|str
operator|>
name|line_size
operator|-
literal|1
condition|)
block|{
name|line_size
operator|=
name|p
operator|-
name|str
operator|+
literal|1
expr_stmt|;
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|line_buffer
argument_list|)
expr_stmt|;
name|line_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|line_size
argument_list|)
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|line_buffer
argument_list|,
name|str
argument_list|,
name|p
operator|-
name|str
argument_list|)
expr_stmt|;
name|line_buffer
index|[
name|p
operator|-
name|str
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|islower
argument_list|(
name|line_buffer
index|[
literal|0
index|]
argument_list|)
condition|)
name|line_buffer
index|[
literal|0
index|]
operator|=
name|toupper
argument_list|(
name|line_buffer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|line_buffer
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Implement a help command on command list LIST.  * RECURSE should be non-zero if this should be done recursively on  * all sublists of LIST.  * PREFIX is the prefix to print before each command name.  * STREAM is the stream upon which the output should be written.  * CLASS should be:  *	A non-negative class number to list only commands in that  * class.  *	ALL_COMMANDS to list all commands in list.  *	ALL_CLASSES  to list all classes in list.  *  *   Note that RECURSE will be active on *all* sublists, not just the  * ones selected by the criteria above (ie. the selection mechanism  * is at the low level, not the high-level).  */
end_comment

begin_function
name|void
name|help_cmd_list
parameter_list|(
name|list
parameter_list|,
name|class
parameter_list|,
name|prefix
parameter_list|,
name|recurse
parameter_list|,
name|stream
parameter_list|)
name|struct
name|cmd_list_element
modifier|*
name|list
decl_stmt|;
name|enum
name|command_class
name|class
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
name|int
name|recurse
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
specifier|register
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|list
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c
operator|->
name|abbrev_flag
operator|==
literal|0
operator|&&
operator|(
name|class
operator|==
name|all_commands
operator|||
operator|(
name|class
operator|==
name|all_classes
operator|&&
name|c
operator|->
name|function
operator|.
name|cfunc
operator|==
name|NULL
operator|)
operator|||
operator|(
name|class
operator|==
name|c
operator|->
name|class
operator|&&
name|c
operator|->
name|function
operator|.
name|cfunc
operator|!=
name|NULL
operator|)
operator|)
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s%s -- "
argument_list|,
name|prefix
argument_list|,
name|c
operator|->
name|name
argument_list|)
expr_stmt|;
name|print_doc_line
argument_list|(
name|stream
argument_list|,
name|c
operator|->
name|doc
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|recurse
operator|&&
name|c
operator|->
name|prefixlist
operator|!=
literal|0
operator|&&
name|c
operator|->
name|abbrev_flag
operator|==
literal|0
condition|)
name|help_cmd_list
argument_list|(
operator|*
name|c
operator|->
name|prefixlist
argument_list|,
name|class
argument_list|,
name|c
operator|->
name|prefixname
argument_list|,
literal|1
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Search the input clist for 'command'.  Return the command if    found (or NULL if not), and return the number of commands    found in nfound */
end_comment

begin_function
specifier|static
name|struct
name|cmd_list_element
modifier|*
name|find_cmd
parameter_list|(
name|command
parameter_list|,
name|len
parameter_list|,
name|clist
parameter_list|,
name|ignore_help_classes
parameter_list|,
name|nfound
parameter_list|)
name|char
modifier|*
name|command
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|clist
decl_stmt|;
name|int
name|ignore_help_classes
decl_stmt|;
name|int
modifier|*
name|nfound
decl_stmt|;
block|{
name|struct
name|cmd_list_element
modifier|*
name|found
decl_stmt|,
modifier|*
name|c
decl_stmt|;
name|found
operator|=
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|)
name|NULL
expr_stmt|;
operator|*
name|nfound
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
name|clist
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|command
argument_list|,
name|c
operator|->
name|name
argument_list|,
name|len
argument_list|)
operator|&&
operator|(
operator|!
name|ignore_help_classes
operator|||
name|c
operator|->
name|function
operator|.
name|cfunc
operator|)
condition|)
block|{
name|found
operator|=
name|c
expr_stmt|;
operator|(
operator|*
name|nfound
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|name
index|[
name|len
index|]
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|nfound
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
return|return
name|found
return|;
block|}
end_function

begin_comment
comment|/* This routine takes a line of TEXT and a CLIST in which to start the    lookup.  When it returns it will have incremented the text pointer past    the section of text it matched, set *RESULT_LIST to point to the list in    which the last word was matched, and will return a pointer to the cmd    list element which the text matches.  It will return NULL if no match at    all was possible.  It will return -1 (cast appropriately, ick) if ambigous    matches are possible; in this case *RESULT_LIST will be set to point to    the list in which there are ambiguous choices (and *TEXT will be set to    the ambiguous text string).     If the located command was an abbreviation, this routine returns the base    command of the abbreviation.     It does no error reporting whatsoever; control will always return    to the superior routine.     In the case of an ambiguous return (-1), *RESULT_LIST will be set to point    at the prefix_command (ie. the best match) *or* (special case) will be NULL    if no prefix command was ever found.  For example, in the case of "info a",    "info" matches without ambiguity, but "a" could be "args" or "address", so    *RESULT_LIST is set to the cmd_list_element for "info".  So in this case    RESULT_LIST should not be interpeted as a pointer to the beginning of a    list; it simply points to a specific command.  In the case of an ambiguous    return *TEXT is advanced past the last non-ambiguous prefix (e.g.    "info t" can be "info types" or "info target"; upon return *TEXT has been    advanced past "info ").     If RESULT_LIST is NULL, don't set *RESULT_LIST (but don't otherwise    affect the operation).     This routine does *not* modify the text pointed to by TEXT.        If IGNORE_HELP_CLASSES is nonzero, ignore any command list elements which    are actually help classes rather than commands (i.e. the function field of    the struct cmd_list_element is NULL).  */
end_comment

begin_function
name|struct
name|cmd_list_element
modifier|*
name|lookup_cmd_1
parameter_list|(
name|text
parameter_list|,
name|clist
parameter_list|,
name|result_list
parameter_list|,
name|ignore_help_classes
parameter_list|)
name|char
modifier|*
modifier|*
name|text
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|clist
decl_stmt|,
decl|*
modifier|*
name|result_list
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|ignore_help_classes
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|command
decl_stmt|;
name|int
name|len
decl_stmt|,
name|tmp
decl_stmt|,
name|nfound
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|found
decl_stmt|,
modifier|*
name|c
decl_stmt|;
while|while
condition|(
operator|*
operator|*
name|text
operator|==
literal|' '
operator|||
operator|*
operator|*
name|text
operator|==
literal|'\t'
condition|)
operator|(
operator|*
name|text
operator|)
operator|++
expr_stmt|;
comment|/* Treating underscores as part of command words is important      so that "set args_foo()" doesn't get interpreted as      "set args _foo()".  */
for|for
control|(
name|p
operator|=
operator|*
name|text
init|;
operator|*
name|p
operator|&&
operator|(
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'-'
operator|||
operator|*
name|p
operator|==
literal|'_'
operator|||
operator|(
name|tui_version
operator|&&
operator|(
operator|*
name|p
operator|==
literal|'+'
operator|||
operator|*
name|p
operator|==
literal|'<'
operator|||
operator|*
name|p
operator|==
literal|'>'
operator|||
operator|*
name|p
operator|==
literal|'$'
operator|)
operator|)
operator|||
operator|(
name|xdb_commands
operator|&&
operator|(
operator|*
name|p
operator|==
literal|'!'
operator|||
operator|*
name|p
operator|==
literal|'/'
operator|||
operator|*
name|p
operator|==
literal|'?'
operator|)
operator|)
operator|)
condition|;
name|p
operator|++
control|)
empty_stmt|;
comment|/* If nothing but whitespace, return 0.  */
if|if
condition|(
name|p
operator|==
operator|*
name|text
condition|)
return|return
literal|0
return|;
name|len
operator|=
name|p
operator|-
operator|*
name|text
expr_stmt|;
comment|/* *text and p now bracket the first command word to lookup (and      it's length is len).  We copy this into a local temporary */
name|command
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|tmp
operator|=
literal|0
init|;
name|tmp
operator|<
name|len
condition|;
name|tmp
operator|++
control|)
block|{
name|char
name|x
init|=
operator|(
operator|*
name|text
operator|)
index|[
name|tmp
index|]
decl_stmt|;
name|command
index|[
name|tmp
index|]
operator|=
name|x
expr_stmt|;
block|}
name|command
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Look it up.  */
name|found
operator|=
literal|0
expr_stmt|;
name|nfound
operator|=
literal|0
expr_stmt|;
name|found
operator|=
name|find_cmd
argument_list|(
name|command
argument_list|,
name|len
argument_list|,
name|clist
argument_list|,
name|ignore_help_classes
argument_list|,
operator|&
name|nfound
argument_list|)
expr_stmt|;
comment|/*    ** We didn't find the command in the entered case, so lower case it   ** and search again.   */
if|if
condition|(
operator|!
name|found
operator|||
name|nfound
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|tmp
operator|=
literal|0
init|;
name|tmp
operator|<
name|len
condition|;
name|tmp
operator|++
control|)
block|{
name|char
name|x
init|=
name|command
index|[
name|tmp
index|]
decl_stmt|;
name|command
index|[
name|tmp
index|]
operator|=
name|isupper
argument_list|(
name|x
argument_list|)
condition|?
name|tolower
argument_list|(
name|x
argument_list|)
else|:
name|x
expr_stmt|;
block|}
name|found
operator|=
name|find_cmd
argument_list|(
name|command
argument_list|,
name|len
argument_list|,
name|clist
argument_list|,
name|ignore_help_classes
argument_list|,
operator|&
name|nfound
argument_list|)
expr_stmt|;
block|}
comment|/* If nothing matches, we have a simple failure.  */
if|if
condition|(
name|nfound
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|nfound
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|result_list
operator|!=
name|NULL
condition|)
comment|/* Will be modified in calling routine 	   if we know what the prefix command is.  */
operator|*
name|result_list
operator|=
literal|0
expr_stmt|;
return|return
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|)
operator|-
literal|1
return|;
comment|/* Ambiguous.  */
block|}
comment|/* We've matched something on this list.  Move text pointer forward. */
operator|*
name|text
operator|=
name|p
expr_stmt|;
comment|/* If this was an abbreviation, use the base command instead.  */
if|if
condition|(
name|found
operator|->
name|cmd_pointer
condition|)
name|found
operator|=
name|found
operator|->
name|cmd_pointer
expr_stmt|;
comment|/* If we found a prefix command, keep looking.  */
if|if
condition|(
name|found
operator|->
name|prefixlist
condition|)
block|{
name|c
operator|=
name|lookup_cmd_1
argument_list|(
name|text
argument_list|,
operator|*
name|found
operator|->
name|prefixlist
argument_list|,
name|result_list
argument_list|,
name|ignore_help_classes
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|c
condition|)
block|{
comment|/* Didn't find anything; this is as far as we got.  */
if|if
condition|(
name|result_list
operator|!=
name|NULL
condition|)
operator|*
name|result_list
operator|=
name|clist
expr_stmt|;
return|return
name|found
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* We've gotten this far properly, but the next step 	     is ambiguous.  We need to set the result list to the best 	     we've found (if an inferior hasn't already set it).  */
if|if
condition|(
name|result_list
operator|!=
name|NULL
condition|)
if|if
condition|(
operator|!
operator|*
name|result_list
condition|)
comment|/* This used to say *result_list = *found->prefixlist 		 If that was correct, need to modify the documentation 		 at the top of this function to clarify what is supposed 		 to be going on.  */
operator|*
name|result_list
operator|=
name|found
expr_stmt|;
return|return
name|c
return|;
block|}
else|else
block|{
comment|/* We matched!  */
return|return
name|c
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|result_list
operator|!=
name|NULL
condition|)
operator|*
name|result_list
operator|=
name|clist
expr_stmt|;
return|return
name|found
return|;
block|}
block|}
end_block

begin_comment
comment|/* All this hair to move the space to the front of cmdtype */
end_comment

begin_function
specifier|static
name|void
name|undef_cmd_error
parameter_list|(
name|cmdtype
parameter_list|,
name|q
parameter_list|)
name|char
modifier|*
name|cmdtype
decl_stmt|,
decl|*
name|q
decl_stmt|;
end_function

begin_block
block|{
name|error
argument_list|(
literal|"Undefined %scommand: \"%s\".  Try \"help%s%.*s\"."
argument_list|,
name|cmdtype
argument_list|,
name|q
argument_list|,
operator|*
name|cmdtype
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|strlen
argument_list|(
name|cmdtype
argument_list|)
operator|-
literal|1
argument_list|,
name|cmdtype
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Look up the contents of *LINE as a command in the command list LIST.    LIST is a chain of struct cmd_list_element's.    If it is found, return the struct cmd_list_element for that command    and update *LINE to point after the command name, at the first argument.    If not found, call error if ALLOW_UNKNOWN is zero    otherwise (or if error returns) return zero.    Call error if specified command is ambiguous,    unless ALLOW_UNKNOWN is negative.    CMDTYPE precedes the word "command" in the error message.     If INGNORE_HELP_CLASSES is nonzero, ignore any command list    elements which are actually help classes rather than commands (i.e.    the function field of the struct cmd_list_element is 0).  */
end_comment

begin_function
name|struct
name|cmd_list_element
modifier|*
name|lookup_cmd
parameter_list|(
name|line
parameter_list|,
name|list
parameter_list|,
name|cmdtype
parameter_list|,
name|allow_unknown
parameter_list|,
name|ignore_help_classes
parameter_list|)
name|char
modifier|*
modifier|*
name|line
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|list
decl_stmt|;
name|char
modifier|*
name|cmdtype
decl_stmt|;
name|int
name|allow_unknown
decl_stmt|;
name|int
name|ignore_help_classes
decl_stmt|;
block|{
name|struct
name|cmd_list_element
modifier|*
name|last_list
init|=
literal|0
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|c
init|=
name|lookup_cmd_1
argument_list|(
name|line
argument_list|,
name|list
argument_list|,
operator|&
name|last_list
argument_list|,
name|ignore_help_classes
argument_list|)
decl_stmt|;
if|#
directive|if
literal|0
comment|/* This is wrong for complete_command.  */
block|char *ptr = (*line) + strlen (*line) - 1;
comment|/* Clear off trailing whitespace.  */
block|while (ptr>= *line&& (*ptr == ' ' || *ptr == '\t'))     ptr--;   *(ptr + 1) = '\0';
endif|#
directive|endif
if|if
condition|(
operator|!
name|c
condition|)
block|{
if|if
condition|(
operator|!
name|allow_unknown
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|line
condition|)
name|error
argument_list|(
literal|"Lack of needed %scommand"
argument_list|,
name|cmdtype
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|line
decl_stmt|,
modifier|*
name|q
decl_stmt|;
while|while
condition|(
name|isalnum
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'-'
condition|)
name|p
operator|++
expr_stmt|;
name|q
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
operator|*
name|line
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|q
argument_list|,
operator|*
name|line
argument_list|,
name|p
operator|-
operator|*
name|line
argument_list|)
expr_stmt|;
name|q
index|[
name|p
operator|-
operator|*
name|line
index|]
operator|=
literal|'\0'
expr_stmt|;
name|undef_cmd_error
argument_list|(
name|cmdtype
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
block|}
else|else
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
operator|(
expr|struct
name|cmd_list_element
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* Ambigous.  Local values should be off prefixlist or called 	 values.  */
name|int
name|local_allow_unknown
init|=
operator|(
name|last_list
condition|?
name|last_list
operator|->
name|allow_unknown
else|:
name|allow_unknown
operator|)
decl_stmt|;
name|char
modifier|*
name|local_cmdtype
init|=
name|last_list
condition|?
name|last_list
operator|->
name|prefixname
else|:
name|cmdtype
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|local_list
init|=
operator|(
name|last_list
condition|?
operator|*
operator|(
name|last_list
operator|->
name|prefixlist
operator|)
else|:
name|list
operator|)
decl_stmt|;
if|if
condition|(
name|local_allow_unknown
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|last_list
condition|)
return|return
name|last_list
return|;
comment|/* Found something.  */
else|else
return|return
literal|0
return|;
comment|/* Found nothing.  */
block|}
else|else
block|{
comment|/* Report as error.  */
name|int
name|amb_len
decl_stmt|;
name|char
name|ambbuf
index|[
literal|100
index|]
decl_stmt|;
for|for
control|(
name|amb_len
operator|=
literal|0
init|;
operator|(
operator|(
operator|*
name|line
operator|)
index|[
name|amb_len
index|]
operator|&&
operator|(
operator|*
name|line
operator|)
index|[
name|amb_len
index|]
operator|!=
literal|' '
operator|&&
operator|(
operator|*
name|line
operator|)
index|[
name|amb_len
index|]
operator|!=
literal|'\t'
operator|)
condition|;
name|amb_len
operator|++
control|)
empty_stmt|;
name|ambbuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
name|local_list
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
operator|*
name|line
argument_list|,
name|c
operator|->
name|name
argument_list|,
name|amb_len
argument_list|)
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|ambbuf
argument_list|)
operator|+
name|strlen
argument_list|(
name|c
operator|->
name|name
argument_list|)
operator|+
literal|6
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
name|ambbuf
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|ambbuf
argument_list|)
condition|)
name|strcat
argument_list|(
name|ambbuf
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|ambbuf
argument_list|,
name|c
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strcat
argument_list|(
name|ambbuf
argument_list|,
literal|".."
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|error
argument_list|(
literal|"Ambiguous %scommand \"%s\": %s."
argument_list|,
name|local_cmdtype
argument_list|,
operator|*
name|line
argument_list|,
name|ambbuf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* lint */
block|}
block|}
else|else
block|{
comment|/* We've got something.  It may still not be what the caller          wants (if this command *needs* a subcommand).  */
while|while
condition|(
operator|*
operator|*
name|line
operator|==
literal|' '
operator|||
operator|*
operator|*
name|line
operator|==
literal|'\t'
condition|)
operator|(
operator|*
name|line
operator|)
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|prefixlist
operator|&&
operator|*
operator|*
name|line
operator|&&
operator|!
name|c
operator|->
name|allow_unknown
condition|)
name|undef_cmd_error
argument_list|(
name|c
operator|->
name|prefixname
argument_list|,
operator|*
name|line
argument_list|)
expr_stmt|;
comment|/* Seems to be what he wants.  Return it.  */
return|return
name|c
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Look up the contents of *LINE as a command in the command list LIST.    LIST is a chain of struct cmd_list_element's.    If it is found, return the struct cmd_list_element for that command    and update *LINE to point after the command name, at the first argument.    If not found, call error if ALLOW_UNKNOWN is zero    otherwise (or if error returns) return zero.    Call error if specified command is ambiguous,    unless ALLOW_UNKNOWN is negative.    CMDTYPE precedes the word "command" in the error message.  */
end_comment

begin_comment
unit|struct cmd_list_element * lookup_cmd (line, list, cmdtype, allow_unknown)      char **line;      struct cmd_list_element *list;      char *cmdtype;      int allow_unknown; {   register char *p;   register struct cmd_list_element *c, *found;   int nfound;   char ambbuf[100];   char *processed_cmd;   int i, cmd_len;
comment|/* Skip leading whitespace.  */
end_comment

begin_comment
unit|while (**line == ' ' || **line == '\t')     (*line)++;
comment|/* Clear out trailing whitespace.  */
end_comment

begin_comment
unit|p = *line + strlen (*line);   while (p != *line&& (p[-1] == ' ' || p[-1] == '\t'))     p--;   *p = 0;
comment|/* Find end of command name.  */
end_comment

begin_comment
unit|p = *line;   while (*p == '-' || isalnum(*p))     p++;
comment|/* Look up the command name.      If exact match, keep that.      Otherwise, take command abbreviated, if unique.  Note that (in my      opinion) a null string does *not* indicate ambiguity; simply the      end of the argument.  */
end_comment

begin_comment
unit|if (p == *line)     {       if (!allow_unknown) 	error ("Lack of needed %scommand", cmdtype);       return 0;     }
comment|/* Copy over to a local buffer, converting to lowercase on the way.      This is in case the command being parsed is a subcommand which      doesn't match anything, and that's ok.  We want the original      untouched for the routine of the original command.  */
end_comment

begin_comment
unit|processed_cmd = (char *) alloca (p - *line + 1);   for (cmd_len = 0; cmd_len< p - *line; cmd_len++)     {       char x = (*line)[cmd_len];       if (isupper(x)) 	processed_cmd[cmd_len] = tolower(x);       else 	processed_cmd[cmd_len] = x;     }   processed_cmd[cmd_len] = '\0';
comment|/* Check all possibilities in the current command list.  */
end_comment

begin_comment
unit|found = 0;   nfound = 0;   for (c = list; c; c = c->next)     {       if (!strncmp (processed_cmd, c->name, cmd_len)) 	{ 	  found = c; 	  nfound++; 	  if (c->name[cmd_len] == 0) 	    { 	      nfound = 1; 	      break; 	    } 	}     }
comment|/* Report error for undefined command name.  */
end_comment

begin_comment
unit|if (nfound != 1)     {       if (nfound> 1&& allow_unknown>= 0) 	{ 	  ambbuf[0] = 0; 	  for (c = list; c; c = c->next) 	    if (!strncmp (processed_cmd, c->name, cmd_len)) 	      { 		if (strlen (ambbuf) + strlen (c->name) + 6< sizeof ambbuf) 		  { 		    if (strlen (ambbuf)) 		      strcat (ambbuf, ", "); 		    strcat (ambbuf, c->name); 		  } 		else 		  { 		    strcat (ambbuf, ".."); 		    break; 		  } 	      } 	  error ("Ambiguous %scommand \"%s\": %s.", cmdtype, 		 processed_cmd, ambbuf); 	}       else if (!allow_unknown) 	error ("Undefined %scommand: \"%s\".", cmdtype, processed_cmd);       return 0;     }
comment|/* Skip whitespace before the argument.  */
end_comment

begin_endif
unit|while (*p == ' ' || *p == '\t') p++;   *line = p;    if (found->prefixlist&& *p)     {       c = lookup_cmd (line, *found->prefixlist, found->prefixname, 		      found->allow_unknown);       if (c) 	return c;     }    return found; }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Helper function for SYMBOL_COMPLETION_FUNCTION.  */
end_comment

begin_comment
comment|/* Return a vector of char pointers which point to the different    possible completions in LIST of TEXT.       WORD points in the same buffer as TEXT, and completions should be    returned relative to this position.  For example, suppose TEXT is "foo"    and we want to complete to "foobar".  If WORD is "oo", return    "oobar"; if WORD is "baz/foo", return "baz/foobar".  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|complete_on_cmdlist
parameter_list|(
name|list
parameter_list|,
name|text
parameter_list|,
name|word
parameter_list|)
name|struct
name|cmd_list_element
modifier|*
name|list
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
name|char
modifier|*
name|word
decl_stmt|;
block|{
name|struct
name|cmd_list_element
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
modifier|*
name|matchlist
decl_stmt|;
name|int
name|sizeof_matchlist
decl_stmt|;
name|int
name|matches
decl_stmt|;
name|int
name|textlen
init|=
name|strlen
argument_list|(
name|text
argument_list|)
decl_stmt|;
name|sizeof_matchlist
operator|=
literal|10
expr_stmt|;
name|matchlist
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|sizeof_matchlist
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|matches
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|list
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|ptr
operator|->
name|name
argument_list|,
name|text
argument_list|,
name|textlen
argument_list|)
operator|&&
operator|!
name|ptr
operator|->
name|abbrev_flag
operator|&&
operator|(
name|ptr
operator|->
name|function
operator|.
name|cfunc
operator|||
name|ptr
operator|->
name|prefixlist
operator|)
condition|)
block|{
if|if
condition|(
name|matches
operator|==
name|sizeof_matchlist
condition|)
block|{
name|sizeof_matchlist
operator|*=
literal|2
expr_stmt|;
name|matchlist
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|matchlist
argument_list|,
operator|(
name|sizeof_matchlist
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|matchlist
index|[
name|matches
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|word
argument_list|)
operator|+
name|strlen
argument_list|(
name|ptr
operator|->
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|word
operator|==
name|text
condition|)
name|strcpy
argument_list|(
name|matchlist
index|[
name|matches
index|]
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|word
operator|>
name|text
condition|)
block|{
comment|/* Return some portion of ptr->name.  */
name|strcpy
argument_list|(
name|matchlist
index|[
name|matches
index|]
argument_list|,
name|ptr
operator|->
name|name
operator|+
operator|(
name|word
operator|-
name|text
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Return some of text plus ptr->name.  */
name|strncpy
argument_list|(
name|matchlist
index|[
name|matches
index|]
argument_list|,
name|word
argument_list|,
name|text
operator|-
name|word
argument_list|)
expr_stmt|;
name|matchlist
index|[
name|matches
index|]
index|[
name|text
operator|-
name|word
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|matchlist
index|[
name|matches
index|]
argument_list|,
name|ptr
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
operator|++
name|matches
expr_stmt|;
block|}
if|if
condition|(
name|matches
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|matchlist
argument_list|)
expr_stmt|;
name|matchlist
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|matchlist
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|matchlist
argument_list|,
operator|(
operator|(
name|matches
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|matchlist
index|[
name|matches
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
return|return
name|matchlist
return|;
block|}
end_function

begin_comment
comment|/* Helper function for SYMBOL_COMPLETION_FUNCTION.  */
end_comment

begin_comment
comment|/* Return a vector of char pointers which point to the different    possible completions in CMD of TEXT.       WORD points in the same buffer as TEXT, and completions should be    returned relative to this position.  For example, suppose TEXT is "foo"    and we want to complete to "foobar".  If WORD is "oo", return    "oobar"; if WORD is "baz/foo", return "baz/foobar".  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|complete_on_enum
parameter_list|(
name|enumlist
parameter_list|,
name|text
parameter_list|,
name|word
parameter_list|)
name|char
modifier|*
modifier|*
name|enumlist
decl_stmt|;
name|char
modifier|*
name|text
decl_stmt|;
name|char
modifier|*
name|word
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|matchlist
decl_stmt|;
name|int
name|sizeof_matchlist
decl_stmt|;
name|int
name|matches
decl_stmt|;
name|int
name|textlen
init|=
name|strlen
argument_list|(
name|text
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|sizeof_matchlist
operator|=
literal|10
expr_stmt|;
name|matchlist
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|sizeof_matchlist
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|matches
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|name
operator|=
name|enumlist
index|[
name|i
index|]
operator|)
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|text
argument_list|,
name|textlen
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|matches
operator|==
name|sizeof_matchlist
condition|)
block|{
name|sizeof_matchlist
operator|*=
literal|2
expr_stmt|;
name|matchlist
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|matchlist
argument_list|,
operator|(
name|sizeof_matchlist
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|matchlist
index|[
name|matches
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|word
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|word
operator|==
name|text
condition|)
name|strcpy
argument_list|(
name|matchlist
index|[
name|matches
index|]
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|word
operator|>
name|text
condition|)
block|{
comment|/* Return some portion of name.  */
name|strcpy
argument_list|(
name|matchlist
index|[
name|matches
index|]
argument_list|,
name|name
operator|+
operator|(
name|word
operator|-
name|text
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Return some of text plus name.  */
name|strncpy
argument_list|(
name|matchlist
index|[
name|matches
index|]
argument_list|,
name|word
argument_list|,
name|text
operator|-
name|word
argument_list|)
expr_stmt|;
name|matchlist
index|[
name|matches
index|]
index|[
name|text
operator|-
name|word
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|matchlist
index|[
name|matches
index|]
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
operator|++
name|matches
expr_stmt|;
block|}
if|if
condition|(
name|matches
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
operator|(
name|PTR
operator|)
name|matchlist
argument_list|)
expr_stmt|;
name|matchlist
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|matchlist
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|matchlist
argument_list|,
operator|(
operator|(
name|matches
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|matchlist
index|[
name|matches
index|]
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
return|return
name|matchlist
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_binary_operation
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|int
name|length
decl_stmt|;
if|if
condition|(
operator|!
name|arg
operator|||
operator|!
operator|*
name|arg
condition|)
return|return
literal|1
return|;
name|length
operator|=
name|strlen
argument_list|(
name|arg
argument_list|)
expr_stmt|;
while|while
condition|(
name|arg
index|[
name|length
operator|-
literal|1
index|]
operator|==
literal|' '
operator|||
name|arg
index|[
name|length
operator|-
literal|1
index|]
operator|==
literal|'\t'
condition|)
name|length
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"on"
argument_list|,
name|length
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"1"
argument_list|,
name|length
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"yes"
argument_list|,
name|length
argument_list|)
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"off"
argument_list|,
name|length
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"0"
argument_list|,
name|length
argument_list|)
operator|||
operator|!
name|strncmp
argument_list|(
name|arg
argument_list|,
literal|"no"
argument_list|,
name|length
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
block|{
name|error
argument_list|(
literal|"\"on\" or \"off\" expected."
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Do a "set" or "show" command.  ARG is NULL if no argument, or the text    of the argument, and FROM_TTY is nonzero if this command is being entered    directly by the user (i.e. these are just like any other    command).  C is the command list element for the command.  */
end_comment

begin_function
name|void
name|do_setshow_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|,
name|c
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
block|{
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|set_cmd
condition|)
block|{
switch|switch
condition|(
name|c
operator|->
name|var_type
condition|)
block|{
case|case
name|var_string
case|:
block|{
name|char
modifier|*
name|new
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|q
decl_stmt|;
name|int
name|ch
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
name|arg
operator|=
literal|""
expr_stmt|;
name|new
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|arg
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|p
operator|=
name|arg
expr_stmt|;
name|q
operator|=
name|new
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|'\000'
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'\\'
condition|)
block|{
comment|/* \ at end of argument is used after spaces 		       so they won't be lost.  */
comment|/* This is obsolete now that we no longer strip 		       trailing whitespace and actually, the backslash 		       didn't get here in my test, readline or 		       something did something funky with a backslash 		       right before a newline.  */
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
break|break;
name|ch
operator|=
name|parse_escape
argument_list|(
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|0
condition|)
break|break;
comment|/* C loses */
elseif|else
if|if
condition|(
name|ch
operator|>
literal|0
condition|)
operator|*
name|q
operator|++
operator|=
name|ch
expr_stmt|;
block|}
else|else
operator|*
name|q
operator|++
operator|=
name|ch
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|if (*(p - 1) != '\\') 	      *q++ = ' ';
endif|#
directive|endif
operator|*
name|q
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|new
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|new
argument_list|,
name|q
operator|-
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
name|c
operator|->
name|var
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
name|c
operator|->
name|var
argument_list|)
expr_stmt|;
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
name|c
operator|->
name|var
operator|=
name|new
expr_stmt|;
block|}
break|break;
case|case
name|var_string_noescape
case|:
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
name|arg
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
name|c
operator|->
name|var
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
name|c
operator|->
name|var
argument_list|)
expr_stmt|;
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
name|c
operator|->
name|var
operator|=
name|savestring
argument_list|(
name|arg
argument_list|,
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|var_filename
case|:
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
name|error_no_arg
argument_list|(
literal|"filename to set it to."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
name|c
operator|->
name|var
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
name|c
operator|->
name|var
argument_list|)
expr_stmt|;
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
name|c
operator|->
name|var
operator|=
name|tilde_expand
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|var_boolean
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|c
operator|->
name|var
operator|=
name|parse_binary_operation
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|var_uinteger
case|:
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
name|error_no_arg
argument_list|(
literal|"integer to set it to."
argument_list|)
expr_stmt|;
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
name|c
operator|->
name|var
operator|=
name|parse_and_eval_address
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
name|c
operator|->
name|var
operator|==
literal|0
condition|)
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
name|c
operator|->
name|var
operator|=
name|UINT_MAX
expr_stmt|;
break|break;
case|case
name|var_integer
case|:
block|{
name|unsigned
name|int
name|val
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
name|error_no_arg
argument_list|(
literal|"integer to set it to."
argument_list|)
expr_stmt|;
name|val
operator|=
name|parse_and_eval_address
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
operator|*
operator|(
name|int
operator|*
operator|)
name|c
operator|->
name|var
operator|=
name|INT_MAX
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|>=
name|INT_MAX
condition|)
name|error
argument_list|(
literal|"integer %u out of range"
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|else
operator|*
operator|(
name|int
operator|*
operator|)
name|c
operator|->
name|var
operator|=
name|val
expr_stmt|;
break|break;
block|}
case|case
name|var_zinteger
case|:
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
name|error_no_arg
argument_list|(
literal|"integer to set it to."
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|c
operator|->
name|var
operator|=
name|parse_and_eval_address
argument_list|(
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|var_enum
case|:
block|{
name|int
name|i
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|nmatches
decl_stmt|;
name|char
modifier|*
name|match
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* if no argument was supplied, print an informative error message */
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
block|{
name|char
name|msg
index|[
literal|1024
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|msg
argument_list|,
literal|"Requires an argument. Valid arguments are "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|c
operator|->
name|enums
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|strcat
argument_list|(
name|msg
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|msg
argument_list|,
name|c
operator|->
name|enums
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|strcat
argument_list|(
name|msg
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|strchr
argument_list|(
name|arg
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|len
operator|=
name|p
operator|-
name|arg
expr_stmt|;
else|else
name|len
operator|=
name|strlen
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|nmatches
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|c
operator|->
name|enums
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|arg
argument_list|,
name|c
operator|->
name|enums
index|[
name|i
index|]
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|match
operator|=
name|c
operator|->
name|enums
index|[
name|i
index|]
expr_stmt|;
name|nmatches
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|nmatches
operator|<=
literal|0
condition|)
name|error
argument_list|(
literal|"Undefined item: \"%s\"."
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmatches
operator|>
literal|1
condition|)
name|error
argument_list|(
literal|"Ambiguous item \"%s\"."
argument_list|,
name|arg
argument_list|)
expr_stmt|;
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
name|c
operator|->
name|var
operator|=
name|match
expr_stmt|;
block|}
break|break;
default|default:
name|error
argument_list|(
literal|"gdb internal error: bad var_type in do_setshow_command"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|type
operator|==
name|show_cmd
condition|)
block|{
comment|/* Print doc minus "show" at start.  */
name|print_doc_line
argument_list|(
name|gdb_stdout
argument_list|,
name|c
operator|->
name|doc
operator|+
literal|5
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" is "
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|wrap_here
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
operator|->
name|var_type
condition|)
block|{
case|case
name|var_string
case|:
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|fputs_filtered
argument_list|(
literal|"\""
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|*
operator|)
name|c
operator|->
name|var
condition|)
for|for
control|(
name|p
operator|=
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|*
operator|)
name|c
operator|->
name|var
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
name|gdb_printchar
argument_list|(
operator|*
name|p
argument_list|,
name|gdb_stdout
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"\""
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|var_string_noescape
case|:
case|case
name|var_filename
case|:
case|case
name|var_enum
case|:
name|fputs_filtered
argument_list|(
literal|"\""
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
name|c
operator|->
name|var
condition|)
name|fputs_filtered
argument_list|(
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
name|c
operator|->
name|var
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"\""
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|var_boolean
case|:
name|fputs_filtered
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|c
operator|->
name|var
condition|?
literal|"on"
else|:
literal|"off"
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|var_uinteger
case|:
if|if
condition|(
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
name|c
operator|->
name|var
operator|==
name|UINT_MAX
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"unlimited"
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* else fall through */
case|case
name|var_zinteger
case|:
name|fprintf_filtered
argument_list|(
name|gdb_stdout
argument_list|,
literal|"%u"
argument_list|,
operator|*
operator|(
name|unsigned
name|int
operator|*
operator|)
name|c
operator|->
name|var
argument_list|)
expr_stmt|;
break|break;
case|case
name|var_integer
case|:
if|if
condition|(
operator|*
operator|(
name|int
operator|*
operator|)
name|c
operator|->
name|var
operator|==
name|INT_MAX
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"unlimited"
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf_filtered
argument_list|(
name|gdb_stdout
argument_list|,
literal|"%d"
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|c
operator|->
name|var
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"gdb internal error: bad var_type in do_setshow_command"
argument_list|)
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
literal|".\n"
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
else|else
name|error
argument_list|(
literal|"gdb internal error: bad cmd_type in do_setshow_command"
argument_list|)
expr_stmt|;
call|(
modifier|*
name|c
operator|->
name|function
operator|.
name|sfunc
call|)
argument_list|(
name|NULL
argument_list|,
name|from_tty
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Show all the settings in a list of show commands.  */
end_comment

begin_function
name|void
name|cmd_show_list
parameter_list|(
name|list
parameter_list|,
name|from_tty
parameter_list|,
name|prefix
parameter_list|)
name|struct
name|cmd_list_element
modifier|*
name|list
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|;
block|{
for|for
control|(
init|;
name|list
operator|!=
name|NULL
condition|;
name|list
operator|=
name|list
operator|->
name|next
control|)
block|{
comment|/* If we find a prefix, run its list, prefixing our output by its        prefix (with "show " skipped).  */
if|if
condition|(
name|list
operator|->
name|prefixlist
operator|&&
operator|!
name|list
operator|->
name|abbrev_flag
condition|)
name|cmd_show_list
argument_list|(
operator|*
name|list
operator|->
name|prefixlist
argument_list|,
name|from_tty
argument_list|,
name|list
operator|->
name|prefixname
operator|+
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
operator|->
name|type
operator|==
name|show_cmd
condition|)
block|{
name|fputs_filtered
argument_list|(
name|prefix
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|list
operator|->
name|name
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|":  "
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
name|do_setshow_command
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|from_tty
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|shell_escape
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|CANT_FORK
comment|/* FIXME: what about errors (I don't know how GO32 system() handles      them)?  */
name|system
argument_list|(
name|arg
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Can fork.  */
name|int
name|rc
decl_stmt|,
name|status
decl_stmt|,
name|pid
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|user_shell
decl_stmt|;
if|if
condition|(
operator|(
name|user_shell
operator|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|user_shell
operator|=
literal|"/bin/sh"
expr_stmt|;
comment|/* Get the name of the shell for arg0 */
if|if
condition|(
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|user_shell
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|p
operator|=
name|user_shell
expr_stmt|;
else|else
name|p
operator|++
expr_stmt|;
comment|/* Get past '/' */
if|if
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|arg
condition|)
name|execl
argument_list|(
name|user_shell
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|execl
argument_list|(
name|user_shell
argument_list|,
name|p
argument_list|,
literal|"-c"
argument_list|,
name|arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Cannot execute %s: %s\n"
argument_list|,
name|user_shell
argument_list|,
name|safe_strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|0177
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|!=
operator|-
literal|1
condition|)
while|while
condition|(
operator|(
name|rc
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|)
operator|!=
name|pid
operator|&&
name|rc
operator|!=
operator|-
literal|1
condition|)
empty_stmt|;
else|else
name|error
argument_list|(
literal|"Fork failed"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Can fork.  */
block|}
end_function

begin_function
specifier|static
name|void
name|make_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|arg
operator|==
literal|0
condition|)
name|p
operator|=
literal|"make"
expr_stmt|;
else|else
block|{
name|p
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
literal|"make "
argument_list|)
operator|+
name|strlen
argument_list|(
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"make "
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|p
operator|+
sizeof|sizeof
argument_list|(
literal|"make "
argument_list|)
operator|-
literal|1
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
name|shell_escape
argument_list|(
name|p
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_user_1
parameter_list|(
name|c
parameter_list|,
name|stream
parameter_list|)
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
specifier|register
name|struct
name|command_line
modifier|*
name|cmdlines
decl_stmt|;
name|cmdlines
operator|=
name|c
operator|->
name|user_commands
expr_stmt|;
if|if
condition|(
operator|!
name|cmdlines
condition|)
return|return;
name|fputs_filtered
argument_list|(
literal|"User command "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|c
operator|->
name|name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|":\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
while|while
condition|(
name|cmdlines
condition|)
block|{
name|print_command_line
argument_list|(
name|cmdlines
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|cmdlines
operator|=
name|cmdlines
operator|->
name|next
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
literal|"\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|show_user
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|struct
name|cmd_list_element
modifier|*
name|c
decl_stmt|;
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|cmdlist
decl_stmt|;
if|if
condition|(
name|args
condition|)
block|{
name|c
operator|=
name|lookup_cmd
argument_list|(
operator|&
name|args
argument_list|,
name|cmdlist
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|class
operator|!=
name|class_user
condition|)
name|error
argument_list|(
literal|"Not a user command."
argument_list|)
expr_stmt|;
name|show_user_1
argument_list|(
name|c
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|c
operator|=
name|cmdlist
init|;
name|c
condition|;
name|c
operator|=
name|c
operator|->
name|next
control|)
block|{
if|if
condition|(
name|c
operator|->
name|class
operator|==
name|class_user
condition|)
name|show_user_1
argument_list|(
name|c
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|_initialize_command
parameter_list|()
block|{
name|add_com
argument_list|(
literal|"shell"
argument_list|,
name|class_support
argument_list|,
name|shell_escape
argument_list|,
literal|"Execute the rest of the line as a shell command.  \n\ With no arguments, run an inferior shell."
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdb_commands
condition|)
name|add_com_alias
argument_list|(
literal|"!"
argument_list|,
literal|"shell"
argument_list|,
name|class_support
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"make"
argument_list|,
name|class_support
argument_list|,
name|make_command
argument_list|,
literal|"Run the ``make'' program using the rest of the line as arguments."
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"user"
argument_list|,
name|no_class
argument_list|,
name|show_user
argument_list|,
literal|"Show definitions of user defined commands.\n\ Argument is the name of the user defined command.\n\ With no argument, show definitions of all user defined commands."
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

