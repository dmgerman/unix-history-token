begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Machine independent support for SVR4 /proc (process file system) for GDB.    Copyright 1999, 2000 Free Software Foundation, Inc.    Written by Michael Snyder at Cygnus Solutions.    Based on work by Fred Fish, Stu Grossman, Geoff Noer, and others.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation,  Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/*  * Pretty-print the pr_why value.  *   * Arguments: unsigned long flags, int verbose  *  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NEW_PROC_API
argument_list|)
end_if

begin_define
define|#
directive|define
name|_STRUCTURED_PROC
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/procfs.h>
end_include

begin_include
include|#
directive|include
file|"proc-utils.h"
end_include

begin_comment
comment|/*  Much of the information used in the /proc interface, particularly for     printing status information, is kept as tables of structures of the     following form.  These tables can be used to map numeric values to     their symbolic names and to a string that describes their specific use. */
end_comment

begin_struct
struct|struct
name|trans
block|{
name|int
name|value
decl_stmt|;
comment|/* The numeric value */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The equivalent symbolic value */
name|char
modifier|*
name|desc
decl_stmt|;
comment|/* Short description of value */
block|}
struct|;
end_struct

begin_comment
comment|/*  Translate values in the pr_why field of the prstatus struct. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|trans
name|pr_why_table
index|[]
init|=
block|{
if|#
directive|if
name|defined
argument_list|(
name|PR_REQUESTED
argument_list|)
comment|/* All platforms */
block|{
name|PR_REQUESTED
block|,
literal|"PR_REQUESTED"
block|,
literal|"Directed to stop by debugger via P(IO)CSTOP or P(IO)CWSTOP"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_SIGNALLED
argument_list|)
comment|/* All platforms */
block|{
name|PR_SIGNALLED
block|,
literal|"PR_SIGNALLED"
block|,
literal|"Receipt of a traced signal"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_SYSENTRY
argument_list|)
comment|/* All platforms */
block|{
name|PR_SYSENTRY
block|,
literal|"PR_SYSENTRY"
block|,
literal|"Entry to a traced system call"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_SYSEXIT
argument_list|)
comment|/* All platforms */
block|{
name|PR_SYSEXIT
block|,
literal|"PR_SYSEXIT"
block|,
literal|"Exit from a traced system call"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_JOBCONTROL
argument_list|)
comment|/* All platforms */
block|{
name|PR_JOBCONTROL
block|,
literal|"PR_JOBCONTROL"
block|,
literal|"Default job control stop signal action"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_FAULTED
argument_list|)
comment|/* All platforms */
block|{
name|PR_FAULTED
block|,
literal|"PR_FAULTED"
block|,
literal|"Incurred a traced hardware fault"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_SUSPENDED
argument_list|)
comment|/* Solaris and UnixWare */
block|{
name|PR_SUSPENDED
block|,
literal|"PR_SUSPENDED"
block|,
literal|"Process suspended"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_CHECKPOINT
argument_list|)
comment|/* Solaris only */
block|{
name|PR_CHECKPOINT
block|,
literal|"PR_CHECKPOINT"
block|,
literal|"Process stopped at checkpoint"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_FORKSTOP
argument_list|)
comment|/* OSF only */
block|{
name|PR_FORKSTOP
block|,
literal|"PR_FORKSTOP"
block|,
literal|"Process stopped at end of fork call"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_TCRSTOP
argument_list|)
comment|/* OSF only */
block|{
name|PR_TCRSTOP
block|,
literal|"PR_TCRSTOP"
block|,
literal|"Process stopped on thread creation"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_TTSTOP
argument_list|)
comment|/* OSF only */
block|{
name|PR_TTSTOP
block|,
literal|"PR_TTSTOP"
block|,
literal|"Process stopped on thread termination"
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|PR_DEAD
argument_list|)
comment|/* OSF only */
block|{
name|PR_DEAD
block|,
literal|"PR_DEAD"
block|,
literal|"Process stopped in exit system call"
block|}
block|,
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|proc_prettyfprint_why
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
name|unsigned
name|long
name|why
parameter_list|,
name|unsigned
name|long
name|what
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|why
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|pr_why_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|pr_why_table
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|why
operator|==
name|pr_why_table
index|[
name|i
index|]
operator|.
name|value
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s "
argument_list|,
name|pr_why_table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|": %s "
argument_list|,
name|pr_why_table
index|[
name|i
index|]
operator|.
name|desc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|why
condition|)
block|{
ifdef|#
directive|ifdef
name|PR_REQUESTED
case|case
name|PR_REQUESTED
case|:
break|break;
comment|/* Nothing more to print. */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PR_SIGNALLED
case|case
name|PR_SIGNALLED
case|:
name|proc_prettyfprint_signal
argument_list|(
name|file
argument_list|,
name|what
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PR_FAULTED
case|case
name|PR_FAULTED
case|:
name|proc_prettyfprint_fault
argument_list|(
name|file
argument_list|,
name|what
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PR_SYSENTRY
case|case
name|PR_SYSENTRY
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Entry to "
argument_list|)
expr_stmt|;
name|proc_prettyfprint_syscall
argument_list|(
name|file
argument_list|,
name|what
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PR_SYSEXIT
case|case
name|PR_SYSEXIT
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Exit from "
argument_list|)
expr_stmt|;
name|proc_prettyfprint_syscall
argument_list|(
name|file
argument_list|,
name|what
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PR_JOBCONTROL
case|case
name|PR_JOBCONTROL
case|:
name|proc_prettyfprint_signal
argument_list|(
name|file
argument_list|,
name|what
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PR_DEAD
case|case
name|PR_DEAD
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Exit status: %d\n"
argument_list|,
name|what
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Unknown why %ld, what %ld\n"
argument_list|,
name|why
argument_list|,
name|what
argument_list|)
expr_stmt|;
break|break;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"Unknown pr_why.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|proc_prettyprint_why
parameter_list|(
name|unsigned
name|long
name|why
parameter_list|,
name|unsigned
name|long
name|what
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
name|proc_prettyfprint_why
argument_list|(
name|stdout
argument_list|,
name|why
argument_list|,
name|what
argument_list|,
name|verbose
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

