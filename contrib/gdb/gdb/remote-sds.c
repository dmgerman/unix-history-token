begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Remote target communications for serial-line targets using SDS' protocol.     Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2004 Free Software    Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This interface was written by studying the behavior of the SDS    monitor on an ADS 821/860 board, and by consulting the    documentation of the monitor that is available on Motorola's web    site.  -sts 8/13/97 */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcmd.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"gdb-stabs.h"
end_include

begin_include
include|#
directive|include
file|"gdbthread.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"regcache.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"serial.h"
end_include

begin_function_decl
specifier|extern
name|void
name|_initialize_remote_sds
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Declarations of local functions. */
end_comment

begin_function_decl
specifier|static
name|int
name|sds_write_bytes
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sds_read_bytes
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sds_files_info
parameter_list|(
name|struct
name|target_ops
modifier|*
name|ignore
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sds_xfer_memory
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|struct
name|mem_attrib
modifier|*
parameter_list|,
name|struct
name|target_ops
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sds_prepare_to_store
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sds_fetch_registers
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sds_resume
parameter_list|(
name|ptid_t
parameter_list|,
name|int
parameter_list|,
name|enum
name|target_signal
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sds_start_remote
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sds_open
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sds_close
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sds_store_registers
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sds_mourn
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sds_create_inferior
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sds_load
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getmessage
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|putmessage
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sds_send
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|readchar
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ptid_t
name|sds_wait
parameter_list|(
name|ptid_t
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sds_kill
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fromhex
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sds_detach
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sds_interrupt
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sds_interrupt_twice
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|interrupt_query
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_frame
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sds_insert_breakpoint
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sds_remove_breakpoint
parameter_list|(
name|CORE_ADDR
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_sds_ops
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sds_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Define the target operations vector. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|target_ops
name|sds_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This was 5 seconds, which is a long time to sit and wait.    Unless this is going though some terminal server or multiplexer or    other form of hairy serial connection, I would think 2 seconds would    be plenty.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sds_timeout
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Descriptor for I/O to remote machine.  Initialize it to NULL so    that sds_open knows that we don't have a file open when the program    starts.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|serial
modifier|*
name|sds_desc
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This limit comes from the monitor.  */
end_comment

begin_define
define|#
directive|define
name|PBUFSIZ
value|250
end_define

begin_comment
comment|/* Maximum number of bytes to read/write at once.  The value here    is chosen to fill up a packet (the headers account for the 32).  */
end_comment

begin_define
define|#
directive|define
name|MAXBUFBYTES
value|((PBUFSIZ-32)/2)
end_define

begin_decl_stmt
specifier|static
name|int
name|next_msg_id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|just_started
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|message_pending
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Clean up connection to a remote debugger.  */
end_comment

begin_function
specifier|static
name|void
name|sds_close
parameter_list|(
name|int
name|quitting
parameter_list|)
block|{
if|if
condition|(
name|sds_desc
condition|)
name|serial_close
argument_list|(
name|sds_desc
argument_list|)
expr_stmt|;
name|sds_desc
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Stub for catch_errors.  */
end_comment

begin_function
specifier|static
name|int
name|sds_start_remote
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
literal|200
index|]
decl_stmt|;
name|immediate_quit
operator|++
expr_stmt|;
comment|/* Allow user to interrupt it */
comment|/* Ack any packet which the remote side has already sent.  */
name|serial_write
argument_list|(
name|sds_desc
argument_list|,
literal|"{#*\r\n"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|serial_write
argument_list|(
name|sds_desc
argument_list|,
literal|"{#}\r\n"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|readchar
argument_list|(
literal|1
argument_list|)
operator|)
operator|>=
literal|0
condition|)
name|printf_unfiltered
argument_list|(
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|printf_unfiltered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|next_msg_id
operator|=
literal|251
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|26
expr_stmt|;
name|sds_send
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|sds_send
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|immediate_quit
operator|--
expr_stmt|;
name|start_remote
argument_list|()
expr_stmt|;
comment|/* Initialize gdb process mechanisms */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Open a connection to a remote debugger.    NAME is the filename used for communication.  */
end_comment

begin_function
specifier|static
name|void
name|sds_open
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
if|if
condition|(
name|name
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"To open a remote debug connection, you need to specify what serial\n\ device is attached to the remote system (e.g. /dev/ttya)."
argument_list|)
expr_stmt|;
name|target_preopen
argument_list|(
name|from_tty
argument_list|)
expr_stmt|;
name|unpush_target
argument_list|(
operator|&
name|sds_ops
argument_list|)
expr_stmt|;
name|sds_desc
operator|=
name|serial_open
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sds_desc
condition|)
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|baud_rate
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|serial_setbaudrate
argument_list|(
name|sds_desc
argument_list|,
name|baud_rate
argument_list|)
condition|)
block|{
name|serial_close
argument_list|(
name|sds_desc
argument_list|)
expr_stmt|;
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|serial_raw
argument_list|(
name|sds_desc
argument_list|)
expr_stmt|;
comment|/* If there is something sitting in the buffer we might take it as a      response to a command, which would be bad.  */
name|serial_flush_input
argument_list|(
name|sds_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
block|{
name|puts_filtered
argument_list|(
literal|"Remote debugging using "
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|push_target
argument_list|(
operator|&
name|sds_ops
argument_list|)
expr_stmt|;
comment|/* Switch to using remote target now */
name|just_started
operator|=
literal|1
expr_stmt|;
comment|/* Start the remote connection; if error (0), discard this target.      In particular, if the user quits, be sure to discard it (we'd be      in an inconsistent state otherwise).  */
if|if
condition|(
operator|!
name|catch_errors
argument_list|(
name|sds_start_remote
argument_list|,
name|NULL
argument_list|,
literal|"Couldn't establish connection to remote target\n"
argument_list|,
name|RETURN_MASK_ALL
argument_list|)
condition|)
name|pop_target
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This takes a program previously attached to and detaches it.  After    this is done, GDB can be used to debug some other program.  We    better not have left any breakpoints in the target program or it'll    die when it hits one.  */
end_comment

begin_function
specifier|static
name|void
name|sds_detach
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
if|if
condition|(
name|args
condition|)
name|error
argument_list|(
literal|"Argument given to \"detach\" when remotely debugging."
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Tell the remote target to detach.  */
block|strcpy (buf, "D");   sds_send (buf, 1);
endif|#
directive|endif
name|pop_target
argument_list|()
expr_stmt|;
if|if
condition|(
name|from_tty
condition|)
name|puts_filtered
argument_list|(
literal|"Ending remote debugging.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Convert hex digit A to a number.  */
end_comment

begin_function
specifier|static
name|int
name|fromhex
parameter_list|(
name|int
name|a
parameter_list|)
block|{
if|if
condition|(
name|a
operator|>=
literal|'0'
operator|&&
name|a
operator|<=
literal|'9'
condition|)
return|return
name|a
operator|-
literal|'0'
return|;
elseif|else
if|if
condition|(
name|a
operator|>=
literal|'a'
operator|&&
name|a
operator|<=
literal|'f'
condition|)
return|return
name|a
operator|-
literal|'a'
operator|+
literal|10
return|;
else|else
name|error
argument_list|(
literal|"Reply contains invalid hex digit %d"
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|tob64
parameter_list|(
name|unsigned
name|char
modifier|*
name|inbuf
parameter_list|,
name|char
modifier|*
name|outbuf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|sum
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|len
operator|%
literal|3
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"bad length"
argument_list|)
expr_stmt|;
name|p
operator|=
name|outbuf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
literal|3
control|)
block|{
comment|/* Collect the next three bytes into a number.  */
name|sum
operator|=
operator|(
operator|(
name|long
operator|)
operator|*
name|inbuf
operator|++
operator|)
operator|<<
literal|16
expr_stmt|;
name|sum
operator||=
operator|(
operator|(
name|long
operator|)
operator|*
name|inbuf
operator|++
operator|)
operator|<<
literal|8
expr_stmt|;
name|sum
operator||=
operator|(
operator|(
name|long
operator|)
operator|*
name|inbuf
operator|++
operator|)
expr_stmt|;
comment|/* Spit out 4 6-bit encodings.  */
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
name|sum
operator|>>
literal|18
operator|)
operator|&
literal|0x3f
operator|)
operator|+
literal|'0'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
name|sum
operator|>>
literal|12
operator|)
operator|&
literal|0x3f
operator|)
operator|+
literal|'0'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
operator|(
name|sum
operator|>>
literal|6
operator|)
operator|&
literal|0x3f
operator|)
operator|+
literal|'0'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
operator|(
name|sum
operator|&
literal|0x3f
operator|)
operator|+
literal|'0'
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|-
name|outbuf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fromb64
parameter_list|(
name|char
modifier|*
name|inbuf
parameter_list|,
name|char
modifier|*
name|outbuf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|sum
decl_stmt|;
if|if
condition|(
name|len
operator|%
literal|4
operator|!=
literal|0
condition|)
name|error
argument_list|(
literal|"bad length"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|+=
literal|4
control|)
block|{
comment|/* Collect 4 6-bit digits.  */
name|sum
operator|=
operator|(
operator|*
name|inbuf
operator|++
operator|-
literal|'0'
operator|)
operator|<<
literal|18
expr_stmt|;
name|sum
operator||=
operator|(
operator|*
name|inbuf
operator|++
operator|-
literal|'0'
operator|)
operator|<<
literal|12
expr_stmt|;
name|sum
operator||=
operator|(
operator|*
name|inbuf
operator|++
operator|-
literal|'0'
operator|)
operator|<<
literal|6
expr_stmt|;
name|sum
operator||=
operator|(
operator|*
name|inbuf
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
comment|/* Now take the resulting 24-bit number and get three bytes out          of it.  */
operator|*
name|outbuf
operator|++
operator|=
operator|(
name|sum
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
name|outbuf
operator|++
operator|=
operator|(
name|sum
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
operator|*
name|outbuf
operator|++
operator|=
name|sum
operator|&
literal|0xff
expr_stmt|;
block|}
return|return
operator|(
name|len
operator|/
literal|4
operator|)
operator|*
literal|3
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Tell the remote machine to resume.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|target_signal
name|last_sent_signal
init|=
name|TARGET_SIGNAL_0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|last_sent_step
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|sds_resume
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|int
name|step
parameter_list|,
name|enum
name|target_signal
name|siggnal
parameter_list|)
block|{
name|unsigned
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|last_sent_signal
operator|=
name|siggnal
expr_stmt|;
name|last_sent_step
operator|=
name|step
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
operator|(
name|step
condition|?
literal|21
else|:
literal|20
operator|)
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* (should be signal?) */
name|sds_send
argument_list|(
name|buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Send a message to target to halt it.  Target will respond, and send    us a message pending notice.  */
end_comment

begin_function
specifier|static
name|void
name|sds_interrupt
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
name|unsigned
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
comment|/* If this doesn't work, try more severe steps.  */
name|signal
argument_list|(
name|signo
argument_list|,
name|sds_interrupt_twice
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"sds_interrupt called\n"
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|25
expr_stmt|;
name|sds_send
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|ofunc
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* The user typed ^C twice.  */
end_comment

begin_function
specifier|static
name|void
name|sds_interrupt_twice
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
name|signal
argument_list|(
name|signo
argument_list|,
name|ofunc
argument_list|)
expr_stmt|;
name|interrupt_query
argument_list|()
expr_stmt|;
name|signal
argument_list|(
name|signo
argument_list|,
name|sds_interrupt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Ask the user what to do when an interrupt is received.  */
end_comment

begin_function
specifier|static
name|void
name|interrupt_query
parameter_list|(
name|void
parameter_list|)
block|{
name|target_terminal_ours
argument_list|()
expr_stmt|;
if|if
condition|(
name|query
argument_list|(
literal|"Interrupted while waiting for the program.\n\ Give up (and stop debugging it)? "
argument_list|)
condition|)
block|{
name|target_mourn_inferior
argument_list|()
expr_stmt|;
name|throw_exception
argument_list|(
name|RETURN_QUIT
argument_list|)
expr_stmt|;
block|}
name|target_terminal_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If nonzero, ignore the next kill.  */
end_comment

begin_decl_stmt
name|int
name|kill_kludge
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Wait until the remote machine stops, then return, storing status in    STATUS just as `wait' would.  Returns "pid" (though it's not clear    what, if anything, that means in the case of this target).  */
end_comment

begin_function
specifier|static
name|ptid_t
name|sds_wait
parameter_list|(
name|ptid_t
name|ptid
parameter_list|,
name|struct
name|target_waitstatus
modifier|*
name|status
parameter_list|)
block|{
name|unsigned
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|int
name|retlen
decl_stmt|;
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|integer
operator|=
literal|0
expr_stmt|;
name|ofunc
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|sds_interrupt
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|ofunc
argument_list|)
expr_stmt|;
if|if
condition|(
name|just_started
condition|)
block|{
name|just_started
operator|=
literal|0
expr_stmt|;
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
return|return
name|inferior_ptid
return|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|getmessage
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|message_pending
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
literal|26
expr_stmt|;
name|retlen
operator|=
name|sds_send
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_debug
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"Signals: %02x%02x %02x %02x\n"
argument_list|,
name|buf
index|[
literal|0
index|]
argument_list|,
name|buf
index|[
literal|1
index|]
argument_list|,
name|buf
index|[
literal|2
index|]
argument_list|,
name|buf
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
name|message_pending
operator|=
literal|0
expr_stmt|;
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|TARGET_SIGNAL_TRAP
expr_stmt|;
goto|goto
name|got_status
goto|;
block|}
block|}
name|got_status
label|:
return|return
name|inferior_ptid
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|sprs
index|[
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read the remote registers into the block REGS.  */
end_comment

begin_comment
comment|/* Currently we just read all the registers, so we don't use regno.  */
end_comment

begin_function
specifier|static
name|void
name|sds_fetch_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|unsigned
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|retlen
decl_stmt|;
name|char
modifier|*
name|regs
init|=
name|alloca
argument_list|(
name|DEPRECATED_REGISTER_BYTES
argument_list|)
decl_stmt|;
comment|/* Unimplemented registers read as all bits zero.  */
name|memset
argument_list|(
name|regs
argument_list|,
literal|0
argument_list|,
name|DEPRECATED_REGISTER_BYTES
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|18
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|retlen
operator|=
name|sds_send
argument_list|(
name|buf
argument_list|,
literal|3
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
operator|*
literal|6
condition|;
operator|++
name|i
control|)
name|regs
index|[
name|i
operator|+
literal|4
operator|*
literal|32
operator|+
literal|8
operator|*
literal|32
index|]
operator|=
name|buf
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
operator|*
literal|4
condition|;
operator|++
name|i
control|)
name|sprs
index|[
name|i
index|]
operator|=
name|buf
index|[
name|i
operator|+
literal|4
operator|*
literal|7
index|]
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|18
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|2
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|retlen
operator|=
name|sds_send
argument_list|(
name|buf
argument_list|,
literal|3
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|retlen
condition|;
name|i
operator|++
control|)
name|regs
index|[
name|i
index|]
operator|=
name|buf
index|[
name|i
index|]
expr_stmt|;
comment|/* (should warn about reply too short) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_REGS
condition|;
name|i
operator|++
control|)
name|supply_register
argument_list|(
name|i
argument_list|,
operator|&
name|regs
index|[
name|DEPRECATED_REGISTER_BYTE
argument_list|(
name|i
argument_list|)
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Prepare to store registers.  Since we may send them all, we have to    read out the ones we don't want to change first.  */
end_comment

begin_function
specifier|static
name|void
name|sds_prepare_to_store
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Make sure the entire registers array is valid.  */
name|deprecated_read_register_bytes
argument_list|(
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|DEPRECATED_REGISTER_BYTES
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store register REGNO, or all registers if REGNO == -1, from the contents    of REGISTERS.  FIXME: ignores errors.  */
end_comment

begin_function
specifier|static
name|void
name|sds_store_registers
parameter_list|(
name|int
name|regno
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Store all the special-purpose registers.  */
name|p
operator|=
name|buf
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|19
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|1
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
operator|*
literal|6
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
name|deprecated_registers
index|[
name|i
operator|+
literal|4
operator|*
literal|32
operator|+
literal|8
operator|*
literal|32
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
operator|*
literal|1
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
operator|*
literal|4
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
name|sprs
index|[
name|i
index|]
expr_stmt|;
name|sds_send
argument_list|(
name|buf
argument_list|,
name|p
operator|-
name|buf
argument_list|)
expr_stmt|;
comment|/* Store all the general-purpose registers.  */
name|p
operator|=
name|buf
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|19
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|2
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
operator|*
literal|32
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
name|deprecated_registers
index|[
name|i
index|]
expr_stmt|;
name|sds_send
argument_list|(
name|buf
argument_list|,
name|p
operator|-
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write memory data directly to the remote machine.  This does not    inform the data cache; the data cache uses this.  MEMADDR is the    address in the remote memory space.  MYADDR is the address of the    buffer in our space.  LEN is the number of bytes.     Returns number of bytes transferred, or 0 for error.  */
end_comment

begin_function
specifier|static
name|int
name|sds_write_bytes
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|max_buf_size
decl_stmt|;
comment|/* Max size of packet output buffer */
name|int
name|origlen
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|int
name|todo
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Chop the transfer down if necessary */
name|max_buf_size
operator|=
literal|150
expr_stmt|;
name|origlen
operator|=
name|len
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|todo
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|max_buf_size
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|13
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|memaddr
operator|>>
literal|24
argument_list|)
operator|&
literal|0xff
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|memaddr
operator|>>
literal|16
argument_list|)
operator|&
literal|0xff
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|memaddr
operator|>>
literal|8
argument_list|)
operator|&
literal|0xff
expr_stmt|;
name|buf
index|[
literal|5
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|memaddr
argument_list|)
operator|&
literal|0xff
expr_stmt|;
name|buf
index|[
literal|6
index|]
operator|=
literal|1
expr_stmt|;
name|buf
index|[
literal|7
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|todo
condition|;
name|i
operator|++
control|)
name|buf
index|[
name|i
operator|+
literal|8
index|]
operator|=
name|myaddr
index|[
name|i
index|]
expr_stmt|;
name|sds_send
argument_list|(
name|buf
argument_list|,
literal|8
operator|+
name|todo
argument_list|)
expr_stmt|;
comment|/* (should look at result) */
name|myaddr
operator|+=
name|todo
expr_stmt|;
name|memaddr
operator|+=
name|todo
expr_stmt|;
name|len
operator|-=
name|todo
expr_stmt|;
block|}
return|return
name|origlen
return|;
block|}
end_function

begin_comment
comment|/* Read memory data directly from the remote machine.  This does not    use the data cache; the data cache uses this.  MEMADDR is the    address in the remote memory space.  MYADDR is the address of the    buffer in our space.  LEN is the number of bytes.     Returns number of bytes transferred, or 0 for error.  */
end_comment

begin_function
specifier|static
name|int
name|sds_read_bytes
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|max_buf_size
decl_stmt|;
comment|/* Max size of packet output buffer */
name|int
name|origlen
decl_stmt|,
name|retlen
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|int
name|todo
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Chop the transfer down if necessary */
name|max_buf_size
operator|=
literal|150
expr_stmt|;
name|origlen
operator|=
name|len
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|todo
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|max_buf_size
argument_list|)
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|12
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|memaddr
operator|>>
literal|24
argument_list|)
operator|&
literal|0xff
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|memaddr
operator|>>
literal|16
argument_list|)
operator|&
literal|0xff
expr_stmt|;
name|buf
index|[
literal|4
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|memaddr
operator|>>
literal|8
argument_list|)
operator|&
literal|0xff
expr_stmt|;
name|buf
index|[
literal|5
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|memaddr
argument_list|)
operator|&
literal|0xff
expr_stmt|;
name|buf
index|[
literal|6
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|todo
operator|>>
literal|8
argument_list|)
operator|&
literal|0xff
expr_stmt|;
name|buf
index|[
literal|7
index|]
operator|=
call|(
name|int
call|)
argument_list|(
name|todo
argument_list|)
operator|&
literal|0xff
expr_stmt|;
name|buf
index|[
literal|8
index|]
operator|=
literal|1
expr_stmt|;
name|retlen
operator|=
name|sds_send
argument_list|(
name|buf
argument_list|,
literal|9
argument_list|)
expr_stmt|;
if|if
condition|(
name|retlen
operator|-
literal|2
operator|!=
name|todo
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* Reply describes memory byte by byte. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|todo
condition|;
name|i
operator|++
control|)
name|myaddr
index|[
name|i
index|]
operator|=
name|buf
index|[
name|i
operator|+
literal|2
index|]
expr_stmt|;
name|myaddr
operator|+=
name|todo
expr_stmt|;
name|memaddr
operator|+=
name|todo
expr_stmt|;
name|len
operator|-=
name|todo
expr_stmt|;
block|}
return|return
name|origlen
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Read or write LEN bytes from inferior memory at MEMADDR,    transferring to or from debugger address MYADDR.  Write to inferior    if SHOULD_WRITE is nonzero.  Returns length of data written or    read; 0 for error.  TARGET is unused.  */
end_comment

begin_function
specifier|static
name|int
name|sds_xfer_memory
parameter_list|(
name|CORE_ADDR
name|memaddr
parameter_list|,
name|char
modifier|*
name|myaddr
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|should_write
parameter_list|,
name|struct
name|mem_attrib
modifier|*
name|attrib
parameter_list|,
name|struct
name|target_ops
modifier|*
name|target
parameter_list|)
block|{
name|int
name|res
decl_stmt|;
if|if
condition|(
name|should_write
condition|)
name|res
operator|=
name|sds_write_bytes
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|sds_read_bytes
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|sds_files_info
parameter_list|(
name|struct
name|target_ops
modifier|*
name|ignore
parameter_list|)
block|{
name|puts_filtered
argument_list|(
literal|"Debugging over a serial connection, using SDS protocol.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Stuff for dealing with the packets which are part of this protocol.    See comment at top of file for details.  */
end_comment

begin_comment
comment|/* Read a single character from the remote end, masking it down to 7 bits. */
end_comment

begin_function
specifier|static
name|int
name|readchar
parameter_list|(
name|int
name|timeout
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
name|ch
operator|=
name|serial_readchar
argument_list|(
name|sds_desc
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_debug
operator|>
literal|1
operator|&&
name|ch
operator|>=
literal|0
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"%c(%x)"
argument_list|,
name|ch
argument_list|,
name|ch
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|SERIAL_EOF
case|:
name|error
argument_list|(
literal|"Remote connection closed"
argument_list|)
expr_stmt|;
case|case
name|SERIAL_ERROR
case|:
name|perror_with_name
argument_list|(
literal|"Remote communication error"
argument_list|)
expr_stmt|;
case|case
name|SERIAL_TIMEOUT
case|:
return|return
name|ch
return|;
default|default:
return|return
name|ch
operator|&
literal|0x7f
return|;
block|}
block|}
end_function

begin_comment
comment|/* An SDS-style checksum is a sum of the bytes modulo 253.  (Presumably    because 253, 254, and 255 are special flags in the protocol.)  */
end_comment

begin_function
specifier|static
name|int
name|compute_checksum
parameter_list|(
name|int
name|csum
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
name|csum
operator|+=
operator|(
name|unsigned
name|char
operator|)
name|buf
index|[
name|i
index|]
expr_stmt|;
name|csum
operator|%=
literal|253
expr_stmt|;
return|return
name|csum
return|;
block|}
end_function

begin_comment
comment|/* Send the command in BUF to the remote machine, and read the reply    into BUF also.  */
end_comment

begin_function
specifier|static
name|int
name|sds_send
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|putmessage
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|getmessage
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Send a message to the remote machine.  */
end_comment

begin_function
specifier|static
name|int
name|putmessage
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|enclen
decl_stmt|;
name|unsigned
name|char
name|csum
init|=
literal|0
decl_stmt|;
name|char
name|buf2
index|[
name|PBUFSIZ
index|]
decl_stmt|,
name|buf3
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|unsigned
name|char
name|header
index|[
literal|3
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Copy the packet into buffer BUF2, encapsulating it      and giving it a checksum.  */
if|if
condition|(
name|len
operator|>
literal|170
condition|)
comment|/* Prosanity check */
name|internal_error
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"failed internal consistency check"
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_debug
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"Message to send: \""
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"%02x"
argument_list|,
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"\"\n"
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|buf2
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'$'
expr_stmt|;
if|if
condition|(
name|len
operator|%
literal|3
operator|!=
literal|0
condition|)
block|{
name|buf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|buf
index|[
name|len
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|header
index|[
literal|1
index|]
operator|=
name|next_msg_id
expr_stmt|;
name|header
index|[
literal|2
index|]
operator|=
name|len
expr_stmt|;
name|csum
operator|=
name|compute_checksum
argument_list|(
name|csum
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|csum
operator|=
name|compute_checksum
argument_list|(
name|csum
argument_list|,
name|header
operator|+
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|header
index|[
literal|0
index|]
operator|=
name|csum
expr_stmt|;
name|tob64
argument_list|(
name|header
argument_list|,
name|p
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
name|enclen
operator|=
name|tob64
argument_list|(
name|buf
argument_list|,
name|buf3
argument_list|,
operator|(
operator|(
name|len
operator|+
literal|2
operator|)
operator|/
literal|3
operator|)
operator|*
literal|3
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|enclen
condition|;
operator|++
name|i
control|)
operator|*
name|p
operator|++
operator|=
name|buf3
index|[
name|i
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\r'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|next_msg_id
operator|=
operator|(
name|next_msg_id
operator|+
literal|3
operator|)
operator|%
literal|245
expr_stmt|;
comment|/* Send it over and over until we get a positive ack.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|remote_debug
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"Sending encoded: \"%s\""
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"  (Checksum %d, id %d, length %d)\n"
argument_list|,
name|header
index|[
literal|0
index|]
argument_list|,
name|header
index|[
literal|1
index|]
argument_list|,
name|header
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|gdb_flush
argument_list|(
name|gdb_stdlog
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|serial_write
argument_list|(
name|sds_desc
argument_list|,
name|buf2
argument_list|,
name|p
operator|-
name|buf2
argument_list|)
condition|)
name|perror_with_name
argument_list|(
literal|"putmessage: write failed"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/* Come here after finding the start of the frame.  Collect the rest    into BUF.  Returns 0 on any error, 1 on success.  */
end_comment

begin_function
specifier|static
name|int
name|read_frame
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|char
modifier|*
name|bp
decl_stmt|;
name|int
name|c
decl_stmt|;
name|bp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
name|readchar
argument_list|(
name|sds_timeout
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|SERIAL_TIMEOUT
case|:
if|if
condition|(
name|remote_debug
condition|)
name|fputs_filtered
argument_list|(
literal|"Timeout in mid-message, retrying\n"
argument_list|,
name|gdb_stdlog
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|'$'
case|:
if|if
condition|(
name|remote_debug
condition|)
name|fputs_filtered
argument_list|(
literal|"Saw new packet start in middle of old one\n"
argument_list|,
name|gdb_stdlog
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* Start a new packet, count retries */
case|case
literal|'\r'
case|:
break|break;
case|case
literal|'\n'
case|:
block|{
operator|*
name|bp
operator|=
literal|'\000'
expr_stmt|;
if|if
condition|(
name|remote_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"Received encoded: \"%s\"\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
default|default:
if|if
condition|(
name|bp
operator|<
name|buf
operator|+
name|PBUFSIZ
operator|-
literal|1
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"Message too long: "
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|puts_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Read a packet from the remote machine, with error checking,    and store it in BUF.  BUF is expected to be of size PBUFSIZ.    If FOREVER, wait forever rather than timing out; this is used    while the target is executing user code.  */
end_comment

begin_function
specifier|static
name|int
name|getmessage
parameter_list|(
name|unsigned
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|forever
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|c2
decl_stmt|,
name|c3
decl_stmt|;
name|int
name|tries
decl_stmt|;
name|int
name|timeout
decl_stmt|;
name|int
name|val
decl_stmt|,
name|i
decl_stmt|,
name|len
decl_stmt|,
name|csum
decl_stmt|;
name|unsigned
name|char
name|header
index|[
literal|3
index|]
decl_stmt|;
name|unsigned
name|char
name|inbuf
index|[
literal|500
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"timeout"
argument_list|)
expr_stmt|;
if|if
condition|(
name|forever
condition|)
block|{
name|timeout
operator|=
name|watchdog
operator|>
literal|0
condition|?
name|watchdog
else|:
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|timeout
operator|=
name|sds_timeout
expr_stmt|;
define|#
directive|define
name|MAX_TRIES
value|3
for|for
control|(
name|tries
operator|=
literal|1
init|;
name|tries
operator|<=
name|MAX_TRIES
condition|;
name|tries
operator|++
control|)
block|{
comment|/* This can loop forever if the remote side sends us characters          continuously, but if it pauses, we'll get a zero from readchar          because of timeout.  Then we'll count that as a retry.  */
comment|/* Note that we will only wait forever prior to the start of a packet.          After that, we expect characters to arrive at a brisk pace.  They          should show up within sds_timeout intervals.  */
do|do
block|{
name|c
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|SERIAL_TIMEOUT
condition|)
block|{
if|if
condition|(
name|forever
condition|)
comment|/* Watchdog went off.  Kill the target. */
block|{
name|target_mourn_inferior
argument_list|()
expr_stmt|;
name|error
argument_list|(
literal|"Watchdog has expired.  Target detached.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|remote_debug
condition|)
name|fputs_filtered
argument_list|(
literal|"Timed out.\n"
argument_list|,
name|gdb_stdlog
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
do|while
condition|(
name|c
operator|!=
literal|'$'
operator|&&
name|c
operator|!=
literal|'{'
condition|)
do|;
comment|/* We might have seen a "trigraph", a sequence of three characters          that indicate various sorts of communication state.  */
if|if
condition|(
name|c
operator|==
literal|'{'
condition|)
block|{
comment|/* Read the other two chars of the trigraph. */
name|c2
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
name|c3
operator|=
name|readchar
argument_list|(
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_debug
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"Trigraph %c%c%c received\n"
argument_list|,
name|c
argument_list|,
name|c2
argument_list|,
name|c3
argument_list|)
expr_stmt|;
if|if
condition|(
name|c3
operator|==
literal|'+'
condition|)
block|{
name|message_pending
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
comment|/*???? */
block|}
continue|continue;
block|}
name|val
operator|=
name|read_frame
argument_list|(
name|inbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|1
condition|)
block|{
name|fromb64
argument_list|(
name|inbuf
argument_list|,
name|header
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* (should check out other bits) */
name|fromb64
argument_list|(
name|inbuf
operator|+
literal|4
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|inbuf
argument_list|)
operator|-
literal|4
argument_list|)
expr_stmt|;
name|len
operator|=
name|header
index|[
literal|2
index|]
expr_stmt|;
name|csum
operator|=
literal|0
expr_stmt|;
name|csum
operator|=
name|compute_checksum
argument_list|(
name|csum
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|csum
operator|=
name|compute_checksum
argument_list|(
name|csum
argument_list|,
name|header
operator|+
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|csum
operator|!=
name|header
index|[
literal|0
index|]
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Checksum mismatch: computed %d, received %d\n"
argument_list|,
name|csum
argument_list|,
name|header
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
index|[
literal|2
index|]
operator|==
literal|0xff
condition|)
name|fprintf_unfiltered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"Requesting resend...\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|remote_debug
condition|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"... (Got checksum %d, id %d, length %d)\n"
argument_list|,
name|header
index|[
literal|0
index|]
argument_list|,
name|header
index|[
literal|1
index|]
argument_list|,
name|header
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"Message received: \""
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"%02x"
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf_unfiltered
argument_list|(
name|gdb_stdlog
argument_list|,
literal|"\"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* no ack required? */
return|return
name|len
return|;
block|}
comment|/* Try the whole thing again.  */
name|retry
label|:
comment|/* need to do something here */
empty_stmt|;
block|}
comment|/* We have tried hard enough, and just can't receive the packet.  Give up. */
name|printf_unfiltered
argument_list|(
literal|"Ignoring packet error, continuing...\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|sds_kill
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Don't try to do anything to the target.  */
block|}
end_function

begin_function
specifier|static
name|void
name|sds_mourn
parameter_list|(
name|void
parameter_list|)
block|{
name|unpush_target
argument_list|(
operator|&
name|sds_ops
argument_list|)
expr_stmt|;
name|generic_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sds_create_inferior
parameter_list|(
name|char
modifier|*
name|exec_file
parameter_list|,
name|char
modifier|*
name|args
parameter_list|,
name|char
modifier|*
modifier|*
name|env
parameter_list|)
block|{
name|inferior_ptid
operator|=
name|pid_to_ptid
argument_list|(
literal|42000
argument_list|)
expr_stmt|;
comment|/* Clean up from the last time we were running.  */
name|clear_proceed_status
argument_list|()
expr_stmt|;
comment|/* Let the remote process run.  */
name|proceed
argument_list|(
name|bfd_get_start_address
argument_list|(
name|exec_bfd
argument_list|)
argument_list|,
name|TARGET_SIGNAL_0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sds_load
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|generic_load
argument_list|(
name|filename
argument_list|,
name|from_tty
argument_list|)
expr_stmt|;
name|inferior_ptid
operator|=
name|null_ptid
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The SDS monitor has commands for breakpoint insertion, although it    it doesn't actually manage the breakpoints, it just returns the    replaced instruction back to the debugger.  */
end_comment

begin_function
specifier|static
name|int
name|sds_insert_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|contents_cache
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|retlen
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|16
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|p
operator|++
operator|=
call|(
name|int
call|)
argument_list|(
name|addr
operator|>>
literal|24
argument_list|)
operator|&
literal|0xff
expr_stmt|;
operator|*
name|p
operator|++
operator|=
call|(
name|int
call|)
argument_list|(
name|addr
operator|>>
literal|16
argument_list|)
operator|&
literal|0xff
expr_stmt|;
operator|*
name|p
operator|++
operator|=
call|(
name|int
call|)
argument_list|(
name|addr
operator|>>
literal|8
argument_list|)
operator|&
literal|0xff
expr_stmt|;
operator|*
name|p
operator|++
operator|=
call|(
name|int
call|)
argument_list|(
name|addr
argument_list|)
operator|&
literal|0xff
expr_stmt|;
name|retlen
operator|=
name|sds_send
argument_list|(
name|buf
argument_list|,
name|p
operator|-
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
name|contents_cache
index|[
name|i
index|]
operator|=
name|buf
index|[
name|i
operator|+
literal|2
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sds_remove_breakpoint
parameter_list|(
name|CORE_ADDR
name|addr
parameter_list|,
name|char
modifier|*
name|contents_cache
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|retlen
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
name|buf
index|[
name|PBUFSIZ
index|]
decl_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|17
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|p
operator|++
operator|=
call|(
name|int
call|)
argument_list|(
name|addr
operator|>>
literal|24
argument_list|)
operator|&
literal|0xff
expr_stmt|;
operator|*
name|p
operator|++
operator|=
call|(
name|int
call|)
argument_list|(
name|addr
operator|>>
literal|16
argument_list|)
operator|&
literal|0xff
expr_stmt|;
operator|*
name|p
operator|++
operator|=
call|(
name|int
call|)
argument_list|(
name|addr
operator|>>
literal|8
argument_list|)
operator|&
literal|0xff
expr_stmt|;
operator|*
name|p
operator|++
operator|=
call|(
name|int
call|)
argument_list|(
name|addr
argument_list|)
operator|&
literal|0xff
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
operator|*
name|p
operator|++
operator|=
name|contents_cache
index|[
name|i
index|]
expr_stmt|;
name|retlen
operator|=
name|sds_send
argument_list|(
name|buf
argument_list|,
name|p
operator|-
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|init_sds_ops
parameter_list|(
name|void
parameter_list|)
block|{
name|sds_ops
operator|.
name|to_shortname
operator|=
literal|"sds"
expr_stmt|;
name|sds_ops
operator|.
name|to_longname
operator|=
literal|"Remote serial target with SDS protocol"
expr_stmt|;
name|sds_ops
operator|.
name|to_doc
operator|=
literal|"Use a remote computer via a serial line; using the SDS protocol.\n\ Specify the serial device it is connected to (e.g. /dev/ttya)."
expr_stmt|;
name|sds_ops
operator|.
name|to_open
operator|=
name|sds_open
expr_stmt|;
name|sds_ops
operator|.
name|to_close
operator|=
name|sds_close
expr_stmt|;
name|sds_ops
operator|.
name|to_detach
operator|=
name|sds_detach
expr_stmt|;
name|sds_ops
operator|.
name|to_resume
operator|=
name|sds_resume
expr_stmt|;
name|sds_ops
operator|.
name|to_wait
operator|=
name|sds_wait
expr_stmt|;
name|sds_ops
operator|.
name|to_fetch_registers
operator|=
name|sds_fetch_registers
expr_stmt|;
name|sds_ops
operator|.
name|to_store_registers
operator|=
name|sds_store_registers
expr_stmt|;
name|sds_ops
operator|.
name|to_prepare_to_store
operator|=
name|sds_prepare_to_store
expr_stmt|;
name|sds_ops
operator|.
name|to_xfer_memory
operator|=
name|sds_xfer_memory
expr_stmt|;
name|sds_ops
operator|.
name|to_files_info
operator|=
name|sds_files_info
expr_stmt|;
name|sds_ops
operator|.
name|to_insert_breakpoint
operator|=
name|sds_insert_breakpoint
expr_stmt|;
name|sds_ops
operator|.
name|to_remove_breakpoint
operator|=
name|sds_remove_breakpoint
expr_stmt|;
name|sds_ops
operator|.
name|to_kill
operator|=
name|sds_kill
expr_stmt|;
name|sds_ops
operator|.
name|to_load
operator|=
name|sds_load
expr_stmt|;
name|sds_ops
operator|.
name|to_create_inferior
operator|=
name|sds_create_inferior
expr_stmt|;
name|sds_ops
operator|.
name|to_mourn_inferior
operator|=
name|sds_mourn
expr_stmt|;
name|sds_ops
operator|.
name|to_stratum
operator|=
name|process_stratum
expr_stmt|;
name|sds_ops
operator|.
name|to_has_all_memory
operator|=
literal|1
expr_stmt|;
name|sds_ops
operator|.
name|to_has_memory
operator|=
literal|1
expr_stmt|;
name|sds_ops
operator|.
name|to_has_stack
operator|=
literal|1
expr_stmt|;
name|sds_ops
operator|.
name|to_has_registers
operator|=
literal|1
expr_stmt|;
name|sds_ops
operator|.
name|to_has_execution
operator|=
literal|1
expr_stmt|;
name|sds_ops
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Put a command string, in args, out to the monitor and display the    reply message.  */
end_comment

begin_function
specifier|static
name|void
name|sds_command
parameter_list|(
name|char
modifier|*
name|args
parameter_list|,
name|int
name|from_tty
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|retlen
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
literal|1000
index|]
decl_stmt|;
comment|/* Convert hexadecimal chars into a byte buffer.  */
name|p
operator|=
name|args
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|buf
index|[
name|len
operator|++
index|]
operator|=
name|fromhex
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
operator|*
literal|16
operator|+
name|fromhex
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
break|break;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
name|retlen
operator|=
name|sds_send
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Reply is "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|retlen
condition|;
operator|++
name|i
control|)
block|{
name|printf_filtered
argument_list|(
literal|"%02x"
argument_list|,
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_initialize_remote_sds
parameter_list|(
name|void
parameter_list|)
block|{
name|init_sds_ops
argument_list|()
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|sds_ops
argument_list|)
expr_stmt|;
name|add_show_from_set
argument_list|(
name|add_set_cmd
argument_list|(
literal|"sdstimeout"
argument_list|,
name|no_class
argument_list|,
name|var_integer
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sds_timeout
argument_list|,
literal|"Set timeout value for sds read.\n"
argument_list|,
operator|&
name|setlist
argument_list|)
argument_list|,
operator|&
name|showlist
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"sds"
argument_list|,
name|class_obscure
argument_list|,
name|sds_command
argument_list|,
literal|"Send a command to the SDS monitor."
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

