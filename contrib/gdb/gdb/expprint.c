begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Print in infix form a struct expression.     Copyright 1986, 1988, 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997,    1998, 1999, 2000, 2003 Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"parser-defs.h"
end_include

begin_include
include|#
directive|include
file|"user-regs.h"
end_include

begin_comment
comment|/* For user_reg_map_regnum_to_name.  */
end_comment

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"block.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CTYPE_H
end_ifdef

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|print_expression
parameter_list|(
name|struct
name|expression
modifier|*
name|exp
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|int
name|pc
init|=
literal|0
decl_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
operator|&
name|pc
argument_list|,
name|stream
argument_list|,
name|PREC_NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the subexpression of EXP that starts in position POS, on STREAM.    PREC is the precedence of the surrounding operator;    if the precedence of the main operator of this subexpression is less,    parentheses are needed here.  */
end_comment

begin_function
name|void
name|print_subexp
parameter_list|(
name|struct
name|expression
modifier|*
name|exp
parameter_list|,
name|int
modifier|*
name|pos
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|enum
name|precedence
name|prec
parameter_list|)
block|{
name|exp
operator|->
name|language_defn
operator|->
name|la_exp_desc
operator|->
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|prec
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Standard implementation of print_subexp for use in language_defn    vectors.  */
end_comment

begin_function
name|void
name|print_subexp_standard
parameter_list|(
name|struct
name|expression
modifier|*
name|exp
parameter_list|,
name|int
modifier|*
name|pos
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|enum
name|precedence
name|prec
parameter_list|)
block|{
name|unsigned
name|tem
decl_stmt|;
specifier|const
name|struct
name|op_print
modifier|*
name|op_print_tab
decl_stmt|;
name|int
name|pc
decl_stmt|;
name|unsigned
name|nargs
decl_stmt|;
name|char
modifier|*
name|op_str
decl_stmt|;
name|int
name|assign_modify
init|=
literal|0
decl_stmt|;
name|enum
name|exp_opcode
name|opcode
decl_stmt|;
name|enum
name|precedence
name|myprec
init|=
name|PREC_NULL
decl_stmt|;
comment|/* Set to 1 for a right-associative operator.  */
name|int
name|assoc
init|=
literal|0
decl_stmt|;
name|struct
name|value
modifier|*
name|val
decl_stmt|;
name|char
modifier|*
name|tempstr
init|=
name|NULL
decl_stmt|;
name|op_print_tab
operator|=
name|exp
operator|->
name|language_defn
operator|->
name|la_op_print_tab
expr_stmt|;
name|pc
operator|=
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
name|opcode
operator|=
name|exp
operator|->
name|elts
index|[
name|pc
index|]
operator|.
name|opcode
expr_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
comment|/* Common ops */
case|case
name|OP_SCOPE
case|:
name|myprec
operator|=
name|PREC_PREFIX
expr_stmt|;
name|assoc
operator|=
literal|0
expr_stmt|;
name|fputs_filtered
argument_list|(
name|type_name_no_tag
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"::"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|nargs
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|4
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|nargs
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|3
index|]
operator|.
name|string
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|OP_LONG
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
expr_stmt|;
name|value_print
argument_list|(
name|value_from_longest
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|,
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|longconst
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|Val_no_prettyprint
argument_list|)
expr_stmt|;
return|return;
case|case
name|OP_DOUBLE
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
expr_stmt|;
name|value_print
argument_list|(
name|value_from_double
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|,
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|doubleconst
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|Val_no_prettyprint
argument_list|)
expr_stmt|;
return|return;
case|case
name|OP_VAR_VALUE
case|:
block|{
name|struct
name|block
modifier|*
name|b
decl_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
expr_stmt|;
name|b
operator|=
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|block
expr_stmt|;
if|if
condition|(
name|b
operator|!=
name|NULL
operator|&&
name|BLOCK_FUNCTION
argument_list|(
name|b
argument_list|)
operator|!=
name|NULL
operator|&&
name|SYMBOL_PRINT_NAME
argument_list|(
name|BLOCK_FUNCTION
argument_list|(
name|b
argument_list|)
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|fputs_filtered
argument_list|(
name|SYMBOL_PRINT_NAME
argument_list|(
name|BLOCK_FUNCTION
argument_list|(
name|b
argument_list|)
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"::"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
name|SYMBOL_PRINT_NAME
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|symbol
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|OP_LAST
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"$%d"
argument_list|,
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|OP_REGISTER
case|:
block|{
name|int
name|regnum
init|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|user_reg_map_regnum_to_name
argument_list|(
name|current_gdbarch
argument_list|,
name|regnum
argument_list|)
decl_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"$%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|OP_BOOL
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
condition|?
literal|"TRUE"
else|:
literal|"FALSE"
argument_list|)
expr_stmt|;
return|return;
case|case
name|OP_INTERNALVAR
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"$%s"
argument_list|,
name|internalvar_name
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|internalvar
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|OP_FUNCALL
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|nargs
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_SUFFIX
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" ("
argument_list|,
name|stream
argument_list|)
expr_stmt|;
for|for
control|(
name|tem
operator|=
literal|0
init|;
name|tem
operator|<
name|nargs
condition|;
name|tem
operator|++
control|)
block|{
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
name|fputs_filtered
argument_list|(
literal|", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_ABOVE_COMMA
argument_list|)
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
literal|")"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|OP_NAME
case|:
case|case
name|OP_EXPRSTRING
case|:
name|nargs
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|nargs
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|OP_STRING
case|:
name|nargs
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|nargs
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* LA_PRINT_STRING will print using the current repeat count threshold.          If necessary, we can temporarily set it to zero, or pass it as an          additional parameter to LA_PRINT_STRING.  -fnf */
name|LA_PRINT_STRING
argument_list|(
name|stream
argument_list|,
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
argument_list|,
name|nargs
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|OP_BITSTRING
case|:
name|nargs
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
operator|(
name|nargs
operator|+
name|HOST_CHAR_BIT
operator|-
literal|1
operator|)
operator|/
name|HOST_CHAR_BIT
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
literal|"B'<unimplemented>'"
argument_list|)
expr_stmt|;
return|return;
case|case
name|OP_OBJC_NSSTRING
case|:
comment|/* Objective-C Foundation Class NSString constant.  */
name|nargs
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|nargs
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"@\""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|LA_PRINT_STRING
argument_list|(
name|stream
argument_list|,
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
argument_list|,
name|nargs
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"\""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|OP_OBJC_MSGCALL
case|:
block|{
comment|/* Objective C message (method) call.  */
name|char
modifier|*
name|selector
decl_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
expr_stmt|;
name|nargs
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
literal|"["
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_SUFFIX
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|target_read_string
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|,
operator|&
name|selector
argument_list|,
literal|1024
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"bad selector"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nargs
condition|)
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|nextS
decl_stmt|;
name|s
operator|=
name|alloca
argument_list|(
name|strlen
argument_list|(
name|selector
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|s
argument_list|,
name|selector
argument_list|)
expr_stmt|;
for|for
control|(
name|tem
operator|=
literal|0
init|;
name|tem
operator|<
name|nargs
condition|;
name|tem
operator|++
control|)
block|{
name|nextS
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
operator|*
name|nextS
operator|=
literal|'\0'
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
literal|" %s: "
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|nextS
operator|+
literal|1
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_ABOVE_COMMA
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
literal|" %s"
argument_list|,
name|selector
argument_list|)
expr_stmt|;
block|}
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
comment|/* "selector" was malloc'd by target_read_string. Free it.  */
name|xfree
argument_list|(
name|selector
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|OP_ARRAY
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
expr_stmt|;
name|nargs
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|nargs
operator|-=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|nargs
operator|++
expr_stmt|;
name|tem
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|4
index|]
operator|.
name|opcode
operator|==
name|OP_LONG
operator|&&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|5
index|]
operator|.
name|type
operator|==
name|builtin_type_char
operator|&&
name|exp
operator|->
name|language_defn
operator|->
name|la_language
operator|==
name|language_c
condition|)
block|{
comment|/* Attempt to print C character arrays using string syntax. 	     Walk through the args, picking up one character from each 	     of the OP_LONG expression elements.  If any array element 	     does not match our expection of what we should find for 	     a simple string, revert back to array printing.  Note that 	     the last expression element is an explicit null terminator 	     byte, which doesn't get printed. */
name|tempstr
operator|=
name|alloca
argument_list|(
name|nargs
argument_list|)
expr_stmt|;
name|pc
operator|+=
literal|4
expr_stmt|;
while|while
condition|(
name|tem
operator|<
name|nargs
condition|)
block|{
if|if
condition|(
name|exp
operator|->
name|elts
index|[
name|pc
index|]
operator|.
name|opcode
operator|!=
name|OP_LONG
operator|||
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
operator|!=
name|builtin_type_char
condition|)
block|{
comment|/* Not a simple array of char, use regular array printing. */
name|tem
operator|=
literal|0
expr_stmt|;
break|break;
block|}
else|else
block|{
name|tempstr
index|[
name|tem
operator|++
index|]
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|pc
operator|+=
literal|4
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|tem
operator|>
literal|0
condition|)
block|{
name|LA_PRINT_STRING
argument_list|(
name|stream
argument_list|,
name|tempstr
argument_list|,
name|nargs
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|=
name|pc
expr_stmt|;
block|}
else|else
block|{
name|fputs_filtered
argument_list|(
literal|" {"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
for|for
control|(
name|tem
operator|=
literal|0
init|;
name|tem
operator|<
name|nargs
condition|;
name|tem
operator|++
control|)
block|{
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_ABOVE_COMMA
argument_list|)
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
literal|"}"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|OP_LABELED
case|:
name|tem
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|tem
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Gcc support both these syntaxes.  Unsure which is preferred.  */
if|#
directive|if
literal|1
name|fputs_filtered
argument_list|(
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|": "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|#
directive|else
name|fputs_filtered
argument_list|(
literal|"."
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"="
argument_list|,
name|stream
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_SUFFIX
argument_list|)
expr_stmt|;
return|return;
case|case
name|TERNOP_COND
case|:
if|if
condition|(
operator|(
name|int
operator|)
name|prec
operator|>
operator|(
name|int
operator|)
name|PREC_COMMA
condition|)
name|fputs_filtered
argument_list|(
literal|"("
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* Print the subexpressions, forcing parentheses          around any binary operations within them.          This is more parentheses than are strictly necessary,          but it looks clearer.  */
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_HYPER
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" ? "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_HYPER
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" : "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_HYPER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|prec
operator|>
operator|(
name|int
operator|)
name|PREC_COMMA
condition|)
name|fputs_filtered
argument_list|(
literal|")"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|TERNOP_SLICE
case|:
case|case
name|TERNOP_SLICE_COUNT
case|:
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_SUFFIX
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"("
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_ABOVE_COMMA
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|opcode
operator|==
name|TERNOP_SLICE
condition|?
literal|" : "
else|:
literal|" UP "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_ABOVE_COMMA
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|")"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|STRUCTOP_STRUCT
case|:
name|tem
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|tem
operator|+
literal|1
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_SUFFIX
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"."
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
comment|/* Will not occur for Modula-2 */
case|case
name|STRUCTOP_PTR
case|:
name|tem
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|tem
operator|+
literal|1
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_SUFFIX
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"->"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|BINOP_SUBSCRIPT
case|:
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_SUFFIX
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"["
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_ABOVE_COMMA
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"]"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNOP_POSTINCREMENT
case|:
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_SUFFIX
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"++"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNOP_POSTDECREMENT
case|:
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_SUFFIX
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"--"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNOP_CAST
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|prec
operator|>
operator|(
name|int
operator|)
name|PREC_PREFIX
condition|)
name|fputs_filtered
argument_list|(
literal|"("
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"("
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|") "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_PREFIX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|prec
operator|>
operator|(
name|int
operator|)
name|PREC_PREFIX
condition|)
name|fputs_filtered
argument_list|(
literal|")"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNOP_MEMVAL
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|prec
operator|>
operator|(
name|int
operator|)
name|PREC_PREFIX
condition|)
name|fputs_filtered
argument_list|(
literal|"("
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|)
operator|==
name|TYPE_CODE_FUNC
operator|&&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|3
index|]
operator|.
name|opcode
operator|==
name|OP_LONG
condition|)
block|{
comment|/* We have a minimal symbol fn, probably.  It's encoded 	     as a UNOP_MEMVAL (function-type) of an OP_LONG (int, address). 	     Swallow the OP_LONG (including both its opcodes); ignore 	     its type; print the value in the type of the MEMVAL.  */
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|4
expr_stmt|;
name|val
operator|=
name|value_at_lazy
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|,
operator|(
name|CORE_ADDR
operator|)
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|5
index|]
operator|.
name|longconst
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|value_print
argument_list|(
name|val
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|Val_no_prettyprint
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fputs_filtered
argument_list|(
literal|"{"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"} "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_PREFIX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|int
operator|)
name|prec
operator|>
operator|(
name|int
operator|)
name|PREC_PREFIX
condition|)
name|fputs_filtered
argument_list|(
literal|")"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|BINOP_ASSIGN_MODIFY
case|:
name|opcode
operator|=
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|opcode
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|myprec
operator|=
name|PREC_ASSIGN
expr_stmt|;
name|assoc
operator|=
literal|1
expr_stmt|;
name|assign_modify
operator|=
literal|1
expr_stmt|;
name|op_str
operator|=
literal|"???"
expr_stmt|;
for|for
control|(
name|tem
operator|=
literal|0
init|;
name|op_print_tab
index|[
name|tem
index|]
operator|.
name|opcode
operator|!=
name|OP_NULL
condition|;
name|tem
operator|++
control|)
if|if
condition|(
name|op_print_tab
index|[
name|tem
index|]
operator|.
name|opcode
operator|==
name|opcode
condition|)
block|{
name|op_str
operator|=
name|op_print_tab
index|[
name|tem
index|]
operator|.
name|string
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|op_print_tab
index|[
name|tem
index|]
operator|.
name|opcode
operator|!=
name|opcode
condition|)
comment|/* Not found; don't try to keep going because we don't know how 	   to interpret further elements.  */
name|error
argument_list|(
literal|"Invalid expression"
argument_list|)
expr_stmt|;
break|break;
comment|/* C++ ops */
case|case
name|OP_THIS
case|:
operator|++
operator|(
operator|*
name|pos
operator|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"this"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
comment|/* Objective-C ops */
case|case
name|OP_OBJC_SELF
case|:
operator|++
operator|(
operator|*
name|pos
operator|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"self"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* The ObjC equivalent of "this".  */
return|return;
comment|/* Modula-2 ops */
case|case
name|MULTI_SUBSCRIPT
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|nargs
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_SUFFIX
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
literal|" ["
argument_list|)
expr_stmt|;
for|for
control|(
name|tem
operator|=
literal|0
init|;
name|tem
operator|<
name|nargs
condition|;
name|tem
operator|++
control|)
block|{
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_ABOVE_COMMA
argument_list|)
expr_stmt|;
block|}
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
return|return;
case|case
name|BINOP_VAL
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
literal|"VAL("
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_PREFIX
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
return|return;
case|case
name|BINOP_INCL
case|:
case|case
name|BINOP_EXCL
case|:
name|error
argument_list|(
literal|"print_subexp:  Not implemented."
argument_list|)
expr_stmt|;
comment|/* Default ops */
default|default:
name|op_str
operator|=
literal|"???"
expr_stmt|;
for|for
control|(
name|tem
operator|=
literal|0
init|;
name|op_print_tab
index|[
name|tem
index|]
operator|.
name|opcode
operator|!=
name|OP_NULL
condition|;
name|tem
operator|++
control|)
if|if
condition|(
name|op_print_tab
index|[
name|tem
index|]
operator|.
name|opcode
operator|==
name|opcode
condition|)
block|{
name|op_str
operator|=
name|op_print_tab
index|[
name|tem
index|]
operator|.
name|string
expr_stmt|;
name|myprec
operator|=
name|op_print_tab
index|[
name|tem
index|]
operator|.
name|precedence
expr_stmt|;
name|assoc
operator|=
name|op_print_tab
index|[
name|tem
index|]
operator|.
name|right_assoc
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|op_print_tab
index|[
name|tem
index|]
operator|.
name|opcode
operator|!=
name|opcode
condition|)
comment|/* Not found; don't try to keep going because we don't know how 	   to interpret further elements.  For example, this happens 	   if opcode is OP_TYPE.  */
name|error
argument_list|(
literal|"Invalid expression"
argument_list|)
expr_stmt|;
block|}
comment|/* Note that PREC_BUILTIN will always emit parentheses. */
if|if
condition|(
operator|(
name|int
operator|)
name|myprec
operator|<
operator|(
name|int
operator|)
name|prec
condition|)
name|fputs_filtered
argument_list|(
literal|"("
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|opcode
operator|>
operator|(
name|int
operator|)
name|BINOP_END
condition|)
block|{
if|if
condition|(
name|assoc
condition|)
block|{
comment|/* Unary postfix operator.  */
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_SUFFIX
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|op_str
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Unary prefix operator.  */
name|fputs_filtered
argument_list|(
name|op_str
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|myprec
operator|==
name|PREC_BUILTIN_FUNCTION
condition|)
name|fputs_filtered
argument_list|(
literal|"("
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_PREFIX
argument_list|)
expr_stmt|;
if|if
condition|(
name|myprec
operator|==
name|PREC_BUILTIN_FUNCTION
condition|)
name|fputs_filtered
argument_list|(
literal|")"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Binary operator.  */
comment|/* Print left operand.          If operator is right-associative,          increment precedence for this operand.  */
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
operator|(
expr|enum
name|precedence
operator|)
operator|(
operator|(
name|int
operator|)
name|myprec
operator|+
name|assoc
operator|)
argument_list|)
expr_stmt|;
comment|/* Print the operator itself.  */
if|if
condition|(
name|assign_modify
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" %s= "
argument_list|,
name|op_str
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|op_str
index|[
literal|0
index|]
operator|==
literal|','
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s "
argument_list|,
name|op_str
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" %s "
argument_list|,
name|op_str
argument_list|)
expr_stmt|;
comment|/* Print right operand.          If operator is left-associative,          increment precedence for this operand.  */
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
operator|(
expr|enum
name|precedence
operator|)
operator|(
operator|(
name|int
operator|)
name|myprec
operator|+
operator|!
name|assoc
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|int
operator|)
name|myprec
operator|<
operator|(
name|int
operator|)
name|prec
condition|)
name|fputs_filtered
argument_list|(
literal|")"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the operator corresponding to opcode OP as    a string.   NULL indicates that the opcode was not found in the    current language table.  */
end_comment

begin_function
name|char
modifier|*
name|op_string
parameter_list|(
name|enum
name|exp_opcode
name|op
parameter_list|)
block|{
name|int
name|tem
decl_stmt|;
specifier|const
name|struct
name|op_print
modifier|*
name|op_print_tab
decl_stmt|;
name|op_print_tab
operator|=
name|current_language
operator|->
name|la_op_print_tab
expr_stmt|;
for|for
control|(
name|tem
operator|=
literal|0
init|;
name|op_print_tab
index|[
name|tem
index|]
operator|.
name|opcode
operator|!=
name|OP_NULL
condition|;
name|tem
operator|++
control|)
if|if
condition|(
name|op_print_tab
index|[
name|tem
index|]
operator|.
name|opcode
operator|==
name|op
condition|)
return|return
name|op_print_tab
index|[
name|tem
index|]
operator|.
name|string
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Support for dumping the raw data from expressions in a human readable    form.  */
end_comment

begin_function_decl
specifier|static
name|char
modifier|*
name|op_name
parameter_list|(
name|struct
name|expression
modifier|*
parameter_list|,
name|enum
name|exp_opcode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dump_subexp_body
parameter_list|(
name|struct
name|expression
modifier|*
name|exp
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Name for OPCODE, when it appears in expression EXP. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|op_name
parameter_list|(
name|struct
name|expression
modifier|*
name|exp
parameter_list|,
name|enum
name|exp_opcode
name|opcode
parameter_list|)
block|{
return|return
name|exp
operator|->
name|language_defn
operator|->
name|la_exp_desc
operator|->
name|op_name
argument_list|(
name|opcode
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Default name for the standard operator OPCODE (i.e., one defined in    the definition of enum exp_opcode).  */
end_comment

begin_function
name|char
modifier|*
name|op_name_standard
parameter_list|(
name|enum
name|exp_opcode
name|opcode
parameter_list|)
block|{
switch|switch
condition|(
name|opcode
condition|)
block|{
default|default:
block|{
specifier|static
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"<unknown %d>"
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
case|case
name|OP_NULL
case|:
return|return
literal|"OP_NULL"
return|;
case|case
name|BINOP_ADD
case|:
return|return
literal|"BINOP_ADD"
return|;
case|case
name|BINOP_SUB
case|:
return|return
literal|"BINOP_SUB"
return|;
case|case
name|BINOP_MUL
case|:
return|return
literal|"BINOP_MUL"
return|;
case|case
name|BINOP_DIV
case|:
return|return
literal|"BINOP_DIV"
return|;
case|case
name|BINOP_REM
case|:
return|return
literal|"BINOP_REM"
return|;
case|case
name|BINOP_MOD
case|:
return|return
literal|"BINOP_MOD"
return|;
case|case
name|BINOP_LSH
case|:
return|return
literal|"BINOP_LSH"
return|;
case|case
name|BINOP_RSH
case|:
return|return
literal|"BINOP_RSH"
return|;
case|case
name|BINOP_LOGICAL_AND
case|:
return|return
literal|"BINOP_LOGICAL_AND"
return|;
case|case
name|BINOP_LOGICAL_OR
case|:
return|return
literal|"BINOP_LOGICAL_OR"
return|;
case|case
name|BINOP_BITWISE_AND
case|:
return|return
literal|"BINOP_BITWISE_AND"
return|;
case|case
name|BINOP_BITWISE_IOR
case|:
return|return
literal|"BINOP_BITWISE_IOR"
return|;
case|case
name|BINOP_BITWISE_XOR
case|:
return|return
literal|"BINOP_BITWISE_XOR"
return|;
case|case
name|BINOP_EQUAL
case|:
return|return
literal|"BINOP_EQUAL"
return|;
case|case
name|BINOP_NOTEQUAL
case|:
return|return
literal|"BINOP_NOTEQUAL"
return|;
case|case
name|BINOP_LESS
case|:
return|return
literal|"BINOP_LESS"
return|;
case|case
name|BINOP_GTR
case|:
return|return
literal|"BINOP_GTR"
return|;
case|case
name|BINOP_LEQ
case|:
return|return
literal|"BINOP_LEQ"
return|;
case|case
name|BINOP_GEQ
case|:
return|return
literal|"BINOP_GEQ"
return|;
case|case
name|BINOP_REPEAT
case|:
return|return
literal|"BINOP_REPEAT"
return|;
case|case
name|BINOP_ASSIGN
case|:
return|return
literal|"BINOP_ASSIGN"
return|;
case|case
name|BINOP_COMMA
case|:
return|return
literal|"BINOP_COMMA"
return|;
case|case
name|BINOP_SUBSCRIPT
case|:
return|return
literal|"BINOP_SUBSCRIPT"
return|;
case|case
name|MULTI_SUBSCRIPT
case|:
return|return
literal|"MULTI_SUBSCRIPT"
return|;
case|case
name|BINOP_EXP
case|:
return|return
literal|"BINOP_EXP"
return|;
case|case
name|BINOP_MIN
case|:
return|return
literal|"BINOP_MIN"
return|;
case|case
name|BINOP_MAX
case|:
return|return
literal|"BINOP_MAX"
return|;
case|case
name|STRUCTOP_MEMBER
case|:
return|return
literal|"STRUCTOP_MEMBER"
return|;
case|case
name|STRUCTOP_MPTR
case|:
return|return
literal|"STRUCTOP_MPTR"
return|;
case|case
name|BINOP_INTDIV
case|:
return|return
literal|"BINOP_INTDIV"
return|;
case|case
name|BINOP_ASSIGN_MODIFY
case|:
return|return
literal|"BINOP_ASSIGN_MODIFY"
return|;
case|case
name|BINOP_VAL
case|:
return|return
literal|"BINOP_VAL"
return|;
case|case
name|BINOP_INCL
case|:
return|return
literal|"BINOP_INCL"
return|;
case|case
name|BINOP_EXCL
case|:
return|return
literal|"BINOP_EXCL"
return|;
case|case
name|BINOP_CONCAT
case|:
return|return
literal|"BINOP_CONCAT"
return|;
case|case
name|BINOP_RANGE
case|:
return|return
literal|"BINOP_RANGE"
return|;
case|case
name|BINOP_END
case|:
return|return
literal|"BINOP_END"
return|;
case|case
name|TERNOP_COND
case|:
return|return
literal|"TERNOP_COND"
return|;
case|case
name|TERNOP_SLICE
case|:
return|return
literal|"TERNOP_SLICE"
return|;
case|case
name|TERNOP_SLICE_COUNT
case|:
return|return
literal|"TERNOP_SLICE_COUNT"
return|;
case|case
name|OP_LONG
case|:
return|return
literal|"OP_LONG"
return|;
case|case
name|OP_DOUBLE
case|:
return|return
literal|"OP_DOUBLE"
return|;
case|case
name|OP_VAR_VALUE
case|:
return|return
literal|"OP_VAR_VALUE"
return|;
case|case
name|OP_LAST
case|:
return|return
literal|"OP_LAST"
return|;
case|case
name|OP_REGISTER
case|:
return|return
literal|"OP_REGISTER"
return|;
case|case
name|OP_INTERNALVAR
case|:
return|return
literal|"OP_INTERNALVAR"
return|;
case|case
name|OP_FUNCALL
case|:
return|return
literal|"OP_FUNCALL"
return|;
case|case
name|OP_STRING
case|:
return|return
literal|"OP_STRING"
return|;
case|case
name|OP_BITSTRING
case|:
return|return
literal|"OP_BITSTRING"
return|;
case|case
name|OP_ARRAY
case|:
return|return
literal|"OP_ARRAY"
return|;
case|case
name|UNOP_CAST
case|:
return|return
literal|"UNOP_CAST"
return|;
case|case
name|UNOP_MEMVAL
case|:
return|return
literal|"UNOP_MEMVAL"
return|;
case|case
name|UNOP_NEG
case|:
return|return
literal|"UNOP_NEG"
return|;
case|case
name|UNOP_LOGICAL_NOT
case|:
return|return
literal|"UNOP_LOGICAL_NOT"
return|;
case|case
name|UNOP_COMPLEMENT
case|:
return|return
literal|"UNOP_COMPLEMENT"
return|;
case|case
name|UNOP_IND
case|:
return|return
literal|"UNOP_IND"
return|;
case|case
name|UNOP_ADDR
case|:
return|return
literal|"UNOP_ADDR"
return|;
case|case
name|UNOP_PREINCREMENT
case|:
return|return
literal|"UNOP_PREINCREMENT"
return|;
case|case
name|UNOP_POSTINCREMENT
case|:
return|return
literal|"UNOP_POSTINCREMENT"
return|;
case|case
name|UNOP_PREDECREMENT
case|:
return|return
literal|"UNOP_PREDECREMENT"
return|;
case|case
name|UNOP_POSTDECREMENT
case|:
return|return
literal|"UNOP_POSTDECREMENT"
return|;
case|case
name|UNOP_SIZEOF
case|:
return|return
literal|"UNOP_SIZEOF"
return|;
case|case
name|UNOP_LOWER
case|:
return|return
literal|"UNOP_LOWER"
return|;
case|case
name|UNOP_UPPER
case|:
return|return
literal|"UNOP_UPPER"
return|;
case|case
name|UNOP_LENGTH
case|:
return|return
literal|"UNOP_LENGTH"
return|;
case|case
name|UNOP_PLUS
case|:
return|return
literal|"UNOP_PLUS"
return|;
case|case
name|UNOP_CAP
case|:
return|return
literal|"UNOP_CAP"
return|;
case|case
name|UNOP_CHR
case|:
return|return
literal|"UNOP_CHR"
return|;
case|case
name|UNOP_ORD
case|:
return|return
literal|"UNOP_ORD"
return|;
case|case
name|UNOP_ABS
case|:
return|return
literal|"UNOP_ABS"
return|;
case|case
name|UNOP_FLOAT
case|:
return|return
literal|"UNOP_FLOAT"
return|;
case|case
name|UNOP_HIGH
case|:
return|return
literal|"UNOP_HIGH"
return|;
case|case
name|UNOP_MAX
case|:
return|return
literal|"UNOP_MAX"
return|;
case|case
name|UNOP_MIN
case|:
return|return
literal|"UNOP_MIN"
return|;
case|case
name|UNOP_ODD
case|:
return|return
literal|"UNOP_ODD"
return|;
case|case
name|UNOP_TRUNC
case|:
return|return
literal|"UNOP_TRUNC"
return|;
case|case
name|OP_BOOL
case|:
return|return
literal|"OP_BOOL"
return|;
case|case
name|OP_M2_STRING
case|:
return|return
literal|"OP_M2_STRING"
return|;
case|case
name|STRUCTOP_STRUCT
case|:
return|return
literal|"STRUCTOP_STRUCT"
return|;
case|case
name|STRUCTOP_PTR
case|:
return|return
literal|"STRUCTOP_PTR"
return|;
case|case
name|OP_THIS
case|:
return|return
literal|"OP_THIS"
return|;
case|case
name|OP_OBJC_SELF
case|:
return|return
literal|"OP_OBJC_SELF"
return|;
case|case
name|OP_SCOPE
case|:
return|return
literal|"OP_SCOPE"
return|;
case|case
name|OP_TYPE
case|:
return|return
literal|"OP_TYPE"
return|;
case|case
name|OP_LABELED
case|:
return|return
literal|"OP_LABELED"
return|;
block|}
block|}
end_function

begin_function
name|void
name|dump_raw_expression
parameter_list|(
name|struct
name|expression
modifier|*
name|exp
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|char
modifier|*
name|note
parameter_list|)
block|{
name|int
name|elt
decl_stmt|;
name|char
modifier|*
name|opcode_name
decl_stmt|;
name|char
modifier|*
name|eltscan
decl_stmt|;
name|int
name|eltsize
decl_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"Dump of expression @ "
argument_list|)
expr_stmt|;
name|gdb_print_host_address
argument_list|(
name|exp
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"'\n\tLanguage %s, %d elements, %ld bytes each.\n"
argument_list|,
name|exp
operator|->
name|language_defn
operator|->
name|la_name
argument_list|,
name|exp
operator|->
name|nelts
argument_list|,
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
expr|union
name|exp_element
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\t%5s  %20s  %16s  %s\n"
argument_list|,
literal|"Index"
argument_list|,
literal|"Opcode"
argument_list|,
literal|"Hex Value"
argument_list|,
literal|"String Value"
argument_list|)
expr_stmt|;
for|for
control|(
name|elt
operator|=
literal|0
init|;
name|elt
operator|<
name|exp
operator|->
name|nelts
condition|;
name|elt
operator|++
control|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\t%5d  "
argument_list|,
name|elt
argument_list|)
expr_stmt|;
name|opcode_name
operator|=
name|op_name
argument_list|(
name|exp
argument_list|,
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|.
name|opcode
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%20s  "
argument_list|,
name|opcode_name
argument_list|)
expr_stmt|;
name|print_longest
argument_list|(
name|stream
argument_list|,
literal|'d'
argument_list|,
literal|0
argument_list|,
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"  "
argument_list|)
expr_stmt|;
for|for
control|(
name|eltscan
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|,
name|eltsize
operator|=
sizeof|sizeof
argument_list|(
expr|union
name|exp_element
argument_list|)
init|;
name|eltsize
operator|--
operator|>
literal|0
condition|;
name|eltscan
operator|++
control|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%c"
argument_list|,
name|isprint
argument_list|(
operator|*
name|eltscan
argument_list|)
condition|?
operator|(
operator|*
name|eltscan
operator|&
literal|0xFF
operator|)
else|:
literal|'.'
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Dump the subexpression of prefix expression EXP whose operator is at    position ELT onto STREAM.  Returns the position of the next     subexpression in EXP.  */
end_comment

begin_function
name|int
name|dump_subexp
parameter_list|(
name|struct
name|expression
modifier|*
name|exp
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|elt
parameter_list|)
block|{
specifier|static
name|int
name|indent
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\t%5d  "
argument_list|,
name|elt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|indent
condition|;
name|i
operator|++
control|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|indent
operator|+=
literal|2
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%-20s  "
argument_list|,
name|op_name
argument_list|(
name|exp
argument_list|,
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|.
name|opcode
argument_list|)
argument_list|)
expr_stmt|;
name|elt
operator|=
name|dump_subexp_body
argument_list|(
name|exp
argument_list|,
name|stream
argument_list|,
name|elt
argument_list|)
expr_stmt|;
name|indent
operator|-=
literal|2
expr_stmt|;
return|return
name|elt
return|;
block|}
end_function

begin_comment
comment|/* Dump the operands of prefix expression EXP whose opcode is at    position ELT onto STREAM.  Returns the position of the next     subexpression in EXP.  */
end_comment

begin_function
specifier|static
name|int
name|dump_subexp_body
parameter_list|(
name|struct
name|expression
modifier|*
name|exp
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|elt
parameter_list|)
block|{
return|return
name|exp
operator|->
name|language_defn
operator|->
name|la_exp_desc
operator|->
name|dump_subexp_body
argument_list|(
name|exp
argument_list|,
name|stream
argument_list|,
name|elt
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Default value for subexp_body in exp_descriptor vector.  */
end_comment

begin_function
name|int
name|dump_subexp_body_standard
parameter_list|(
name|struct
name|expression
modifier|*
name|exp
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|elt
parameter_list|)
block|{
name|int
name|opcode
init|=
name|exp
operator|->
name|elts
index|[
name|elt
operator|++
index|]
operator|.
name|opcode
decl_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|TERNOP_COND
case|:
case|case
name|TERNOP_SLICE
case|:
case|case
name|TERNOP_SLICE_COUNT
case|:
name|elt
operator|=
name|dump_subexp
argument_list|(
name|exp
argument_list|,
name|stream
argument_list|,
name|elt
argument_list|)
expr_stmt|;
case|case
name|BINOP_ADD
case|:
case|case
name|BINOP_SUB
case|:
case|case
name|BINOP_MUL
case|:
case|case
name|BINOP_DIV
case|:
case|case
name|BINOP_REM
case|:
case|case
name|BINOP_MOD
case|:
case|case
name|BINOP_LSH
case|:
case|case
name|BINOP_RSH
case|:
case|case
name|BINOP_LOGICAL_AND
case|:
case|case
name|BINOP_LOGICAL_OR
case|:
case|case
name|BINOP_BITWISE_AND
case|:
case|case
name|BINOP_BITWISE_IOR
case|:
case|case
name|BINOP_BITWISE_XOR
case|:
case|case
name|BINOP_EQUAL
case|:
case|case
name|BINOP_NOTEQUAL
case|:
case|case
name|BINOP_LESS
case|:
case|case
name|BINOP_GTR
case|:
case|case
name|BINOP_LEQ
case|:
case|case
name|BINOP_GEQ
case|:
case|case
name|BINOP_REPEAT
case|:
case|case
name|BINOP_ASSIGN
case|:
case|case
name|BINOP_COMMA
case|:
case|case
name|BINOP_SUBSCRIPT
case|:
case|case
name|BINOP_EXP
case|:
case|case
name|BINOP_MIN
case|:
case|case
name|BINOP_MAX
case|:
case|case
name|BINOP_INTDIV
case|:
case|case
name|BINOP_ASSIGN_MODIFY
case|:
case|case
name|BINOP_VAL
case|:
case|case
name|BINOP_INCL
case|:
case|case
name|BINOP_EXCL
case|:
case|case
name|BINOP_CONCAT
case|:
case|case
name|BINOP_IN
case|:
case|case
name|BINOP_RANGE
case|:
case|case
name|BINOP_END
case|:
name|elt
operator|=
name|dump_subexp
argument_list|(
name|exp
argument_list|,
name|stream
argument_list|,
name|elt
argument_list|)
expr_stmt|;
case|case
name|UNOP_NEG
case|:
case|case
name|UNOP_LOGICAL_NOT
case|:
case|case
name|UNOP_COMPLEMENT
case|:
case|case
name|UNOP_IND
case|:
case|case
name|UNOP_ADDR
case|:
case|case
name|UNOP_PREINCREMENT
case|:
case|case
name|UNOP_POSTINCREMENT
case|:
case|case
name|UNOP_PREDECREMENT
case|:
case|case
name|UNOP_POSTDECREMENT
case|:
case|case
name|UNOP_SIZEOF
case|:
case|case
name|UNOP_PLUS
case|:
case|case
name|UNOP_CAP
case|:
case|case
name|UNOP_CHR
case|:
case|case
name|UNOP_ORD
case|:
case|case
name|UNOP_ABS
case|:
case|case
name|UNOP_FLOAT
case|:
case|case
name|UNOP_HIGH
case|:
case|case
name|UNOP_MAX
case|:
case|case
name|UNOP_MIN
case|:
case|case
name|UNOP_ODD
case|:
case|case
name|UNOP_TRUNC
case|:
case|case
name|UNOP_LOWER
case|:
case|case
name|UNOP_UPPER
case|:
case|case
name|UNOP_LENGTH
case|:
case|case
name|UNOP_CARD
case|:
case|case
name|UNOP_CHMAX
case|:
case|case
name|UNOP_CHMIN
case|:
name|elt
operator|=
name|dump_subexp
argument_list|(
name|exp
argument_list|,
name|stream
argument_list|,
name|elt
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_LONG
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"Type @"
argument_list|)
expr_stmt|;
name|gdb_print_host_address
argument_list|(
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|.
name|type
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|.
name|type
argument_list|,
name|NULL
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"), value %ld (0x%lx)"
argument_list|,
operator|(
name|long
operator|)
name|exp
operator|->
name|elts
index|[
name|elt
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|,
operator|(
name|long
operator|)
name|exp
operator|->
name|elts
index|[
name|elt
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|elt
operator|+=
literal|3
expr_stmt|;
break|break;
case|case
name|OP_DOUBLE
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"Type @"
argument_list|)
expr_stmt|;
name|gdb_print_host_address
argument_list|(
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|.
name|type
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|.
name|type
argument_list|,
name|NULL
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"), value %g"
argument_list|,
operator|(
name|double
operator|)
name|exp
operator|->
name|elts
index|[
name|elt
operator|+
literal|1
index|]
operator|.
name|doubleconst
argument_list|)
expr_stmt|;
name|elt
operator|+=
literal|3
expr_stmt|;
break|break;
case|case
name|OP_VAR_VALUE
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"Block @"
argument_list|)
expr_stmt|;
name|gdb_print_host_address
argument_list|(
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|.
name|block
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", symbol @"
argument_list|)
expr_stmt|;
name|gdb_print_host_address
argument_list|(
name|exp
operator|->
name|elts
index|[
name|elt
operator|+
literal|1
index|]
operator|.
name|symbol
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" (%s)"
argument_list|,
name|DEPRECATED_SYMBOL_NAME
argument_list|(
name|exp
operator|->
name|elts
index|[
name|elt
operator|+
literal|1
index|]
operator|.
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|elt
operator|+=
literal|3
expr_stmt|;
break|break;
case|case
name|OP_LAST
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"History element %ld"
argument_list|,
operator|(
name|long
operator|)
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|elt
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|OP_REGISTER
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"Register %ld"
argument_list|,
operator|(
name|long
operator|)
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|elt
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|OP_INTERNALVAR
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"Internal var @"
argument_list|)
expr_stmt|;
name|gdb_print_host_address
argument_list|(
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|.
name|internalvar
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" (%s)"
argument_list|,
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|.
name|internalvar
operator|->
name|name
argument_list|)
expr_stmt|;
name|elt
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|OP_FUNCALL
case|:
block|{
name|int
name|i
decl_stmt|,
name|nargs
decl_stmt|;
name|nargs
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"Number of args: %d"
argument_list|,
name|nargs
argument_list|)
expr_stmt|;
name|elt
operator|+=
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nargs
operator|+
literal|1
condition|;
name|i
operator|++
control|)
name|elt
operator|=
name|dump_subexp
argument_list|(
name|exp
argument_list|,
name|stream
argument_list|,
name|elt
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_ARRAY
case|:
block|{
name|int
name|lower
decl_stmt|,
name|upper
decl_stmt|;
name|int
name|i
decl_stmt|;
name|lower
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|upper
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|elt
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"Bounds [%d:%d]"
argument_list|,
name|lower
argument_list|,
name|upper
argument_list|)
expr_stmt|;
name|elt
operator|+=
literal|3
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|upper
operator|-
name|lower
operator|+
literal|1
condition|;
name|i
operator|++
control|)
name|elt
operator|=
name|dump_subexp
argument_list|(
name|exp
argument_list|,
name|stream
argument_list|,
name|elt
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|UNOP_MEMVAL
case|:
case|case
name|UNOP_CAST
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"Type @"
argument_list|)
expr_stmt|;
name|gdb_print_host_address
argument_list|(
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|.
name|type
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|.
name|type
argument_list|,
name|NULL
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|elt
operator|=
name|dump_subexp
argument_list|(
name|exp
argument_list|,
name|stream
argument_list|,
name|elt
operator|+
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_TYPE
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"Type @"
argument_list|)
expr_stmt|;
name|gdb_print_host_address
argument_list|(
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|.
name|type
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|.
name|type
argument_list|,
name|NULL
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|elt
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|STRUCTOP_STRUCT
case|:
case|case
name|STRUCTOP_PTR
case|:
block|{
name|char
modifier|*
name|elem_name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|elem_name
operator|=
operator|&
name|exp
operator|->
name|elts
index|[
name|elt
operator|+
literal|1
index|]
operator|.
name|string
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"Element name: `%.*s'"
argument_list|,
name|len
argument_list|,
name|elem_name
argument_list|)
expr_stmt|;
name|elt
operator|=
name|dump_subexp
argument_list|(
name|exp
argument_list|,
name|stream
argument_list|,
name|elt
operator|+
literal|3
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|len
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_SCOPE
case|:
block|{
name|char
modifier|*
name|elem_name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"Type @"
argument_list|)
expr_stmt|;
name|gdb_print_host_address
argument_list|(
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|.
name|type
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" ("
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|.
name|type
argument_list|,
name|NULL
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|") "
argument_list|)
expr_stmt|;
name|len
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|elt
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|elem_name
operator|=
operator|&
name|exp
operator|->
name|elts
index|[
name|elt
operator|+
literal|2
index|]
operator|.
name|string
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"Field name: `%.*s'"
argument_list|,
name|len
argument_list|,
name|elem_name
argument_list|)
expr_stmt|;
name|elt
operator|+=
literal|4
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
case|case
name|OP_NULL
case|:
case|case
name|STRUCTOP_MEMBER
case|:
case|case
name|STRUCTOP_MPTR
case|:
case|case
name|MULTI_SUBSCRIPT
case|:
case|case
name|OP_F77_UNDETERMINED_ARGLIST
case|:
case|case
name|OP_COMPLEX
case|:
case|case
name|OP_STRING
case|:
case|case
name|OP_BITSTRING
case|:
case|case
name|OP_BOOL
case|:
case|case
name|OP_M2_STRING
case|:
case|case
name|OP_THIS
case|:
case|case
name|OP_LABELED
case|:
case|case
name|OP_NAME
case|:
case|case
name|OP_EXPRSTRING
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"Unknown format"
argument_list|)
expr_stmt|;
block|}
return|return
name|elt
return|;
block|}
end_function

begin_function
name|void
name|dump_prefix_expression
parameter_list|(
name|struct
name|expression
modifier|*
name|exp
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|int
name|elt
decl_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"Dump of expression @ "
argument_list|)
expr_stmt|;
name|gdb_print_host_address
argument_list|(
name|exp
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|", after conversion to prefix form:\nExpression: `"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|elts
index|[
literal|0
index|]
operator|.
name|opcode
operator|!=
name|OP_TYPE
condition|)
name|print_expression
argument_list|(
name|exp
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|"Type printing not yet supported...."
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"'\n\tLanguage %s, %d elements, %ld bytes each.\n"
argument_list|,
name|exp
operator|->
name|language_defn
operator|->
name|la_name
argument_list|,
name|exp
operator|->
name|nelts
argument_list|,
operator|(
name|long
operator|)
sizeof|sizeof
argument_list|(
expr|union
name|exp_element
argument_list|)
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
for|for
control|(
name|elt
operator|=
literal|0
init|;
name|elt
operator|<
name|exp
operator|->
name|nelts
condition|;
control|)
name|elt
operator|=
name|dump_subexp
argument_list|(
name|exp
argument_list|,
name|stream
argument_list|,
name|elt
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

