begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Print in infix form a struct expression.    Copyright (C) 1986, 1989, 1991 Free Software Foundation, Inc.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"parser-defs.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CTYPE_H
end_ifdef

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Prototypes for local functions */
end_comment

begin_decl_stmt
specifier|static
name|void
name|print_subexp
name|PARAMS
argument_list|(
operator|(
expr|struct
name|expression
operator|*
operator|,
name|int
operator|*
operator|,
name|GDB_FILE
operator|*
operator|,
expr|enum
name|precedence
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|print_expression
parameter_list|(
name|exp
parameter_list|,
name|stream
parameter_list|)
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
block|{
name|int
name|pc
init|=
literal|0
decl_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
operator|&
name|pc
argument_list|,
name|stream
argument_list|,
name|PREC_NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the subexpression of EXP that starts in position POS, on STREAM.    PREC is the precedence of the surrounding operator;    if the precedence of the main operator of this subexpression is less,    parentheses are needed here.  */
end_comment

begin_function
specifier|static
name|void
name|print_subexp
parameter_list|(
name|exp
parameter_list|,
name|pos
parameter_list|,
name|stream
parameter_list|,
name|prec
parameter_list|)
specifier|register
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
specifier|register
name|int
modifier|*
name|pos
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|enum
name|precedence
name|prec
decl_stmt|;
block|{
specifier|register
name|unsigned
name|tem
decl_stmt|;
specifier|register
specifier|const
name|struct
name|op_print
modifier|*
name|op_print_tab
decl_stmt|;
specifier|register
name|int
name|pc
decl_stmt|;
name|unsigned
name|nargs
decl_stmt|;
specifier|register
name|char
modifier|*
name|op_str
decl_stmt|;
name|int
name|assign_modify
init|=
literal|0
decl_stmt|;
name|enum
name|exp_opcode
name|opcode
decl_stmt|;
name|enum
name|precedence
name|myprec
init|=
name|PREC_NULL
decl_stmt|;
comment|/* Set to 1 for a right-associative operator.  */
name|int
name|assoc
init|=
literal|0
decl_stmt|;
name|value_ptr
name|val
decl_stmt|;
name|char
modifier|*
name|tempstr
init|=
name|NULL
decl_stmt|;
name|op_print_tab
operator|=
name|exp
operator|->
name|language_defn
operator|->
name|la_op_print_tab
expr_stmt|;
name|pc
operator|=
operator|(
operator|*
name|pos
operator|)
operator|++
expr_stmt|;
name|opcode
operator|=
name|exp
operator|->
name|elts
index|[
name|pc
index|]
operator|.
name|opcode
expr_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
comment|/* Common ops */
case|case
name|OP_SCOPE
case|:
name|myprec
operator|=
name|PREC_PREFIX
expr_stmt|;
name|assoc
operator|=
literal|0
expr_stmt|;
name|fputs_filtered
argument_list|(
name|type_name_no_tag
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"::"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|nargs
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|4
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|nargs
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|3
index|]
operator|.
name|string
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|OP_LONG
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
expr_stmt|;
name|value_print
argument_list|(
name|value_from_longest
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|,
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|longconst
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|Val_no_prettyprint
argument_list|)
expr_stmt|;
return|return;
case|case
name|OP_DOUBLE
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
expr_stmt|;
name|value_print
argument_list|(
name|value_from_double
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|,
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|doubleconst
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|Val_no_prettyprint
argument_list|)
expr_stmt|;
return|return;
case|case
name|OP_VAR_VALUE
case|:
block|{
name|struct
name|block
modifier|*
name|b
decl_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
expr_stmt|;
name|b
operator|=
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|block
expr_stmt|;
if|if
condition|(
name|b
operator|!=
name|NULL
operator|&&
name|BLOCK_FUNCTION
argument_list|(
name|b
argument_list|)
operator|!=
name|NULL
operator|&&
name|SYMBOL_SOURCE_NAME
argument_list|(
name|BLOCK_FUNCTION
argument_list|(
name|b
argument_list|)
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|fputs_filtered
argument_list|(
name|SYMBOL_SOURCE_NAME
argument_list|(
name|BLOCK_FUNCTION
argument_list|(
name|b
argument_list|)
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"::"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
name|SYMBOL_SOURCE_NAME
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|symbol
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|OP_LAST
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"$%d"
argument_list|,
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|OP_REGISTER
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"$%s"
argument_list|,
name|REGISTER_NAME
argument_list|(
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|OP_BOOL
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s"
argument_list|,
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
condition|?
literal|"TRUE"
else|:
literal|"FALSE"
argument_list|)
expr_stmt|;
return|return;
case|case
name|OP_INTERNALVAR
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"$%s"
argument_list|,
name|internalvar_name
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|internalvar
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|OP_FUNCALL
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|nargs
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_SUFFIX
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" ("
argument_list|,
name|stream
argument_list|)
expr_stmt|;
for|for
control|(
name|tem
operator|=
literal|0
init|;
name|tem
operator|<
name|nargs
condition|;
name|tem
operator|++
control|)
block|{
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
name|fputs_filtered
argument_list|(
literal|", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_ABOVE_COMMA
argument_list|)
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
literal|")"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|OP_NAME
case|:
case|case
name|OP_EXPRSTRING
case|:
name|nargs
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|nargs
operator|+
literal|1
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|OP_STRING
case|:
name|nargs
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|nargs
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* LA_PRINT_STRING will print using the current repeat count threshold. 	 If necessary, we can temporarily set it to zero, or pass it as an 	 additional parameter to LA_PRINT_STRING.  -fnf */
name|LA_PRINT_STRING
argument_list|(
name|stream
argument_list|,
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
argument_list|,
name|nargs
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
case|case
name|OP_BITSTRING
case|:
name|nargs
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
operator|(
name|nargs
operator|+
name|HOST_CHAR_BIT
operator|-
literal|1
operator|)
operator|/
name|HOST_CHAR_BIT
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
literal|"B'<unimplemented>'"
argument_list|)
expr_stmt|;
return|return;
case|case
name|OP_ARRAY
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
expr_stmt|;
name|nargs
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|nargs
operator|-=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|nargs
operator|++
expr_stmt|;
name|tem
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|4
index|]
operator|.
name|opcode
operator|==
name|OP_LONG
operator|&&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|5
index|]
operator|.
name|type
operator|==
name|builtin_type_char
operator|&&
name|exp
operator|->
name|language_defn
operator|->
name|la_language
operator|==
name|language_c
condition|)
block|{
comment|/* Attempt to print C character arrays using string syntax. 	     Walk through the args, picking up one character from each 	     of the OP_LONG expression elements.  If any array element 	     does not match our expection of what we should find for 	     a simple string, revert back to array printing.  Note that 	     the last expression element is an explicit null terminator 	     byte, which doesn't get printed. */
name|tempstr
operator|=
name|alloca
argument_list|(
name|nargs
argument_list|)
expr_stmt|;
name|pc
operator|+=
literal|4
expr_stmt|;
while|while
condition|(
name|tem
operator|<
name|nargs
condition|)
block|{
if|if
condition|(
name|exp
operator|->
name|elts
index|[
name|pc
index|]
operator|.
name|opcode
operator|!=
name|OP_LONG
operator|||
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
operator|!=
name|builtin_type_char
condition|)
block|{
comment|/* Not a simple array of char, use regular array printing. */
name|tem
operator|=
literal|0
expr_stmt|;
break|break;
block|}
else|else
block|{
name|tempstr
index|[
name|tem
operator|++
index|]
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|pc
operator|+=
literal|4
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|tem
operator|>
literal|0
condition|)
block|{
name|LA_PRINT_STRING
argument_list|(
name|stream
argument_list|,
name|tempstr
argument_list|,
name|nargs
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|=
name|pc
expr_stmt|;
block|}
else|else
block|{
name|int
name|is_chill
init|=
name|exp
operator|->
name|language_defn
operator|->
name|la_language
operator|==
name|language_chill
decl_stmt|;
name|fputs_filtered
argument_list|(
name|is_chill
condition|?
literal|" ["
else|:
literal|" {"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
for|for
control|(
name|tem
operator|=
literal|0
init|;
name|tem
operator|<
name|nargs
condition|;
name|tem
operator|++
control|)
block|{
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_ABOVE_COMMA
argument_list|)
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
name|is_chill
condition|?
literal|"]"
else|:
literal|"}"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|OP_LABELED
case|:
name|tem
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|tem
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|language_defn
operator|->
name|la_language
operator|==
name|language_chill
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"."
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|exp
operator|->
name|elts
index|[
operator|*
name|pos
index|]
operator|.
name|opcode
operator|==
name|OP_LABELED
condition|?
literal|", "
else|:
literal|": "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Gcc support both these syntaxes.  Unsure which is preferred.  */
if|#
directive|if
literal|1
name|fputs_filtered
argument_list|(
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|": "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|#
directive|else
name|fputs_filtered
argument_list|(
literal|"."
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"="
argument_list|,
name|stream
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_SUFFIX
argument_list|)
expr_stmt|;
return|return;
case|case
name|TERNOP_COND
case|:
if|if
condition|(
operator|(
name|int
operator|)
name|prec
operator|>
operator|(
name|int
operator|)
name|PREC_COMMA
condition|)
name|fputs_filtered
argument_list|(
literal|"("
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* Print the subexpressions, forcing parentheses 	 around any binary operations within them. 	 This is more parentheses than are strictly necessary, 	 but it looks clearer.  */
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_HYPER
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" ? "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_HYPER
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" : "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_HYPER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|prec
operator|>
operator|(
name|int
operator|)
name|PREC_COMMA
condition|)
name|fputs_filtered
argument_list|(
literal|")"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|TERNOP_SLICE
case|:
case|case
name|TERNOP_SLICE_COUNT
case|:
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_SUFFIX
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"("
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_ABOVE_COMMA
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|opcode
operator|==
name|TERNOP_SLICE
condition|?
literal|" : "
else|:
literal|" UP "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_ABOVE_COMMA
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|")"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|STRUCTOP_STRUCT
case|:
name|tem
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|tem
operator|+
literal|1
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_SUFFIX
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"."
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
comment|/* Will not occur for Modula-2 */
case|case
name|STRUCTOP_PTR
case|:
name|tem
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|3
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|tem
operator|+
literal|1
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_SUFFIX
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"->"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
operator|&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|2
index|]
operator|.
name|string
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|BINOP_SUBSCRIPT
case|:
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_SUFFIX
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"["
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_ABOVE_COMMA
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"]"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNOP_POSTINCREMENT
case|:
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_SUFFIX
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"++"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNOP_POSTDECREMENT
case|:
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_SUFFIX
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"--"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNOP_CAST
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|prec
operator|>
operator|(
name|int
operator|)
name|PREC_PREFIX
condition|)
name|fputs_filtered
argument_list|(
literal|"("
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"("
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|") "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_PREFIX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|prec
operator|>
operator|(
name|int
operator|)
name|PREC_PREFIX
condition|)
name|fputs_filtered
argument_list|(
literal|")"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNOP_MEMVAL
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|prec
operator|>
operator|(
name|int
operator|)
name|PREC_PREFIX
condition|)
name|fputs_filtered
argument_list|(
literal|"("
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
operator|->
name|code
operator|==
name|TYPE_CODE_FUNC
operator|&&
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|3
index|]
operator|.
name|opcode
operator|==
name|OP_LONG
condition|)
block|{
comment|/* We have a minimal symbol fn, probably.  It's encoded 	   as a UNOP_MEMVAL (function-type) of an OP_LONG (int, address). 	   Swallow the OP_LONG (including both its opcodes); ignore 	   its type; print the value in the type of the MEMVAL.  */
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|4
expr_stmt|;
name|val
operator|=
name|value_at_lazy
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|,
operator|(
name|CORE_ADDR
operator|)
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|5
index|]
operator|.
name|longconst
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|value_print
argument_list|(
name|val
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|Val_no_prettyprint
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fputs_filtered
argument_list|(
literal|"{"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"} "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_PREFIX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|int
operator|)
name|prec
operator|>
operator|(
name|int
operator|)
name|PREC_PREFIX
condition|)
name|fputs_filtered
argument_list|(
literal|")"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
case|case
name|BINOP_ASSIGN_MODIFY
case|:
name|opcode
operator|=
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|opcode
expr_stmt|;
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|myprec
operator|=
name|PREC_ASSIGN
expr_stmt|;
name|assoc
operator|=
literal|1
expr_stmt|;
name|assign_modify
operator|=
literal|1
expr_stmt|;
name|op_str
operator|=
literal|"???"
expr_stmt|;
for|for
control|(
name|tem
operator|=
literal|0
init|;
name|op_print_tab
index|[
name|tem
index|]
operator|.
name|opcode
operator|!=
name|OP_NULL
condition|;
name|tem
operator|++
control|)
if|if
condition|(
name|op_print_tab
index|[
name|tem
index|]
operator|.
name|opcode
operator|==
name|opcode
condition|)
block|{
name|op_str
operator|=
name|op_print_tab
index|[
name|tem
index|]
operator|.
name|string
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|op_print_tab
index|[
name|tem
index|]
operator|.
name|opcode
operator|!=
name|opcode
condition|)
comment|/* Not found; don't try to keep going because we don't know how 	   to interpret further elements.  */
name|error
argument_list|(
literal|"Invalid expression"
argument_list|)
expr_stmt|;
break|break;
comment|/* C++ ops */
case|case
name|OP_THIS
case|:
operator|++
operator|(
operator|*
name|pos
operator|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"this"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
comment|/* Modula-2 ops */
case|case
name|MULTI_SUBSCRIPT
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|nargs
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_SUFFIX
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
literal|" ["
argument_list|)
expr_stmt|;
for|for
control|(
name|tem
operator|=
literal|0
init|;
name|tem
operator|<
name|nargs
condition|;
name|tem
operator|++
control|)
block|{
if|if
condition|(
name|tem
operator|!=
literal|0
condition|)
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_ABOVE_COMMA
argument_list|)
expr_stmt|;
block|}
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
return|return;
case|case
name|BINOP_VAL
case|:
operator|(
operator|*
name|pos
operator|)
operator|+=
literal|2
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
literal|"VAL("
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|exp
operator|->
name|elts
index|[
name|pc
operator|+
literal|1
index|]
operator|.
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_PREFIX
argument_list|)
expr_stmt|;
name|fprintf_unfiltered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
return|return;
case|case
name|BINOP_INCL
case|:
case|case
name|BINOP_EXCL
case|:
name|error
argument_list|(
literal|"print_subexp:  Not implemented."
argument_list|)
expr_stmt|;
comment|/* Default ops */
default|default:
name|op_str
operator|=
literal|"???"
expr_stmt|;
for|for
control|(
name|tem
operator|=
literal|0
init|;
name|op_print_tab
index|[
name|tem
index|]
operator|.
name|opcode
operator|!=
name|OP_NULL
condition|;
name|tem
operator|++
control|)
if|if
condition|(
name|op_print_tab
index|[
name|tem
index|]
operator|.
name|opcode
operator|==
name|opcode
condition|)
block|{
name|op_str
operator|=
name|op_print_tab
index|[
name|tem
index|]
operator|.
name|string
expr_stmt|;
name|myprec
operator|=
name|op_print_tab
index|[
name|tem
index|]
operator|.
name|precedence
expr_stmt|;
name|assoc
operator|=
name|op_print_tab
index|[
name|tem
index|]
operator|.
name|right_assoc
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|op_print_tab
index|[
name|tem
index|]
operator|.
name|opcode
operator|!=
name|opcode
condition|)
comment|/* Not found; don't try to keep going because we don't know how 	   to interpret further elements.  For example, this happens 	   if opcode is OP_TYPE.  */
name|error
argument_list|(
literal|"Invalid expression"
argument_list|)
expr_stmt|;
block|}
comment|/* Note that PREC_BUILTIN will always emit parentheses. */
if|if
condition|(
operator|(
name|int
operator|)
name|myprec
operator|<
operator|(
name|int
operator|)
name|prec
condition|)
name|fputs_filtered
argument_list|(
literal|"("
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|opcode
operator|>
operator|(
name|int
operator|)
name|BINOP_END
condition|)
block|{
if|if
condition|(
name|assoc
condition|)
block|{
comment|/* Unary postfix operator.  */
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_SUFFIX
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|op_str
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Unary prefix operator.  */
name|fputs_filtered
argument_list|(
name|op_str
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|myprec
operator|==
name|PREC_BUILTIN_FUNCTION
condition|)
name|fputs_filtered
argument_list|(
literal|"("
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
name|PREC_PREFIX
argument_list|)
expr_stmt|;
if|if
condition|(
name|myprec
operator|==
name|PREC_BUILTIN_FUNCTION
condition|)
name|fputs_filtered
argument_list|(
literal|")"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Binary operator.  */
comment|/* Print left operand. 	 If operator is right-associative, 	 increment precedence for this operand.  */
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
operator|(
expr|enum
name|precedence
operator|)
operator|(
operator|(
name|int
operator|)
name|myprec
operator|+
name|assoc
operator|)
argument_list|)
expr_stmt|;
comment|/* Print the operator itself.  */
if|if
condition|(
name|assign_modify
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" %s= "
argument_list|,
name|op_str
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|op_str
index|[
literal|0
index|]
operator|==
literal|','
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s "
argument_list|,
name|op_str
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" %s "
argument_list|,
name|op_str
argument_list|)
expr_stmt|;
comment|/* Print right operand. 	 If operator is left-associative, 	 increment precedence for this operand.  */
name|print_subexp
argument_list|(
name|exp
argument_list|,
name|pos
argument_list|,
name|stream
argument_list|,
operator|(
expr|enum
name|precedence
operator|)
operator|(
operator|(
name|int
operator|)
name|myprec
operator|+
operator|!
name|assoc
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|int
operator|)
name|myprec
operator|<
operator|(
name|int
operator|)
name|prec
condition|)
name|fputs_filtered
argument_list|(
literal|")"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the operator corresponding to opcode OP as    a string.   NULL indicates that the opcode was not found in the    current language table.  */
end_comment

begin_function
name|char
modifier|*
name|op_string
parameter_list|(
name|op
parameter_list|)
name|enum
name|exp_opcode
name|op
decl_stmt|;
block|{
name|int
name|tem
decl_stmt|;
specifier|register
specifier|const
name|struct
name|op_print
modifier|*
name|op_print_tab
decl_stmt|;
name|op_print_tab
operator|=
name|current_language
operator|->
name|la_op_print_tab
expr_stmt|;
for|for
control|(
name|tem
operator|=
literal|0
init|;
name|op_print_tab
index|[
name|tem
index|]
operator|.
name|opcode
operator|!=
name|OP_NULL
condition|;
name|tem
operator|++
control|)
if|if
condition|(
name|op_print_tab
index|[
name|tem
index|]
operator|.
name|opcode
operator|==
name|op
condition|)
return|return
name|op_print_tab
index|[
name|tem
index|]
operator|.
name|string
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MAINTENANCE_CMDS
end_ifdef

begin_comment
comment|/* Support for dumping the raw data from expressions in a human readable    form.  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|op_name
name|PARAMS
argument_list|(
operator|(
name|int
name|opcode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|op_name
parameter_list|(
name|opcode
parameter_list|)
name|int
name|opcode
decl_stmt|;
block|{
switch|switch
condition|(
name|opcode
condition|)
block|{
default|default:
block|{
specifier|static
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"<unknown %d>"
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
case|case
name|OP_NULL
case|:
return|return
literal|"OP_NULL"
return|;
case|case
name|BINOP_ADD
case|:
return|return
literal|"BINOP_ADD"
return|;
case|case
name|BINOP_SUB
case|:
return|return
literal|"BINOP_SUB"
return|;
case|case
name|BINOP_MUL
case|:
return|return
literal|"BINOP_MUL"
return|;
case|case
name|BINOP_DIV
case|:
return|return
literal|"BINOP_DIV"
return|;
case|case
name|BINOP_REM
case|:
return|return
literal|"BINOP_REM"
return|;
case|case
name|BINOP_MOD
case|:
return|return
literal|"BINOP_MOD"
return|;
case|case
name|BINOP_LSH
case|:
return|return
literal|"BINOP_LSH"
return|;
case|case
name|BINOP_RSH
case|:
return|return
literal|"BINOP_RSH"
return|;
case|case
name|BINOP_LOGICAL_AND
case|:
return|return
literal|"BINOP_LOGICAL_AND"
return|;
case|case
name|BINOP_LOGICAL_OR
case|:
return|return
literal|"BINOP_LOGICAL_OR"
return|;
case|case
name|BINOP_BITWISE_AND
case|:
return|return
literal|"BINOP_BITWISE_AND"
return|;
case|case
name|BINOP_BITWISE_IOR
case|:
return|return
literal|"BINOP_BITWISE_IOR"
return|;
case|case
name|BINOP_BITWISE_XOR
case|:
return|return
literal|"BINOP_BITWISE_XOR"
return|;
case|case
name|BINOP_EQUAL
case|:
return|return
literal|"BINOP_EQUAL"
return|;
case|case
name|BINOP_NOTEQUAL
case|:
return|return
literal|"BINOP_NOTEQUAL"
return|;
case|case
name|BINOP_LESS
case|:
return|return
literal|"BINOP_LESS"
return|;
case|case
name|BINOP_GTR
case|:
return|return
literal|"BINOP_GTR"
return|;
case|case
name|BINOP_LEQ
case|:
return|return
literal|"BINOP_LEQ"
return|;
case|case
name|BINOP_GEQ
case|:
return|return
literal|"BINOP_GEQ"
return|;
case|case
name|BINOP_REPEAT
case|:
return|return
literal|"BINOP_REPEAT"
return|;
case|case
name|BINOP_ASSIGN
case|:
return|return
literal|"BINOP_ASSIGN"
return|;
case|case
name|BINOP_COMMA
case|:
return|return
literal|"BINOP_COMMA"
return|;
case|case
name|BINOP_SUBSCRIPT
case|:
return|return
literal|"BINOP_SUBSCRIPT"
return|;
case|case
name|MULTI_SUBSCRIPT
case|:
return|return
literal|"MULTI_SUBSCRIPT"
return|;
case|case
name|BINOP_EXP
case|:
return|return
literal|"BINOP_EXP"
return|;
case|case
name|BINOP_MIN
case|:
return|return
literal|"BINOP_MIN"
return|;
case|case
name|BINOP_MAX
case|:
return|return
literal|"BINOP_MAX"
return|;
case|case
name|BINOP_SCOPE
case|:
return|return
literal|"BINOP_SCOPE"
return|;
case|case
name|STRUCTOP_MEMBER
case|:
return|return
literal|"STRUCTOP_MEMBER"
return|;
case|case
name|STRUCTOP_MPTR
case|:
return|return
literal|"STRUCTOP_MPTR"
return|;
case|case
name|BINOP_INTDIV
case|:
return|return
literal|"BINOP_INTDIV"
return|;
case|case
name|BINOP_ASSIGN_MODIFY
case|:
return|return
literal|"BINOP_ASSIGN_MODIFY"
return|;
case|case
name|BINOP_VAL
case|:
return|return
literal|"BINOP_VAL"
return|;
case|case
name|BINOP_INCL
case|:
return|return
literal|"BINOP_INCL"
return|;
case|case
name|BINOP_EXCL
case|:
return|return
literal|"BINOP_EXCL"
return|;
case|case
name|BINOP_CONCAT
case|:
return|return
literal|"BINOP_CONCAT"
return|;
case|case
name|BINOP_RANGE
case|:
return|return
literal|"BINOP_RANGE"
return|;
case|case
name|BINOP_END
case|:
return|return
literal|"BINOP_END"
return|;
case|case
name|TERNOP_COND
case|:
return|return
literal|"TERNOP_COND"
return|;
case|case
name|TERNOP_SLICE
case|:
return|return
literal|"TERNOP_SLICE"
return|;
case|case
name|TERNOP_SLICE_COUNT
case|:
return|return
literal|"TERNOP_SLICE_COUNT"
return|;
case|case
name|OP_LONG
case|:
return|return
literal|"OP_LONG"
return|;
case|case
name|OP_DOUBLE
case|:
return|return
literal|"OP_DOUBLE"
return|;
case|case
name|OP_VAR_VALUE
case|:
return|return
literal|"OP_VAR_VALUE"
return|;
case|case
name|OP_LAST
case|:
return|return
literal|"OP_LAST"
return|;
case|case
name|OP_REGISTER
case|:
return|return
literal|"OP_REGISTER"
return|;
case|case
name|OP_INTERNALVAR
case|:
return|return
literal|"OP_INTERNALVAR"
return|;
case|case
name|OP_FUNCALL
case|:
return|return
literal|"OP_FUNCALL"
return|;
case|case
name|OP_STRING
case|:
return|return
literal|"OP_STRING"
return|;
case|case
name|OP_BITSTRING
case|:
return|return
literal|"OP_BITSTRING"
return|;
case|case
name|OP_ARRAY
case|:
return|return
literal|"OP_ARRAY"
return|;
case|case
name|UNOP_CAST
case|:
return|return
literal|"UNOP_CAST"
return|;
case|case
name|UNOP_MEMVAL
case|:
return|return
literal|"UNOP_MEMVAL"
return|;
case|case
name|UNOP_NEG
case|:
return|return
literal|"UNOP_NEG"
return|;
case|case
name|UNOP_LOGICAL_NOT
case|:
return|return
literal|"UNOP_LOGICAL_NOT"
return|;
case|case
name|UNOP_COMPLEMENT
case|:
return|return
literal|"UNOP_COMPLEMENT"
return|;
case|case
name|UNOP_IND
case|:
return|return
literal|"UNOP_IND"
return|;
case|case
name|UNOP_ADDR
case|:
return|return
literal|"UNOP_ADDR"
return|;
case|case
name|UNOP_PREINCREMENT
case|:
return|return
literal|"UNOP_PREINCREMENT"
return|;
case|case
name|UNOP_POSTINCREMENT
case|:
return|return
literal|"UNOP_POSTINCREMENT"
return|;
case|case
name|UNOP_PREDECREMENT
case|:
return|return
literal|"UNOP_PREDECREMENT"
return|;
case|case
name|UNOP_POSTDECREMENT
case|:
return|return
literal|"UNOP_POSTDECREMENT"
return|;
case|case
name|UNOP_SIZEOF
case|:
return|return
literal|"UNOP_SIZEOF"
return|;
case|case
name|UNOP_LOWER
case|:
return|return
literal|"UNOP_LOWER"
return|;
case|case
name|UNOP_UPPER
case|:
return|return
literal|"UNOP_UPPER"
return|;
case|case
name|UNOP_LENGTH
case|:
return|return
literal|"UNOP_LENGTH"
return|;
case|case
name|UNOP_PLUS
case|:
return|return
literal|"UNOP_PLUS"
return|;
case|case
name|UNOP_CAP
case|:
return|return
literal|"UNOP_CAP"
return|;
case|case
name|UNOP_CHR
case|:
return|return
literal|"UNOP_CHR"
return|;
case|case
name|UNOP_ORD
case|:
return|return
literal|"UNOP_ORD"
return|;
case|case
name|UNOP_ABS
case|:
return|return
literal|"UNOP_ABS"
return|;
case|case
name|UNOP_FLOAT
case|:
return|return
literal|"UNOP_FLOAT"
return|;
case|case
name|UNOP_HIGH
case|:
return|return
literal|"UNOP_HIGH"
return|;
case|case
name|UNOP_MAX
case|:
return|return
literal|"UNOP_MAX"
return|;
case|case
name|UNOP_MIN
case|:
return|return
literal|"UNOP_MIN"
return|;
case|case
name|UNOP_ODD
case|:
return|return
literal|"UNOP_ODD"
return|;
case|case
name|UNOP_TRUNC
case|:
return|return
literal|"UNOP_TRUNC"
return|;
case|case
name|OP_BOOL
case|:
return|return
literal|"OP_BOOL"
return|;
case|case
name|OP_M2_STRING
case|:
return|return
literal|"OP_M2_STRING"
return|;
case|case
name|STRUCTOP_STRUCT
case|:
return|return
literal|"STRUCTOP_STRUCT"
return|;
case|case
name|STRUCTOP_PTR
case|:
return|return
literal|"STRUCTOP_PTR"
return|;
case|case
name|OP_THIS
case|:
return|return
literal|"OP_THIS"
return|;
case|case
name|OP_SCOPE
case|:
return|return
literal|"OP_SCOPE"
return|;
case|case
name|OP_TYPE
case|:
return|return
literal|"OP_TYPE"
return|;
case|case
name|OP_LABELED
case|:
return|return
literal|"OP_LABELED"
return|;
block|}
block|}
end_function

begin_function
name|void
name|dump_prefix_expression
parameter_list|(
name|exp
parameter_list|,
name|stream
parameter_list|,
name|note
parameter_list|)
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|note
decl_stmt|;
block|{
name|int
name|elt
decl_stmt|;
name|char
modifier|*
name|opcode_name
decl_stmt|;
name|char
modifier|*
name|eltscan
decl_stmt|;
name|int
name|eltsize
decl_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"Dump of expression @ "
argument_list|)
expr_stmt|;
name|gdb_print_address
argument_list|(
name|exp
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", %s:\nExpression: `"
argument_list|,
name|note
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|elts
index|[
literal|0
index|]
operator|.
name|opcode
operator|!=
name|OP_TYPE
condition|)
name|print_expression
argument_list|(
name|exp
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"Type printing not yet supported...."
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"'\n\tLanguage %s, %d elements, %d bytes each.\n"
argument_list|,
name|exp
operator|->
name|language_defn
operator|->
name|la_name
argument_list|,
name|exp
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|exp_element
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\t%5s  %20s  %16s  %s\n"
argument_list|,
literal|"Index"
argument_list|,
literal|"Opcode"
argument_list|,
literal|"Hex Value"
argument_list|,
literal|"String Value"
argument_list|)
expr_stmt|;
for|for
control|(
name|elt
operator|=
literal|0
init|;
name|elt
operator|<
name|exp
operator|->
name|nelts
condition|;
name|elt
operator|++
control|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\t%5d  "
argument_list|,
name|elt
argument_list|)
expr_stmt|;
name|opcode_name
operator|=
name|op_name
argument_list|(
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|.
name|opcode
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%20s  "
argument_list|,
name|opcode_name
argument_list|)
expr_stmt|;
name|print_longest
argument_list|(
name|stream
argument_list|,
literal|'d'
argument_list|,
literal|0
argument_list|,
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"  "
argument_list|)
expr_stmt|;
for|for
control|(
name|eltscan
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|,
name|eltsize
operator|=
sizeof|sizeof
argument_list|(
expr|union
name|exp_element
argument_list|)
init|;
name|eltsize
operator|--
operator|>
literal|0
condition|;
name|eltscan
operator|++
control|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%c"
argument_list|,
name|isprint
argument_list|(
operator|*
name|eltscan
argument_list|)
condition|?
operator|(
operator|*
name|eltscan
operator|&
literal|0xFF
operator|)
else|:
literal|'.'
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|dump_subexp
name|PARAMS
argument_list|(
operator|(
expr|struct
name|expression
operator|*
name|exp
operator|,
name|GDB_FILE
operator|*
name|stream
operator|,
name|int
name|elt
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|dump_subexp
parameter_list|(
name|exp
parameter_list|,
name|stream
parameter_list|,
name|elt
parameter_list|)
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|elt
decl_stmt|;
block|{
specifier|static
name|int
name|indent
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\t%5d  "
argument_list|,
name|elt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|indent
condition|;
name|i
operator|++
control|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|indent
operator|+=
literal|2
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%-20s  "
argument_list|,
name|op_name
argument_list|(
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|.
name|opcode
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|exp
operator|->
name|elts
index|[
name|elt
operator|++
index|]
operator|.
name|opcode
condition|)
block|{
case|case
name|TERNOP_COND
case|:
case|case
name|TERNOP_SLICE
case|:
case|case
name|TERNOP_SLICE_COUNT
case|:
name|elt
operator|=
name|dump_subexp
argument_list|(
name|exp
argument_list|,
name|stream
argument_list|,
name|elt
argument_list|)
expr_stmt|;
case|case
name|BINOP_ADD
case|:
case|case
name|BINOP_SUB
case|:
case|case
name|BINOP_MUL
case|:
case|case
name|BINOP_DIV
case|:
case|case
name|BINOP_REM
case|:
case|case
name|BINOP_MOD
case|:
case|case
name|BINOP_LSH
case|:
case|case
name|BINOP_RSH
case|:
case|case
name|BINOP_LOGICAL_AND
case|:
case|case
name|BINOP_LOGICAL_OR
case|:
case|case
name|BINOP_BITWISE_AND
case|:
case|case
name|BINOP_BITWISE_IOR
case|:
case|case
name|BINOP_BITWISE_XOR
case|:
case|case
name|BINOP_EQUAL
case|:
case|case
name|BINOP_NOTEQUAL
case|:
case|case
name|BINOP_LESS
case|:
case|case
name|BINOP_GTR
case|:
case|case
name|BINOP_LEQ
case|:
case|case
name|BINOP_GEQ
case|:
case|case
name|BINOP_REPEAT
case|:
case|case
name|BINOP_ASSIGN
case|:
case|case
name|BINOP_COMMA
case|:
case|case
name|BINOP_SUBSCRIPT
case|:
case|case
name|BINOP_EXP
case|:
case|case
name|BINOP_MIN
case|:
case|case
name|BINOP_MAX
case|:
case|case
name|BINOP_SCOPE
case|:
case|case
name|BINOP_INTDIV
case|:
case|case
name|BINOP_ASSIGN_MODIFY
case|:
case|case
name|BINOP_VAL
case|:
case|case
name|BINOP_INCL
case|:
case|case
name|BINOP_EXCL
case|:
case|case
name|BINOP_CONCAT
case|:
case|case
name|BINOP_IN
case|:
case|case
name|BINOP_RANGE
case|:
case|case
name|BINOP_END
case|:
name|elt
operator|=
name|dump_subexp
argument_list|(
name|exp
argument_list|,
name|stream
argument_list|,
name|elt
argument_list|)
expr_stmt|;
case|case
name|UNOP_NEG
case|:
case|case
name|UNOP_LOGICAL_NOT
case|:
case|case
name|UNOP_COMPLEMENT
case|:
case|case
name|UNOP_IND
case|:
case|case
name|UNOP_ADDR
case|:
case|case
name|UNOP_PREINCREMENT
case|:
case|case
name|UNOP_POSTINCREMENT
case|:
case|case
name|UNOP_PREDECREMENT
case|:
case|case
name|UNOP_POSTDECREMENT
case|:
case|case
name|UNOP_SIZEOF
case|:
case|case
name|UNOP_PLUS
case|:
case|case
name|UNOP_CAP
case|:
case|case
name|UNOP_CHR
case|:
case|case
name|UNOP_ORD
case|:
case|case
name|UNOP_ABS
case|:
case|case
name|UNOP_FLOAT
case|:
case|case
name|UNOP_HIGH
case|:
case|case
name|UNOP_MAX
case|:
case|case
name|UNOP_MIN
case|:
case|case
name|UNOP_ODD
case|:
case|case
name|UNOP_TRUNC
case|:
case|case
name|UNOP_LOWER
case|:
case|case
name|UNOP_UPPER
case|:
case|case
name|UNOP_LENGTH
case|:
case|case
name|UNOP_CARD
case|:
case|case
name|UNOP_CHMAX
case|:
case|case
name|UNOP_CHMIN
case|:
name|elt
operator|=
name|dump_subexp
argument_list|(
name|exp
argument_list|,
name|stream
argument_list|,
name|elt
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_LONG
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"Type @0x%x ("
argument_list|,
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|.
name|type
argument_list|,
name|NULL
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"), value %ld (0x%lx)"
argument_list|,
operator|(
name|long
operator|)
name|exp
operator|->
name|elts
index|[
name|elt
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|,
operator|(
name|long
operator|)
name|exp
operator|->
name|elts
index|[
name|elt
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|elt
operator|+=
literal|3
expr_stmt|;
break|break;
case|case
name|OP_DOUBLE
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"Type @0x%x ("
argument_list|,
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|.
name|type
argument_list|,
name|NULL
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"), value %g"
argument_list|,
operator|(
name|double
operator|)
name|exp
operator|->
name|elts
index|[
name|elt
operator|+
literal|1
index|]
operator|.
name|doubleconst
argument_list|)
expr_stmt|;
name|elt
operator|+=
literal|3
expr_stmt|;
break|break;
case|case
name|OP_VAR_VALUE
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"Block @0x%x, symbol @0x%x (%s)"
argument_list|,
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|.
name|block
argument_list|,
name|exp
operator|->
name|elts
index|[
name|elt
operator|+
literal|1
index|]
operator|.
name|symbol
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|exp
operator|->
name|elts
index|[
name|elt
operator|+
literal|1
index|]
operator|.
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
name|elt
operator|+=
literal|3
expr_stmt|;
break|break;
case|case
name|OP_LAST
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"History element %ld"
argument_list|,
operator|(
name|long
operator|)
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|elt
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|OP_REGISTER
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"Register %ld"
argument_list|,
operator|(
name|long
operator|)
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|elt
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|OP_INTERNALVAR
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"Internal var @0x%x (%s)"
argument_list|,
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|.
name|internalvar
argument_list|,
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|.
name|internalvar
operator|->
name|name
argument_list|)
expr_stmt|;
name|elt
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|OP_FUNCALL
case|:
block|{
name|int
name|nargs
decl_stmt|;
name|nargs
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"Number of args: %d"
argument_list|,
name|nargs
argument_list|)
expr_stmt|;
name|elt
operator|+=
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nargs
operator|+
literal|1
condition|;
name|i
operator|++
control|)
name|elt
operator|=
name|dump_subexp
argument_list|(
name|exp
argument_list|,
name|stream
argument_list|,
name|elt
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_ARRAY
case|:
block|{
name|int
name|lower
decl_stmt|,
name|upper
decl_stmt|;
name|int
name|i
decl_stmt|;
name|lower
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|upper
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|elt
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"Bounds [%d:%d]"
argument_list|,
name|lower
argument_list|,
name|upper
argument_list|)
expr_stmt|;
name|elt
operator|+=
literal|3
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|upper
operator|-
name|lower
operator|+
literal|1
condition|;
name|i
operator|++
control|)
name|elt
operator|=
name|dump_subexp
argument_list|(
name|exp
argument_list|,
name|stream
argument_list|,
name|elt
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|UNOP_MEMVAL
case|:
case|case
name|UNOP_CAST
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"Type @0x%x ("
argument_list|,
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|.
name|type
argument_list|,
name|NULL
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|elt
operator|=
name|dump_subexp
argument_list|(
name|exp
argument_list|,
name|stream
argument_list|,
name|elt
operator|+
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|OP_TYPE
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"Type @0x%x ("
argument_list|,
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|.
name|type
argument_list|,
name|NULL
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|elt
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|STRUCTOP_STRUCT
case|:
case|case
name|STRUCTOP_PTR
case|:
block|{
name|char
modifier|*
name|elem_name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|elem_name
operator|=
operator|&
name|exp
operator|->
name|elts
index|[
name|elt
operator|+
literal|1
index|]
operator|.
name|string
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"Element name: `%.*s'"
argument_list|,
name|len
argument_list|,
name|elem_name
argument_list|)
expr_stmt|;
name|elt
operator|=
name|dump_subexp
argument_list|(
name|exp
argument_list|,
name|stream
argument_list|,
name|elt
operator|+
literal|3
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|len
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|OP_SCOPE
case|:
block|{
name|char
modifier|*
name|elem_name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"Type @0x%x ("
argument_list|,
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|exp
operator|->
name|elts
index|[
name|elt
index|]
operator|.
name|type
argument_list|,
name|NULL
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|") "
argument_list|)
expr_stmt|;
name|len
operator|=
name|longest_to_int
argument_list|(
name|exp
operator|->
name|elts
index|[
name|elt
operator|+
literal|1
index|]
operator|.
name|longconst
argument_list|)
expr_stmt|;
name|elem_name
operator|=
operator|&
name|exp
operator|->
name|elts
index|[
name|elt
operator|+
literal|2
index|]
operator|.
name|string
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"Field name: `%.*s'"
argument_list|,
name|len
argument_list|,
name|elem_name
argument_list|)
expr_stmt|;
name|elt
operator|+=
literal|4
operator|+
name|BYTES_TO_EXP_ELEM
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
case|case
name|OP_NULL
case|:
case|case
name|STRUCTOP_MEMBER
case|:
case|case
name|STRUCTOP_MPTR
case|:
case|case
name|MULTI_SUBSCRIPT
case|:
case|case
name|OP_F77_UNDETERMINED_ARGLIST
case|:
case|case
name|OP_COMPLEX
case|:
case|case
name|OP_STRING
case|:
case|case
name|OP_BITSTRING
case|:
case|case
name|OP_BOOL
case|:
case|case
name|OP_M2_STRING
case|:
case|case
name|OP_THIS
case|:
case|case
name|OP_LABELED
case|:
case|case
name|OP_NAME
case|:
case|case
name|OP_EXPRSTRING
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"Unknown format"
argument_list|)
expr_stmt|;
block|}
name|indent
operator|-=
literal|2
expr_stmt|;
return|return
name|elt
return|;
block|}
end_function

begin_function
name|void
name|dump_postfix_expression
parameter_list|(
name|exp
parameter_list|,
name|stream
parameter_list|,
name|note
parameter_list|)
name|struct
name|expression
modifier|*
name|exp
decl_stmt|;
name|GDB_FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|note
decl_stmt|;
block|{
name|int
name|elt
decl_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"Dump of expression @ "
argument_list|)
expr_stmt|;
name|gdb_print_address
argument_list|(
name|exp
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", %s:\nExpression: `"
argument_list|,
name|note
argument_list|)
expr_stmt|;
if|if
condition|(
name|exp
operator|->
name|elts
index|[
literal|0
index|]
operator|.
name|opcode
operator|!=
name|OP_TYPE
condition|)
name|print_expression
argument_list|(
name|exp
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
literal|"Type printing not yet supported...."
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"'\n\tLanguage %s, %d elements, %d bytes each.\n"
argument_list|,
name|exp
operator|->
name|language_defn
operator|->
name|la_name
argument_list|,
name|exp
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|exp_element
argument_list|)
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
for|for
control|(
name|elt
operator|=
literal|0
init|;
name|elt
operator|<
name|exp
operator|->
name|nelts
condition|;
control|)
name|elt
operator|=
name|dump_subexp
argument_list|(
name|exp
argument_list|,
name|stream
argument_list|,
name|elt
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"\n"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAINTENANCE_CMDS */
end_comment

end_unit

