begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generic remote debugging interface for simulators.    Copyright 1993, 1994 Free Software Foundation, Inc.    Contributed by Cygnus Support.    Steve Chamberlain (sac@cygnus.com).  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"terminal.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"remote-sim.h"
end_include

begin_include
include|#
directive|include
file|"remote-utils.h"
end_include

begin_include
include|#
directive|include
file|"callback.h"
end_include

begin_comment
comment|/* Naming convention:     sim_* are the interface to the simulator (see remote-sim.h).    sim_callback_* are the stuff which the simulator can see inside GDB.    gdbsim_* are stuff which is internal to gdb.  */
end_comment

begin_comment
comment|/* Forward data declarations */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|gdbsim_ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|program_loaded
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|dump_mem
parameter_list|(
name|buf
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
if|if
condition|(
name|len
operator|<=
literal|8
condition|)
block|{
if|if
condition|(
name|len
operator|==
literal|8
operator|||
name|len
operator|==
literal|4
condition|)
block|{
name|long
name|l
index|[
literal|2
index|]
decl_stmt|;
name|memcpy
argument_list|(
name|l
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\t0x%x"
argument_list|,
name|l
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
name|len
operator|==
literal|8
condition|?
literal|" 0x%x\n"
else|:
literal|"\n"
argument_list|,
name|l
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
name|printf_filtered
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|printf_filtered
argument_list|(
literal|"0x%x "
argument_list|,
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|gdbsim_fetch_register
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
name|gdbsim_fetch_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|buf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|sim_fetch_register
argument_list|(
name|regno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|supply_register
argument_list|(
name|regno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"gdbsim_fetch_register: %d"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
comment|/* FIXME: We could print something more intelligible.  */
name|dump_mem
argument_list|(
name|buf
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|gdbsim_store_register
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
name|gdbsim_store_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* FIXME: Until read_register() returns LONGEST, we have this.  */
name|char
name|tmp
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|read_register_gen
argument_list|(
name|regno
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|sim_store_register
argument_list|(
name|regno
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"gdbsim_store_register: %d"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
comment|/* FIXME: We could print something more intelligible.  */
name|dump_mem
argument_list|(
name|tmp
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Kill the running program.  This may involve closing any open files    and releasing other resources acquired by the simulated program.  */
end_comment

begin_function
specifier|static
name|void
name|gdbsim_kill
parameter_list|()
block|{
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|printf_filtered
argument_list|(
literal|"gdbsim_kill\n"
argument_list|)
expr_stmt|;
name|sim_kill
argument_list|()
expr_stmt|;
comment|/* close fd's, remove mappings */
name|inferior_pid
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Load an executable file into the target process.  This is expected to    not only bring new code into the target process, but also to update    GDB's symbol tables to match.  */
end_comment

begin_function
specifier|static
name|void
name|gdbsim_load
parameter_list|(
name|prog
parameter_list|,
name|fromtty
parameter_list|)
name|char
modifier|*
name|prog
decl_stmt|;
name|int
name|fromtty
decl_stmt|;
block|{
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|printf_filtered
argument_list|(
literal|"gdbsim_load: prog \"%s\"\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
literal|0
expr_stmt|;
comment|/* This must be done before calling gr_load_image.  */
name|program_loaded
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sim_load
argument_list|(
name|prog
argument_list|,
name|fromtty
argument_list|)
operator|!=
literal|0
condition|)
name|generic_load
argument_list|(
name|prog
argument_list|,
name|fromtty
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start an inferior process and set inferior_pid to its pid.    EXEC_FILE is the file to run.    ALLARGS is a string containing the arguments to the program.    ENV is the environment vector to pass.  Errors reported with error().    On VxWorks and various standalone systems, we ignore exec_file.  */
end_comment

begin_comment
comment|/* This is called not only when we first attach, but also when the    user types "run" after having attached.  */
end_comment

begin_function
specifier|static
name|void
name|gdbsim_create_inferior
parameter_list|(
name|exec_file
parameter_list|,
name|args
parameter_list|,
name|env
parameter_list|)
name|char
modifier|*
name|exec_file
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
name|char
modifier|*
modifier|*
name|env
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|arg_buf
decl_stmt|,
modifier|*
modifier|*
name|argv
decl_stmt|;
name|CORE_ADDR
name|entry_pt
decl_stmt|;
if|if
condition|(
operator|!
name|program_loaded
condition|)
name|error
argument_list|(
literal|"No program loaded."
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|printf_filtered
argument_list|(
literal|"gdbsim_create_inferior: exec_file \"%s\", args \"%s\"\n"
argument_list|,
name|exec_file
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|exec_file
operator|==
literal|0
operator|||
name|exec_bfd
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"No exec file specified."
argument_list|)
expr_stmt|;
name|entry_pt
operator|=
operator|(
name|CORE_ADDR
operator|)
name|bfd_get_start_address
argument_list|(
name|exec_bfd
argument_list|)
expr_stmt|;
name|gdbsim_kill
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|init_wait_for_inferior
argument_list|()
expr_stmt|;
name|len
operator|=
literal|5
operator|+
name|strlen
argument_list|(
name|exec_file
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|args
argument_list|)
operator|+
literal|1
operator|+
comment|/*slop*/
literal|10
expr_stmt|;
name|arg_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|arg_buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|arg_buf
argument_list|,
name|exec_file
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|arg_buf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|arg_buf
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|argv
operator|=
name|buildargv
argument_list|(
name|arg_buf
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
name|freeargv
argument_list|,
operator|(
name|char
operator|*
operator|)
name|argv
argument_list|)
expr_stmt|;
name|sim_create_inferior
argument_list|(
name|entry_pt
argument_list|,
name|argv
argument_list|,
name|env
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
literal|42
expr_stmt|;
name|insert_breakpoints
argument_list|()
expr_stmt|;
comment|/* Needed to get correct instruction in cache */
name|proceed
argument_list|(
name|entry_pt
argument_list|,
name|TARGET_SIGNAL_DEFAULT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The open routine takes the rest of the parameters from the command,    and (if successful) pushes a new target onto the stack.    Targets should supply this routine, if only to provide an error message.  */
end_comment

begin_comment
comment|/* Called when selecting the simulator. EG: (gdb) target sim name.  */
end_comment

begin_function
specifier|static
name|void
name|gdbsim_open
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|printf_filtered
argument_list|(
literal|"gdbsim_open: args \"%s\"\n"
argument_list|,
name|args
condition|?
name|args
else|:
literal|"(null)"
argument_list|)
expr_stmt|;
name|sim_set_callbacks
argument_list|(
operator|&
name|default_callback
argument_list|)
expr_stmt|;
name|default_callback
operator|.
name|init
argument_list|(
operator|&
name|default_callback
argument_list|)
expr_stmt|;
name|sim_open
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|push_target
argument_list|(
operator|&
name|gdbsim_ops
argument_list|)
expr_stmt|;
name|target_fetch_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Connected to the simulator.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Does whatever cleanup is required for a target that we are no longer    going to be calling.  Argument says whether we are quitting gdb and    should not get hung in case of errors, or whether we want a clean    termination even if it takes a while.  This routine is automatically    always called just before a routine is popped off the target stack.    Closing file descriptors and freeing memory are typical things it should    do.  */
end_comment

begin_comment
comment|/* Close out all files and local state before this target loses control. */
end_comment

begin_function
specifier|static
name|void
name|gdbsim_close
parameter_list|(
name|quitting
parameter_list|)
name|int
name|quitting
decl_stmt|;
block|{
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|printf_filtered
argument_list|(
literal|"gdbsim_close: quitting %d\n"
argument_list|,
name|quitting
argument_list|)
expr_stmt|;
name|program_loaded
operator|=
literal|0
expr_stmt|;
name|sim_close
argument_list|(
name|quitting
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Takes a program previously attached to and detaches it.    The program may resume execution (some targets do, some don't) and will    no longer stop on signals, etc.  We better not have left any breakpoints    in the program or it'll die when it hits one.  ARGS is arguments    typed by the user (e.g. a signal to send the process).  FROM_TTY    says whether to be verbose or not.  */
end_comment

begin_comment
comment|/* Terminate the open connection to the remote debugger.    Use this when you want to detach and do something else with your gdb.  */
end_comment

begin_function
specifier|static
name|void
name|gdbsim_detach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|printf_filtered
argument_list|(
literal|"gdbsim_detach: args \"%s\"\n"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|pop_target
argument_list|()
expr_stmt|;
comment|/* calls gdbsim_close to do the real work */
if|if
condition|(
name|from_tty
condition|)
name|printf_filtered
argument_list|(
literal|"Ending simulator %s debugging\n"
argument_list|,
name|target_shortname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Resume execution of the target process.  STEP says whether to single-step    or to run free; SIGGNAL is the signal value (e.g. SIGINT) to be given    to the target, or zero for no signal.  */
end_comment

begin_function
specifier|static
name|void
name|gdbsim_resume
parameter_list|(
name|pid
parameter_list|,
name|step
parameter_list|,
name|siggnal
parameter_list|)
name|int
name|pid
decl_stmt|,
name|step
decl_stmt|;
name|enum
name|target_signal
name|siggnal
decl_stmt|;
block|{
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|printf_filtered
argument_list|(
literal|"gdbsim_resume: step %d, signal %d\n"
argument_list|,
name|step
argument_list|,
name|siggnal
argument_list|)
expr_stmt|;
name|sim_resume
argument_list|(
name|step
argument_list|,
name|target_signal_to_host
argument_list|(
name|siggnal
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wait for inferior process to do something.  Return pid of child,    or -1 in case of error; store status through argument pointer STATUS,    just as `wait' would.  */
end_comment

begin_function
specifier|static
name|int
name|gdbsim_wait
parameter_list|(
name|pid
parameter_list|,
name|status
parameter_list|)
name|int
name|pid
decl_stmt|;
name|struct
name|target_waitstatus
modifier|*
name|status
decl_stmt|;
block|{
name|int
name|sigrc
decl_stmt|;
name|enum
name|sim_stop
name|reason
decl_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|printf_filtered
argument_list|(
literal|"gdbsim_wait\n"
argument_list|)
expr_stmt|;
name|sim_stop_reason
argument_list|(
operator|&
name|reason
argument_list|,
operator|&
name|sigrc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|reason
condition|)
block|{
case|case
name|sim_exited
case|:
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|integer
operator|=
name|sigrc
expr_stmt|;
break|break;
case|case
name|sim_stopped
case|:
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
comment|/* The signal in sigrc is a host signal.  That probably 	 should be fixed.  */
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|target_signal_from_host
argument_list|(
name|sigrc
argument_list|)
expr_stmt|;
break|break;
case|case
name|sim_signalled
case|:
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_SIGNALLED
expr_stmt|;
comment|/* The signal in sigrc is a host signal.  That probably 	 should be fixed.  */
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|target_signal_from_host
argument_list|(
name|sigrc
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|inferior_pid
return|;
block|}
end_function

begin_comment
comment|/* Get ready to modify the registers array.  On machines which store    individual registers, this doesn't need to do anything.  On machines    which store all the registers in one fell swoop, this makes sure    that registers contains all the registers from the program being    debugged.  */
end_comment

begin_function
specifier|static
name|void
name|gdbsim_prepare_to_store
parameter_list|()
block|{
comment|/* Do nothing, since we can store individual regs */
block|}
end_function

begin_function
specifier|static
name|int
name|gdbsim_xfer_inferior_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|write
parameter_list|,
name|target
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|write
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
comment|/* ignored */
block|{
if|if
condition|(
operator|!
name|program_loaded
condition|)
name|error
argument_list|(
literal|"No program loaded."
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"gdbsim_xfer_inferior_memory: myaddr 0x%x, memaddr 0x%x, len %d, write %d\n"
argument_list|,
name|myaddr
argument_list|,
name|memaddr
argument_list|,
name|len
argument_list|,
name|write
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
operator|&&
name|write
condition|)
name|dump_mem
argument_list|(
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|write
condition|)
block|{
name|len
operator|=
name|sim_write
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|sim_read
argument_list|(
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
operator|&&
name|len
operator|>
literal|0
condition|)
name|dump_mem
argument_list|(
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gdbsim_files_info
parameter_list|(
name|target
parameter_list|)
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
block|{
name|char
modifier|*
name|file
init|=
literal|"nothing"
decl_stmt|;
if|if
condition|(
name|exec_bfd
condition|)
name|file
operator|=
name|bfd_get_filename
argument_list|(
name|exec_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|printf_filtered
argument_list|(
literal|"gdbsim_files_info: file \"%s\"\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|exec_bfd
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\tAttached to %s running program %s\n"
argument_list|,
name|target_shortname
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|sim_info
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Clear the simulator's notion of what the break points are.  */
end_comment

begin_function
specifier|static
name|void
name|gdbsim_mourn_inferior
parameter_list|()
block|{
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|printf_filtered
argument_list|(
literal|"gdbsim_mourn_inferior:\n"
argument_list|)
expr_stmt|;
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|generic_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Put a command string, in args, out to MONITOR.  Output from MONITOR    is placed on the users terminal until the prompt is seen. FIXME: We    read the characters ourseleves here cause of a nasty echo.  */
end_comment

begin_function
specifier|static
name|void
name|simulator_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|sim_do_command
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define the target subroutine names */
end_comment

begin_decl_stmt
name|struct
name|target_ops
name|gdbsim_ops
init|=
block|{
literal|"sim"
block|,
comment|/* to_shortname */
literal|"simulator"
block|,
comment|/* to_longname */
literal|"Use the compiled-in simulator."
block|,
comment|/* to_doc */
name|gdbsim_open
block|,
comment|/* to_open */
name|gdbsim_close
block|,
comment|/* to_close */
name|NULL
block|,
comment|/* to_attach */
name|gdbsim_detach
block|,
comment|/* to_detach */
name|gdbsim_resume
block|,
comment|/* to_resume */
name|gdbsim_wait
block|,
comment|/* to_wait */
name|gdbsim_fetch_register
block|,
comment|/* to_fetch_registers */
name|gdbsim_store_register
block|,
comment|/* to_store_registers */
name|gdbsim_prepare_to_store
block|,
comment|/* to_prepare_to_store */
name|gdbsim_xfer_inferior_memory
block|,
comment|/* to_xfer_memory */
name|gdbsim_files_info
block|,
comment|/* to_files_info */
name|memory_insert_breakpoint
block|,
comment|/* to_insert_breakpoint */
name|memory_remove_breakpoint
block|,
comment|/* to_remove_breakpoint */
name|NULL
block|,
comment|/* to_terminal_init */
name|NULL
block|,
comment|/* to_terminal_inferior */
name|NULL
block|,
comment|/* to_terminal_ours_for_output */
name|NULL
block|,
comment|/* to_terminal_ours */
name|NULL
block|,
comment|/* to_terminal_info */
name|gdbsim_kill
block|,
comment|/* to_kill */
name|gdbsim_load
block|,
comment|/* to_load */
name|NULL
block|,
comment|/* to_lookup_symbol */
name|gdbsim_create_inferior
block|,
comment|/* to_create_inferior */
name|gdbsim_mourn_inferior
block|,
comment|/* to_mourn_inferior */
literal|0
block|,
comment|/* to_can_run */
literal|0
block|,
comment|/* to_notice_signals */
literal|0
block|,
comment|/* to_thread_alive */
literal|0
block|,
comment|/* to_stop */
name|process_stratum
block|,
comment|/* to_stratum */
name|NULL
block|,
comment|/* to_next */
literal|1
block|,
comment|/* to_has_all_memory */
literal|1
block|,
comment|/* to_has_memory */
literal|1
block|,
comment|/* to_has_stack */
literal|1
block|,
comment|/* to_has_registers */
literal|1
block|,
comment|/* to_has_execution */
name|NULL
block|,
comment|/* sections */
name|NULL
block|,
comment|/* sections_end */
name|OPS_MAGIC
block|,
comment|/* to_magic */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_remote_sim
parameter_list|()
block|{
name|add_target
argument_list|(
operator|&
name|gdbsim_ops
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"sim<command>"
argument_list|,
name|class_obscure
argument_list|,
name|simulator_command
argument_list|,
literal|"Send a command to the simulator."
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

