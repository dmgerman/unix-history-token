begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Generic remote debugging interface for simulators.    Copyright 1993, 1994, 1996, 1997 Free Software Foundation, Inc.    Contributed by Cygnus Support.    Steve Chamberlain (sac@cygnus.com).  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"inferior.h"
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"terminal.h"
end_include

begin_include
include|#
directive|include
file|"target.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_include
include|#
directive|include
file|"callback.h"
end_include

begin_include
include|#
directive|include
file|"remote-sim.h"
end_include

begin_include
include|#
directive|include
file|"remote-utils.h"
end_include

begin_include
include|#
directive|include
file|"command.h"
end_include

begin_comment
comment|/* Prototypes */
end_comment

begin_decl_stmt
specifier|static
name|void
name|dump_mem
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|buf
operator|,
name|int
name|len
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|init_callbacks
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|end_callbacks
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gdb_os_write_stdout
name|PARAMS
argument_list|(
operator|(
name|host_callback
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gdb_os_flush_stdout
name|PARAMS
argument_list|(
operator|(
name|host_callback
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gdb_os_write_stderr
name|PARAMS
argument_list|(
operator|(
name|host_callback
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gdb_os_flush_stderr
name|PARAMS
argument_list|(
operator|(
name|host_callback
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gdb_os_poll_quit
name|PARAMS
argument_list|(
operator|(
name|host_callback
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* printf_filtered is depreciated */
end_comment

begin_decl_stmt
specifier|static
name|void
name|gdb_os_printf_filtered
name|PARAMS
argument_list|(
operator|(
name|host_callback
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gdb_os_vprintf_filtered
name|PARAMS
argument_list|(
operator|(
name|host_callback
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gdb_os_evprintf_filtered
name|PARAMS
argument_list|(
operator|(
name|host_callback
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|va_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gdb_os_error
name|PARAMS
argument_list|(
operator|(
name|host_callback
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
operator|...
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gdbsim_fetch_register
name|PARAMS
argument_list|(
operator|(
name|int
name|regno
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gdbsim_store_register
name|PARAMS
argument_list|(
operator|(
name|int
name|regno
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gdbsim_kill
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gdbsim_load
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|prog
operator|,
name|int
name|fromtty
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gdbsim_create_inferior
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|exec_file
operator|,
name|char
operator|*
name|args
operator|,
name|char
operator|*
operator|*
name|env
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gdbsim_open
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|args
operator|,
name|int
name|from_tty
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gdbsim_close
name|PARAMS
argument_list|(
operator|(
name|int
name|quitting
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gdbsim_detach
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|args
operator|,
name|int
name|from_tty
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gdbsim_resume
name|PARAMS
argument_list|(
operator|(
name|int
name|pid
operator|,
name|int
name|step
operator|,
expr|enum
name|target_signal
name|siggnal
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gdbsim_wait
name|PARAMS
argument_list|(
operator|(
name|int
name|pid
operator|,
expr|struct
name|target_waitstatus
operator|*
name|status
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gdbsim_prepare_to_store
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gdbsim_xfer_inferior_memory
name|PARAMS
argument_list|(
operator|(
name|CORE_ADDR
name|memaddr
operator|,
name|char
operator|*
name|myaddr
operator|,
name|int
name|len
operator|,
name|int
name|write
operator|,
expr|struct
name|target_ops
operator|*
name|target
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gdbsim_files_info
name|PARAMS
argument_list|(
operator|(
expr|struct
name|target_ops
operator|*
name|target
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gdbsim_mourn_inferior
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|gdbsim_stop
name|PARAMS
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|simulator_command
name|PARAMS
argument_list|(
operator|(
name|char
operator|*
name|args
operator|,
name|int
name|from_tty
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Naming convention:     sim_* are the interface to the simulator (see remote-sim.h).    gdbsim_* are stuff which is internal to gdb.  */
end_comment

begin_comment
comment|/* Forward data declarations */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|target_ops
name|gdbsim_ops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|program_loaded
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We must keep track of whether the simulator has been opened or not because    GDB can call a target's close routine twice, but sim_close doesn't allow    this.  We also need to record the result of sim_open so we can pass it    back to the other sim_foo routines.  */
end_comment

begin_decl_stmt
specifier|static
name|SIM_DESC
name|gdbsim_desc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|dump_mem
parameter_list|(
name|buf
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
if|if
condition|(
name|len
operator|<=
literal|8
condition|)
block|{
if|if
condition|(
name|len
operator|==
literal|8
operator|||
name|len
operator|==
literal|4
condition|)
block|{
name|long
name|l
index|[
literal|2
index|]
decl_stmt|;
name|memcpy
argument_list|(
name|l
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\t0x%x"
argument_list|,
name|l
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
name|len
operator|==
literal|8
condition|?
literal|" 0x%x\n"
else|:
literal|"\n"
argument_list|,
name|l
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
name|printf_filtered
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|printf_filtered
argument_list|(
literal|"0x%x "
argument_list|,
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|host_callback
name|gdb_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|callbacks_initialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize gdb_callback.  */
end_comment

begin_function
specifier|static
name|void
name|init_callbacks
parameter_list|()
block|{
if|if
condition|(
operator|!
name|callbacks_initialized
condition|)
block|{
name|gdb_callback
operator|=
name|default_callback
expr_stmt|;
name|gdb_callback
operator|.
name|init
argument_list|(
operator|&
name|gdb_callback
argument_list|)
expr_stmt|;
name|gdb_callback
operator|.
name|write_stdout
operator|=
name|gdb_os_write_stdout
expr_stmt|;
name|gdb_callback
operator|.
name|flush_stdout
operator|=
name|gdb_os_flush_stdout
expr_stmt|;
name|gdb_callback
operator|.
name|write_stderr
operator|=
name|gdb_os_write_stderr
expr_stmt|;
name|gdb_callback
operator|.
name|flush_stderr
operator|=
name|gdb_os_flush_stderr
expr_stmt|;
name|gdb_callback
operator|.
name|printf_filtered
operator|=
name|gdb_os_printf_filtered
expr_stmt|;
name|gdb_callback
operator|.
name|vprintf_filtered
operator|=
name|gdb_os_vprintf_filtered
expr_stmt|;
name|gdb_callback
operator|.
name|evprintf_filtered
operator|=
name|gdb_os_evprintf_filtered
expr_stmt|;
name|gdb_callback
operator|.
name|error
operator|=
name|gdb_os_error
expr_stmt|;
name|gdb_callback
operator|.
name|poll_quit
operator|=
name|gdb_os_poll_quit
expr_stmt|;
name|gdb_callback
operator|.
name|magic
operator|=
name|HOST_CALLBACK_MAGIC
expr_stmt|;
name|callbacks_initialized
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Release callbacks (free resources used by them).  */
end_comment

begin_function
specifier|static
name|void
name|end_callbacks
parameter_list|()
block|{
if|if
condition|(
name|callbacks_initialized
condition|)
block|{
name|gdb_callback
operator|.
name|shutdown
argument_list|(
operator|&
name|gdb_callback
argument_list|)
expr_stmt|;
name|callbacks_initialized
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* GDB version of os_write_stdout callback.  */
end_comment

begin_function
specifier|static
name|int
name|gdb_os_write_stdout
parameter_list|(
name|p
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|host_callback
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
name|b
index|[
literal|2
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|b
index|[
literal|0
index|]
operator|=
name|buf
index|[
name|i
index|]
expr_stmt|;
name|b
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|target_output_hook
condition|)
name|target_output_hook
argument_list|(
name|b
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
name|b
argument_list|,
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* GDB version of os_flush_stdout callback.  */
end_comment

begin_function
specifier|static
name|void
name|gdb_os_flush_stdout
parameter_list|(
name|p
parameter_list|)
name|host_callback
modifier|*
name|p
decl_stmt|;
block|{
name|gdb_flush
argument_list|(
name|gdb_stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* GDB version of os_write_stderr callback.  */
end_comment

begin_function
specifier|static
name|int
name|gdb_os_write_stderr
parameter_list|(
name|p
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|host_callback
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
name|b
index|[
literal|2
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|b
index|[
literal|0
index|]
operator|=
name|buf
index|[
name|i
index|]
expr_stmt|;
name|b
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|target_output_hook
condition|)
name|target_output_hook
argument_list|(
name|b
argument_list|)
expr_stmt|;
else|else
name|fputs_filtered
argument_list|(
name|b
argument_list|,
name|gdb_stderr
argument_list|)
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* GDB version of os_flush_stderr callback.  */
end_comment

begin_function
specifier|static
name|void
name|gdb_os_flush_stderr
parameter_list|(
name|p
parameter_list|)
name|host_callback
modifier|*
name|p
decl_stmt|;
block|{
name|gdb_flush
argument_list|(
name|gdb_stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* GDB version of printf_filtered callback.  */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|gdb_os_printf_filtered
parameter_list|(
name|host_callback
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|gdb_os_printf_filtered
parameter_list|(
name|p
parameter_list|,
name|va_alist
parameter_list|)
name|host_callback
modifier|*
name|p
decl_stmt|;
function|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|args
decl_stmt|;
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
else|#
directive|else
name|char
modifier|*
name|format
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|format
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vfprintf_filtered
argument_list|(
name|gdb_stdout
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* GDB version of error vprintf_filtered.  */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|gdb_os_vprintf_filtered
parameter_list|(
name|host_callback
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|ap
parameter_list|)
else|#
directive|else
function|gdb_os_vprintf_filtered
parameter_list|(
name|p
parameter_list|,
name|format
parameter_list|,
name|ap
parameter_list|)
name|host_callback
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
endif|#
directive|endif
block|{
name|vfprintf_filtered
argument_list|(
name|gdb_stdout
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* GDB version of error evprintf_filtered.  */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|gdb_os_evprintf_filtered
parameter_list|(
name|host_callback
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
name|va_list
name|ap
parameter_list|)
else|#
directive|else
function|gdb_os_evprintf_filtered
parameter_list|(
name|p
parameter_list|,
name|format
parameter_list|,
name|ap
parameter_list|)
name|host_callback
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
endif|#
directive|endif
block|{
name|vfprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* GDB version of error callback.  */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_function
specifier|static
name|void
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|gdb_os_error
parameter_list|(
name|host_callback
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|gdb_os_error
parameter_list|(
name|p
parameter_list|,
name|va_alist
parameter_list|)
name|host_callback
modifier|*
name|p
decl_stmt|;
function|va_dcl
endif|#
directive|endif
block|{
if|if
condition|(
name|error_hook
condition|)
call|(
modifier|*
name|error_hook
call|)
argument_list|()
expr_stmt|;
else|else
block|{
name|va_list
name|args
decl_stmt|;
ifdef|#
directive|ifdef
name|ANSI_PROTOTYPES
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
else|#
directive|else
name|char
modifier|*
name|format
decl_stmt|;
name|va_start
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|format
operator|=
name|va_arg
argument_list|(
name|args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error_begin
argument_list|()
expr_stmt|;
name|vfprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|gdb_stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
name|return_to_top_level
argument_list|(
name|RETURN_ERROR
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|gdbsim_fetch_register
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
specifier|static
name|int
name|warn_user
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
name|gdbsim_fetch_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|REGISTER_NAME
argument_list|(
name|regno
argument_list|)
operator|!=
name|NULL
operator|&&
operator|*
name|REGISTER_NAME
argument_list|(
name|regno
argument_list|)
operator|!=
literal|'\0'
condition|)
block|{
name|char
name|buf
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|int
name|nr_bytes
init|=
name|sim_fetch_register
argument_list|(
name|gdbsim_desc
argument_list|,
name|regno
argument_list|,
name|buf
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|nr_bytes
operator|==
literal|0
condition|)
comment|/* register not applicable, supply zero's */
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|MAX_REGISTER_RAW_SIZE
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nr_bytes
operator|>
literal|0
operator|&&
name|nr_bytes
operator|!=
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
operator|&&
name|warn_user
condition|)
block|{
name|printf_unfiltered
argument_list|(
literal|"Size of register %s (%d) incorrect (%d instead of %d))"
argument_list|,
name|REGISTER_NAME
argument_list|(
name|regno
argument_list|)
argument_list|,
name|regno
argument_list|,
name|nr_bytes
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
name|warn_user
operator|=
literal|0
expr_stmt|;
block|}
name|supply_register
argument_list|(
name|regno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"gdbsim_fetch_register: %d"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
comment|/* FIXME: We could print something more intelligible.  */
name|dump_mem
argument_list|(
name|buf
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|gdbsim_store_register
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
if|if
condition|(
name|regno
operator|==
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|regno
operator|=
literal|0
init|;
name|regno
operator|<
name|NUM_REGS
condition|;
name|regno
operator|++
control|)
name|gdbsim_store_register
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|REGISTER_NAME
argument_list|(
name|regno
argument_list|)
operator|!=
name|NULL
operator|&&
operator|*
name|REGISTER_NAME
argument_list|(
name|regno
argument_list|)
operator|!=
literal|'\0'
condition|)
block|{
name|char
name|tmp
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|int
name|nr_bytes
decl_stmt|;
name|read_register_gen
argument_list|(
name|regno
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|nr_bytes
operator|=
name|sim_store_register
argument_list|(
name|gdbsim_desc
argument_list|,
name|regno
argument_list|,
name|tmp
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nr_bytes
operator|>
literal|0
operator|&&
name|nr_bytes
operator|!=
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"Register size different to expected"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"gdbsim_store_register: %d"
argument_list|,
name|regno
argument_list|)
expr_stmt|;
comment|/* FIXME: We could print something more intelligible.  */
name|dump_mem
argument_list|(
name|tmp
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Kill the running program.  This may involve closing any open files    and releasing other resources acquired by the simulated program.  */
end_comment

begin_function
specifier|static
name|void
name|gdbsim_kill
parameter_list|()
block|{
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|printf_filtered
argument_list|(
literal|"gdbsim_kill\n"
argument_list|)
expr_stmt|;
comment|/* There is no need to `kill' running simulator - the simulator is      not running */
name|inferior_pid
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Load an executable file into the target process.  This is expected to    not only bring new code into the target process, but also to update    GDB's symbol tables to match.  */
end_comment

begin_function
specifier|static
name|void
name|gdbsim_load
parameter_list|(
name|prog
parameter_list|,
name|fromtty
parameter_list|)
name|char
modifier|*
name|prog
decl_stmt|;
name|int
name|fromtty
decl_stmt|;
block|{
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|printf_filtered
argument_list|(
literal|"gdbsim_load: prog \"%s\"\n"
argument_list|,
name|prog
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
literal|0
expr_stmt|;
comment|/* FIXME: We will print two messages on error.      Need error to either not print anything if passed NULL or need      another routine that doesn't take any arguments.  */
if|if
condition|(
name|sim_load
argument_list|(
name|gdbsim_desc
argument_list|,
name|prog
argument_list|,
name|NULL
argument_list|,
name|fromtty
argument_list|)
operator|==
name|SIM_RC_FAIL
condition|)
name|error
argument_list|(
literal|"unable to load program"
argument_list|)
expr_stmt|;
comment|/* FIXME: If a load command should reset the targets registers then      a call to sim_create_inferior() should go here. */
name|program_loaded
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Start an inferior process and set inferior_pid to its pid.    EXEC_FILE is the file to run.    ARGS is a string containing the arguments to the program.    ENV is the environment vector to pass.  Errors reported with error().    On VxWorks and various standalone systems, we ignore exec_file.  */
end_comment

begin_comment
comment|/* This is called not only when we first attach, but also when the    user types "run" after having attached.  */
end_comment

begin_function
specifier|static
name|void
name|gdbsim_create_inferior
parameter_list|(
name|exec_file
parameter_list|,
name|args
parameter_list|,
name|env
parameter_list|)
name|char
modifier|*
name|exec_file
decl_stmt|;
name|char
modifier|*
name|args
decl_stmt|;
name|char
modifier|*
modifier|*
name|env
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|arg_buf
decl_stmt|,
modifier|*
modifier|*
name|argv
decl_stmt|;
if|if
condition|(
name|exec_file
operator|==
literal|0
operator|||
name|exec_bfd
operator|==
literal|0
condition|)
name|warning
argument_list|(
literal|"No executable file specified."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|program_loaded
condition|)
name|warning
argument_list|(
literal|"No program loaded."
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|printf_filtered
argument_list|(
literal|"gdbsim_create_inferior: exec_file \"%s\", args \"%s\"\n"
argument_list|,
operator|(
name|exec_file
condition|?
name|exec_file
else|:
literal|"(NULL)"
operator|)
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|gdbsim_kill
argument_list|()
expr_stmt|;
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|init_wait_for_inferior
argument_list|()
expr_stmt|;
if|if
condition|(
name|exec_file
operator|!=
name|NULL
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|exec_file
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|args
argument_list|)
operator|+
literal|1
operator|+
comment|/*slop*/
literal|10
expr_stmt|;
name|arg_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|arg_buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|arg_buf
argument_list|,
name|exec_file
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|arg_buf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|arg_buf
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|argv
operator|=
name|buildargv
argument_list|(
name|arg_buf
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|freeargv
argument_list|,
name|argv
argument_list|)
expr_stmt|;
block|}
else|else
name|argv
operator|=
name|NULL
expr_stmt|;
name|sim_create_inferior
argument_list|(
name|gdbsim_desc
argument_list|,
name|exec_bfd
argument_list|,
name|argv
argument_list|,
name|env
argument_list|)
expr_stmt|;
name|inferior_pid
operator|=
literal|42
expr_stmt|;
name|insert_breakpoints
argument_list|()
expr_stmt|;
comment|/* Needed to get correct instruction in cache */
name|clear_proceed_status
argument_list|()
expr_stmt|;
comment|/* NB: Entry point already set by sim_create_inferior. */
name|proceed
argument_list|(
operator|(
name|CORE_ADDR
operator|)
operator|-
literal|1
argument_list|,
name|TARGET_SIGNAL_DEFAULT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The open routine takes the rest of the parameters from the command,    and (if successful) pushes a new target onto the stack.    Targets should supply this routine, if only to provide an error message.  */
end_comment

begin_comment
comment|/* Called when selecting the simulator. EG: (gdb) target sim name.  */
end_comment

begin_function
specifier|static
name|void
name|gdbsim_open
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|arg_buf
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|printf_filtered
argument_list|(
literal|"gdbsim_open: args \"%s\"\n"
argument_list|,
name|args
condition|?
name|args
else|:
literal|"(null)"
argument_list|)
expr_stmt|;
comment|/* Remove current simulator if one exists.  Only do this if the simulator      has been opened because sim_close requires it.      This is important because the call to push_target below will cause      sim_close to be called if the simulator is already open, but push_target      is called after sim_open!  We can't move the call to push_target before      the call to sim_open because sim_open may invoke `error'.  */
if|if
condition|(
name|gdbsim_desc
operator|!=
name|NULL
condition|)
name|unpush_target
argument_list|(
operator|&
name|gdbsim_ops
argument_list|)
expr_stmt|;
name|len
operator|=
operator|(
literal|7
operator|+
literal|1
comment|/* gdbsim */
operator|+
name|strlen
argument_list|(
literal|" -E little"
argument_list|)
operator|+
name|strlen
argument_list|(
literal|" --architecture=xxxxxxxxxx"
argument_list|)
operator|+
operator|(
name|args
condition|?
name|strlen
argument_list|(
name|args
argument_list|)
else|:
literal|0
operator|)
operator|+
literal|50
operator|)
comment|/* slack */
expr_stmt|;
name|arg_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|arg_buf
argument_list|,
literal|"gdbsim"
argument_list|)
expr_stmt|;
comment|/* 7 */
comment|/* Specify the byte order for the target when it is both selectable      and explicitly specified by the user (not auto detected). */
if|if
condition|(
name|TARGET_BYTE_ORDER_SELECTABLE_P
operator|&&
operator|!
name|TARGET_BYTE_ORDER_AUTO
condition|)
block|{
switch|switch
condition|(
name|TARGET_BYTE_ORDER
condition|)
block|{
case|case
name|BIG_ENDIAN
case|:
name|strcat
argument_list|(
name|arg_buf
argument_list|,
literal|" -E big"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LITTLE_ENDIAN
case|:
name|strcat
argument_list|(
name|arg_buf
argument_list|,
literal|" -E little"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fatal
argument_list|(
literal|"Value of TARGET_BYTE_ORDER unknown"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Specify the architecture of the target when it has been      explicitly specified */
if|if
condition|(
operator|!
name|TARGET_ARCHITECTURE_AUTO
condition|)
block|{
name|strcat
argument_list|(
name|arg_buf
argument_list|,
literal|" --architecture="
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|arg_buf
argument_list|,
name|TARGET_ARCHITECTURE
operator|->
name|printable_name
argument_list|)
expr_stmt|;
block|}
comment|/* finally, any explicit args */
if|if
condition|(
name|args
condition|)
block|{
name|strcat
argument_list|(
name|arg_buf
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
comment|/* 1 */
name|strcat
argument_list|(
name|arg_buf
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
name|argv
operator|=
name|buildargv
argument_list|(
name|arg_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|argv
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"Insufficient memory available to allocate simulator arg list."
argument_list|)
expr_stmt|;
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|freeargv
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|init_callbacks
argument_list|()
expr_stmt|;
name|gdbsim_desc
operator|=
name|sim_open
argument_list|(
name|SIM_OPEN_DEBUG
argument_list|,
operator|&
name|gdb_callback
argument_list|,
name|exec_bfd
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
name|gdbsim_desc
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"unable to create simulator instance"
argument_list|)
expr_stmt|;
name|push_target
argument_list|(
operator|&
name|gdbsim_ops
argument_list|)
expr_stmt|;
name|target_fetch_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|printf_filtered
argument_list|(
literal|"Connected to the simulator.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Does whatever cleanup is required for a target that we are no longer    going to be calling.  Argument says whether we are quitting gdb and    should not get hung in case of errors, or whether we want a clean    termination even if it takes a while.  This routine is automatically    always called just before a routine is popped off the target stack.    Closing file descriptors and freeing memory are typical things it should    do.  */
end_comment

begin_comment
comment|/* Close out all files and local state before this target loses control. */
end_comment

begin_function
specifier|static
name|void
name|gdbsim_close
parameter_list|(
name|quitting
parameter_list|)
name|int
name|quitting
decl_stmt|;
block|{
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|printf_filtered
argument_list|(
literal|"gdbsim_close: quitting %d\n"
argument_list|,
name|quitting
argument_list|)
expr_stmt|;
name|program_loaded
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gdbsim_desc
operator|!=
name|NULL
condition|)
block|{
name|sim_close
argument_list|(
name|gdbsim_desc
argument_list|,
name|quitting
argument_list|)
expr_stmt|;
name|gdbsim_desc
operator|=
name|NULL
expr_stmt|;
block|}
name|end_callbacks
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Takes a program previously attached to and detaches it.    The program may resume execution (some targets do, some don't) and will    no longer stop on signals, etc.  We better not have left any breakpoints    in the program or it'll die when it hits one.  ARGS is arguments    typed by the user (e.g. a signal to send the process).  FROM_TTY    says whether to be verbose or not.  */
end_comment

begin_comment
comment|/* Terminate the open connection to the remote debugger.    Use this when you want to detach and do something else with your gdb.  */
end_comment

begin_function
specifier|static
name|void
name|gdbsim_detach
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|printf_filtered
argument_list|(
literal|"gdbsim_detach: args \"%s\"\n"
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|pop_target
argument_list|()
expr_stmt|;
comment|/* calls gdbsim_close to do the real work */
if|if
condition|(
name|from_tty
condition|)
name|printf_filtered
argument_list|(
literal|"Ending simulator %s debugging\n"
argument_list|,
name|target_shortname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Resume execution of the target process.  STEP says whether to single-step    or to run free; SIGGNAL is the signal value (e.g. SIGINT) to be given    to the target, or zero for no signal.  */
end_comment

begin_decl_stmt
specifier|static
name|enum
name|target_signal
name|resume_siggnal
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|resume_step
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|gdbsim_resume
parameter_list|(
name|pid
parameter_list|,
name|step
parameter_list|,
name|siggnal
parameter_list|)
name|int
name|pid
decl_stmt|,
name|step
decl_stmt|;
name|enum
name|target_signal
name|siggnal
decl_stmt|;
block|{
if|if
condition|(
name|inferior_pid
operator|!=
literal|42
condition|)
name|error
argument_list|(
literal|"The program is not being run."
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|printf_filtered
argument_list|(
literal|"gdbsim_resume: step %d, signal %d\n"
argument_list|,
name|step
argument_list|,
name|siggnal
argument_list|)
expr_stmt|;
name|resume_siggnal
operator|=
name|siggnal
expr_stmt|;
name|resume_step
operator|=
name|step
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Notify the simulator of an asynchronous request to stop.        The simulator shall ensure that the stop request is eventually    delivered to the simulator.  If the call is made while the    simulator is not running then the stop request is processed when    the simulator is next resumed.     For simulators that do not support this operation, just abort */
end_comment

begin_function
specifier|static
name|void
name|gdbsim_stop
parameter_list|()
block|{
if|if
condition|(
operator|!
name|sim_stop
argument_list|(
name|gdbsim_desc
argument_list|)
condition|)
block|{
name|quit
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* GDB version of os_poll_quit callback.    Taken from gdb/util.c - should be in a library */
end_comment

begin_function
specifier|static
name|int
name|gdb_os_poll_quit
parameter_list|(
name|p
parameter_list|)
name|host_callback
modifier|*
name|p
decl_stmt|;
block|{
name|notice_quit
argument_list|()
expr_stmt|;
if|if
condition|(
name|quit_flag
condition|)
comment|/* gdb's idea of quit */
block|{
name|quit_flag
operator|=
literal|0
expr_stmt|;
comment|/* we've stolen it */
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|immediate_quit
condition|)
block|{
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Wait for inferior process to do something.  Return pid of child,    or -1 in case of error; store status through argument pointer STATUS,    just as `wait' would. */
end_comment

begin_function
specifier|static
name|void
name|gdbsim_cntrl_c
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|gdbsim_stop
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|gdbsim_wait
parameter_list|(
name|pid
parameter_list|,
name|status
parameter_list|)
name|int
name|pid
decl_stmt|;
name|struct
name|target_waitstatus
modifier|*
name|status
decl_stmt|;
block|{
specifier|static
name|RETSIGTYPE
function_decl|(
modifier|*
name|prev_sigint
function_decl|)
parameter_list|()
function_decl|;
name|int
name|sigrc
init|=
literal|0
decl_stmt|;
name|enum
name|sim_stop
name|reason
init|=
name|sim_running
decl_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|printf_filtered
argument_list|(
literal|"gdbsim_wait\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SIGACTION
argument_list|)
operator|&&
name|defined
argument_list|(
name|SA_RESTART
argument_list|)
block|{
name|struct
name|sigaction
name|sa
decl_stmt|,
name|osa
decl_stmt|;
name|sa
operator|.
name|sa_handler
operator|=
name|gdbsim_cntrl_c
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|sa
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|sa
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
name|sigaction
argument_list|(
name|SIGINT
argument_list|,
operator|&
name|sa
argument_list|,
operator|&
name|osa
argument_list|)
expr_stmt|;
name|prev_sigint
operator|=
name|osa
operator|.
name|sa_handler
expr_stmt|;
block|}
else|#
directive|else
name|prev_sigint
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|gdbsim_cntrl_c
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sim_resume
argument_list|(
name|gdbsim_desc
argument_list|,
name|resume_step
argument_list|,
name|target_signal_to_host
argument_list|(
name|resume_siggnal
argument_list|)
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|prev_sigint
argument_list|)
expr_stmt|;
name|resume_step
operator|=
literal|0
expr_stmt|;
name|sim_stop_reason
argument_list|(
name|gdbsim_desc
argument_list|,
operator|&
name|reason
argument_list|,
operator|&
name|sigrc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|reason
condition|)
block|{
case|case
name|sim_exited
case|:
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_EXITED
expr_stmt|;
name|status
operator|->
name|value
operator|.
name|integer
operator|=
name|sigrc
expr_stmt|;
break|break;
case|case
name|sim_stopped
case|:
switch|switch
condition|(
name|sigrc
condition|)
block|{
case|case
name|SIGABRT
case|:
name|quit
argument_list|()
expr_stmt|;
break|break;
case|case
name|SIGINT
case|:
case|case
name|SIGTRAP
case|:
default|default:
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_STOPPED
expr_stmt|;
comment|/* The signal in sigrc is a host signal.  That probably 	     should be fixed.  */
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|target_signal_from_host
argument_list|(
name|sigrc
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|sim_signalled
case|:
name|status
operator|->
name|kind
operator|=
name|TARGET_WAITKIND_SIGNALLED
expr_stmt|;
comment|/* The signal in sigrc is a host signal.  That probably 	 should be fixed.  */
name|status
operator|->
name|value
operator|.
name|sig
operator|=
name|target_signal_from_host
argument_list|(
name|sigrc
argument_list|)
expr_stmt|;
break|break;
case|case
name|sim_running
case|:
case|case
name|sim_polling
case|:
comment|/* FIXME: Is this correct? */
break|break;
block|}
return|return
name|inferior_pid
return|;
block|}
end_function

begin_comment
comment|/* Get ready to modify the registers array.  On machines which store    individual registers, this doesn't need to do anything.  On machines    which store all the registers in one fell swoop, this makes sure    that registers contains all the registers from the program being    debugged.  */
end_comment

begin_function
specifier|static
name|void
name|gdbsim_prepare_to_store
parameter_list|()
block|{
comment|/* Do nothing, since we can store individual regs */
block|}
end_function

begin_function
specifier|static
name|int
name|gdbsim_xfer_inferior_memory
parameter_list|(
name|memaddr
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|,
name|write
parameter_list|,
name|target
parameter_list|)
name|CORE_ADDR
name|memaddr
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|write
decl_stmt|;
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
comment|/* ignored */
block|{
if|if
condition|(
operator|!
name|program_loaded
condition|)
name|error
argument_list|(
literal|"No program loaded."
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"gdbsim_xfer_inferior_memory: myaddr 0x%x, memaddr 0x%x, len %d, write %d\n"
argument_list|,
name|myaddr
argument_list|,
name|memaddr
argument_list|,
name|len
argument_list|,
name|write
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
operator|&&
name|write
condition|)
name|dump_mem
argument_list|(
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|write
condition|)
block|{
name|len
operator|=
name|sim_write
argument_list|(
name|gdbsim_desc
argument_list|,
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|sim_read
argument_list|(
name|gdbsim_desc
argument_list|,
name|memaddr
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
operator|&&
name|len
operator|>
literal|0
condition|)
name|dump_mem
argument_list|(
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gdbsim_files_info
parameter_list|(
name|target
parameter_list|)
name|struct
name|target_ops
modifier|*
name|target
decl_stmt|;
block|{
name|char
modifier|*
name|file
init|=
literal|"nothing"
decl_stmt|;
if|if
condition|(
name|exec_bfd
condition|)
name|file
operator|=
name|bfd_get_filename
argument_list|(
name|exec_bfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|printf_filtered
argument_list|(
literal|"gdbsim_files_info: file \"%s\"\n"
argument_list|,
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|exec_bfd
condition|)
block|{
name|printf_filtered
argument_list|(
literal|"\tAttached to %s running program %s\n"
argument_list|,
name|target_shortname
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|sim_info
argument_list|(
name|gdbsim_desc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Clear the simulator's notion of what the break points are.  */
end_comment

begin_function
specifier|static
name|void
name|gdbsim_mourn_inferior
parameter_list|()
block|{
if|if
condition|(
name|sr_get_debug
argument_list|()
condition|)
name|printf_filtered
argument_list|(
literal|"gdbsim_mourn_inferior:\n"
argument_list|)
expr_stmt|;
name|remove_breakpoints
argument_list|()
expr_stmt|;
name|generic_mourn_inferior
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|gdbsim_insert_breakpoint
parameter_list|(
name|addr
parameter_list|,
name|contents_cache
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|contents_cache
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|SIM_HAS_BREAKPOINTS
name|SIM_RC
name|retcode
decl_stmt|;
name|retcode
operator|=
name|sim_set_breakpoint
argument_list|(
name|gdbsim_desc
argument_list|,
name|addr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|retcode
condition|)
block|{
case|case
name|SIM_RC_OK
case|:
return|return
literal|0
return|;
case|case
name|SIM_RC_INSUFFICIENT_RESOURCES
case|:
return|return
name|ENOMEM
return|;
default|default:
return|return
name|EIO
return|;
block|}
else|#
directive|else
return|return
name|memory_insert_breakpoint
argument_list|(
name|addr
argument_list|,
name|contents_cache
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|gdbsim_remove_breakpoint
parameter_list|(
name|addr
parameter_list|,
name|contents_cache
parameter_list|)
name|CORE_ADDR
name|addr
decl_stmt|;
name|char
modifier|*
name|contents_cache
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|SIM_HAS_BREAKPOINTS
name|SIM_RC
name|retcode
decl_stmt|;
name|retcode
operator|=
name|sim_clear_breakpoint
argument_list|(
name|gdbsim_desc
argument_list|,
name|addr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|retcode
condition|)
block|{
case|case
name|SIM_RC_OK
case|:
case|case
name|SIM_RC_UNKNOWN_BREAKPOINT
case|:
return|return
literal|0
return|;
case|case
name|SIM_RC_INSUFFICIENT_RESOURCES
case|:
return|return
name|ENOMEM
return|;
default|default:
return|return
name|EIO
return|;
block|}
else|#
directive|else
return|return
name|memory_remove_breakpoint
argument_list|(
name|addr
argument_list|,
name|contents_cache
argument_list|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Pass the command argument through to the simulator verbatim.  The    simulator must do any command interpretation work.  */
end_comment

begin_function
name|void
name|simulator_command
parameter_list|(
name|args
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|args
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
if|if
condition|(
name|gdbsim_desc
operator|==
name|NULL
condition|)
block|{
comment|/* PREVIOUSLY: The user may give a command before the simulator          is opened. [...] (??? assuming of course one wishes to          continue to allow commands to be sent to unopened simulators,          which isn't entirely unreasonable). */
comment|/* The simulator is a builtin abstraction of a remote target.          Consistent with that model, access to the simulator, via sim          commands, is restricted to the period when the channel to the          simulator is open. */
name|error
argument_list|(
literal|"Not connected to the simulator target"
argument_list|)
expr_stmt|;
block|}
name|sim_do_command
argument_list|(
name|gdbsim_desc
argument_list|,
name|args
argument_list|)
expr_stmt|;
comment|/* Invalidate the register cache, in case the simulator command does      something funny. */
name|registers_changed
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Define the target subroutine names */
end_comment

begin_decl_stmt
name|struct
name|target_ops
name|gdbsim_ops
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|init_gdbsim_ops
parameter_list|(
name|void
parameter_list|)
block|{
name|gdbsim_ops
operator|.
name|to_shortname
operator|=
literal|"sim"
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_longname
operator|=
literal|"simulator"
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_doc
operator|=
literal|"Use the compiled-in simulator."
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_open
operator|=
name|gdbsim_open
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_close
operator|=
name|gdbsim_close
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_attach
operator|=
name|NULL
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_post_attach
operator|=
name|NULL
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_require_attach
operator|=
name|NULL
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_detach
operator|=
name|gdbsim_detach
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_require_detach
operator|=
name|NULL
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_resume
operator|=
name|gdbsim_resume
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_wait
operator|=
name|gdbsim_wait
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_post_wait
operator|=
name|NULL
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_fetch_registers
operator|=
name|gdbsim_fetch_register
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_store_registers
operator|=
name|gdbsim_store_register
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_prepare_to_store
operator|=
name|gdbsim_prepare_to_store
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_xfer_memory
operator|=
name|gdbsim_xfer_inferior_memory
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_files_info
operator|=
name|gdbsim_files_info
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_insert_breakpoint
operator|=
name|gdbsim_insert_breakpoint
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_remove_breakpoint
operator|=
name|gdbsim_remove_breakpoint
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_terminal_init
operator|=
name|NULL
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_terminal_inferior
operator|=
name|NULL
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_terminal_ours_for_output
operator|=
name|NULL
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_terminal_ours
operator|=
name|NULL
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_terminal_info
operator|=
name|NULL
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_kill
operator|=
name|gdbsim_kill
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_load
operator|=
name|gdbsim_load
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_lookup_symbol
operator|=
name|NULL
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_create_inferior
operator|=
name|gdbsim_create_inferior
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_post_startup_inferior
operator|=
name|NULL
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_acknowledge_created_inferior
operator|=
name|NULL
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_clone_and_follow_inferior
operator|=
name|NULL
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_post_follow_inferior_by_clone
operator|=
name|NULL
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_insert_fork_catchpoint
operator|=
name|NULL
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_remove_fork_catchpoint
operator|=
name|NULL
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_insert_vfork_catchpoint
operator|=
name|NULL
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_remove_vfork_catchpoint
operator|=
name|NULL
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_has_forked
operator|=
name|NULL
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_has_vforked
operator|=
name|NULL
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_can_follow_vfork_prior_to_exec
operator|=
name|NULL
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_post_follow_vfork
operator|=
name|NULL
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_insert_exec_catchpoint
operator|=
name|NULL
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_remove_exec_catchpoint
operator|=
name|NULL
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_has_execd
operator|=
name|NULL
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_reported_exec_events_per_exec_call
operator|=
name|NULL
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_has_exited
operator|=
name|NULL
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_mourn_inferior
operator|=
name|gdbsim_mourn_inferior
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_can_run
operator|=
literal|0
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_notice_signals
operator|=
literal|0
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_thread_alive
operator|=
literal|0
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_stop
operator|=
name|gdbsim_stop
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_pid_to_exec_file
operator|=
name|NULL
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_core_file_to_sym_file
operator|=
name|NULL
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_stratum
operator|=
name|process_stratum
expr_stmt|;
name|gdbsim_ops
operator|.
name|DONT_USE
operator|=
name|NULL
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_has_all_memory
operator|=
literal|1
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_has_memory
operator|=
literal|1
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_has_stack
operator|=
literal|1
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_has_registers
operator|=
literal|1
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_has_execution
operator|=
literal|1
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_sections
operator|=
name|NULL
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_sections_end
operator|=
name|NULL
expr_stmt|;
name|gdbsim_ops
operator|.
name|to_magic
operator|=
name|OPS_MAGIC
expr_stmt|;
ifdef|#
directive|ifdef
name|TARGET_REDEFINE_DEFAULT_OPS
name|TARGET_REDEFINE_DEFAULT_OPS
argument_list|(
operator|&
name|gdbsim_ops
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|_initialize_remote_sim
parameter_list|()
block|{
name|init_gdbsim_ops
argument_list|()
expr_stmt|;
name|add_target
argument_list|(
operator|&
name|gdbsim_ops
argument_list|)
expr_stmt|;
name|add_com
argument_list|(
literal|"sim<command>"
argument_list|,
name|class_obscure
argument_list|,
name|simulator_command
argument_list|,
literal|"Send a command to the simulator."
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

