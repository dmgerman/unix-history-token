begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Scheme/Guile language support routines for GDB, the GNU debugger.    Copyright 1995, 1996, 1998, 1999, 2000, 2001    Free Software Foundation, Inc.     This file is part of GDB.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2 of the License, or    (at your option) any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 59 Temple Place - Suite 330,    Boston, MA 02111-1307, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"gdbtypes.h"
end_include

begin_include
include|#
directive|include
file|"expression.h"
end_include

begin_include
include|#
directive|include
file|"parser-defs.h"
end_include

begin_include
include|#
directive|include
file|"language.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_include
include|#
directive|include
file|"scm-lang.h"
end_include

begin_include
include|#
directive|include
file|"valprint.h"
end_include

begin_include
include|#
directive|include
file|"gdbcore.h"
end_include

begin_comment
comment|/* FIXME: Should be in a header file that we import. */
end_comment

begin_function_decl
specifier|extern
name|int
name|c_val_print
parameter_list|(
name|struct
name|type
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|CORE_ADDR
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|enum
name|val_prettyprint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scm_ipruk
parameter_list|(
name|char
modifier|*
parameter_list|,
name|LONGEST
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|scm_scmlist_print
parameter_list|(
name|LONGEST
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|enum
name|val_prettyprint
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|scm_inferior_print
parameter_list|(
name|LONGEST
parameter_list|,
name|struct
name|ui_file
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|enum
name|val_prettyprint
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Prints the SCM value VALUE by invoking the inferior, if appropraite.    Returns>= 0 on succes;  retunr -1 if the inferior cannot/should not    print VALUE. */
end_comment

begin_function
specifier|static
name|int
name|scm_inferior_print
parameter_list|(
name|LONGEST
name|value
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|format
parameter_list|,
name|int
name|deref_ref
parameter_list|,
name|int
name|recurse
parameter_list|,
name|enum
name|val_prettyprint
name|pretty
parameter_list|)
block|{
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* {Names of immediate symbols}  * This table must agree with the declarations in scm.h: {Immediate Symbols}.*/
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|scm_isymnames
index|[]
init|=
block|{
comment|/* This table must agree with the declarations */
literal|"and"
block|,
literal|"begin"
block|,
literal|"case"
block|,
literal|"cond"
block|,
literal|"do"
block|,
literal|"if"
block|,
literal|"lambda"
block|,
literal|"let"
block|,
literal|"let*"
block|,
literal|"letrec"
block|,
literal|"or"
block|,
literal|"quote"
block|,
literal|"set!"
block|,
literal|"define"
block|,
if|#
directive|if
literal|0
block|"literal-variable-ref",   "literal-variable-set!",
endif|#
directive|endif
literal|"apply"
block|,
literal|"call-with-current-continuation"
block|,
comment|/* user visible ISYMS */
comment|/* other keywords */
comment|/* Flags */
literal|"#f"
block|,
literal|"#t"
block|,
literal|"#<undefined>"
block|,
literal|"#<eof>"
block|,
literal|"()"
block|,
literal|"#<unspecified>"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|scm_scmlist_print
parameter_list|(
name|LONGEST
name|svalue
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|format
parameter_list|,
name|int
name|deref_ref
parameter_list|,
name|int
name|recurse
parameter_list|,
name|enum
name|val_prettyprint
name|pretty
parameter_list|)
block|{
name|unsigned
name|int
name|more
init|=
name|print_max
decl_stmt|;
if|if
condition|(
name|recurse
operator|>
literal|6
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"..."
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
block|}
name|scm_scmval_print
argument_list|(
name|SCM_CAR
argument_list|(
name|svalue
argument_list|)
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
name|svalue
operator|=
name|SCM_CDR
argument_list|(
name|svalue
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|SCM_NIMP
argument_list|(
name|svalue
argument_list|)
condition|;
name|svalue
operator|=
name|SCM_CDR
argument_list|(
name|svalue
argument_list|)
control|)
block|{
if|if
condition|(
name|SCM_NECONSP
argument_list|(
name|svalue
argument_list|)
condition|)
break|break;
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|more
operator|==
literal|0
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"..."
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
block|}
name|scm_scmval_print
argument_list|(
name|SCM_CAR
argument_list|(
name|svalue
argument_list|)
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SCM_NNULLP
argument_list|(
name|svalue
argument_list|)
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|" . "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|scm_scmval_print
argument_list|(
name|svalue
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|scm_ipruk
parameter_list|(
name|char
modifier|*
name|hdr
parameter_list|,
name|LONGEST
name|ptr
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"#<unknown-%s"
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
define|#
directive|define
name|SCM_SIZE
value|TYPE_LENGTH (builtin_type_scm)
if|if
condition|(
name|SCM_CELLP
argument_list|(
name|ptr
argument_list|)
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" (0x%lx . 0x%lx) @"
argument_list|,
operator|(
name|long
operator|)
name|SCM_CAR
argument_list|(
name|ptr
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|SCM_CDR
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" 0x%s>"
argument_list|,
name|paddr_nz
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|scm_scmval_print
parameter_list|(
name|LONGEST
name|svalue
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|format
parameter_list|,
name|int
name|deref_ref
parameter_list|,
name|int
name|recurse
parameter_list|,
name|enum
name|val_prettyprint
name|pretty
parameter_list|)
block|{
name|taloop
label|:
switch|switch
condition|(
literal|7
operator|&
operator|(
name|int
operator|)
name|svalue
condition|)
block|{
case|case
literal|2
case|:
case|case
literal|6
case|:
name|print_longest
argument_list|(
name|stream
argument_list|,
name|format
condition|?
name|format
else|:
literal|'d'
argument_list|,
literal|1
argument_list|,
name|svalue
operator|>>
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
if|if
condition|(
name|SCM_ICHRP
argument_list|(
name|svalue
argument_list|)
condition|)
block|{
name|svalue
operator|=
name|SCM_ICHR
argument_list|(
name|svalue
argument_list|)
expr_stmt|;
name|scm_printchar
argument_list|(
name|svalue
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|SCM_IFLAGP
argument_list|(
name|svalue
argument_list|)
operator|&&
operator|(
name|SCM_ISYMNUM
argument_list|(
name|svalue
argument_list|)
operator|<
operator|(
sizeof|sizeof
name|scm_isymnames
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
operator|)
condition|)
block|{
name|fputs_filtered
argument_list|(
name|SCM_ISYMCHARS
argument_list|(
name|svalue
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|SCM_ILOCP
argument_list|(
name|svalue
argument_list|)
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"#@%ld%c%ld"
argument_list|,
operator|(
name|long
operator|)
name|SCM_IFRAME
argument_list|(
name|svalue
argument_list|)
argument_list|,
name|SCM_ICDRP
argument_list|(
name|svalue
argument_list|)
condition|?
literal|'-'
else|:
literal|'+'
argument_list|,
operator|(
name|long
operator|)
name|SCM_IDIST
argument_list|(
name|svalue
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
goto|goto
name|idef
goto|;
break|break;
case|case
literal|1
case|:
comment|/* gloc */
name|svalue
operator|=
name|SCM_CAR
argument_list|(
name|svalue
operator|-
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|taloop
goto|;
default|default:
name|idef
label|:
name|scm_ipruk
argument_list|(
literal|"immediate"
argument_list|,
name|svalue
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
switch|switch
condition|(
name|SCM_TYP7
argument_list|(
name|svalue
argument_list|)
condition|)
block|{
case|case
name|scm_tcs_cons_gloc
case|:
if|if
condition|(
name|SCM_CDR
argument_list|(
name|SCM_CAR
argument_list|(
name|svalue
argument_list|)
operator|-
literal|1L
argument_list|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
literal|0
block|SCM name;
endif|#
directive|endif
name|fputs_filtered
argument_list|(
literal|"#<latte "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
name|fputs_filtered
argument_list|(
literal|"???"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|#
directive|else
name|name
operator|=
operator|(
operator|(
name|SCM
name|n
operator|*
operator|)
operator|(
name|STRUCT_TYPE
argument_list|(
name|exp
argument_list|)
operator|)
operator|)
index|[
name|struct_i_name
index|]
expr_stmt|;
name|scm_lfwrite
argument_list|(
name|CHARS
argument_list|(
name|name
argument_list|)
argument_list|,
operator|(
name|sizet
operator|)
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
operator|(
name|sizet
operator|)
name|LENGTH
argument_list|(
name|name
argument_list|)
argument_list|,
name|port
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" #X%s>"
argument_list|,
name|paddr_nz
argument_list|(
name|svalue
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|scm_tcs_cons_imcar
case|:
case|case
name|scm_tcs_cons_nimcar
case|:
name|fputs_filtered
argument_list|(
literal|"("
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|scm_scmlist_print
argument_list|(
name|svalue
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|")"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
name|scm_tcs_closures
case|:
name|fputs_filtered
argument_list|(
literal|"#<CLOSURE "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|scm_scmlist_print
argument_list|(
name|SCM_CODE
argument_list|(
name|svalue
argument_list|)
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|">"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
name|scm_tc7_string
case|:
block|{
name|int
name|len
init|=
name|SCM_LENGTH
argument_list|(
name|svalue
argument_list|)
decl_stmt|;
name|CORE_ADDR
name|addr
init|=
operator|(
name|CORE_ADDR
operator|)
name|SCM_CDR
argument_list|(
name|svalue
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
name|int
name|buf_size
decl_stmt|;
name|char
name|buffer
index|[
literal|64
index|]
decl_stmt|;
name|int
name|truncate
init|=
name|print_max
operator|&&
name|len
operator|>
operator|(
name|int
operator|)
name|print_max
decl_stmt|;
if|if
condition|(
name|truncate
condition|)
name|len
operator|=
name|print_max
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"\""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|done
operator|<
name|len
condition|;
name|done
operator|+=
name|buf_size
control|)
block|{
name|buf_size
operator|=
name|min
argument_list|(
name|len
operator|-
name|done
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|read_memory
argument_list|(
name|addr
operator|+
name|done
argument_list|,
name|buffer
argument_list|,
name|buf_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|buf_size
condition|;
operator|++
name|i
control|)
switch|switch
condition|(
name|buffer
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'\"'
case|:
case|case
literal|'\\'
case|:
name|fputs_filtered
argument_list|(
literal|"\\"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
default|default:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%c"
argument_list|,
name|buffer
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|fputs_filtered
argument_list|(
name|truncate
condition|?
literal|"...\""
else|:
literal|"\""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|scm_tcs_symbols
case|:
block|{
name|int
name|len
init|=
name|SCM_LENGTH
argument_list|(
name|svalue
argument_list|)
decl_stmt|;
name|char
modifier|*
name|str
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|read_memory
argument_list|(
name|SCM_CDR
argument_list|(
name|svalue
argument_list|)
argument_list|,
name|str
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Should handle weird characters FIXME */
name|str
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fputs_filtered
argument_list|(
name|str
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|scm_tc7_vector
case|:
block|{
name|int
name|len
init|=
name|SCM_LENGTH
argument_list|(
name|svalue
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|LONGEST
name|elements
init|=
name|SCM_CDR
argument_list|(
name|svalue
argument_list|)
decl_stmt|;
name|fputs_filtered
argument_list|(
literal|"#("
argument_list|,
name|stream
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|scm_scmval_print
argument_list|(
name|scm_get_field
argument_list|(
name|elements
argument_list|,
name|i
argument_list|)
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
literal|")"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
break|break;
if|#
directive|if
literal|0
block|case tc7_lvector: 	  { 	    SCM result; 	    SCM hook; 	    hook = scm_get_lvector_hook (exp, LV_PRINT_FN); 	    if (hook == BOOL_F) 	      { 		scm_puts ("#<locked-vector ", port); 		scm_intprint (CDR (exp), 16, port); 		scm_puts (">", port); 	      } 	    else 	      { 		result 		  = scm_apply (hook, 			scm_listify (exp, port, (writing ? BOOL_T : BOOL_F), 				     SCM_UNDEFINED), 			       EOL); 		if (result == BOOL_F) 		  goto punk; 	      } 	    break; 	  } 	  break; 	case tc7_bvect: 	case tc7_ivect: 	case tc7_uvect: 	case tc7_fvect: 	case tc7_dvect: 	case tc7_cvect: 	  scm_raprin1 (exp, port, writing); 	  break;
endif|#
directive|endif
case|case
name|scm_tcs_subrs
case|:
block|{
name|int
name|index
init|=
name|SCM_CAR
argument_list|(
name|svalue
argument_list|)
operator|>>
literal|8
decl_stmt|;
if|#
directive|if
literal|1
name|char
name|str
index|[
literal|20
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"#%d"
argument_list|,
name|index
argument_list|)
expr_stmt|;
else|#
directive|else
name|char
modifier|*
name|str
init|=
name|index
condition|?
name|SCM_CHARS
argument_list|(
name|scm_heap_org
operator|+
name|index
argument_list|)
else|:
literal|""
decl_stmt|;
define|#
directive|define
name|SCM_CHARS
parameter_list|(
name|x
parameter_list|)
value|((char *)(SCM_CDR(x)))
name|char
modifier|*
name|str
init|=
name|CHARS
argument_list|(
name|SNAME
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"#<primitive-procedure %s>"
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
break|break;
if|#
directive|if
literal|0
ifdef|#
directive|ifdef
name|CCLO
block|case tc7_cclo: 	  scm_puts ("#<compiled-closure ", port); 	  scm_iprin1 (CCLO_SUBR (exp), port, writing); 	  scm_putc ('>', port); 	  break;
endif|#
directive|endif
block|case tc7_contin: 	  fprintf_filtered (stream, "#<continuation %d @ #X%lx>", 			    LENGTH (svalue), 			    (long) CHARS (svalue)); 	  break; 	case tc7_port: 	  i = PTOBNUM (exp); 	  if (i< scm_numptob&& scm_ptobs[i].print&& (scm_ptobs[i].print) (exp, port, writing)) 	    break; 	  goto punk; 	case tc7_smob: 	  i = SMOBNUM (exp); 	  if (i< scm_numsmob&& scm_smobs[i].print&& (scm_smobs[i].print) (exp, port, writing)) 	    break; 	  goto punk;
endif|#
directive|endif
default|default:
if|#
directive|if
literal|0
block|punk:
endif|#
directive|endif
name|scm_ipruk
argument_list|(
literal|"type"
argument_list|,
name|svalue
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_function
name|int
name|scm_val_print
parameter_list|(
name|struct
name|type
modifier|*
name|type
parameter_list|,
name|char
modifier|*
name|valaddr
parameter_list|,
name|int
name|embedded_offset
parameter_list|,
name|CORE_ADDR
name|address
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|format
parameter_list|,
name|int
name|deref_ref
parameter_list|,
name|int
name|recurse
parameter_list|,
name|enum
name|val_prettyprint
name|pretty
parameter_list|)
block|{
if|if
condition|(
name|is_scmvalue_type
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|LONGEST
name|svalue
init|=
name|extract_signed_integer
argument_list|(
name|valaddr
argument_list|,
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|scm_inferior_print
argument_list|(
name|svalue
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|)
operator|>=
literal|0
condition|)
block|{ 	}
else|else
block|{
name|scm_scmval_print
argument_list|(
name|svalue
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
block|}
name|gdb_flush
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
name|c_val_print
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
literal|0
argument_list|,
name|address
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
argument_list|,
name|pretty
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|int
name|scm_value_print
parameter_list|(
name|struct
name|value
modifier|*
name|val
parameter_list|,
name|struct
name|ui_file
modifier|*
name|stream
parameter_list|,
name|int
name|format
parameter_list|,
name|enum
name|val_prettyprint
name|pretty
parameter_list|)
block|{
return|return
operator|(
name|common_val_print
argument_list|(
name|val
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|pretty
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

