begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Read a symbol table in MIPS' format (Third-Eye).    Copyright 1986, 87, 89, 90, 91, 92, 93, 94, 95, 96, 1998    Free Software Foundation, Inc.    Contributed by Alessandro Forin (af@cs.cmu.edu) at CMU.  Major work    by Per Bothner, John Gilmore and Ian Lance Taylor at Cygnus Support.  This file is part of GDB.  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2 of the License, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* Read symbols from an ECOFF file.  Most of the work is done in    mdebugread.c.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"gdb_string.h"
end_include

begin_include
include|#
directive|include
file|"bfd.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"symfile.h"
end_include

begin_include
include|#
directive|include
file|"objfiles.h"
end_include

begin_include
include|#
directive|include
file|"buildsym.h"
end_include

begin_include
include|#
directive|include
file|"stabsread.h"
end_include

begin_include
include|#
directive|include
file|"gdb-stabs.h"
end_include

begin_include
include|#
directive|include
file|"coff/sym.h"
end_include

begin_include
include|#
directive|include
file|"coff/internal.h"
end_include

begin_include
include|#
directive|include
file|"coff/ecoff.h"
end_include

begin_include
include|#
directive|include
file|"libcoff.h"
end_include

begin_comment
comment|/* Private BFD COFF information.  */
end_comment

begin_include
include|#
directive|include
file|"libecoff.h"
end_include

begin_comment
comment|/* Private BFD ECOFF information.  */
end_comment

begin_include
include|#
directive|include
file|"elf/common.h"
end_include

begin_include
include|#
directive|include
file|"elf/mips.h"
end_include

begin_decl_stmt
specifier|static
name|void
name|mipscoff_new_init
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mipscoff_symfile_init
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mipscoff_symfile_read
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|,
expr|struct
name|section_offsets
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|mipscoff_symfile_finish
name|PARAMS
argument_list|(
operator|(
expr|struct
name|objfile
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|read_alphacoff_dynamic_symtab
name|PARAMS
argument_list|(
operator|(
expr|struct
name|section_offsets
operator|*
operator|,
expr|struct
name|objfile
operator|*
name|objfile
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Initialize anything that needs initializing when a completely new    symbol file is specified (not just adding some symbols from another    file, e.g. a shared library).  */
end_comment

begin_decl_stmt
specifier|extern
name|CORE_ADDR
name|sigtramp_address
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|mipscoff_new_init
parameter_list|(
name|ignore
parameter_list|)
name|struct
name|objfile
modifier|*
name|ignore
decl_stmt|;
block|{
name|sigtramp_address
operator|=
literal|0
expr_stmt|;
name|stabsread_new_init
argument_list|()
expr_stmt|;
name|buildsym_new_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize to read a symbol file (nothing to do).  */
end_comment

begin_function
specifier|static
name|void
name|mipscoff_symfile_init
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{ }
end_function

begin_comment
comment|/* Read a symbol file from a file.  */
end_comment

begin_function
specifier|static
name|void
name|mipscoff_symfile_read
parameter_list|(
name|objfile
parameter_list|,
name|section_offsets
parameter_list|,
name|mainline
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|int
name|mainline
decl_stmt|;
block|{
name|bfd
modifier|*
name|abfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
name|struct
name|cleanup
modifier|*
name|back_to
decl_stmt|;
name|init_minimal_symbol_collection
argument_list|()
expr_stmt|;
name|back_to
operator|=
name|make_cleanup
argument_list|(
operator|(
name|make_cleanup_func
operator|)
name|discard_minimal_symbols
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now that the executable file is positioned at symbol table,      process it and define symbols accordingly.  */
if|if
condition|(
operator|!
operator|(
operator|(
operator|*
name|ecoff_backend
argument_list|(
name|abfd
argument_list|)
operator|->
name|debug_swap
operator|.
name|read_debug_info
operator|)
operator|(
name|abfd
operator|,
operator|(
name|asection
operator|*
operator|)
name|NULL
operator|,
operator|&
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|debug_info
operator|)
operator|)
condition|)
name|error
argument_list|(
literal|"Error reading symbol table: %s"
argument_list|,
name|bfd_errmsg
argument_list|(
name|bfd_get_error
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|mdebug_build_psymtabs
argument_list|(
name|objfile
argument_list|,
operator|&
name|ecoff_backend
argument_list|(
name|abfd
argument_list|)
operator|->
name|debug_swap
argument_list|,
operator|&
name|ecoff_data
argument_list|(
name|abfd
argument_list|)
operator|->
name|debug_info
argument_list|,
name|section_offsets
argument_list|)
expr_stmt|;
comment|/* Add alpha coff dynamic symbols.  */
name|read_alphacoff_dynamic_symtab
argument_list|(
name|section_offsets
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
comment|/* Install any minimal symbols that have been collected as the current      minimal symbols for this objfile. */
name|install_minimal_symbols
argument_list|(
name|objfile
argument_list|)
expr_stmt|;
comment|/* If the entry_file bounds are still unknown after processing the      partial symbols, then try to set them from the minimal symbols      surrounding the entry_point.  */
if|if
condition|(
name|mainline
operator|&&
name|objfile
operator|->
name|ei
operator|.
name|entry_point
operator|!=
name|INVALID_ENTRY_POINT
operator|&&
name|objfile
operator|->
name|ei
operator|.
name|entry_file_lowpc
operator|==
name|INVALID_ENTRY_LOWPC
condition|)
block|{
name|struct
name|minimal_symbol
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|lookup_minimal_symbol_by_pc
argument_list|(
name|objfile
operator|->
name|ei
operator|.
name|entry_point
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|&&
name|SYMBOL_NAME
argument_list|(
name|m
operator|+
literal|1
argument_list|)
condition|)
block|{
name|objfile
operator|->
name|ei
operator|.
name|entry_file_lowpc
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|objfile
operator|->
name|ei
operator|.
name|entry_file_highpc
operator|=
name|SYMBOL_VALUE_ADDRESS
argument_list|(
name|m
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|do_cleanups
argument_list|(
name|back_to
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Perform any local cleanups required when we are done with a    particular objfile.  */
end_comment

begin_function
specifier|static
name|void
name|mipscoff_symfile_finish
parameter_list|(
name|objfile
parameter_list|)
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{ }
end_function

begin_comment
comment|/* Alpha OSF/1 encapsulates the dynamic symbols in ELF format in a    standard coff section.  The ELF format for the symbols differs from    the format defined in elf/external.h. It seems that a normal ELF 32 bit    format is used, and the representation only changes because longs are    64 bit on the alpha. In addition, the handling of text/data section    indices for symbols is different from the ELF ABI.    As the BFD linker currently does not support dynamic linking on the alpha,    there seems to be no reason to pollute BFD with another mixture of object    file formats for now.  */
end_comment

begin_comment
comment|/* Format of an alpha external ELF symbol.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|char
name|st_name
index|[
literal|4
index|]
decl_stmt|;
comment|/* Symbol name, index in string tbl */
name|unsigned
name|char
name|st_pad
index|[
literal|4
index|]
decl_stmt|;
comment|/* Pad to long word boundary */
name|unsigned
name|char
name|st_value
index|[
literal|8
index|]
decl_stmt|;
comment|/* Value of the symbol */
name|unsigned
name|char
name|st_size
index|[
literal|4
index|]
decl_stmt|;
comment|/* Associated symbol size */
name|unsigned
name|char
name|st_info
index|[
literal|1
index|]
decl_stmt|;
comment|/* Type and binding attributes */
name|unsigned
name|char
name|st_other
index|[
literal|1
index|]
decl_stmt|;
comment|/* No defined meaning, 0 */
name|unsigned
name|char
name|st_shndx
index|[
literal|2
index|]
decl_stmt|;
comment|/* Associated section index */
block|}
name|Elfalpha_External_Sym
typedef|;
end_typedef

begin_comment
comment|/* Format of an alpha external ELF dynamic info structure.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|char
name|d_tag
index|[
literal|4
index|]
decl_stmt|;
comment|/* Tag */
name|unsigned
name|char
name|d_pad
index|[
literal|4
index|]
decl_stmt|;
comment|/* Pad to long word boundary */
union|union
block|{
name|unsigned
name|char
name|d_ptr
index|[
literal|8
index|]
decl_stmt|;
comment|/* Pointer value */
name|unsigned
name|char
name|d_val
index|[
literal|4
index|]
decl_stmt|;
comment|/* Integer value */
block|}
name|d_un
union|;
block|}
name|Elfalpha_External_Dyn
typedef|;
end_typedef

begin_comment
comment|/* Struct to obtain the section pointers for alpha dynamic symbol info.  */
end_comment

begin_struct
struct|struct
name|alphacoff_dynsecinfo
block|{
name|asection
modifier|*
name|sym_sect
decl_stmt|;
comment|/* Section pointer for .dynsym section */
name|asection
modifier|*
name|str_sect
decl_stmt|;
comment|/* Section pointer for .dynstr section */
name|asection
modifier|*
name|dyninfo_sect
decl_stmt|;
comment|/* Section pointer for .dynamic section */
name|asection
modifier|*
name|got_sect
decl_stmt|;
comment|/* Section pointer for .got section */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|alphacoff_locate_sections
name|PARAMS
argument_list|(
operator|(
name|bfd
operator|*
operator|,
name|asection
operator|*
operator|,
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We are called once per section from read_alphacoff_dynamic_symtab.    We need to examine each section we are passed, check to see    if it is something we are interested in processing, and    if so, stash away some access information for the section.  */
end_comment

begin_function
specifier|static
name|void
name|alphacoff_locate_sections
parameter_list|(
name|ignore_abfd
parameter_list|,
name|sectp
parameter_list|,
name|sip
parameter_list|)
name|bfd
modifier|*
name|ignore_abfd
decl_stmt|;
name|asection
modifier|*
name|sectp
decl_stmt|;
name|PTR
name|sip
decl_stmt|;
block|{
specifier|register
name|struct
name|alphacoff_dynsecinfo
modifier|*
name|si
decl_stmt|;
name|si
operator|=
operator|(
expr|struct
name|alphacoff_dynsecinfo
operator|*
operator|)
name|sip
expr_stmt|;
if|if
condition|(
name|STREQ
argument_list|(
name|sectp
operator|->
name|name
argument_list|,
literal|".dynsym"
argument_list|)
condition|)
block|{
name|si
operator|->
name|sym_sect
operator|=
name|sectp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|sectp
operator|->
name|name
argument_list|,
literal|".dynstr"
argument_list|)
condition|)
block|{
name|si
operator|->
name|str_sect
operator|=
name|sectp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|sectp
operator|->
name|name
argument_list|,
literal|".dynamic"
argument_list|)
condition|)
block|{
name|si
operator|->
name|dyninfo_sect
operator|=
name|sectp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|STREQ
argument_list|(
name|sectp
operator|->
name|name
argument_list|,
literal|".got"
argument_list|)
condition|)
block|{
name|si
operator|->
name|got_sect
operator|=
name|sectp
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Scan an alpha dynamic symbol table for symbols of interest and    add them to the minimal symbol table.  */
end_comment

begin_function
specifier|static
name|void
name|read_alphacoff_dynamic_symtab
parameter_list|(
name|section_offsets
parameter_list|,
name|objfile
parameter_list|)
name|struct
name|section_offsets
modifier|*
name|section_offsets
decl_stmt|;
name|struct
name|objfile
modifier|*
name|objfile
decl_stmt|;
block|{
name|bfd
modifier|*
name|abfd
init|=
name|objfile
operator|->
name|obfd
decl_stmt|;
name|struct
name|alphacoff_dynsecinfo
name|si
decl_stmt|;
name|char
modifier|*
name|sym_secptr
decl_stmt|;
name|char
modifier|*
name|str_secptr
decl_stmt|;
name|char
modifier|*
name|dyninfo_secptr
decl_stmt|;
name|char
modifier|*
name|got_secptr
decl_stmt|;
name|bfd_size_type
name|sym_secsize
decl_stmt|;
name|bfd_size_type
name|str_secsize
decl_stmt|;
name|bfd_size_type
name|dyninfo_secsize
decl_stmt|;
name|bfd_size_type
name|got_secsize
decl_stmt|;
name|int
name|sym_count
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|stripped
decl_stmt|;
name|Elfalpha_External_Sym
modifier|*
name|x_symp
decl_stmt|;
name|char
modifier|*
name|dyninfo_p
decl_stmt|;
name|char
modifier|*
name|dyninfo_end
decl_stmt|;
name|int
name|got_entry_size
init|=
literal|8
decl_stmt|;
name|int
name|dt_mips_local_gotno
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|dt_mips_gotsym
init|=
operator|-
literal|1
decl_stmt|;
comment|/* We currently only know how to handle alpha dynamic symbols.  */
if|if
condition|(
name|bfd_get_arch
argument_list|(
name|abfd
argument_list|)
operator|!=
name|bfd_arch_alpha
condition|)
return|return;
comment|/* Locate the dynamic symbols sections and read them in.  */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|si
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
name|bfd_map_over_sections
argument_list|(
name|abfd
argument_list|,
name|alphacoff_locate_sections
argument_list|,
operator|(
name|PTR
operator|)
operator|&
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
name|si
operator|.
name|sym_sect
operator|==
name|NULL
operator|||
name|si
operator|.
name|str_sect
operator|==
name|NULL
operator|||
name|si
operator|.
name|dyninfo_sect
operator|==
name|NULL
operator|||
name|si
operator|.
name|got_sect
operator|==
name|NULL
condition|)
return|return;
name|sym_secsize
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|si
operator|.
name|sym_sect
argument_list|)
expr_stmt|;
name|str_secsize
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|si
operator|.
name|str_sect
argument_list|)
expr_stmt|;
name|dyninfo_secsize
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|si
operator|.
name|dyninfo_sect
argument_list|)
expr_stmt|;
name|got_secsize
operator|=
name|bfd_get_section_size_before_reloc
argument_list|(
name|si
operator|.
name|got_sect
argument_list|)
expr_stmt|;
name|sym_secptr
operator|=
name|alloca
argument_list|(
name|sym_secsize
argument_list|)
expr_stmt|;
name|str_secptr
operator|=
name|alloca
argument_list|(
name|str_secsize
argument_list|)
expr_stmt|;
name|dyninfo_secptr
operator|=
name|alloca
argument_list|(
name|dyninfo_secsize
argument_list|)
expr_stmt|;
name|got_secptr
operator|=
name|alloca
argument_list|(
name|got_secsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|si
operator|.
name|sym_sect
argument_list|,
name|sym_secptr
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|sym_secsize
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|si
operator|.
name|str_sect
argument_list|,
name|str_secptr
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|str_secsize
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|si
operator|.
name|dyninfo_sect
argument_list|,
name|dyninfo_secptr
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|dyninfo_secsize
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|!
name|bfd_get_section_contents
argument_list|(
name|abfd
argument_list|,
name|si
operator|.
name|got_sect
argument_list|,
name|got_secptr
argument_list|,
operator|(
name|file_ptr
operator|)
literal|0
argument_list|,
name|got_secsize
argument_list|)
condition|)
return|return;
comment|/* Find the number of local GOT entries and the index for the      the first dynamic symbol in the GOT. */
for|for
control|(
name|dyninfo_p
operator|=
name|dyninfo_secptr
operator|,
name|dyninfo_end
operator|=
name|dyninfo_p
operator|+
name|dyninfo_secsize
init|;
name|dyninfo_p
operator|<
name|dyninfo_end
condition|;
name|dyninfo_p
operator|+=
sizeof|sizeof
argument_list|(
name|Elfalpha_External_Dyn
argument_list|)
control|)
block|{
name|Elfalpha_External_Dyn
modifier|*
name|x_dynp
init|=
operator|(
name|Elfalpha_External_Dyn
operator|*
operator|)
name|dyninfo_p
decl_stmt|;
name|long
name|dyn_tag
decl_stmt|;
name|dyn_tag
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|x_dynp
operator|->
name|d_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|dyn_tag
operator|==
name|DT_NULL
condition|)
break|break;
elseif|else
if|if
condition|(
name|dyn_tag
operator|==
name|DT_MIPS_LOCAL_GOTNO
condition|)
block|{
if|if
condition|(
name|dt_mips_local_gotno
operator|<
literal|0
condition|)
name|dt_mips_local_gotno
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|x_dynp
operator|->
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dyn_tag
operator|==
name|DT_MIPS_GOTSYM
condition|)
block|{
if|if
condition|(
name|dt_mips_gotsym
operator|<
literal|0
condition|)
name|dt_mips_gotsym
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|x_dynp
operator|->
name|d_un
operator|.
name|d_val
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dt_mips_local_gotno
operator|<
literal|0
operator|||
name|dt_mips_gotsym
operator|<
literal|0
condition|)
return|return;
comment|/* Scan all dynamic symbols and enter them into the minimal symbol table      if appropriate.  */
name|sym_count
operator|=
name|sym_secsize
operator|/
sizeof|sizeof
argument_list|(
name|Elfalpha_External_Sym
argument_list|)
expr_stmt|;
name|stripped
operator|=
operator|(
name|bfd_get_symcount
argument_list|(
name|abfd
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
comment|/* Skip first symbol, which is a null dummy.  */
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|x_symp
operator|=
operator|(
name|Elfalpha_External_Sym
operator|*
operator|)
name|sym_secptr
operator|+
literal|1
init|;
name|i
operator|<
name|sym_count
condition|;
name|i
operator|++
operator|,
name|x_symp
operator|++
control|)
block|{
name|unsigned
name|long
name|strx
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|bfd_vma
name|sym_value
decl_stmt|;
name|unsigned
name|char
name|sym_info
decl_stmt|;
name|unsigned
name|int
name|sym_shndx
decl_stmt|;
name|int
name|isglobal
decl_stmt|;
name|enum
name|minimal_symbol_type
name|ms_type
decl_stmt|;
name|strx
operator|=
name|bfd_h_get_32
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|x_symp
operator|->
name|st_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|strx
operator|>=
name|str_secsize
condition|)
continue|continue;
name|name
operator|=
name|str_secptr
operator|+
name|strx
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
operator|||
operator|*
name|name
operator|==
literal|'.'
condition|)
continue|continue;
name|sym_value
operator|=
name|bfd_h_get_64
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|x_symp
operator|->
name|st_value
argument_list|)
expr_stmt|;
name|sym_info
operator|=
name|bfd_h_get_8
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|x_symp
operator|->
name|st_info
argument_list|)
expr_stmt|;
name|sym_shndx
operator|=
name|bfd_h_get_16
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
name|x_symp
operator|->
name|st_shndx
argument_list|)
expr_stmt|;
name|isglobal
operator|=
operator|(
name|ELF_ST_BIND
argument_list|(
name|sym_info
argument_list|)
operator|==
name|STB_GLOBAL
operator|)
expr_stmt|;
if|if
condition|(
name|sym_shndx
operator|==
name|SHN_UNDEF
condition|)
block|{
comment|/* Handle undefined functions which are defined in a shared 	     library.  */
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|sym_info
argument_list|)
operator|!=
name|STT_FUNC
operator|||
name|ELF_ST_BIND
argument_list|(
name|sym_info
argument_list|)
operator|!=
name|STB_GLOBAL
condition|)
continue|continue;
name|ms_type
operator|=
name|mst_solib_trampoline
expr_stmt|;
comment|/* If sym_value is nonzero, it points to the shared library 	     trampoline entry, which is what we are looking for.  	     If sym_value is zero, then we have to get the GOT entry 	     for the symbol. 	     If the GOT entry is nonzero, it represents the quickstart 	     address of the function and we use that as the symbol value.  	     If the GOT entry is zero, the function address has to be resolved 	     by the runtime loader before the executable is started. 	     We are unable to find any meaningful address for these 	     functions in the executable file, so we skip them.  */
if|if
condition|(
name|sym_value
operator|==
literal|0
condition|)
block|{
name|int
name|got_entry_offset
init|=
operator|(
name|i
operator|-
name|dt_mips_gotsym
operator|+
name|dt_mips_local_gotno
operator|)
operator|*
name|got_entry_size
decl_stmt|;
if|if
condition|(
name|got_entry_offset
operator|<
literal|0
operator|||
name|got_entry_offset
operator|>=
name|got_secsize
condition|)
continue|continue;
name|sym_value
operator|=
name|bfd_h_get_64
argument_list|(
name|abfd
argument_list|,
operator|(
name|bfd_byte
operator|*
operator|)
operator|(
name|got_secptr
operator|+
name|got_entry_offset
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym_value
operator|==
literal|0
condition|)
continue|continue;
block|}
block|}
else|else
block|{
comment|/* Symbols defined in the executable itself. We only care about 	     them if this is a stripped executable, otherwise they have 	     been retrieved from the normal symbol table already.  */
if|if
condition|(
operator|!
name|stripped
condition|)
continue|continue;
if|if
condition|(
name|sym_shndx
operator|==
name|SHN_MIPS_TEXT
condition|)
block|{
if|if
condition|(
name|isglobal
condition|)
name|ms_type
operator|=
name|mst_text
expr_stmt|;
else|else
name|ms_type
operator|=
name|mst_file_text
expr_stmt|;
name|sym_value
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_TEXT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sym_shndx
operator|==
name|SHN_MIPS_DATA
condition|)
block|{
if|if
condition|(
name|isglobal
condition|)
name|ms_type
operator|=
name|mst_data
expr_stmt|;
else|else
name|ms_type
operator|=
name|mst_file_data
expr_stmt|;
name|sym_value
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_DATA
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sym_shndx
operator|==
name|SHN_MIPS_ACOMMON
condition|)
block|{
if|if
condition|(
name|isglobal
condition|)
name|ms_type
operator|=
name|mst_bss
expr_stmt|;
else|else
name|ms_type
operator|=
name|mst_file_bss
expr_stmt|;
name|sym_value
operator|+=
name|ANOFFSET
argument_list|(
name|section_offsets
argument_list|,
name|SECT_OFF_BSS
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sym_shndx
operator|==
name|SHN_ABS
condition|)
block|{
name|ms_type
operator|=
name|mst_abs
expr_stmt|;
block|}
else|else
block|{
continue|continue;
block|}
block|}
name|prim_record_minimal_symbol
argument_list|(
name|name
argument_list|,
name|sym_value
argument_list|,
name|ms_type
argument_list|,
name|objfile
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initialization */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sym_fns
name|ecoff_sym_fns
init|=
block|{
name|bfd_target_ecoff_flavour
block|,
name|mipscoff_new_init
block|,
comment|/* sym_new_init: init anything gbl to entire symtab */
name|mipscoff_symfile_init
block|,
comment|/* sym_init: read initial info, setup for sym_read() */
name|mipscoff_symfile_read
block|,
comment|/* sym_read: read a symbol file into symtab */
name|mipscoff_symfile_finish
block|,
comment|/* sym_finish: finished with file, cleanup */
name|default_symfile_offsets
block|,
comment|/* sym_offsets: dummy FIXME til implem sym reloc */
name|NULL
comment|/* next: pointer to next struct sym_fns */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_mipsread
parameter_list|()
block|{
name|add_symtab_fns
argument_list|(
operator|&
name|ecoff_sym_fns
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

